2025-10-17 21:45:45.947 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 21:45:55.351 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=965, output_tokens=13, cost=0.010040
2025-10-17 21:46:04.822 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1145, output_tokens=453, cost=0.025040
2025-10-17 21:46:06.381 | INFO     | registered non reproducing test 0
2025-10-17 21:46:17.770 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1880, output_tokens=564, cost=0.035720
2025-10-17 21:46:19.020 | INFO     | registered non reproducing test 1
2025-10-17 21:46:32.401 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1997, output_tokens=559, cost=0.036740
2025-10-17 21:46:33.644 | INFO     | registered non reproducing test 2
2025-10-17 21:46:33.644 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 21:46:33.650 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 21:46:42.819 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1199, output_tokens=386, cost=0.023570
2025-10-17 21:46:42.826 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 21:46:46.012 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=740, output_tokens=64, cost=0.009320
2025-10-17 21:46:46.014 | DEBUG    | Extracted a valid json.
2025-10-17 21:46:46.014 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"_print_Pow\", \"LatexPrinter\")",
        "search_method_in_class(\"_print_LambertW\", \"LatexPrinter\")",
        "search_class(\"LatexPrinter\")"
    ],
    "bug_locations": []
}
2025-10-17 21:46:46.103 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 21:46:46.104 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 21:47:06.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6241, output_tokens=838, cost=0.087550
2025-10-17 21:47:06.859 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 21:47:18.796 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7295, output_tokens=443, cost=0.086240
2025-10-17 21:47:18.805 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 21:47:28.944 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=797, output_tokens=397, cost=0.019880
2025-10-17 21:47:28.945 | DEBUG    | Extracted a valid json.
2025-10-17 21:47:28.945 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Pow",
            "intended_behavior": "The `_print_Pow` method should be adapted to handle function bases that do not accept an `exp` keyword argument. Specifically, for the `LambertW` function, the method should avoid passing the `exp` argument directly and instead implement a way to correctly format the power operation in LaTeX. One approach could be checking if the base is an instance of `LambertW` (or any other function with similar constraints) and then handle the exponent separately in a manner that aligns with LaTeX standards without violating the method signatures of specific print functions like `_print_LambertW`. This preserves the existing functionality for other functions and cases while providing a tailored handling for `LambertW` and potentially similar future cases."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_LambertW",
            "intended_behavior": "Although the `_print_LambertW` method is not directly at fault based on the existing implementation, considering a future-proofing approach, it may be beneficial to allow this method (and similarly implemented methods for other functions) to optionally handle an `exp` argument. This would not change the method's current handling but would add an optional pathway for dealing with exponentiation directly within the function's LaTeX representation. This adaptation would require a fallback or default behavior that ensures compatibility with the current usage while enabling new functionality where necessary. This method could, for example, provide a basic LaTeX exponentiation wrapping around its current output if `exp` is provided and is not trivial (e.g., an exponent of 1)."
        }
    ]
}
2025-10-17 21:47:28.965 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Pow</method>
<code>
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)

</code><intended_behavior>The `_print_Pow` method should be adapted to handle function bases that do not accept an `exp` keyword argument. Specifically, for the `LambertW` function, the method should avoid passing the `exp` argument directly and instead implement a way to correctly format the power operation in LaTeX. One approach could be checking if the base is an instance of `LambertW` (or any other function with similar constraints) and then handle the exponent separately in a manner that aligns with LaTeX standards without violating the method signatures of specific print functions like `_print_LambertW`. This preserves the existing functionality for other functions and cases while providing a tailored handling for `LambertW` and potentially similar future cases.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_Exp1(self, expr, exp=None):
1113         return "e"
1114 
1115     def _print_elliptic_k(self, expr, exp=None):
1116         tex = r"\left(%s\right)" % self._print(expr.args[0])
1117         if exp is not None:
1118             return r"K^{%s}%s" % (exp, tex)
1119         else:
1120             return r"K%s" % tex
1121 
1122     def _print_elliptic_f(self, expr, exp=None):
1123         tex = r"\left(%s\middle| %s\right)" % \
1124             (self._print(expr.args[0]), self._print(expr.args[1]))
1125         if exp is not None:
1126             return r"F^{%s}%s" % (exp, tex)
1127         else:
1128             return r"F%s" % tex
1129 
1130     def _print_elliptic_e(self, expr, exp=None):
1131         if len(expr.args) == 2:
1132             tex = r"\left(%s\middle| %s\right)" % \
1133                 (self._print(expr.args[0]), self._print(expr.args[1]))
1134         else:
1135             tex = r"\left(%s\right)" % self._print(expr.args[0])
1136         if exp is not None:
1137             return r"E^{%s}%s" % (exp, tex)
1138         else:
1139             return r"E%s" % tex
1140 
1141     def _print_elliptic_pi(self, expr, exp=None):
1142         if len(expr.args) == 3:
1143             tex = r"\left(%s; %s\middle| %s\right)" % \
1144                 (self._print(expr.args[0]), self._print(expr.args[1]),
1145                  self._print(expr.args[2]))
1146         else:
1147             tex = r"\left(%s\middle| %s\right)" % \
1148                 (self._print(expr.args[0]), self._print(expr.args[1]))
1149         if exp is not None:
1150             return r"\Pi^{%s}%s" % (exp, tex)
1151         else:
1152             return r"\Pi%s" % tex
1153 
1154     def _print_beta(self, expr, exp=None):
1155         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1156                                         self._print(expr.args[1]))
1157 
1158         if exp is not None:
1159             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1160         else:
1161             return r"\operatorname{B}%s" % tex
1162 
1163     def _print_betainc(self, expr, exp=None, operator='B'):
1164         largs = [self._print(arg) for arg in expr.args]
1165         tex = r"\left(%s, %s\right)" % (largs[0], largs[1])
1166 
1167         if exp is not None:
1168             return r"\operatorname{%s}_{(%s, %s)}^{%s}%s" % (operator, largs[2], largs[3], exp, tex)
1169         else:
1170             return r"\operatorname{%s}_{(%s, %s)}%s" % (operator, largs[2], largs[3], tex)
1171 
1172     def _print_betainc_regularized(self, expr, exp=None):
1173         return self._print_betainc(expr, exp, operator='I')
1174 
1175     def _print_uppergamma(self, expr, exp=None):
1176         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1177                                         self._print(expr.args[1]))
1178 
1179         if exp is not None:
1180             return r"\Gamma^{%s}%s" % (exp, tex)
1181         else:
1182             return r"\Gamma%s" % tex
1183 
1184     def _print_lowergamma(self, expr, exp=None):
1185         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1186                                         self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"\gamma^{%s}%s" % (exp, tex)
1190         else:
1191             return r"\gamma%s" % tex
1192 
1193     def _hprint_one_arg_func(self, expr, exp=None):
1194         tex = r"\left(%s\right)" % self._print(expr.args[0])
1195 
1196         if exp is not None:
1197             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1198         else:
1199             return r"%s%s" % (self._print(expr.func), tex)
1200 
1201     _print_gamma = _hprint_one_arg_func
1202 
1203     def _print_Chi(self, expr, exp=None):
1204         tex = r"\left(%s\right)" % self._print(expr.args[0])
1205 
1206         if exp is not None:
1207             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1208         else:
1209             return r"\operatorname{Chi}%s" % tex
1210 
1211     def _print_expint(self, expr, exp=None):
1212         tex = r"\left(%s\right)" % self._print(expr.args[1])
1213         nu = self._print(expr.args[0])
1214 
1215         if exp is not None:
1216             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1217         else:
1218             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1219 
1220     def _print_fresnels(self, expr, exp=None):
1221         tex = r"\left(%s\right)" % self._print(expr.args[0])
1222 
1223         if exp is not None:
1224             return r"S^{%s}%s" % (exp, tex)
1225         else:
1226             return r"S%s" % tex
1227 
1228     def _print_fresnelc(self, expr, exp=None):
1229         tex = r"\left(%s\right)" % self._print(expr.args[0])
1230 
1231         if exp is not None:
1232             return r"C^{%s}%s" % (exp, tex)
1233         else:
1234             return r"C%s" % tex
1235 
1236     def _print_subfactorial(self, expr, exp=None):
1237         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1238 
1239         if exp is not None:
1240             return r"\left(%s\right)^{%s}" % (tex, exp)
1241         else:
1242             return tex
1243 
1244     def _print_factorial(self, expr, exp=None):
1245         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1246 
1247         if exp is not None:
1248             return r"%s^{%s}" % (tex, exp)
1249         else:
1250             return tex
1251 
1252     def _print_factorial2(self, expr, exp=None):
1253         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1254 
1255         if exp is not None:
1256             return r"%s^{%s}" % (tex, exp)
1257         else:
1258             return tex
1259 
1260     def _print_binomial(self, expr, exp=None):
1261         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1262                                      self._print(expr.args[1]))
1263 
1264         if exp is not None:
1265             return r"%s^{%s}" % (tex, exp)
1266         else:
1267             return tex
1268 
1269     def _print_RisingFactorial(self, expr, exp=None):
1270         n, k = expr.args
1271         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1272 
1273         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1274 
1275         return self._do_exponent(tex, exp)
1276 
1277     def _print_FallingFactorial(self, expr, exp=None):
1278         n, k = expr.args
1279         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1280 
1281         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1282 
1283         return self._do_exponent(tex, exp)
1284 
1285     def _hprint_BesselBase(self, expr, exp, sym):
1286         tex = r"%s" % (sym)
1287 
1288         need_exp = False
1289         if exp is not None:
1290             if tex.find('^') == -1:
1291                 tex = r"%s^{%s}" % (tex, exp)
1292             else:
1293                 need_exp = True
1294 
1295         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1296                                            self._print(expr.argument))
1297 
1298         if need_exp:
1299             tex = self._do_exponent(tex, exp)
1300         return tex
1301 
1302     def _hprint_vec(self, vec):
1303         if not vec:
1304             return ""
1305         s = ""
1306         for i in vec[:-1]:
1307             s += "%s, " % self._print(i)
1308         s += self._print(vec[-1])
1309         return s
1310 
1311     def _print_besselj(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'J')
1313 
1314     def _print_besseli(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'I')
1316 
1317     def _print_besselk(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'K')
1319 
1320     def _print_bessely(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'Y')
1322 
1323     def _print_yn(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'y')
1325 
1326     def _print_jn(self, expr, exp=None):
1327         return self._hprint_BesselBase(expr, exp, 'j')
1328 
1329     def _print_hankel1(self, expr, exp=None):
1330         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1331 
1332     def _print_hankel2(self, expr, exp=None):
1333         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1334 
1335     def _print_hn1(self, expr, exp=None):
1336         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1337 
1338     def _print_hn2(self, expr, exp=None):
1339         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1340 
1341     def _hprint_airy(self, expr, exp=None, notation=""):
1342         tex = r"\left(%s\right)" % self._print(expr.args[0])
1343 
1344         if exp is not None:
1345             return r"%s^{%s}%s" % (notation, exp, tex)
1346         else:
1347             return r"%s%s" % (notation, tex)
1348 
1349     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1350         tex = r"\left(%s\right)" % self._print(expr.args[0])
1351 
1352         if exp is not None:
1353             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1354         else:
1355             return r"%s^\prime%s" % (notation, tex)
1356 
1357     def _print_airyai(self, expr, exp=None):
1358         return self._hprint_airy(expr, exp, 'Ai')
1359 
1360     def _print_airybi(self, expr, exp=None):
1361         return self._hprint_airy(expr, exp, 'Bi')
1362 
1363     def _print_airyaiprime(self, expr, exp=None):
1364         return self._hprint_airy_prime(expr, exp, 'Ai')
1365 
1366     def _print_airybiprime(self, expr, exp=None):
1367         return self._hprint_airy_prime(expr, exp, 'Bi')
1368 
1369     def _print_hyper(self, expr, exp=None):
1370         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1371               r"\middle| {%s} \right)}" % \
1372             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1373               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1374               self._print(expr.argument))
1375 
1376         if exp is not None:
1377             tex = r"{%s}^{%s}" % (tex, exp)
1378         return tex
1379 
1380     def _print_meijerg(self, expr, exp=None):
1381         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1382               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1383             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1384               self._print(len(expr.bm)), self._print(len(expr.an)),
1385               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1386               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1387               self._print(expr.argument))
1388 
1389         if exp is not None:
1390             tex = r"{%s}^{%s}" % (tex, exp)
1391         return tex
1392 
1393     def _print_dirichlet_eta(self, expr, exp=None):
1394         tex = r"\left(%s\right)" % self._print(expr.args[0])
1395         if exp is not None:
1396             return r"\eta^{%s}%s" % (exp, tex)
1397         return r"\eta%s" % tex
1398 
1399     def _print_zeta(self, expr, exp=None):
1400         if len(expr.args) == 2:
1401             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1402         else:
1403             tex = r"\left(%s\right)" % self._print(expr.args[0])
1404         if exp is not None:
1405             return r"\zeta^{%s}%s" % (exp, tex)
1406         return r"\zeta%s" % tex
1407 
1408     def _print_stieltjes(self, expr, exp=None):
1409         if len(expr.args) == 2:
1410             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1411         else:
1412             tex = r"_{%s}" % self._print(expr.args[0])
1413         if exp is not None:
1414             return r"\gamma%s^{%s}" % (tex, exp)
1415         return r"\gamma%s" % tex
1416 
1417     def _print_lerchphi(self, expr, exp=None):
1418         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1419         if exp is None:
1420             return r"\Phi%s" % tex
1421         return r"\Phi^{%s}%s" % (exp, tex)
1422 
1423     def _print_polylog(self, expr, exp=None):
1424         s, z = map(self._print, expr.args)
1425         tex = r"\left(%s\right)" % z
1426         if exp is None:
1427             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1428         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1429 
1430     def _print_jacobi(self, expr, exp=None):
1431         n, a, b, x = map(self._print, expr.args)
1432         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1433         if exp is not None:
1434             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1435         return tex
1436 
1437     def _print_gegenbauer(self, expr, exp=None):
1438         n, a, x = map(self._print, expr.args)
1439         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1440         if exp is not None:
1441             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1442         return tex
1443 
1444     def _print_chebyshevt(self, expr, exp=None):
1445         n, x = map(self._print, expr.args)
1446         tex = r"T_{%s}\left(%s\right)" % (n, x)
1447         if exp is not None:
1448             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1449         return tex
1450 
1451     def _print_chebyshevu(self, expr, exp=None):
1452         n, x = map(self._print, expr.args)
1453         tex = r"U_{%s}\left(%s\right)" % (n, x)
1454         if exp is not None:
1455             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1456         return tex
1457 
1458     def _print_legendre(self, expr, exp=None):
1459         n, x = map(self._print, expr.args)
1460         tex = r"P_{%s}\left(%s\right)" % (n, x)
1461         if exp is not None:
1462             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1463         return tex
1464 
1465     def _print_assoc_legendre(self, expr, exp=None):
1466         n, a, x = map(self._print, expr.args)
1467         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1468         if exp is not None:
1469             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1470         return tex
1471 
1472     def _print_hermite(self, expr, exp=None):
1473         n, x = map(self._print, expr.args)
1474         tex = r"H_{%s}\left(%s\right)" % (n, x)
1475         if exp is not None:
1476             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1477         return tex
1478 
1479     def _print_laguerre(self, expr, exp=None):
1480         n, x = map(self._print, expr.args)
1481         tex = r"L_{%s}\left(%s\right)" % (n, x)
1482         if exp is not None:
1483             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1484         return tex
1485 
1486     def _print_assoc_laguerre(self, expr, exp=None):
1487         n, a, x = map(self._print, expr.args)
1488         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1489         if exp is not None:
1490             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1491         return tex
1492 
1493     def _print_Ynm(self, expr, exp=None):
1494         n, m, theta, phi = map(self._print, expr.args)
1495         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1496         if exp is not None:
1497             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1498         return tex
1499 
1500     def _print_Znm(self, expr, exp=None):
1501         n, m, theta, phi = map(self._print, expr.args)
1502         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1503         if exp is not None:
1504             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1505         return tex
1506 
1507     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1508         a, q, z = map(self._print, args)
1509         sup = r"^{\prime}" if prime else ""
1510         exp = "" if not exp else "^{%s}" % exp
1511         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1512 
1513     def _print_mathieuc(self, expr, exp=None):
1514         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1515 
1516     def _print_mathieus(self, expr, exp=None):
1517         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1518 
1519     def _print_mathieucprime(self, expr, exp=None):
1520         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1521 
1522     def _print_mathieusprime(self, expr, exp=None):
1523         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1524 
1525     def _print_Rational(self, expr):
1526         if expr.q != 1:
1527             sign = ""
1528             p = expr.p
1529             if expr.p < 0:
1530                 sign = "- "
1531                 p = -p
1532             if self._settings['fold_short_frac']:
1533                 return r"%s%d / %d" % (sign, p, expr.q)
1534             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1535         else:
1536             return self._print(expr.p)
1537 
1538     def _print_Order(self, expr):
1539         s = self._print(expr.expr)
1540         if expr.point and any(p != S.Zero for p in expr.point) or \
1541            len(expr.variables) > 1:
1542             s += '; '
1543             if len(expr.variables) > 1:
1544                 s += self._print(expr.variables)
1545             elif expr.variables:
1546                 s += self._print(expr.variables[0])
1547             s += r'\rightarrow '
1548             if len(expr.point) > 1:
1549                 s += self._print(expr.point)
1550             else:
1551                 s += self._print(expr.point[0])
1552         return r"O\left(%s\right)" % s
1553 
1554     def _print_Symbol(self, expr, style='plain'):
1555         if expr in self._settings['symbol_names']:
1556             return self._settings['symbol_names'][expr]
1557 
1558         return self._deal_with_super_sub(expr.name, style=style)
1559 
1560     _print_RandomSymbol = _print_Symbol
1561 
1562     def _deal_with_super_sub(self, string, style='plain'):
1563         if '{' in string:
1564             name, supers, subs = string, [], []
1565         else:
1566             name, supers, subs = split_super_sub(string)
1567 
1568             name = translate(name)
1569             supers = [translate(sup) for sup in supers]
1570             subs = [translate(sub) for sub in subs]
1571 
1572         # apply the style only to the name
1573         if style == 'bold':
1574             name = "\\mathbf{{{}}}".format(name)
1575 
1576         # glue all items together:
1577         if supers:
1578             name += "^{%s}" % " ".join(supers)
1579         if subs:
1580             name += "_{%s}" % " ".join(subs)
1581 
1582         return name
1583 
1584     def _print_Relational(self, expr):
1585         if self._settings['itex']:
1586             gt = r"\gt"
1587             lt = r"\lt"
1588         else:
1589             gt = ">"
1590             lt = "<"
1591 
1592         charmap = {
1593             "==": "=",
1594             ">": gt,
1595             "<": lt,
1596             ">=": r"\geq",
1597             "<=": r"\leq",
1598             "!=": r"\neq",
1599         }
1600 
1601         return "%s %s %s" % (self._print(expr.lhs),
1602                              charmap[expr.rel_op], self._print(expr.rhs))
1603 
1604     def _print_Piecewise(self, expr):
1605         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1606                    for e, c in expr.args[:-1]]
1607         if expr.args[-1].cond == true:
1608             ecpairs.append(r"%s & \text{otherwise}" %
1609                            self._print(expr.args[-1].expr))
1610         else:
1611             ecpairs.append(r"%s & \text{for}\: %s" %
1612                            (self._print(expr.args[-1].expr),
1613                             self._print(expr.args[-1].cond)))
1614         tex = r"\begin{cases} %s \end{cases}"
1615         return tex % r" \\".join(ecpairs)
1616 
1617     def _print_MatrixBase(self, expr):
1618         lines = []
1619 
1620         for line in range(expr.rows):  # horrible, should be 'rows'
1621             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1622 
1623         mat_str = self._settings['mat_str']
1624         if mat_str is None:
1625             if self._settings['mode'] == 'inline':
1626                 mat_str = 'smallmatrix'
1627             else:
1628                 if (expr.cols <= 10) is True:
1629                     mat_str = 'matrix'
1630                 else:
1631                     mat_str = 'array'
1632 
1633         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1634         out_str = out_str.replace('%MATSTR%', mat_str)
1635         if mat_str == 'array':
1636             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1637         if self._settings['mat_delim']:
1638             left_delim = self._settings['mat_delim']
1639             right_delim = self._delim_dict[left_delim]
1640             out_str = r'\left' + left_delim + out_str + \
1641                       r'\right' + right_delim
1642         return out_str % r"\\".join(lines)
1643 
1644     def _print_MatrixElement(self, expr):
1645         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1646             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1647 
1648     def _print_MatrixSlice(self, expr):
1649         def latexslice(x, dim):
1650             x = list(x)
1651             if x[2] == 1:
1652                 del x[2]
1653             if x[0] == 0:
1654                 x[0] = None
1655             if x[1] == dim:
1656                 x[1] = None
1657             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1658         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1659                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1660                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1661 
1662     def _print_BlockMatrix(self, expr):
1663         return self._print(expr.blocks)
1664 
1665     def _print_Transpose(self, expr):
1666         mat = expr.arg
1667         from sympy.matrices import MatrixSymbol
1668         if not isinstance(mat, MatrixSymbol):
1669             return r"\left(%s\right)^{T}" % self._print(mat)
1670         else:
1671             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1672 
1673     def _print_Trace(self, expr):
1674         mat = expr.arg
1675         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1676 
1677     def _print_Adjoint(self, expr):
1678         mat = expr.arg
1679         from sympy.matrices import MatrixSymbol
1680         if not isinstance(mat, MatrixSymbol):
1681             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1682         else:
1683             return r"%s^{\dagger}" % self._print(mat)
1684 
1685     def _print_MatMul(self, expr):
1686         from sympy import MatMul, Mul
1687 
1688         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1689                                              False)
1690 
1691         args = expr.args
1692         if isinstance(args[0], Mul):
1693             args = args[0].as_ordered_factors() + list(args[1:])
1694         else:
1695             args = list(args)
1696 
1697         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1698             if args[0] == -1:
1699                 args = args[1:]
1700             else:
1701                 args[0] = -args[0]
1702             return '- ' + ' '.join(map(parens, args))
1703         else:
1704             return ' '.join(map(parens, args))
1705 
1706     def _print_Mod(self, expr, exp=None):
1707         if exp is not None:
1708             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1709                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1710                                    strict=True), self._print(expr.args[1]),
1711                  exp)
1712         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1713                                  PRECEDENCE['Mul'], strict=True),
1714                                  self._print(expr.args[1]))
1715 
1716     def _print_HadamardProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \circ '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_HadamardPower(self, expr):
1725         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1726             template = r"%s^{\circ \left({%s}\right)}"
1727         else:
1728             template = r"%s^{\circ {%s}}"
1729         return self._helper_print_standard_power(expr, template)
1730 
1731     def _print_KroneckerProduct(self, expr):
1732         args = expr.args
1733         prec = PRECEDENCE['Pow']
1734         parens = self.parenthesize
1735 
1736         return r' \otimes '.join(
1737             map(lambda arg: parens(arg, prec, strict=True), args))
1738 
1739     def _print_MatPow(self, expr):
1740         base, exp = expr.base, expr.exp
1741         from sympy.matrices import MatrixSymbol
1742         if not isinstance(base, MatrixSymbol):
1743             return "\\left(%s\\right)^{%s}" % (self._print(base),
1744                                               self._print(exp))
1745         else:
1746             return "%s^{%s}" % (self._print(base), self._print(exp))
1747 
1748     def _print_MatrixSymbol(self, expr):
1749         return self._print_Symbol(expr, style=self._settings[
1750             'mat_symbol_style'])
1751 
1752     def _print_ZeroMatrix(self, Z):
1753         return r"\mathbb{0}" if self._settings[
1754             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1755 
1756     def _print_OneMatrix(self, O):
1757         return r"\mathbb{1}" if self._settings[
1758             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1759 
1760     def _print_Identity(self, I):
1761         return r"\mathbb{I}" if self._settings[
1762             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1763 
1764     def _print_PermutationMatrix(self, P):
1765         perm_str = self._print(P.args[0])
1766         return "P_{%s}" % perm_str
1767 
1768     def _print_NDimArray(self, expr):
1769 
1770         if expr.rank() == 0:
1771             return self._print(expr[()])
1772 
1773         mat_str = self._settings['mat_str']
1774         if mat_str is None:
1775             if self._settings['mode'] == 'inline':
1776                 mat_str = 'smallmatrix'
1777             else:
1778                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1779                     mat_str = 'matrix'
1780                 else:
1781                     mat_str = 'array'
1782         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1783         block_str = block_str.replace('%MATSTR%', mat_str)
1784         if self._settings['mat_delim']:
1785             left_delim = self._settings['mat_delim']
1786             right_delim = self._delim_dict[left_delim]
1787             block_str = r'\left' + left_delim + block_str + \
1788                         r'\right' + right_delim
1789 
1790         if expr.rank() == 0:
1791             return block_str % ""
1792 
1793         level_str = [[]] + [[] for i in range(expr.rank())]
1794         shape_ranges = [list(range(i)) for i in expr.shape]
1795         for outer_i in itertools.product(*shape_ranges):
1796             level_str[-1].append(self._print(expr[outer_i]))
1797             even = True
1798             for back_outer_i in range(expr.rank()-1, -1, -1):
1799                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1800                     break
1801                 if even:
1802                     level_str[back_outer_i].append(
1803                         r" & ".join(level_str[back_outer_i+1]))
1804                 else:
1805                     level_str[back_outer_i].append(
1806                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1807                     if len(level_str[back_outer_i+1]) == 1:
1808                         level_str[back_outer_i][-1] = r"\left[" + \
1809                             level_str[back_outer_i][-1] + r"\right]"
1810                 even = not even
1811                 level_str[back_outer_i+1] = []
1812 
1813         out_str = level_str[0][0]
1814 
1815         if expr.rank() % 2 == 1:
1816             out_str = block_str % out_str
1817 
1818         return out_str
1819 
1820     def _printer_tensor_indices(self, name, indices, index_map={}):
1821         out_str = self._print(name)
1822         last_valence = None
1823         prev_map = None
1824         for index in indices:
1825             new_valence = index.is_up
1826             if ((index in index_map) or prev_map) and \
1827                     last_valence == new_valence:
1828                 out_str += ","
1829             if last_valence != new_valence:
1830                 if last_valence is not None:
1831                     out_str += "}"
1832                 if index.is_up:
1833                     out_str += "{}^{"
1834                 else:
1835                     out_str += "{}_{"
1836             out_str += self._print(index.args[0])
1837             if index in index_map:
1838                 out_str += "="
1839                 out_str += self._print(index_map[index])
1840                 prev_map = True
1841             else:
1842                 prev_map = False
1843             last_valence = new_valence
1844         if last_valence is not None:
1845             out_str += "}"
1846         return out_str
1847 
1848     def _print_Tensor(self, expr):
1849         name = expr.args[0].args[0]
1850         indices = expr.get_indices()
1851         return self._printer_tensor_indices(name, indices)
1852 
1853     def _print_TensorElement(self, expr):
1854         name = expr.expr.args[0].args[0]
1855         indices = expr.expr.get_indices()
1856         index_map = expr.index_map
1857         return self._printer_tensor_indices(name, indices, index_map)
1858 
1859     def _print_TensMul(self, expr):
1860         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1861         sign, args = expr._get_args_for_traditional_printer()
1862         return sign + "".join(
1863             [self.parenthesize(arg, precedence(expr)) for arg in args]
1864         )
1865 
1866     def _print_TensAdd(self, expr):
1867         a = []
1868         args = expr.args
1869         for x in args:
1870             a.append(self.parenthesize(x, precedence(expr)))
1871         a.sort()
1872         s = ' + '.join(a)
1873         s = s.replace('+ -', '- ')
1874         return s
1875 
1876     def _print_TensorIndex(self, expr):
1877         return "{}%s{%s}" % (
1878             "^" if expr.is_up else "_",
1879             self._print(expr.args[0])
1880         )
1881 
1882     def _print_PartialDerivative(self, expr):
1883         if len(expr.variables) == 1:
1884             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1885                 self._print(expr.variables[0]),
1886                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1887             )
1888         else:
1889             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1890                 len(expr.variables),
1891                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1892                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1893             )
1894 
1895     def _print_ArraySymbol(self, expr):
1896         return self._print(expr.name)
1897 
1898     def _print_ArrayElement(self, expr):
1899         return "{{%s}_{%s}}" % (expr.name, ", ".join([f"{self._print(i)}" for i in expr.indices]))
1900 
1901     def _print_UniversalSet(self, expr):
1902         return r"\mathbb{U}"
1903 
1904     def _print_frac(self, expr, exp=None):
1905         if exp is None:
1906             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1907         else:
1908             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1909                     self._print(expr.args[0]), exp)
1910 
1911     def _print_tuple(self, expr):
1912         if self._settings['decimal_separator'] == 'comma':
1913             sep = ";"
1914         elif self._settings['decimal_separator'] == 'period':
1915             sep = ","
1916         else:
1917             raise ValueError('Unknown Decimal Separator')
1918 
1919         if len(expr) == 1:
1920             # 1-tuple needs a trailing separator
1921             return self._add_parens_lspace(self._print(expr[0]) + sep)
1922         else:
1923             return self._add_parens_lspace(
1924                 (sep + r" \  ").join([self._print(i) for i in expr]))
1925 
1926     def _print_TensorProduct(self, expr):
1927         elements = [self._print(a) for a in expr.args]
1928         return r' \otimes '.join(elements)
1929 
1930     def _print_WedgeProduct(self, expr):
1931         elements = [self._print(a) for a in expr.args]
1932         return r' \wedge '.join(elements)
1933 
1934     def _print_Tuple(self, expr):
1935         return self._print_tuple(expr)
1936 
1937     def _print_list(self, expr):
1938         if self._settings['decimal_separator'] == 'comma':
1939             return r"\left[ %s\right]" % \
1940                 r"; \  ".join([self._print(i) for i in expr])
1941         elif self._settings['decimal_separator'] == 'period':
1942             return r"\left[ %s\right]" % \
1943                 r", \  ".join([self._print(i) for i in expr])
1944         else:
1945             raise ValueError('Unknown Decimal Separator')
1946 
1947 
1948     def _print_dict(self, d):
1949         keys = sorted(d.keys(), key=default_sort_key)
1950         items = []
1951 
1952         for key in keys:
1953             val = d[key]
1954             items.append("%s : %s" % (self._print(key), self._print(val)))
1955 
1956         return r"\left\{ %s\right\}" % r", \  ".join(items)
1957 
1958     def _print_Dict(self, expr):
1959         return self._print_dict(expr)
1960 
1961     def _print_DiracDelta(self, expr, exp=None):
1962         if len(expr.args) == 1 or expr.args[1] == 0:
1963             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1964         else:
1965             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1966                 self._print(expr.args[1]), self._print(expr.args[0]))
1967         if exp:
1968             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1969         return tex
1970 
1971     def _print_SingularityFunction(self, expr, exp=None):
1972         shift = self._print(expr.args[0] - expr.args[1])
1973         power = self._print(expr.args[2])
1974         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1975         if exp is not None:
1976             tex = r"{\left({\langle %s \rangle}^{%s}\right)}^{%s}" % (shift, power, exp)
1977         return tex
1978 
1979     def _print_Heaviside(self, expr, exp=None):
1980         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1981         if exp:
1982             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1983         return tex
1984 
1985     def _print_KroneckerDelta(self, expr, exp=None):
1986         i = self._print(expr.args[0])
1987         j = self._print(expr.args[1])
1988         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1989             tex = r'\delta_{%s %s}' % (i, j)
1990         else:
1991             tex = r'\delta_{%s, %s}' % (i, j)
1992         if exp is not None:
1993             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1994         return tex
1995 
1996     def _print_LeviCivita(self, expr, exp=None):
1997         indices = map(self._print, expr.args)
1998         if all(x.is_Atom for x in expr.args):
1999             tex = r'\varepsilon_{%s}' % " ".join(indices)
2000         else:
2001             tex = r'\varepsilon_{%s}' % ", ".join(indices)
2002         if exp:
2003             tex = r'\left(%s\right)^{%s}' % (tex, exp)
2004         return tex
2005 
2006     def _print_RandomDomain(self, d):
2007         if hasattr(d, 'as_boolean'):
2008             return '\\text{Domain: }' + self._print(d.as_boolean())
2009         elif hasattr(d, 'set'):
2010             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
2011                     self._print(d.set))
2012         elif hasattr(d, 'symbols'):
2013             return '\\text{Domain on }' + self._print(d.symbols)
2014         else:
2015             return self._print(None)
2016 
2017     def _print_FiniteSet(self, s):
2018         items = sorted(s.args, key=default_sort_key)
2019         return self._print_set(items)
2020 
2021     def _print_set(self, s):
2022         items = sorted(s, key=default_sort_key)
2023         if self._settings['decimal_separator'] == 'comma':
2024             items = "; ".join(map(self._print, items))
2025         elif self._settings['decimal_separator'] == 'period':
2026             items = ", ".join(map(self._print, items))
2027         else:
2028             raise ValueError('Unknown Decimal Separator')
2029         return r"\left\{%s\right\}" % items
2030 
2031 
2032     _print_frozenset = _print_set
2033 
2034     def _print_Range(self, s):
2035         dots = object()
2036 
2037         if s.has(Symbol):
2038             return self._print_Basic(s)
2039 
2040         if s.start.is_infinite and s.stop.is_infinite:
2041             if s.step.is_positive:
2042                 printset = dots, -1, 0, 1, dots
2043             else:
2044                 printset = dots, 1, 0, -1, dots
2045         elif s.start.is_infinite:
2046             printset = dots, s[-1] - s.step, s[-1]
2047         elif s.stop.is_infinite:
2048             it = iter(s)
2049             printset = next(it), next(it), dots
2050         elif len(s) > 4:
2051             it = iter(s)
2052             printset = next(it), next(it), dots, s[-1]
2053         else:
2054             printset = tuple(s)
2055 
2056         return (r"\left\{" +
2057                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2058                 r"\right\}")
2059 
2060     def __print_number_polynomial(self, expr, letter, exp=None):
2061         if len(expr.args) == 2:
2062             if exp is not None:
2063                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2064                             self._print(expr.args[0]), exp,
2065                             self._print(expr.args[1]))
2066             return r"%s_{%s}\left(%s\right)" % (letter,
2067                         self._print(expr.args[0]), self._print(expr.args[1]))
2068 
2069         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2070         if exp is not None:
2071             tex = r"%s^{%s}" % (tex, exp)
2072         return tex
2073 
2074     def _print_bernoulli(self, expr, exp=None):
2075         return self.__print_number_polynomial(expr, "B", exp)
2076 
2077     def _print_bell(self, expr, exp=None):
2078         if len(expr.args) == 3:
2079             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2080                                 self._print(expr.args[1]))
2081             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2082                                                el in expr.args[2])
2083             if exp is not None:
2084                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2085             else:
2086                 tex = tex1 + tex2
2087             return tex
2088         return self.__print_number_polynomial(expr, "B", exp)
2089 
2090 
2091     def _print_fibonacci(self, expr, exp=None):
2092         return self.__print_number_polynomial(expr, "F", exp)
2093 
2094     def _print_lucas(self, expr, exp=None):
2095         tex = r"L_{%s}" % self._print(expr.args[0])
2096         if exp is not None:
2097             tex = r"%s^{%s}" % (tex, exp)
2098         return tex
2099 
2100     def _print_tribonacci(self, expr, exp=None):
2101         return self.__print_number_polynomial(expr, "T", exp)
2102 
2103     def _print_SeqFormula(self, s):
2104         dots = object()
2105         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2106             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2107                 self._print(s.formula),
2108                 self._print(s.variables[0]),
2109                 self._print(s.start),
2110                 self._print(s.stop)
2111             )
2112         if s.start is S.NegativeInfinity:
2113             stop = s.stop
2114             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2115                         s.coeff(stop - 1), s.coeff(stop))
2116         elif s.stop is S.Infinity or s.length > 4:
2117             printset = s[:4]
2118             printset.append(dots)
2119         else:
2120             printset = tuple(s)
2121 
2122         return (r"\left[" +
2123                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2124                 r"\right]")
2125 
2126     _print_SeqPer = _print_SeqFormula
2127     _print_SeqAdd = _print_SeqFormula
2128     _print_SeqMul = _print_SeqFormula
2129 
2130     def _print_Interval(self, i):
2131         if i.start == i.end:
2132             return r"\left\{%s\right\}" % self._print(i.start)
2133 
2134         else:
2135             if i.left_open:
2136                 left = '('
2137             else:
2138                 left = '['
2139 
2140             if i.right_open:
2141                 right = ')'
2142             else:
2143                 right = ']'
2144 
2145             return r"\left%s%s, %s\right%s" % \
2146                    (left, self._print(i.start), self._print(i.end), right)
2147 
2148     def _print_AccumulationBounds(self, i):
2149         return r"\left\langle %s, %s\right\rangle" % \
2150                 (self._print(i.min), self._print(i.max))
2151 
2152     def _print_Union(self, u):
2153         prec = precedence_traditional(u)
2154         args_str = [self.parenthesize(i, prec) for i in u.args]
2155         return r" \cup ".join(args_str)
2156 
2157     def _print_Complement(self, u):
2158         prec = precedence_traditional(u)
2159         args_str = [self.parenthesize(i, prec) for i in u.args]
2160         return r" \setminus ".join(args_str)
2161 
2162     def _print_Intersection(self, u):
2163         prec = precedence_traditional(u)
2164         args_str = [self.parenthesize(i, prec) for i in u.args]
2165         return r" \cap ".join(args_str)
2166 
2167     def _print_SymmetricDifference(self, u):
2168         prec = precedence_traditional(u)
2169         args_str = [self.parenthesize(i, prec) for i in u.args]
2170         return r" \triangle ".join(args_str)
2171 
2172     def _print_ProductSet(self, p):
2173         prec = precedence_traditional(p)
2174         if len(p.sets) >= 1 and not has_variety(p.sets):
2175             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2176         return r" \times ".join(
2177             self.parenthesize(set, prec) for set in p.sets)
2178 
2179     def _print_EmptySet(self, e):
2180         return r"\emptyset"
2181 
2182     def _print_Naturals(self, n):
2183         return r"\mathbb{N}"
2184 
2185     def _print_Naturals0(self, n):
2186         return r"\mathbb{N}_0"
2187 
2188     def _print_Integers(self, i):
2189         return r"\mathbb{Z}"
2190 
2191     def _print_Rationals(self, i):
2192         return r"\mathbb{Q}"
2193 
2194     def _print_Reals(self, i):
2195         return r"\mathbb{R}"
2196 
2197     def _print_Complexes(self, i):
2198         return r"\mathbb{C}"
2199 
2200     def _print_ImageSet(self, s):
2201         expr = s.lamda.expr
2202         sig = s.lamda.signature
2203         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2204         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2205         return r"\left\{%s\; \middle|\; %s\right\}" % (self._print(expr), xinys)
2206 
2207     def _print_ConditionSet(self, s):
2208         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2209         if s.base_set is S.UniversalSet:
2210             return r"\left\{%s\; \middle|\; %s \right\}" % \
2211                 (vars_print, self._print(s.condition))
2212 
2213         return r"\left\{%s\; \middle|\; %s \in %s \wedge %s \right\}" % (
2214             vars_print,
2215             vars_print,
2216             self._print(s.base_set),
2217             self._print(s.condition))
2218 
2219     def _print_ComplexRegion(self, s):
2220         vars_print = ', '.join([self._print(var) for var in s.variables])
2221         return r"\left\{%s\; \middle|\; %s \in %s \right\}" % (
2222             self._print(s.expr),
2223             vars_print,
2224             self._print(s.sets))
2225 
2226     def _print_Contains(self, e):
2227         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2228 
2229     def _print_FourierSeries(self, s):
2230         return self._print_Add(s.truncate()) + r' + \ldots'
2231 
2232     def _print_FormalPowerSeries(self, s):
2233         return self._print_Add(s.infinite)
2234 
2235     def _print_FiniteField(self, expr):
2236         return r"\mathbb{F}_{%s}" % expr.mod
2237 
2238     def _print_IntegerRing(self, expr):
2239         return r"\mathbb{Z}"
2240 
2241     def _print_RationalField(self, expr):
2242         return r"\mathbb{Q}"
2243 
2244     def _print_RealField(self, expr):
2245         return r"\mathbb{R}"
2246 
2247     def _print_ComplexField(self, expr):
2248         return r"\mathbb{C}"
2249 
2250     def _print_PolynomialRing(self, expr):
2251         domain = self._print(expr.domain)
2252         symbols = ", ".join(map(self._print, expr.symbols))
2253         return r"%s\left[%s\right]" % (domain, symbols)
2254 
2255     def _print_FractionField(self, expr):
2256         domain = self._print(expr.domain)
2257         symbols = ", ".join(map(self._print, expr.symbols))
2258         return r"%s\left(%s\right)" % (domain, symbols)
2259 
2260     def _print_PolynomialRingBase(self, expr):
2261         domain = self._print(expr.domain)
2262         symbols = ", ".join(map(self._print, expr.symbols))
2263         inv = ""
2264         if not expr.is_Poly:
2265             inv = r"S_<^{-1}"
2266         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2267 
2268     def _print_Poly(self, poly):
2269         cls = poly.__class__.__name__
2270         terms = []
2271         for monom, coeff in poly.terms():
2272             s_monom = ''
2273             for i, exp in enumerate(monom):
2274                 if exp > 0:
2275                     if exp == 1:
2276                         s_monom += self._print(poly.gens[i])
2277                     else:
2278                         s_monom += self._print(pow(poly.gens[i], exp))
2279 
2280             if coeff.is_Add:
2281                 if s_monom:
2282                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2283                 else:
2284                     s_coeff = self._print(coeff)
2285             else:
2286                 if s_monom:
2287                     if coeff is S.One:
2288                         terms.extend(['+', s_monom])
2289                         continue
2290 
2291                     if coeff is S.NegativeOne:
2292                         terms.extend(['-', s_monom])
2293                         continue
2294 
2295                 s_coeff = self._print(coeff)
2296 
2297             if not s_monom:
2298                 s_term = s_coeff
2299             else:
2300                 s_term = s_coeff + " " + s_monom
2301 
2302             if s_term.startswith('-'):
2303                 terms.extend(['-', s_term[1:]])
2304             else:
2305                 terms.extend(['+', s_term])
2306 
2307         if terms[0] in ['-', '+']:
2308             modifier = terms.pop(0)
2309 
2310             if modifier == '-':
2311                 terms[0] = '-' + terms[0]
2312 
2313         expr = ' '.join(terms)
2314         gens = list(map(self._print, poly.gens))
2315         domain = "domain=%s" % self._print(poly.get_domain())
2316 
2317         args = ", ".join([expr] + gens + [domain])
2318         if cls in accepted_latex_functions:
2319             tex = r"\%s {\left(%s \right)}" % (cls, args)
2320         else:
2321             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2322 
2323         return tex
2324 
2325     def _print_ComplexRootOf(self, root):
2326         cls = root.__class__.__name__
2327         if cls == "ComplexRootOf":
2328             cls = "CRootOf"
2329         expr = self._print(root.expr)
2330         index = root.index
2331         if cls in accepted_latex_functions:
2332             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2333         else:
2334             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2335                                                                  index)
2336 
2337     def _print_RootSum(self, expr):
2338         cls = expr.__class__.__name__
2339         args = [self._print(expr.expr)]
2340 
2341         if expr.fun is not S.IdentityFunction:
2342             args.append(self._print(expr.fun))
2343 
2344         if cls in accepted_latex_functions:
2345             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2346         else:
2347             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2348                                                              ", ".join(args))
2349 
2350     def _print_PolyElement(self, poly):
2351         mul_symbol = self._settings['mul_symbol_latex']
2352         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2353 
2354     def _print_FracElement(self, frac):
2355         if frac.denom == 1:
2356             return self._print(frac.numer)
2357         else:
2358             numer = self._print(frac.numer)
2359             denom = self._print(frac.denom)
2360             return r"\frac{%s}{%s}" % (numer, denom)
2361 
2362     def _print_euler(self, expr, exp=None):
2363         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2364         tex = r"E_{%s}" % self._print(m)
2365         if exp is not None:
2366             tex = r"%s^{%s}" % (tex, exp)
2367         if x is not None:
2368             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2369         return tex
2370 
2371     def _print_catalan(self, expr, exp=None):
2372         tex = r"C_{%s}" % self._print(expr.args[0])
2373         if exp is not None:
2374             tex = r"%s^{%s}" % (tex, exp)
2375         return tex
2376 
2377     def _print_UnifiedTransform(self, expr, s, inverse=False):
2378         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2379 
2380     def _print_MellinTransform(self, expr):
2381         return self._print_UnifiedTransform(expr, 'M')
2382 
2383     def _print_InverseMellinTransform(self, expr):
2384         return self._print_UnifiedTransform(expr, 'M', True)
2385 
2386     def _print_LaplaceTransform(self, expr):
2387         return self._print_UnifiedTransform(expr, 'L')
2388 
2389     def _print_InverseLaplaceTransform(self, expr):
2390         return self._print_UnifiedTransform(expr, 'L', True)
2391 
2392     def _print_FourierTransform(self, expr):
2393         return self._print_UnifiedTransform(expr, 'F')
2394 
2395     def _print_InverseFourierTransform(self, expr):
2396         return self._print_UnifiedTransform(expr, 'F', True)
2397 
2398     def _print_SineTransform(self, expr):
2399         return self._print_UnifiedTransform(expr, 'SIN')
2400 
2401     def _print_InverseSineTransform(self, expr):
2402         return self._print_UnifiedTransform(expr, 'SIN', True)
2403 
2404     def _print_CosineTransform(self, expr):
2405         return self._print_UnifiedTransform(expr, 'COS')
2406 
2407     def _print_InverseCosineTransform(self, expr):
2408         return self._print_UnifiedTransform(expr, 'COS', True)
2409 
2410     def _print_DMP(self, p):
2411         try:
2412             if p.ring is not None:
2413                 # TODO incorporate order
2414                 return self._print(p.ring.to_sympy(p))
2415         except SympifyError:
2416             pass
2417         return self._print(repr(p))
2418 
2419     def _print_DMF(self, p):
2420         return self._print_DMP(p)
2421 
2422     def _print_Object(self, object):
2423         return self._print(Symbol(object.name))
2424 
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))
2430 
2431     def _print_Morphism(self, morphism):
2432         domain = self._print(morphism.domain)
2433         codomain = self._print(morphism.codomain)
2434         return "%s\\rightarrow %s" % (domain, codomain)
2435 
2436     def _print_TransferFunction(self, expr):
2437         num, den = self._print(expr.num), self._print(expr.den)
2438         return r"\frac{%s}{%s}" % (num, den)
2439 
2440     def _print_Series(self, expr):
2441         args = list(expr.args)
2442         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2443                                             False)
2444         return ' '.join(map(parens, args))
2445 
2446     def _print_MIMOSeries(self, expr):
2447         from sympy.physics.control.lti import MIMOParallel
2448         args = list(expr.args)[::-1]
2449         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2450                                              False) if isinstance(x, MIMOParallel) else self._print(x)
2451         return r"\cdot".join(map(parens, args))
2452 
2453     def _print_Parallel(self, expr):
2454         args = list(expr.args)
2455         func = lambda x: self._print(x)
2456         return ' + '.join(map(func, args))
2457 
2458     def _print_MIMOParallel(self, expr):
2459         args = list(expr.args)
2460         func = lambda x: self._print(x)
2461         return ' + '.join(map(func, args))
2462 
2463     def _print_Feedback(self, expr):
2464         from sympy.physics.control import TransferFunction, Parallel, Series
2465 
2466         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2467         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2468         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2469 
2470         if isinstance(num, Series) and isinstance(expr.den, Series):
2471             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2472         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2473             if expr.den == tf:
2474                 den = Parallel(tf, Series(*num_arg_list))
2475             else:
2476                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2477         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2478             if num == tf:
2479                 den = Parallel(tf, Series(*den_arg_list))
2480             else:
2481                 den = Parallel(tf, Series(num, *den_arg_list))
2482         else:
2483             if num == tf:
2484                 den = Parallel(tf, *den_arg_list)
2485             elif expr.den == tf:
2486                 den = Parallel(tf, *num_arg_list)
2487             else:
2488                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2489 
2490         numer = self._print(num)
2491         denom = self._print(den)
2492         return r"\frac{%s}{%s}" % (numer, denom)
2493 
2494     def _print_TransferFunctionMatrix(self, expr):
2495         mat = self._print(expr._expr_mat)
2496         return r"%s_\tau" % mat
2497 
2498     def _print_NamedMorphism(self, morphism):
2499         pretty_name = self._print(Symbol(morphism.name))
2500         pretty_morphism = self._print_Morphism(morphism)
2501         return "%s:%s" % (pretty_name, pretty_morphism)
2502 
2503     def _print_IdentityMorphism(self, morphism):
2504         from sympy.categories import NamedMorphism
2505         return self._print_NamedMorphism(NamedMorphism(
2506             morphism.domain, morphism.codomain, "id"))
2507 
2508     def _print_CompositeMorphism(self, morphism):
2509         # All components of the morphism have names and it is thus
2510         # possible to build the name of the composite.
2511         component_names_list = [self._print(Symbol(component.name)) for
2512                                 component in morphism.components]
2513         component_names_list.reverse()
2514         component_names = "\\circ ".join(component_names_list) + ":"
2515 
2516         pretty_morphism = self._print_Morphism(morphism)
2517         return component_names + pretty_morphism
2518 
2519     def _print_Category(self, morphism):
2520         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2521 
2522     def _print_Diagram(self, diagram):
2523         if not diagram.premises:
2524             # This is an empty diagram.
2525             return self._print(S.EmptySet)
2526 
2527         latex_result = self._print(diagram.premises)
2528         if diagram.conclusions:
2529             latex_result += "\\Longrightarrow %s" % \
2530                             self._print(diagram.conclusions)
2531 
2532         return latex_result
2533 
2534     def _print_DiagramGrid(self, grid):
2535         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2536 
2537         for i in range(grid.height):
2538             for j in range(grid.width):
2539                 if grid[i, j]:
2540                     latex_result += latex(grid[i, j])
2541                 latex_result += " "
2542                 if j != grid.width - 1:
2543                     latex_result += "& "
2544 
2545             if i != grid.height - 1:
2546                 latex_result += "\\\\"
2547             latex_result += "\n"
2548 
2549         latex_result += "\\end{array}\n"
2550         return latex_result
2551 
2552     def _print_FreeModule(self, M):
2553         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2554 
2555     def _print_FreeModuleElement(self, m):
2556         # Print as row vector for convenience, for now.
2557         return r"\left[ {} \right]".format(",".join(
2558             '{' + self._print(x) + '}' for x in m))
2559 
2560     def _print_SubModule(self, m):
2561         return r"\left\langle {} \right\rangle".format(",".join(
2562             '{' + self._print(x) + '}' for x in m.gens))
2563 
2564     def _print_ModuleImplementedIdeal(self, m):
2565         return r"\left\langle {} \right\rangle".format(",".join(
2566             '{' + self._print(x) + '}' for [x] in m._module.gens))
2567 
2568     def _print_Quaternion(self, expr):
2569         # TODO: This expression is potentially confusing,
2570         # shall we print it as `Quaternion( ... )`?
2571         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2572              for i in expr.args]
2573         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2574         return " + ".join(a)
2575 
2576     def _print_QuotientRing(self, R):
2577         # TODO nicer fractions for few generators...
2578         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2579                  self._print(R.base_ideal))
2580 
2581     def _print_QuotientRingElement(self, x):
2582         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2583                  self._print(x.ring.base_ideal))
2584 
2585     def _print_QuotientModuleElement(self, m):
2586         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2587                  self._print(m.module.killed_module))
2588 
2589     def _print_QuotientModule(self, M):
2590         # TODO nicer fractions for few generators...
2591         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2592                  self._print(M.killed_module))
2593 
2594     def _print_MatrixHomomorphism(self, h):
2595         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2596             self._print(h.domain), self._print(h.codomain))
2597 
2598     def _print_Manifold(self, manifold):
2599         string = manifold.name.name
2600         if '{' in string:
2601             name, supers, subs = string, [], []
2602         else:
2603             name, supers, subs = split_super_sub(string)
2604 
2605             name = translate(name)
2606             supers = [translate(sup) for sup in supers]
2607             subs = [translate(sub) for sub in subs]
2608 
2609         name = r'\text{%s}' % name
2610         if supers:
2611             name += "^{%s}" % " ".join(supers)
2612         if subs:
2613             name += "_{%s}" % " ".join(subs)
2614 
2615         return name
2616 
2617     def _print_Patch(self, patch):
2618         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2619 
2620     def _print_CoordSystem(self, coordsys):
2621         return r'\text{%s}^{\text{%s}}_{%s}' % (
2622             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2623         )
2624 
2625     def _print_CovarDerivativeOp(self, cvd):
2626         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2627 
2628     def _print_BaseScalarField(self, field):
2629         string = field._coord_sys.symbols[field._index].name
2630         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2631 
2632     def _print_BaseVectorField(self, field):
2633         string = field._coord_sys.symbols[field._index].name
2634         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2635 
2636     def _print_Differential(self, diff):
2637         field = diff._form_field
2638         if hasattr(field, '_coord_sys'):
2639             string = field._coord_sys.symbols[field._index].name
2640             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2641         else:
2642             string = self._print(field)
2643             return r'\operatorname{{d}}\left({}\right)'.format(string)
2644 
2645     def _print_Tr(self, p):
2646         # TODO: Handle indices
2647         contents = self._print(p.args[0])
2648         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2649 
2650     def _print_totient(self, expr, exp=None):
2651         if exp is not None:
2652             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2653                 (self._print(expr.args[0]), exp)
2654         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2655 
2656     def _print_reduced_totient(self, expr, exp=None):
2657         if exp is not None:
2658             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2659                 (self._print(expr.args[0]), exp)
2660         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2661 
2662     def _print_divisor_sigma(self, expr, exp=None):
2663         if len(expr.args) == 2:
2664             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2665                                                 (expr.args[1], expr.args[0])))
2666         else:
2667             tex = r"\left(%s\right)" % self._print(expr.args[0])
2668         if exp is not None:
2669             return r"\sigma^{%s}%s" % (exp, tex)
2670         return r"\sigma%s" % tex
2671 
2672     def _print_udivisor_sigma(self, expr, exp=None):
2673         if len(expr.args) == 2:
2674             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2675                                                 (expr.args[1], expr.args[0])))
2676         else:
2677             tex = r"\left(%s\right)" % self._print(expr.args[0])
2678         if exp is not None:
2679             return r"\sigma^*^{%s}%s" % (exp, tex)
2680         return r"\sigma^*%s" % tex
2681 
2682     def _print_primenu(self, expr, exp=None):
2683         if exp is not None:
2684             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2685                 (self._print(expr.args[0]), exp)
2686         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2687 
2688     def _print_primeomega(self, expr, exp=None):
2689         if exp is not None:
2690             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2691                 (self._print(expr.args[0]), exp)
2692         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2693 
2694     def _print_Str(self, s):
2695         return str(s.name)
2696 
2697     def _print_float(self, expr):
2698         return self._print(Float(expr))
2699 
2700     def _print_int(self, expr):
2701         return str(expr)
2702 
2703     def _print_mpz(self, expr):
2704         return str(expr)
2705 
2706     def _print_mpq(self, expr):
2707         return str(expr)
2708 
2709     def _print_Predicate(self, expr):
2710         return str(expr)
2711 
2712     def _print_AppliedPredicate(self, expr):
2713         pred = expr.function
2714         args = expr.arguments
2715         pred_latex = self._print(pred)
2716         args_latex = ', '.join([self._print(a) for a in args])
2717         return '%s(%s)' % (pred_latex, args_latex)
2718 
2719     def emptyPrinter(self, expr):
2720         # default to just printing as monospace, like would normally be shown
2721         s = super().emptyPrinter(expr)
2722 
2723         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_LambertW</method>
<code>
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))

</code><intended_behavior>Although the `_print_LambertW` method is not directly at fault based on the existing implementation, considering a future-proofing approach, it may be beneficial to allow this method (and similarly implemented methods for other functions) to optionally handle an `exp` argument. This would not change the method's current handling but would add an optional pathway for dealing with exponentiation directly within the function's LaTeX representation. This adaptation would require a fallback or default behavior that ensures compatibility with the current usage while enabling new functionality where necessary. This method could, for example, provide a basic LaTeX exponentiation wrapping around its current output if `exp` is provided and is not trivial (e.g., an exponent of 1).</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_Exp1(self, expr, exp=None):
1113         return "e"
1114 
1115     def _print_elliptic_k(self, expr, exp=None):
1116         tex = r"\left(%s\right)" % self._print(expr.args[0])
1117         if exp is not None:
1118             return r"K^{%s}%s" % (exp, tex)
1119         else:
1120             return r"K%s" % tex
1121 
1122     def _print_elliptic_f(self, expr, exp=None):
1123         tex = r"\left(%s\middle| %s\right)" % \
1124             (self._print(expr.args[0]), self._print(expr.args[1]))
1125         if exp is not None:
1126             return r"F^{%s}%s" % (exp, tex)
1127         else:
1128             return r"F%s" % tex
1129 
1130     def _print_elliptic_e(self, expr, exp=None):
1131         if len(expr.args) == 2:
1132             tex = r"\left(%s\middle| %s\right)" % \
1133                 (self._print(expr.args[0]), self._print(expr.args[1]))
1134         else:
1135             tex = r"\left(%s\right)" % self._print(expr.args[0])
1136         if exp is not None:
1137             return r"E^{%s}%s" % (exp, tex)
1138         else:
1139             return r"E%s" % tex
1140 
1141     def _print_elliptic_pi(self, expr, exp=None):
1142         if len(expr.args) == 3:
1143             tex = r"\left(%s; %s\middle| %s\right)" % \
1144                 (self._print(expr.args[0]), self._print(expr.args[1]),
1145                  self._print(expr.args[2]))
1146         else:
1147             tex = r"\left(%s\middle| %s\right)" % \
1148                 (self._print(expr.args[0]), self._print(expr.args[1]))
1149         if exp is not None:
1150             return r"\Pi^{%s}%s" % (exp, tex)
1151         else:
1152             return r"\Pi%s" % tex
1153 
1154     def _print_beta(self, expr, exp=None):
1155         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1156                                         self._print(expr.args[1]))
1157 
1158         if exp is not None:
1159             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1160         else:
1161             return r"\operatorname{B}%s" % tex
1162 
1163     def _print_betainc(self, expr, exp=None, operator='B'):
1164         largs = [self._print(arg) for arg in expr.args]
1165         tex = r"\left(%s, %s\right)" % (largs[0], largs[1])
1166 
1167         if exp is not None:
1168             return r"\operatorname{%s}_{(%s, %s)}^{%s}%s" % (operator, largs[2], largs[3], exp, tex)
1169         else:
1170             return r"\operatorname{%s}_{(%s, %s)}%s" % (operator, largs[2], largs[3], tex)
1171 
1172     def _print_betainc_regularized(self, expr, exp=None):
1173         return self._print_betainc(expr, exp, operator='I')
1174 
1175     def _print_uppergamma(self, expr, exp=None):
1176         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1177                                         self._print(expr.args[1]))
1178 
1179         if exp is not None:
1180             return r"\Gamma^{%s}%s" % (exp, tex)
1181         else:
1182             return r"\Gamma%s" % tex
1183 
1184     def _print_lowergamma(self, expr, exp=None):
1185         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1186                                         self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"\gamma^{%s}%s" % (exp, tex)
1190         else:
1191             return r"\gamma%s" % tex
1192 
1193     def _hprint_one_arg_func(self, expr, exp=None):
1194         tex = r"\left(%s\right)" % self._print(expr.args[0])
1195 
1196         if exp is not None:
1197             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1198         else:
1199             return r"%s%s" % (self._print(expr.func), tex)
1200 
1201     _print_gamma = _hprint_one_arg_func
1202 
1203     def _print_Chi(self, expr, exp=None):
1204         tex = r"\left(%s\right)" % self._print(expr.args[0])
1205 
1206         if exp is not None:
1207             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1208         else:
1209             return r"\operatorname{Chi}%s" % tex
1210 
1211     def _print_expint(self, expr, exp=None):
1212         tex = r"\left(%s\right)" % self._print(expr.args[1])
1213         nu = self._print(expr.args[0])
1214 
1215         if exp is not None:
1216             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1217         else:
1218             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1219 
1220     def _print_fresnels(self, expr, exp=None):
1221         tex = r"\left(%s\right)" % self._print(expr.args[0])
1222 
1223         if exp is not None:
1224             return r"S^{%s}%s" % (exp, tex)
1225         else:
1226             return r"S%s" % tex
1227 
1228     def _print_fresnelc(self, expr, exp=None):
1229         tex = r"\left(%s\right)" % self._print(expr.args[0])
1230 
1231         if exp is not None:
1232             return r"C^{%s}%s" % (exp, tex)
1233         else:
1234             return r"C%s" % tex
1235 
1236     def _print_subfactorial(self, expr, exp=None):
1237         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1238 
1239         if exp is not None:
1240             return r"\left(%s\right)^{%s}" % (tex, exp)
1241         else:
1242             return tex
1243 
1244     def _print_factorial(self, expr, exp=None):
1245         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1246 
1247         if exp is not None:
1248             return r"%s^{%s}" % (tex, exp)
1249         else:
1250             return tex
1251 
1252     def _print_factorial2(self, expr, exp=None):
1253         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1254 
1255         if exp is not None:
1256             return r"%s^{%s}" % (tex, exp)
1257         else:
1258             return tex
1259 
1260     def _print_binomial(self, expr, exp=None):
1261         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1262                                      self._print(expr.args[1]))
1263 
1264         if exp is not None:
1265             return r"%s^{%s}" % (tex, exp)
1266         else:
1267             return tex
1268 
1269     def _print_RisingFactorial(self, expr, exp=None):
1270         n, k = expr.args
1271         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1272 
1273         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1274 
1275         return self._do_exponent(tex, exp)
1276 
1277     def _print_FallingFactorial(self, expr, exp=None):
1278         n, k = expr.args
1279         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1280 
1281         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1282 
1283         return self._do_exponent(tex, exp)
1284 
1285     def _hprint_BesselBase(self, expr, exp, sym):
1286         tex = r"%s" % (sym)
1287 
1288         need_exp = False
1289         if exp is not None:
1290             if tex.find('^') == -1:
1291                 tex = r"%s^{%s}" % (tex, exp)
1292             else:
1293                 need_exp = True
1294 
1295         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1296                                            self._print(expr.argument))
1297 
1298         if need_exp:
1299             tex = self._do_exponent(tex, exp)
1300         return tex
1301 
1302     def _hprint_vec(self, vec):
1303         if not vec:
1304             return ""
1305         s = ""
1306         for i in vec[:-1]:
1307             s += "%s, " % self._print(i)
1308         s += self._print(vec[-1])
1309         return s
1310 
1311     def _print_besselj(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'J')
1313 
1314     def _print_besseli(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'I')
1316 
1317     def _print_besselk(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'K')
1319 
1320     def _print_bessely(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'Y')
1322 
1323     def _print_yn(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'y')
1325 
1326     def _print_jn(self, expr, exp=None):
1327         return self._hprint_BesselBase(expr, exp, 'j')
1328 
1329     def _print_hankel1(self, expr, exp=None):
1330         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1331 
1332     def _print_hankel2(self, expr, exp=None):
1333         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1334 
1335     def _print_hn1(self, expr, exp=None):
1336         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1337 
1338     def _print_hn2(self, expr, exp=None):
1339         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1340 
1341     def _hprint_airy(self, expr, exp=None, notation=""):
1342         tex = r"\left(%s\right)" % self._print(expr.args[0])
1343 
1344         if exp is not None:
1345             return r"%s^{%s}%s" % (notation, exp, tex)
1346         else:
1347             return r"%s%s" % (notation, tex)
1348 
1349     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1350         tex = r"\left(%s\right)" % self._print(expr.args[0])
1351 
1352         if exp is not None:
1353             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1354         else:
1355             return r"%s^\prime%s" % (notation, tex)
1356 
1357     def _print_airyai(self, expr, exp=None):
1358         return self._hprint_airy(expr, exp, 'Ai')
1359 
1360     def _print_airybi(self, expr, exp=None):
1361         return self._hprint_airy(expr, exp, 'Bi')
1362 
1363     def _print_airyaiprime(self, expr, exp=None):
1364         return self._hprint_airy_prime(expr, exp, 'Ai')
1365 
1366     def _print_airybiprime(self, expr, exp=None):
1367         return self._hprint_airy_prime(expr, exp, 'Bi')
1368 
1369     def _print_hyper(self, expr, exp=None):
1370         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1371               r"\middle| {%s} \right)}" % \
1372             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1373               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1374               self._print(expr.argument))
1375 
1376         if exp is not None:
1377             tex = r"{%s}^{%s}" % (tex, exp)
1378         return tex
1379 
1380     def _print_meijerg(self, expr, exp=None):
1381         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1382               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1383             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1384               self._print(len(expr.bm)), self._print(len(expr.an)),
1385               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1386               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1387               self._print(expr.argument))
1388 
1389         if exp is not None:
1390             tex = r"{%s}^{%s}" % (tex, exp)
1391         return tex
1392 
1393     def _print_dirichlet_eta(self, expr, exp=None):
1394         tex = r"\left(%s\right)" % self._print(expr.args[0])
1395         if exp is not None:
1396             return r"\eta^{%s}%s" % (exp, tex)
1397         return r"\eta%s" % tex
1398 
1399     def _print_zeta(self, expr, exp=None):
1400         if len(expr.args) == 2:
1401             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1402         else:
1403             tex = r"\left(%s\right)" % self._print(expr.args[0])
1404         if exp is not None:
1405             return r"\zeta^{%s}%s" % (exp, tex)
1406         return r"\zeta%s" % tex
1407 
1408     def _print_stieltjes(self, expr, exp=None):
1409         if len(expr.args) == 2:
1410             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1411         else:
1412             tex = r"_{%s}" % self._print(expr.args[0])
1413         if exp is not None:
1414             return r"\gamma%s^{%s}" % (tex, exp)
1415         return r"\gamma%s" % tex
1416 
1417     def _print_lerchphi(self, expr, exp=None):
1418         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1419         if exp is None:
1420             return r"\Phi%s" % tex
1421         return r"\Phi^{%s}%s" % (exp, tex)
1422 
1423     def _print_polylog(self, expr, exp=None):
1424         s, z = map(self._print, expr.args)
1425         tex = r"\left(%s\right)" % z
1426         if exp is None:
1427             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1428         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1429 
1430     def _print_jacobi(self, expr, exp=None):
1431         n, a, b, x = map(self._print, expr.args)
1432         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1433         if exp is not None:
1434             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1435         return tex
1436 
1437     def _print_gegenbauer(self, expr, exp=None):
1438         n, a, x = map(self._print, expr.args)
1439         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1440         if exp is not None:
1441             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1442         return tex
1443 
1444     def _print_chebyshevt(self, expr, exp=None):
1445         n, x = map(self._print, expr.args)
1446         tex = r"T_{%s}\left(%s\right)" % (n, x)
1447         if exp is not None:
1448             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1449         return tex
1450 
1451     def _print_chebyshevu(self, expr, exp=None):
1452         n, x = map(self._print, expr.args)
1453         tex = r"U_{%s}\left(%s\right)" % (n, x)
1454         if exp is not None:
1455             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1456         return tex
1457 
1458     def _print_legendre(self, expr, exp=None):
1459         n, x = map(self._print, expr.args)
1460         tex = r"P_{%s}\left(%s\right)" % (n, x)
1461         if exp is not None:
1462             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1463         return tex
1464 
1465     def _print_assoc_legendre(self, expr, exp=None):
1466         n, a, x = map(self._print, expr.args)
1467         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1468         if exp is not None:
1469             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1470         return tex
1471 
1472     def _print_hermite(self, expr, exp=None):
1473         n, x = map(self._print, expr.args)
1474         tex = r"H_{%s}\left(%s\right)" % (n, x)
1475         if exp is not None:
1476             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1477         return tex
1478 
1479     def _print_laguerre(self, expr, exp=None):
1480         n, x = map(self._print, expr.args)
1481         tex = r"L_{%s}\left(%s\right)" % (n, x)
1482         if exp is not None:
1483             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1484         return tex
1485 
1486     def _print_assoc_laguerre(self, expr, exp=None):
1487         n, a, x = map(self._print, expr.args)
1488         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1489         if exp is not None:
1490             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1491         return tex
1492 
1493     def _print_Ynm(self, expr, exp=None):
1494         n, m, theta, phi = map(self._print, expr.args)
1495         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1496         if exp is not None:
1497             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1498         return tex
1499 
1500     def _print_Znm(self, expr, exp=None):
1501         n, m, theta, phi = map(self._print, expr.args)
1502         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1503         if exp is not None:
1504             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1505         return tex
1506 
1507     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1508         a, q, z = map(self._print, args)
1509         sup = r"^{\prime}" if prime else ""
1510         exp = "" if not exp else "^{%s}" % exp
1511         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1512 
1513     def _print_mathieuc(self, expr, exp=None):
1514         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1515 
1516     def _print_mathieus(self, expr, exp=None):
1517         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1518 
1519     def _print_mathieucprime(self, expr, exp=None):
1520         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1521 
1522     def _print_mathieusprime(self, expr, exp=None):
1523         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1524 
1525     def _print_Rational(self, expr):
1526         if expr.q != 1:
1527             sign = ""
1528             p = expr.p
1529             if expr.p < 0:
1530                 sign = "- "
1531                 p = -p
1532             if self._settings['fold_short_frac']:
1533                 return r"%s%d / %d" % (sign, p, expr.q)
1534             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1535         else:
1536             return self._print(expr.p)
1537 
1538     def _print_Order(self, expr):
1539         s = self._print(expr.expr)
1540         if expr.point and any(p != S.Zero for p in expr.point) or \
1541            len(expr.variables) > 1:
1542             s += '; '
1543             if len(expr.variables) > 1:
1544                 s += self._print(expr.variables)
1545             elif expr.variables:
1546                 s += self._print(expr.variables[0])
1547             s += r'\rightarrow '
1548             if len(expr.point) > 1:
1549                 s += self._print(expr.point)
1550             else:
1551                 s += self._print(expr.point[0])
1552         return r"O\left(%s\right)" % s
1553 
1554     def _print_Symbol(self, expr, style='plain'):
1555         if expr in self._settings['symbol_names']:
1556             return self._settings['symbol_names'][expr]
1557 
1558         return self._deal_with_super_sub(expr.name, style=style)
1559 
1560     _print_RandomSymbol = _print_Symbol
1561 
1562     def _deal_with_super_sub(self, string, style='plain'):
1563         if '{' in string:
1564             name, supers, subs = string, [], []
1565         else:
1566             name, supers, subs = split_super_sub(string)
1567 
1568             name = translate(name)
1569             supers = [translate(sup) for sup in supers]
1570             subs = [translate(sub) for sub in subs]
1571 
1572         # apply the style only to the name
1573         if style == 'bold':
1574             name = "\\mathbf{{{}}}".format(name)
1575 
1576         # glue all items together:
1577         if supers:
1578             name += "^{%s}" % " ".join(supers)
1579         if subs:
1580             name += "_{%s}" % " ".join(subs)
1581 
1582         return name
1583 
1584     def _print_Relational(self, expr):
1585         if self._settings['itex']:
1586             gt = r"\gt"
1587             lt = r"\lt"
1588         else:
1589             gt = ">"
1590             lt = "<"
1591 
1592         charmap = {
1593             "==": "=",
1594             ">": gt,
1595             "<": lt,
1596             ">=": r"\geq",
1597             "<=": r"\leq",
1598             "!=": r"\neq",
1599         }
1600 
1601         return "%s %s %s" % (self._print(expr.lhs),
1602                              charmap[expr.rel_op], self._print(expr.rhs))
1603 
1604     def _print_Piecewise(self, expr):
1605         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1606                    for e, c in expr.args[:-1]]
1607         if expr.args[-1].cond == true:
1608             ecpairs.append(r"%s & \text{otherwise}" %
1609                            self._print(expr.args[-1].expr))
1610         else:
1611             ecpairs.append(r"%s & \text{for}\: %s" %
1612                            (self._print(expr.args[-1].expr),
1613                             self._print(expr.args[-1].cond)))
1614         tex = r"\begin{cases} %s \end{cases}"
1615         return tex % r" \\".join(ecpairs)
1616 
1617     def _print_MatrixBase(self, expr):
1618         lines = []
1619 
1620         for line in range(expr.rows):  # horrible, should be 'rows'
1621             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1622 
1623         mat_str = self._settings['mat_str']
1624         if mat_str is None:
1625             if self._settings['mode'] == 'inline':
1626                 mat_str = 'smallmatrix'
1627             else:
1628                 if (expr.cols <= 10) is True:
1629                     mat_str = 'matrix'
1630                 else:
1631                     mat_str = 'array'
1632 
1633         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1634         out_str = out_str.replace('%MATSTR%', mat_str)
1635         if mat_str == 'array':
1636             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1637         if self._settings['mat_delim']:
1638             left_delim = self._settings['mat_delim']
1639             right_delim = self._delim_dict[left_delim]
1640             out_str = r'\left' + left_delim + out_str + \
1641                       r'\right' + right_delim
1642         return out_str % r"\\".join(lines)
1643 
1644     def _print_MatrixElement(self, expr):
1645         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1646             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1647 
1648     def _print_MatrixSlice(self, expr):
1649         def latexslice(x, dim):
1650             x = list(x)
1651             if x[2] == 1:
1652                 del x[2]
1653             if x[0] == 0:
1654                 x[0] = None
1655             if x[1] == dim:
1656                 x[1] = None
1657             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1658         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1659                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1660                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1661 
1662     def _print_BlockMatrix(self, expr):
1663         return self._print(expr.blocks)
1664 
1665     def _print_Transpose(self, expr):
1666         mat = expr.arg
1667         from sympy.matrices import MatrixSymbol
1668         if not isinstance(mat, MatrixSymbol):
1669             return r"\left(%s\right)^{T}" % self._print(mat)
1670         else:
1671             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1672 
1673     def _print_Trace(self, expr):
1674         mat = expr.arg
1675         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1676 
1677     def _print_Adjoint(self, expr):
1678         mat = expr.arg
1679         from sympy.matrices import MatrixSymbol
1680         if not isinstance(mat, MatrixSymbol):
1681             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1682         else:
1683             return r"%s^{\dagger}" % self._print(mat)
1684 
1685     def _print_MatMul(self, expr):
1686         from sympy import MatMul, Mul
1687 
1688         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1689                                              False)
1690 
1691         args = expr.args
1692         if isinstance(args[0], Mul):
1693             args = args[0].as_ordered_factors() + list(args[1:])
1694         else:
1695             args = list(args)
1696 
1697         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1698             if args[0] == -1:
1699                 args = args[1:]
1700             else:
1701                 args[0] = -args[0]
1702             return '- ' + ' '.join(map(parens, args))
1703         else:
1704             return ' '.join(map(parens, args))
1705 
1706     def _print_Mod(self, expr, exp=None):
1707         if exp is not None:
1708             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1709                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1710                                    strict=True), self._print(expr.args[1]),
1711                  exp)
1712         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1713                                  PRECEDENCE['Mul'], strict=True),
1714                                  self._print(expr.args[1]))
1715 
1716     def _print_HadamardProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \circ '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_HadamardPower(self, expr):
1725         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1726             template = r"%s^{\circ \left({%s}\right)}"
1727         else:
1728             template = r"%s^{\circ {%s}}"
1729         return self._helper_print_standard_power(expr, template)
1730 
1731     def _print_KroneckerProduct(self, expr):
1732         args = expr.args
1733         prec = PRECEDENCE['Pow']
1734         parens = self.parenthesize
1735 
1736         return r' \otimes '.join(
1737             map(lambda arg: parens(arg, prec, strict=True), args))
1738 
1739     def _print_MatPow(self, expr):
1740         base, exp = expr.base, expr.exp
1741         from sympy.matrices import MatrixSymbol
1742         if not isinstance(base, MatrixSymbol):
1743             return "\\left(%s\\right)^{%s}" % (self._print(base),
1744                                               self._print(exp))
1745         else:
1746             return "%s^{%s}" % (self._print(base), self._print(exp))
1747 
1748     def _print_MatrixSymbol(self, expr):
1749         return self._print_Symbol(expr, style=self._settings[
1750             'mat_symbol_style'])
1751 
1752     def _print_ZeroMatrix(self, Z):
1753         return r"\mathbb{0}" if self._settings[
1754             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1755 
1756     def _print_OneMatrix(self, O):
1757         return r"\mathbb{1}" if self._settings[
1758             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1759 
1760     def _print_Identity(self, I):
1761         return r"\mathbb{I}" if self._settings[
1762             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1763 
1764     def _print_PermutationMatrix(self, P):
1765         perm_str = self._print(P.args[0])
1766         return "P_{%s}" % perm_str
1767 
1768     def _print_NDimArray(self, expr):
1769 
1770         if expr.rank() == 0:
1771             return self._print(expr[()])
1772 
1773         mat_str = self._settings['mat_str']
1774         if mat_str is None:
1775             if self._settings['mode'] == 'inline':
1776                 mat_str = 'smallmatrix'
1777             else:
1778                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1779                     mat_str = 'matrix'
1780                 else:
1781                     mat_str = 'array'
1782         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1783         block_str = block_str.replace('%MATSTR%', mat_str)
1784         if self._settings['mat_delim']:
1785             left_delim = self._settings['mat_delim']
1786             right_delim = self._delim_dict[left_delim]
1787             block_str = r'\left' + left_delim + block_str + \
1788                         r'\right' + right_delim
1789 
1790         if expr.rank() == 0:
1791             return block_str % ""
1792 
1793         level_str = [[]] + [[] for i in range(expr.rank())]
1794         shape_ranges = [list(range(i)) for i in expr.shape]
1795         for outer_i in itertools.product(*shape_ranges):
1796             level_str[-1].append(self._print(expr[outer_i]))
1797             even = True
1798             for back_outer_i in range(expr.rank()-1, -1, -1):
1799                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1800                     break
1801                 if even:
1802                     level_str[back_outer_i].append(
1803                         r" & ".join(level_str[back_outer_i+1]))
1804                 else:
1805                     level_str[back_outer_i].append(
1806                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1807                     if len(level_str[back_outer_i+1]) == 1:
1808                         level_str[back_outer_i][-1] = r"\left[" + \
1809                             level_str[back_outer_i][-1] + r"\right]"
1810                 even = not even
1811                 level_str[back_outer_i+1] = []
1812 
1813         out_str = level_str[0][0]
1814 
1815         if expr.rank() % 2 == 1:
1816             out_str = block_str % out_str
1817 
1818         return out_str
1819 
1820     def _printer_tensor_indices(self, name, indices, index_map={}):
1821         out_str = self._print(name)
1822         last_valence = None
1823         prev_map = None
1824         for index in indices:
1825             new_valence = index.is_up
1826             if ((index in index_map) or prev_map) and \
1827                     last_valence == new_valence:
1828                 out_str += ","
1829             if last_valence != new_valence:
1830                 if last_valence is not None:
1831                     out_str += "}"
1832                 if index.is_up:
1833                     out_str += "{}^{"
1834                 else:
1835                     out_str += "{}_{"
1836             out_str += self._print(index.args[0])
1837             if index in index_map:
1838                 out_str += "="
1839                 out_str += self._print(index_map[index])
1840                 prev_map = True
1841             else:
1842                 prev_map = False
1843             last_valence = new_valence
1844         if last_valence is not None:
1845             out_str += "}"
1846         return out_str
1847 
1848     def _print_Tensor(self, expr):
1849         name = expr.args[0].args[0]
1850         indices = expr.get_indices()
1851         return self._printer_tensor_indices(name, indices)
1852 
1853     def _print_TensorElement(self, expr):
1854         name = expr.expr.args[0].args[0]
1855         indices = expr.expr.get_indices()
1856         index_map = expr.index_map
1857         return self._printer_tensor_indices(name, indices, index_map)
1858 
1859     def _print_TensMul(self, expr):
1860         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1861         sign, args = expr._get_args_for_traditional_printer()
1862         return sign + "".join(
1863             [self.parenthesize(arg, precedence(expr)) for arg in args]
1864         )
1865 
1866     def _print_TensAdd(self, expr):
1867         a = []
1868         args = expr.args
1869         for x in args:
1870             a.append(self.parenthesize(x, precedence(expr)))
1871         a.sort()
1872         s = ' + '.join(a)
1873         s = s.replace('+ -', '- ')
1874         return s
1875 
1876     def _print_TensorIndex(self, expr):
1877         return "{}%s{%s}" % (
1878             "^" if expr.is_up else "_",
1879             self._print(expr.args[0])
1880         )
1881 
1882     def _print_PartialDerivative(self, expr):
1883         if len(expr.variables) == 1:
1884             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1885                 self._print(expr.variables[0]),
1886                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1887             )
1888         else:
1889             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1890                 len(expr.variables),
1891                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1892                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1893             )
1894 
1895     def _print_ArraySymbol(self, expr):
1896         return self._print(expr.name)
1897 
1898     def _print_ArrayElement(self, expr):
1899         return "{{%s}_{%s}}" % (expr.name, ", ".join([f"{self._print(i)}" for i in expr.indices]))
1900 
1901     def _print_UniversalSet(self, expr):
1902         return r"\mathbb{U}"
1903 
1904     def _print_frac(self, expr, exp=None):
1905         if exp is None:
1906             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1907         else:
1908             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1909                     self._print(expr.args[0]), exp)
1910 
1911     def _print_tuple(self, expr):
1912         if self._settings['decimal_separator'] == 'comma':
1913             sep = ";"
1914         elif self._settings['decimal_separator'] == 'period':
1915             sep = ","
1916         else:
1917             raise ValueError('Unknown Decimal Separator')
1918 
1919         if len(expr) == 1:
1920             # 1-tuple needs a trailing separator
1921             return self._add_parens_lspace(self._print(expr[0]) + sep)
1922         else:
1923             return self._add_parens_lspace(
1924                 (sep + r" \  ").join([self._print(i) for i in expr]))
1925 
1926     def _print_TensorProduct(self, expr):
1927         elements = [self._print(a) for a in expr.args]
1928         return r' \otimes '.join(elements)
1929 
1930     def _print_WedgeProduct(self, expr):
1931         elements = [self._print(a) for a in expr.args]
1932         return r' \wedge '.join(elements)
1933 
1934     def _print_Tuple(self, expr):
1935         return self._print_tuple(expr)
1936 
1937     def _print_list(self, expr):
1938         if self._settings['decimal_separator'] == 'comma':
1939             return r"\left[ %s\right]" % \
1940                 r"; \  ".join([self._print(i) for i in expr])
1941         elif self._settings['decimal_separator'] == 'period':
1942             return r"\left[ %s\right]" % \
1943                 r", \  ".join([self._print(i) for i in expr])
1944         else:
1945             raise ValueError('Unknown Decimal Separator')
1946 
1947 
1948     def _print_dict(self, d):
1949         keys = sorted(d.keys(), key=default_sort_key)
1950         items = []
1951 
1952         for key in keys:
1953             val = d[key]
1954             items.append("%s : %s" % (self._print(key), self._print(val)))
1955 
1956         return r"\left\{ %s\right\}" % r", \  ".join(items)
1957 
1958     def _print_Dict(self, expr):
1959         return self._print_dict(expr)
1960 
1961     def _print_DiracDelta(self, expr, exp=None):
1962         if len(expr.args) == 1 or expr.args[1] == 0:
1963             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1964         else:
1965             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1966                 self._print(expr.args[1]), self._print(expr.args[0]))
1967         if exp:
1968             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1969         return tex
1970 
1971     def _print_SingularityFunction(self, expr, exp=None):
1972         shift = self._print(expr.args[0] - expr.args[1])
1973         power = self._print(expr.args[2])
1974         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1975         if exp is not None:
1976             tex = r"{\left({\langle %s \rangle}^{%s}\right)}^{%s}" % (shift, power, exp)
1977         return tex
1978 
1979     def _print_Heaviside(self, expr, exp=None):
1980         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1981         if exp:
1982             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1983         return tex
1984 
1985     def _print_KroneckerDelta(self, expr, exp=None):
1986         i = self._print(expr.args[0])
1987         j = self._print(expr.args[1])
1988         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1989             tex = r'\delta_{%s %s}' % (i, j)
1990         else:
1991             tex = r'\delta_{%s, %s}' % (i, j)
1992         if exp is not None:
1993             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1994         return tex
1995 
1996     def _print_LeviCivita(self, expr, exp=None):
1997         indices = map(self._print, expr.args)
1998         if all(x.is_Atom for x in expr.args):
1999             tex = r'\varepsilon_{%s}' % " ".join(indices)
2000         else:
2001             tex = r'\varepsilon_{%s}' % ", ".join(indices)
2002         if exp:
2003             tex = r'\left(%s\right)^{%s}' % (tex, exp)
2004         return tex
2005 
2006     def _print_RandomDomain(self, d):
2007         if hasattr(d, 'as_boolean'):
2008             return '\\text{Domain: }' + self._print(d.as_boolean())
2009         elif hasattr(d, 'set'):
2010             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
2011                     self._print(d.set))
2012         elif hasattr(d, 'symbols'):
2013             return '\\text{Domain on }' + self._print(d.symbols)
2014         else:
2015             return self._print(None)
2016 
2017     def _print_FiniteSet(self, s):
2018         items = sorted(s.args, key=default_sort_key)
2019         return self._print_set(items)
2020 
2021     def _print_set(self, s):
2022         items = sorted(s, key=default_sort_key)
2023         if self._settings['decimal_separator'] == 'comma':
2024             items = "; ".join(map(self._print, items))
2025         elif self._settings['decimal_separator'] == 'period':
2026             items = ", ".join(map(self._print, items))
2027         else:
2028             raise ValueError('Unknown Decimal Separator')
2029         return r"\left\{%s\right\}" % items
2030 
2031 
2032     _print_frozenset = _print_set
2033 
2034     def _print_Range(self, s):
2035         dots = object()
2036 
2037         if s.has(Symbol):
2038             return self._print_Basic(s)
2039 
2040         if s.start.is_infinite and s.stop.is_infinite:
2041             if s.step.is_positive:
2042                 printset = dots, -1, 0, 1, dots
2043             else:
2044                 printset = dots, 1, 0, -1, dots
2045         elif s.start.is_infinite:
2046             printset = dots, s[-1] - s.step, s[-1]
2047         elif s.stop.is_infinite:
2048             it = iter(s)
2049             printset = next(it), next(it), dots
2050         elif len(s) > 4:
2051             it = iter(s)
2052             printset = next(it), next(it), dots, s[-1]
2053         else:
2054             printset = tuple(s)
2055 
2056         return (r"\left\{" +
2057                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2058                 r"\right\}")
2059 
2060     def __print_number_polynomial(self, expr, letter, exp=None):
2061         if len(expr.args) == 2:
2062             if exp is not None:
2063                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2064                             self._print(expr.args[0]), exp,
2065                             self._print(expr.args[1]))
2066             return r"%s_{%s}\left(%s\right)" % (letter,
2067                         self._print(expr.args[0]), self._print(expr.args[1]))
2068 
2069         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2070         if exp is not None:
2071             tex = r"%s^{%s}" % (tex, exp)
2072         return tex
2073 
2074     def _print_bernoulli(self, expr, exp=None):
2075         return self.__print_number_polynomial(expr, "B", exp)
2076 
2077     def _print_bell(self, expr, exp=None):
2078         if len(expr.args) == 3:
2079             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2080                                 self._print(expr.args[1]))
2081             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2082                                                el in expr.args[2])
2083             if exp is not None:
2084                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2085             else:
2086                 tex = tex1 + tex2
2087             return tex
2088         return self.__print_number_polynomial(expr, "B", exp)
2089 
2090 
2091     def _print_fibonacci(self, expr, exp=None):
2092         return self.__print_number_polynomial(expr, "F", exp)
2093 
2094     def _print_lucas(self, expr, exp=None):
2095         tex = r"L_{%s}" % self._print(expr.args[0])
2096         if exp is not None:
2097             tex = r"%s^{%s}" % (tex, exp)
2098         return tex
2099 
2100     def _print_tribonacci(self, expr, exp=None):
2101         return self.__print_number_polynomial(expr, "T", exp)
2102 
2103     def _print_SeqFormula(self, s):
2104         dots = object()
2105         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2106             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2107                 self._print(s.formula),
2108                 self._print(s.variables[0]),
2109                 self._print(s.start),
2110                 self._print(s.stop)
2111             )
2112         if s.start is S.NegativeInfinity:
2113             stop = s.stop
2114             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2115                         s.coeff(stop - 1), s.coeff(stop))
2116         elif s.stop is S.Infinity or s.length > 4:
2117             printset = s[:4]
2118             printset.append(dots)
2119         else:
2120             printset = tuple(s)
2121 
2122         return (r"\left[" +
2123                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2124                 r"\right]")
2125 
2126     _print_SeqPer = _print_SeqFormula
2127     _print_SeqAdd = _print_SeqFormula
2128     _print_SeqMul = _print_SeqFormula
2129 
2130     def _print_Interval(self, i):
2131         if i.start == i.end:
2132             return r"\left\{%s\right\}" % self._print(i.start)
2133 
2134         else:
2135             if i.left_open:
2136                 left = '('
2137             else:
2138                 left = '['
2139 
2140             if i.right_open:
2141                 right = ')'
2142             else:
2143                 right = ']'
2144 
2145             return r"\left%s%s, %s\right%s" % \
2146                    (left, self._print(i.start), self._print(i.end), right)
2147 
2148     def _print_AccumulationBounds(self, i):
2149         return r"\left\langle %s, %s\right\rangle" % \
2150                 (self._print(i.min), self._print(i.max))
2151 
2152     def _print_Union(self, u):
2153         prec = precedence_traditional(u)
2154         args_str = [self.parenthesize(i, prec) for i in u.args]
2155         return r" \cup ".join(args_str)
2156 
2157     def _print_Complement(self, u):
2158         prec = precedence_traditional(u)
2159         args_str = [self.parenthesize(i, prec) for i in u.args]
2160         return r" \setminus ".join(args_str)
2161 
2162     def _print_Intersection(self, u):
2163         prec = precedence_traditional(u)
2164         args_str = [self.parenthesize(i, prec) for i in u.args]
2165         return r" \cap ".join(args_str)
2166 
2167     def _print_SymmetricDifference(self, u):
2168         prec = precedence_traditional(u)
2169         args_str = [self.parenthesize(i, prec) for i in u.args]
2170         return r" \triangle ".join(args_str)
2171 
2172     def _print_ProductSet(self, p):
2173         prec = precedence_traditional(p)
2174         if len(p.sets) >= 1 and not has_variety(p.sets):
2175             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2176         return r" \times ".join(
2177             self.parenthesize(set, prec) for set in p.sets)
2178 
2179     def _print_EmptySet(self, e):
2180         return r"\emptyset"
2181 
2182     def _print_Naturals(self, n):
2183         return r"\mathbb{N}"
2184 
2185     def _print_Naturals0(self, n):
2186         return r"\mathbb{N}_0"
2187 
2188     def _print_Integers(self, i):
2189         return r"\mathbb{Z}"
2190 
2191     def _print_Rationals(self, i):
2192         return r"\mathbb{Q}"
2193 
2194     def _print_Reals(self, i):
2195         return r"\mathbb{R}"
2196 
2197     def _print_Complexes(self, i):
2198         return r"\mathbb{C}"
2199 
2200     def _print_ImageSet(self, s):
2201         expr = s.lamda.expr
2202         sig = s.lamda.signature
2203         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2204         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2205         return r"\left\{%s\; \middle|\; %s\right\}" % (self._print(expr), xinys)
2206 
2207     def _print_ConditionSet(self, s):
2208         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2209         if s.base_set is S.UniversalSet:
2210             return r"\left\{%s\; \middle|\; %s \right\}" % \
2211                 (vars_print, self._print(s.condition))
2212 
2213         return r"\left\{%s\; \middle|\; %s \in %s \wedge %s \right\}" % (
2214             vars_print,
2215             vars_print,
2216             self._print(s.base_set),
2217             self._print(s.condition))
2218 
2219     def _print_ComplexRegion(self, s):
2220         vars_print = ', '.join([self._print(var) for var in s.variables])
2221         return r"\left\{%s\; \middle|\; %s \in %s \right\}" % (
2222             self._print(s.expr),
2223             vars_print,
2224             self._print(s.sets))
2225 
2226     def _print_Contains(self, e):
2227         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2228 
2229     def _print_FourierSeries(self, s):
2230         return self._print_Add(s.truncate()) + r' + \ldots'
2231 
2232     def _print_FormalPowerSeries(self, s):
2233         return self._print_Add(s.infinite)
2234 
2235     def _print_FiniteField(self, expr):
2236         return r"\mathbb{F}_{%s}" % expr.mod
2237 
2238     def _print_IntegerRing(self, expr):
2239         return r"\mathbb{Z}"
2240 
2241     def _print_RationalField(self, expr):
2242         return r"\mathbb{Q}"
2243 
2244     def _print_RealField(self, expr):
2245         return r"\mathbb{R}"
2246 
2247     def _print_ComplexField(self, expr):
2248         return r"\mathbb{C}"
2249 
2250     def _print_PolynomialRing(self, expr):
2251         domain = self._print(expr.domain)
2252         symbols = ", ".join(map(self._print, expr.symbols))
2253         return r"%s\left[%s\right]" % (domain, symbols)
2254 
2255     def _print_FractionField(self, expr):
2256         domain = self._print(expr.domain)
2257         symbols = ", ".join(map(self._print, expr.symbols))
2258         return r"%s\left(%s\right)" % (domain, symbols)
2259 
2260     def _print_PolynomialRingBase(self, expr):
2261         domain = self._print(expr.domain)
2262         symbols = ", ".join(map(self._print, expr.symbols))
2263         inv = ""
2264         if not expr.is_Poly:
2265             inv = r"S_<^{-1}"
2266         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2267 
2268     def _print_Poly(self, poly):
2269         cls = poly.__class__.__name__
2270         terms = []
2271         for monom, coeff in poly.terms():
2272             s_monom = ''
2273             for i, exp in enumerate(monom):
2274                 if exp > 0:
2275                     if exp == 1:
2276                         s_monom += self._print(poly.gens[i])
2277                     else:
2278                         s_monom += self._print(pow(poly.gens[i], exp))
2279 
2280             if coeff.is_Add:
2281                 if s_monom:
2282                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2283                 else:
2284                     s_coeff = self._print(coeff)
2285             else:
2286                 if s_monom:
2287                     if coeff is S.One:
2288                         terms.extend(['+', s_monom])
2289                         continue
2290 
2291                     if coeff is S.NegativeOne:
2292                         terms.extend(['-', s_monom])
2293                         continue
2294 
2295                 s_coeff = self._print(coeff)
2296 
2297             if not s_monom:
2298                 s_term = s_coeff
2299             else:
2300                 s_term = s_coeff + " " + s_monom
2301 
2302             if s_term.startswith('-'):
2303                 terms.extend(['-', s_term[1:]])
2304             else:
2305                 terms.extend(['+', s_term])
2306 
2307         if terms[0] in ['-', '+']:
2308             modifier = terms.pop(0)
2309 
2310             if modifier == '-':
2311                 terms[0] = '-' + terms[0]
2312 
2313         expr = ' '.join(terms)
2314         gens = list(map(self._print, poly.gens))
2315         domain = "domain=%s" % self._print(poly.get_domain())
2316 
2317         args = ", ".join([expr] + gens + [domain])
2318         if cls in accepted_latex_functions:
2319             tex = r"\%s {\left(%s \right)}" % (cls, args)
2320         else:
2321             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2322 
2323         return tex
2324 
2325     def _print_ComplexRootOf(self, root):
2326         cls = root.__class__.__name__
2327         if cls == "ComplexRootOf":
2328             cls = "CRootOf"
2329         expr = self._print(root.expr)
2330         index = root.index
2331         if cls in accepted_latex_functions:
2332             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2333         else:
2334             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2335                                                                  index)
2336 
2337     def _print_RootSum(self, expr):
2338         cls = expr.__class__.__name__
2339         args = [self._print(expr.expr)]
2340 
2341         if expr.fun is not S.IdentityFunction:
2342             args.append(self._print(expr.fun))
2343 
2344         if cls in accepted_latex_functions:
2345             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2346         else:
2347             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2348                                                              ", ".join(args))
2349 
2350     def _print_PolyElement(self, poly):
2351         mul_symbol = self._settings['mul_symbol_latex']
2352         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2353 
2354     def _print_FracElement(self, frac):
2355         if frac.denom == 1:
2356             return self._print(frac.numer)
2357         else:
2358             numer = self._print(frac.numer)
2359             denom = self._print(frac.denom)
2360             return r"\frac{%s}{%s}" % (numer, denom)
2361 
2362     def _print_euler(self, expr, exp=None):
2363         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2364         tex = r"E_{%s}" % self._print(m)
2365         if exp is not None:
2366             tex = r"%s^{%s}" % (tex, exp)
2367         if x is not None:
2368             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2369         return tex
2370 
2371     def _print_catalan(self, expr, exp=None):
2372         tex = r"C_{%s}" % self._print(expr.args[0])
2373         if exp is not None:
2374             tex = r"%s^{%s}" % (tex, exp)
2375         return tex
2376 
2377     def _print_UnifiedTransform(self, expr, s, inverse=False):
2378         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2379 
2380     def _print_MellinTransform(self, expr):
2381         return self._print_UnifiedTransform(expr, 'M')
2382 
2383     def _print_InverseMellinTransform(self, expr):
2384         return self._print_UnifiedTransform(expr, 'M', True)
2385 
2386     def _print_LaplaceTransform(self, expr):
2387         return self._print_UnifiedTransform(expr, 'L')
2388 
2389     def _print_InverseLaplaceTransform(self, expr):
2390         return self._print_UnifiedTransform(expr, 'L', True)
2391 
2392     def _print_FourierTransform(self, expr):
2393         return self._print_UnifiedTransform(expr, 'F')
2394 
2395     def _print_InverseFourierTransform(self, expr):
2396         return self._print_UnifiedTransform(expr, 'F', True)
2397 
2398     def _print_SineTransform(self, expr):
2399         return self._print_UnifiedTransform(expr, 'SIN')
2400 
2401     def _print_InverseSineTransform(self, expr):
2402         return self._print_UnifiedTransform(expr, 'SIN', True)
2403 
2404     def _print_CosineTransform(self, expr):
2405         return self._print_UnifiedTransform(expr, 'COS')
2406 
2407     def _print_InverseCosineTransform(self, expr):
2408         return self._print_UnifiedTransform(expr, 'COS', True)
2409 
2410     def _print_DMP(self, p):
2411         try:
2412             if p.ring is not None:
2413                 # TODO incorporate order
2414                 return self._print(p.ring.to_sympy(p))
2415         except SympifyError:
2416             pass
2417         return self._print(repr(p))
2418 
2419     def _print_DMF(self, p):
2420         return self._print_DMP(p)
2421 
2422     def _print_Object(self, object):
2423         return self._print(Symbol(object.name))
2424 
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))
2430 
2431     def _print_Morphism(self, morphism):
2432         domain = self._print(morphism.domain)
2433         codomain = self._print(morphism.codomain)
2434         return "%s\\rightarrow %s" % (domain, codomain)
2435 
2436     def _print_TransferFunction(self, expr):
2437         num, den = self._print(expr.num), self._print(expr.den)
2438         return r"\frac{%s}{%s}" % (num, den)
2439 
2440     def _print_Series(self, expr):
2441         args = list(expr.args)
2442         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2443                                             False)
2444         return ' '.join(map(parens, args))
2445 
2446     def _print_MIMOSeries(self, expr):
2447         from sympy.physics.control.lti import MIMOParallel
2448         args = list(expr.args)[::-1]
2449         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2450                                              False) if isinstance(x, MIMOParallel) else self._print(x)
2451         return r"\cdot".join(map(parens, args))
2452 
2453     def _print_Parallel(self, expr):
2454         args = list(expr.args)
2455         func = lambda x: self._print(x)
2456         return ' + '.join(map(func, args))
2457 
2458     def _print_MIMOParallel(self, expr):
2459         args = list(expr.args)
2460         func = lambda x: self._print(x)
2461         return ' + '.join(map(func, args))
2462 
2463     def _print_Feedback(self, expr):
2464         from sympy.physics.control import TransferFunction, Parallel, Series
2465 
2466         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2467         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2468         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2469 
2470         if isinstance(num, Series) and isinstance(expr.den, Series):
2471             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2472         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2473             if expr.den == tf:
2474                 den = Parallel(tf, Series(*num_arg_list))
2475             else:
2476                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2477         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2478             if num == tf:
2479                 den = Parallel(tf, Series(*den_arg_list))
2480             else:
2481                 den = Parallel(tf, Series(num, *den_arg_list))
2482         else:
2483             if num == tf:
2484                 den = Parallel(tf, *den_arg_list)
2485             elif expr.den == tf:
2486                 den = Parallel(tf, *num_arg_list)
2487             else:
2488                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2489 
2490         numer = self._print(num)
2491         denom = self._print(den)
2492         return r"\frac{%s}{%s}" % (numer, denom)
2493 
2494     def _print_TransferFunctionMatrix(self, expr):
2495         mat = self._print(expr._expr_mat)
2496         return r"%s_\tau" % mat
2497 
2498     def _print_NamedMorphism(self, morphism):
2499         pretty_name = self._print(Symbol(morphism.name))
2500         pretty_morphism = self._print_Morphism(morphism)
2501         return "%s:%s" % (pretty_name, pretty_morphism)
2502 
2503     def _print_IdentityMorphism(self, morphism):
2504         from sympy.categories import NamedMorphism
2505         return self._print_NamedMorphism(NamedMorphism(
2506             morphism.domain, morphism.codomain, "id"))
2507 
2508     def _print_CompositeMorphism(self, morphism):
2509         # All components of the morphism have names and it is thus
2510         # possible to build the name of the composite.
2511         component_names_list = [self._print(Symbol(component.name)) for
2512                                 component in morphism.components]
2513         component_names_list.reverse()
2514         component_names = "\\circ ".join(component_names_list) + ":"
2515 
2516         pretty_morphism = self._print_Morphism(morphism)
2517         return component_names + pretty_morphism
2518 
2519     def _print_Category(self, morphism):
2520         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2521 
2522     def _print_Diagram(self, diagram):
2523         if not diagram.premises:
2524             # This is an empty diagram.
2525             return self._print(S.EmptySet)
2526 
2527         latex_result = self._print(diagram.premises)
2528         if diagram.conclusions:
2529             latex_result += "\\Longrightarrow %s" % \
2530                             self._print(diagram.conclusions)
2531 
2532         return latex_result
2533 
2534     def _print_DiagramGrid(self, grid):
2535         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2536 
2537         for i in range(grid.height):
2538             for j in range(grid.width):
2539                 if grid[i, j]:
2540                     latex_result += latex(grid[i, j])
2541                 latex_result += " "
2542                 if j != grid.width - 1:
2543                     latex_result += "& "
2544 
2545             if i != grid.height - 1:
2546                 latex_result += "\\\\"
2547             latex_result += "\n"
2548 
2549         latex_result += "\\end{array}\n"
2550         return latex_result
2551 
2552     def _print_FreeModule(self, M):
2553         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2554 
2555     def _print_FreeModuleElement(self, m):
2556         # Print as row vector for convenience, for now.
2557         return r"\left[ {} \right]".format(",".join(
2558             '{' + self._print(x) + '}' for x in m))
2559 
2560     def _print_SubModule(self, m):
2561         return r"\left\langle {} \right\rangle".format(",".join(
2562             '{' + self._print(x) + '}' for x in m.gens))
2563 
2564     def _print_ModuleImplementedIdeal(self, m):
2565         return r"\left\langle {} \right\rangle".format(",".join(
2566             '{' + self._print(x) + '}' for [x] in m._module.gens))
2567 
2568     def _print_Quaternion(self, expr):
2569         # TODO: This expression is potentially confusing,
2570         # shall we print it as `Quaternion( ... )`?
2571         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2572              for i in expr.args]
2573         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2574         return " + ".join(a)
2575 
2576     def _print_QuotientRing(self, R):
2577         # TODO nicer fractions for few generators...
2578         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2579                  self._print(R.base_ideal))
2580 
2581     def _print_QuotientRingElement(self, x):
2582         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2583                  self._print(x.ring.base_ideal))
2584 
2585     def _print_QuotientModuleElement(self, m):
2586         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2587                  self._print(m.module.killed_module))
2588 
2589     def _print_QuotientModule(self, M):
2590         # TODO nicer fractions for few generators...
2591         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2592                  self._print(M.killed_module))
2593 
2594     def _print_MatrixHomomorphism(self, h):
2595         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2596             self._print(h.domain), self._print(h.codomain))
2597 
2598     def _print_Manifold(self, manifold):
2599         string = manifold.name.name
2600         if '{' in string:
2601             name, supers, subs = string, [], []
2602         else:
2603             name, supers, subs = split_super_sub(string)
2604 
2605             name = translate(name)
2606             supers = [translate(sup) for sup in supers]
2607             subs = [translate(sub) for sub in subs]
2608 
2609         name = r'\text{%s}' % name
2610         if supers:
2611             name += "^{%s}" % " ".join(supers)
2612         if subs:
2613             name += "_{%s}" % " ".join(subs)
2614 
2615         return name
2616 
2617     def _print_Patch(self, patch):
2618         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2619 
2620     def _print_CoordSystem(self, coordsys):
2621         return r'\text{%s}^{\text{%s}}_{%s}' % (
2622             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2623         )
2624 
2625     def _print_CovarDerivativeOp(self, cvd):
2626         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2627 
2628     def _print_BaseScalarField(self, field):
2629         string = field._coord_sys.symbols[field._index].name
2630         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2631 
2632     def _print_BaseVectorField(self, field):
2633         string = field._coord_sys.symbols[field._index].name
2634         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2635 
2636     def _print_Differential(self, diff):
2637         field = diff._form_field
2638         if hasattr(field, '_coord_sys'):
2639             string = field._coord_sys.symbols[field._index].name
2640             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2641         else:
2642             string = self._print(field)
2643             return r'\operatorname{{d}}\left({}\right)'.format(string)
2644 
2645     def _print_Tr(self, p):
2646         # TODO: Handle indices
2647         contents = self._print(p.args[0])
2648         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2649 
2650     def _print_totient(self, expr, exp=None):
2651         if exp is not None:
2652             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2653                 (self._print(expr.args[0]), exp)
2654         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2655 
2656     def _print_reduced_totient(self, expr, exp=None):
2657         if exp is not None:
2658             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2659                 (self._print(expr.args[0]), exp)
2660         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2661 
2662     def _print_divisor_sigma(self, expr, exp=None):
2663         if len(expr.args) == 2:
2664             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2665                                                 (expr.args[1], expr.args[0])))
2666         else:
2667             tex = r"\left(%s\right)" % self._print(expr.args[0])
2668         if exp is not None:
2669             return r"\sigma^{%s}%s" % (exp, tex)
2670         return r"\sigma%s" % tex
2671 
2672     def _print_udivisor_sigma(self, expr, exp=None):
2673         if len(expr.args) == 2:
2674             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2675                                                 (expr.args[1], expr.args[0])))
2676         else:
2677             tex = r"\left(%s\right)" % self._print(expr.args[0])
2678         if exp is not None:
2679             return r"\sigma^*^{%s}%s" % (exp, tex)
2680         return r"\sigma^*%s" % tex
2681 
2682     def _print_primenu(self, expr, exp=None):
2683         if exp is not None:
2684             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2685                 (self._print(expr.args[0]), exp)
2686         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2687 
2688     def _print_primeomega(self, expr, exp=None):
2689         if exp is not None:
2690             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2691                 (self._print(expr.args[0]), exp)
2692         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2693 
2694     def _print_Str(self, s):
2695         return str(s.name)
2696 
2697     def _print_float(self, expr):
2698         return self._print(Float(expr))
2699 
2700     def _print_int(self, expr):
2701         return str(expr)
2702 
2703     def _print_mpz(self, expr):
2704         return str(expr)
2705 
2706     def _print_mpq(self, expr):
2707         return str(expr)
2708 
2709     def _print_Predicate(self, expr):
2710         return str(expr)
2711 
2712     def _print_AppliedPredicate(self, expr):
2713         pred = expr.function
2714         args = expr.arguments
2715         pred_latex = self._print(pred)
2716         args_latex = ', '.join([self._print(a) for a in args])
2717         return '%s(%s)' % (pred_latex, args_latex)
2718 
2719     def emptyPrinter(self, expr):
2720         # default to just printing as monospace, like would normally be shown
2721         s = super().emptyPrinter(expr)
2722 
2723         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 21:47:28.965 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Pow</method>
<code>
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)

</code><intended_behavior>The `_print_Pow` method should be adapted to handle function bases that do not accept an `exp` keyword argument. Specifically, for the `LambertW` function, the method should avoid passing the `exp` argument directly and instead implement a way to correctly format the power operation in LaTeX. One approach could be checking if the base is an instance of `LambertW` (or any other function with similar constraints) and then handle the exponent separately in a manner that aligns with LaTeX standards without violating the method signatures of specific print functions like `_print_LambertW`. This preserves the existing functionality for other functions and cases while providing a tailored handling for `LambertW` and potentially similar future cases.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_Exp1(self, expr, exp=None):
1113         return "e"
1114 
1115     def _print_elliptic_k(self, expr, exp=None):
1116         tex = r"\left(%s\right)" % self._print(expr.args[0])
1117         if exp is not None:
1118             return r"K^{%s}%s" % (exp, tex)
1119         else:
1120             return r"K%s" % tex
1121 
1122     def _print_elliptic_f(self, expr, exp=None):
1123         tex = r"\left(%s\middle| %s\right)" % \
1124             (self._print(expr.args[0]), self._print(expr.args[1]))
1125         if exp is not None:
1126             return r"F^{%s}%s" % (exp, tex)
1127         else:
1128             return r"F%s" % tex
1129 
1130     def _print_elliptic_e(self, expr, exp=None):
1131         if len(expr.args) == 2:
1132             tex = r"\left(%s\middle| %s\right)" % \
1133                 (self._print(expr.args[0]), self._print(expr.args[1]))
1134         else:
1135             tex = r"\left(%s\right)" % self._print(expr.args[0])
1136         if exp is not None:
1137             return r"E^{%s}%s" % (exp, tex)
1138         else:
1139             return r"E%s" % tex
1140 
1141     def _print_elliptic_pi(self, expr, exp=None):
1142         if len(expr.args) == 3:
1143             tex = r"\left(%s; %s\middle| %s\right)" % \
1144                 (self._print(expr.args[0]), self._print(expr.args[1]),
1145                  self._print(expr.args[2]))
1146         else:
1147             tex = r"\left(%s\middle| %s\right)" % \
1148                 (self._print(expr.args[0]), self._print(expr.args[1]))
1149         if exp is not None:
1150             return r"\Pi^{%s}%s" % (exp, tex)
1151         else:
1152             return r"\Pi%s" % tex
1153 
1154     def _print_beta(self, expr, exp=None):
1155         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1156                                         self._print(expr.args[1]))
1157 
1158         if exp is not None:
1159             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1160         else:
1161             return r"\operatorname{B}%s" % tex
1162 
1163     def _print_betainc(self, expr, exp=None, operator='B'):
1164         largs = [self._print(arg) for arg in expr.args]
1165         tex = r"\left(%s, %s\right)" % (largs[0], largs[1])
1166 
1167         if exp is not None:
1168             return r"\operatorname{%s}_{(%s, %s)}^{%s}%s" % (operator, largs[2], largs[3], exp, tex)
1169         else:
1170             return r"\operatorname{%s}_{(%s, %s)}%s" % (operator, largs[2], largs[3], tex)
1171 
1172     def _print_betainc_regularized(self, expr, exp=None):
1173         return self._print_betainc(expr, exp, operator='I')
1174 
1175     def _print_uppergamma(self, expr, exp=None):
1176         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1177                                         self._print(expr.args[1]))
1178 
1179         if exp is not None:
1180             return r"\Gamma^{%s}%s" % (exp, tex)
1181         else:
1182             return r"\Gamma%s" % tex
1183 
1184     def _print_lowergamma(self, expr, exp=None):
1185         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1186                                         self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"\gamma^{%s}%s" % (exp, tex)
1190         else:
1191             return r"\gamma%s" % tex
1192 
1193     def _hprint_one_arg_func(self, expr, exp=None):
1194         tex = r"\left(%s\right)" % self._print(expr.args[0])
1195 
1196         if exp is not None:
1197             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1198         else:
1199             return r"%s%s" % (self._print(expr.func), tex)
1200 
1201     _print_gamma = _hprint_one_arg_func
1202 
1203     def _print_Chi(self, expr, exp=None):
1204         tex = r"\left(%s\right)" % self._print(expr.args[0])
1205 
1206         if exp is not None:
1207             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1208         else:
1209             return r"\operatorname{Chi}%s" % tex
1210 
1211     def _print_expint(self, expr, exp=None):
1212         tex = r"\left(%s\right)" % self._print(expr.args[1])
1213         nu = self._print(expr.args[0])
1214 
1215         if exp is not None:
1216             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1217         else:
1218             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1219 
1220     def _print_fresnels(self, expr, exp=None):
1221         tex = r"\left(%s\right)" % self._print(expr.args[0])
1222 
1223         if exp is not None:
1224             return r"S^{%s}%s" % (exp, tex)
1225         else:
1226             return r"S%s" % tex
1227 
1228     def _print_fresnelc(self, expr, exp=None):
1229         tex = r"\left(%s\right)" % self._print(expr.args[0])
1230 
1231         if exp is not None:
1232             return r"C^{%s}%s" % (exp, tex)
1233         else:
1234             return r"C%s" % tex
1235 
1236     def _print_subfactorial(self, expr, exp=None):
1237         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1238 
1239         if exp is not None:
1240             return r"\left(%s\right)^{%s}" % (tex, exp)
1241         else:
1242             return tex
1243 
1244     def _print_factorial(self, expr, exp=None):
1245         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1246 
1247         if exp is not None:
1248             return r"%s^{%s}" % (tex, exp)
1249         else:
1250             return tex
1251 
1252     def _print_factorial2(self, expr, exp=None):
1253         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1254 
1255         if exp is not None:
1256             return r"%s^{%s}" % (tex, exp)
1257         else:
1258             return tex
1259 
1260     def _print_binomial(self, expr, exp=None):
1261         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1262                                      self._print(expr.args[1]))
1263 
1264         if exp is not None:
1265             return r"%s^{%s}" % (tex, exp)
1266         else:
1267             return tex
1268 
1269     def _print_RisingFactorial(self, expr, exp=None):
1270         n, k = expr.args
1271         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1272 
1273         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1274 
1275         return self._do_exponent(tex, exp)
1276 
1277     def _print_FallingFactorial(self, expr, exp=None):
1278         n, k = expr.args
1279         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1280 
1281         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1282 
1283         return self._do_exponent(tex, exp)
1284 
1285     def _hprint_BesselBase(self, expr, exp, sym):
1286         tex = r"%s" % (sym)
1287 
1288         need_exp = False
1289         if exp is not None:
1290             if tex.find('^') == -1:
1291                 tex = r"%s^{%s}" % (tex, exp)
1292             else:
1293                 need_exp = True
1294 
1295         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1296                                            self._print(expr.argument))
1297 
1298         if need_exp:
1299             tex = self._do_exponent(tex, exp)
1300         return tex
1301 
1302     def _hprint_vec(self, vec):
1303         if not vec:
1304             return ""
1305         s = ""
1306         for i in vec[:-1]:
1307             s += "%s, " % self._print(i)
1308         s += self._print(vec[-1])
1309         return s
1310 
1311     def _print_besselj(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'J')
1313 
1314     def _print_besseli(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'I')
1316 
1317     def _print_besselk(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'K')
1319 
1320     def _print_bessely(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'Y')
1322 
1323     def _print_yn(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'y')
1325 
1326     def _print_jn(self, expr, exp=None):
1327         return self._hprint_BesselBase(expr, exp, 'j')
1328 
1329     def _print_hankel1(self, expr, exp=None):
1330         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1331 
1332     def _print_hankel2(self, expr, exp=None):
1333         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1334 
1335     def _print_hn1(self, expr, exp=None):
1336         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1337 
1338     def _print_hn2(self, expr, exp=None):
1339         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1340 
1341     def _hprint_airy(self, expr, exp=None, notation=""):
1342         tex = r"\left(%s\right)" % self._print(expr.args[0])
1343 
1344         if exp is not None:
1345             return r"%s^{%s}%s" % (notation, exp, tex)
1346         else:
1347             return r"%s%s" % (notation, tex)
1348 
1349     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1350         tex = r"\left(%s\right)" % self._print(expr.args[0])
1351 
1352         if exp is not None:
1353             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1354         else:
1355             return r"%s^\prime%s" % (notation, tex)
1356 
1357     def _print_airyai(self, expr, exp=None):
1358         return self._hprint_airy(expr, exp, 'Ai')
1359 
1360     def _print_airybi(self, expr, exp=None):
1361         return self._hprint_airy(expr, exp, 'Bi')
1362 
1363     def _print_airyaiprime(self, expr, exp=None):
1364         return self._hprint_airy_prime(expr, exp, 'Ai')
1365 
1366     def _print_airybiprime(self, expr, exp=None):
1367         return self._hprint_airy_prime(expr, exp, 'Bi')
1368 
1369     def _print_hyper(self, expr, exp=None):
1370         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1371               r"\middle| {%s} \right)}" % \
1372             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1373               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1374               self._print(expr.argument))
1375 
1376         if exp is not None:
1377             tex = r"{%s}^{%s}" % (tex, exp)
1378         return tex
1379 
1380     def _print_meijerg(self, expr, exp=None):
1381         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1382               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1383             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1384               self._print(len(expr.bm)), self._print(len(expr.an)),
1385               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1386               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1387               self._print(expr.argument))
1388 
1389         if exp is not None:
1390             tex = r"{%s}^{%s}" % (tex, exp)
1391         return tex
1392 
1393     def _print_dirichlet_eta(self, expr, exp=None):
1394         tex = r"\left(%s\right)" % self._print(expr.args[0])
1395         if exp is not None:
1396             return r"\eta^{%s}%s" % (exp, tex)
1397         return r"\eta%s" % tex
1398 
1399     def _print_zeta(self, expr, exp=None):
1400         if len(expr.args) == 2:
1401             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1402         else:
1403             tex = r"\left(%s\right)" % self._print(expr.args[0])
1404         if exp is not None:
1405             return r"\zeta^{%s}%s" % (exp, tex)
1406         return r"\zeta%s" % tex
1407 
1408     def _print_stieltjes(self, expr, exp=None):
1409         if len(expr.args) == 2:
1410             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1411         else:
1412             tex = r"_{%s}" % self._print(expr.args[0])
1413         if exp is not None:
1414             return r"\gamma%s^{%s}" % (tex, exp)
1415         return r"\gamma%s" % tex
1416 
1417     def _print_lerchphi(self, expr, exp=None):
1418         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1419         if exp is None:
1420             return r"\Phi%s" % tex
1421         return r"\Phi^{%s}%s" % (exp, tex)
1422 
1423     def _print_polylog(self, expr, exp=None):
1424         s, z = map(self._print, expr.args)
1425         tex = r"\left(%s\right)" % z
1426         if exp is None:
1427             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1428         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1429 
1430     def _print_jacobi(self, expr, exp=None):
1431         n, a, b, x = map(self._print, expr.args)
1432         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1433         if exp is not None:
1434             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1435         return tex
1436 
1437     def _print_gegenbauer(self, expr, exp=None):
1438         n, a, x = map(self._print, expr.args)
1439         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1440         if exp is not None:
1441             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1442         return tex
1443 
1444     def _print_chebyshevt(self, expr, exp=None):
1445         n, x = map(self._print, expr.args)
1446         tex = r"T_{%s}\left(%s\right)" % (n, x)
1447         if exp is not None:
1448             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1449         return tex
1450 
1451     def _print_chebyshevu(self, expr, exp=None):
1452         n, x = map(self._print, expr.args)
1453         tex = r"U_{%s}\left(%s\right)" % (n, x)
1454         if exp is not None:
1455             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1456         return tex
1457 
1458     def _print_legendre(self, expr, exp=None):
1459         n, x = map(self._print, expr.args)
1460         tex = r"P_{%s}\left(%s\right)" % (n, x)
1461         if exp is not None:
1462             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1463         return tex
1464 
1465     def _print_assoc_legendre(self, expr, exp=None):
1466         n, a, x = map(self._print, expr.args)
1467         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1468         if exp is not None:
1469             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1470         return tex
1471 
1472     def _print_hermite(self, expr, exp=None):
1473         n, x = map(self._print, expr.args)
1474         tex = r"H_{%s}\left(%s\right)" % (n, x)
1475         if exp is not None:
1476             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1477         return tex
1478 
1479     def _print_laguerre(self, expr, exp=None):
1480         n, x = map(self._print, expr.args)
1481         tex = r"L_{%s}\left(%s\right)" % (n, x)
1482         if exp is not None:
1483             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1484         return tex
1485 
1486     def _print_assoc_laguerre(self, expr, exp=None):
1487         n, a, x = map(self._print, expr.args)
1488         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1489         if exp is not None:
1490             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1491         return tex
1492 
1493     def _print_Ynm(self, expr, exp=None):
1494         n, m, theta, phi = map(self._print, expr.args)
1495         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1496         if exp is not None:
1497             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1498         return tex
1499 
1500     def _print_Znm(self, expr, exp=None):
1501         n, m, theta, phi = map(self._print, expr.args)
1502         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1503         if exp is not None:
1504             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1505         return tex
1506 
1507     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1508         a, q, z = map(self._print, args)
1509         sup = r"^{\prime}" if prime else ""
1510         exp = "" if not exp else "^{%s}" % exp
1511         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1512 
1513     def _print_mathieuc(self, expr, exp=None):
1514         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1515 
1516     def _print_mathieus(self, expr, exp=None):
1517         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1518 
1519     def _print_mathieucprime(self, expr, exp=None):
1520         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1521 
1522     def _print_mathieusprime(self, expr, exp=None):
1523         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1524 
1525     def _print_Rational(self, expr):
1526         if expr.q != 1:
1527             sign = ""
1528             p = expr.p
1529             if expr.p < 0:
1530                 sign = "- "
1531                 p = -p
1532             if self._settings['fold_short_frac']:
1533                 return r"%s%d / %d" % (sign, p, expr.q)
1534             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1535         else:
1536             return self._print(expr.p)
1537 
1538     def _print_Order(self, expr):
1539         s = self._print(expr.expr)
1540         if expr.point and any(p != S.Zero for p in expr.point) or \
1541            len(expr.variables) > 1:
1542             s += '; '
1543             if len(expr.variables) > 1:
1544                 s += self._print(expr.variables)
1545             elif expr.variables:
1546                 s += self._print(expr.variables[0])
1547             s += r'\rightarrow '
1548             if len(expr.point) > 1:
1549                 s += self._print(expr.point)
1550             else:
1551                 s += self._print(expr.point[0])
1552         return r"O\left(%s\right)" % s
1553 
1554     def _print_Symbol(self, expr, style='plain'):
1555         if expr in self._settings['symbol_names']:
1556             return self._settings['symbol_names'][expr]
1557 
1558         return self._deal_with_super_sub(expr.name, style=style)
1559 
1560     _print_RandomSymbol = _print_Symbol
1561 
1562     def _deal_with_super_sub(self, string, style='plain'):
1563         if '{' in string:
1564             name, supers, subs = string, [], []
1565         else:
1566             name, supers, subs = split_super_sub(string)
1567 
1568             name = translate(name)
1569             supers = [translate(sup) for sup in supers]
1570             subs = [translate(sub) for sub in subs]
1571 
1572         # apply the style only to the name
1573         if style == 'bold':
1574             name = "\\mathbf{{{}}}".format(name)
1575 
1576         # glue all items together:
1577         if supers:
1578             name += "^{%s}" % " ".join(supers)
1579         if subs:
1580             name += "_{%s}" % " ".join(subs)
1581 
1582         return name
1583 
1584     def _print_Relational(self, expr):
1585         if self._settings['itex']:
1586             gt = r"\gt"
1587             lt = r"\lt"
1588         else:
1589             gt = ">"
1590             lt = "<"
1591 
1592         charmap = {
1593             "==": "=",
1594             ">": gt,
1595             "<": lt,
1596             ">=": r"\geq",
1597             "<=": r"\leq",
1598             "!=": r"\neq",
1599         }
1600 
1601         return "%s %s %s" % (self._print(expr.lhs),
1602                              charmap[expr.rel_op], self._print(expr.rhs))
1603 
1604     def _print_Piecewise(self, expr):
1605         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1606                    for e, c in expr.args[:-1]]
1607         if expr.args[-1].cond == true:
1608             ecpairs.append(r"%s & \text{otherwise}" %
1609                            self._print(expr.args[-1].expr))
1610         else:
1611             ecpairs.append(r"%s & \text{for}\: %s" %
1612                            (self._print(expr.args[-1].expr),
1613                             self._print(expr.args[-1].cond)))
1614         tex = r"\begin{cases} %s \end{cases}"
1615         return tex % r" \\".join(ecpairs)
1616 
1617     def _print_MatrixBase(self, expr):
1618         lines = []
1619 
1620         for line in range(expr.rows):  # horrible, should be 'rows'
1621             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1622 
1623         mat_str = self._settings['mat_str']
1624         if mat_str is None:
1625             if self._settings['mode'] == 'inline':
1626                 mat_str = 'smallmatrix'
1627             else:
1628                 if (expr.cols <= 10) is True:
1629                     mat_str = 'matrix'
1630                 else:
1631                     mat_str = 'array'
1632 
1633         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1634         out_str = out_str.replace('%MATSTR%', mat_str)
1635         if mat_str == 'array':
1636             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1637         if self._settings['mat_delim']:
1638             left_delim = self._settings['mat_delim']
1639             right_delim = self._delim_dict[left_delim]
1640             out_str = r'\left' + left_delim + out_str + \
1641                       r'\right' + right_delim
1642         return out_str % r"\\".join(lines)
1643 
1644     def _print_MatrixElement(self, expr):
1645         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1646             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1647 
1648     def _print_MatrixSlice(self, expr):
1649         def latexslice(x, dim):
1650             x = list(x)
1651             if x[2] == 1:
1652                 del x[2]
1653             if x[0] == 0:
1654                 x[0] = None
1655             if x[1] == dim:
1656                 x[1] = None
1657             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1658         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1659                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1660                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1661 
1662     def _print_BlockMatrix(self, expr):
1663         return self._print(expr.blocks)
1664 
1665     def _print_Transpose(self, expr):
1666         mat = expr.arg
1667         from sympy.matrices import MatrixSymbol
1668         if not isinstance(mat, MatrixSymbol):
1669             return r"\left(%s\right)^{T}" % self._print(mat)
1670         else:
1671             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1672 
1673     def _print_Trace(self, expr):
1674         mat = expr.arg
1675         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1676 
1677     def _print_Adjoint(self, expr):
1678         mat = expr.arg
1679         from sympy.matrices import MatrixSymbol
1680         if not isinstance(mat, MatrixSymbol):
1681             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1682         else:
1683             return r"%s^{\dagger}" % self._print(mat)
1684 
1685     def _print_MatMul(self, expr):
1686         from sympy import MatMul, Mul
1687 
1688         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1689                                              False)
1690 
1691         args = expr.args
1692         if isinstance(args[0], Mul):
1693             args = args[0].as_ordered_factors() + list(args[1:])
1694         else:
1695             args = list(args)
1696 
1697         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1698             if args[0] == -1:
1699                 args = args[1:]
1700             else:
1701                 args[0] = -args[0]
1702             return '- ' + ' '.join(map(parens, args))
1703         else:
1704             return ' '.join(map(parens, args))
1705 
1706     def _print_Mod(self, expr, exp=None):
1707         if exp is not None:
1708             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1709                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1710                                    strict=True), self._print(expr.args[1]),
1711                  exp)
1712         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1713                                  PRECEDENCE['Mul'], strict=True),
1714                                  self._print(expr.args[1]))
1715 
1716     def _print_HadamardProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \circ '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_HadamardPower(self, expr):
1725         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1726             template = r"%s^{\circ \left({%s}\right)}"
1727         else:
1728             template = r"%s^{\circ {%s}}"
1729         return self._helper_print_standard_power(expr, template)
1730 
1731     def _print_KroneckerProduct(self, expr):
1732         args = expr.args
1733         prec = PRECEDENCE['Pow']
1734         parens = self.parenthesize
1735 
1736         return r' \otimes '.join(
1737             map(lambda arg: parens(arg, prec, strict=True), args))
1738 
1739     def _print_MatPow(self, expr):
1740         base, exp = expr.base, expr.exp
1741         from sympy.matrices import MatrixSymbol
1742         if not isinstance(base, MatrixSymbol):
1743             return "\\left(%s\\right)^{%s}" % (self._print(base),
1744                                               self._print(exp))
1745         else:
1746             return "%s^{%s}" % (self._print(base), self._print(exp))
1747 
1748     def _print_MatrixSymbol(self, expr):
1749         return self._print_Symbol(expr, style=self._settings[
1750             'mat_symbol_style'])
1751 
1752     def _print_ZeroMatrix(self, Z):
1753         return r"\mathbb{0}" if self._settings[
1754             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1755 
1756     def _print_OneMatrix(self, O):
1757         return r"\mathbb{1}" if self._settings[
1758             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1759 
1760     def _print_Identity(self, I):
1761         return r"\mathbb{I}" if self._settings[
1762             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1763 
1764     def _print_PermutationMatrix(self, P):
1765         perm_str = self._print(P.args[0])
1766         return "P_{%s}" % perm_str
1767 
1768     def _print_NDimArray(self, expr):
1769 
1770         if expr.rank() == 0:
1771             return self._print(expr[()])
1772 
1773         mat_str = self._settings['mat_str']
1774         if mat_str is None:
1775             if self._settings['mode'] == 'inline':
1776                 mat_str = 'smallmatrix'
1777             else:
1778                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1779                     mat_str = 'matrix'
1780                 else:
1781                     mat_str = 'array'
1782         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1783         block_str = block_str.replace('%MATSTR%', mat_str)
1784         if self._settings['mat_delim']:
1785             left_delim = self._settings['mat_delim']
1786             right_delim = self._delim_dict[left_delim]
1787             block_str = r'\left' + left_delim + block_str + \
1788                         r'\right' + right_delim
1789 
1790         if expr.rank() == 0:
1791             return block_str % ""
1792 
1793         level_str = [[]] + [[] for i in range(expr.rank())]
1794         shape_ranges = [list(range(i)) for i in expr.shape]
1795         for outer_i in itertools.product(*shape_ranges):
1796             level_str[-1].append(self._print(expr[outer_i]))
1797             even = True
1798             for back_outer_i in range(expr.rank()-1, -1, -1):
1799                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1800                     break
1801                 if even:
1802                     level_str[back_outer_i].append(
1803                         r" & ".join(level_str[back_outer_i+1]))
1804                 else:
1805                     level_str[back_outer_i].append(
1806                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1807                     if len(level_str[back_outer_i+1]) == 1:
1808                         level_str[back_outer_i][-1] = r"\left[" + \
1809                             level_str[back_outer_i][-1] + r"\right]"
1810                 even = not even
1811                 level_str[back_outer_i+1] = []
1812 
1813         out_str = level_str[0][0]
1814 
1815         if expr.rank() % 2 == 1:
1816             out_str = block_str % out_str
1817 
1818         return out_str
1819 
1820     def _printer_tensor_indices(self, name, indices, index_map={}):
1821         out_str = self._print(name)
1822         last_valence = None
1823         prev_map = None
1824         for index in indices:
1825             new_valence = index.is_up
1826             if ((index in index_map) or prev_map) and \
1827                     last_valence == new_valence:
1828                 out_str += ","
1829             if last_valence != new_valence:
1830                 if last_valence is not None:
1831                     out_str += "}"
1832                 if index.is_up:
1833                     out_str += "{}^{"
1834                 else:
1835                     out_str += "{}_{"
1836             out_str += self._print(index.args[0])
1837             if index in index_map:
1838                 out_str += "="
1839                 out_str += self._print(index_map[index])
1840                 prev_map = True
1841             else:
1842                 prev_map = False
1843             last_valence = new_valence
1844         if last_valence is not None:
1845             out_str += "}"
1846         return out_str
1847 
1848     def _print_Tensor(self, expr):
1849         name = expr.args[0].args[0]
1850         indices = expr.get_indices()
1851         return self._printer_tensor_indices(name, indices)
1852 
1853     def _print_TensorElement(self, expr):
1854         name = expr.expr.args[0].args[0]
1855         indices = expr.expr.get_indices()
1856         index_map = expr.index_map
1857         return self._printer_tensor_indices(name, indices, index_map)
1858 
1859     def _print_TensMul(self, expr):
1860         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1861         sign, args = expr._get_args_for_traditional_printer()
1862         return sign + "".join(
1863             [self.parenthesize(arg, precedence(expr)) for arg in args]
1864         )
1865 
1866     def _print_TensAdd(self, expr):
1867         a = []
1868         args = expr.args
1869         for x in args:
1870             a.append(self.parenthesize(x, precedence(expr)))
1871         a.sort()
1872         s = ' + '.join(a)
1873         s = s.replace('+ -', '- ')
1874         return s
1875 
1876     def _print_TensorIndex(self, expr):
1877         return "{}%s{%s}" % (
1878             "^" if expr.is_up else "_",
1879             self._print(expr.args[0])
1880         )
1881 
1882     def _print_PartialDerivative(self, expr):
1883         if len(expr.variables) == 1:
1884             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1885                 self._print(expr.variables[0]),
1886                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1887             )
1888         else:
1889             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1890                 len(expr.variables),
1891                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1892                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1893             )
1894 
1895     def _print_ArraySymbol(self, expr):
1896         return self._print(expr.name)
1897 
1898     def _print_ArrayElement(self, expr):
1899         return "{{%s}_{%s}}" % (expr.name, ", ".join([f"{self._print(i)}" for i in expr.indices]))
1900 
1901     def _print_UniversalSet(self, expr):
1902         return r"\mathbb{U}"
1903 
1904     def _print_frac(self, expr, exp=None):
1905         if exp is None:
1906             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1907         else:
1908             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1909                     self._print(expr.args[0]), exp)
1910 
1911     def _print_tuple(self, expr):
1912         if self._settings['decimal_separator'] == 'comma':
1913             sep = ";"
1914         elif self._settings['decimal_separator'] == 'period':
1915             sep = ","
1916         else:
1917             raise ValueError('Unknown Decimal Separator')
1918 
1919         if len(expr) == 1:
1920             # 1-tuple needs a trailing separator
1921             return self._add_parens_lspace(self._print(expr[0]) + sep)
1922         else:
1923             return self._add_parens_lspace(
1924                 (sep + r" \  ").join([self._print(i) for i in expr]))
1925 
1926     def _print_TensorProduct(self, expr):
1927         elements = [self._print(a) for a in expr.args]
1928         return r' \otimes '.join(elements)
1929 
1930     def _print_WedgeProduct(self, expr):
1931         elements = [self._print(a) for a in expr.args]
1932         return r' \wedge '.join(elements)
1933 
1934     def _print_Tuple(self, expr):
1935         return self._print_tuple(expr)
1936 
1937     def _print_list(self, expr):
1938         if self._settings['decimal_separator'] == 'comma':
1939             return r"\left[ %s\right]" % \
1940                 r"; \  ".join([self._print(i) for i in expr])
1941         elif self._settings['decimal_separator'] == 'period':
1942             return r"\left[ %s\right]" % \
1943                 r", \  ".join([self._print(i) for i in expr])
1944         else:
1945             raise ValueError('Unknown Decimal Separator')
1946 
1947 
1948     def _print_dict(self, d):
1949         keys = sorted(d.keys(), key=default_sort_key)
1950         items = []
1951 
1952         for key in keys:
1953             val = d[key]
1954             items.append("%s : %s" % (self._print(key), self._print(val)))
1955 
1956         return r"\left\{ %s\right\}" % r", \  ".join(items)
1957 
1958     def _print_Dict(self, expr):
1959         return self._print_dict(expr)
1960 
1961     def _print_DiracDelta(self, expr, exp=None):
1962         if len(expr.args) == 1 or expr.args[1] == 0:
1963             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1964         else:
1965             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1966                 self._print(expr.args[1]), self._print(expr.args[0]))
1967         if exp:
1968             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1969         return tex
1970 
1971     def _print_SingularityFunction(self, expr, exp=None):
1972         shift = self._print(expr.args[0] - expr.args[1])
1973         power = self._print(expr.args[2])
1974         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1975         if exp is not None:
1976             tex = r"{\left({\langle %s \rangle}^{%s}\right)}^{%s}" % (shift, power, exp)
1977         return tex
1978 
1979     def _print_Heaviside(self, expr, exp=None):
1980         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1981         if exp:
1982             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1983         return tex
1984 
1985     def _print_KroneckerDelta(self, expr, exp=None):
1986         i = self._print(expr.args[0])
1987         j = self._print(expr.args[1])
1988         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1989             tex = r'\delta_{%s %s}' % (i, j)
1990         else:
1991             tex = r'\delta_{%s, %s}' % (i, j)
1992         if exp is not None:
1993             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1994         return tex
1995 
1996     def _print_LeviCivita(self, expr, exp=None):
1997         indices = map(self._print, expr.args)
1998         if all(x.is_Atom for x in expr.args):
1999             tex = r'\varepsilon_{%s}' % " ".join(indices)
2000         else:
2001             tex = r'\varepsilon_{%s}' % ", ".join(indices)
2002         if exp:
2003             tex = r'\left(%s\right)^{%s}' % (tex, exp)
2004         return tex
2005 
2006     def _print_RandomDomain(self, d):
2007         if hasattr(d, 'as_boolean'):
2008             return '\\text{Domain: }' + self._print(d.as_boolean())
2009         elif hasattr(d, 'set'):
2010             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
2011                     self._print(d.set))
2012         elif hasattr(d, 'symbols'):
2013             return '\\text{Domain on }' + self._print(d.symbols)
2014         else:
2015             return self._print(None)
2016 
2017     def _print_FiniteSet(self, s):
2018         items = sorted(s.args, key=default_sort_key)
2019         return self._print_set(items)
2020 
2021     def _print_set(self, s):
2022         items = sorted(s, key=default_sort_key)
2023         if self._settings['decimal_separator'] == 'comma':
2024             items = "; ".join(map(self._print, items))
2025         elif self._settings['decimal_separator'] == 'period':
2026             items = ", ".join(map(self._print, items))
2027         else:
2028             raise ValueError('Unknown Decimal Separator')
2029         return r"\left\{%s\right\}" % items
2030 
2031 
2032     _print_frozenset = _print_set
2033 
2034     def _print_Range(self, s):
2035         dots = object()
2036 
2037         if s.has(Symbol):
2038             return self._print_Basic(s)
2039 
2040         if s.start.is_infinite and s.stop.is_infinite:
2041             if s.step.is_positive:
2042                 printset = dots, -1, 0, 1, dots
2043             else:
2044                 printset = dots, 1, 0, -1, dots
2045         elif s.start.is_infinite:
2046             printset = dots, s[-1] - s.step, s[-1]
2047         elif s.stop.is_infinite:
2048             it = iter(s)
2049             printset = next(it), next(it), dots
2050         elif len(s) > 4:
2051             it = iter(s)
2052             printset = next(it), next(it), dots, s[-1]
2053         else:
2054             printset = tuple(s)
2055 
2056         return (r"\left\{" +
2057                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2058                 r"\right\}")
2059 
2060     def __print_number_polynomial(self, expr, letter, exp=None):
2061         if len(expr.args) == 2:
2062             if exp is not None:
2063                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2064                             self._print(expr.args[0]), exp,
2065                             self._print(expr.args[1]))
2066             return r"%s_{%s}\left(%s\right)" % (letter,
2067                         self._print(expr.args[0]), self._print(expr.args[1]))
2068 
2069         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2070         if exp is not None:
2071             tex = r"%s^{%s}" % (tex, exp)
2072         return tex
2073 
2074     def _print_bernoulli(self, expr, exp=None):
2075         return self.__print_number_polynomial(expr, "B", exp)
2076 
2077     def _print_bell(self, expr, exp=None):
2078         if len(expr.args) == 3:
2079             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2080                                 self._print(expr.args[1]))
2081             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2082                                                el in expr.args[2])
2083             if exp is not None:
2084                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2085             else:
2086                 tex = tex1 + tex2
2087             return tex
2088         return self.__print_number_polynomial(expr, "B", exp)
2089 
2090 
2091     def _print_fibonacci(self, expr, exp=None):
2092         return self.__print_number_polynomial(expr, "F", exp)
2093 
2094     def _print_lucas(self, expr, exp=None):
2095         tex = r"L_{%s}" % self._print(expr.args[0])
2096         if exp is not None:
2097             tex = r"%s^{%s}" % (tex, exp)
2098         return tex
2099 
2100     def _print_tribonacci(self, expr, exp=None):
2101         return self.__print_number_polynomial(expr, "T", exp)
2102 
2103     def _print_SeqFormula(self, s):
2104         dots = object()
2105         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2106             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2107                 self._print(s.formula),
2108                 self._print(s.variables[0]),
2109                 self._print(s.start),
2110                 self._print(s.stop)
2111             )
2112         if s.start is S.NegativeInfinity:
2113             stop = s.stop
2114             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2115                         s.coeff(stop - 1), s.coeff(stop))
2116         elif s.stop is S.Infinity or s.length > 4:
2117             printset = s[:4]
2118             printset.append(dots)
2119         else:
2120             printset = tuple(s)
2121 
2122         return (r"\left[" +
2123                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2124                 r"\right]")
2125 
2126     _print_SeqPer = _print_SeqFormula
2127     _print_SeqAdd = _print_SeqFormula
2128     _print_SeqMul = _print_SeqFormula
2129 
2130     def _print_Interval(self, i):
2131         if i.start == i.end:
2132             return r"\left\{%s\right\}" % self._print(i.start)
2133 
2134         else:
2135             if i.left_open:
2136                 left = '('
2137             else:
2138                 left = '['
2139 
2140             if i.right_open:
2141                 right = ')'
2142             else:
2143                 right = ']'
2144 
2145             return r"\left%s%s, %s\right%s" % \
2146                    (left, self._print(i.start), self._print(i.end), right)
2147 
2148     def _print_AccumulationBounds(self, i):
2149         return r"\left\langle %s, %s\right\rangle" % \
2150                 (self._print(i.min), self._print(i.max))
2151 
2152     def _print_Union(self, u):
2153         prec = precedence_traditional(u)
2154         args_str = [self.parenthesize(i, prec) for i in u.args]
2155         return r" \cup ".join(args_str)
2156 
2157     def _print_Complement(self, u):
2158         prec = precedence_traditional(u)
2159         args_str = [self.parenthesize(i, prec) for i in u.args]
2160         return r" \setminus ".join(args_str)
2161 
2162     def _print_Intersection(self, u):
2163         prec = precedence_traditional(u)
2164         args_str = [self.parenthesize(i, prec) for i in u.args]
2165         return r" \cap ".join(args_str)
2166 
2167     def _print_SymmetricDifference(self, u):
2168         prec = precedence_traditional(u)
2169         args_str = [self.parenthesize(i, prec) for i in u.args]
2170         return r" \triangle ".join(args_str)
2171 
2172     def _print_ProductSet(self, p):
2173         prec = precedence_traditional(p)
2174         if len(p.sets) >= 1 and not has_variety(p.sets):
2175             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2176         return r" \times ".join(
2177             self.parenthesize(set, prec) for set in p.sets)
2178 
2179     def _print_EmptySet(self, e):
2180         return r"\emptyset"
2181 
2182     def _print_Naturals(self, n):
2183         return r"\mathbb{N}"
2184 
2185     def _print_Naturals0(self, n):
2186         return r"\mathbb{N}_0"
2187 
2188     def _print_Integers(self, i):
2189         return r"\mathbb{Z}"
2190 
2191     def _print_Rationals(self, i):
2192         return r"\mathbb{Q}"
2193 
2194     def _print_Reals(self, i):
2195         return r"\mathbb{R}"
2196 
2197     def _print_Complexes(self, i):
2198         return r"\mathbb{C}"
2199 
2200     def _print_ImageSet(self, s):
2201         expr = s.lamda.expr
2202         sig = s.lamda.signature
2203         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2204         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2205         return r"\left\{%s\; \middle|\; %s\right\}" % (self._print(expr), xinys)
2206 
2207     def _print_ConditionSet(self, s):
2208         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2209         if s.base_set is S.UniversalSet:
2210             return r"\left\{%s\; \middle|\; %s \right\}" % \
2211                 (vars_print, self._print(s.condition))
2212 
2213         return r"\left\{%s\; \middle|\; %s \in %s \wedge %s \right\}" % (
2214             vars_print,
2215             vars_print,
2216             self._print(s.base_set),
2217             self._print(s.condition))
2218 
2219     def _print_ComplexRegion(self, s):
2220         vars_print = ', '.join([self._print(var) for var in s.variables])
2221         return r"\left\{%s\; \middle|\; %s \in %s \right\}" % (
2222             self._print(s.expr),
2223             vars_print,
2224             self._print(s.sets))
2225 
2226     def _print_Contains(self, e):
2227         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2228 
2229     def _print_FourierSeries(self, s):
2230         return self._print_Add(s.truncate()) + r' + \ldots'
2231 
2232     def _print_FormalPowerSeries(self, s):
2233         return self._print_Add(s.infinite)
2234 
2235     def _print_FiniteField(self, expr):
2236         return r"\mathbb{F}_{%s}" % expr.mod
2237 
2238     def _print_IntegerRing(self, expr):
2239         return r"\mathbb{Z}"
2240 
2241     def _print_RationalField(self, expr):
2242         return r"\mathbb{Q}"
2243 
2244     def _print_RealField(self, expr):
2245         return r"\mathbb{R}"
2246 
2247     def _print_ComplexField(self, expr):
2248         return r"\mathbb{C}"
2249 
2250     def _print_PolynomialRing(self, expr):
2251         domain = self._print(expr.domain)
2252         symbols = ", ".join(map(self._print, expr.symbols))
2253         return r"%s\left[%s\right]" % (domain, symbols)
2254 
2255     def _print_FractionField(self, expr):
2256         domain = self._print(expr.domain)
2257         symbols = ", ".join(map(self._print, expr.symbols))
2258         return r"%s\left(%s\right)" % (domain, symbols)
2259 
2260     def _print_PolynomialRingBase(self, expr):
2261         domain = self._print(expr.domain)
2262         symbols = ", ".join(map(self._print, expr.symbols))
2263         inv = ""
2264         if not expr.is_Poly:
2265             inv = r"S_<^{-1}"
2266         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2267 
2268     def _print_Poly(self, poly):
2269         cls = poly.__class__.__name__
2270         terms = []
2271         for monom, coeff in poly.terms():
2272             s_monom = ''
2273             for i, exp in enumerate(monom):
2274                 if exp > 0:
2275                     if exp == 1:
2276                         s_monom += self._print(poly.gens[i])
2277                     else:
2278                         s_monom += self._print(pow(poly.gens[i], exp))
2279 
2280             if coeff.is_Add:
2281                 if s_monom:
2282                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2283                 else:
2284                     s_coeff = self._print(coeff)
2285             else:
2286                 if s_monom:
2287                     if coeff is S.One:
2288                         terms.extend(['+', s_monom])
2289                         continue
2290 
2291                     if coeff is S.NegativeOne:
2292                         terms.extend(['-', s_monom])
2293                         continue
2294 
2295                 s_coeff = self._print(coeff)
2296 
2297             if not s_monom:
2298                 s_term = s_coeff
2299             else:
2300                 s_term = s_coeff + " " + s_monom
2301 
2302             if s_term.startswith('-'):
2303                 terms.extend(['-', s_term[1:]])
2304             else:
2305                 terms.extend(['+', s_term])
2306 
2307         if terms[0] in ['-', '+']:
2308             modifier = terms.pop(0)
2309 
2310             if modifier == '-':
2311                 terms[0] = '-' + terms[0]
2312 
2313         expr = ' '.join(terms)
2314         gens = list(map(self._print, poly.gens))
2315         domain = "domain=%s" % self._print(poly.get_domain())
2316 
2317         args = ", ".join([expr] + gens + [domain])
2318         if cls in accepted_latex_functions:
2319             tex = r"\%s {\left(%s \right)}" % (cls, args)
2320         else:
2321             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2322 
2323         return tex
2324 
2325     def _print_ComplexRootOf(self, root):
2326         cls = root.__class__.__name__
2327         if cls == "ComplexRootOf":
2328             cls = "CRootOf"
2329         expr = self._print(root.expr)
2330         index = root.index
2331         if cls in accepted_latex_functions:
2332             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2333         else:
2334             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2335                                                                  index)
2336 
2337     def _print_RootSum(self, expr):
2338         cls = expr.__class__.__name__
2339         args = [self._print(expr.expr)]
2340 
2341         if expr.fun is not S.IdentityFunction:
2342             args.append(self._print(expr.fun))
2343 
2344         if cls in accepted_latex_functions:
2345             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2346         else:
2347             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2348                                                              ", ".join(args))
2349 
2350     def _print_PolyElement(self, poly):
2351         mul_symbol = self._settings['mul_symbol_latex']
2352         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2353 
2354     def _print_FracElement(self, frac):
2355         if frac.denom == 1:
2356             return self._print(frac.numer)
2357         else:
2358             numer = self._print(frac.numer)
2359             denom = self._print(frac.denom)
2360             return r"\frac{%s}{%s}" % (numer, denom)
2361 
2362     def _print_euler(self, expr, exp=None):
2363         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2364         tex = r"E_{%s}" % self._print(m)
2365         if exp is not None:
2366             tex = r"%s^{%s}" % (tex, exp)
2367         if x is not None:
2368             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2369         return tex
2370 
2371     def _print_catalan(self, expr, exp=None):
2372         tex = r"C_{%s}" % self._print(expr.args[0])
2373         if exp is not None:
2374             tex = r"%s^{%s}" % (tex, exp)
2375         return tex
2376 
2377     def _print_UnifiedTransform(self, expr, s, inverse=False):
2378         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2379 
2380     def _print_MellinTransform(self, expr):
2381         return self._print_UnifiedTransform(expr, 'M')
2382 
2383     def _print_InverseMellinTransform(self, expr):
2384         return self._print_UnifiedTransform(expr, 'M', True)
2385 
2386     def _print_LaplaceTransform(self, expr):
2387         return self._print_UnifiedTransform(expr, 'L')
2388 
2389     def _print_InverseLaplaceTransform(self, expr):
2390         return self._print_UnifiedTransform(expr, 'L', True)
2391 
2392     def _print_FourierTransform(self, expr):
2393         return self._print_UnifiedTransform(expr, 'F')
2394 
2395     def _print_InverseFourierTransform(self, expr):
2396         return self._print_UnifiedTransform(expr, 'F', True)
2397 
2398     def _print_SineTransform(self, expr):
2399         return self._print_UnifiedTransform(expr, 'SIN')
2400 
2401     def _print_InverseSineTransform(self, expr):
2402         return self._print_UnifiedTransform(expr, 'SIN', True)
2403 
2404     def _print_CosineTransform(self, expr):
2405         return self._print_UnifiedTransform(expr, 'COS')
2406 
2407     def _print_InverseCosineTransform(self, expr):
2408         return self._print_UnifiedTransform(expr, 'COS', True)
2409 
2410     def _print_DMP(self, p):
2411         try:
2412             if p.ring is not None:
2413                 # TODO incorporate order
2414                 return self._print(p.ring.to_sympy(p))
2415         except SympifyError:
2416             pass
2417         return self._print(repr(p))
2418 
2419     def _print_DMF(self, p):
2420         return self._print_DMP(p)
2421 
2422     def _print_Object(self, object):
2423         return self._print(Symbol(object.name))
2424 
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))
2430 
2431     def _print_Morphism(self, morphism):
2432         domain = self._print(morphism.domain)
2433         codomain = self._print(morphism.codomain)
2434         return "%s\\rightarrow %s" % (domain, codomain)
2435 
2436     def _print_TransferFunction(self, expr):
2437         num, den = self._print(expr.num), self._print(expr.den)
2438         return r"\frac{%s}{%s}" % (num, den)
2439 
2440     def _print_Series(self, expr):
2441         args = list(expr.args)
2442         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2443                                             False)
2444         return ' '.join(map(parens, args))
2445 
2446     def _print_MIMOSeries(self, expr):
2447         from sympy.physics.control.lti import MIMOParallel
2448         args = list(expr.args)[::-1]
2449         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2450                                              False) if isinstance(x, MIMOParallel) else self._print(x)
2451         return r"\cdot".join(map(parens, args))
2452 
2453     def _print_Parallel(self, expr):
2454         args = list(expr.args)
2455         func = lambda x: self._print(x)
2456         return ' + '.join(map(func, args))
2457 
2458     def _print_MIMOParallel(self, expr):
2459         args = list(expr.args)
2460         func = lambda x: self._print(x)
2461         return ' + '.join(map(func, args))
2462 
2463     def _print_Feedback(self, expr):
2464         from sympy.physics.control import TransferFunction, Parallel, Series
2465 
2466         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2467         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2468         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2469 
2470         if isinstance(num, Series) and isinstance(expr.den, Series):
2471             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2472         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2473             if expr.den == tf:
2474                 den = Parallel(tf, Series(*num_arg_list))
2475             else:
2476                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2477         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2478             if num == tf:
2479                 den = Parallel(tf, Series(*den_arg_list))
2480             else:
2481                 den = Parallel(tf, Series(num, *den_arg_list))
2482         else:
2483             if num == tf:
2484                 den = Parallel(tf, *den_arg_list)
2485             elif expr.den == tf:
2486                 den = Parallel(tf, *num_arg_list)
2487             else:
2488                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2489 
2490         numer = self._print(num)
2491         denom = self._print(den)
2492         return r"\frac{%s}{%s}" % (numer, denom)
2493 
2494     def _print_TransferFunctionMatrix(self, expr):
2495         mat = self._print(expr._expr_mat)
2496         return r"%s_\tau" % mat
2497 
2498     def _print_NamedMorphism(self, morphism):
2499         pretty_name = self._print(Symbol(morphism.name))
2500         pretty_morphism = self._print_Morphism(morphism)
2501         return "%s:%s" % (pretty_name, pretty_morphism)
2502 
2503     def _print_IdentityMorphism(self, morphism):
2504         from sympy.categories import NamedMorphism
2505         return self._print_NamedMorphism(NamedMorphism(
2506             morphism.domain, morphism.codomain, "id"))
2507 
2508     def _print_CompositeMorphism(self, morphism):
2509         # All components of the morphism have names and it is thus
2510         # possible to build the name of the composite.
2511         component_names_list = [self._print(Symbol(component.name)) for
2512                                 component in morphism.components]
2513         component_names_list.reverse()
2514         component_names = "\\circ ".join(component_names_list) + ":"
2515 
2516         pretty_morphism = self._print_Morphism(morphism)
2517         return component_names + pretty_morphism
2518 
2519     def _print_Category(self, morphism):
2520         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2521 
2522     def _print_Diagram(self, diagram):
2523         if not diagram.premises:
2524             # This is an empty diagram.
2525             return self._print(S.EmptySet)
2526 
2527         latex_result = self._print(diagram.premises)
2528         if diagram.conclusions:
2529             latex_result += "\\Longrightarrow %s" % \
2530                             self._print(diagram.conclusions)
2531 
2532         return latex_result
2533 
2534     def _print_DiagramGrid(self, grid):
2535         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2536 
2537         for i in range(grid.height):
2538             for j in range(grid.width):
2539                 if grid[i, j]:
2540                     latex_result += latex(grid[i, j])
2541                 latex_result += " "
2542                 if j != grid.width - 1:
2543                     latex_result += "& "
2544 
2545             if i != grid.height - 1:
2546                 latex_result += "\\\\"
2547             latex_result += "\n"
2548 
2549         latex_result += "\\end{array}\n"
2550         return latex_result
2551 
2552     def _print_FreeModule(self, M):
2553         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2554 
2555     def _print_FreeModuleElement(self, m):
2556         # Print as row vector for convenience, for now.
2557         return r"\left[ {} \right]".format(",".join(
2558             '{' + self._print(x) + '}' for x in m))
2559 
2560     def _print_SubModule(self, m):
2561         return r"\left\langle {} \right\rangle".format(",".join(
2562             '{' + self._print(x) + '}' for x in m.gens))
2563 
2564     def _print_ModuleImplementedIdeal(self, m):
2565         return r"\left\langle {} \right\rangle".format(",".join(
2566             '{' + self._print(x) + '}' for [x] in m._module.gens))
2567 
2568     def _print_Quaternion(self, expr):
2569         # TODO: This expression is potentially confusing,
2570         # shall we print it as `Quaternion( ... )`?
2571         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2572              for i in expr.args]
2573         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2574         return " + ".join(a)
2575 
2576     def _print_QuotientRing(self, R):
2577         # TODO nicer fractions for few generators...
2578         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2579                  self._print(R.base_ideal))
2580 
2581     def _print_QuotientRingElement(self, x):
2582         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2583                  self._print(x.ring.base_ideal))
2584 
2585     def _print_QuotientModuleElement(self, m):
2586         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2587                  self._print(m.module.killed_module))
2588 
2589     def _print_QuotientModule(self, M):
2590         # TODO nicer fractions for few generators...
2591         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2592                  self._print(M.killed_module))
2593 
2594     def _print_MatrixHomomorphism(self, h):
2595         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2596             self._print(h.domain), self._print(h.codomain))
2597 
2598     def _print_Manifold(self, manifold):
2599         string = manifold.name.name
2600         if '{' in string:
2601             name, supers, subs = string, [], []
2602         else:
2603             name, supers, subs = split_super_sub(string)
2604 
2605             name = translate(name)
2606             supers = [translate(sup) for sup in supers]
2607             subs = [translate(sub) for sub in subs]
2608 
2609         name = r'\text{%s}' % name
2610         if supers:
2611             name += "^{%s}" % " ".join(supers)
2612         if subs:
2613             name += "_{%s}" % " ".join(subs)
2614 
2615         return name
2616 
2617     def _print_Patch(self, patch):
2618         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2619 
2620     def _print_CoordSystem(self, coordsys):
2621         return r'\text{%s}^{\text{%s}}_{%s}' % (
2622             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2623         )
2624 
2625     def _print_CovarDerivativeOp(self, cvd):
2626         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2627 
2628     def _print_BaseScalarField(self, field):
2629         string = field._coord_sys.symbols[field._index].name
2630         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2631 
2632     def _print_BaseVectorField(self, field):
2633         string = field._coord_sys.symbols[field._index].name
2634         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2635 
2636     def _print_Differential(self, diff):
2637         field = diff._form_field
2638         if hasattr(field, '_coord_sys'):
2639             string = field._coord_sys.symbols[field._index].name
2640             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2641         else:
2642             string = self._print(field)
2643             return r'\operatorname{{d}}\left({}\right)'.format(string)
2644 
2645     def _print_Tr(self, p):
2646         # TODO: Handle indices
2647         contents = self._print(p.args[0])
2648         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2649 
2650     def _print_totient(self, expr, exp=None):
2651         if exp is not None:
2652             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2653                 (self._print(expr.args[0]), exp)
2654         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2655 
2656     def _print_reduced_totient(self, expr, exp=None):
2657         if exp is not None:
2658             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2659                 (self._print(expr.args[0]), exp)
2660         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2661 
2662     def _print_divisor_sigma(self, expr, exp=None):
2663         if len(expr.args) == 2:
2664             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2665                                                 (expr.args[1], expr.args[0])))
2666         else:
2667             tex = r"\left(%s\right)" % self._print(expr.args[0])
2668         if exp is not None:
2669             return r"\sigma^{%s}%s" % (exp, tex)
2670         return r"\sigma%s" % tex
2671 
2672     def _print_udivisor_sigma(self, expr, exp=None):
2673         if len(expr.args) == 2:
2674             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2675                                                 (expr.args[1], expr.args[0])))
2676         else:
2677             tex = r"\left(%s\right)" % self._print(expr.args[0])
2678         if exp is not None:
2679             return r"\sigma^*^{%s}%s" % (exp, tex)
2680         return r"\sigma^*%s" % tex
2681 
2682     def _print_primenu(self, expr, exp=None):
2683         if exp is not None:
2684             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2685                 (self._print(expr.args[0]), exp)
2686         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2687 
2688     def _print_primeomega(self, expr, exp=None):
2689         if exp is not None:
2690             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2691                 (self._print(expr.args[0]), exp)
2692         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2693 
2694     def _print_Str(self, s):
2695         return str(s.name)
2696 
2697     def _print_float(self, expr):
2698         return self._print(Float(expr))
2699 
2700     def _print_int(self, expr):
2701         return str(expr)
2702 
2703     def _print_mpz(self, expr):
2704         return str(expr)
2705 
2706     def _print_mpq(self, expr):
2707         return str(expr)
2708 
2709     def _print_Predicate(self, expr):
2710         return str(expr)
2711 
2712     def _print_AppliedPredicate(self, expr):
2713         pred = expr.function
2714         args = expr.arguments
2715         pred_latex = self._print(pred)
2716         args_latex = ', '.join([self._print(a) for a in args])
2717         return '%s(%s)' % (pred_latex, args_latex)
2718 
2719     def emptyPrinter(self, expr):
2720         # default to just printing as monospace, like would normally be shown
2721         s = super().emptyPrinter(expr)
2722 
2723         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_LambertW</method>
<code>
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))

</code><intended_behavior>Although the `_print_LambertW` method is not directly at fault based on the existing implementation, considering a future-proofing approach, it may be beneficial to allow this method (and similarly implemented methods for other functions) to optionally handle an `exp` argument. This would not change the method's current handling but would add an optional pathway for dealing with exponentiation directly within the function's LaTeX representation. This adaptation would require a fallback or default behavior that ensures compatibility with the current usage while enabling new functionality where necessary. This method could, for example, provide a basic LaTeX exponentiation wrapping around its current output if `exp` is provided and is not trivial (e.g., an exponent of 1).</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_Exp1(self, expr, exp=None):
1113         return "e"
1114 
1115     def _print_elliptic_k(self, expr, exp=None):
1116         tex = r"\left(%s\right)" % self._print(expr.args[0])
1117         if exp is not None:
1118             return r"K^{%s}%s" % (exp, tex)
1119         else:
1120             return r"K%s" % tex
1121 
1122     def _print_elliptic_f(self, expr, exp=None):
1123         tex = r"\left(%s\middle| %s\right)" % \
1124             (self._print(expr.args[0]), self._print(expr.args[1]))
1125         if exp is not None:
1126             return r"F^{%s}%s" % (exp, tex)
1127         else:
1128             return r"F%s" % tex
1129 
1130     def _print_elliptic_e(self, expr, exp=None):
1131         if len(expr.args) == 2:
1132             tex = r"\left(%s\middle| %s\right)" % \
1133                 (self._print(expr.args[0]), self._print(expr.args[1]))
1134         else:
1135             tex = r"\left(%s\right)" % self._print(expr.args[0])
1136         if exp is not None:
1137             return r"E^{%s}%s" % (exp, tex)
1138         else:
1139             return r"E%s" % tex
1140 
1141     def _print_elliptic_pi(self, expr, exp=None):
1142         if len(expr.args) == 3:
1143             tex = r"\left(%s; %s\middle| %s\right)" % \
1144                 (self._print(expr.args[0]), self._print(expr.args[1]),
1145                  self._print(expr.args[2]))
1146         else:
1147             tex = r"\left(%s\middle| %s\right)" % \
1148                 (self._print(expr.args[0]), self._print(expr.args[1]))
1149         if exp is not None:
1150             return r"\Pi^{%s}%s" % (exp, tex)
1151         else:
1152             return r"\Pi%s" % tex
1153 
1154     def _print_beta(self, expr, exp=None):
1155         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1156                                         self._print(expr.args[1]))
1157 
1158         if exp is not None:
1159             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1160         else:
1161             return r"\operatorname{B}%s" % tex
1162 
1163     def _print_betainc(self, expr, exp=None, operator='B'):
1164         largs = [self._print(arg) for arg in expr.args]
1165         tex = r"\left(%s, %s\right)" % (largs[0], largs[1])
1166 
1167         if exp is not None:
1168             return r"\operatorname{%s}_{(%s, %s)}^{%s}%s" % (operator, largs[2], largs[3], exp, tex)
1169         else:
1170             return r"\operatorname{%s}_{(%s, %s)}%s" % (operator, largs[2], largs[3], tex)
1171 
1172     def _print_betainc_regularized(self, expr, exp=None):
1173         return self._print_betainc(expr, exp, operator='I')
1174 
1175     def _print_uppergamma(self, expr, exp=None):
1176         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1177                                         self._print(expr.args[1]))
1178 
1179         if exp is not None:
1180             return r"\Gamma^{%s}%s" % (exp, tex)
1181         else:
1182             return r"\Gamma%s" % tex
1183 
1184     def _print_lowergamma(self, expr, exp=None):
1185         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1186                                         self._print(expr.args[1]))
1187 
1188         if exp is not None:
1189             return r"\gamma^{%s}%s" % (exp, tex)
1190         else:
1191             return r"\gamma%s" % tex
1192 
1193     def _hprint_one_arg_func(self, expr, exp=None):
1194         tex = r"\left(%s\right)" % self._print(expr.args[0])
1195 
1196         if exp is not None:
1197             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1198         else:
1199             return r"%s%s" % (self._print(expr.func), tex)
1200 
1201     _print_gamma = _hprint_one_arg_func
1202 
1203     def _print_Chi(self, expr, exp=None):
1204         tex = r"\left(%s\right)" % self._print(expr.args[0])
1205 
1206         if exp is not None:
1207             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1208         else:
1209             return r"\operatorname{Chi}%s" % tex
1210 
1211     def _print_expint(self, expr, exp=None):
1212         tex = r"\left(%s\right)" % self._print(expr.args[1])
1213         nu = self._print(expr.args[0])
1214 
1215         if exp is not None:
1216             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1217         else:
1218             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1219 
1220     def _print_fresnels(self, expr, exp=None):
1221         tex = r"\left(%s\right)" % self._print(expr.args[0])
1222 
1223         if exp is not None:
1224             return r"S^{%s}%s" % (exp, tex)
1225         else:
1226             return r"S%s" % tex
1227 
1228     def _print_fresnelc(self, expr, exp=None):
1229         tex = r"\left(%s\right)" % self._print(expr.args[0])
1230 
1231         if exp is not None:
1232             return r"C^{%s}%s" % (exp, tex)
1233         else:
1234             return r"C%s" % tex
1235 
1236     def _print_subfactorial(self, expr, exp=None):
1237         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1238 
1239         if exp is not None:
1240             return r"\left(%s\right)^{%s}" % (tex, exp)
1241         else:
1242             return tex
1243 
1244     def _print_factorial(self, expr, exp=None):
1245         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1246 
1247         if exp is not None:
1248             return r"%s^{%s}" % (tex, exp)
1249         else:
1250             return tex
1251 
1252     def _print_factorial2(self, expr, exp=None):
1253         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1254 
1255         if exp is not None:
1256             return r"%s^{%s}" % (tex, exp)
1257         else:
1258             return tex
1259 
1260     def _print_binomial(self, expr, exp=None):
1261         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1262                                      self._print(expr.args[1]))
1263 
1264         if exp is not None:
1265             return r"%s^{%s}" % (tex, exp)
1266         else:
1267             return tex
1268 
1269     def _print_RisingFactorial(self, expr, exp=None):
1270         n, k = expr.args
1271         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1272 
1273         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1274 
1275         return self._do_exponent(tex, exp)
1276 
1277     def _print_FallingFactorial(self, expr, exp=None):
1278         n, k = expr.args
1279         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1280 
1281         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1282 
1283         return self._do_exponent(tex, exp)
1284 
1285     def _hprint_BesselBase(self, expr, exp, sym):
1286         tex = r"%s" % (sym)
1287 
1288         need_exp = False
1289         if exp is not None:
1290             if tex.find('^') == -1:
1291                 tex = r"%s^{%s}" % (tex, exp)
1292             else:
1293                 need_exp = True
1294 
1295         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1296                                            self._print(expr.argument))
1297 
1298         if need_exp:
1299             tex = self._do_exponent(tex, exp)
1300         return tex
1301 
1302     def _hprint_vec(self, vec):
1303         if not vec:
1304             return ""
1305         s = ""
1306         for i in vec[:-1]:
1307             s += "%s, " % self._print(i)
1308         s += self._print(vec[-1])
1309         return s
1310 
1311     def _print_besselj(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'J')
1313 
1314     def _print_besseli(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'I')
1316 
1317     def _print_besselk(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'K')
1319 
1320     def _print_bessely(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'Y')
1322 
1323     def _print_yn(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'y')
1325 
1326     def _print_jn(self, expr, exp=None):
1327         return self._hprint_BesselBase(expr, exp, 'j')
1328 
1329     def _print_hankel1(self, expr, exp=None):
1330         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1331 
1332     def _print_hankel2(self, expr, exp=None):
1333         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1334 
1335     def _print_hn1(self, expr, exp=None):
1336         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1337 
1338     def _print_hn2(self, expr, exp=None):
1339         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1340 
1341     def _hprint_airy(self, expr, exp=None, notation=""):
1342         tex = r"\left(%s\right)" % self._print(expr.args[0])
1343 
1344         if exp is not None:
1345             return r"%s^{%s}%s" % (notation, exp, tex)
1346         else:
1347             return r"%s%s" % (notation, tex)
1348 
1349     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1350         tex = r"\left(%s\right)" % self._print(expr.args[0])
1351 
1352         if exp is not None:
1353             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1354         else:
1355             return r"%s^\prime%s" % (notation, tex)
1356 
1357     def _print_airyai(self, expr, exp=None):
1358         return self._hprint_airy(expr, exp, 'Ai')
1359 
1360     def _print_airybi(self, expr, exp=None):
1361         return self._hprint_airy(expr, exp, 'Bi')
1362 
1363     def _print_airyaiprime(self, expr, exp=None):
1364         return self._hprint_airy_prime(expr, exp, 'Ai')
1365 
1366     def _print_airybiprime(self, expr, exp=None):
1367         return self._hprint_airy_prime(expr, exp, 'Bi')
1368 
1369     def _print_hyper(self, expr, exp=None):
1370         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1371               r"\middle| {%s} \right)}" % \
1372             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1373               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1374               self._print(expr.argument))
1375 
1376         if exp is not None:
1377             tex = r"{%s}^{%s}" % (tex, exp)
1378         return tex
1379 
1380     def _print_meijerg(self, expr, exp=None):
1381         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1382               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1383             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1384               self._print(len(expr.bm)), self._print(len(expr.an)),
1385               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1386               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1387               self._print(expr.argument))
1388 
1389         if exp is not None:
1390             tex = r"{%s}^{%s}" % (tex, exp)
1391         return tex
1392 
1393     def _print_dirichlet_eta(self, expr, exp=None):
1394         tex = r"\left(%s\right)" % self._print(expr.args[0])
1395         if exp is not None:
1396             return r"\eta^{%s}%s" % (exp, tex)
1397         return r"\eta%s" % tex
1398 
1399     def _print_zeta(self, expr, exp=None):
1400         if len(expr.args) == 2:
1401             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1402         else:
1403             tex = r"\left(%s\right)" % self._print(expr.args[0])
1404         if exp is not None:
1405             return r"\zeta^{%s}%s" % (exp, tex)
1406         return r"\zeta%s" % tex
1407 
1408     def _print_stieltjes(self, expr, exp=None):
1409         if len(expr.args) == 2:
1410             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1411         else:
1412             tex = r"_{%s}" % self._print(expr.args[0])
1413         if exp is not None:
1414             return r"\gamma%s^{%s}" % (tex, exp)
1415         return r"\gamma%s" % tex
1416 
1417     def _print_lerchphi(self, expr, exp=None):
1418         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1419         if exp is None:
1420             return r"\Phi%s" % tex
1421         return r"\Phi^{%s}%s" % (exp, tex)
1422 
1423     def _print_polylog(self, expr, exp=None):
1424         s, z = map(self._print, expr.args)
1425         tex = r"\left(%s\right)" % z
1426         if exp is None:
1427             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1428         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1429 
1430     def _print_jacobi(self, expr, exp=None):
1431         n, a, b, x = map(self._print, expr.args)
1432         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1433         if exp is not None:
1434             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1435         return tex
1436 
1437     def _print_gegenbauer(self, expr, exp=None):
1438         n, a, x = map(self._print, expr.args)
1439         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1440         if exp is not None:
1441             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1442         return tex
1443 
1444     def _print_chebyshevt(self, expr, exp=None):
1445         n, x = map(self._print, expr.args)
1446         tex = r"T_{%s}\left(%s\right)" % (n, x)
1447         if exp is not None:
1448             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1449         return tex
1450 
1451     def _print_chebyshevu(self, expr, exp=None):
1452         n, x = map(self._print, expr.args)
1453         tex = r"U_{%s}\left(%s\right)" % (n, x)
1454         if exp is not None:
1455             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1456         return tex
1457 
1458     def _print_legendre(self, expr, exp=None):
1459         n, x = map(self._print, expr.args)
1460         tex = r"P_{%s}\left(%s\right)" % (n, x)
1461         if exp is not None:
1462             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1463         return tex
1464 
1465     def _print_assoc_legendre(self, expr, exp=None):
1466         n, a, x = map(self._print, expr.args)
1467         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1468         if exp is not None:
1469             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1470         return tex
1471 
1472     def _print_hermite(self, expr, exp=None):
1473         n, x = map(self._print, expr.args)
1474         tex = r"H_{%s}\left(%s\right)" % (n, x)
1475         if exp is not None:
1476             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1477         return tex
1478 
1479     def _print_laguerre(self, expr, exp=None):
1480         n, x = map(self._print, expr.args)
1481         tex = r"L_{%s}\left(%s\right)" % (n, x)
1482         if exp is not None:
1483             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1484         return tex
1485 
1486     def _print_assoc_laguerre(self, expr, exp=None):
1487         n, a, x = map(self._print, expr.args)
1488         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1489         if exp is not None:
1490             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1491         return tex
1492 
1493     def _print_Ynm(self, expr, exp=None):
1494         n, m, theta, phi = map(self._print, expr.args)
1495         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1496         if exp is not None:
1497             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1498         return tex
1499 
1500     def _print_Znm(self, expr, exp=None):
1501         n, m, theta, phi = map(self._print, expr.args)
1502         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1503         if exp is not None:
1504             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1505         return tex
1506 
1507     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1508         a, q, z = map(self._print, args)
1509         sup = r"^{\prime}" if prime else ""
1510         exp = "" if not exp else "^{%s}" % exp
1511         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1512 
1513     def _print_mathieuc(self, expr, exp=None):
1514         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1515 
1516     def _print_mathieus(self, expr, exp=None):
1517         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1518 
1519     def _print_mathieucprime(self, expr, exp=None):
1520         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1521 
1522     def _print_mathieusprime(self, expr, exp=None):
1523         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1524 
1525     def _print_Rational(self, expr):
1526         if expr.q != 1:
1527             sign = ""
1528             p = expr.p
1529             if expr.p < 0:
1530                 sign = "- "
1531                 p = -p
1532             if self._settings['fold_short_frac']:
1533                 return r"%s%d / %d" % (sign, p, expr.q)
1534             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1535         else:
1536             return self._print(expr.p)
1537 
1538     def _print_Order(self, expr):
1539         s = self._print(expr.expr)
1540         if expr.point and any(p != S.Zero for p in expr.point) or \
1541            len(expr.variables) > 1:
1542             s += '; '
1543             if len(expr.variables) > 1:
1544                 s += self._print(expr.variables)
1545             elif expr.variables:
1546                 s += self._print(expr.variables[0])
1547             s += r'\rightarrow '
1548             if len(expr.point) > 1:
1549                 s += self._print(expr.point)
1550             else:
1551                 s += self._print(expr.point[0])
1552         return r"O\left(%s\right)" % s
1553 
1554     def _print_Symbol(self, expr, style='plain'):
1555         if expr in self._settings['symbol_names']:
1556             return self._settings['symbol_names'][expr]
1557 
1558         return self._deal_with_super_sub(expr.name, style=style)
1559 
1560     _print_RandomSymbol = _print_Symbol
1561 
1562     def _deal_with_super_sub(self, string, style='plain'):
1563         if '{' in string:
1564             name, supers, subs = string, [], []
1565         else:
1566             name, supers, subs = split_super_sub(string)
1567 
1568             name = translate(name)
1569             supers = [translate(sup) for sup in supers]
1570             subs = [translate(sub) for sub in subs]
1571 
1572         # apply the style only to the name
1573         if style == 'bold':
1574             name = "\\mathbf{{{}}}".format(name)
1575 
1576         # glue all items together:
1577         if supers:
1578             name += "^{%s}" % " ".join(supers)
1579         if subs:
1580             name += "_{%s}" % " ".join(subs)
1581 
1582         return name
1583 
1584     def _print_Relational(self, expr):
1585         if self._settings['itex']:
1586             gt = r"\gt"
1587             lt = r"\lt"
1588         else:
1589             gt = ">"
1590             lt = "<"
1591 
1592         charmap = {
1593             "==": "=",
1594             ">": gt,
1595             "<": lt,
1596             ">=": r"\geq",
1597             "<=": r"\leq",
1598             "!=": r"\neq",
1599         }
1600 
1601         return "%s %s %s" % (self._print(expr.lhs),
1602                              charmap[expr.rel_op], self._print(expr.rhs))
1603 
1604     def _print_Piecewise(self, expr):
1605         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1606                    for e, c in expr.args[:-1]]
1607         if expr.args[-1].cond == true:
1608             ecpairs.append(r"%s & \text{otherwise}" %
1609                            self._print(expr.args[-1].expr))
1610         else:
1611             ecpairs.append(r"%s & \text{for}\: %s" %
1612                            (self._print(expr.args[-1].expr),
1613                             self._print(expr.args[-1].cond)))
1614         tex = r"\begin{cases} %s \end{cases}"
1615         return tex % r" \\".join(ecpairs)
1616 
1617     def _print_MatrixBase(self, expr):
1618         lines = []
1619 
1620         for line in range(expr.rows):  # horrible, should be 'rows'
1621             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1622 
1623         mat_str = self._settings['mat_str']
1624         if mat_str is None:
1625             if self._settings['mode'] == 'inline':
1626                 mat_str = 'smallmatrix'
1627             else:
1628                 if (expr.cols <= 10) is True:
1629                     mat_str = 'matrix'
1630                 else:
1631                     mat_str = 'array'
1632 
1633         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1634         out_str = out_str.replace('%MATSTR%', mat_str)
1635         if mat_str == 'array':
1636             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1637         if self._settings['mat_delim']:
1638             left_delim = self._settings['mat_delim']
1639             right_delim = self._delim_dict[left_delim]
1640             out_str = r'\left' + left_delim + out_str + \
1641                       r'\right' + right_delim
1642         return out_str % r"\\".join(lines)
1643 
1644     def _print_MatrixElement(self, expr):
1645         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1646             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1647 
1648     def _print_MatrixSlice(self, expr):
1649         def latexslice(x, dim):
1650             x = list(x)
1651             if x[2] == 1:
1652                 del x[2]
1653             if x[0] == 0:
1654                 x[0] = None
1655             if x[1] == dim:
1656                 x[1] = None
1657             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1658         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1659                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1660                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1661 
1662     def _print_BlockMatrix(self, expr):
1663         return self._print(expr.blocks)
1664 
1665     def _print_Transpose(self, expr):
1666         mat = expr.arg
1667         from sympy.matrices import MatrixSymbol
1668         if not isinstance(mat, MatrixSymbol):
1669             return r"\left(%s\right)^{T}" % self._print(mat)
1670         else:
1671             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1672 
1673     def _print_Trace(self, expr):
1674         mat = expr.arg
1675         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1676 
1677     def _print_Adjoint(self, expr):
1678         mat = expr.arg
1679         from sympy.matrices import MatrixSymbol
1680         if not isinstance(mat, MatrixSymbol):
1681             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1682         else:
1683             return r"%s^{\dagger}" % self._print(mat)
1684 
1685     def _print_MatMul(self, expr):
1686         from sympy import MatMul, Mul
1687 
1688         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1689                                              False)
1690 
1691         args = expr.args
1692         if isinstance(args[0], Mul):
1693             args = args[0].as_ordered_factors() + list(args[1:])
1694         else:
1695             args = list(args)
1696 
1697         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1698             if args[0] == -1:
1699                 args = args[1:]
1700             else:
1701                 args[0] = -args[0]
1702             return '- ' + ' '.join(map(parens, args))
1703         else:
1704             return ' '.join(map(parens, args))
1705 
1706     def _print_Mod(self, expr, exp=None):
1707         if exp is not None:
1708             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1709                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1710                                    strict=True), self._print(expr.args[1]),
1711                  exp)
1712         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1713                                  PRECEDENCE['Mul'], strict=True),
1714                                  self._print(expr.args[1]))
1715 
1716     def _print_HadamardProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \circ '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_HadamardPower(self, expr):
1725         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1726             template = r"%s^{\circ \left({%s}\right)}"
1727         else:
1728             template = r"%s^{\circ {%s}}"
1729         return self._helper_print_standard_power(expr, template)
1730 
1731     def _print_KroneckerProduct(self, expr):
1732         args = expr.args
1733         prec = PRECEDENCE['Pow']
1734         parens = self.parenthesize
1735 
1736         return r' \otimes '.join(
1737             map(lambda arg: parens(arg, prec, strict=True), args))
1738 
1739     def _print_MatPow(self, expr):
1740         base, exp = expr.base, expr.exp
1741         from sympy.matrices import MatrixSymbol
1742         if not isinstance(base, MatrixSymbol):
1743             return "\\left(%s\\right)^{%s}" % (self._print(base),
1744                                               self._print(exp))
1745         else:
1746             return "%s^{%s}" % (self._print(base), self._print(exp))
1747 
1748     def _print_MatrixSymbol(self, expr):
1749         return self._print_Symbol(expr, style=self._settings[
1750             'mat_symbol_style'])
1751 
1752     def _print_ZeroMatrix(self, Z):
1753         return r"\mathbb{0}" if self._settings[
1754             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1755 
1756     def _print_OneMatrix(self, O):
1757         return r"\mathbb{1}" if self._settings[
1758             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1759 
1760     def _print_Identity(self, I):
1761         return r"\mathbb{I}" if self._settings[
1762             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1763 
1764     def _print_PermutationMatrix(self, P):
1765         perm_str = self._print(P.args[0])
1766         return "P_{%s}" % perm_str
1767 
1768     def _print_NDimArray(self, expr):
1769 
1770         if expr.rank() == 0:
1771             return self._print(expr[()])
1772 
1773         mat_str = self._settings['mat_str']
1774         if mat_str is None:
1775             if self._settings['mode'] == 'inline':
1776                 mat_str = 'smallmatrix'
1777             else:
1778                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1779                     mat_str = 'matrix'
1780                 else:
1781                     mat_str = 'array'
1782         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1783         block_str = block_str.replace('%MATSTR%', mat_str)
1784         if self._settings['mat_delim']:
1785             left_delim = self._settings['mat_delim']
1786             right_delim = self._delim_dict[left_delim]
1787             block_str = r'\left' + left_delim + block_str + \
1788                         r'\right' + right_delim
1789 
1790         if expr.rank() == 0:
1791             return block_str % ""
1792 
1793         level_str = [[]] + [[] for i in range(expr.rank())]
1794         shape_ranges = [list(range(i)) for i in expr.shape]
1795         for outer_i in itertools.product(*shape_ranges):
1796             level_str[-1].append(self._print(expr[outer_i]))
1797             even = True
1798             for back_outer_i in range(expr.rank()-1, -1, -1):
1799                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1800                     break
1801                 if even:
1802                     level_str[back_outer_i].append(
1803                         r" & ".join(level_str[back_outer_i+1]))
1804                 else:
1805                     level_str[back_outer_i].append(
1806                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1807                     if len(level_str[back_outer_i+1]) == 1:
1808                         level_str[back_outer_i][-1] = r"\left[" + \
1809                             level_str[back_outer_i][-1] + r"\right]"
1810                 even = not even
1811                 level_str[back_outer_i+1] = []
1812 
1813         out_str = level_str[0][0]
1814 
1815         if expr.rank() % 2 == 1:
1816             out_str = block_str % out_str
1817 
1818         return out_str
1819 
1820     def _printer_tensor_indices(self, name, indices, index_map={}):
1821         out_str = self._print(name)
1822         last_valence = None
1823         prev_map = None
1824         for index in indices:
1825             new_valence = index.is_up
1826             if ((index in index_map) or prev_map) and \
1827                     last_valence == new_valence:
1828                 out_str += ","
1829             if last_valence != new_valence:
1830                 if last_valence is not None:
1831                     out_str += "}"
1832                 if index.is_up:
1833                     out_str += "{}^{"
1834                 else:
1835                     out_str += "{}_{"
1836             out_str += self._print(index.args[0])
1837             if index in index_map:
1838                 out_str += "="
1839                 out_str += self._print(index_map[index])
1840                 prev_map = True
1841             else:
1842                 prev_map = False
1843             last_valence = new_valence
1844         if last_valence is not None:
1845             out_str += "}"
1846         return out_str
1847 
1848     def _print_Tensor(self, expr):
1849         name = expr.args[0].args[0]
1850         indices = expr.get_indices()
1851         return self._printer_tensor_indices(name, indices)
1852 
1853     def _print_TensorElement(self, expr):
1854         name = expr.expr.args[0].args[0]
1855         indices = expr.expr.get_indices()
1856         index_map = expr.index_map
1857         return self._printer_tensor_indices(name, indices, index_map)
1858 
1859     def _print_TensMul(self, expr):
1860         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1861         sign, args = expr._get_args_for_traditional_printer()
1862         return sign + "".join(
1863             [self.parenthesize(arg, precedence(expr)) for arg in args]
1864         )
1865 
1866     def _print_TensAdd(self, expr):
1867         a = []
1868         args = expr.args
1869         for x in args:
1870             a.append(self.parenthesize(x, precedence(expr)))
1871         a.sort()
1872         s = ' + '.join(a)
1873         s = s.replace('+ -', '- ')
1874         return s
1875 
1876     def _print_TensorIndex(self, expr):
1877         return "{}%s{%s}" % (
1878             "^" if expr.is_up else "_",
1879             self._print(expr.args[0])
1880         )
1881 
1882     def _print_PartialDerivative(self, expr):
1883         if len(expr.variables) == 1:
1884             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1885                 self._print(expr.variables[0]),
1886                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1887             )
1888         else:
1889             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1890                 len(expr.variables),
1891                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1892                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1893             )
1894 
1895     def _print_ArraySymbol(self, expr):
1896         return self._print(expr.name)
1897 
1898     def _print_ArrayElement(self, expr):
1899         return "{{%s}_{%s}}" % (expr.name, ", ".join([f"{self._print(i)}" for i in expr.indices]))
1900 
1901     def _print_UniversalSet(self, expr):
1902         return r"\mathbb{U}"
1903 
1904     def _print_frac(self, expr, exp=None):
1905         if exp is None:
1906             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1907         else:
1908             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1909                     self._print(expr.args[0]), exp)
1910 
1911     def _print_tuple(self, expr):
1912         if self._settings['decimal_separator'] == 'comma':
1913             sep = ";"
1914         elif self._settings['decimal_separator'] == 'period':
1915             sep = ","
1916         else:
1917             raise ValueError('Unknown Decimal Separator')
1918 
1919         if len(expr) == 1:
1920             # 1-tuple needs a trailing separator
1921             return self._add_parens_lspace(self._print(expr[0]) + sep)
1922         else:
1923             return self._add_parens_lspace(
1924                 (sep + r" \  ").join([self._print(i) for i in expr]))
1925 
1926     def _print_TensorProduct(self, expr):
1927         elements = [self._print(a) for a in expr.args]
1928         return r' \otimes '.join(elements)
1929 
1930     def _print_WedgeProduct(self, expr):
1931         elements = [self._print(a) for a in expr.args]
1932         return r' \wedge '.join(elements)
1933 
1934     def _print_Tuple(self, expr):
1935         return self._print_tuple(expr)
1936 
1937     def _print_list(self, expr):
1938         if self._settings['decimal_separator'] == 'comma':
1939             return r"\left[ %s\right]" % \
1940                 r"; \  ".join([self._print(i) for i in expr])
1941         elif self._settings['decimal_separator'] == 'period':
1942             return r"\left[ %s\right]" % \
1943                 r", \  ".join([self._print(i) for i in expr])
1944         else:
1945             raise ValueError('Unknown Decimal Separator')
1946 
1947 
1948     def _print_dict(self, d):
1949         keys = sorted(d.keys(), key=default_sort_key)
1950         items = []
1951 
1952         for key in keys:
1953             val = d[key]
1954             items.append("%s : %s" % (self._print(key), self._print(val)))
1955 
1956         return r"\left\{ %s\right\}" % r", \  ".join(items)
1957 
1958     def _print_Dict(self, expr):
1959         return self._print_dict(expr)
1960 
1961     def _print_DiracDelta(self, expr, exp=None):
1962         if len(expr.args) == 1 or expr.args[1] == 0:
1963             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1964         else:
1965             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1966                 self._print(expr.args[1]), self._print(expr.args[0]))
1967         if exp:
1968             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1969         return tex
1970 
1971     def _print_SingularityFunction(self, expr, exp=None):
1972         shift = self._print(expr.args[0] - expr.args[1])
1973         power = self._print(expr.args[2])
1974         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1975         if exp is not None:
1976             tex = r"{\left({\langle %s \rangle}^{%s}\right)}^{%s}" % (shift, power, exp)
1977         return tex
1978 
1979     def _print_Heaviside(self, expr, exp=None):
1980         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1981         if exp:
1982             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1983         return tex
1984 
1985     def _print_KroneckerDelta(self, expr, exp=None):
1986         i = self._print(expr.args[0])
1987         j = self._print(expr.args[1])
1988         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1989             tex = r'\delta_{%s %s}' % (i, j)
1990         else:
1991             tex = r'\delta_{%s, %s}' % (i, j)
1992         if exp is not None:
1993             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1994         return tex
1995 
1996     def _print_LeviCivita(self, expr, exp=None):
1997         indices = map(self._print, expr.args)
1998         if all(x.is_Atom for x in expr.args):
1999             tex = r'\varepsilon_{%s}' % " ".join(indices)
2000         else:
2001             tex = r'\varepsilon_{%s}' % ", ".join(indices)
2002         if exp:
2003             tex = r'\left(%s\right)^{%s}' % (tex, exp)
2004         return tex
2005 
2006     def _print_RandomDomain(self, d):
2007         if hasattr(d, 'as_boolean'):
2008             return '\\text{Domain: }' + self._print(d.as_boolean())
2009         elif hasattr(d, 'set'):
2010             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
2011                     self._print(d.set))
2012         elif hasattr(d, 'symbols'):
2013             return '\\text{Domain on }' + self._print(d.symbols)
2014         else:
2015             return self._print(None)
2016 
2017     def _print_FiniteSet(self, s):
2018         items = sorted(s.args, key=default_sort_key)
2019         return self._print_set(items)
2020 
2021     def _print_set(self, s):
2022         items = sorted(s, key=default_sort_key)
2023         if self._settings['decimal_separator'] == 'comma':
2024             items = "; ".join(map(self._print, items))
2025         elif self._settings['decimal_separator'] == 'period':
2026             items = ", ".join(map(self._print, items))
2027         else:
2028             raise ValueError('Unknown Decimal Separator')
2029         return r"\left\{%s\right\}" % items
2030 
2031 
2032     _print_frozenset = _print_set
2033 
2034     def _print_Range(self, s):
2035         dots = object()
2036 
2037         if s.has(Symbol):
2038             return self._print_Basic(s)
2039 
2040         if s.start.is_infinite and s.stop.is_infinite:
2041             if s.step.is_positive:
2042                 printset = dots, -1, 0, 1, dots
2043             else:
2044                 printset = dots, 1, 0, -1, dots
2045         elif s.start.is_infinite:
2046             printset = dots, s[-1] - s.step, s[-1]
2047         elif s.stop.is_infinite:
2048             it = iter(s)
2049             printset = next(it), next(it), dots
2050         elif len(s) > 4:
2051             it = iter(s)
2052             printset = next(it), next(it), dots, s[-1]
2053         else:
2054             printset = tuple(s)
2055 
2056         return (r"\left\{" +
2057                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2058                 r"\right\}")
2059 
2060     def __print_number_polynomial(self, expr, letter, exp=None):
2061         if len(expr.args) == 2:
2062             if exp is not None:
2063                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2064                             self._print(expr.args[0]), exp,
2065                             self._print(expr.args[1]))
2066             return r"%s_{%s}\left(%s\right)" % (letter,
2067                         self._print(expr.args[0]), self._print(expr.args[1]))
2068 
2069         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2070         if exp is not None:
2071             tex = r"%s^{%s}" % (tex, exp)
2072         return tex
2073 
2074     def _print_bernoulli(self, expr, exp=None):
2075         return self.__print_number_polynomial(expr, "B", exp)
2076 
2077     def _print_bell(self, expr, exp=None):
2078         if len(expr.args) == 3:
2079             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2080                                 self._print(expr.args[1]))
2081             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2082                                                el in expr.args[2])
2083             if exp is not None:
2084                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2085             else:
2086                 tex = tex1 + tex2
2087             return tex
2088         return self.__print_number_polynomial(expr, "B", exp)
2089 
2090 
2091     def _print_fibonacci(self, expr, exp=None):
2092         return self.__print_number_polynomial(expr, "F", exp)
2093 
2094     def _print_lucas(self, expr, exp=None):
2095         tex = r"L_{%s}" % self._print(expr.args[0])
2096         if exp is not None:
2097             tex = r"%s^{%s}" % (tex, exp)
2098         return tex
2099 
2100     def _print_tribonacci(self, expr, exp=None):
2101         return self.__print_number_polynomial(expr, "T", exp)
2102 
2103     def _print_SeqFormula(self, s):
2104         dots = object()
2105         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2106             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2107                 self._print(s.formula),
2108                 self._print(s.variables[0]),
2109                 self._print(s.start),
2110                 self._print(s.stop)
2111             )
2112         if s.start is S.NegativeInfinity:
2113             stop = s.stop
2114             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2115                         s.coeff(stop - 1), s.coeff(stop))
2116         elif s.stop is S.Infinity or s.length > 4:
2117             printset = s[:4]
2118             printset.append(dots)
2119         else:
2120             printset = tuple(s)
2121 
2122         return (r"\left[" +
2123                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2124                 r"\right]")
2125 
2126     _print_SeqPer = _print_SeqFormula
2127     _print_SeqAdd = _print_SeqFormula
2128     _print_SeqMul = _print_SeqFormula
2129 
2130     def _print_Interval(self, i):
2131         if i.start == i.end:
2132             return r"\left\{%s\right\}" % self._print(i.start)
2133 
2134         else:
2135             if i.left_open:
2136                 left = '('
2137             else:
2138                 left = '['
2139 
2140             if i.right_open:
2141                 right = ')'
2142             else:
2143                 right = ']'
2144 
2145             return r"\left%s%s, %s\right%s" % \
2146                    (left, self._print(i.start), self._print(i.end), right)
2147 
2148     def _print_AccumulationBounds(self, i):
2149         return r"\left\langle %s, %s\right\rangle" % \
2150                 (self._print(i.min), self._print(i.max))
2151 
2152     def _print_Union(self, u):
2153         prec = precedence_traditional(u)
2154         args_str = [self.parenthesize(i, prec) for i in u.args]
2155         return r" \cup ".join(args_str)
2156 
2157     def _print_Complement(self, u):
2158         prec = precedence_traditional(u)
2159         args_str = [self.parenthesize(i, prec) for i in u.args]
2160         return r" \setminus ".join(args_str)
2161 
2162     def _print_Intersection(self, u):
2163         prec = precedence_traditional(u)
2164         args_str = [self.parenthesize(i, prec) for i in u.args]
2165         return r" \cap ".join(args_str)
2166 
2167     def _print_SymmetricDifference(self, u):
2168         prec = precedence_traditional(u)
2169         args_str = [self.parenthesize(i, prec) for i in u.args]
2170         return r" \triangle ".join(args_str)
2171 
2172     def _print_ProductSet(self, p):
2173         prec = precedence_traditional(p)
2174         if len(p.sets) >= 1 and not has_variety(p.sets):
2175             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2176         return r" \times ".join(
2177             self.parenthesize(set, prec) for set in p.sets)
2178 
2179     def _print_EmptySet(self, e):
2180         return r"\emptyset"
2181 
2182     def _print_Naturals(self, n):
2183         return r"\mathbb{N}"
2184 
2185     def _print_Naturals0(self, n):
2186         return r"\mathbb{N}_0"
2187 
2188     def _print_Integers(self, i):
2189         return r"\mathbb{Z}"
2190 
2191     def _print_Rationals(self, i):
2192         return r"\mathbb{Q}"
2193 
2194     def _print_Reals(self, i):
2195         return r"\mathbb{R}"
2196 
2197     def _print_Complexes(self, i):
2198         return r"\mathbb{C}"
2199 
2200     def _print_ImageSet(self, s):
2201         expr = s.lamda.expr
2202         sig = s.lamda.signature
2203         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2204         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2205         return r"\left\{%s\; \middle|\; %s\right\}" % (self._print(expr), xinys)
2206 
2207     def _print_ConditionSet(self, s):
2208         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2209         if s.base_set is S.UniversalSet:
2210             return r"\left\{%s\; \middle|\; %s \right\}" % \
2211                 (vars_print, self._print(s.condition))
2212 
2213         return r"\left\{%s\; \middle|\; %s \in %s \wedge %s \right\}" % (
2214             vars_print,
2215             vars_print,
2216             self._print(s.base_set),
2217             self._print(s.condition))
2218 
2219     def _print_ComplexRegion(self, s):
2220         vars_print = ', '.join([self._print(var) for var in s.variables])
2221         return r"\left\{%s\; \middle|\; %s \in %s \right\}" % (
2222             self._print(s.expr),
2223             vars_print,
2224             self._print(s.sets))
2225 
2226     def _print_Contains(self, e):
2227         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2228 
2229     def _print_FourierSeries(self, s):
2230         return self._print_Add(s.truncate()) + r' + \ldots'
2231 
2232     def _print_FormalPowerSeries(self, s):
2233         return self._print_Add(s.infinite)
2234 
2235     def _print_FiniteField(self, expr):
2236         return r"\mathbb{F}_{%s}" % expr.mod
2237 
2238     def _print_IntegerRing(self, expr):
2239         return r"\mathbb{Z}"
2240 
2241     def _print_RationalField(self, expr):
2242         return r"\mathbb{Q}"
2243 
2244     def _print_RealField(self, expr):
2245         return r"\mathbb{R}"
2246 
2247     def _print_ComplexField(self, expr):
2248         return r"\mathbb{C}"
2249 
2250     def _print_PolynomialRing(self, expr):
2251         domain = self._print(expr.domain)
2252         symbols = ", ".join(map(self._print, expr.symbols))
2253         return r"%s\left[%s\right]" % (domain, symbols)
2254 
2255     def _print_FractionField(self, expr):
2256         domain = self._print(expr.domain)
2257         symbols = ", ".join(map(self._print, expr.symbols))
2258         return r"%s\left(%s\right)" % (domain, symbols)
2259 
2260     def _print_PolynomialRingBase(self, expr):
2261         domain = self._print(expr.domain)
2262         symbols = ", ".join(map(self._print, expr.symbols))
2263         inv = ""
2264         if not expr.is_Poly:
2265             inv = r"S_<^{-1}"
2266         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2267 
2268     def _print_Poly(self, poly):
2269         cls = poly.__class__.__name__
2270         terms = []
2271         for monom, coeff in poly.terms():
2272             s_monom = ''
2273             for i, exp in enumerate(monom):
2274                 if exp > 0:
2275                     if exp == 1:
2276                         s_monom += self._print(poly.gens[i])
2277                     else:
2278                         s_monom += self._print(pow(poly.gens[i], exp))
2279 
2280             if coeff.is_Add:
2281                 if s_monom:
2282                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2283                 else:
2284                     s_coeff = self._print(coeff)
2285             else:
2286                 if s_monom:
2287                     if coeff is S.One:
2288                         terms.extend(['+', s_monom])
2289                         continue
2290 
2291                     if coeff is S.NegativeOne:
2292                         terms.extend(['-', s_monom])
2293                         continue
2294 
2295                 s_coeff = self._print(coeff)
2296 
2297             if not s_monom:
2298                 s_term = s_coeff
2299             else:
2300                 s_term = s_coeff + " " + s_monom
2301 
2302             if s_term.startswith('-'):
2303                 terms.extend(['-', s_term[1:]])
2304             else:
2305                 terms.extend(['+', s_term])
2306 
2307         if terms[0] in ['-', '+']:
2308             modifier = terms.pop(0)
2309 
2310             if modifier == '-':
2311                 terms[0] = '-' + terms[0]
2312 
2313         expr = ' '.join(terms)
2314         gens = list(map(self._print, poly.gens))
2315         domain = "domain=%s" % self._print(poly.get_domain())
2316 
2317         args = ", ".join([expr] + gens + [domain])
2318         if cls in accepted_latex_functions:
2319             tex = r"\%s {\left(%s \right)}" % (cls, args)
2320         else:
2321             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2322 
2323         return tex
2324 
2325     def _print_ComplexRootOf(self, root):
2326         cls = root.__class__.__name__
2327         if cls == "ComplexRootOf":
2328             cls = "CRootOf"
2329         expr = self._print(root.expr)
2330         index = root.index
2331         if cls in accepted_latex_functions:
2332             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2333         else:
2334             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2335                                                                  index)
2336 
2337     def _print_RootSum(self, expr):
2338         cls = expr.__class__.__name__
2339         args = [self._print(expr.expr)]
2340 
2341         if expr.fun is not S.IdentityFunction:
2342             args.append(self._print(expr.fun))
2343 
2344         if cls in accepted_latex_functions:
2345             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2346         else:
2347             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2348                                                              ", ".join(args))
2349 
2350     def _print_PolyElement(self, poly):
2351         mul_symbol = self._settings['mul_symbol_latex']
2352         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2353 
2354     def _print_FracElement(self, frac):
2355         if frac.denom == 1:
2356             return self._print(frac.numer)
2357         else:
2358             numer = self._print(frac.numer)
2359             denom = self._print(frac.denom)
2360             return r"\frac{%s}{%s}" % (numer, denom)
2361 
2362     def _print_euler(self, expr, exp=None):
2363         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2364         tex = r"E_{%s}" % self._print(m)
2365         if exp is not None:
2366             tex = r"%s^{%s}" % (tex, exp)
2367         if x is not None:
2368             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2369         return tex
2370 
2371     def _print_catalan(self, expr, exp=None):
2372         tex = r"C_{%s}" % self._print(expr.args[0])
2373         if exp is not None:
2374             tex = r"%s^{%s}" % (tex, exp)
2375         return tex
2376 
2377     def _print_UnifiedTransform(self, expr, s, inverse=False):
2378         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2379 
2380     def _print_MellinTransform(self, expr):
2381         return self._print_UnifiedTransform(expr, 'M')
2382 
2383     def _print_InverseMellinTransform(self, expr):
2384         return self._print_UnifiedTransform(expr, 'M', True)
2385 
2386     def _print_LaplaceTransform(self, expr):
2387         return self._print_UnifiedTransform(expr, 'L')
2388 
2389     def _print_InverseLaplaceTransform(self, expr):
2390         return self._print_UnifiedTransform(expr, 'L', True)
2391 
2392     def _print_FourierTransform(self, expr):
2393         return self._print_UnifiedTransform(expr, 'F')
2394 
2395     def _print_InverseFourierTransform(self, expr):
2396         return self._print_UnifiedTransform(expr, 'F', True)
2397 
2398     def _print_SineTransform(self, expr):
2399         return self._print_UnifiedTransform(expr, 'SIN')
2400 
2401     def _print_InverseSineTransform(self, expr):
2402         return self._print_UnifiedTransform(expr, 'SIN', True)
2403 
2404     def _print_CosineTransform(self, expr):
2405         return self._print_UnifiedTransform(expr, 'COS')
2406 
2407     def _print_InverseCosineTransform(self, expr):
2408         return self._print_UnifiedTransform(expr, 'COS', True)
2409 
2410     def _print_DMP(self, p):
2411         try:
2412             if p.ring is not None:
2413                 # TODO incorporate order
2414                 return self._print(p.ring.to_sympy(p))
2415         except SympifyError:
2416             pass
2417         return self._print(repr(p))
2418 
2419     def _print_DMF(self, p):
2420         return self._print_DMP(p)
2421 
2422     def _print_Object(self, object):
2423         return self._print(Symbol(object.name))
2424 
2425     def _print_LambertW(self, expr):
2426         if len(expr.args) == 1:
2427             return r"W\left(%s\right)" % self._print(expr.args[0])
2428         return r"W_{%s}\left(%s\right)" % \
2429             (self._print(expr.args[1]), self._print(expr.args[0]))
2430 
2431     def _print_Morphism(self, morphism):
2432         domain = self._print(morphism.domain)
2433         codomain = self._print(morphism.codomain)
2434         return "%s\\rightarrow %s" % (domain, codomain)
2435 
2436     def _print_TransferFunction(self, expr):
2437         num, den = self._print(expr.num), self._print(expr.den)
2438         return r"\frac{%s}{%s}" % (num, den)
2439 
2440     def _print_Series(self, expr):
2441         args = list(expr.args)
2442         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2443                                             False)
2444         return ' '.join(map(parens, args))
2445 
2446     def _print_MIMOSeries(self, expr):
2447         from sympy.physics.control.lti import MIMOParallel
2448         args = list(expr.args)[::-1]
2449         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2450                                              False) if isinstance(x, MIMOParallel) else self._print(x)
2451         return r"\cdot".join(map(parens, args))
2452 
2453     def _print_Parallel(self, expr):
2454         args = list(expr.args)
2455         func = lambda x: self._print(x)
2456         return ' + '.join(map(func, args))
2457 
2458     def _print_MIMOParallel(self, expr):
2459         args = list(expr.args)
2460         func = lambda x: self._print(x)
2461         return ' + '.join(map(func, args))
2462 
2463     def _print_Feedback(self, expr):
2464         from sympy.physics.control import TransferFunction, Parallel, Series
2465 
2466         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2467         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2468         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2469 
2470         if isinstance(num, Series) and isinstance(expr.den, Series):
2471             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2472         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2473             if expr.den == tf:
2474                 den = Parallel(tf, Series(*num_arg_list))
2475             else:
2476                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2477         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2478             if num == tf:
2479                 den = Parallel(tf, Series(*den_arg_list))
2480             else:
2481                 den = Parallel(tf, Series(num, *den_arg_list))
2482         else:
2483             if num == tf:
2484                 den = Parallel(tf, *den_arg_list)
2485             elif expr.den == tf:
2486                 den = Parallel(tf, *num_arg_list)
2487             else:
2488                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2489 
2490         numer = self._print(num)
2491         denom = self._print(den)
2492         return r"\frac{%s}{%s}" % (numer, denom)
2493 
2494     def _print_TransferFunctionMatrix(self, expr):
2495         mat = self._print(expr._expr_mat)
2496         return r"%s_\tau" % mat
2497 
2498     def _print_NamedMorphism(self, morphism):
2499         pretty_name = self._print(Symbol(morphism.name))
2500         pretty_morphism = self._print_Morphism(morphism)
2501         return "%s:%s" % (pretty_name, pretty_morphism)
2502 
2503     def _print_IdentityMorphism(self, morphism):
2504         from sympy.categories import NamedMorphism
2505         return self._print_NamedMorphism(NamedMorphism(
2506             morphism.domain, morphism.codomain, "id"))
2507 
2508     def _print_CompositeMorphism(self, morphism):
2509         # All components of the morphism have names and it is thus
2510         # possible to build the name of the composite.
2511         component_names_list = [self._print(Symbol(component.name)) for
2512                                 component in morphism.components]
2513         component_names_list.reverse()
2514         component_names = "\\circ ".join(component_names_list) + ":"
2515 
2516         pretty_morphism = self._print_Morphism(morphism)
2517         return component_names + pretty_morphism
2518 
2519     def _print_Category(self, morphism):
2520         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2521 
2522     def _print_Diagram(self, diagram):
2523         if not diagram.premises:
2524             # This is an empty diagram.
2525             return self._print(S.EmptySet)
2526 
2527         latex_result = self._print(diagram.premises)
2528         if diagram.conclusions:
2529             latex_result += "\\Longrightarrow %s" % \
2530                             self._print(diagram.conclusions)
2531 
2532         return latex_result
2533 
2534     def _print_DiagramGrid(self, grid):
2535         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2536 
2537         for i in range(grid.height):
2538             for j in range(grid.width):
2539                 if grid[i, j]:
2540                     latex_result += latex(grid[i, j])
2541                 latex_result += " "
2542                 if j != grid.width - 1:
2543                     latex_result += "& "
2544 
2545             if i != grid.height - 1:
2546                 latex_result += "\\\\"
2547             latex_result += "\n"
2548 
2549         latex_result += "\\end{array}\n"
2550         return latex_result
2551 
2552     def _print_FreeModule(self, M):
2553         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2554 
2555     def _print_FreeModuleElement(self, m):
2556         # Print as row vector for convenience, for now.
2557         return r"\left[ {} \right]".format(",".join(
2558             '{' + self._print(x) + '}' for x in m))
2559 
2560     def _print_SubModule(self, m):
2561         return r"\left\langle {} \right\rangle".format(",".join(
2562             '{' + self._print(x) + '}' for x in m.gens))
2563 
2564     def _print_ModuleImplementedIdeal(self, m):
2565         return r"\left\langle {} \right\rangle".format(",".join(
2566             '{' + self._print(x) + '}' for [x] in m._module.gens))
2567 
2568     def _print_Quaternion(self, expr):
2569         # TODO: This expression is potentially confusing,
2570         # shall we print it as `Quaternion( ... )`?
2571         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2572              for i in expr.args]
2573         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2574         return " + ".join(a)
2575 
2576     def _print_QuotientRing(self, R):
2577         # TODO nicer fractions for few generators...
2578         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2579                  self._print(R.base_ideal))
2580 
2581     def _print_QuotientRingElement(self, x):
2582         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2583                  self._print(x.ring.base_ideal))
2584 
2585     def _print_QuotientModuleElement(self, m):
2586         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2587                  self._print(m.module.killed_module))
2588 
2589     def _print_QuotientModule(self, M):
2590         # TODO nicer fractions for few generators...
2591         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2592                  self._print(M.killed_module))
2593 
2594     def _print_MatrixHomomorphism(self, h):
2595         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2596             self._print(h.domain), self._print(h.codomain))
2597 
2598     def _print_Manifold(self, manifold):
2599         string = manifold.name.name
2600         if '{' in string:
2601             name, supers, subs = string, [], []
2602         else:
2603             name, supers, subs = split_super_sub(string)
2604 
2605             name = translate(name)
2606             supers = [translate(sup) for sup in supers]
2607             subs = [translate(sub) for sub in subs]
2608 
2609         name = r'\text{%s}' % name
2610         if supers:
2611             name += "^{%s}" % " ".join(supers)
2612         if subs:
2613             name += "_{%s}" % " ".join(subs)
2614 
2615         return name
2616 
2617     def _print_Patch(self, patch):
2618         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2619 
2620     def _print_CoordSystem(self, coordsys):
2621         return r'\text{%s}^{\text{%s}}_{%s}' % (
2622             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2623         )
2624 
2625     def _print_CovarDerivativeOp(self, cvd):
2626         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2627 
2628     def _print_BaseScalarField(self, field):
2629         string = field._coord_sys.symbols[field._index].name
2630         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2631 
2632     def _print_BaseVectorField(self, field):
2633         string = field._coord_sys.symbols[field._index].name
2634         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2635 
2636     def _print_Differential(self, diff):
2637         field = diff._form_field
2638         if hasattr(field, '_coord_sys'):
2639             string = field._coord_sys.symbols[field._index].name
2640             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2641         else:
2642             string = self._print(field)
2643             return r'\operatorname{{d}}\left({}\right)'.format(string)
2644 
2645     def _print_Tr(self, p):
2646         # TODO: Handle indices
2647         contents = self._print(p.args[0])
2648         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2649 
2650     def _print_totient(self, expr, exp=None):
2651         if exp is not None:
2652             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2653                 (self._print(expr.args[0]), exp)
2654         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2655 
2656     def _print_reduced_totient(self, expr, exp=None):
2657         if exp is not None:
2658             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2659                 (self._print(expr.args[0]), exp)
2660         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2661 
2662     def _print_divisor_sigma(self, expr, exp=None):
2663         if len(expr.args) == 2:
2664             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2665                                                 (expr.args[1], expr.args[0])))
2666         else:
2667             tex = r"\left(%s\right)" % self._print(expr.args[0])
2668         if exp is not None:
2669             return r"\sigma^{%s}%s" % (exp, tex)
2670         return r"\sigma%s" % tex
2671 
2672     def _print_udivisor_sigma(self, expr, exp=None):
2673         if len(expr.args) == 2:
2674             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2675                                                 (expr.args[1], expr.args[0])))
2676         else:
2677             tex = r"\left(%s\right)" % self._print(expr.args[0])
2678         if exp is not None:
2679             return r"\sigma^*^{%s}%s" % (exp, tex)
2680         return r"\sigma^*%s" % tex
2681 
2682     def _print_primenu(self, expr, exp=None):
2683         if exp is not None:
2684             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2685                 (self._print(expr.args[0]), exp)
2686         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2687 
2688     def _print_primeomega(self, expr, exp=None):
2689         if exp is not None:
2690             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2691                 (self._print(expr.args[0]), exp)
2692         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2693 
2694     def _print_Str(self, s):
2695         return str(s.name)
2696 
2697     def _print_float(self, expr):
2698         return self._print(Float(expr))
2699 
2700     def _print_int(self, expr):
2701         return str(expr)
2702 
2703     def _print_mpz(self, expr):
2704         return str(expr)
2705 
2706     def _print_mpq(self, expr):
2707         return str(expr)
2708 
2709     def _print_Predicate(self, expr):
2710         return str(expr)
2711 
2712     def _print_AppliedPredicate(self, expr):
2713         pred = expr.function
2714         args = expr.arguments
2715         pred_latex = self._print(pred)
2716         args_latex = ', '.join([self._print(a) for a in args])
2717         return '%s(%s)' % (pred_latex, args_latex)
2718 
2719     def emptyPrinter(self, expr):
2720         # default to just printing as monospace, like would normally be shown
2721         s = super().emptyPrinter(expr)
2722 
2723         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 21:47:28.966 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 21:47:28.966 | INFO     | Search-only: skipping patch selection
2025-10-17 21:47:29.090 | INFO     | Task sympy__sympy-21849 completed successfully.
2025-10-17 21:47:29.091 | INFO     | No patch generated. You can try running ACR again.
