2025-10-17 16:17:19.399 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 16:17:21.366 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=303, output_tokens=12, cost=0.003390
2025-10-17 16:17:50.562 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=483, output_tokens=531, cost=0.020760
2025-10-17 16:17:51.569 | INFO     | registered non reproducing test 0
2025-10-17 16:18:23.392 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1548, output_tokens=677, cost=0.035790
2025-10-17 16:18:24.377 | INFO     | registered non reproducing test 1
2025-10-17 16:19:01.293 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1649, output_tokens=759, cost=0.039260
2025-10-17 16:19:02.278 | INFO     | registered non reproducing test 2
2025-10-17 16:19:02.279 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 16:19:02.285 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:19:15.297 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=280, cost=0.014510
2025-10-17 16:19:15.303 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:19:18.949 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=634, output_tokens=37, cost=0.007450
2025-10-17 16:19:18.951 | DEBUG    | Extracted a valid json.
2025-10-17 16:19:18.951 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ArgumentParser\")",
        "search_code(\"add_argument('--verbose'\")"
    ],
    "bug_locations": []
}
2025-10-17 16:19:18.997 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:19:18.998 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:19:46.072 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1176, output_tokens=549, cost=0.028230
2025-10-17 16:19:46.085 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:19:48.494 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1941, output_tokens=43, cost=0.020700
2025-10-17 16:19:48.497 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:19:50.650 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=397, output_tokens=50, cost=0.005470
2025-10-17 16:19:50.651 | DEBUG    | Extracted a valid json.
2025-10-17 16:19:50.651 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code_in_file(\"-v\", \"pylint/config/argument.py\")", "search_code_in_file(\"-v\", \"pylint/config/arguments_manager.py\")"],
    "bug_locations": []
}
2025-10-17 16:19:50.656 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:19:50.657 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:20:04.816 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2161, output_tokens=441, cost=0.034840
2025-10-17 16:20:04.827 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:20:08.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2818, output_tokens=24, cost=0.028900
2025-10-17 16:20:08.141 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:20:11.838 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=378, output_tokens=29, cost=0.004650
2025-10-17 16:20:11.839 | DEBUG    | Extracted a valid json.
2025-10-17 16:20:11.839 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"add_argument\")", "search_code(\"help=\")"],
    "bug_locations": []
}
2025-10-17 16:20:11.903 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:20:11.904 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:20:28.534 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3196, output_tokens=612, cost=0.050320
2025-10-17 16:20:28.543 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:20:36.515 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4024, output_tokens=296, cost=0.049120
2025-10-17 16:20:36.522 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:20:41.900 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=650, output_tokens=175, cost=0.011750
2025-10-17 16:20:41.902 | DEBUG    | Extracted a valid json.
2025-10-17 16:20:41.902 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/config/argument.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value."
        },
        {
            "file": "pylint/config/arguments_manager.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value."
        }
    ]
}
2025-10-17 16:20:41.908 | DEBUG    | Bug location extracted successfully: [<file>pylint/config/argument.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Definition of an Argument class and transformers for various argument types.
6 
7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser
8 """
9 
10 from __future__ import annotations
11 
12 import argparse
13 import pathlib
14 import re
15 import sys
16 from collections.abc import Callable
17 from typing import Any, Pattern, Sequence, Tuple, Union
18 
19 from pylint import interfaces
20 from pylint import utils as pylint_utils
21 from pylint.config.callback_actions import _CallbackAction, _ExtendAction
22 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction
23 from pylint.constants import PY38_PLUS
24 
25 if sys.version_info >= (3, 8):
26     from typing import Literal
27 else:
28     from typing_extensions import Literal
29 
30 
31 _ArgumentTypes = Union[
32     str,
33     int,
34     float,
35     bool,
36     Pattern[str],
37     Sequence[str],
38     Sequence[Pattern[str]],
39     Tuple[int, ...],
40 ]
41 """List of possible argument types."""
42 
43 
44 def _confidence_transformer(value: str) -> Sequence[str]:
45     """Transforms a comma separated string of confidence values."""
46     values = pylint_utils._check_csv(value)
47     for confidence in values:
48         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:
49             raise argparse.ArgumentTypeError(
50                 f"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}"
51             )
52     return values
53 
54 
55 def _csv_transformer(value: str) -> Sequence[str]:
56     """Transforms a comma separated string."""
57     return pylint_utils._check_csv(value)
58 
59 
60 YES_VALUES = {"y", "yes", "true"}
61 NO_VALUES = {"n", "no", "false"}
62 
63 
64 def _yn_transformer(value: str) -> bool:
65     """Transforms a yes/no or stringified bool into a bool."""
66     value = value.lower()
67     if value in YES_VALUES:
68         return True
69     if value in NO_VALUES:
70         return False
71     raise argparse.ArgumentTypeError(
72         None, f"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}"
73     )
74 
75 
76 def _non_empty_string_transformer(value: str) -> str:
77     """Check that a string is not empty and remove quotes."""
78     if not value:
79         raise argparse.ArgumentTypeError("Option cannot be an empty string.")
80     return pylint_utils._unquote(value)
81 
82 
83 def _py_version_transformer(value: str) -> tuple[int, ...]:
84     """Transforms a version string into a version tuple."""
85     try:
86         version = tuple(int(val) for val in value.replace(",", ".").split("."))
87     except ValueError:
88         raise argparse.ArgumentTypeError(
89             f"{value} has an invalid format, should be a version string. E.g., '3.8'"
90         ) from None
91     return version
92 
93 
94 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
95     """Transforms a comma separated list of regular expressions."""
96     patterns: list[Pattern[str]] = []
97     for pattern in _csv_transformer(value):
98         patterns.append(re.compile(pattern))
99     return patterns
100 
101 
102 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
103     """Transforms a comma separated list of regular expressions paths."""
104     patterns: list[Pattern[str]] = []
105     for pattern in _csv_transformer(value):
106         patterns.append(
107             re.compile(
108                 str(pathlib.PureWindowsPath(pattern)).replace("\\", "\\\\")
109                 + "|"
110                 + pathlib.PureWindowsPath(pattern).as_posix()
111             )
112         )
113     return patterns
114 
115 
116 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {
117     "choice": str,
118     "csv": _csv_transformer,
119     "float": float,
120     "int": int,
121     "confidence": _confidence_transformer,
122     "non_empty_string": _non_empty_string_transformer,
123     "py_version": _py_version_transformer,
124     "regexp": re.compile,
125     "regexp_csv": _regexp_csv_transfomer,
126     "regexp_paths_csv": _regexp_paths_csv_transfomer,
127     "string": pylint_utils._unquote,
128     "yn": _yn_transformer,
129 }
130 """Type transformers for all argument types.
131 
132 A transformer should accept a string and return one of the supported
133 Argument types. It will only be called when parsing 1) command-line,
134 2) configuration files and 3) a string default value.
135 Non-string default values are assumed to be of the correct type.
136 """
137 
138 
139 class _Argument:
140     """Class representing an argument to be parsed by an argparse.ArgumentsParser.
141 
142     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
143     See:
144     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
145     """
146 
147     def __init__(
148         self,
149         *,
150         flags: list[str],
151         arg_help: str,
152         hide_help: bool,
153         section: str | None,
154     ) -> None:
155         self.flags = flags
156         """The name of the argument."""
157 
158         self.hide_help = hide_help
159         """Whether to hide this argument in the help message."""
160 
161         # argparse uses % formatting on help strings, so a % needs to be escaped
162         self.help = arg_help.replace("%", "%%")
163         """The description of the argument."""
164 
165         if hide_help:
166             self.help = argparse.SUPPRESS
167 
168         self.section = section
169         """The section to add this argument to."""
170 
171 
172 class _BaseStoreArgument(_Argument):
173     """Base class for store arguments to be parsed by an argparse.ArgumentsParser.
174 
175     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
176     See:
177     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
178     """
179 
180     def __init__(
181         self,
182         *,
183         flags: list[str],
184         action: str,
185         default: _ArgumentTypes,
186         arg_help: str,
187         hide_help: bool,
188         section: str | None,
189     ) -> None:
190         super().__init__(
191             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
192         )
193 
194         self.action = action
195         """The action to perform with the argument."""
196 
197         self.default = default
198         """The default value of the argument."""
199 
200 
201 class _StoreArgument(_BaseStoreArgument):
202     """Class representing a store argument to be parsed by an argparse.ArgumentsParser.
203 
204     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
205     See:
206     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
207     """
208 
209     def __init__(
210         self,
211         *,
212         flags: list[str],
213         action: str,
214         default: _ArgumentTypes,
215         arg_type: str,
216         choices: list[str] | None,
217         arg_help: str,
218         metavar: str,
219         hide_help: bool,
220         section: str | None,
221     ) -> None:
222         super().__init__(
223             flags=flags,
224             action=action,
225             default=default,
226             arg_help=arg_help,
227             hide_help=hide_help,
228             section=section,
229         )
230 
231         self.type = _TYPE_TRANSFORMERS[arg_type]
232         """A transformer function that returns a transformed type of the argument."""
233 
234         self.choices = choices
235         """A list of possible choices for the argument.
236 
237         None if there are no restrictions.
238         """
239 
240         self.metavar = metavar
241         """The metavar of the argument.
242 
243         See:
244         https://docs.python.org/3/library/argparse.html#metavar
245         """
246 
247 
248 class _StoreTrueArgument(_BaseStoreArgument):
249     """Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.
250 
251     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
252     See:
253     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
254     """
255 
256     # pylint: disable-next=useless-super-delegation # We narrow down the type of action
257     def __init__(
258         self,
259         *,
260         flags: list[str],
261         action: Literal["store_true"],
262         default: _ArgumentTypes,
263         arg_help: str,
264         hide_help: bool,
265         section: str | None,
266     ) -> None:
267         super().__init__(
268             flags=flags,
269             action=action,
270             default=default,
271             arg_help=arg_help,
272             hide_help=hide_help,
273             section=section,
274         )
275 
276 
277 class _DeprecationArgument(_Argument):
278     """Store arguments while also handling deprecation warnings for old and new names.
279 
280     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
281     See:
282     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
283     """
284 
285     def __init__(
286         self,
287         *,
288         flags: list[str],
289         action: type[argparse.Action],
290         default: _ArgumentTypes,
291         arg_type: str,
292         choices: list[str] | None,
293         arg_help: str,
294         metavar: str,
295         hide_help: bool,
296         section: str | None,
297     ) -> None:
298         super().__init__(
299             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
300         )
301 
302         self.action = action
303         """The action to perform with the argument."""
304 
305         self.default = default
306         """The default value of the argument."""
307 
308         self.type = _TYPE_TRANSFORMERS[arg_type]
309         """A transformer function that returns a transformed type of the argument."""
310 
311         self.choices = choices
312         """A list of possible choices for the argument.
313 
314         None if there are no restrictions.
315         """
316 
317         self.metavar = metavar
318         """The metavar of the argument.
319 
320         See:
321         https://docs.python.org/3/library/argparse.html#metavar
322         """
323 
324 
325 class _ExtendArgument(_DeprecationArgument):
326     """Class for extend arguments to be parsed by an argparse.ArgumentsParser.
327 
328     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
329     See:
330     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
331     """
332 
333     def __init__(
334         self,
335         *,
336         flags: list[str],
337         action: Literal["extend"],
338         default: _ArgumentTypes,
339         arg_type: str,
340         metavar: str,
341         arg_help: str,
342         hide_help: bool,
343         section: str | None,
344         choices: list[str] | None,
345         dest: str | None,
346     ) -> None:
347         # The extend action is included in the stdlib from 3.8+
348         if PY38_PLUS:
349             action_class = argparse._ExtendAction  # type: ignore[attr-defined]
350         else:
351             action_class = _ExtendAction
352 
353         self.dest = dest
354         """The destination of the argument."""
355 
356         super().__init__(
357             flags=flags,
358             action=action_class,
359             default=default,
360             arg_type=arg_type,
361             choices=choices,
362             arg_help=arg_help,
363             metavar=metavar,
364             hide_help=hide_help,
365             section=section,
366         )
367 
368 
369 class _StoreOldNamesArgument(_DeprecationArgument):
370     """Store arguments while also handling old names.
371 
372     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
373     See:
374     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
375     """
376 
377     def __init__(
378         self,
379         *,
380         flags: list[str],
381         default: _ArgumentTypes,
382         arg_type: str,
383         choices: list[str] | None,
384         arg_help: str,
385         metavar: str,
386         hide_help: bool,
387         kwargs: dict[str, Any],
388         section: str | None,
389     ) -> None:
390         super().__init__(
391             flags=flags,
392             action=_OldNamesAction,
393             default=default,
394             arg_type=arg_type,
395             choices=choices,
396             arg_help=arg_help,
397             metavar=metavar,
398             hide_help=hide_help,
399             section=section,
400         )
401 
402         self.kwargs = kwargs
403         """Any additional arguments passed to the action."""
404 
405 
406 class _StoreNewNamesArgument(_DeprecationArgument):
407     """Store arguments while also emitting deprecation warnings.
408 
409     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
410     See:
411     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
412     """
413 
414     def __init__(
415         self,
416         *,
417         flags: list[str],
418         default: _ArgumentTypes,
419         arg_type: str,
420         choices: list[str] | None,
421         arg_help: str,
422         metavar: str,
423         hide_help: bool,
424         kwargs: dict[str, Any],
425         section: str | None,
426     ) -> None:
427         super().__init__(
428             flags=flags,
429             action=_NewNamesAction,
430             default=default,
431             arg_type=arg_type,
432             choices=choices,
433             arg_help=arg_help,
434             metavar=metavar,
435             hide_help=hide_help,
436             section=section,
437         )
438 
439         self.kwargs = kwargs
440         """Any additional arguments passed to the action."""
441 
442 
443 class _CallableArgument(_Argument):
444     """Class representing an callable argument to be parsed by an argparse.ArgumentsParser.
445 
446     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
447     See:
448     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
449     """
450 
451     def __init__(
452         self,
453         *,
454         flags: list[str],
455         action: type[_CallbackAction],
456         arg_help: str,
457         kwargs: dict[str, Any],
458         hide_help: bool,
459         section: str | None,
460     ) -> None:
461         super().__init__(
462             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
463         )
464 
465         self.action = action
466         """The action to perform with the argument."""
467 
468         self.kwargs = kwargs
469         """Any additional arguments passed to the action."""

</code><intended_behavior>Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value.</intended_behavior>, <file>pylint/config/arguments_manager.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Arguments manager class used to handle command-line arguments and options."""
6 
7 from __future__ import annotations
8 
9 import argparse
10 import configparser
11 import copy
12 import optparse  # pylint: disable=deprecated-module
13 import os
14 import re
15 import sys
16 import textwrap
17 import warnings
18 from collections import OrderedDict
19 from collections.abc import Sequence
20 from pathlib import Path
21 from typing import TYPE_CHECKING, Any, TextIO, Union
22 
23 import tomlkit
24 
25 from pylint import utils
26 from pylint.config.argument import (
27     _Argument,
28     _CallableArgument,
29     _ExtendArgument,
30     _StoreArgument,
31     _StoreNewNamesArgument,
32     _StoreOldNamesArgument,
33     _StoreTrueArgument,
34 )
35 from pylint.config.exceptions import (
36     UnrecognizedArgumentAction,
37     _UnrecognizedOptionError,
38 )
39 from pylint.config.help_formatter import _HelpFormatter
40 from pylint.config.option import Option
41 from pylint.config.option_parser import OptionParser
42 from pylint.config.options_provider_mixin import OptionsProviderMixIn
43 from pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value
44 from pylint.constants import MAIN_CHECKER_NAME
45 from pylint.typing import OptionDict
46 
47 if sys.version_info >= (3, 11):
48     import tomllib
49 else:
50     import tomli as tomllib
51 
52 
53 if TYPE_CHECKING:
54     from pylint.config.arguments_provider import _ArgumentsProvider
55 
56 ConfigProvider = Union["_ArgumentsProvider", OptionsProviderMixIn]
57 
58 
59 # pylint: disable-next=too-many-instance-attributes
60 class _ArgumentsManager:
61     """Arguments manager class used to handle command-line arguments and options."""
62 
63     def __init__(
64         self, prog: str, usage: str | None = None, description: str | None = None
65     ) -> None:
66         self._config = argparse.Namespace()
67         """Namespace for all options."""
68 
69         self._arg_parser = argparse.ArgumentParser(
70             prog=prog,
71             usage=usage or "%(prog)s [options]",
72             description=description,
73             formatter_class=_HelpFormatter,
74         )
75         """The command line argument parser."""
76 
77         self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}
78         """Dictionary of all the argument groups."""
79 
80         self._option_dicts: dict[str, OptionDict] = {}
81         """All option dictionaries that have been registered."""
82 
83         # pylint: disable=fixme
84         # TODO: 3.0: Remove deprecated attributes introduced to keep API
85         # parity with optparse. Until '_maxlevel'
86         with warnings.catch_warnings():
87             warnings.filterwarnings("ignore", category=DeprecationWarning)
88             self.reset_parsers(usage or "")
89         # list of registered options providers
90         self._options_providers: list[ConfigProvider] = []
91         # dictionary associating option name to checker
92         self._all_options: OrderedDict[str, ConfigProvider] = OrderedDict()
93         self._short_options: dict[str, str] = {}
94         self._nocallback_options: dict[ConfigProvider, str] = {}
95         self._mygroups: dict[str, optparse.OptionGroup] = {}
96         # verbosity
97         self._maxlevel: int = 0
98 
99     @property
100     def config(self) -> argparse.Namespace:
101         """Namespace for all options."""
102         return self._config
103 
104     @config.setter
105     def config(self, value: argparse.Namespace) -> None:
106         self._config = value
107 
108     @property
109     def options_providers(self) -> list[ConfigProvider]:
110         # TODO: 3.0: Remove deprecated attribute. # pylint: disable=fixme
111         warnings.warn(
112             "options_providers has been deprecated. It will be removed in pylint 3.0.",
113             DeprecationWarning,
114         )
115         return self._options_providers
116 
117     @options_providers.setter
118     def options_providers(self, value: list[ConfigProvider]) -> None:
119         warnings.warn(
120             "Setting options_providers has been deprecated. It will be removed in pylint 3.0.",
121             DeprecationWarning,
122         )
123         self._options_providers = value
124 
125     def _register_options_provider(self, provider: _ArgumentsProvider) -> None:
126         """Register an options provider and load its defaults."""
127         for opt, optdict in provider.options:
128             self._option_dicts[opt] = optdict
129             argument = _convert_option_to_argument(opt, optdict)
130             section = argument.section or provider.name.capitalize()
131 
132             section_desc = provider.option_groups_descs.get(section, None)
133 
134             # We exclude master since its docstring comes from PyLinter
135             if provider.name != MAIN_CHECKER_NAME and provider.__doc__:
136                 section_desc = provider.__doc__.split("\n\n")[0]
137 
138             self._add_arguments_to_parser(section, section_desc, argument)
139 
140         self._load_default_argument_values()
141 
142     def _add_arguments_to_parser(
143         self, section: str, section_desc: str | None, argument: _Argument
144     ) -> None:
145         """Add an argument to the correct argument section/group."""
146         try:
147             section_group = self._argument_groups_dict[section]
148         except KeyError:
149             if section_desc:
150                 section_group = self._arg_parser.add_argument_group(
151                     section, section_desc
152                 )
153             else:
154                 section_group = self._arg_parser.add_argument_group(title=section)
155             self._argument_groups_dict[section] = section_group
156         self._add_parser_option(section_group, argument)
157 
158     @staticmethod
159     def _add_parser_option(
160         section_group: argparse._ArgumentGroup, argument: _Argument
161     ) -> None:
162         """Add an argument."""
163         if isinstance(argument, _StoreArgument):
164             section_group.add_argument(
165                 *argument.flags,
166                 action=argument.action,
167                 default=argument.default,
168                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
169                 help=argument.help,
170                 metavar=argument.metavar,
171                 choices=argument.choices,
172             )
173         elif isinstance(argument, _StoreOldNamesArgument):
174             section_group.add_argument(
175                 *argument.flags,
176                 **argument.kwargs,
177                 action=argument.action,
178                 default=argument.default,
179                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
180                 help=argument.help,
181                 metavar=argument.metavar,
182                 choices=argument.choices,
183             )
184             # We add the old name as hidden option to make it's default value gets loaded when
185             # argparse initializes all options from the checker
186             assert argument.kwargs["old_names"]
187             for old_name in argument.kwargs["old_names"]:
188                 section_group.add_argument(
189                     f"--{old_name}",
190                     action="store",
191                     default=argument.default,
192                     type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
193                     help=argparse.SUPPRESS,
194                     metavar=argument.metavar,
195                     choices=argument.choices,
196                 )
197         elif isinstance(argument, _StoreNewNamesArgument):
198             section_group.add_argument(
199                 *argument.flags,
200                 **argument.kwargs,
201                 action=argument.action,
202                 default=argument.default,
203                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
204                 help=argument.help,
205                 metavar=argument.metavar,
206                 choices=argument.choices,
207             )
208         elif isinstance(argument, _StoreTrueArgument):
209             section_group.add_argument(
210                 *argument.flags,
211                 action=argument.action,
212                 default=argument.default,
213                 help=argument.help,
214             )
215         elif isinstance(argument, _CallableArgument):
216             section_group.add_argument(
217                 *argument.flags,
218                 **argument.kwargs,
219                 action=argument.action,
220                 help=argument.help,
221             )
222         elif isinstance(argument, _ExtendArgument):
223             section_group.add_argument(
224                 *argument.flags,
225                 action=argument.action,
226                 default=argument.default,
227                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
228                 help=argument.help,
229                 metavar=argument.metavar,
230                 choices=argument.choices,
231                 dest=argument.dest,
232             )
233         else:
234             raise UnrecognizedArgumentAction
235 
236     def _load_default_argument_values(self) -> None:
237         """Loads the default values of all registered options."""
238         self.config = self._arg_parser.parse_args([], self.config)
239 
240     def _parse_configuration_file(self, arguments: list[str]) -> None:
241         """Parse the arguments found in a configuration file into the namespace."""
242         self.config, parsed_args = self._arg_parser.parse_known_args(
243             arguments, self.config
244         )
245         unrecognized_options: list[str] = []
246         for opt in parsed_args:
247             if opt.startswith("--"):
248                 unrecognized_options.append(opt[2:])
249         if unrecognized_options:
250             raise _UnrecognizedOptionError(options=unrecognized_options)
251 
252     def _parse_command_line_configuration(
253         self, arguments: Sequence[str] | None = None
254     ) -> list[str]:
255         """Parse the arguments found on the command line into the namespace."""
256         arguments = sys.argv[1:] if arguments is None else arguments
257 
258         self.config, parsed_args = self._arg_parser.parse_known_args(
259             arguments, self.config
260         )
261 
262         return parsed_args
263 
264     def reset_parsers(self, usage: str = "") -> None:  # pragma: no cover
265         """DEPRECATED."""
266         warnings.warn(
267             "reset_parsers has been deprecated. Parsers should be instantiated "
268             "once during initialization and do not need to be reset.",
269             DeprecationWarning,
270         )
271         # configuration file parser
272         self.cfgfile_parser = configparser.ConfigParser(
273             inline_comment_prefixes=("#", ";")
274         )
275         # command line parser
276         self.cmdline_parser = OptionParser(Option, usage=usage)
277         self.cmdline_parser.options_manager = self  # type: ignore[attr-defined]
278         self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)
279 
280     def register_options_provider(
281         self, provider: ConfigProvider, own_group: bool = True
282     ) -> None:  # pragma: no cover
283         """DEPRECATED: Register an options provider."""
284         warnings.warn(
285             "register_options_provider has been deprecated. Options providers and "
286             "arguments providers should be registered by initializing ArgumentsProvider. "
287             "This automatically registers the provider on the ArgumentsManager.",
288             DeprecationWarning,
289         )
290         self.options_providers.append(provider)
291         non_group_spec_options = [
292             option for option in provider.options if "group" not in option[1]
293         ]
294         groups = getattr(provider, "option_groups", ())
295         if own_group and non_group_spec_options:
296             with warnings.catch_warnings():
297                 warnings.filterwarnings("ignore", category=DeprecationWarning)
298                 self.add_option_group(
299                     provider.name.upper(),
300                     provider.__doc__,
301                     non_group_spec_options,
302                     provider,
303                 )
304         else:
305             for opt, optdict in non_group_spec_options:
306                 with warnings.catch_warnings():
307                     warnings.filterwarnings("ignore", category=DeprecationWarning)
308                     self.add_optik_option(provider, self.cmdline_parser, opt, optdict)
309         for gname, gdoc in groups:
310             gname = gname.upper()
311             goptions = [
312                 option
313                 for option in provider.options
314                 if option[1].get("group", "").upper() == gname  # type: ignore[union-attr]
315             ]
316             with warnings.catch_warnings():
317                 warnings.filterwarnings("ignore", category=DeprecationWarning)
318                 self.add_option_group(gname, gdoc, goptions, provider)
319 
320     def add_option_group(
321         self,
322         group_name: str,
323         _: str | None,
324         options: list[tuple[str, OptionDict]],
325         provider: ConfigProvider,
326     ) -> None:  # pragma: no cover
327         """DEPRECATED."""
328         warnings.warn(
329             "add_option_group has been deprecated. Option groups should be "
330             "registered by initializing ArgumentsProvider. "
331             "This automatically registers the group on the ArgumentsManager.",
332             DeprecationWarning,
333         )
334         # add option group to the command line parser
335         if group_name in self._mygroups:
336             group = self._mygroups[group_name]
337         else:
338             group = optparse.OptionGroup(
339                 self.cmdline_parser, title=group_name.capitalize()
340             )
341             self.cmdline_parser.add_option_group(group)
342             self._mygroups[group_name] = group
343             # add section to the config file
344             if (
345                 group_name != "DEFAULT"
346                 and group_name not in self.cfgfile_parser._sections  # type: ignore[attr-defined]
347             ):
348                 self.cfgfile_parser.add_section(group_name)
349         # add provider's specific options
350         for opt, optdict in options:
351             if not isinstance(optdict.get("action", "store"), str):
352                 optdict["action"] = "callback"
353             with warnings.catch_warnings():
354                 warnings.filterwarnings("ignore", category=DeprecationWarning)
355                 self.add_optik_option(provider, group, opt, optdict)
356 
357     def add_optik_option(
358         self,
359         provider: ConfigProvider,
360         optikcontainer: optparse.OptionParser | optparse.OptionGroup,
361         opt: str,
362         optdict: OptionDict,
363     ) -> None:  # pragma: no cover
364         """DEPRECATED."""
365         warnings.warn(
366             "add_optik_option has been deprecated. Options should be automatically "
367             "added by initializing an ArgumentsProvider.",
368             DeprecationWarning,
369         )
370         with warnings.catch_warnings():
371             warnings.filterwarnings("ignore", category=DeprecationWarning)
372             args, optdict = self.optik_option(provider, opt, optdict)
373         option = optikcontainer.add_option(*args, **optdict)
374         self._all_options[opt] = provider
375         self._maxlevel = max(self._maxlevel, option.level or 0)
376 
377     def optik_option(
378         self, provider: ConfigProvider, opt: str, optdict: OptionDict
379     ) -> tuple[list[str], OptionDict]:  # pragma: no cover
380         """DEPRECATED: Get our personal option definition and return a suitable form for
381         use with optik/optparse
382         """
383         warnings.warn(
384             "optik_option has been deprecated. Parsing of option dictionaries should be done "
385             "automatically by initializing an ArgumentsProvider.",
386             DeprecationWarning,
387         )
388         optdict = copy.copy(optdict)
389         if "action" in optdict:
390             self._nocallback_options[provider] = opt
391         else:
392             optdict["action"] = "callback"
393             optdict["callback"] = self.cb_set_provider_option
394         # default is handled here and *must not* be given to optik if you
395         # want the whole machinery to work
396         if "default" in optdict:
397             if (
398                 "help" in optdict
399                 and optdict.get("default") is not None
400                 and optdict["action"] not in ("store_true", "store_false")
401             ):
402                 optdict["help"] += " [current: %default]"  # type: ignore[operator]
403             del optdict["default"]
404         args = ["--" + str(opt)]
405         if "short" in optdict:
406             self._short_options[optdict["short"]] = opt  # type: ignore[index]
407             args.append("-" + optdict["short"])  # type: ignore[operator]
408             del optdict["short"]
409         # cleanup option definition dict before giving it to optik
410         for key in list(optdict.keys()):
411             if key not in self._optik_option_attrs:
412                 optdict.pop(key)
413         return args, optdict
414 
415     def generate_config(
416         self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()
417     ) -> None:  # pragma: no cover
418         """DEPRECATED: Write a configuration file according to the current configuration
419         into the given stream or stdout
420         """
421         warnings.warn(
422             "generate_config has been deprecated. It will be removed in pylint 3.0.",
423             DeprecationWarning,
424         )
425         options_by_section = {}
426         sections = []
427         for group in self._arg_parser._action_groups:
428             group_name = group.title
429             assert group_name
430             if group_name in skipsections:
431                 continue
432 
433             options = []
434             for opt in group._group_actions:
435                 if "--help" in opt.option_strings:
436                     continue
437 
438                 optname = opt.option_strings[0][2:]
439 
440                 try:
441                     optdict = self._option_dicts[optname]
442                 except KeyError:
443                     continue
444 
445                 options.append(
446                     (
447                         optname,
448                         optdict,
449                         getattr(self.config, optname.replace("-", "_")),
450                     )
451                 )
452 
453                 options = [
454                     (n, d, v) for (n, d, v) in options if not d.get("deprecated")
455                 ]
456 
457             if options:
458                 sections.append(group_name)
459                 options_by_section[group_name] = options
460         stream = stream or sys.stdout
461         printed = False
462         for section in sections:
463             if printed:
464                 print("\n", file=stream)
465             with warnings.catch_warnings():
466                 warnings.filterwarnings("ignore", category=DeprecationWarning)
467                 utils.format_section(
468                     stream, section.upper(), sorted(options_by_section[section])
469                 )
470             printed = True
471 
472     def load_provider_defaults(self) -> None:  # pragma: no cover
473         """DEPRECATED: Initialize configuration using default values."""
474         warnings.warn(
475             "load_provider_defaults has been deprecated. Parsing of option defaults should be done "
476             "automatically by initializing an ArgumentsProvider.",
477             DeprecationWarning,
478         )
479         for provider in self.options_providers:
480             with warnings.catch_warnings():
481                 warnings.filterwarnings("ignore", category=DeprecationWarning)
482                 provider.load_defaults()
483 
484     def read_config_file(
485         self, config_file: Path | None = None, verbose: bool = False
486     ) -> None:  # pragma: no cover
487         """DEPRECATED: Read the configuration file but do not load it (i.e. dispatching
488         values to each option's provider)
489 
490         :raises OSError: Whem the specified config file doesn't exist
491         """
492         warnings.warn(
493             "read_config_file has been deprecated. It will be removed in pylint 3.0.",
494             DeprecationWarning,
495         )
496         if not config_file:
497             if verbose:
498                 print(
499                     "No config file found, using default configuration", file=sys.stderr
500                 )
501             return
502         config_file = Path(os.path.expandvars(config_file)).expanduser()
503         if not config_file.exists():
504             raise OSError(f"The config file {str(config_file)} doesn't exist!")
505         parser = self.cfgfile_parser
506         if config_file.suffix == ".toml":
507             try:
508                 self._parse_toml(config_file, parser)
509             except tomllib.TOMLDecodeError:
510                 pass
511         else:
512             # Use this encoding in order to strip the BOM marker, if any.
513             with open(config_file, encoding="utf_8_sig") as fp:
514                 parser.read_file(fp)
515             # normalize each section's title
516             for sect, values in list(parser._sections.items()):  # type: ignore[attr-defined]
517                 if sect.startswith("pylint."):
518                     sect = sect[len("pylint.") :]
519                 if not sect.isupper() and values:
520                     parser._sections[sect.upper()] = values  # type: ignore[attr-defined]
521 
522         if verbose:
523             print(f"Using config file '{config_file}'", file=sys.stderr)
524 
525     @staticmethod
526     def _parse_toml(
527         config_file: Path, parser: configparser.ConfigParser
528     ) -> None:  # pragma: no cover
529         """DEPRECATED: Parse and handle errors of a toml configuration file.
530 
531         TODO: 3.0: Remove depreacted method.
532         """
533         with open(config_file, mode="rb") as fp:
534             content = tomllib.load(fp)
535         try:
536             sections_values = content["tool"]["pylint"]
537         except KeyError:
538             return
539         for section, values in sections_values.items():
540             section_name = section.upper()
541             # TOML has rich types, convert values to
542             # strings as ConfigParser expects.
543             if not isinstance(values, dict):
544                 continue
545             for option, value in values.items():
546                 if isinstance(value, bool):
547                     values[option] = "yes" if value else "no"
548                 elif isinstance(value, list):
549                     values[option] = ",".join(value)
550                 else:
551                     values[option] = str(value)
552             for option, value in values.items():
553                 try:
554                     parser.set(section_name, option, value=value)
555                 except configparser.NoSectionError:
556                     parser.add_section(section_name)
557                     parser.set(section_name, option, value=value)
558 
559     def load_config_file(self) -> None:  # pragma: no cover
560         """DEPRECATED: Dispatch values previously read from a configuration file to each
561         option's provider
562         """
563         warnings.warn(
564             "load_config_file has been deprecated. It will be removed in pylint 3.0.",
565             DeprecationWarning,
566         )
567         parser = self.cfgfile_parser
568         for section in parser.sections():
569             for option, value in parser.items(section):
570                 try:
571                     self.global_set_option(option, value)
572                 except (KeyError, optparse.OptionError):
573                     continue
574 
575     def load_configuration(self, **kwargs: Any) -> None:  # pragma: no cover
576         """DEPRECATED: Override configuration according to given parameters."""
577         warnings.warn(
578             "load_configuration has been deprecated. It will be removed in pylint 3.0.",
579             DeprecationWarning,
580         )
581         with warnings.catch_warnings():
582             warnings.filterwarnings("ignore", category=DeprecationWarning)
583             return self.load_configuration_from_config(kwargs)
584 
585     def load_configuration_from_config(
586         self, config: dict[str, Any]
587     ) -> None:  # pragma: no cover
588         warnings.warn(
589             "DEPRECATED: load_configuration_from_config has been deprecated. It will be removed in pylint 3.0.",
590             DeprecationWarning,
591         )
592         for opt, opt_value in config.items():
593             opt = opt.replace("_", "-")
594             provider = self._all_options[opt]
595             provider.set_option(opt, opt_value)
596 
597     def load_command_line_configuration(
598         self, args: list[str] | None = None
599     ) -> list[str]:  # pragma: no cover
600         """DEPRECATED: Override configuration according to command line parameters.
601 
602         return additional arguments
603         """
604         warnings.warn(
605             "load_command_line_configuration has been deprecated. It will be removed in pylint 3.0.",
606             DeprecationWarning,
607         )
608         args = sys.argv[1:] if args is None else list(args)
609         (options, args) = self.cmdline_parser.parse_args(args=args)
610         for provider in self._nocallback_options:
611             config = provider.config
612             for attr in config.__dict__.keys():
613                 value = getattr(options, attr, None)
614                 if value is None:
615                     continue
616                 setattr(config, attr, value)
617         return args
618 
619     def help(self, level: int | None = None) -> str:
620         """Return the usage string based on the available options."""
621         if level is not None:
622             warnings.warn(
623                 "Supplying a 'level' argument to help() has been deprecated."
624                 "You can call help() without any arguments.",
625                 DeprecationWarning,
626             )
627         return self._arg_parser.format_help()
628 
629     def cb_set_provider_option(self, option, opt, value, parser):  # pragma: no cover
630         """DEPRECATED: Optik callback for option setting."""
631         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme
632         warnings.warn(
633             "cb_set_provider_option has been deprecated. It will be removed in pylint 3.0.",
634             DeprecationWarning,
635         )
636         if opt.startswith("--"):
637             # remove -- on long option
638             opt = opt[2:]
639         else:
640             # short option, get its long equivalent
641             opt = self._short_options[opt[1:]]
642         # trick since we can't set action='store_true' on options
643         if value is None:
644             value = 1
645         self.set_option(opt, value)
646 
647     def global_set_option(self, opt: str, value: Any) -> None:  # pragma: no cover
648         """DEPRECATED: Set option on the correct option provider."""
649         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme
650         warnings.warn(
651             "global_set_option has been deprecated. You can use _arguments_manager.set_option "
652             "or linter.set_option to set options on the global configuration object.",
653             DeprecationWarning,
654         )
655         self.set_option(opt, value)
656 
657     def _generate_config_file(self) -> None:
658         """Write a configuration file according to the current configuration into stdout."""
659         toml_doc = tomlkit.document()
660         pylint_tool_table = tomlkit.table(is_super_table=True)
661         toml_doc.add(tomlkit.key(["tool", "pylint"]), pylint_tool_table)
662 
663         for group in sorted(
664             self._arg_parser._action_groups,
665             key=lambda x: (x.title != "Master", x.title),
666         ):
667             # Skip the options section with the --help option
668             if group.title == "options":
669                 continue
670 
671             # Skip sections without options such as "positional arguments"
672             if not group._group_actions:
673                 continue
674 
675             group_table = tomlkit.table()
676             for action in sorted(
677                 group._group_actions, key=lambda x: x.option_strings[0][2:]
678             ):
679                 optname = action.option_strings[0][2:]
680 
681                 # We skip old name options that don't have their own optdict
682                 try:
683                     optdict = self._option_dicts[optname]
684                 except KeyError:
685                     continue
686 
687                 if optdict.get("hide_from_config_file"):
688                     continue
689 
690                 # Add help comment
691                 help_msg = optdict.get("help", "")
692                 assert isinstance(help_msg, str)
693                 help_text = textwrap.wrap(help_msg, width=79)
694                 for line in help_text:
695                     group_table.add(tomlkit.comment(line))
696 
697                 # Get current value of option
698                 value = getattr(self.config, optname.replace("-", "_"))
699 
700                 # Create a comment if the option has no value
701                 if not value:
702                     group_table.add(tomlkit.comment(f"{optname} ="))
703                     group_table.add(tomlkit.nl())
704                     continue
705 
706                 # Tomlkit doesn't support regular expressions
707                 if isinstance(value, re.Pattern):
708                     value = value.pattern
709                 elif isinstance(value, (list, tuple)) and isinstance(
710                     value[0], re.Pattern
711                 ):
712                     value = [i.pattern for i in value]
713 
714                 # Add to table
715                 group_table.add(optname, value)
716                 group_table.add(tomlkit.nl())
717 
718             assert group.title
719             pylint_tool_table.add(group.title.lower(), group_table)
720 
721         toml_string = tomlkit.dumps(toml_doc)
722 
723         # Make sure the string we produce is valid toml and can be parsed
724         tomllib.loads(toml_string)
725 
726         print(toml_string)
727 
728     def set_option(
729         self,
730         optname: str,
731         value: Any,
732         action: str | None = "default_value",
733         optdict: None | str | OptionDict = "default_value",
734     ) -> None:
735         """Set an option on the namespace object."""
736         # TODO: 3.0: Remove deprecated arguments. # pylint: disable=fixme
737         if action != "default_value":
738             warnings.warn(
739                 "The 'action' argument has been deprecated. You can use set_option "
740                 "without the 'action' or 'optdict' arguments.",
741                 DeprecationWarning,
742             )
743         if optdict != "default_value":
744             warnings.warn(
745                 "The 'optdict' argument has been deprecated. You can use set_option "
746                 "without the 'action' or 'optdict' arguments.",
747                 DeprecationWarning,
748             )
749 
750         self.config = self._arg_parser.parse_known_args(
751             [f"--{optname.replace('_', '-')}", _parse_rich_type_value(value)],
752             self.config,
753         )[0]

</code><intended_behavior>Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value.</intended_behavior>]
2025-10-17 16:20:41.908 | INFO     | Search completed. Bug locations: [<file>pylint/config/argument.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Definition of an Argument class and transformers for various argument types.
6 
7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser
8 """
9 
10 from __future__ import annotations
11 
12 import argparse
13 import pathlib
14 import re
15 import sys
16 from collections.abc import Callable
17 from typing import Any, Pattern, Sequence, Tuple, Union
18 
19 from pylint import interfaces
20 from pylint import utils as pylint_utils
21 from pylint.config.callback_actions import _CallbackAction, _ExtendAction
22 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction
23 from pylint.constants import PY38_PLUS
24 
25 if sys.version_info >= (3, 8):
26     from typing import Literal
27 else:
28     from typing_extensions import Literal
29 
30 
31 _ArgumentTypes = Union[
32     str,
33     int,
34     float,
35     bool,
36     Pattern[str],
37     Sequence[str],
38     Sequence[Pattern[str]],
39     Tuple[int, ...],
40 ]
41 """List of possible argument types."""
42 
43 
44 def _confidence_transformer(value: str) -> Sequence[str]:
45     """Transforms a comma separated string of confidence values."""
46     values = pylint_utils._check_csv(value)
47     for confidence in values:
48         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:
49             raise argparse.ArgumentTypeError(
50                 f"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}"
51             )
52     return values
53 
54 
55 def _csv_transformer(value: str) -> Sequence[str]:
56     """Transforms a comma separated string."""
57     return pylint_utils._check_csv(value)
58 
59 
60 YES_VALUES = {"y", "yes", "true"}
61 NO_VALUES = {"n", "no", "false"}
62 
63 
64 def _yn_transformer(value: str) -> bool:
65     """Transforms a yes/no or stringified bool into a bool."""
66     value = value.lower()
67     if value in YES_VALUES:
68         return True
69     if value in NO_VALUES:
70         return False
71     raise argparse.ArgumentTypeError(
72         None, f"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}"
73     )
74 
75 
76 def _non_empty_string_transformer(value: str) -> str:
77     """Check that a string is not empty and remove quotes."""
78     if not value:
79         raise argparse.ArgumentTypeError("Option cannot be an empty string.")
80     return pylint_utils._unquote(value)
81 
82 
83 def _py_version_transformer(value: str) -> tuple[int, ...]:
84     """Transforms a version string into a version tuple."""
85     try:
86         version = tuple(int(val) for val in value.replace(",", ".").split("."))
87     except ValueError:
88         raise argparse.ArgumentTypeError(
89             f"{value} has an invalid format, should be a version string. E.g., '3.8'"
90         ) from None
91     return version
92 
93 
94 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
95     """Transforms a comma separated list of regular expressions."""
96     patterns: list[Pattern[str]] = []
97     for pattern in _csv_transformer(value):
98         patterns.append(re.compile(pattern))
99     return patterns
100 
101 
102 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:
103     """Transforms a comma separated list of regular expressions paths."""
104     patterns: list[Pattern[str]] = []
105     for pattern in _csv_transformer(value):
106         patterns.append(
107             re.compile(
108                 str(pathlib.PureWindowsPath(pattern)).replace("\\", "\\\\")
109                 + "|"
110                 + pathlib.PureWindowsPath(pattern).as_posix()
111             )
112         )
113     return patterns
114 
115 
116 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {
117     "choice": str,
118     "csv": _csv_transformer,
119     "float": float,
120     "int": int,
121     "confidence": _confidence_transformer,
122     "non_empty_string": _non_empty_string_transformer,
123     "py_version": _py_version_transformer,
124     "regexp": re.compile,
125     "regexp_csv": _regexp_csv_transfomer,
126     "regexp_paths_csv": _regexp_paths_csv_transfomer,
127     "string": pylint_utils._unquote,
128     "yn": _yn_transformer,
129 }
130 """Type transformers for all argument types.
131 
132 A transformer should accept a string and return one of the supported
133 Argument types. It will only be called when parsing 1) command-line,
134 2) configuration files and 3) a string default value.
135 Non-string default values are assumed to be of the correct type.
136 """
137 
138 
139 class _Argument:
140     """Class representing an argument to be parsed by an argparse.ArgumentsParser.
141 
142     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
143     See:
144     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
145     """
146 
147     def __init__(
148         self,
149         *,
150         flags: list[str],
151         arg_help: str,
152         hide_help: bool,
153         section: str | None,
154     ) -> None:
155         self.flags = flags
156         """The name of the argument."""
157 
158         self.hide_help = hide_help
159         """Whether to hide this argument in the help message."""
160 
161         # argparse uses % formatting on help strings, so a % needs to be escaped
162         self.help = arg_help.replace("%", "%%")
163         """The description of the argument."""
164 
165         if hide_help:
166             self.help = argparse.SUPPRESS
167 
168         self.section = section
169         """The section to add this argument to."""
170 
171 
172 class _BaseStoreArgument(_Argument):
173     """Base class for store arguments to be parsed by an argparse.ArgumentsParser.
174 
175     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
176     See:
177     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
178     """
179 
180     def __init__(
181         self,
182         *,
183         flags: list[str],
184         action: str,
185         default: _ArgumentTypes,
186         arg_help: str,
187         hide_help: bool,
188         section: str | None,
189     ) -> None:
190         super().__init__(
191             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
192         )
193 
194         self.action = action
195         """The action to perform with the argument."""
196 
197         self.default = default
198         """The default value of the argument."""
199 
200 
201 class _StoreArgument(_BaseStoreArgument):
202     """Class representing a store argument to be parsed by an argparse.ArgumentsParser.
203 
204     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
205     See:
206     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
207     """
208 
209     def __init__(
210         self,
211         *,
212         flags: list[str],
213         action: str,
214         default: _ArgumentTypes,
215         arg_type: str,
216         choices: list[str] | None,
217         arg_help: str,
218         metavar: str,
219         hide_help: bool,
220         section: str | None,
221     ) -> None:
222         super().__init__(
223             flags=flags,
224             action=action,
225             default=default,
226             arg_help=arg_help,
227             hide_help=hide_help,
228             section=section,
229         )
230 
231         self.type = _TYPE_TRANSFORMERS[arg_type]
232         """A transformer function that returns a transformed type of the argument."""
233 
234         self.choices = choices
235         """A list of possible choices for the argument.
236 
237         None if there are no restrictions.
238         """
239 
240         self.metavar = metavar
241         """The metavar of the argument.
242 
243         See:
244         https://docs.python.org/3/library/argparse.html#metavar
245         """
246 
247 
248 class _StoreTrueArgument(_BaseStoreArgument):
249     """Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.
250 
251     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
252     See:
253     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
254     """
255 
256     # pylint: disable-next=useless-super-delegation # We narrow down the type of action
257     def __init__(
258         self,
259         *,
260         flags: list[str],
261         action: Literal["store_true"],
262         default: _ArgumentTypes,
263         arg_help: str,
264         hide_help: bool,
265         section: str | None,
266     ) -> None:
267         super().__init__(
268             flags=flags,
269             action=action,
270             default=default,
271             arg_help=arg_help,
272             hide_help=hide_help,
273             section=section,
274         )
275 
276 
277 class _DeprecationArgument(_Argument):
278     """Store arguments while also handling deprecation warnings for old and new names.
279 
280     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
281     See:
282     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
283     """
284 
285     def __init__(
286         self,
287         *,
288         flags: list[str],
289         action: type[argparse.Action],
290         default: _ArgumentTypes,
291         arg_type: str,
292         choices: list[str] | None,
293         arg_help: str,
294         metavar: str,
295         hide_help: bool,
296         section: str | None,
297     ) -> None:
298         super().__init__(
299             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
300         )
301 
302         self.action = action
303         """The action to perform with the argument."""
304 
305         self.default = default
306         """The default value of the argument."""
307 
308         self.type = _TYPE_TRANSFORMERS[arg_type]
309         """A transformer function that returns a transformed type of the argument."""
310 
311         self.choices = choices
312         """A list of possible choices for the argument.
313 
314         None if there are no restrictions.
315         """
316 
317         self.metavar = metavar
318         """The metavar of the argument.
319 
320         See:
321         https://docs.python.org/3/library/argparse.html#metavar
322         """
323 
324 
325 class _ExtendArgument(_DeprecationArgument):
326     """Class for extend arguments to be parsed by an argparse.ArgumentsParser.
327 
328     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
329     See:
330     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
331     """
332 
333     def __init__(
334         self,
335         *,
336         flags: list[str],
337         action: Literal["extend"],
338         default: _ArgumentTypes,
339         arg_type: str,
340         metavar: str,
341         arg_help: str,
342         hide_help: bool,
343         section: str | None,
344         choices: list[str] | None,
345         dest: str | None,
346     ) -> None:
347         # The extend action is included in the stdlib from 3.8+
348         if PY38_PLUS:
349             action_class = argparse._ExtendAction  # type: ignore[attr-defined]
350         else:
351             action_class = _ExtendAction
352 
353         self.dest = dest
354         """The destination of the argument."""
355 
356         super().__init__(
357             flags=flags,
358             action=action_class,
359             default=default,
360             arg_type=arg_type,
361             choices=choices,
362             arg_help=arg_help,
363             metavar=metavar,
364             hide_help=hide_help,
365             section=section,
366         )
367 
368 
369 class _StoreOldNamesArgument(_DeprecationArgument):
370     """Store arguments while also handling old names.
371 
372     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
373     See:
374     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
375     """
376 
377     def __init__(
378         self,
379         *,
380         flags: list[str],
381         default: _ArgumentTypes,
382         arg_type: str,
383         choices: list[str] | None,
384         arg_help: str,
385         metavar: str,
386         hide_help: bool,
387         kwargs: dict[str, Any],
388         section: str | None,
389     ) -> None:
390         super().__init__(
391             flags=flags,
392             action=_OldNamesAction,
393             default=default,
394             arg_type=arg_type,
395             choices=choices,
396             arg_help=arg_help,
397             metavar=metavar,
398             hide_help=hide_help,
399             section=section,
400         )
401 
402         self.kwargs = kwargs
403         """Any additional arguments passed to the action."""
404 
405 
406 class _StoreNewNamesArgument(_DeprecationArgument):
407     """Store arguments while also emitting deprecation warnings.
408 
409     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
410     See:
411     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
412     """
413 
414     def __init__(
415         self,
416         *,
417         flags: list[str],
418         default: _ArgumentTypes,
419         arg_type: str,
420         choices: list[str] | None,
421         arg_help: str,
422         metavar: str,
423         hide_help: bool,
424         kwargs: dict[str, Any],
425         section: str | None,
426     ) -> None:
427         super().__init__(
428             flags=flags,
429             action=_NewNamesAction,
430             default=default,
431             arg_type=arg_type,
432             choices=choices,
433             arg_help=arg_help,
434             metavar=metavar,
435             hide_help=hide_help,
436             section=section,
437         )
438 
439         self.kwargs = kwargs
440         """Any additional arguments passed to the action."""
441 
442 
443 class _CallableArgument(_Argument):
444     """Class representing an callable argument to be parsed by an argparse.ArgumentsParser.
445 
446     This is based on the parameters passed to argparse.ArgumentsParser.add_message.
447     See:
448     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
449     """
450 
451     def __init__(
452         self,
453         *,
454         flags: list[str],
455         action: type[_CallbackAction],
456         arg_help: str,
457         kwargs: dict[str, Any],
458         hide_help: bool,
459         section: str | None,
460     ) -> None:
461         super().__init__(
462             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section
463         )
464 
465         self.action = action
466         """The action to perform with the argument."""
467 
468         self.kwargs = kwargs
469         """Any additional arguments passed to the action."""

</code><intended_behavior>Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value.</intended_behavior>, <file>pylint/config/arguments_manager.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Arguments manager class used to handle command-line arguments and options."""
6 
7 from __future__ import annotations
8 
9 import argparse
10 import configparser
11 import copy
12 import optparse  # pylint: disable=deprecated-module
13 import os
14 import re
15 import sys
16 import textwrap
17 import warnings
18 from collections import OrderedDict
19 from collections.abc import Sequence
20 from pathlib import Path
21 from typing import TYPE_CHECKING, Any, TextIO, Union
22 
23 import tomlkit
24 
25 from pylint import utils
26 from pylint.config.argument import (
27     _Argument,
28     _CallableArgument,
29     _ExtendArgument,
30     _StoreArgument,
31     _StoreNewNamesArgument,
32     _StoreOldNamesArgument,
33     _StoreTrueArgument,
34 )
35 from pylint.config.exceptions import (
36     UnrecognizedArgumentAction,
37     _UnrecognizedOptionError,
38 )
39 from pylint.config.help_formatter import _HelpFormatter
40 from pylint.config.option import Option
41 from pylint.config.option_parser import OptionParser
42 from pylint.config.options_provider_mixin import OptionsProviderMixIn
43 from pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value
44 from pylint.constants import MAIN_CHECKER_NAME
45 from pylint.typing import OptionDict
46 
47 if sys.version_info >= (3, 11):
48     import tomllib
49 else:
50     import tomli as tomllib
51 
52 
53 if TYPE_CHECKING:
54     from pylint.config.arguments_provider import _ArgumentsProvider
55 
56 ConfigProvider = Union["_ArgumentsProvider", OptionsProviderMixIn]
57 
58 
59 # pylint: disable-next=too-many-instance-attributes
60 class _ArgumentsManager:
61     """Arguments manager class used to handle command-line arguments and options."""
62 
63     def __init__(
64         self, prog: str, usage: str | None = None, description: str | None = None
65     ) -> None:
66         self._config = argparse.Namespace()
67         """Namespace for all options."""
68 
69         self._arg_parser = argparse.ArgumentParser(
70             prog=prog,
71             usage=usage or "%(prog)s [options]",
72             description=description,
73             formatter_class=_HelpFormatter,
74         )
75         """The command line argument parser."""
76 
77         self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}
78         """Dictionary of all the argument groups."""
79 
80         self._option_dicts: dict[str, OptionDict] = {}
81         """All option dictionaries that have been registered."""
82 
83         # pylint: disable=fixme
84         # TODO: 3.0: Remove deprecated attributes introduced to keep API
85         # parity with optparse. Until '_maxlevel'
86         with warnings.catch_warnings():
87             warnings.filterwarnings("ignore", category=DeprecationWarning)
88             self.reset_parsers(usage or "")
89         # list of registered options providers
90         self._options_providers: list[ConfigProvider] = []
91         # dictionary associating option name to checker
92         self._all_options: OrderedDict[str, ConfigProvider] = OrderedDict()
93         self._short_options: dict[str, str] = {}
94         self._nocallback_options: dict[ConfigProvider, str] = {}
95         self._mygroups: dict[str, optparse.OptionGroup] = {}
96         # verbosity
97         self._maxlevel: int = 0
98 
99     @property
100     def config(self) -> argparse.Namespace:
101         """Namespace for all options."""
102         return self._config
103 
104     @config.setter
105     def config(self, value: argparse.Namespace) -> None:
106         self._config = value
107 
108     @property
109     def options_providers(self) -> list[ConfigProvider]:
110         # TODO: 3.0: Remove deprecated attribute. # pylint: disable=fixme
111         warnings.warn(
112             "options_providers has been deprecated. It will be removed in pylint 3.0.",
113             DeprecationWarning,
114         )
115         return self._options_providers
116 
117     @options_providers.setter
118     def options_providers(self, value: list[ConfigProvider]) -> None:
119         warnings.warn(
120             "Setting options_providers has been deprecated. It will be removed in pylint 3.0.",
121             DeprecationWarning,
122         )
123         self._options_providers = value
124 
125     def _register_options_provider(self, provider: _ArgumentsProvider) -> None:
126         """Register an options provider and load its defaults."""
127         for opt, optdict in provider.options:
128             self._option_dicts[opt] = optdict
129             argument = _convert_option_to_argument(opt, optdict)
130             section = argument.section or provider.name.capitalize()
131 
132             section_desc = provider.option_groups_descs.get(section, None)
133 
134             # We exclude master since its docstring comes from PyLinter
135             if provider.name != MAIN_CHECKER_NAME and provider.__doc__:
136                 section_desc = provider.__doc__.split("\n\n")[0]
137 
138             self._add_arguments_to_parser(section, section_desc, argument)
139 
140         self._load_default_argument_values()
141 
142     def _add_arguments_to_parser(
143         self, section: str, section_desc: str | None, argument: _Argument
144     ) -> None:
145         """Add an argument to the correct argument section/group."""
146         try:
147             section_group = self._argument_groups_dict[section]
148         except KeyError:
149             if section_desc:
150                 section_group = self._arg_parser.add_argument_group(
151                     section, section_desc
152                 )
153             else:
154                 section_group = self._arg_parser.add_argument_group(title=section)
155             self._argument_groups_dict[section] = section_group
156         self._add_parser_option(section_group, argument)
157 
158     @staticmethod
159     def _add_parser_option(
160         section_group: argparse._ArgumentGroup, argument: _Argument
161     ) -> None:
162         """Add an argument."""
163         if isinstance(argument, _StoreArgument):
164             section_group.add_argument(
165                 *argument.flags,
166                 action=argument.action,
167                 default=argument.default,
168                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
169                 help=argument.help,
170                 metavar=argument.metavar,
171                 choices=argument.choices,
172             )
173         elif isinstance(argument, _StoreOldNamesArgument):
174             section_group.add_argument(
175                 *argument.flags,
176                 **argument.kwargs,
177                 action=argument.action,
178                 default=argument.default,
179                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
180                 help=argument.help,
181                 metavar=argument.metavar,
182                 choices=argument.choices,
183             )
184             # We add the old name as hidden option to make it's default value gets loaded when
185             # argparse initializes all options from the checker
186             assert argument.kwargs["old_names"]
187             for old_name in argument.kwargs["old_names"]:
188                 section_group.add_argument(
189                     f"--{old_name}",
190                     action="store",
191                     default=argument.default,
192                     type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
193                     help=argparse.SUPPRESS,
194                     metavar=argument.metavar,
195                     choices=argument.choices,
196                 )
197         elif isinstance(argument, _StoreNewNamesArgument):
198             section_group.add_argument(
199                 *argument.flags,
200                 **argument.kwargs,
201                 action=argument.action,
202                 default=argument.default,
203                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
204                 help=argument.help,
205                 metavar=argument.metavar,
206                 choices=argument.choices,
207             )
208         elif isinstance(argument, _StoreTrueArgument):
209             section_group.add_argument(
210                 *argument.flags,
211                 action=argument.action,
212                 default=argument.default,
213                 help=argument.help,
214             )
215         elif isinstance(argument, _CallableArgument):
216             section_group.add_argument(
217                 *argument.flags,
218                 **argument.kwargs,
219                 action=argument.action,
220                 help=argument.help,
221             )
222         elif isinstance(argument, _ExtendArgument):
223             section_group.add_argument(
224                 *argument.flags,
225                 action=argument.action,
226                 default=argument.default,
227                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed
228                 help=argument.help,
229                 metavar=argument.metavar,
230                 choices=argument.choices,
231                 dest=argument.dest,
232             )
233         else:
234             raise UnrecognizedArgumentAction
235 
236     def _load_default_argument_values(self) -> None:
237         """Loads the default values of all registered options."""
238         self.config = self._arg_parser.parse_args([], self.config)
239 
240     def _parse_configuration_file(self, arguments: list[str]) -> None:
241         """Parse the arguments found in a configuration file into the namespace."""
242         self.config, parsed_args = self._arg_parser.parse_known_args(
243             arguments, self.config
244         )
245         unrecognized_options: list[str] = []
246         for opt in parsed_args:
247             if opt.startswith("--"):
248                 unrecognized_options.append(opt[2:])
249         if unrecognized_options:
250             raise _UnrecognizedOptionError(options=unrecognized_options)
251 
252     def _parse_command_line_configuration(
253         self, arguments: Sequence[str] | None = None
254     ) -> list[str]:
255         """Parse the arguments found on the command line into the namespace."""
256         arguments = sys.argv[1:] if arguments is None else arguments
257 
258         self.config, parsed_args = self._arg_parser.parse_known_args(
259             arguments, self.config
260         )
261 
262         return parsed_args
263 
264     def reset_parsers(self, usage: str = "") -> None:  # pragma: no cover
265         """DEPRECATED."""
266         warnings.warn(
267             "reset_parsers has been deprecated. Parsers should be instantiated "
268             "once during initialization and do not need to be reset.",
269             DeprecationWarning,
270         )
271         # configuration file parser
272         self.cfgfile_parser = configparser.ConfigParser(
273             inline_comment_prefixes=("#", ";")
274         )
275         # command line parser
276         self.cmdline_parser = OptionParser(Option, usage=usage)
277         self.cmdline_parser.options_manager = self  # type: ignore[attr-defined]
278         self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)
279 
280     def register_options_provider(
281         self, provider: ConfigProvider, own_group: bool = True
282     ) -> None:  # pragma: no cover
283         """DEPRECATED: Register an options provider."""
284         warnings.warn(
285             "register_options_provider has been deprecated. Options providers and "
286             "arguments providers should be registered by initializing ArgumentsProvider. "
287             "This automatically registers the provider on the ArgumentsManager.",
288             DeprecationWarning,
289         )
290         self.options_providers.append(provider)
291         non_group_spec_options = [
292             option for option in provider.options if "group" not in option[1]
293         ]
294         groups = getattr(provider, "option_groups", ())
295         if own_group and non_group_spec_options:
296             with warnings.catch_warnings():
297                 warnings.filterwarnings("ignore", category=DeprecationWarning)
298                 self.add_option_group(
299                     provider.name.upper(),
300                     provider.__doc__,
301                     non_group_spec_options,
302                     provider,
303                 )
304         else:
305             for opt, optdict in non_group_spec_options:
306                 with warnings.catch_warnings():
307                     warnings.filterwarnings("ignore", category=DeprecationWarning)
308                     self.add_optik_option(provider, self.cmdline_parser, opt, optdict)
309         for gname, gdoc in groups:
310             gname = gname.upper()
311             goptions = [
312                 option
313                 for option in provider.options
314                 if option[1].get("group", "").upper() == gname  # type: ignore[union-attr]
315             ]
316             with warnings.catch_warnings():
317                 warnings.filterwarnings("ignore", category=DeprecationWarning)
318                 self.add_option_group(gname, gdoc, goptions, provider)
319 
320     def add_option_group(
321         self,
322         group_name: str,
323         _: str | None,
324         options: list[tuple[str, OptionDict]],
325         provider: ConfigProvider,
326     ) -> None:  # pragma: no cover
327         """DEPRECATED."""
328         warnings.warn(
329             "add_option_group has been deprecated. Option groups should be "
330             "registered by initializing ArgumentsProvider. "
331             "This automatically registers the group on the ArgumentsManager.",
332             DeprecationWarning,
333         )
334         # add option group to the command line parser
335         if group_name in self._mygroups:
336             group = self._mygroups[group_name]
337         else:
338             group = optparse.OptionGroup(
339                 self.cmdline_parser, title=group_name.capitalize()
340             )
341             self.cmdline_parser.add_option_group(group)
342             self._mygroups[group_name] = group
343             # add section to the config file
344             if (
345                 group_name != "DEFAULT"
346                 and group_name not in self.cfgfile_parser._sections  # type: ignore[attr-defined]
347             ):
348                 self.cfgfile_parser.add_section(group_name)
349         # add provider's specific options
350         for opt, optdict in options:
351             if not isinstance(optdict.get("action", "store"), str):
352                 optdict["action"] = "callback"
353             with warnings.catch_warnings():
354                 warnings.filterwarnings("ignore", category=DeprecationWarning)
355                 self.add_optik_option(provider, group, opt, optdict)
356 
357     def add_optik_option(
358         self,
359         provider: ConfigProvider,
360         optikcontainer: optparse.OptionParser | optparse.OptionGroup,
361         opt: str,
362         optdict: OptionDict,
363     ) -> None:  # pragma: no cover
364         """DEPRECATED."""
365         warnings.warn(
366             "add_optik_option has been deprecated. Options should be automatically "
367             "added by initializing an ArgumentsProvider.",
368             DeprecationWarning,
369         )
370         with warnings.catch_warnings():
371             warnings.filterwarnings("ignore", category=DeprecationWarning)
372             args, optdict = self.optik_option(provider, opt, optdict)
373         option = optikcontainer.add_option(*args, **optdict)
374         self._all_options[opt] = provider
375         self._maxlevel = max(self._maxlevel, option.level or 0)
376 
377     def optik_option(
378         self, provider: ConfigProvider, opt: str, optdict: OptionDict
379     ) -> tuple[list[str], OptionDict]:  # pragma: no cover
380         """DEPRECATED: Get our personal option definition and return a suitable form for
381         use with optik/optparse
382         """
383         warnings.warn(
384             "optik_option has been deprecated. Parsing of option dictionaries should be done "
385             "automatically by initializing an ArgumentsProvider.",
386             DeprecationWarning,
387         )
388         optdict = copy.copy(optdict)
389         if "action" in optdict:
390             self._nocallback_options[provider] = opt
391         else:
392             optdict["action"] = "callback"
393             optdict["callback"] = self.cb_set_provider_option
394         # default is handled here and *must not* be given to optik if you
395         # want the whole machinery to work
396         if "default" in optdict:
397             if (
398                 "help" in optdict
399                 and optdict.get("default") is not None
400                 and optdict["action"] not in ("store_true", "store_false")
401             ):
402                 optdict["help"] += " [current: %default]"  # type: ignore[operator]
403             del optdict["default"]
404         args = ["--" + str(opt)]
405         if "short" in optdict:
406             self._short_options[optdict["short"]] = opt  # type: ignore[index]
407             args.append("-" + optdict["short"])  # type: ignore[operator]
408             del optdict["short"]
409         # cleanup option definition dict before giving it to optik
410         for key in list(optdict.keys()):
411             if key not in self._optik_option_attrs:
412                 optdict.pop(key)
413         return args, optdict
414 
415     def generate_config(
416         self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()
417     ) -> None:  # pragma: no cover
418         """DEPRECATED: Write a configuration file according to the current configuration
419         into the given stream or stdout
420         """
421         warnings.warn(
422             "generate_config has been deprecated. It will be removed in pylint 3.0.",
423             DeprecationWarning,
424         )
425         options_by_section = {}
426         sections = []
427         for group in self._arg_parser._action_groups:
428             group_name = group.title
429             assert group_name
430             if group_name in skipsections:
431                 continue
432 
433             options = []
434             for opt in group._group_actions:
435                 if "--help" in opt.option_strings:
436                     continue
437 
438                 optname = opt.option_strings[0][2:]
439 
440                 try:
441                     optdict = self._option_dicts[optname]
442                 except KeyError:
443                     continue
444 
445                 options.append(
446                     (
447                         optname,
448                         optdict,
449                         getattr(self.config, optname.replace("-", "_")),
450                     )
451                 )
452 
453                 options = [
454                     (n, d, v) for (n, d, v) in options if not d.get("deprecated")
455                 ]
456 
457             if options:
458                 sections.append(group_name)
459                 options_by_section[group_name] = options
460         stream = stream or sys.stdout
461         printed = False
462         for section in sections:
463             if printed:
464                 print("\n", file=stream)
465             with warnings.catch_warnings():
466                 warnings.filterwarnings("ignore", category=DeprecationWarning)
467                 utils.format_section(
468                     stream, section.upper(), sorted(options_by_section[section])
469                 )
470             printed = True
471 
472     def load_provider_defaults(self) -> None:  # pragma: no cover
473         """DEPRECATED: Initialize configuration using default values."""
474         warnings.warn(
475             "load_provider_defaults has been deprecated. Parsing of option defaults should be done "
476             "automatically by initializing an ArgumentsProvider.",
477             DeprecationWarning,
478         )
479         for provider in self.options_providers:
480             with warnings.catch_warnings():
481                 warnings.filterwarnings("ignore", category=DeprecationWarning)
482                 provider.load_defaults()
483 
484     def read_config_file(
485         self, config_file: Path | None = None, verbose: bool = False
486     ) -> None:  # pragma: no cover
487         """DEPRECATED: Read the configuration file but do not load it (i.e. dispatching
488         values to each option's provider)
489 
490         :raises OSError: Whem the specified config file doesn't exist
491         """
492         warnings.warn(
493             "read_config_file has been deprecated. It will be removed in pylint 3.0.",
494             DeprecationWarning,
495         )
496         if not config_file:
497             if verbose:
498                 print(
499                     "No config file found, using default configuration", file=sys.stderr
500                 )
501             return
502         config_file = Path(os.path.expandvars(config_file)).expanduser()
503         if not config_file.exists():
504             raise OSError(f"The config file {str(config_file)} doesn't exist!")
505         parser = self.cfgfile_parser
506         if config_file.suffix == ".toml":
507             try:
508                 self._parse_toml(config_file, parser)
509             except tomllib.TOMLDecodeError:
510                 pass
511         else:
512             # Use this encoding in order to strip the BOM marker, if any.
513             with open(config_file, encoding="utf_8_sig") as fp:
514                 parser.read_file(fp)
515             # normalize each section's title
516             for sect, values in list(parser._sections.items()):  # type: ignore[attr-defined]
517                 if sect.startswith("pylint."):
518                     sect = sect[len("pylint.") :]
519                 if not sect.isupper() and values:
520                     parser._sections[sect.upper()] = values  # type: ignore[attr-defined]
521 
522         if verbose:
523             print(f"Using config file '{config_file}'", file=sys.stderr)
524 
525     @staticmethod
526     def _parse_toml(
527         config_file: Path, parser: configparser.ConfigParser
528     ) -> None:  # pragma: no cover
529         """DEPRECATED: Parse and handle errors of a toml configuration file.
530 
531         TODO: 3.0: Remove depreacted method.
532         """
533         with open(config_file, mode="rb") as fp:
534             content = tomllib.load(fp)
535         try:
536             sections_values = content["tool"]["pylint"]
537         except KeyError:
538             return
539         for section, values in sections_values.items():
540             section_name = section.upper()
541             # TOML has rich types, convert values to
542             # strings as ConfigParser expects.
543             if not isinstance(values, dict):
544                 continue
545             for option, value in values.items():
546                 if isinstance(value, bool):
547                     values[option] = "yes" if value else "no"
548                 elif isinstance(value, list):
549                     values[option] = ",".join(value)
550                 else:
551                     values[option] = str(value)
552             for option, value in values.items():
553                 try:
554                     parser.set(section_name, option, value=value)
555                 except configparser.NoSectionError:
556                     parser.add_section(section_name)
557                     parser.set(section_name, option, value=value)
558 
559     def load_config_file(self) -> None:  # pragma: no cover
560         """DEPRECATED: Dispatch values previously read from a configuration file to each
561         option's provider
562         """
563         warnings.warn(
564             "load_config_file has been deprecated. It will be removed in pylint 3.0.",
565             DeprecationWarning,
566         )
567         parser = self.cfgfile_parser
568         for section in parser.sections():
569             for option, value in parser.items(section):
570                 try:
571                     self.global_set_option(option, value)
572                 except (KeyError, optparse.OptionError):
573                     continue
574 
575     def load_configuration(self, **kwargs: Any) -> None:  # pragma: no cover
576         """DEPRECATED: Override configuration according to given parameters."""
577         warnings.warn(
578             "load_configuration has been deprecated. It will be removed in pylint 3.0.",
579             DeprecationWarning,
580         )
581         with warnings.catch_warnings():
582             warnings.filterwarnings("ignore", category=DeprecationWarning)
583             return self.load_configuration_from_config(kwargs)
584 
585     def load_configuration_from_config(
586         self, config: dict[str, Any]
587     ) -> None:  # pragma: no cover
588         warnings.warn(
589             "DEPRECATED: load_configuration_from_config has been deprecated. It will be removed in pylint 3.0.",
590             DeprecationWarning,
591         )
592         for opt, opt_value in config.items():
593             opt = opt.replace("_", "-")
594             provider = self._all_options[opt]
595             provider.set_option(opt, opt_value)
596 
597     def load_command_line_configuration(
598         self, args: list[str] | None = None
599     ) -> list[str]:  # pragma: no cover
600         """DEPRECATED: Override configuration according to command line parameters.
601 
602         return additional arguments
603         """
604         warnings.warn(
605             "load_command_line_configuration has been deprecated. It will be removed in pylint 3.0.",
606             DeprecationWarning,
607         )
608         args = sys.argv[1:] if args is None else list(args)
609         (options, args) = self.cmdline_parser.parse_args(args=args)
610         for provider in self._nocallback_options:
611             config = provider.config
612             for attr in config.__dict__.keys():
613                 value = getattr(options, attr, None)
614                 if value is None:
615                     continue
616                 setattr(config, attr, value)
617         return args
618 
619     def help(self, level: int | None = None) -> str:
620         """Return the usage string based on the available options."""
621         if level is not None:
622             warnings.warn(
623                 "Supplying a 'level' argument to help() has been deprecated."
624                 "You can call help() without any arguments.",
625                 DeprecationWarning,
626             )
627         return self._arg_parser.format_help()
628 
629     def cb_set_provider_option(self, option, opt, value, parser):  # pragma: no cover
630         """DEPRECATED: Optik callback for option setting."""
631         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme
632         warnings.warn(
633             "cb_set_provider_option has been deprecated. It will be removed in pylint 3.0.",
634             DeprecationWarning,
635         )
636         if opt.startswith("--"):
637             # remove -- on long option
638             opt = opt[2:]
639         else:
640             # short option, get its long equivalent
641             opt = self._short_options[opt[1:]]
642         # trick since we can't set action='store_true' on options
643         if value is None:
644             value = 1
645         self.set_option(opt, value)
646 
647     def global_set_option(self, opt: str, value: Any) -> None:  # pragma: no cover
648         """DEPRECATED: Set option on the correct option provider."""
649         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme
650         warnings.warn(
651             "global_set_option has been deprecated. You can use _arguments_manager.set_option "
652             "or linter.set_option to set options on the global configuration object.",
653             DeprecationWarning,
654         )
655         self.set_option(opt, value)
656 
657     def _generate_config_file(self) -> None:
658         """Write a configuration file according to the current configuration into stdout."""
659         toml_doc = tomlkit.document()
660         pylint_tool_table = tomlkit.table(is_super_table=True)
661         toml_doc.add(tomlkit.key(["tool", "pylint"]), pylint_tool_table)
662 
663         for group in sorted(
664             self._arg_parser._action_groups,
665             key=lambda x: (x.title != "Master", x.title),
666         ):
667             # Skip the options section with the --help option
668             if group.title == "options":
669                 continue
670 
671             # Skip sections without options such as "positional arguments"
672             if not group._group_actions:
673                 continue
674 
675             group_table = tomlkit.table()
676             for action in sorted(
677                 group._group_actions, key=lambda x: x.option_strings[0][2:]
678             ):
679                 optname = action.option_strings[0][2:]
680 
681                 # We skip old name options that don't have their own optdict
682                 try:
683                     optdict = self._option_dicts[optname]
684                 except KeyError:
685                     continue
686 
687                 if optdict.get("hide_from_config_file"):
688                     continue
689 
690                 # Add help comment
691                 help_msg = optdict.get("help", "")
692                 assert isinstance(help_msg, str)
693                 help_text = textwrap.wrap(help_msg, width=79)
694                 for line in help_text:
695                     group_table.add(tomlkit.comment(line))
696 
697                 # Get current value of option
698                 value = getattr(self.config, optname.replace("-", "_"))
699 
700                 # Create a comment if the option has no value
701                 if not value:
702                     group_table.add(tomlkit.comment(f"{optname} ="))
703                     group_table.add(tomlkit.nl())
704                     continue
705 
706                 # Tomlkit doesn't support regular expressions
707                 if isinstance(value, re.Pattern):
708                     value = value.pattern
709                 elif isinstance(value, (list, tuple)) and isinstance(
710                     value[0], re.Pattern
711                 ):
712                     value = [i.pattern for i in value]
713 
714                 # Add to table
715                 group_table.add(optname, value)
716                 group_table.add(tomlkit.nl())
717 
718             assert group.title
719             pylint_tool_table.add(group.title.lower(), group_table)
720 
721         toml_string = tomlkit.dumps(toml_doc)
722 
723         # Make sure the string we produce is valid toml and can be parsed
724         tomllib.loads(toml_string)
725 
726         print(toml_string)
727 
728     def set_option(
729         self,
730         optname: str,
731         value: Any,
732         action: str | None = "default_value",
733         optdict: None | str | OptionDict = "default_value",
734     ) -> None:
735         """Set an option on the namespace object."""
736         # TODO: 3.0: Remove deprecated arguments. # pylint: disable=fixme
737         if action != "default_value":
738             warnings.warn(
739                 "The 'action' argument has been deprecated. You can use set_option "
740                 "without the 'action' or 'optdict' arguments.",
741                 DeprecationWarning,
742             )
743         if optdict != "default_value":
744             warnings.warn(
745                 "The 'optdict' argument has been deprecated. You can use set_option "
746                 "without the 'action' or 'optdict' arguments.",
747                 DeprecationWarning,
748             )
749 
750         self.config = self._arg_parser.parse_known_args(
751             [f"--{optname.replace('_', '-')}", _parse_rich_type_value(value)],
752             self.config,
753         )[0]

</code><intended_behavior>Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value.</intended_behavior>]
2025-10-17 16:20:41.909 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 16:20:41.909 | INFO     | Search-only: skipping patch selection
2025-10-17 16:20:42.000 | INFO     | Task pylint-dev__pylint-6386 completed successfully.
2025-10-17 16:20:42.001 | INFO     | No patch generated. You can try running ACR again.
