[
    {
        "rel_file_path": "pylint/config/argument.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/argument.py",
        "start": 1,
        "end": 469,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 \"\"\"Definition of an Argument class and transformers for various argument types.\n6 \n7 An Argument instance represents a pylint option to be handled by an argparse.ArgumentParser\n8 \"\"\"\n9 \n10 from __future__ import annotations\n11 \n12 import argparse\n13 import pathlib\n14 import re\n15 import sys\n16 from collections.abc import Callable\n17 from typing import Any, Pattern, Sequence, Tuple, Union\n18 \n19 from pylint import interfaces\n20 from pylint import utils as pylint_utils\n21 from pylint.config.callback_actions import _CallbackAction, _ExtendAction\n22 from pylint.config.deprecation_actions import _NewNamesAction, _OldNamesAction\n23 from pylint.constants import PY38_PLUS\n24 \n25 if sys.version_info >= (3, 8):\n26     from typing import Literal\n27 else:\n28     from typing_extensions import Literal\n29 \n30 \n31 _ArgumentTypes = Union[\n32     str,\n33     int,\n34     float,\n35     bool,\n36     Pattern[str],\n37     Sequence[str],\n38     Sequence[Pattern[str]],\n39     Tuple[int, ...],\n40 ]\n41 \"\"\"List of possible argument types.\"\"\"\n42 \n43 \n44 def _confidence_transformer(value: str) -> Sequence[str]:\n45     \"\"\"Transforms a comma separated string of confidence values.\"\"\"\n46     values = pylint_utils._check_csv(value)\n47     for confidence in values:\n48         if confidence not in interfaces.CONFIDENCE_LEVEL_NAMES:\n49             raise argparse.ArgumentTypeError(\n50                 f\"{value} should be in {*interfaces.CONFIDENCE_LEVEL_NAMES,}\"\n51             )\n52     return values\n53 \n54 \n55 def _csv_transformer(value: str) -> Sequence[str]:\n56     \"\"\"Transforms a comma separated string.\"\"\"\n57     return pylint_utils._check_csv(value)\n58 \n59 \n60 YES_VALUES = {\"y\", \"yes\", \"true\"}\n61 NO_VALUES = {\"n\", \"no\", \"false\"}\n62 \n63 \n64 def _yn_transformer(value: str) -> bool:\n65     \"\"\"Transforms a yes/no or stringified bool into a bool.\"\"\"\n66     value = value.lower()\n67     if value in YES_VALUES:\n68         return True\n69     if value in NO_VALUES:\n70         return False\n71     raise argparse.ArgumentTypeError(\n72         None, f\"Invalid yn value '{value}', should be in {*YES_VALUES, *NO_VALUES}\"\n73     )\n74 \n75 \n76 def _non_empty_string_transformer(value: str) -> str:\n77     \"\"\"Check that a string is not empty and remove quotes.\"\"\"\n78     if not value:\n79         raise argparse.ArgumentTypeError(\"Option cannot be an empty string.\")\n80     return pylint_utils._unquote(value)\n81 \n82 \n83 def _py_version_transformer(value: str) -> tuple[int, ...]:\n84     \"\"\"Transforms a version string into a version tuple.\"\"\"\n85     try:\n86         version = tuple(int(val) for val in value.replace(\",\", \".\").split(\".\"))\n87     except ValueError:\n88         raise argparse.ArgumentTypeError(\n89             f\"{value} has an invalid format, should be a version string. E.g., '3.8'\"\n90         ) from None\n91     return version\n92 \n93 \n94 def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n95     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n96     patterns: list[Pattern[str]] = []\n97     for pattern in _csv_transformer(value):\n98         patterns.append(re.compile(pattern))\n99     return patterns\n100 \n101 \n102 def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n103     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n104     patterns: list[Pattern[str]] = []\n105     for pattern in _csv_transformer(value):\n106         patterns.append(\n107             re.compile(\n108                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\n109                 + \"|\"\n110                 + pathlib.PureWindowsPath(pattern).as_posix()\n111             )\n112         )\n113     return patterns\n114 \n115 \n116 _TYPE_TRANSFORMERS: dict[str, Callable[[str], _ArgumentTypes]] = {\n117     \"choice\": str,\n118     \"csv\": _csv_transformer,\n119     \"float\": float,\n120     \"int\": int,\n121     \"confidence\": _confidence_transformer,\n122     \"non_empty_string\": _non_empty_string_transformer,\n123     \"py_version\": _py_version_transformer,\n124     \"regexp\": re.compile,\n125     \"regexp_csv\": _regexp_csv_transfomer,\n126     \"regexp_paths_csv\": _regexp_paths_csv_transfomer,\n127     \"string\": pylint_utils._unquote,\n128     \"yn\": _yn_transformer,\n129 }\n130 \"\"\"Type transformers for all argument types.\n131 \n132 A transformer should accept a string and return one of the supported\n133 Argument types. It will only be called when parsing 1) command-line,\n134 2) configuration files and 3) a string default value.\n135 Non-string default values are assumed to be of the correct type.\n136 \"\"\"\n137 \n138 \n139 class _Argument:\n140     \"\"\"Class representing an argument to be parsed by an argparse.ArgumentsParser.\n141 \n142     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n143     See:\n144     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n145     \"\"\"\n146 \n147     def __init__(\n148         self,\n149         *,\n150         flags: list[str],\n151         arg_help: str,\n152         hide_help: bool,\n153         section: str | None,\n154     ) -> None:\n155         self.flags = flags\n156         \"\"\"The name of the argument.\"\"\"\n157 \n158         self.hide_help = hide_help\n159         \"\"\"Whether to hide this argument in the help message.\"\"\"\n160 \n161         # argparse uses % formatting on help strings, so a % needs to be escaped\n162         self.help = arg_help.replace(\"%\", \"%%\")\n163         \"\"\"The description of the argument.\"\"\"\n164 \n165         if hide_help:\n166             self.help = argparse.SUPPRESS\n167 \n168         self.section = section\n169         \"\"\"The section to add this argument to.\"\"\"\n170 \n171 \n172 class _BaseStoreArgument(_Argument):\n173     \"\"\"Base class for store arguments to be parsed by an argparse.ArgumentsParser.\n174 \n175     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n176     See:\n177     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n178     \"\"\"\n179 \n180     def __init__(\n181         self,\n182         *,\n183         flags: list[str],\n184         action: str,\n185         default: _ArgumentTypes,\n186         arg_help: str,\n187         hide_help: bool,\n188         section: str | None,\n189     ) -> None:\n190         super().__init__(\n191             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n192         )\n193 \n194         self.action = action\n195         \"\"\"The action to perform with the argument.\"\"\"\n196 \n197         self.default = default\n198         \"\"\"The default value of the argument.\"\"\"\n199 \n200 \n201 class _StoreArgument(_BaseStoreArgument):\n202     \"\"\"Class representing a store argument to be parsed by an argparse.ArgumentsParser.\n203 \n204     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n205     See:\n206     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n207     \"\"\"\n208 \n209     def __init__(\n210         self,\n211         *,\n212         flags: list[str],\n213         action: str,\n214         default: _ArgumentTypes,\n215         arg_type: str,\n216         choices: list[str] | None,\n217         arg_help: str,\n218         metavar: str,\n219         hide_help: bool,\n220         section: str | None,\n221     ) -> None:\n222         super().__init__(\n223             flags=flags,\n224             action=action,\n225             default=default,\n226             arg_help=arg_help,\n227             hide_help=hide_help,\n228             section=section,\n229         )\n230 \n231         self.type = _TYPE_TRANSFORMERS[arg_type]\n232         \"\"\"A transformer function that returns a transformed type of the argument.\"\"\"\n233 \n234         self.choices = choices\n235         \"\"\"A list of possible choices for the argument.\n236 \n237         None if there are no restrictions.\n238         \"\"\"\n239 \n240         self.metavar = metavar\n241         \"\"\"The metavar of the argument.\n242 \n243         See:\n244         https://docs.python.org/3/library/argparse.html#metavar\n245         \"\"\"\n246 \n247 \n248 class _StoreTrueArgument(_BaseStoreArgument):\n249     \"\"\"Class representing a 'store_true' argument to be parsed by an argparse.ArgumentsParser.\n250 \n251     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n252     See:\n253     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n254     \"\"\"\n255 \n256     # pylint: disable-next=useless-super-delegation # We narrow down the type of action\n257     def __init__(\n258         self,\n259         *,\n260         flags: list[str],\n261         action: Literal[\"store_true\"],\n262         default: _ArgumentTypes,\n263         arg_help: str,\n264         hide_help: bool,\n265         section: str | None,\n266     ) -> None:\n267         super().__init__(\n268             flags=flags,\n269             action=action,\n270             default=default,\n271             arg_help=arg_help,\n272             hide_help=hide_help,\n273             section=section,\n274         )\n275 \n276 \n277 class _DeprecationArgument(_Argument):\n278     \"\"\"Store arguments while also handling deprecation warnings for old and new names.\n279 \n280     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n281     See:\n282     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n283     \"\"\"\n284 \n285     def __init__(\n286         self,\n287         *,\n288         flags: list[str],\n289         action: type[argparse.Action],\n290         default: _ArgumentTypes,\n291         arg_type: str,\n292         choices: list[str] | None,\n293         arg_help: str,\n294         metavar: str,\n295         hide_help: bool,\n296         section: str | None,\n297     ) -> None:\n298         super().__init__(\n299             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n300         )\n301 \n302         self.action = action\n303         \"\"\"The action to perform with the argument.\"\"\"\n304 \n305         self.default = default\n306         \"\"\"The default value of the argument.\"\"\"\n307 \n308         self.type = _TYPE_TRANSFORMERS[arg_type]\n309         \"\"\"A transformer function that returns a transformed type of the argument.\"\"\"\n310 \n311         self.choices = choices\n312         \"\"\"A list of possible choices for the argument.\n313 \n314         None if there are no restrictions.\n315         \"\"\"\n316 \n317         self.metavar = metavar\n318         \"\"\"The metavar of the argument.\n319 \n320         See:\n321         https://docs.python.org/3/library/argparse.html#metavar\n322         \"\"\"\n323 \n324 \n325 class _ExtendArgument(_DeprecationArgument):\n326     \"\"\"Class for extend arguments to be parsed by an argparse.ArgumentsParser.\n327 \n328     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n329     See:\n330     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n331     \"\"\"\n332 \n333     def __init__(\n334         self,\n335         *,\n336         flags: list[str],\n337         action: Literal[\"extend\"],\n338         default: _ArgumentTypes,\n339         arg_type: str,\n340         metavar: str,\n341         arg_help: str,\n342         hide_help: bool,\n343         section: str | None,\n344         choices: list[str] | None,\n345         dest: str | None,\n346     ) -> None:\n347         # The extend action is included in the stdlib from 3.8+\n348         if PY38_PLUS:\n349             action_class = argparse._ExtendAction  # type: ignore[attr-defined]\n350         else:\n351             action_class = _ExtendAction\n352 \n353         self.dest = dest\n354         \"\"\"The destination of the argument.\"\"\"\n355 \n356         super().__init__(\n357             flags=flags,\n358             action=action_class,\n359             default=default,\n360             arg_type=arg_type,\n361             choices=choices,\n362             arg_help=arg_help,\n363             metavar=metavar,\n364             hide_help=hide_help,\n365             section=section,\n366         )\n367 \n368 \n369 class _StoreOldNamesArgument(_DeprecationArgument):\n370     \"\"\"Store arguments while also handling old names.\n371 \n372     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n373     See:\n374     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n375     \"\"\"\n376 \n377     def __init__(\n378         self,\n379         *,\n380         flags: list[str],\n381         default: _ArgumentTypes,\n382         arg_type: str,\n383         choices: list[str] | None,\n384         arg_help: str,\n385         metavar: str,\n386         hide_help: bool,\n387         kwargs: dict[str, Any],\n388         section: str | None,\n389     ) -> None:\n390         super().__init__(\n391             flags=flags,\n392             action=_OldNamesAction,\n393             default=default,\n394             arg_type=arg_type,\n395             choices=choices,\n396             arg_help=arg_help,\n397             metavar=metavar,\n398             hide_help=hide_help,\n399             section=section,\n400         )\n401 \n402         self.kwargs = kwargs\n403         \"\"\"Any additional arguments passed to the action.\"\"\"\n404 \n405 \n406 class _StoreNewNamesArgument(_DeprecationArgument):\n407     \"\"\"Store arguments while also emitting deprecation warnings.\n408 \n409     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n410     See:\n411     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n412     \"\"\"\n413 \n414     def __init__(\n415         self,\n416         *,\n417         flags: list[str],\n418         default: _ArgumentTypes,\n419         arg_type: str,\n420         choices: list[str] | None,\n421         arg_help: str,\n422         metavar: str,\n423         hide_help: bool,\n424         kwargs: dict[str, Any],\n425         section: str | None,\n426     ) -> None:\n427         super().__init__(\n428             flags=flags,\n429             action=_NewNamesAction,\n430             default=default,\n431             arg_type=arg_type,\n432             choices=choices,\n433             arg_help=arg_help,\n434             metavar=metavar,\n435             hide_help=hide_help,\n436             section=section,\n437         )\n438 \n439         self.kwargs = kwargs\n440         \"\"\"Any additional arguments passed to the action.\"\"\"\n441 \n442 \n443 class _CallableArgument(_Argument):\n444     \"\"\"Class representing an callable argument to be parsed by an argparse.ArgumentsParser.\n445 \n446     This is based on the parameters passed to argparse.ArgumentsParser.add_message.\n447     See:\n448     https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument\n449     \"\"\"\n450 \n451     def __init__(\n452         self,\n453         *,\n454         flags: list[str],\n455         action: type[_CallbackAction],\n456         arg_help: str,\n457         kwargs: dict[str, Any],\n458         hide_help: bool,\n459         section: str | None,\n460     ) -> None:\n461         super().__init__(\n462             flags=flags, arg_help=arg_help, hide_help=hide_help, section=section\n463         )\n464 \n465         self.action = action\n466         \"\"\"The action to perform with the argument.\"\"\"\n467 \n468         self.kwargs = kwargs\n469         \"\"\"Any additional arguments passed to the action.\"\"\"\n",
        "intended_behavior": "Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value."
    },
    {
        "rel_file_path": "pylint/config/arguments_manager.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/arguments_manager.py",
        "start": 1,
        "end": 753,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n6 \n7 from __future__ import annotations\n8 \n9 import argparse\n10 import configparser\n11 import copy\n12 import optparse  # pylint: disable=deprecated-module\n13 import os\n14 import re\n15 import sys\n16 import textwrap\n17 import warnings\n18 from collections import OrderedDict\n19 from collections.abc import Sequence\n20 from pathlib import Path\n21 from typing import TYPE_CHECKING, Any, TextIO, Union\n22 \n23 import tomlkit\n24 \n25 from pylint import utils\n26 from pylint.config.argument import (\n27     _Argument,\n28     _CallableArgument,\n29     _ExtendArgument,\n30     _StoreArgument,\n31     _StoreNewNamesArgument,\n32     _StoreOldNamesArgument,\n33     _StoreTrueArgument,\n34 )\n35 from pylint.config.exceptions import (\n36     UnrecognizedArgumentAction,\n37     _UnrecognizedOptionError,\n38 )\n39 from pylint.config.help_formatter import _HelpFormatter\n40 from pylint.config.option import Option\n41 from pylint.config.option_parser import OptionParser\n42 from pylint.config.options_provider_mixin import OptionsProviderMixIn\n43 from pylint.config.utils import _convert_option_to_argument, _parse_rich_type_value\n44 from pylint.constants import MAIN_CHECKER_NAME\n45 from pylint.typing import OptionDict\n46 \n47 if sys.version_info >= (3, 11):\n48     import tomllib\n49 else:\n50     import tomli as tomllib\n51 \n52 \n53 if TYPE_CHECKING:\n54     from pylint.config.arguments_provider import _ArgumentsProvider\n55 \n56 ConfigProvider = Union[\"_ArgumentsProvider\", OptionsProviderMixIn]\n57 \n58 \n59 # pylint: disable-next=too-many-instance-attributes\n60 class _ArgumentsManager:\n61     \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n62 \n63     def __init__(\n64         self, prog: str, usage: str | None = None, description: str | None = None\n65     ) -> None:\n66         self._config = argparse.Namespace()\n67         \"\"\"Namespace for all options.\"\"\"\n68 \n69         self._arg_parser = argparse.ArgumentParser(\n70             prog=prog,\n71             usage=usage or \"%(prog)s [options]\",\n72             description=description,\n73             formatter_class=_HelpFormatter,\n74         )\n75         \"\"\"The command line argument parser.\"\"\"\n76 \n77         self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n78         \"\"\"Dictionary of all the argument groups.\"\"\"\n79 \n80         self._option_dicts: dict[str, OptionDict] = {}\n81         \"\"\"All option dictionaries that have been registered.\"\"\"\n82 \n83         # pylint: disable=fixme\n84         # TODO: 3.0: Remove deprecated attributes introduced to keep API\n85         # parity with optparse. Until '_maxlevel'\n86         with warnings.catch_warnings():\n87             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n88             self.reset_parsers(usage or \"\")\n89         # list of registered options providers\n90         self._options_providers: list[ConfigProvider] = []\n91         # dictionary associating option name to checker\n92         self._all_options: OrderedDict[str, ConfigProvider] = OrderedDict()\n93         self._short_options: dict[str, str] = {}\n94         self._nocallback_options: dict[ConfigProvider, str] = {}\n95         self._mygroups: dict[str, optparse.OptionGroup] = {}\n96         # verbosity\n97         self._maxlevel: int = 0\n98 \n99     @property\n100     def config(self) -> argparse.Namespace:\n101         \"\"\"Namespace for all options.\"\"\"\n102         return self._config\n103 \n104     @config.setter\n105     def config(self, value: argparse.Namespace) -> None:\n106         self._config = value\n107 \n108     @property\n109     def options_providers(self) -> list[ConfigProvider]:\n110         # TODO: 3.0: Remove deprecated attribute. # pylint: disable=fixme\n111         warnings.warn(\n112             \"options_providers has been deprecated. It will be removed in pylint 3.0.\",\n113             DeprecationWarning,\n114         )\n115         return self._options_providers\n116 \n117     @options_providers.setter\n118     def options_providers(self, value: list[ConfigProvider]) -> None:\n119         warnings.warn(\n120             \"Setting options_providers has been deprecated. It will be removed in pylint 3.0.\",\n121             DeprecationWarning,\n122         )\n123         self._options_providers = value\n124 \n125     def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n126         \"\"\"Register an options provider and load its defaults.\"\"\"\n127         for opt, optdict in provider.options:\n128             self._option_dicts[opt] = optdict\n129             argument = _convert_option_to_argument(opt, optdict)\n130             section = argument.section or provider.name.capitalize()\n131 \n132             section_desc = provider.option_groups_descs.get(section, None)\n133 \n134             # We exclude master since its docstring comes from PyLinter\n135             if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n136                 section_desc = provider.__doc__.split(\"\\n\\n\")[0]\n137 \n138             self._add_arguments_to_parser(section, section_desc, argument)\n139 \n140         self._load_default_argument_values()\n141 \n142     def _add_arguments_to_parser(\n143         self, section: str, section_desc: str | None, argument: _Argument\n144     ) -> None:\n145         \"\"\"Add an argument to the correct argument section/group.\"\"\"\n146         try:\n147             section_group = self._argument_groups_dict[section]\n148         except KeyError:\n149             if section_desc:\n150                 section_group = self._arg_parser.add_argument_group(\n151                     section, section_desc\n152                 )\n153             else:\n154                 section_group = self._arg_parser.add_argument_group(title=section)\n155             self._argument_groups_dict[section] = section_group\n156         self._add_parser_option(section_group, argument)\n157 \n158     @staticmethod\n159     def _add_parser_option(\n160         section_group: argparse._ArgumentGroup, argument: _Argument\n161     ) -> None:\n162         \"\"\"Add an argument.\"\"\"\n163         if isinstance(argument, _StoreArgument):\n164             section_group.add_argument(\n165                 *argument.flags,\n166                 action=argument.action,\n167                 default=argument.default,\n168                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n169                 help=argument.help,\n170                 metavar=argument.metavar,\n171                 choices=argument.choices,\n172             )\n173         elif isinstance(argument, _StoreOldNamesArgument):\n174             section_group.add_argument(\n175                 *argument.flags,\n176                 **argument.kwargs,\n177                 action=argument.action,\n178                 default=argument.default,\n179                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n180                 help=argument.help,\n181                 metavar=argument.metavar,\n182                 choices=argument.choices,\n183             )\n184             # We add the old name as hidden option to make it's default value gets loaded when\n185             # argparse initializes all options from the checker\n186             assert argument.kwargs[\"old_names\"]\n187             for old_name in argument.kwargs[\"old_names\"]:\n188                 section_group.add_argument(\n189                     f\"--{old_name}\",\n190                     action=\"store\",\n191                     default=argument.default,\n192                     type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n193                     help=argparse.SUPPRESS,\n194                     metavar=argument.metavar,\n195                     choices=argument.choices,\n196                 )\n197         elif isinstance(argument, _StoreNewNamesArgument):\n198             section_group.add_argument(\n199                 *argument.flags,\n200                 **argument.kwargs,\n201                 action=argument.action,\n202                 default=argument.default,\n203                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n204                 help=argument.help,\n205                 metavar=argument.metavar,\n206                 choices=argument.choices,\n207             )\n208         elif isinstance(argument, _StoreTrueArgument):\n209             section_group.add_argument(\n210                 *argument.flags,\n211                 action=argument.action,\n212                 default=argument.default,\n213                 help=argument.help,\n214             )\n215         elif isinstance(argument, _CallableArgument):\n216             section_group.add_argument(\n217                 *argument.flags,\n218                 **argument.kwargs,\n219                 action=argument.action,\n220                 help=argument.help,\n221             )\n222         elif isinstance(argument, _ExtendArgument):\n223             section_group.add_argument(\n224                 *argument.flags,\n225                 action=argument.action,\n226                 default=argument.default,\n227                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n228                 help=argument.help,\n229                 metavar=argument.metavar,\n230                 choices=argument.choices,\n231                 dest=argument.dest,\n232             )\n233         else:\n234             raise UnrecognizedArgumentAction\n235 \n236     def _load_default_argument_values(self) -> None:\n237         \"\"\"Loads the default values of all registered options.\"\"\"\n238         self.config = self._arg_parser.parse_args([], self.config)\n239 \n240     def _parse_configuration_file(self, arguments: list[str]) -> None:\n241         \"\"\"Parse the arguments found in a configuration file into the namespace.\"\"\"\n242         self.config, parsed_args = self._arg_parser.parse_known_args(\n243             arguments, self.config\n244         )\n245         unrecognized_options: list[str] = []\n246         for opt in parsed_args:\n247             if opt.startswith(\"--\"):\n248                 unrecognized_options.append(opt[2:])\n249         if unrecognized_options:\n250             raise _UnrecognizedOptionError(options=unrecognized_options)\n251 \n252     def _parse_command_line_configuration(\n253         self, arguments: Sequence[str] | None = None\n254     ) -> list[str]:\n255         \"\"\"Parse the arguments found on the command line into the namespace.\"\"\"\n256         arguments = sys.argv[1:] if arguments is None else arguments\n257 \n258         self.config, parsed_args = self._arg_parser.parse_known_args(\n259             arguments, self.config\n260         )\n261 \n262         return parsed_args\n263 \n264     def reset_parsers(self, usage: str = \"\") -> None:  # pragma: no cover\n265         \"\"\"DEPRECATED.\"\"\"\n266         warnings.warn(\n267             \"reset_parsers has been deprecated. Parsers should be instantiated \"\n268             \"once during initialization and do not need to be reset.\",\n269             DeprecationWarning,\n270         )\n271         # configuration file parser\n272         self.cfgfile_parser = configparser.ConfigParser(\n273             inline_comment_prefixes=(\"#\", \";\")\n274         )\n275         # command line parser\n276         self.cmdline_parser = OptionParser(Option, usage=usage)\n277         self.cmdline_parser.options_manager = self  # type: ignore[attr-defined]\n278         self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)\n279 \n280     def register_options_provider(\n281         self, provider: ConfigProvider, own_group: bool = True\n282     ) -> None:  # pragma: no cover\n283         \"\"\"DEPRECATED: Register an options provider.\"\"\"\n284         warnings.warn(\n285             \"register_options_provider has been deprecated. Options providers and \"\n286             \"arguments providers should be registered by initializing ArgumentsProvider. \"\n287             \"This automatically registers the provider on the ArgumentsManager.\",\n288             DeprecationWarning,\n289         )\n290         self.options_providers.append(provider)\n291         non_group_spec_options = [\n292             option for option in provider.options if \"group\" not in option[1]\n293         ]\n294         groups = getattr(provider, \"option_groups\", ())\n295         if own_group and non_group_spec_options:\n296             with warnings.catch_warnings():\n297                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n298                 self.add_option_group(\n299                     provider.name.upper(),\n300                     provider.__doc__,\n301                     non_group_spec_options,\n302                     provider,\n303                 )\n304         else:\n305             for opt, optdict in non_group_spec_options:\n306                 with warnings.catch_warnings():\n307                     warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n308                     self.add_optik_option(provider, self.cmdline_parser, opt, optdict)\n309         for gname, gdoc in groups:\n310             gname = gname.upper()\n311             goptions = [\n312                 option\n313                 for option in provider.options\n314                 if option[1].get(\"group\", \"\").upper() == gname  # type: ignore[union-attr]\n315             ]\n316             with warnings.catch_warnings():\n317                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n318                 self.add_option_group(gname, gdoc, goptions, provider)\n319 \n320     def add_option_group(\n321         self,\n322         group_name: str,\n323         _: str | None,\n324         options: list[tuple[str, OptionDict]],\n325         provider: ConfigProvider,\n326     ) -> None:  # pragma: no cover\n327         \"\"\"DEPRECATED.\"\"\"\n328         warnings.warn(\n329             \"add_option_group has been deprecated. Option groups should be \"\n330             \"registered by initializing ArgumentsProvider. \"\n331             \"This automatically registers the group on the ArgumentsManager.\",\n332             DeprecationWarning,\n333         )\n334         # add option group to the command line parser\n335         if group_name in self._mygroups:\n336             group = self._mygroups[group_name]\n337         else:\n338             group = optparse.OptionGroup(\n339                 self.cmdline_parser, title=group_name.capitalize()\n340             )\n341             self.cmdline_parser.add_option_group(group)\n342             self._mygroups[group_name] = group\n343             # add section to the config file\n344             if (\n345                 group_name != \"DEFAULT\"\n346                 and group_name not in self.cfgfile_parser._sections  # type: ignore[attr-defined]\n347             ):\n348                 self.cfgfile_parser.add_section(group_name)\n349         # add provider's specific options\n350         for opt, optdict in options:\n351             if not isinstance(optdict.get(\"action\", \"store\"), str):\n352                 optdict[\"action\"] = \"callback\"\n353             with warnings.catch_warnings():\n354                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n355                 self.add_optik_option(provider, group, opt, optdict)\n356 \n357     def add_optik_option(\n358         self,\n359         provider: ConfigProvider,\n360         optikcontainer: optparse.OptionParser | optparse.OptionGroup,\n361         opt: str,\n362         optdict: OptionDict,\n363     ) -> None:  # pragma: no cover\n364         \"\"\"DEPRECATED.\"\"\"\n365         warnings.warn(\n366             \"add_optik_option has been deprecated. Options should be automatically \"\n367             \"added by initializing an ArgumentsProvider.\",\n368             DeprecationWarning,\n369         )\n370         with warnings.catch_warnings():\n371             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n372             args, optdict = self.optik_option(provider, opt, optdict)\n373         option = optikcontainer.add_option(*args, **optdict)\n374         self._all_options[opt] = provider\n375         self._maxlevel = max(self._maxlevel, option.level or 0)\n376 \n377     def optik_option(\n378         self, provider: ConfigProvider, opt: str, optdict: OptionDict\n379     ) -> tuple[list[str], OptionDict]:  # pragma: no cover\n380         \"\"\"DEPRECATED: Get our personal option definition and return a suitable form for\n381         use with optik/optparse\n382         \"\"\"\n383         warnings.warn(\n384             \"optik_option has been deprecated. Parsing of option dictionaries should be done \"\n385             \"automatically by initializing an ArgumentsProvider.\",\n386             DeprecationWarning,\n387         )\n388         optdict = copy.copy(optdict)\n389         if \"action\" in optdict:\n390             self._nocallback_options[provider] = opt\n391         else:\n392             optdict[\"action\"] = \"callback\"\n393             optdict[\"callback\"] = self.cb_set_provider_option\n394         # default is handled here and *must not* be given to optik if you\n395         # want the whole machinery to work\n396         if \"default\" in optdict:\n397             if (\n398                 \"help\" in optdict\n399                 and optdict.get(\"default\") is not None\n400                 and optdict[\"action\"] not in (\"store_true\", \"store_false\")\n401             ):\n402                 optdict[\"help\"] += \" [current: %default]\"  # type: ignore[operator]\n403             del optdict[\"default\"]\n404         args = [\"--\" + str(opt)]\n405         if \"short\" in optdict:\n406             self._short_options[optdict[\"short\"]] = opt  # type: ignore[index]\n407             args.append(\"-\" + optdict[\"short\"])  # type: ignore[operator]\n408             del optdict[\"short\"]\n409         # cleanup option definition dict before giving it to optik\n410         for key in list(optdict.keys()):\n411             if key not in self._optik_option_attrs:\n412                 optdict.pop(key)\n413         return args, optdict\n414 \n415     def generate_config(\n416         self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()\n417     ) -> None:  # pragma: no cover\n418         \"\"\"DEPRECATED: Write a configuration file according to the current configuration\n419         into the given stream or stdout\n420         \"\"\"\n421         warnings.warn(\n422             \"generate_config has been deprecated. It will be removed in pylint 3.0.\",\n423             DeprecationWarning,\n424         )\n425         options_by_section = {}\n426         sections = []\n427         for group in self._arg_parser._action_groups:\n428             group_name = group.title\n429             assert group_name\n430             if group_name in skipsections:\n431                 continue\n432 \n433             options = []\n434             for opt in group._group_actions:\n435                 if \"--help\" in opt.option_strings:\n436                     continue\n437 \n438                 optname = opt.option_strings[0][2:]\n439 \n440                 try:\n441                     optdict = self._option_dicts[optname]\n442                 except KeyError:\n443                     continue\n444 \n445                 options.append(\n446                     (\n447                         optname,\n448                         optdict,\n449                         getattr(self.config, optname.replace(\"-\", \"_\")),\n450                     )\n451                 )\n452 \n453                 options = [\n454                     (n, d, v) for (n, d, v) in options if not d.get(\"deprecated\")\n455                 ]\n456 \n457             if options:\n458                 sections.append(group_name)\n459                 options_by_section[group_name] = options\n460         stream = stream or sys.stdout\n461         printed = False\n462         for section in sections:\n463             if printed:\n464                 print(\"\\n\", file=stream)\n465             with warnings.catch_warnings():\n466                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n467                 utils.format_section(\n468                     stream, section.upper(), sorted(options_by_section[section])\n469                 )\n470             printed = True\n471 \n472     def load_provider_defaults(self) -> None:  # pragma: no cover\n473         \"\"\"DEPRECATED: Initialize configuration using default values.\"\"\"\n474         warnings.warn(\n475             \"load_provider_defaults has been deprecated. Parsing of option defaults should be done \"\n476             \"automatically by initializing an ArgumentsProvider.\",\n477             DeprecationWarning,\n478         )\n479         for provider in self.options_providers:\n480             with warnings.catch_warnings():\n481                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n482                 provider.load_defaults()\n483 \n484     def read_config_file(\n485         self, config_file: Path | None = None, verbose: bool = False\n486     ) -> None:  # pragma: no cover\n487         \"\"\"DEPRECATED: Read the configuration file but do not load it (i.e. dispatching\n488         values to each option's provider)\n489 \n490         :raises OSError: Whem the specified config file doesn't exist\n491         \"\"\"\n492         warnings.warn(\n493             \"read_config_file has been deprecated. It will be removed in pylint 3.0.\",\n494             DeprecationWarning,\n495         )\n496         if not config_file:\n497             if verbose:\n498                 print(\n499                     \"No config file found, using default configuration\", file=sys.stderr\n500                 )\n501             return\n502         config_file = Path(os.path.expandvars(config_file)).expanduser()\n503         if not config_file.exists():\n504             raise OSError(f\"The config file {str(config_file)} doesn't exist!\")\n505         parser = self.cfgfile_parser\n506         if config_file.suffix == \".toml\":\n507             try:\n508                 self._parse_toml(config_file, parser)\n509             except tomllib.TOMLDecodeError:\n510                 pass\n511         else:\n512             # Use this encoding in order to strip the BOM marker, if any.\n513             with open(config_file, encoding=\"utf_8_sig\") as fp:\n514                 parser.read_file(fp)\n515             # normalize each section's title\n516             for sect, values in list(parser._sections.items()):  # type: ignore[attr-defined]\n517                 if sect.startswith(\"pylint.\"):\n518                     sect = sect[len(\"pylint.\") :]\n519                 if not sect.isupper() and values:\n520                     parser._sections[sect.upper()] = values  # type: ignore[attr-defined]\n521 \n522         if verbose:\n523             print(f\"Using config file '{config_file}'\", file=sys.stderr)\n524 \n525     @staticmethod\n526     def _parse_toml(\n527         config_file: Path, parser: configparser.ConfigParser\n528     ) -> None:  # pragma: no cover\n529         \"\"\"DEPRECATED: Parse and handle errors of a toml configuration file.\n530 \n531         TODO: 3.0: Remove depreacted method.\n532         \"\"\"\n533         with open(config_file, mode=\"rb\") as fp:\n534             content = tomllib.load(fp)\n535         try:\n536             sections_values = content[\"tool\"][\"pylint\"]\n537         except KeyError:\n538             return\n539         for section, values in sections_values.items():\n540             section_name = section.upper()\n541             # TOML has rich types, convert values to\n542             # strings as ConfigParser expects.\n543             if not isinstance(values, dict):\n544                 continue\n545             for option, value in values.items():\n546                 if isinstance(value, bool):\n547                     values[option] = \"yes\" if value else \"no\"\n548                 elif isinstance(value, list):\n549                     values[option] = \",\".join(value)\n550                 else:\n551                     values[option] = str(value)\n552             for option, value in values.items():\n553                 try:\n554                     parser.set(section_name, option, value=value)\n555                 except configparser.NoSectionError:\n556                     parser.add_section(section_name)\n557                     parser.set(section_name, option, value=value)\n558 \n559     def load_config_file(self) -> None:  # pragma: no cover\n560         \"\"\"DEPRECATED: Dispatch values previously read from a configuration file to each\n561         option's provider\n562         \"\"\"\n563         warnings.warn(\n564             \"load_config_file has been deprecated. It will be removed in pylint 3.0.\",\n565             DeprecationWarning,\n566         )\n567         parser = self.cfgfile_parser\n568         for section in parser.sections():\n569             for option, value in parser.items(section):\n570                 try:\n571                     self.global_set_option(option, value)\n572                 except (KeyError, optparse.OptionError):\n573                     continue\n574 \n575     def load_configuration(self, **kwargs: Any) -> None:  # pragma: no cover\n576         \"\"\"DEPRECATED: Override configuration according to given parameters.\"\"\"\n577         warnings.warn(\n578             \"load_configuration has been deprecated. It will be removed in pylint 3.0.\",\n579             DeprecationWarning,\n580         )\n581         with warnings.catch_warnings():\n582             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n583             return self.load_configuration_from_config(kwargs)\n584 \n585     def load_configuration_from_config(\n586         self, config: dict[str, Any]\n587     ) -> None:  # pragma: no cover\n588         warnings.warn(\n589             \"DEPRECATED: load_configuration_from_config has been deprecated. It will be removed in pylint 3.0.\",\n590             DeprecationWarning,\n591         )\n592         for opt, opt_value in config.items():\n593             opt = opt.replace(\"_\", \"-\")\n594             provider = self._all_options[opt]\n595             provider.set_option(opt, opt_value)\n596 \n597     def load_command_line_configuration(\n598         self, args: list[str] | None = None\n599     ) -> list[str]:  # pragma: no cover\n600         \"\"\"DEPRECATED: Override configuration according to command line parameters.\n601 \n602         return additional arguments\n603         \"\"\"\n604         warnings.warn(\n605             \"load_command_line_configuration has been deprecated. It will be removed in pylint 3.0.\",\n606             DeprecationWarning,\n607         )\n608         args = sys.argv[1:] if args is None else list(args)\n609         (options, args) = self.cmdline_parser.parse_args(args=args)\n610         for provider in self._nocallback_options:\n611             config = provider.config\n612             for attr in config.__dict__.keys():\n613                 value = getattr(options, attr, None)\n614                 if value is None:\n615                     continue\n616                 setattr(config, attr, value)\n617         return args\n618 \n619     def help(self, level: int | None = None) -> str:\n620         \"\"\"Return the usage string based on the available options.\"\"\"\n621         if level is not None:\n622             warnings.warn(\n623                 \"Supplying a 'level' argument to help() has been deprecated.\"\n624                 \"You can call help() without any arguments.\",\n625                 DeprecationWarning,\n626             )\n627         return self._arg_parser.format_help()\n628 \n629     def cb_set_provider_option(self, option, opt, value, parser):  # pragma: no cover\n630         \"\"\"DEPRECATED: Optik callback for option setting.\"\"\"\n631         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme\n632         warnings.warn(\n633             \"cb_set_provider_option has been deprecated. It will be removed in pylint 3.0.\",\n634             DeprecationWarning,\n635         )\n636         if opt.startswith(\"--\"):\n637             # remove -- on long option\n638             opt = opt[2:]\n639         else:\n640             # short option, get its long equivalent\n641             opt = self._short_options[opt[1:]]\n642         # trick since we can't set action='store_true' on options\n643         if value is None:\n644             value = 1\n645         self.set_option(opt, value)\n646 \n647     def global_set_option(self, opt: str, value: Any) -> None:  # pragma: no cover\n648         \"\"\"DEPRECATED: Set option on the correct option provider.\"\"\"\n649         # TODO: 3.0: Remove deprecated method. # pylint: disable=fixme\n650         warnings.warn(\n651             \"global_set_option has been deprecated. You can use _arguments_manager.set_option \"\n652             \"or linter.set_option to set options on the global configuration object.\",\n653             DeprecationWarning,\n654         )\n655         self.set_option(opt, value)\n656 \n657     def _generate_config_file(self) -> None:\n658         \"\"\"Write a configuration file according to the current configuration into stdout.\"\"\"\n659         toml_doc = tomlkit.document()\n660         pylint_tool_table = tomlkit.table(is_super_table=True)\n661         toml_doc.add(tomlkit.key([\"tool\", \"pylint\"]), pylint_tool_table)\n662 \n663         for group in sorted(\n664             self._arg_parser._action_groups,\n665             key=lambda x: (x.title != \"Master\", x.title),\n666         ):\n667             # Skip the options section with the --help option\n668             if group.title == \"options\":\n669                 continue\n670 \n671             # Skip sections without options such as \"positional arguments\"\n672             if not group._group_actions:\n673                 continue\n674 \n675             group_table = tomlkit.table()\n676             for action in sorted(\n677                 group._group_actions, key=lambda x: x.option_strings[0][2:]\n678             ):\n679                 optname = action.option_strings[0][2:]\n680 \n681                 # We skip old name options that don't have their own optdict\n682                 try:\n683                     optdict = self._option_dicts[optname]\n684                 except KeyError:\n685                     continue\n686 \n687                 if optdict.get(\"hide_from_config_file\"):\n688                     continue\n689 \n690                 # Add help comment\n691                 help_msg = optdict.get(\"help\", \"\")\n692                 assert isinstance(help_msg, str)\n693                 help_text = textwrap.wrap(help_msg, width=79)\n694                 for line in help_text:\n695                     group_table.add(tomlkit.comment(line))\n696 \n697                 # Get current value of option\n698                 value = getattr(self.config, optname.replace(\"-\", \"_\"))\n699 \n700                 # Create a comment if the option has no value\n701                 if not value:\n702                     group_table.add(tomlkit.comment(f\"{optname} =\"))\n703                     group_table.add(tomlkit.nl())\n704                     continue\n705 \n706                 # Tomlkit doesn't support regular expressions\n707                 if isinstance(value, re.Pattern):\n708                     value = value.pattern\n709                 elif isinstance(value, (list, tuple)) and isinstance(\n710                     value[0], re.Pattern\n711                 ):\n712                     value = [i.pattern for i in value]\n713 \n714                 # Add to table\n715                 group_table.add(optname, value)\n716                 group_table.add(tomlkit.nl())\n717 \n718             assert group.title\n719             pylint_tool_table.add(group.title.lower(), group_table)\n720 \n721         toml_string = tomlkit.dumps(toml_doc)\n722 \n723         # Make sure the string we produce is valid toml and can be parsed\n724         tomllib.loads(toml_string)\n725 \n726         print(toml_string)\n727 \n728     def set_option(\n729         self,\n730         optname: str,\n731         value: Any,\n732         action: str | None = \"default_value\",\n733         optdict: None | str | OptionDict = \"default_value\",\n734     ) -> None:\n735         \"\"\"Set an option on the namespace object.\"\"\"\n736         # TODO: 3.0: Remove deprecated arguments. # pylint: disable=fixme\n737         if action != \"default_value\":\n738             warnings.warn(\n739                 \"The 'action' argument has been deprecated. You can use set_option \"\n740                 \"without the 'action' or 'optdict' arguments.\",\n741                 DeprecationWarning,\n742             )\n743         if optdict != \"default_value\":\n744             warnings.warn(\n745                 \"The 'optdict' argument has been deprecated. You can use set_option \"\n746                 \"without the 'action' or 'optdict' arguments.\",\n747                 DeprecationWarning,\n748             )\n749 \n750         self.config = self._arg_parser.parse_known_args(\n751             [f\"--{optname.replace('_', '-')}\", _parse_rich_type_value(value)],\n752             self.config,\n753         )[0]\n",
        "intended_behavior": "Ensure the `-v` option does not expect an additional argument and clarify the help message associated with the `-v`/`--verbose` option to accurately describe its behavior as a toggle or flag, not requiring an input value."
    }
]