2025-10-17 14:32:33.291 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:32:36.621 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1120, output_tokens=12, cost=0.011560
2025-10-17 14:32:52.130 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1300, output_tokens=531, cost=0.028930
2025-10-17 14:32:54.716 | INFO     | registered non reproducing test 0
2025-10-17 14:33:09.934 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2104, output_tokens=609, cost=0.039310
2025-10-17 14:33:11.341 | INFO     | registered non reproducing test 1
2025-10-17 14:33:27.217 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2186, output_tokens=685, cost=0.042410
2025-10-17 14:33:28.586 | INFO     | registered non reproducing test 2
2025-10-17 14:33:28.586 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 14:33:28.589 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:33:37.123 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1399, output_tokens=371, cost=0.025120
2025-10-17 14:33:37.131 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:33:40.277 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=725, output_tokens=65, cost=0.009200
2025-10-17 14:33:40.278 | DEBUG    | Extracted a valid json.
2025-10-17 14:33:40.279 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogNorm\")",
        "search_method_in_class(\"update_scalarmappable\", \"Collection\")",
        "search_method_in_class(\"__call__\", \"Norm\")",
        "search_method(\"autoscale\")"
    ],
    "bug_locations": []
}
2025-10-17 14:33:40.306 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:33:40.307 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:34:01.718 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2836, output_tokens=870, cost=0.054460
2025-10-17 14:34:01.733 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:34:12.495 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3922, output_tokens=404, cost=0.051340
2025-10-17 14:34:12.504 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:34:20.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=758, output_tokens=334, cost=0.017600
2025-10-17 14:34:20.616 | DEBUG    | Extracted a valid json.
2025-10-17 14:34:20.616 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogNorm\")",
        "search_method_in_file(\"autoscale\", \"lib/matplotlib/axes/_base.py\")",
        "search_code(\"LogNorm\")"
    ],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colors.py",
            "class": "Norm",
            "method": "__call__",
            "intended_behavior": "The normalization process, particularly when applying a `LogNorm`, should validate `vmin` and `vmax` to ensure they are suitable for logarithmic normalization. The process should account for the characteristics of logarithmic scales, such as not allowing `vmin` to be <= 0. The validation and transformation process of data values should be ensured to handle the logarithmic scale correctly without throwing `Invalid vmin or vmax` errors for valid log scale ranges."
        },
        {
            "file": "lib/matplotlib/collections.py",
            "class": "Collection",
            "method": "update_scalarmappable",
            "intended_behavior": "When the norm is changed (for example, to `LogNorm`), the `update_scalarmappable` should incorporate the new normalization correctly when updating the color mapping of the collection, ensuring that it recalculates colors based on the new normalization without error. This might involve better handling of norm changes to ensure that data array (`_A`) mapping to colors is recalculated accurately according to the new norm's `vmin` and `vmax` and that any assumptions about linear scaling are re-evaluated for non-linear norms."
        }
    ]
}
2025-10-17 14:34:20.730 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:34:20.730 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:34:36.653 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5876, output_tokens=620, cost=0.077360
2025-10-17 14:34:36.661 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:34:48.770 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6712, output_tokens=467, cost=0.081130
2025-10-17 14:34:48.777 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:34:54.092 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=821, output_tokens=215, cost=0.014660
2025-10-17 14:34:54.093 | DEBUG    | Extracted a valid json.
2025-10-17 14:34:54.093 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colors.py",
            "class": "Norm/LogNorm",
            "method": "__call__",
            "intended_behavior": "Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling."
        },
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "_AxesBase",
            "method": "autoscale",
            "intended_behavior": "After a norm change to LogNorm, the autoscale method should correctly assess and update the plot's view limits in accordance with the logarithmic scale. This might involve ensuring that data limits are recalculated or interpreted correctly under the new norm, potentially requiring an additional check or recalibration step."
        }
    ]
}
2025-10-17 14:34:54.162 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
2040     def __call__(self, value, clip=None):
2041         return value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Colormap</class>
<method>__call__</method>
<code>
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Normalize</class>
<method>__call__</method>
<code>
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>TwoSlopeNorm</class>
<method>__call__</method>
<code>
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>PowerNorm</class>
<method>__call__</method>
<code>
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>BoundaryNorm</class>
<method>__call__</method>
<code>
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>NoNorm</class>
<method>__call__</method>
<code>
2040     def __call__(self, value, clip=None):
2041         return value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Norm</class>
<method>__call__</method>
<code>
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>autoscale</method>
<code>
2766     def autoscale(self, enable=True, axis='both', tight=None):
2767         """
2768         Autoscale the axis view to the data (toggle).
2769 
2770         Convenience method for simple axis view autoscaling.
2771         It turns autoscaling on or off, and then,
2772         if autoscaling for either axis is on, it performs
2773         the autoscaling on the specified axis or Axes.
2774 
2775         Parameters
2776         ----------
2777         enable : bool or None, default: True
2778             True turns autoscaling on, False turns it off.
2779             None leaves the autoscaling state unchanged.
2780         axis : {'both', 'x', 'y'}, default: 'both'
2781             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2782             to 'z', and 'both' refers to all three axes.)
2783         tight : bool or None, default: None
2784             If True, first set the margins to zero.  Then, this argument is
2785             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2786             its value); see the description of its behavior there.
2787         """
2788         if enable is None:
2789             scalex = True
2790             scaley = True
2791         else:
2792             if axis in ['x', 'both']:
2793                 self.set_autoscalex_on(bool(enable))
2794                 scalex = self.get_autoscalex_on()
2795             else:
2796                 scalex = False
2797             if axis in ['y', 'both']:
2798                 self.set_autoscaley_on(bool(enable))
2799                 scaley = self.get_autoscaley_on()
2800             else:
2801                 scaley = False
2802         if tight and scalex:
2803             self._xmargin = 0
2804         if tight and scaley:
2805             self._ymargin = 0
2806         if scalex:
2807             self._request_autoscale_view("x", tight=tight)
2808         if scaley:
2809             self._request_autoscale_view("y", tight=tight)

</code><intended_behavior>After a norm change to LogNorm, the autoscale method should correctly assess and update the plot's view limits in accordance with the logarithmic scale. This might involve ensuring that data limits are recalculated or interpreted correctly under the new norm, potentially requiring an additional check or recalibration step.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     @_api.delete_parameter("3.6", "args")
800     @_api.delete_parameter("3.6", "kwargs")
801     def get_window_extent(self, renderer=None, *args, **kwargs):
802         """
803         Return the Axes bounding box in display space; *args* and *kwargs*
804         are empty.
805 
806         This bounding box does not include the spines, ticks, ticklabels,
807         or other labels.  For a bounding box including these elements use
808         `~matplotlib.axes.Axes.get_tightbbox`.
809 
810         See Also
811         --------
812         matplotlib.axes.Axes.get_tightbbox
813         matplotlib.axis.Axis.get_tightbbox
814         matplotlib.spines.Spine.get_window_extent
815         """
816         return self.bbox
817 
818     def _init_axis(self):
819         # This is moved out of __init__ because non-separable axes don't use it
820         self.xaxis = maxis.XAxis(self)
821         self.spines.bottom.register_axis(self.xaxis)
822         self.spines.top.register_axis(self.xaxis)
823         self.yaxis = maxis.YAxis(self)
824         self.spines.left.register_axis(self.yaxis)
825         self.spines.right.register_axis(self.yaxis)
826 
827     def set_figure(self, fig):
828         # docstring inherited
829         super().set_figure(fig)
830 
831         self.bbox = mtransforms.TransformedBbox(self._position,
832                                                 fig.transSubfigure)
833         # these will be updated later as data is added
834         self.dataLim = mtransforms.Bbox.null()
835         self._viewLim = mtransforms.Bbox.unit()
836         self.transScale = mtransforms.TransformWrapper(
837             mtransforms.IdentityTransform())
838 
839         self._set_lim_and_transforms()
840 
841     def _unstale_viewLim(self):
842         # We should arrange to store this information once per share-group
843         # instead of on every axis.
844         need_scale = {
845             name: any(ax._stale_viewlims[name]
846                       for ax in self._shared_axes[name].get_siblings(self))
847             for name in self._axis_names}
848         if any(need_scale.values()):
849             for name in need_scale:
850                 for ax in self._shared_axes[name].get_siblings(self):
851                     ax._stale_viewlims[name] = False
852             self.autoscale_view(**{f"scale{name}": scale
853                                    for name, scale in need_scale.items()})
854 
855     @property
856     def viewLim(self):
857         self._unstale_viewLim()
858         return self._viewLim
859 
860     def _request_autoscale_view(self, axis="all", tight=None):
861         """
862         Mark a single axis, or all of them, as stale wrt. autoscaling.
863 
864         No computation is performed until the next autoscaling; thus, separate
865         calls to control individual axises incur negligible performance cost.
866 
867         Parameters
868         ----------
869         axis : str, default: "all"
870             Either an element of ``self._axis_names``, or "all".
871         tight : bool or None, default: None
872         """
873         axis_names = _api.check_getitem(
874             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
875             axis=axis)
876         for name in axis_names:
877             self._stale_viewlims[name] = True
878         if tight is not None:
879             self._tight = tight
880 
881     def _set_lim_and_transforms(self):
882         """
883         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
884         *transData*, *transLimits* and *transAxes* transformations.
885 
886         .. note::
887 
888             This method is primarily used by rectilinear projections of the
889             `~matplotlib.axes.Axes` class, and is meant to be overridden by
890             new kinds of projection Axes that need different transformations
891             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
892             example.)
893         """
894         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
895 
896         # Transforms the x and y axis separately by a scale factor.
897         # It is assumed that this part will have non-linear components
898         # (e.g., for a log scale).
899         self.transScale = mtransforms.TransformWrapper(
900             mtransforms.IdentityTransform())
901 
902         # An affine transformation on the data, generally to limit the
903         # range of the axes
904         self.transLimits = mtransforms.BboxTransformFrom(
905             mtransforms.TransformedBbox(self._viewLim, self.transScale))
906 
907         # The parentheses are important for efficiency here -- they
908         # group the last two (which are usually affines) separately
909         # from the first (which, with log-scaling can be non-affine).
910         self.transData = self.transScale + (self.transLimits + self.transAxes)
911 
912         self._xaxis_transform = mtransforms.blended_transform_factory(
913             self.transData, self.transAxes)
914         self._yaxis_transform = mtransforms.blended_transform_factory(
915             self.transAxes, self.transData)
916 
917     def get_xaxis_transform(self, which='grid'):
918         """
919         Get the transformation used for drawing x-axis labels, ticks
920         and gridlines.  The x-direction is in data coordinates and the
921         y-direction is in axis coordinates.
922 
923         .. note::
924 
925             This transformation is primarily used by the
926             `~matplotlib.axis.Axis` class, and is meant to be
927             overridden by new kinds of projections that may need to
928             place axis elements in different locations.
929 
930         Parameters
931         ----------
932         which : {'grid', 'tick1', 'tick2'}
933         """
934         if which == 'grid':
935             return self._xaxis_transform
936         elif which == 'tick1':
937             # for cartesian projection, this is bottom spine
938             return self.spines.bottom.get_spine_transform()
939         elif which == 'tick2':
940             # for cartesian projection, this is top spine
941             return self.spines.top.get_spine_transform()
942         else:
943             raise ValueError(f'unknown value for which: {which!r}')
944 
945     def get_xaxis_text1_transform(self, pad_points):
946         """
947         Returns
948         -------
949         transform : Transform
950             The transform used for drawing x-axis labels, which will add
951             *pad_points* of padding (in points) between the axis and the label.
952             The x-direction is in data coordinates and the y-direction is in
953             axis coordinates
954         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
955             The text vertical alignment.
956         halign : {'center', 'left', 'right'}
957             The text horizontal alignment.
958 
959         Notes
960         -----
961         This transformation is primarily used by the `~matplotlib.axis.Axis`
962         class, and is meant to be overridden by new kinds of projections that
963         may need to place axis elements in different locations.
964         """
965         labels_align = mpl.rcParams["xtick.alignment"]
966         return (self.get_xaxis_transform(which='tick1') +
967                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
968                                               self.figure.dpi_scale_trans),
969                 "top", labels_align)
970 
971     def get_xaxis_text2_transform(self, pad_points):
972         """
973         Returns
974         -------
975         transform : Transform
976             The transform used for drawing secondary x-axis labels, which will
977             add *pad_points* of padding (in points) between the axis and the
978             label.  The x-direction is in data coordinates and the y-direction
979             is in axis coordinates
980         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
981             The text vertical alignment.
982         halign : {'center', 'left', 'right'}
983             The text horizontal alignment.
984 
985         Notes
986         -----
987         This transformation is primarily used by the `~matplotlib.axis.Axis`
988         class, and is meant to be overridden by new kinds of projections that
989         may need to place axis elements in different locations.
990         """
991         labels_align = mpl.rcParams["xtick.alignment"]
992         return (self.get_xaxis_transform(which='tick2') +
993                 mtransforms.ScaledTranslation(0, pad_points / 72,
994                                               self.figure.dpi_scale_trans),
995                 "bottom", labels_align)
996 
997     def get_yaxis_transform(self, which='grid'):
998         """
999         Get the transformation used for drawing y-axis labels, ticks
1000         and gridlines.  The x-direction is in axis coordinates and the
1001         y-direction is in data coordinates.
1002 
1003         .. note::
1004 
1005             This transformation is primarily used by the
1006             `~matplotlib.axis.Axis` class, and is meant to be
1007             overridden by new kinds of projections that may need to
1008             place axis elements in different locations.
1009 
1010         Parameters
1011         ----------
1012         which : {'grid', 'tick1', 'tick2'}
1013         """
1014         if which == 'grid':
1015             return self._yaxis_transform
1016         elif which == 'tick1':
1017             # for cartesian projection, this is bottom spine
1018             return self.spines.left.get_spine_transform()
1019         elif which == 'tick2':
1020             # for cartesian projection, this is top spine
1021             return self.spines.right.get_spine_transform()
1022         else:
1023             raise ValueError(f'unknown value for which: {which!r}')
1024 
1025     def get_yaxis_text1_transform(self, pad_points):
1026         """
1027         Returns
1028         -------
1029         transform : Transform
1030             The transform used for drawing y-axis labels, which will add
1031             *pad_points* of padding (in points) between the axis and the label.
1032             The x-direction is in axis coordinates and the y-direction is in
1033             data coordinates
1034         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1035             The text vertical alignment.
1036         halign : {'center', 'left', 'right'}
1037             The text horizontal alignment.
1038 
1039         Notes
1040         -----
1041         This transformation is primarily used by the `~matplotlib.axis.Axis`
1042         class, and is meant to be overridden by new kinds of projections that
1043         may need to place axis elements in different locations.
1044         """
1045         labels_align = mpl.rcParams["ytick.alignment"]
1046         return (self.get_yaxis_transform(which='tick1') +
1047                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1048                                               self.figure.dpi_scale_trans),
1049                 labels_align, "right")
1050 
1051     def get_yaxis_text2_transform(self, pad_points):
1052         """
1053         Returns
1054         -------
1055         transform : Transform
1056             The transform used for drawing secondart y-axis labels, which will
1057             add *pad_points* of padding (in points) between the axis and the
1058             label.  The x-direction is in axis coordinates and the y-direction
1059             is in data coordinates
1060         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1061             The text vertical alignment.
1062         halign : {'center', 'left', 'right'}
1063             The text horizontal alignment.
1064 
1065         Notes
1066         -----
1067         This transformation is primarily used by the `~matplotlib.axis.Axis`
1068         class, and is meant to be overridden by new kinds of projections that
1069         may need to place axis elements in different locations.
1070         """
1071         labels_align = mpl.rcParams["ytick.alignment"]
1072         return (self.get_yaxis_transform(which='tick2') +
1073                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1074                                               self.figure.dpi_scale_trans),
1075                 labels_align, "left")
1076 
1077     def _update_transScale(self):
1078         self.transScale.set(
1079             mtransforms.blended_transform_factory(
1080                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1081 
1082     def get_position(self, original=False):
1083         """
1084         Return the position of the Axes within the figure as a `.Bbox`.
1085 
1086         Parameters
1087         ----------
1088         original : bool
1089             If ``True``, return the original position. Otherwise, return the
1090             active position. For an explanation of the positions see
1091             `.set_position`.
1092 
1093         Returns
1094         -------
1095         `.Bbox`
1096 
1097         """
1098         if original:
1099             return self._originalPosition.frozen()
1100         else:
1101             locator = self.get_axes_locator()
1102             if not locator:
1103                 self.apply_aspect()
1104             return self._position.frozen()
1105 
1106     def set_position(self, pos, which='both'):
1107         """
1108         Set the Axes position.
1109 
1110         Axes have two position attributes. The 'original' position is the
1111         position allocated for the Axes. The 'active' position is the
1112         position the Axes is actually drawn at. These positions are usually
1113         the same unless a fixed aspect is set to the Axes. See
1114         `.Axes.set_aspect` for details.
1115 
1116         Parameters
1117         ----------
1118         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1119             The new position of the Axes in `.Figure` coordinates.
1120 
1121         which : {'both', 'active', 'original'}, default: 'both'
1122             Determines which position variables to change.
1123 
1124         See Also
1125         --------
1126         matplotlib.transforms.Bbox.from_bounds
1127         matplotlib.transforms.Bbox.from_extents
1128         """
1129         self._set_position(pos, which=which)
1130         # because this is being called externally to the library we
1131         # don't let it be in the layout.
1132         self.set_in_layout(False)
1133 
1134     def _set_position(self, pos, which='both'):
1135         """
1136         Private version of set_position.
1137 
1138         Call this internally to get the same functionality of `set_position`,
1139         but not to take the axis out of the constrained_layout hierarchy.
1140         """
1141         if not isinstance(pos, mtransforms.BboxBase):
1142             pos = mtransforms.Bbox.from_bounds(*pos)
1143         for ax in self._twinned_axes.get_siblings(self):
1144             if which in ('both', 'active'):
1145                 ax._position.set(pos)
1146             if which in ('both', 'original'):
1147                 ax._originalPosition.set(pos)
1148         self.stale = True
1149 
1150     def reset_position(self):
1151         """
1152         Reset the active position to the original position.
1153 
1154         This undoes changes to the active position (as defined in
1155         `.set_position`) which may have been performed to satisfy fixed-aspect
1156         constraints.
1157         """
1158         for ax in self._twinned_axes.get_siblings(self):
1159             pos = ax.get_position(original=True)
1160             ax.set_position(pos, which='active')
1161 
1162     def set_axes_locator(self, locator):
1163         """
1164         Set the Axes locator.
1165 
1166         Parameters
1167         ----------
1168         locator : Callable[[Axes, Renderer], Bbox]
1169         """
1170         self._axes_locator = locator
1171         self.stale = True
1172 
1173     def get_axes_locator(self):
1174         """
1175         Return the axes_locator.
1176         """
1177         return self._axes_locator
1178 
1179     def _set_artist_props(self, a):
1180         """Set the boilerplate props for artists added to Axes."""
1181         a.set_figure(self.figure)
1182         if not a.is_transform_set():
1183             a.set_transform(self.transData)
1184 
1185         a.axes = self
1186         if a.get_mouseover():
1187             self._mouseover_set.add(a)
1188 
1189     def _gen_axes_patch(self):
1190         """
1191         Returns
1192         -------
1193         Patch
1194             The patch used to draw the background of the Axes.  It is also used
1195             as the clipping path for any data elements on the Axes.
1196 
1197             In the standard Axes, this is a rectangle, but in other projections
1198             it may not be.
1199 
1200         Notes
1201         -----
1202         Intended to be overridden by new projection types.
1203         """
1204         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1205 
1206     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1207         """
1208         Returns
1209         -------
1210         dict
1211             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1212             used to draw Axes spines.
1213 
1214             In the standard Axes, spines are single line segments, but in other
1215             projections they may not be.
1216 
1217         Notes
1218         -----
1219         Intended to be overridden by new projection types.
1220         """
1221         return {side: mspines.Spine.linear_spine(self, side)
1222                 for side in ['left', 'right', 'bottom', 'top']}
1223 
1224     def sharex(self, other):
1225         """
1226         Share the x-axis with *other*.
1227 
1228         This is equivalent to passing ``sharex=other`` when constructing the
1229         Axes, and cannot be used if the x-axis is already being shared with
1230         another Axes.
1231         """
1232         _api.check_isinstance(_AxesBase, other=other)
1233         if self._sharex is not None and other is not self._sharex:
1234             raise ValueError("x-axis is already shared")
1235         self._shared_axes["x"].join(self, other)
1236         self._sharex = other
1237         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1238         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1239         x0, x1 = other.get_xlim()
1240         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1241         self.xaxis._scale = other.xaxis._scale
1242 
1243     def sharey(self, other):
1244         """
1245         Share the y-axis with *other*.
1246 
1247         This is equivalent to passing ``sharey=other`` when constructing the
1248         Axes, and cannot be used if the y-axis is already being shared with
1249         another Axes.
1250         """
1251         _api.check_isinstance(_AxesBase, other=other)
1252         if self._sharey is not None and other is not self._sharey:
1253             raise ValueError("y-axis is already shared")
1254         self._shared_axes["y"].join(self, other)
1255         self._sharey = other
1256         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1257         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1258         y0, y1 = other.get_ylim()
1259         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1260         self.yaxis._scale = other.yaxis._scale
1261 
1262     def __clear(self):
1263         """Clear the Axes."""
1264         # The actual implementation of clear() as long as clear() has to be
1265         # an adapter delegating to the correct implementation.
1266         # The implementation can move back into clear() when the
1267         # deprecation on cla() subclassing expires.
1268 
1269         # stash the current visibility state
1270         if hasattr(self, 'patch'):
1271             patch_visible = self.patch.get_visible()
1272         else:
1273             patch_visible = True
1274 
1275         xaxis_visible = self.xaxis.get_visible()
1276         yaxis_visible = self.yaxis.get_visible()
1277 
1278         for axis in self._axis_map.values():
1279             axis.clear()  # Also resets the scale to linear.
1280         for spine in self.spines.values():
1281             spine.clear()
1282 
1283         self.ignore_existing_data_limits = True
1284         self.callbacks = cbook.CallbackRegistry(
1285             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1286 
1287         # update the minor locator for x and y axis based on rcParams
1288         if mpl.rcParams['xtick.minor.visible']:
1289             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1290         if mpl.rcParams['ytick.minor.visible']:
1291             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1292 
1293         self._xmargin = mpl.rcParams['axes.xmargin']
1294         self._ymargin = mpl.rcParams['axes.ymargin']
1295         self._tight = None
1296         self._use_sticky_edges = True
1297 
1298         self._get_lines = _process_plot_var_args(self)
1299         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1300 
1301         self._gridOn = mpl.rcParams['axes.grid']
1302         old_children, self._children = self._children, []
1303         for chld in old_children:
1304             chld.axes = chld.figure = None
1305         self._mouseover_set = _OrderedSet()
1306         self.child_axes = []
1307         self._current_image = None  # strictly for pyplot via _sci, _gci
1308         self._projection_init = None  # strictly for pyplot.subplot
1309         self.legend_ = None
1310         self.containers = []
1311 
1312         self.grid(False)  # Disable grid on init to use rcParameter
1313         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1314                   axis=mpl.rcParams['axes.grid.axis'])
1315         props = font_manager.FontProperties(
1316             size=mpl.rcParams['axes.titlesize'],
1317             weight=mpl.rcParams['axes.titleweight'])
1318 
1319         y = mpl.rcParams['axes.titley']
1320         if y is None:
1321             y = 1.0
1322             self._autotitlepos = True
1323         else:
1324             self._autotitlepos = False
1325 
1326         self.title = mtext.Text(
1327             x=0.5, y=y, text='',
1328             fontproperties=props,
1329             verticalalignment='baseline',
1330             horizontalalignment='center',
1331             )
1332         self._left_title = mtext.Text(
1333             x=0.0, y=y, text='',
1334             fontproperties=props.copy(),
1335             verticalalignment='baseline',
1336             horizontalalignment='left', )
1337         self._right_title = mtext.Text(
1338             x=1.0, y=y, text='',
1339             fontproperties=props.copy(),
1340             verticalalignment='baseline',
1341             horizontalalignment='right',
1342             )
1343         title_offset_points = mpl.rcParams['axes.titlepad']
1344         # refactor this out so it can be called in ax.set_title if
1345         # pad argument used...
1346         self._set_title_offset_trans(title_offset_points)
1347 
1348         for _title in (self.title, self._left_title, self._right_title):
1349             self._set_artist_props(_title)
1350 
1351         # The patch draws the background of the Axes.  We want this to be below
1352         # the other artists.  We use the frame to draw the edges so we are
1353         # setting the edgecolor to None.
1354         self.patch = self._gen_axes_patch()
1355         self.patch.set_figure(self.figure)
1356         self.patch.set_facecolor(self._facecolor)
1357         self.patch.set_edgecolor('none')
1358         self.patch.set_linewidth(0)
1359         self.patch.set_transform(self.transAxes)
1360 
1361         self.set_axis_on()
1362 
1363         self.xaxis.set_clip_path(self.patch)
1364         self.yaxis.set_clip_path(self.patch)
1365 
1366         self._shared_axes["x"].clean()
1367         self._shared_axes["y"].clean()
1368         if self._sharex is not None:
1369             self.xaxis.set_visible(xaxis_visible)
1370             self.patch.set_visible(patch_visible)
1371         if self._sharey is not None:
1372             self.yaxis.set_visible(yaxis_visible)
1373             self.patch.set_visible(patch_visible)
1374 
1375         # This comes last, as the call to _set_lim may trigger an autoscale (in
1376         # case of shared axes), requiring children to be already set up.
1377         for name, axis in self._axis_map.items():
1378             share = getattr(self, f"_share{name}")
1379             if share is not None:
1380                 getattr(self, f"share{name}")(share)
1381             else:
1382                 axis._set_scale("linear")
1383                 axis._set_lim(0, 1, auto=True)
1384         self._update_transScale()
1385 
1386         self.stale = True
1387 
1388     def clear(self):
1389         """Clear the Axes."""
1390         # Act as an alias, or as the superclass implementation depending on the
1391         # subclass implementation.
1392         if self._subclass_uses_cla:
1393             self.cla()
1394         else:
1395             self.__clear()
1396 
1397     def cla(self):
1398         """Clear the Axes."""
1399         # Act as an alias, or as the superclass implementation depending on the
1400         # subclass implementation.
1401         if self._subclass_uses_cla:
1402             self.__clear()
1403         else:
1404             self.clear()
1405 
1406     class ArtistList(Sequence):
1407         """
1408         A sublist of Axes children based on their type.
1409 
1410         The type-specific children sublists were made immutable in Matplotlib
1411         3.7.  In the future these artist lists may be replaced by tuples. Use
1412         as if this is a tuple already.
1413         """
1414         def __init__(self, axes, prop_name,
1415                      valid_types=None, invalid_types=None):
1416             """
1417             Parameters
1418             ----------
1419             axes : `~matplotlib.axes.Axes`
1420                 The Axes from which this sublist will pull the children
1421                 Artists.
1422             prop_name : str
1423                 The property name used to access this sublist from the Axes;
1424                 used to generate deprecation warnings.
1425             valid_types : list of type, optional
1426                 A list of types that determine which children will be returned
1427                 by this sublist. If specified, then the Artists in the sublist
1428                 must be instances of any of these types. If unspecified, then
1429                 any type of Artist is valid (unless limited by
1430                 *invalid_types*.)
1431             invalid_types : tuple, optional
1432                 A list of types that determine which children will *not* be
1433                 returned by this sublist. If specified, then Artists in the
1434                 sublist will never be an instance of these types. Otherwise, no
1435                 types will be excluded.
1436             """
1437             self._axes = axes
1438             self._prop_name = prop_name
1439             self._type_check = lambda artist: (
1440                 (not valid_types or isinstance(artist, valid_types)) and
1441                 (not invalid_types or not isinstance(artist, invalid_types))
1442             )
1443 
1444         def __repr__(self):
1445             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1446 
1447         def __len__(self):
1448             return sum(self._type_check(artist)
1449                        for artist in self._axes._children)
1450 
1451         def __iter__(self):
1452             for artist in list(self._axes._children):
1453                 if self._type_check(artist):
1454                     yield artist
1455 
1456         def __getitem__(self, key):
1457             return [artist
1458                     for artist in self._axes._children
1459                     if self._type_check(artist)][key]
1460 
1461         def __add__(self, other):
1462             if isinstance(other, (list, _AxesBase.ArtistList)):
1463                 return [*self, *other]
1464             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1465                 return (*self, *other)
1466             return NotImplemented
1467 
1468         def __radd__(self, other):
1469             if isinstance(other, list):
1470                 return other + list(self)
1471             if isinstance(other, tuple):
1472                 return other + tuple(self)
1473             return NotImplemented
1474 
1475     @property
1476     def artists(self):
1477         return self.ArtistList(self, 'artists', invalid_types=(
1478             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1479             mtable.Table, mtext.Text))
1480 
1481     @property
1482     def collections(self):
1483         return self.ArtistList(self, 'collections',
1484                                valid_types=mcoll.Collection)
1485 
1486     @property
1487     def images(self):
1488         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1489 
1490     @property
1491     def lines(self):
1492         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1493 
1494     @property
1495     def patches(self):
1496         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1497 
1498     @property
1499     def tables(self):
1500         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1501 
1502     @property
1503     def texts(self):
1504         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1505 
1506     def get_facecolor(self):
1507         """Get the facecolor of the Axes."""
1508         return self.patch.get_facecolor()
1509 
1510     def set_facecolor(self, color):
1511         """
1512         Set the facecolor of the Axes.
1513 
1514         Parameters
1515         ----------
1516         color : color
1517         """
1518         self._facecolor = color
1519         self.stale = True
1520         return self.patch.set_facecolor(color)
1521 
1522     def _set_title_offset_trans(self, title_offset_points):
1523         """
1524         Set the offset for the title either from :rc:`axes.titlepad`
1525         or from set_title kwarg ``pad``.
1526         """
1527         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1528                 0.0, title_offset_points / 72,
1529                 self.figure.dpi_scale_trans)
1530         for _title in (self.title, self._left_title, self._right_title):
1531             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1532             _title.set_clip_box(None)
1533 
1534     def set_prop_cycle(self, *args, **kwargs):
1535         """
1536         Set the property cycle of the Axes.
1537 
1538         The property cycle controls the style properties such as color,
1539         marker and linestyle of future plot commands. The style properties
1540         of data already added to the Axes are not modified.
1541 
1542         Call signatures::
1543 
1544           set_prop_cycle(cycler)
1545           set_prop_cycle(label=values[, label2=values2[, ...]])
1546           set_prop_cycle(label, values)
1547 
1548         Form 1 sets given `~cycler.Cycler` object.
1549 
1550         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1551         properties simultaneously and set it as the property cycle of the
1552         Axes. If multiple properties are given, their value lists must have
1553         the same length. This is just a shortcut for explicitly creating a
1554         cycler and passing it to the function, i.e. it's short for
1555         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1556 
1557         Form 3 creates a `~cycler.Cycler` for a single property and set it
1558         as the property cycle of the Axes. This form exists for compatibility
1559         with the original `cycler.cycler` interface. Its use is discouraged
1560         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1561 
1562         Parameters
1563         ----------
1564         cycler : Cycler
1565             Set the given Cycler. *None* resets to the cycle defined by the
1566             current style.
1567 
1568         label : str
1569             The property key. Must be a valid `.Artist` property.
1570             For example, 'color' or 'linestyle'. Aliases are allowed,
1571             such as 'c' for 'color' and 'lw' for 'linewidth'.
1572 
1573         values : iterable
1574             Finite-length iterable of the property values. These values
1575             are validated and will raise a ValueError if invalid.
1576 
1577         See Also
1578         --------
1579         matplotlib.rcsetup.cycler
1580             Convenience function for creating validated cyclers for properties.
1581         cycler.cycler
1582             The original function for creating unvalidated cyclers.
1583 
1584         Examples
1585         --------
1586         Setting the property cycle for a single property:
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1589 
1590         Setting the property cycle for simultaneously cycling over multiple
1591         properties (e.g. red circle, green plus, blue cross):
1592 
1593         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1594         ...                   marker=['o', '+', 'x'])
1595 
1596         """
1597         if args and kwargs:
1598             raise TypeError("Cannot supply both positional and keyword "
1599                             "arguments to this method.")
1600         # Can't do `args == (None,)` as that crashes cycler.
1601         if len(args) == 1 and args[0] is None:
1602             prop_cycle = None
1603         else:
1604             prop_cycle = cycler(*args, **kwargs)
1605         self._get_lines.set_prop_cycle(prop_cycle)
1606         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1607 
1608     def get_aspect(self):
1609         """
1610         Return the aspect ratio of the axes scaling.
1611 
1612         This is either "auto" or a float giving the ratio of y/x-scale.
1613         """
1614         return self._aspect
1615 
1616     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1617         """
1618         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1619 
1620         Parameters
1621         ----------
1622         aspect : {'auto', 'equal'} or float
1623             Possible values:
1624 
1625             - 'auto': fill the position rectangle with data.
1626             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1627             - *float*: The displayed size of 1 unit in y-data coordinates will
1628               be *aspect* times the displayed size of 1 unit in x-data
1629               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1630               will be rendered with a height of twice its width.
1631 
1632         adjustable : None or {'box', 'datalim'}, optional
1633             If not ``None``, this defines which parameter will be adjusted to
1634             meet the required aspect. See `.set_adjustable` for further
1635             details.
1636 
1637         anchor : None or str or (float, float), optional
1638             If not ``None``, this defines where the Axes will be drawn if there
1639             is extra space due to aspect constraints. The most common way
1640             to specify the anchor are abbreviations of cardinal directions:
1641 
1642             =====   =====================
1643             value   description
1644             =====   =====================
1645             'C'     centered
1646             'SW'    lower left corner
1647             'S'     middle of bottom edge
1648             'SE'    lower right corner
1649             etc.
1650             =====   =====================
1651 
1652             See `~.Axes.set_anchor` for further details.
1653 
1654         share : bool, default: False
1655             If ``True``, apply the settings to all shared Axes.
1656 
1657         See Also
1658         --------
1659         matplotlib.axes.Axes.set_adjustable
1660             Set how the Axes adjusts to achieve the required aspect ratio.
1661         matplotlib.axes.Axes.set_anchor
1662             Set the position in case of extra space.
1663         """
1664         if cbook._str_equal(aspect, 'equal'):
1665             aspect = 1
1666         if not cbook._str_equal(aspect, 'auto'):
1667             aspect = float(aspect)  # raise ValueError if necessary
1668             if aspect <= 0 or not np.isfinite(aspect):
1669                 raise ValueError("aspect must be finite and positive ")
1670 
1671         if share:
1672             axes = {sibling for name in self._axis_names
1673                     for sibling in self._shared_axes[name].get_siblings(self)}
1674         else:
1675             axes = [self]
1676 
1677         for ax in axes:
1678             ax._aspect = aspect
1679 
1680         if adjustable is None:
1681             adjustable = self._adjustable
1682         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1683 
1684         if anchor is not None:
1685             self.set_anchor(anchor, share=share)
1686         self.stale = True
1687 
1688     def get_adjustable(self):
1689         """
1690         Return whether the Axes will adjust its physical dimension ('box') or
1691         its data limits ('datalim') to achieve the desired aspect ratio.
1692 
1693         See Also
1694         --------
1695         matplotlib.axes.Axes.set_adjustable
1696             Set how the Axes adjusts to achieve the required aspect ratio.
1697         matplotlib.axes.Axes.set_aspect
1698             For a description of aspect handling.
1699         """
1700         return self._adjustable
1701 
1702     def set_adjustable(self, adjustable, share=False):
1703         """
1704         Set how the Axes adjusts to achieve the required aspect ratio.
1705 
1706         Parameters
1707         ----------
1708         adjustable : {'box', 'datalim'}
1709             If 'box', change the physical dimensions of the Axes.
1710             If 'datalim', change the ``x`` or ``y`` data limits.
1711 
1712         share : bool, default: False
1713             If ``True``, apply the settings to all shared Axes.
1714 
1715         See Also
1716         --------
1717         matplotlib.axes.Axes.set_aspect
1718             For a description of aspect handling.
1719 
1720         Notes
1721         -----
1722         Shared Axes (of which twinned Axes are a special case)
1723         impose restrictions on how aspect ratios can be imposed.
1724         For twinned Axes, use 'datalim'.  For Axes that share both
1725         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1726         may be used.  These limitations are partly a requirement
1727         to avoid over-specification, and partly a result of the
1728         particular implementation we are currently using, in
1729         which the adjustments for aspect ratios are done sequentially
1730         and independently on each Axes as it is drawn.
1731         """
1732         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1733         if share:
1734             axs = {sibling for name in self._axis_names
1735                    for sibling in self._shared_axes[name].get_siblings(self)}
1736         else:
1737             axs = [self]
1738         if (adjustable == "datalim"
1739                 and any(getattr(ax.get_data_ratio, "__func__", None)
1740                         != _AxesBase.get_data_ratio
1741                         for ax in axs)):
1742             # Limits adjustment by apply_aspect assumes that the axes' aspect
1743             # ratio can be computed from the data limits and scales.
1744             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1745                              "Axes which override 'get_data_ratio'")
1746         for ax in axs:
1747             ax._adjustable = adjustable
1748         self.stale = True
1749 
1750     def get_box_aspect(self):
1751         """
1752         Return the Axes box aspect, i.e. the ratio of height to width.
1753 
1754         The box aspect is ``None`` (i.e. chosen depending on the available
1755         figure space) unless explicitly specified.
1756 
1757         See Also
1758         --------
1759         matplotlib.axes.Axes.set_box_aspect
1760             for a description of box aspect.
1761         matplotlib.axes.Axes.set_aspect
1762             for a description of aspect handling.
1763         """
1764         return self._box_aspect
1765 
1766     def set_box_aspect(self, aspect=None):
1767         """
1768         Set the Axes box aspect, i.e. the ratio of height to width.
1769 
1770         This defines the aspect of the Axes in figure space and is not to be
1771         confused with the data aspect (see `~.Axes.set_aspect`).
1772 
1773         Parameters
1774         ----------
1775         aspect : float or None
1776             Changes the physical dimensions of the Axes, such that the ratio
1777             of the Axes height to the Axes width in physical units is equal to
1778             *aspect*. Defining a box aspect will change the *adjustable*
1779             property to 'datalim' (see `~.Axes.set_adjustable`).
1780 
1781             *None* will disable a fixed box aspect so that height and width
1782             of the Axes are chosen independently.
1783 
1784         See Also
1785         --------
1786         matplotlib.axes.Axes.set_aspect
1787             for a description of aspect handling.
1788         """
1789         axs = {*self._twinned_axes.get_siblings(self),
1790                *self._twinned_axes.get_siblings(self)}
1791 
1792         if aspect is not None:
1793             aspect = float(aspect)
1794             # when box_aspect is set to other than ´None`,
1795             # adjustable must be "datalim"
1796             for ax in axs:
1797                 ax.set_adjustable("datalim")
1798 
1799         for ax in axs:
1800             ax._box_aspect = aspect
1801             ax.stale = True
1802 
1803     def get_anchor(self):
1804         """
1805         Get the anchor location.
1806 
1807         See Also
1808         --------
1809         matplotlib.axes.Axes.set_anchor
1810             for a description of the anchor.
1811         matplotlib.axes.Axes.set_aspect
1812             for a description of aspect handling.
1813         """
1814         return self._anchor
1815 
1816     def set_anchor(self, anchor, share=False):
1817         """
1818         Define the anchor location.
1819 
1820         The actual drawing area (active position) of the Axes may be smaller
1821         than the Bbox (original position) when a fixed aspect is required. The
1822         anchor defines where the drawing area will be located within the
1823         available space.
1824 
1825         Parameters
1826         ----------
1827         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1828             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1829             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1830             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1831             for (*x*, *y*) coordinates, as shown in the following diagram::
1832 
1833                ┌─────────────────┬─────────────────┬─────────────────┐
1834                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1835                ├─────────────────┼─────────────────┼─────────────────┤
1836                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1837                ├─────────────────┼─────────────────┼─────────────────┤
1838                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1839                └─────────────────┴─────────────────┴─────────────────┘
1840 
1841         share : bool, default: False
1842             If ``True``, apply the settings to all shared Axes.
1843 
1844         See Also
1845         --------
1846         matplotlib.axes.Axes.set_aspect
1847             for a description of aspect handling.
1848         """
1849         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1850             raise ValueError('argument must be among %s' %
1851                              ', '.join(mtransforms.Bbox.coefs))
1852         if share:
1853             axes = {sibling for name in self._axis_names
1854                     for sibling in self._shared_axes[name].get_siblings(self)}
1855         else:
1856             axes = [self]
1857         for ax in axes:
1858             ax._anchor = anchor
1859 
1860         self.stale = True
1861 
1862     def get_data_ratio(self):
1863         """
1864         Return the aspect ratio of the scaled data.
1865 
1866         Notes
1867         -----
1868         This method is intended to be overridden by new projection types.
1869         """
1870         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1871         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1872         xsize = max(abs(txmax - txmin), 1e-30)
1873         ysize = max(abs(tymax - tymin), 1e-30)
1874         return ysize / xsize
1875 
1876     def apply_aspect(self, position=None):
1877         """
1878         Adjust the Axes for a specified data aspect ratio.
1879 
1880         Depending on `.get_adjustable` this will modify either the
1881         Axes box (position) or the view limits. In the former case,
1882         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1883 
1884         Parameters
1885         ----------
1886         position : None or .Bbox
1887             If not ``None``, this defines the position of the
1888             Axes within the figure as a Bbox. See `~.Axes.get_position`
1889             for further details.
1890 
1891         Notes
1892         -----
1893         This is called automatically when each Axes is drawn.  You may need
1894         to call it yourself if you need to update the Axes position and/or
1895         view limits before the Figure is drawn.
1896 
1897         See Also
1898         --------
1899         matplotlib.axes.Axes.set_aspect
1900             For a description of aspect ratio handling.
1901         matplotlib.axes.Axes.set_adjustable
1902             Set how the Axes adjusts to achieve the required aspect ratio.
1903         matplotlib.axes.Axes.set_anchor
1904             Set the position in case of extra space.
1905         """
1906         if position is None:
1907             position = self.get_position(original=True)
1908 
1909         aspect = self.get_aspect()
1910 
1911         if aspect == 'auto' and self._box_aspect is None:
1912             self._set_position(position, which='active')
1913             return
1914 
1915         trans = self.get_figure().transSubfigure
1916         bb = mtransforms.Bbox.unit().transformed(trans)
1917         # this is the physical aspect of the panel (or figure):
1918         fig_aspect = bb.height / bb.width
1919 
1920         if self._adjustable == 'box':
1921             if self in self._twinned_axes:
1922                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1923                                    "twinned Axes; use 'datalim' instead")
1924             box_aspect = aspect * self.get_data_ratio()
1925             pb = position.frozen()
1926             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1927             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1928             return
1929 
1930         # The following is only seen if self._adjustable == 'datalim'
1931         if self._box_aspect is not None:
1932             pb = position.frozen()
1933             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1934             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1935             if aspect == "auto":
1936                 return
1937 
1938         # reset active to original in case it had been changed by prior use
1939         # of 'box'
1940         if self._box_aspect is None:
1941             self._set_position(position, which='active')
1942         else:
1943             position = pb1.anchored(self.get_anchor(), pb)
1944 
1945         x_trf = self.xaxis.get_transform()
1946         y_trf = self.yaxis.get_transform()
1947         xmin, xmax = x_trf.transform(self.get_xbound())
1948         ymin, ymax = y_trf.transform(self.get_ybound())
1949         xsize = max(abs(xmax - xmin), 1e-30)
1950         ysize = max(abs(ymax - ymin), 1e-30)
1951 
1952         box_aspect = fig_aspect * (position.height / position.width)
1953         data_ratio = box_aspect / aspect
1954 
1955         y_expander = data_ratio * xsize / ysize - 1
1956         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1957         if abs(y_expander) < 0.005:
1958             return
1959 
1960         dL = self.dataLim
1961         x0, x1 = x_trf.transform(dL.intervalx)
1962         y0, y1 = y_trf.transform(dL.intervaly)
1963         xr = 1.05 * (x1 - x0)
1964         yr = 1.05 * (y1 - y0)
1965 
1966         xmarg = xsize - xr
1967         ymarg = ysize - yr
1968         Ysize = data_ratio * xsize
1969         Xsize = ysize / data_ratio
1970         Xmarg = Xsize - xr
1971         Ymarg = Ysize - yr
1972         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1973         xm = 0
1974         ym = 0
1975 
1976         shared_x = self in self._shared_axes["x"]
1977         shared_y = self in self._shared_axes["y"]
1978 
1979         if shared_x and shared_y:
1980             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1981                                "axis('equal') are not allowed when both axes "
1982                                "are shared.  Try set_aspect(..., "
1983                                "adjustable='box').")
1984 
1985         # If y is shared, then we are only allowed to change x, etc.
1986         if shared_y:
1987             adjust_y = False
1988         else:
1989             if xmarg > xm and ymarg > ym:
1990                 adjy = ((Ymarg > 0 and y_expander < 0) or
1991                         (Xmarg < 0 and y_expander > 0))
1992             else:
1993                 adjy = y_expander > 0
1994             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1995 
1996         if adjust_y:
1997             yc = 0.5 * (ymin + ymax)
1998             y0 = yc - Ysize / 2.0
1999             y1 = yc + Ysize / 2.0
2000             self.set_ybound(y_trf.inverted().transform([y0, y1]))
2001         else:
2002             xc = 0.5 * (xmin + xmax)
2003             x0 = xc - Xsize / 2.0
2004             x1 = xc + Xsize / 2.0
2005             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2006 
2007     def axis(self, arg=None, /, *, emit=True, **kwargs):
2008         """
2009         Convenience method to get or set some axis properties.
2010 
2011         Call signatures::
2012 
2013           xmin, xmax, ymin, ymax = axis()
2014           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2015           xmin, xmax, ymin, ymax = axis(option)
2016           xmin, xmax, ymin, ymax = axis(**kwargs)
2017 
2018         Parameters
2019         ----------
2020         xmin, xmax, ymin, ymax : float, optional
2021             The axis limits to be set.  This can also be achieved using ::
2022 
2023                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2024 
2025         option : bool or str
2026             If a bool, turns axis lines and labels on or off. If a string,
2027             possible values are:
2028 
2029             ======== ==========================================================
2030             Value    Description
2031             ======== ==========================================================
2032             'on'     Turn on axis lines and labels. Same as ``True``.
2033             'off'    Turn off axis lines and labels. Same as ``False``.
2034             'equal'  Set equal scaling (i.e., make circles circular) by
2035                      changing axis limits. This is the same as
2036                      ``ax.set_aspect('equal', adjustable='datalim')``.
2037                      Explicit data limits may not be respected in this case.
2038             'scaled' Set equal scaling (i.e., make circles circular) by
2039                      changing dimensions of the plot box. This is the same as
2040                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2041                      Additionally, further autoscaling will be disabled.
2042             'tight'  Set limits just large enough to show all data, then
2043                      disable further autoscaling.
2044             'auto'   Automatic scaling (fill plot box with data).
2045             'image'  'scaled' with axis limits equal to data limits.
2046             'square' Square plot; similar to 'scaled', but initially forcing
2047                      ``xmax-xmin == ymax-ymin``.
2048             ======== ==========================================================
2049 
2050         emit : bool, default: True
2051             Whether observers are notified of the axis limit change.
2052             This option is passed on to `~.Axes.set_xlim` and
2053             `~.Axes.set_ylim`.
2054 
2055         Returns
2056         -------
2057         xmin, xmax, ymin, ymax : float
2058             The axis limits.
2059 
2060         See Also
2061         --------
2062         matplotlib.axes.Axes.set_xlim
2063         matplotlib.axes.Axes.set_ylim
2064         """
2065         if isinstance(arg, (str, bool)):
2066             if arg is True:
2067                 arg = 'on'
2068             if arg is False:
2069                 arg = 'off'
2070             arg = arg.lower()
2071             if arg == 'on':
2072                 self.set_axis_on()
2073             elif arg == 'off':
2074                 self.set_axis_off()
2075             elif arg in [
2076                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2077                 self.set_autoscale_on(True)
2078                 self.set_aspect('auto')
2079                 self.autoscale_view(tight=False)
2080                 if arg == 'equal':
2081                     self.set_aspect('equal', adjustable='datalim')
2082                 elif arg == 'scaled':
2083                     self.set_aspect('equal', adjustable='box', anchor='C')
2084                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2085                 elif arg == 'tight':
2086                     self.autoscale_view(tight=True)
2087                     self.set_autoscale_on(False)
2088                 elif arg == 'image':
2089                     self.autoscale_view(tight=True)
2090                     self.set_autoscale_on(False)
2091                     self.set_aspect('equal', adjustable='box', anchor='C')
2092                 elif arg == 'square':
2093                     self.set_aspect('equal', adjustable='box', anchor='C')
2094                     self.set_autoscale_on(False)
2095                     xlim = self.get_xlim()
2096                     ylim = self.get_ylim()
2097                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2098                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2099                                   emit=emit, auto=False)
2100                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2101                                   emit=emit, auto=False)
2102             else:
2103                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2104                                  "try 'on' or 'off'")
2105         else:
2106             if arg is not None:
2107                 try:
2108                     xmin, xmax, ymin, ymax = arg
2109                 except (TypeError, ValueError) as err:
2110                     raise TypeError('the first argument to axis() must be an '
2111                                     'iterable of the form '
2112                                     '[xmin, xmax, ymin, ymax]') from err
2113             else:
2114                 xmin = kwargs.pop('xmin', None)
2115                 xmax = kwargs.pop('xmax', None)
2116                 ymin = kwargs.pop('ymin', None)
2117                 ymax = kwargs.pop('ymax', None)
2118             xauto = (None  # Keep autoscale state as is.
2119                      if xmin is None and xmax is None
2120                      else False)  # Turn off autoscale.
2121             yauto = (None
2122                      if ymin is None and ymax is None
2123                      else False)
2124             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2125             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2126         if kwargs:
2127             raise _api.kwarg_error("axis", kwargs)
2128         return (*self.get_xlim(), *self.get_ylim())
2129 
2130     def get_legend(self):
2131         """Return the `.Legend` instance, or None if no legend is defined."""
2132         return self.legend_
2133 
2134     def get_images(self):
2135         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2136         return cbook.silent_list('AxesImage', self.images)
2137 
2138     def get_lines(self):
2139         """Return a list of lines contained by the Axes."""
2140         return cbook.silent_list('Line2D', self.lines)
2141 
2142     def get_xaxis(self):
2143         """
2144         [*Discouraged*] Return the XAxis instance.
2145 
2146         .. admonition:: Discouraged
2147 
2148             The use of this function is discouraged. You should instead
2149             directly access the attribute ``ax.xaxis``.
2150         """
2151         return self.xaxis
2152 
2153     def get_yaxis(self):
2154         """
2155         [*Discouraged*] Return the YAxis instance.
2156 
2157         .. admonition:: Discouraged
2158 
2159             The use of this function is discouraged. You should instead
2160             directly access the attribute ``ax.yaxis``.
2161         """
2162         return self.yaxis
2163 
2164     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2165     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2166     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2167     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2168 
2169     # Adding and tracking artists
2170 
2171     def _sci(self, im):
2172         """
2173         Set the current image.
2174 
2175         This image will be the target of colormap functions like
2176         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2177         current image is an attribute of the current Axes.
2178         """
2179         _api.check_isinstance(
2180             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2181             im=im)
2182         if isinstance(im, mpl.contour.ContourSet):
2183             if im.collections[0] not in self._children:
2184                 raise ValueError("ContourSet must be in current Axes")
2185         elif im not in self._children:
2186             raise ValueError("Argument must be an image, collection, or "
2187                              "ContourSet in this Axes")
2188         self._current_image = im
2189 
2190     def _gci(self):
2191         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2192         return self._current_image
2193 
2194     def has_data(self):
2195         """
2196         Return whether any artists have been added to the Axes.
2197 
2198         This should not be used to determine whether the *dataLim*
2199         need to be updated, and may not actually be useful for
2200         anything.
2201         """
2202         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2203                                   mlines.Line2D, mpatches.Patch))
2204                    for a in self._children)
2205 
2206     def add_artist(self, a):
2207         """
2208         Add an `.Artist` to the Axes; return the artist.
2209 
2210         Use `add_artist` only for artists for which there is no dedicated
2211         "add" method; and if necessary, use a method such as `update_datalim`
2212         to manually update the dataLim if the artist is to be included in
2213         autoscaling.
2214 
2215         If no ``transform`` has been specified when creating the artist (e.g.
2216         ``artist.get_transform() == None``) then the transform is set to
2217         ``ax.transData``.
2218         """
2219         a.axes = self
2220         self._children.append(a)
2221         a._remove_method = self._children.remove
2222         self._set_artist_props(a)
2223         a.set_clip_path(self.patch)
2224         self.stale = True
2225         return a
2226 
2227     def add_child_axes(self, ax):
2228         """
2229         Add an `.AxesBase` to the Axes' children; return the child Axes.
2230 
2231         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2232         """
2233 
2234         # normally Axes have themselves as the Axes, but these need to have
2235         # their parent...
2236         # Need to bypass the getter...
2237         ax._axes = self
2238         ax.stale_callback = martist._stale_axes_callback
2239 
2240         self.child_axes.append(ax)
2241         ax._remove_method = self.child_axes.remove
2242         self.stale = True
2243         return ax
2244 
2245     def add_collection(self, collection, autolim=True):
2246         """
2247         Add a `.Collection` to the Axes; return the collection.
2248         """
2249         _api.check_isinstance(mcoll.Collection, collection=collection)
2250         label = collection.get_label()
2251         if not label:
2252             collection.set_label(f'_child{len(self._children)}')
2253         self._children.append(collection)
2254         collection._remove_method = self._children.remove
2255         self._set_artist_props(collection)
2256 
2257         if collection.get_clip_path() is None:
2258             collection.set_clip_path(self.patch)
2259 
2260         if autolim:
2261             # Make sure viewLim is not stale (mostly to match
2262             # pre-lazy-autoscale behavior, which is not really better).
2263             self._unstale_viewLim()
2264             datalim = collection.get_datalim(self.transData)
2265             points = datalim.get_points()
2266             if not np.isinf(datalim.minpos).all():
2267                 # By definition, if minpos (minimum positive value) is set
2268                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2269                 # and minpos would be superfluous. However, we add minpos to
2270                 # the call so that self.dataLim will update its own minpos.
2271                 # This ensures that log scales see the correct minimum.
2272                 points = np.concatenate([points, [datalim.minpos]])
2273             self.update_datalim(points)
2274 
2275         self.stale = True
2276         return collection
2277 
2278     def add_image(self, image):
2279         """
2280         Add an `.AxesImage` to the Axes; return the image.
2281         """
2282         _api.check_isinstance(mimage.AxesImage, image=image)
2283         self._set_artist_props(image)
2284         if not image.get_label():
2285             image.set_label(f'_child{len(self._children)}')
2286         self._children.append(image)
2287         image._remove_method = self._children.remove
2288         self.stale = True
2289         return image
2290 
2291     def _update_image_limits(self, image):
2292         xmin, xmax, ymin, ymax = image.get_extent()
2293         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2294 
2295     def add_line(self, line):
2296         """
2297         Add a `.Line2D` to the Axes; return the line.
2298         """
2299         _api.check_isinstance(mlines.Line2D, line=line)
2300         self._set_artist_props(line)
2301         if line.get_clip_path() is None:
2302             line.set_clip_path(self.patch)
2303 
2304         self._update_line_limits(line)
2305         if not line.get_label():
2306             line.set_label(f'_child{len(self._children)}')
2307         self._children.append(line)
2308         line._remove_method = self._children.remove
2309         self.stale = True
2310         return line
2311 
2312     def _add_text(self, txt):
2313         """
2314         Add a `.Text` to the Axes; return the text.
2315         """
2316         _api.check_isinstance(mtext.Text, txt=txt)
2317         self._set_artist_props(txt)
2318         self._children.append(txt)
2319         txt._remove_method = self._children.remove
2320         self.stale = True
2321         return txt
2322 
2323     def _update_line_limits(self, line):
2324         """
2325         Figures out the data limit of the given line, updating self.dataLim.
2326         """
2327         path = line.get_path()
2328         if path.vertices.size == 0:
2329             return
2330 
2331         line_trf = line.get_transform()
2332 
2333         if line_trf == self.transData:
2334             data_path = path
2335         elif any(line_trf.contains_branch_seperately(self.transData)):
2336             # Compute the transform from line coordinates to data coordinates.
2337             trf_to_data = line_trf - self.transData
2338             # If transData is affine we can use the cached non-affine component
2339             # of line's path (since the non-affine part of line_trf is
2340             # entirely encapsulated in trf_to_data).
2341             if self.transData.is_affine:
2342                 line_trans_path = line._get_transformed_path()
2343                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2344                 data_path = trf_to_data.transform_path_affine(na_path)
2345             else:
2346                 data_path = trf_to_data.transform_path(path)
2347         else:
2348             # For backwards compatibility we update the dataLim with the
2349             # coordinate range of the given path, even though the coordinate
2350             # systems are completely different. This may occur in situations
2351             # such as when ax.transAxes is passed through for absolute
2352             # positioning.
2353             data_path = path
2354 
2355         if not data_path.vertices.size:
2356             return
2357 
2358         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2359         if self.name != "rectilinear":
2360             # This block is mostly intended to handle axvline in polar plots,
2361             # for which updatey would otherwise be True.
2362             if updatex and line_trf == self.get_yaxis_transform():
2363                 updatex = False
2364             if updatey and line_trf == self.get_xaxis_transform():
2365                 updatey = False
2366         self.dataLim.update_from_path(data_path,
2367                                       self.ignore_existing_data_limits,
2368                                       updatex=updatex, updatey=updatey)
2369         self.ignore_existing_data_limits = False
2370 
2371     def add_patch(self, p):
2372         """
2373         Add a `.Patch` to the Axes; return the patch.
2374         """
2375         _api.check_isinstance(mpatches.Patch, p=p)
2376         self._set_artist_props(p)
2377         if p.get_clip_path() is None:
2378             p.set_clip_path(self.patch)
2379         self._update_patch_limits(p)
2380         self._children.append(p)
2381         p._remove_method = self._children.remove
2382         return p
2383 
2384     def _update_patch_limits(self, patch):
2385         """Update the data limits for the given patch."""
2386         # hist can add zero height Rectangles, which is useful to keep
2387         # the bins, counts and patches lined up, but it throws off log
2388         # scaling.  We'll ignore rects with zero height or width in
2389         # the auto-scaling
2390 
2391         # cannot check for '==0' since unitized data may not compare to zero
2392         # issue #2150 - we update the limits if patch has non zero width
2393         # or height.
2394         if (isinstance(patch, mpatches.Rectangle) and
2395                 ((not patch.get_width()) and (not patch.get_height()))):
2396             return
2397         p = patch.get_path()
2398         # Get all vertices on the path
2399         # Loop through each segment to get extrema for Bezier curve sections
2400         vertices = []
2401         for curve, code in p.iter_bezier(simplify=False):
2402             # Get distance along the curve of any extrema
2403             _, dzeros = curve.axis_aligned_extrema()
2404             # Calculate vertices of start, end and any extrema in between
2405             vertices.append(curve([0, *dzeros, 1]))
2406 
2407         if len(vertices):
2408             vertices = np.row_stack(vertices)
2409 
2410         patch_trf = patch.get_transform()
2411         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2412         if not (updatex or updatey):
2413             return
2414         if self.name != "rectilinear":
2415             # As in _update_line_limits, but for axvspan.
2416             if updatex and patch_trf == self.get_yaxis_transform():
2417                 updatex = False
2418             if updatey and patch_trf == self.get_xaxis_transform():
2419                 updatey = False
2420         trf_to_data = patch_trf - self.transData
2421         xys = trf_to_data.transform(vertices)
2422         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2423 
2424     def add_table(self, tab):
2425         """
2426         Add a `.Table` to the Axes; return the table.
2427         """
2428         _api.check_isinstance(mtable.Table, tab=tab)
2429         self._set_artist_props(tab)
2430         self._children.append(tab)
2431         tab.set_clip_path(self.patch)
2432         tab._remove_method = self._children.remove
2433         return tab
2434 
2435     def add_container(self, container):
2436         """
2437         Add a `.Container` to the Axes' containers; return the container.
2438         """
2439         label = container.get_label()
2440         if not label:
2441             container.set_label('_container%d' % len(self.containers))
2442         self.containers.append(container)
2443         container._remove_method = self.containers.remove
2444         return container
2445 
2446     def _unit_change_handler(self, axis_name, event=None):
2447         """
2448         Process axis units changes: requests updates to data and view limits.
2449         """
2450         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2451             return functools.partial(
2452                 self._unit_change_handler, axis_name, event=object())
2453         _api.check_in_list(self._axis_map, axis_name=axis_name)
2454         for line in self.lines:
2455             line.recache_always()
2456         self.relim()
2457         self._request_autoscale_view(axis_name)
2458 
2459     def relim(self, visible_only=False):
2460         """
2461         Recompute the data limits based on current artists.
2462 
2463         At present, `.Collection` instances are not supported.
2464 
2465         Parameters
2466         ----------
2467         visible_only : bool, default: False
2468             Whether to exclude invisible artists.
2469         """
2470         # Collections are deliberately not supported (yet); see
2471         # the TODO note in artists.py.
2472         self.dataLim.ignore(True)
2473         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2474         self.ignore_existing_data_limits = True
2475 
2476         for artist in self._children:
2477             if not visible_only or artist.get_visible():
2478                 if isinstance(artist, mlines.Line2D):
2479                     self._update_line_limits(artist)
2480                 elif isinstance(artist, mpatches.Patch):
2481                     self._update_patch_limits(artist)
2482                 elif isinstance(artist, mimage.AxesImage):
2483                     self._update_image_limits(artist)
2484 
2485     def update_datalim(self, xys, updatex=True, updatey=True):
2486         """
2487         Extend the `~.Axes.dataLim` Bbox to include the given points.
2488 
2489         If no data is set currently, the Bbox will ignore its limits and set
2490         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2491         compute the bounds of the union of its current data and the data in
2492         *xys*.
2493 
2494         Parameters
2495         ----------
2496         xys : 2D array-like
2497             The points to include in the data limits Bbox. This can be either
2498             a list of (x, y) tuples or a Nx2 array.
2499 
2500         updatex, updatey : bool, default: True
2501             Whether to update the x/y limits.
2502         """
2503         xys = np.asarray(xys)
2504         if not np.any(np.isfinite(xys)):
2505             return
2506         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2507                                          updatex=updatex, updatey=updatey)
2508         self.ignore_existing_data_limits = False
2509 
2510     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2511         """
2512         Set axis units based on *datasets* and *kwargs*, and optionally apply
2513         unit conversions to *datasets*.
2514 
2515         Parameters
2516         ----------
2517         datasets : list
2518             List of (axis_name, dataset) pairs (where the axis name is defined
2519             as in `._axis_map`).  Individual datasets can also be None
2520             (which gets passed through).
2521         kwargs : dict
2522             Other parameters from which unit info (i.e., the *xunits*,
2523             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2524             polar) entries) is popped, if present.  Note that this dict is
2525             mutated in-place!
2526         convert : bool, default: True
2527             Whether to return the original datasets or the converted ones.
2528 
2529         Returns
2530         -------
2531         list
2532             Either the original datasets if *convert* is False, or the
2533             converted ones if *convert* is True (the default).
2534         """
2535         # The API makes datasets a list of pairs rather than an axis_name to
2536         # dataset mapping because it is sometimes necessary to process multiple
2537         # datasets for a single axis, and concatenating them may be tricky
2538         # (e.g. if some are scalars, etc.).
2539         datasets = datasets or []
2540         kwargs = kwargs or {}
2541         axis_map = self._axis_map
2542         for axis_name, data in datasets:
2543             try:
2544                 axis = axis_map[axis_name]
2545             except KeyError:
2546                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2547             # Update from data if axis is already set but no unit is set yet.
2548             if (axis is not None and
2549                     data is not None and
2550                     not axis._have_units_and_converter()):
2551                 axis.update_units(data)
2552         for axis_name, axis in axis_map.items():
2553             # Return if no axis is set.
2554             if axis is None:
2555                 continue
2556             # Check for units in the kwargs, and if present update axis.
2557             units = kwargs.pop(f"{axis_name}units", axis.units)
2558             if self.name == "polar":
2559                 # Special case: polar supports "thetaunits"/"runits".
2560                 polar_units = {"x": "thetaunits", "y": "runits"}
2561                 units = kwargs.pop(polar_units[axis_name], units)
2562             if units != axis.units and units is not None:
2563                 axis.set_units(units)
2564                 # If the units being set imply a different converter,
2565                 # we need to update again.
2566                 for dataset_axis_name, data in datasets:
2567                     if dataset_axis_name == axis_name and data is not None:
2568                         axis.update_units(data)
2569         return [axis_map[axis_name].convert_units(data)
2570                 if convert and data is not None else data
2571                 for axis_name, data in datasets]
2572 
2573     def in_axes(self, mouseevent):
2574         """
2575         Return whether the given event (in display coords) is in the Axes.
2576         """
2577         return self.patch.contains(mouseevent)[0]
2578 
2579     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2580     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2581     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2582     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2583 
2584     def get_autoscale_on(self):
2585         """Return True if each axis is autoscaled, False otherwise."""
2586         return all(axis._get_autoscale_on()
2587                    for axis in self._axis_map.values())
2588 
2589     def set_autoscale_on(self, b):
2590         """
2591         Set whether autoscaling is applied to each axis on the next draw or
2592         call to `.Axes.autoscale_view`.
2593 
2594         Parameters
2595         ----------
2596         b : bool
2597         """
2598         for axis in self._axis_map.values():
2599             axis._set_autoscale_on(b)
2600 
2601     @property
2602     def use_sticky_edges(self):
2603         """
2604         When autoscaling, whether to obey all `Artist.sticky_edges`.
2605 
2606         Default is ``True``.
2607 
2608         Setting this to ``False`` ensures that the specified margins
2609         will be applied, even if the plot includes an image, for
2610         example, which would otherwise force a view limit to coincide
2611         with its data limit.
2612 
2613         The changing this property does not change the plot until
2614         `autoscale` or `autoscale_view` is called.
2615         """
2616         return self._use_sticky_edges
2617 
2618     @use_sticky_edges.setter
2619     def use_sticky_edges(self, b):
2620         self._use_sticky_edges = bool(b)
2621         # No effect until next autoscaling, which will mark the Axes as stale.
2622 
2623     def set_xmargin(self, m):
2624         """
2625         Set padding of X data limits prior to autoscaling.
2626 
2627         *m* times the data interval will be added to each end of that interval
2628         before it is used in autoscaling.  If *m* is negative, this will clip
2629         the data range instead of expanding it.
2630 
2631         For example, if your data is in the range [0, 2], a margin of 0.1 will
2632         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2633         of [0.2, 1.8].
2634 
2635         Parameters
2636         ----------
2637         m : float greater than -0.5
2638         """
2639         if m <= -0.5:
2640             raise ValueError("margin must be greater than -0.5")
2641         self._xmargin = m
2642         self._request_autoscale_view("x")
2643         self.stale = True
2644 
2645     def set_ymargin(self, m):
2646         """
2647         Set padding of Y data limits prior to autoscaling.
2648 
2649         *m* times the data interval will be added to each end of that interval
2650         before it is used in autoscaling.  If *m* is negative, this will clip
2651         the data range instead of expanding it.
2652 
2653         For example, if your data is in the range [0, 2], a margin of 0.1 will
2654         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2655         of [0.2, 1.8].
2656 
2657         Parameters
2658         ----------
2659         m : float greater than -0.5
2660         """
2661         if m <= -0.5:
2662             raise ValueError("margin must be greater than -0.5")
2663         self._ymargin = m
2664         self._request_autoscale_view("y")
2665         self.stale = True
2666 
2667     def margins(self, *margins, x=None, y=None, tight=True):
2668         """
2669         Set or retrieve autoscaling margins.
2670 
2671         The padding added to each limit of the Axes is the *margin*
2672         times the data interval. All input parameters must be floats
2673         within the range [0, 1]. Passing both positional and keyword
2674         arguments is invalid and will raise a TypeError. If no
2675         arguments (positional or otherwise) are provided, the current
2676         margins will remain in place and simply be returned.
2677 
2678         Specifying any margin changes only the autoscaling; for example,
2679         if *xmargin* is not None, then *xmargin* times the X data
2680         interval will be added to each end of that interval before
2681         it is used in autoscaling.
2682 
2683         Parameters
2684         ----------
2685         *margins : float, optional
2686             If a single positional argument is provided, it specifies
2687             both margins of the x-axis and y-axis limits. If two
2688             positional arguments are provided, they will be interpreted
2689             as *xmargin*, *ymargin*. If setting the margin on a single
2690             axis is desired, use the keyword arguments described below.
2691 
2692         x, y : float, optional
2693             Specific margin values for the x-axis and y-axis,
2694             respectively. These cannot be used with positional
2695             arguments, but can be used individually to alter on e.g.,
2696             only the y-axis.
2697 
2698         tight : bool or None, default: True
2699             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2700             which is executed after a margin is changed; the default
2701             here is *True*, on the assumption that when margins are
2702             specified, no additional padding to match tick marks is
2703             usually desired.  Setting *tight* to *None* preserves
2704             the previous setting.
2705 
2706         Returns
2707         -------
2708         xmargin, ymargin : float
2709 
2710         Notes
2711         -----
2712         If a previously used Axes method such as :meth:`pcolor` has set
2713         :attr:`use_sticky_edges` to `True`, only the limits not set by
2714         the "sticky artists" will be modified. To force all of the
2715         margins to be set, set :attr:`use_sticky_edges` to `False`
2716         before calling :meth:`margins`.
2717         """
2718 
2719         if margins and (x is not None or y is not None):
2720             raise TypeError('Cannot pass both positional and keyword '
2721                             'arguments for x and/or y.')
2722         elif len(margins) == 1:
2723             x = y = margins[0]
2724         elif len(margins) == 2:
2725             x, y = margins
2726         elif margins:
2727             raise TypeError('Must pass a single positional argument for all '
2728                             'margins, or one for each margin (x, y).')
2729 
2730         if x is None and y is None:
2731             if tight is not True:
2732                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2733             return self._xmargin, self._ymargin
2734 
2735         if tight is not None:
2736             self._tight = tight
2737         if x is not None:
2738             self.set_xmargin(x)
2739         if y is not None:
2740             self.set_ymargin(y)
2741 
2742     def set_rasterization_zorder(self, z):
2743         """
2744         Set the zorder threshold for rasterization for vector graphics output.
2745 
2746         All artists with a zorder below the given value will be rasterized if
2747         they support rasterization.
2748 
2749         This setting is ignored for pixel-based output.
2750 
2751         See also :doc:`/gallery/misc/rasterization_demo`.
2752 
2753         Parameters
2754         ----------
2755         z : float or None
2756             The zorder below which artists are rasterized.
2757             If ``None`` rasterization based on zorder is deactivated.
2758         """
2759         self._rasterization_zorder = z
2760         self.stale = True
2761 
2762     def get_rasterization_zorder(self):
2763         """Return the zorder value below which artists will be rasterized."""
2764         return self._rasterization_zorder
2765 
2766     def autoscale(self, enable=True, axis='both', tight=None):
2767         """
2768         Autoscale the axis view to the data (toggle).
2769 
2770         Convenience method for simple axis view autoscaling.
2771         It turns autoscaling on or off, and then,
2772         if autoscaling for either axis is on, it performs
2773         the autoscaling on the specified axis or Axes.
2774 
2775         Parameters
2776         ----------
2777         enable : bool or None, default: True
2778             True turns autoscaling on, False turns it off.
2779             None leaves the autoscaling state unchanged.
2780         axis : {'both', 'x', 'y'}, default: 'both'
2781             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2782             to 'z', and 'both' refers to all three axes.)
2783         tight : bool or None, default: None
2784             If True, first set the margins to zero.  Then, this argument is
2785             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2786             its value); see the description of its behavior there.
2787         """
2788         if enable is None:
2789             scalex = True
2790             scaley = True
2791         else:
2792             if axis in ['x', 'both']:
2793                 self.set_autoscalex_on(bool(enable))
2794                 scalex = self.get_autoscalex_on()
2795             else:
2796                 scalex = False
2797             if axis in ['y', 'both']:
2798                 self.set_autoscaley_on(bool(enable))
2799                 scaley = self.get_autoscaley_on()
2800             else:
2801                 scaley = False
2802         if tight and scalex:
2803             self._xmargin = 0
2804         if tight and scaley:
2805             self._ymargin = 0
2806         if scalex:
2807             self._request_autoscale_view("x", tight=tight)
2808         if scaley:
2809             self._request_autoscale_view("y", tight=tight)
2810 
2811     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2812         """
2813         Autoscale the view limits using the data limits.
2814 
2815         Parameters
2816         ----------
2817         tight : bool or None
2818             If *True*, only expand the axis limits using the margins.  Note
2819             that unlike for `autoscale`, ``tight=True`` does *not* set the
2820             margins to zero.
2821 
2822             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2823             after expansion by the margins, further expand the axis limits
2824             using the axis major locator.
2825 
2826             If None (the default), reuse the value set in the previous call to
2827             `autoscale_view` (the initial value is False, but the default style
2828             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2829             behaves like True).
2830 
2831         scalex : bool, default: True
2832             Whether to autoscale the x-axis.
2833 
2834         scaley : bool, default: True
2835             Whether to autoscale the y-axis.
2836 
2837         Notes
2838         -----
2839         The autoscaling preserves any preexisting axis direction reversal.
2840 
2841         The data limits are not updated automatically when artist data are
2842         changed after the artist has been added to an Axes instance.  In that
2843         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2844         autoscale_view.
2845 
2846         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2847         not be changed by autoscale_view().
2848         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2849         """
2850         if tight is not None:
2851             self._tight = bool(tight)
2852 
2853         x_stickies = y_stickies = np.array([])
2854         if self.use_sticky_edges:
2855             if self._xmargin and scalex and self.get_autoscalex_on():
2856                 x_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.x
2858                     for ax in self._shared_axes["x"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860             if self._ymargin and scaley and self.get_autoscaley_on():
2861                 y_stickies = np.sort(np.concatenate([
2862                     artist.sticky_edges.y
2863                     for ax in self._shared_axes["y"].get_siblings(self)
2864                     for artist in ax.get_children()]))
2865         if self.get_xscale() == 'log':
2866             x_stickies = x_stickies[x_stickies > 0]
2867         if self.get_yscale() == 'log':
2868             y_stickies = y_stickies[y_stickies > 0]
2869 
2870         def handle_single_axis(
2871                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2872 
2873             if not (scale and axis._get_autoscale_on()):
2874                 return  # nothing to do...
2875 
2876             shared = shared_axes.get_siblings(self)
2877             # Base autoscaling on finite data limits when there is at least one
2878             # finite data limit among all the shared_axes and intervals.
2879             values = [val for ax in shared
2880                       for val in getattr(ax.dataLim, f"interval{name}")
2881                       if np.isfinite(val)]
2882             if values:
2883                 x0, x1 = (min(values), max(values))
2884             elif getattr(self._viewLim, f"mutated{name}")():
2885                 # No data, but explicit viewLims already set:
2886                 # in mutatedx or mutatedy.
2887                 return
2888             else:
2889                 x0, x1 = (-np.inf, np.inf)
2890             # If x0 and x1 are nonfinite, get default limits from the locator.
2891             locator = axis.get_major_locator()
2892             x0, x1 = locator.nonsingular(x0, x1)
2893             # Find the minimum minpos for use in the margin calculation.
2894             minimum_minpos = min(
2895                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2896 
2897             # Prevent margin addition from crossing a sticky value.  A small
2898             # tolerance must be added due to floating point issues with
2899             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2900             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2901             # datasets where all values are tiny (less than 1e-8).
2902             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2903             # Index of largest element < x0 + tol, if any.
2904             i0 = stickies.searchsorted(x0 + tol) - 1
2905             x0bound = stickies[i0] if i0 != -1 else None
2906             # Index of smallest element > x1 - tol, if any.
2907             i1 = stickies.searchsorted(x1 - tol)
2908             x1bound = stickies[i1] if i1 != len(stickies) else None
2909 
2910             # Add the margin in figure space and then transform back, to handle
2911             # non-linear scales.
2912             transform = axis.get_transform()
2913             inverse_trans = transform.inverted()
2914             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2915             x0t, x1t = transform.transform([x0, x1])
2916             delta = (x1t - x0t) * margin
2917             if not np.isfinite(delta):
2918                 delta = 0  # If a bound isn't finite, set margin to zero.
2919             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2920 
2921             # Apply sticky bounds.
2922             if x0bound is not None:
2923                 x0 = max(x0, x0bound)
2924             if x1bound is not None:
2925                 x1 = min(x1, x1bound)
2926 
2927             if not self._tight:
2928                 x0, x1 = locator.view_limits(x0, x1)
2929             set_bound(x0, x1)
2930             # End of definition of internal function 'handle_single_axis'.
2931 
2932         handle_single_axis(
2933             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2934             x_stickies, self.set_xbound)
2935         handle_single_axis(
2936             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2937             y_stickies, self.set_ybound)
2938 
2939     def _update_title_position(self, renderer):
2940         """
2941         Update the title position based on the bounding box enclosing
2942         all the ticklabels and x-axis spine and xlabel...
2943         """
2944         if self._autotitlepos is not None and not self._autotitlepos:
2945             _log.debug('title position was updated manually, not adjusting')
2946             return
2947 
2948         titles = (self.title, self._left_title, self._right_title)
2949 
2950         # Need to check all our twins too, and all the children as well.
2951         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2952         for ax in self.child_axes:  # Child positions must be updated first.
2953             locator = ax.get_axes_locator()
2954             ax.apply_aspect(locator(self, renderer) if locator else None)
2955 
2956         for title in titles:
2957             x, _ = title.get_position()
2958             # need to start again in case of window resizing
2959             title.set_position((x, 1.0))
2960             top = -np.inf
2961             for ax in axs:
2962                 bb = None
2963                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2964                         or ax.xaxis.get_label_position() == 'top'):
2965                     bb = ax.xaxis.get_tightbbox(renderer)
2966                 if bb is None:
2967                     if 'outline' in ax.spines:
2968                         # Special case for colorbars:
2969                         bb = ax.spines['outline'].get_window_extent()
2970                     else:
2971                         bb = ax.get_window_extent(renderer)
2972                 top = max(top, bb.ymax)
2973                 if title.get_text():
2974                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2975                     if ax.yaxis.offsetText.get_text():
2976                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2977                         if bb.intersection(title.get_tightbbox(renderer), bb):
2978                             top = bb.ymax
2979             if top < 0:
2980                 # the top of Axes is not even on the figure, so don't try and
2981                 # automatically place it.
2982                 _log.debug('top of Axes not in the figure, so title not moved')
2983                 return
2984             if title.get_window_extent(renderer).ymin < top:
2985                 _, y = self.transAxes.inverted().transform((0, top))
2986                 title.set_position((x, y))
2987                 # empirically, this doesn't always get the min to top,
2988                 # so we need to adjust again.
2989                 if title.get_window_extent(renderer).ymin < top:
2990                     _, y = self.transAxes.inverted().transform(
2991                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2992                     title.set_position((x, y))
2993 
2994         ymax = max(title.get_position()[1] for title in titles)
2995         for title in titles:
2996             # now line up all the titles at the highest baseline.
2997             x, _ = title.get_position()
2998             title.set_position((x, ymax))
2999 
3000     # Drawing
3001     @martist.allow_rasterization
3002     def draw(self, renderer):
3003         # docstring inherited
3004         if renderer is None:
3005             raise RuntimeError('No renderer defined')
3006         if not self.get_visible():
3007             return
3008         self._unstale_viewLim()
3009 
3010         renderer.open_group('axes', gid=self.get_gid())
3011 
3012         # prevent triggering call backs during the draw process
3013         self._stale = True
3014 
3015         # loop over self and child Axes...
3016         locator = self.get_axes_locator()
3017         self.apply_aspect(locator(self, renderer) if locator else None)
3018 
3019         artists = self.get_children()
3020         artists.remove(self.patch)
3021 
3022         # the frame draws the edges around the Axes patch -- we
3023         # decouple these so the patch can be in the background and the
3024         # frame in the foreground. Do this before drawing the axis
3025         # objects so that the spine has the opportunity to update them.
3026         if not (self.axison and self._frameon):
3027             for spine in self.spines.values():
3028                 artists.remove(spine)
3029 
3030         self._update_title_position(renderer)
3031 
3032         if not self.axison:
3033             for _axis in self._axis_map.values():
3034                 artists.remove(_axis)
3035 
3036         if not self.figure.canvas.is_saving():
3037             artists = [
3038                 a for a in artists
3039                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3040         artists = sorted(artists, key=attrgetter('zorder'))
3041 
3042         # rasterize artists with negative zorder
3043         # if the minimum zorder is negative, start rasterization
3044         rasterization_zorder = self._rasterization_zorder
3045 
3046         if (rasterization_zorder is not None and
3047                 artists and artists[0].zorder < rasterization_zorder):
3048             split_index = np.searchsorted(
3049                 [art.zorder for art in artists],
3050                 rasterization_zorder, side='right'
3051             )
3052             artists_rasterized = artists[:split_index]
3053             artists = artists[split_index:]
3054         else:
3055             artists_rasterized = []
3056 
3057         if self.axison and self._frameon:
3058             if artists_rasterized:
3059                 artists_rasterized = [self.patch] + artists_rasterized
3060             else:
3061                 artists = [self.patch] + artists
3062 
3063         if artists_rasterized:
3064             _draw_rasterized(self.figure, artists_rasterized, renderer)
3065 
3066         mimage._draw_list_compositing_images(
3067             renderer, self, artists, self.figure.suppressComposite)
3068 
3069         renderer.close_group('axes')
3070         self.stale = False
3071 
3072     def draw_artist(self, a):
3073         """
3074         Efficiently redraw a single artist.
3075         """
3076         a.draw(self.figure.canvas.get_renderer())
3077 
3078     def redraw_in_frame(self):
3079         """
3080         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3081         """
3082         with ExitStack() as stack:
3083             for artist in [*self._axis_map.values(),
3084                            self.title, self._left_title, self._right_title]:
3085                 stack.enter_context(artist._cm_set(visible=False))
3086             self.draw(self.figure.canvas.get_renderer())
3087 
3088     @_api.deprecated("3.6", alternative="Axes.figure.canvas.get_renderer()")
3089     def get_renderer_cache(self):
3090         return self.figure.canvas.get_renderer()
3091 
3092     # Axes rectangle characteristics
3093 
3094     def get_frame_on(self):
3095         """Get whether the Axes rectangle patch is drawn."""
3096         return self._frameon
3097 
3098     def set_frame_on(self, b):
3099         """
3100         Set whether the Axes rectangle patch is drawn.
3101 
3102         Parameters
3103         ----------
3104         b : bool
3105         """
3106         self._frameon = b
3107         self.stale = True
3108 
3109     def get_axisbelow(self):
3110         """
3111         Get whether axis ticks and gridlines are above or below most artists.
3112 
3113         Returns
3114         -------
3115         bool or 'line'
3116 
3117         See Also
3118         --------
3119         set_axisbelow
3120         """
3121         return self._axisbelow
3122 
3123     def set_axisbelow(self, b):
3124         """
3125         Set whether axis ticks and gridlines are above or below most artists.
3126 
3127         This controls the zorder of the ticks and gridlines. For more
3128         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3129 
3130         Parameters
3131         ----------
3132         b : bool or 'line'
3133             Possible values:
3134 
3135             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3136             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3137               (e.g. rectangles, with default zorder = 1) but still below lines
3138               and markers (with their default zorder = 2).
3139             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3140               and lines / markers.
3141 
3142         See Also
3143         --------
3144         get_axisbelow
3145         """
3146         # Check that b is True, False or 'line'
3147         self._axisbelow = axisbelow = validate_axisbelow(b)
3148         zorder = {
3149             True: 0.5,
3150             'line': 1.5,
3151             False: 2.5,
3152         }[axisbelow]
3153         for axis in self._axis_map.values():
3154             axis.set_zorder(zorder)
3155         self.stale = True
3156 
3157     @_docstring.dedent_interpd
3158     def grid(self, visible=None, which='major', axis='both', **kwargs):
3159         """
3160         Configure the grid lines.
3161 
3162         Parameters
3163         ----------
3164         visible : bool or None, optional
3165             Whether to show the grid lines.  If any *kwargs* are supplied, it
3166             is assumed you want the grid on and *visible* will be set to True.
3167 
3168             If *visible* is *None* and there are no *kwargs*, this toggles the
3169             visibility of the lines.
3170 
3171         which : {'major', 'minor', 'both'}, optional
3172             The grid lines to apply the changes on.
3173 
3174         axis : {'both', 'x', 'y'}, optional
3175             The axis to apply the changes on.
3176 
3177         **kwargs : `.Line2D` properties
3178             Define the line properties of the grid, e.g.::
3179 
3180                 grid(color='r', linestyle='-', linewidth=2)
3181 
3182             Valid keyword arguments are:
3183 
3184             %(Line2D:kwdoc)s
3185 
3186         Notes
3187         -----
3188         The axis is drawn as a unit, so the effective zorder for drawing the
3189         grid is determined by the zorder of each axis, not by the zorder of the
3190         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3191         use `.set_axisbelow` or, for more control, call the
3192         `~.Artist.set_zorder` method of each axis.
3193         """
3194         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3195         if axis in ['x', 'both']:
3196             self.xaxis.grid(visible, which=which, **kwargs)
3197         if axis in ['y', 'both']:
3198             self.yaxis.grid(visible, which=which, **kwargs)
3199 
3200     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3201                          useOffset=None, useLocale=None, useMathText=None):
3202         r"""
3203         Configure the `.ScalarFormatter` used by default for linear Axes.
3204 
3205         If a parameter is not set, the corresponding property of the formatter
3206         is left unchanged.
3207 
3208         Parameters
3209         ----------
3210         axis : {'x', 'y', 'both'}, default: 'both'
3211             The axis to configure.  Only major ticks are affected.
3212 
3213         style : {'sci', 'scientific', 'plain'}
3214             Whether to use scientific notation.
3215             The formatter default is to use scientific notation.
3216 
3217         scilimits : pair of ints (m, n)
3218             Scientific notation is used only for numbers outside the range
3219             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3220             configured to use scientific notation at all).  Use (0, 0) to
3221             include all numbers.  Use (m, m) where m != 0 to fix the order of
3222             magnitude to 10\ :sup:`m`.
3223             The formatter default is :rc:`axes.formatter.limits`.
3224 
3225         useOffset : bool or float
3226             If True, the offset is calculated as needed.
3227             If False, no offset is used.
3228             If a numeric value, it sets the offset.
3229             The formatter default is :rc:`axes.formatter.useoffset`.
3230 
3231         useLocale : bool
3232             Whether to format the number using the current locale or using the
3233             C (English) locale.  This affects e.g. the decimal separator.  The
3234             formatter default is :rc:`axes.formatter.use_locale`.
3235 
3236         useMathText : bool
3237             Render the offset and scientific notation in mathtext.
3238             The formatter default is :rc:`axes.formatter.use_mathtext`.
3239 
3240         Raises
3241         ------
3242         AttributeError
3243             If the current formatter is not a `.ScalarFormatter`.
3244         """
3245         style = style.lower()
3246         axis = axis.lower()
3247         if scilimits is not None:
3248             try:
3249                 m, n = scilimits
3250                 m + n + 1  # check that both are numbers
3251             except (ValueError, TypeError) as err:
3252                 raise ValueError("scilimits must be a sequence of 2 integers"
3253                                  ) from err
3254         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3255         is_sci_style = _api.check_getitem(STYLES, style=style)
3256         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3257                     'both': list(self._axis_map.values())}
3258         axises = _api.check_getitem(axis_map, axis=axis)
3259         try:
3260             for axis in axises:
3261                 if is_sci_style is not None:
3262                     axis.major.formatter.set_scientific(is_sci_style)
3263                 if scilimits is not None:
3264                     axis.major.formatter.set_powerlimits(scilimits)
3265                 if useOffset is not None:
3266                     axis.major.formatter.set_useOffset(useOffset)
3267                 if useLocale is not None:
3268                     axis.major.formatter.set_useLocale(useLocale)
3269                 if useMathText is not None:
3270                     axis.major.formatter.set_useMathText(useMathText)
3271         except AttributeError as err:
3272             raise AttributeError(
3273                 "This method only works with the ScalarFormatter") from err
3274 
3275     def locator_params(self, axis='both', tight=None, **kwargs):
3276         """
3277         Control behavior of major tick locators.
3278 
3279         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3280         is called automatically after the parameters are changed.
3281 
3282         Parameters
3283         ----------
3284         axis : {'both', 'x', 'y'}, default: 'both'
3285             The axis on which to operate.  (For 3D Axes, *axis* can also be
3286             set to 'z', and 'both' refers to all three axes.)
3287         tight : bool or None, optional
3288             Parameter passed to `~.Axes.autoscale_view`.
3289             Default is None, for no change.
3290 
3291         Other Parameters
3292         ----------------
3293         **kwargs
3294             Remaining keyword arguments are passed to directly to the
3295             ``set_params()`` method of the locator. Supported keywords depend
3296             on the type of the locator. See for example
3297             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3298             used by default for linear.
3299 
3300         Examples
3301         --------
3302         When plotting small subplots, one might want to reduce the maximum
3303         number of ticks and use tight bounds, for example::
3304 
3305             ax.locator_params(tight=True, nbins=4)
3306 
3307         """
3308         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3309         for name in self._axis_names:
3310             if axis in [name, "both"]:
3311                 loc = self._axis_map[name].get_major_locator()
3312                 loc.set_params(**kwargs)
3313                 self._request_autoscale_view(name, tight=tight)
3314         self.stale = True
3315 
3316     def tick_params(self, axis='both', **kwargs):
3317         """
3318         Change the appearance of ticks, tick labels, and gridlines.
3319 
3320         Tick properties that are not explicitly set using the keyword
3321         arguments remain unchanged unless *reset* is True. For the current
3322         style settings, see `.Axis.get_tick_params`.
3323 
3324         Parameters
3325         ----------
3326         axis : {'x', 'y', 'both'}, default: 'both'
3327             The axis to which the parameters are applied.
3328         which : {'major', 'minor', 'both'}, default: 'major'
3329             The group of ticks to which the parameters are applied.
3330         reset : bool, default: False
3331             Whether to reset the ticks to defaults before updating them.
3332 
3333         Other Parameters
3334         ----------------
3335         direction : {'in', 'out', 'inout'}
3336             Puts ticks inside the Axes, outside the Axes, or both.
3337         length : float
3338             Tick length in points.
3339         width : float
3340             Tick width in points.
3341         color : color
3342             Tick color.
3343         pad : float
3344             Distance in points between tick and label.
3345         labelsize : float or str
3346             Tick label font size in points or as a string (e.g., 'large').
3347         labelcolor : color
3348             Tick label color.
3349         colors : color
3350             Tick color and label color.
3351         zorder : float
3352             Tick and label zorder.
3353         bottom, top, left, right : bool
3354             Whether to draw the respective ticks.
3355         labelbottom, labeltop, labelleft, labelright : bool
3356             Whether to draw the respective tick labels.
3357         labelrotation : float
3358             Tick label rotation
3359         grid_color : color
3360             Gridline color.
3361         grid_alpha : float
3362             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3363         grid_linewidth : float
3364             Width of gridlines in points.
3365         grid_linestyle : str
3366             Any valid `.Line2D` line style spec.
3367 
3368         Examples
3369         --------
3370         ::
3371 
3372             ax.tick_params(direction='out', length=6, width=2, colors='r',
3373                            grid_color='r', grid_alpha=0.5)
3374 
3375         This will make all major ticks be red, pointing out of the box,
3376         and with dimensions 6 points by 2 points.  Tick labels will
3377         also be red.  Gridlines will be red and translucent.
3378 
3379         """
3380         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3381         if axis in ['x', 'both']:
3382             xkw = dict(kwargs)
3383             xkw.pop('left', None)
3384             xkw.pop('right', None)
3385             xkw.pop('labelleft', None)
3386             xkw.pop('labelright', None)
3387             self.xaxis.set_tick_params(**xkw)
3388         if axis in ['y', 'both']:
3389             ykw = dict(kwargs)
3390             ykw.pop('top', None)
3391             ykw.pop('bottom', None)
3392             ykw.pop('labeltop', None)
3393             ykw.pop('labelbottom', None)
3394             self.yaxis.set_tick_params(**ykw)
3395 
3396     def set_axis_off(self):
3397         """
3398         Turn the x- and y-axis off.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = False
3403         self.stale = True
3404 
3405     def set_axis_on(self):
3406         """
3407         Turn the x- and y-axis on.
3408 
3409         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3410         """
3411         self.axison = True
3412         self.stale = True
3413 
3414     # data limits, ticks, tick labels, and formatting
3415 
3416     def get_xlabel(self):
3417         """
3418         Get the xlabel text string.
3419         """
3420         label = self.xaxis.get_label()
3421         return label.get_text()
3422 
3423     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3424                    loc=None, **kwargs):
3425         """
3426         Set the label for the x-axis.
3427 
3428         Parameters
3429         ----------
3430         xlabel : str
3431             The label text.
3432 
3433         labelpad : float, default: :rc:`axes.labelpad`
3434             Spacing in points from the Axes bounding box including ticks
3435             and tick labels.  If None, the previous value is left as is.
3436 
3437         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3438             The label position. This is a high-level alternative for passing
3439             parameters *x* and *horizontalalignment*.
3440 
3441         Other Parameters
3442         ----------------
3443         **kwargs : `.Text` properties
3444             `.Text` properties control the appearance of the label.
3445 
3446         See Also
3447         --------
3448         text : Documents the properties supported by `.Text`.
3449         """
3450         if labelpad is not None:
3451             self.xaxis.labelpad = labelpad
3452         protected_kw = ['x', 'horizontalalignment', 'ha']
3453         if {*kwargs} & {*protected_kw}:
3454             if loc is not None:
3455                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3456                                 f"its corresponding low level keyword "
3457                                 f"arguments ({protected_kw}) are also "
3458                                 f"supplied")
3459 
3460         else:
3461             loc = (loc if loc is not None
3462                    else mpl.rcParams['xaxis.labellocation'])
3463             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3464 
3465             x = {
3466                 'left': 0,
3467                 'center': 0.5,
3468                 'right': 1,
3469             }[loc]
3470             kwargs.update(x=x, horizontalalignment=loc)
3471 
3472         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3473 
3474     def invert_xaxis(self):
3475         """
3476         Invert the x-axis.
3477 
3478         See Also
3479         --------
3480         xaxis_inverted
3481         get_xlim, set_xlim
3482         get_xbound, set_xbound
3483         """
3484         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3485 
3486     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3487 
3488     def get_xbound(self):
3489         """
3490         Return the lower and upper x-axis bounds, in increasing order.
3491 
3492         See Also
3493         --------
3494         set_xbound
3495         get_xlim, set_xlim
3496         invert_xaxis, xaxis_inverted
3497         """
3498         left, right = self.get_xlim()
3499         if left < right:
3500             return left, right
3501         else:
3502             return right, left
3503 
3504     def set_xbound(self, lower=None, upper=None):
3505         """
3506         Set the lower and upper numerical bounds of the x-axis.
3507 
3508         This method will honor axis inversion regardless of parameter order.
3509         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3510 
3511         Parameters
3512         ----------
3513         lower, upper : float or None
3514             The lower and upper bounds. If *None*, the respective axis bound
3515             is not modified.
3516 
3517         See Also
3518         --------
3519         get_xbound
3520         get_xlim, set_xlim
3521         invert_xaxis, xaxis_inverted
3522         """
3523         if upper is None and np.iterable(lower):
3524             lower, upper = lower
3525 
3526         old_lower, old_upper = self.get_xbound()
3527         if lower is None:
3528             lower = old_lower
3529         if upper is None:
3530             upper = old_upper
3531 
3532         self.set_xlim(sorted((lower, upper),
3533                              reverse=bool(self.xaxis_inverted())),
3534                       auto=None)
3535 
3536     def get_xlim(self):
3537         """
3538         Return the x-axis view limits.
3539 
3540         Returns
3541         -------
3542         left, right : (float, float)
3543             The current x-axis limits in data coordinates.
3544 
3545         See Also
3546         --------
3547         .Axes.set_xlim
3548         set_xbound, get_xbound
3549         invert_xaxis, xaxis_inverted
3550 
3551         Notes
3552         -----
3553         The x-axis may be inverted, in which case the *left* value will
3554         be greater than the *right* value.
3555         """
3556         return tuple(self.viewLim.intervalx)
3557 
3558     def _validate_converted_limits(self, limit, convert):
3559         """
3560         Raise ValueError if converted limits are non-finite.
3561 
3562         Note that this function also accepts None as a limit argument.
3563 
3564         Returns
3565         -------
3566         The limit value after call to convert(), or None if limit is None.
3567         """
3568         if limit is not None:
3569             converted_limit = convert(limit)
3570             if (isinstance(converted_limit, Real)
3571                     and not np.isfinite(converted_limit)):
3572                 raise ValueError("Axis limits cannot be NaN or Inf")
3573             return converted_limit
3574 
3575     @_api.make_keyword_only("3.6", "emit")
3576     def set_xlim(self, left=None, right=None, emit=True, auto=False,
3577                  *, xmin=None, xmax=None):
3578         """
3579         Set the x-axis view limits.
3580 
3581         Parameters
3582         ----------
3583         left : float, optional
3584             The left xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587             The left and right xlims may also be passed as the tuple
3588             (*left*, *right*) as the first positional argument (or as
3589             the *left* keyword argument).
3590 
3591             .. ACCEPTS: (bottom: float, top: float)
3592 
3593         right : float, optional
3594             The right xlim in data coordinates. Passing *None* leaves the
3595             limit unchanged.
3596 
3597         emit : bool, default: True
3598             Whether to notify observers of limit change.
3599 
3600         auto : bool or None, default: False
3601             Whether to turn on autoscaling of the x-axis. True turns on,
3602             False turns off, None leaves unchanged.
3603 
3604         xmin, xmax : float, optional
3605             They are equivalent to left and right respectively, and it is an
3606             error to pass both *xmin* and *left* or *xmax* and *right*.
3607 
3608         Returns
3609         -------
3610         left, right : (float, float)
3611             The new x-axis limits in data coordinates.
3612 
3613         See Also
3614         --------
3615         get_xlim
3616         set_xbound, get_xbound
3617         invert_xaxis, xaxis_inverted
3618 
3619         Notes
3620         -----
3621         The *left* value may be greater than the *right* value, in which
3622         case the x-axis values will decrease from left to right.
3623 
3624         Examples
3625         --------
3626         >>> set_xlim(left, right)
3627         >>> set_xlim((left, right))
3628         >>> left, right = set_xlim(left, right)
3629 
3630         One limit may be left unchanged.
3631 
3632         >>> set_xlim(right=right_lim)
3633 
3634         Limits may be passed in reverse order to flip the direction of
3635         the x-axis. For example, suppose *x* represents the number of
3636         years before present. The x-axis limits might be set like the
3637         following so 5000 years ago is on the left of the plot and the
3638         present is on the right.
3639 
3640         >>> set_xlim(5000, 0)
3641         """
3642         if right is None and np.iterable(left):
3643             left, right = left
3644         if xmin is not None:
3645             if left is not None:
3646                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3647             left = xmin
3648         if xmax is not None:
3649             if right is not None:
3650                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3651             right = xmax
3652         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3653 
3654     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3655     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3656     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3657     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3658     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3659     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3660     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3661     set_xticklabels = _axis_method_wrapper(
3662         "xaxis", "set_ticklabels",
3663         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3664 
3665     def get_ylabel(self):
3666         """
3667         Get the ylabel text string.
3668         """
3669         label = self.yaxis.get_label()
3670         return label.get_text()
3671 
3672     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3673                    loc=None, **kwargs):
3674         """
3675         Set the label for the y-axis.
3676 
3677         Parameters
3678         ----------
3679         ylabel : str
3680             The label text.
3681 
3682         labelpad : float, default: :rc:`axes.labelpad`
3683             Spacing in points from the Axes bounding box including ticks
3684             and tick labels.  If None, the previous value is left as is.
3685 
3686         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3687             The label position. This is a high-level alternative for passing
3688             parameters *y* and *horizontalalignment*.
3689 
3690         Other Parameters
3691         ----------------
3692         **kwargs : `.Text` properties
3693             `.Text` properties control the appearance of the label.
3694 
3695         See Also
3696         --------
3697         text : Documents the properties supported by `.Text`.
3698         """
3699         if labelpad is not None:
3700             self.yaxis.labelpad = labelpad
3701         protected_kw = ['y', 'horizontalalignment', 'ha']
3702         if {*kwargs} & {*protected_kw}:
3703             if loc is not None:
3704                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3705                                 f"its corresponding low level keyword "
3706                                 f"arguments ({protected_kw}) are also "
3707                                 f"supplied")
3708 
3709         else:
3710             loc = (loc if loc is not None
3711                    else mpl.rcParams['yaxis.labellocation'])
3712             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3713 
3714             y, ha = {
3715                 'bottom': (0, 'left'),
3716                 'center': (0.5, 'center'),
3717                 'top': (1, 'right')
3718             }[loc]
3719             kwargs.update(y=y, horizontalalignment=ha)
3720 
3721         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3722 
3723     def invert_yaxis(self):
3724         """
3725         Invert the y-axis.
3726 
3727         See Also
3728         --------
3729         yaxis_inverted
3730         get_ylim, set_ylim
3731         get_ybound, set_ybound
3732         """
3733         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3734 
3735     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3736 
3737     def get_ybound(self):
3738         """
3739         Return the lower and upper y-axis bounds, in increasing order.
3740 
3741         See Also
3742         --------
3743         set_ybound
3744         get_ylim, set_ylim
3745         invert_yaxis, yaxis_inverted
3746         """
3747         bottom, top = self.get_ylim()
3748         if bottom < top:
3749             return bottom, top
3750         else:
3751             return top, bottom
3752 
3753     def set_ybound(self, lower=None, upper=None):
3754         """
3755         Set the lower and upper numerical bounds of the y-axis.
3756 
3757         This method will honor axis inversion regardless of parameter order.
3758         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3759 
3760         Parameters
3761         ----------
3762         lower, upper : float or None
3763             The lower and upper bounds. If *None*, the respective axis bound
3764             is not modified.
3765 
3766         See Also
3767         --------
3768         get_ybound
3769         get_ylim, set_ylim
3770         invert_yaxis, yaxis_inverted
3771         """
3772         if upper is None and np.iterable(lower):
3773             lower, upper = lower
3774 
3775         old_lower, old_upper = self.get_ybound()
3776         if lower is None:
3777             lower = old_lower
3778         if upper is None:
3779             upper = old_upper
3780 
3781         self.set_ylim(sorted((lower, upper),
3782                              reverse=bool(self.yaxis_inverted())),
3783                       auto=None)
3784 
3785     def get_ylim(self):
3786         """
3787         Return the y-axis view limits.
3788 
3789         Returns
3790         -------
3791         bottom, top : (float, float)
3792             The current y-axis limits in data coordinates.
3793 
3794         See Also
3795         --------
3796         .Axes.set_ylim
3797         set_ybound, get_ybound
3798         invert_yaxis, yaxis_inverted
3799 
3800         Notes
3801         -----
3802         The y-axis may be inverted, in which case the *bottom* value
3803         will be greater than the *top* value.
3804         """
3805         return tuple(self.viewLim.intervaly)
3806 
3807     @_api.make_keyword_only("3.6", "emit")
3808     def set_ylim(self, bottom=None, top=None, emit=True, auto=False,
3809                  *, ymin=None, ymax=None):
3810         """
3811         Set the y-axis view limits.
3812 
3813         Parameters
3814         ----------
3815         bottom : float, optional
3816             The bottom ylim in data coordinates. Passing *None* leaves the
3817             limit unchanged.
3818 
3819             The bottom and top ylims may also be passed as the tuple
3820             (*bottom*, *top*) as the first positional argument (or as
3821             the *bottom* keyword argument).
3822 
3823             .. ACCEPTS: (bottom: float, top: float)
3824 
3825         top : float, optional
3826             The top ylim in data coordinates. Passing *None* leaves the
3827             limit unchanged.
3828 
3829         emit : bool, default: True
3830             Whether to notify observers of limit change.
3831 
3832         auto : bool or None, default: False
3833             Whether to turn on autoscaling of the y-axis. *True* turns on,
3834             *False* turns off, *None* leaves unchanged.
3835 
3836         ymin, ymax : float, optional
3837             They are equivalent to bottom and top respectively, and it is an
3838             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3839 
3840         Returns
3841         -------
3842         bottom, top : (float, float)
3843             The new y-axis limits in data coordinates.
3844 
3845         See Also
3846         --------
3847         get_ylim
3848         set_ybound, get_ybound
3849         invert_yaxis, yaxis_inverted
3850 
3851         Notes
3852         -----
3853         The *bottom* value may be greater than the *top* value, in which
3854         case the y-axis values will decrease from *bottom* to *top*.
3855 
3856         Examples
3857         --------
3858         >>> set_ylim(bottom, top)
3859         >>> set_ylim((bottom, top))
3860         >>> bottom, top = set_ylim(bottom, top)
3861 
3862         One limit may be left unchanged.
3863 
3864         >>> set_ylim(top=top_lim)
3865 
3866         Limits may be passed in reverse order to flip the direction of
3867         the y-axis. For example, suppose ``y`` represents depth of the
3868         ocean in m. The y-axis limits might be set like the following
3869         so 5000 m depth is at the bottom of the plot and the surface,
3870         0 m, is at the top.
3871 
3872         >>> set_ylim(5000, 0)
3873         """
3874         if top is None and np.iterable(bottom):
3875             bottom, top = bottom
3876         if ymin is not None:
3877             if bottom is not None:
3878                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3879             bottom = ymin
3880         if ymax is not None:
3881             if top is not None:
3882                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3883             top = ymax
3884         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3885 
3886     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3887     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3888     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3889     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3890     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3891     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3892     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3893     set_yticklabels = _axis_method_wrapper(
3894         "yaxis", "set_ticklabels",
3895         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3896 
3897     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3898     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3899 
3900     def format_xdata(self, x):
3901         """
3902         Return *x* formatted as an x-value.
3903 
3904         This function will use the `.fmt_xdata` attribute if it is not None,
3905         else will fall back on the xaxis major formatter.
3906         """
3907         return (self.fmt_xdata if self.fmt_xdata is not None
3908                 else self.xaxis.get_major_formatter().format_data_short)(x)
3909 
3910     def format_ydata(self, y):
3911         """
3912         Return *y* formatted as a y-value.
3913 
3914         This function will use the `.fmt_ydata` attribute if it is not None,
3915         else will fall back on the yaxis major formatter.
3916         """
3917         return (self.fmt_ydata if self.fmt_ydata is not None
3918                 else self.yaxis.get_major_formatter().format_data_short)(y)
3919 
3920     def format_coord(self, x, y):
3921         """Return a format string formatting the *x*, *y* coordinates."""
3922         return "x={} y={}".format(
3923             "???" if x is None else self.format_xdata(x),
3924             "???" if y is None else self.format_ydata(y),
3925         )
3926 
3927     def minorticks_on(self):
3928         """
3929         Display minor ticks on the Axes.
3930 
3931         Displaying minor ticks may reduce performance; you may turn them off
3932         using `minorticks_off()` if drawing speed is a problem.
3933         """
3934         for ax in (self.xaxis, self.yaxis):
3935             scale = ax.get_scale()
3936             if scale == 'log':
3937                 s = ax._scale
3938                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3939             elif scale == 'symlog':
3940                 s = ax._scale
3941                 ax.set_minor_locator(
3942                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3943             else:
3944                 ax.set_minor_locator(mticker.AutoMinorLocator())
3945 
3946     def minorticks_off(self):
3947         """Remove minor ticks from the Axes."""
3948         self.xaxis.set_minor_locator(mticker.NullLocator())
3949         self.yaxis.set_minor_locator(mticker.NullLocator())
3950 
3951     # Interactive manipulation
3952 
3953     def can_zoom(self):
3954         """
3955         Return whether this Axes supports the zoom box button functionality.
3956         """
3957         return True
3958 
3959     def can_pan(self):
3960         """
3961         Return whether this Axes supports any pan/zoom button functionality.
3962         """
3963         return True
3964 
3965     def get_navigate(self):
3966         """
3967         Get whether the Axes responds to navigation commands.
3968         """
3969         return self._navigate
3970 
3971     def set_navigate(self, b):
3972         """
3973         Set whether the Axes responds to navigation toolbar commands.
3974 
3975         Parameters
3976         ----------
3977         b : bool
3978         """
3979         self._navigate = b
3980 
3981     def get_navigate_mode(self):
3982         """
3983         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3984         """
3985         return self._navigate_mode
3986 
3987     def set_navigate_mode(self, b):
3988         """
3989         Set the navigation toolbar button status.
3990 
3991         .. warning::
3992             This is not a user-API function.
3993 
3994         """
3995         self._navigate_mode = b
3996 
3997     def _get_view(self):
3998         """
3999         Save information required to reproduce the current view.
4000 
4001         Called before a view is changed, such as during a pan or zoom
4002         initiated by the user. You may return any information you deem
4003         necessary to describe the view.
4004 
4005         .. note::
4006 
4007             Intended to be overridden by new projection types, but if not, the
4008             default implementation saves the view limits. You *must* implement
4009             :meth:`_set_view` if you implement this method.
4010         """
4011         xmin, xmax = self.get_xlim()
4012         ymin, ymax = self.get_ylim()
4013         return xmin, xmax, ymin, ymax
4014 
4015     def _set_view(self, view):
4016         """
4017         Apply a previously saved view.
4018 
4019         Called when restoring a view, such as with the navigation buttons.
4020 
4021         .. note::
4022 
4023             Intended to be overridden by new projection types, but if not, the
4024             default implementation restores the view limits. You *must*
4025             implement :meth:`_get_view` if you implement this method.
4026         """
4027         xmin, xmax, ymin, ymax = view
4028         self.set_xlim((xmin, xmax))
4029         self.set_ylim((ymin, ymax))
4030 
4031     def _prepare_view_from_bbox(self, bbox, direction='in',
4032                                 mode=None, twinx=False, twiny=False):
4033         """
4034         Helper function to prepare the new bounds from a bbox.
4035 
4036         This helper function returns the new x and y bounds from the zoom
4037         bbox. This a convenience method to abstract the bbox logic
4038         out of the base setter.
4039         """
4040         if len(bbox) == 3:
4041             xp, yp, scl = bbox  # Zooming code
4042             if scl == 0:  # Should not happen
4043                 scl = 1.
4044             if scl > 1:
4045                 direction = 'in'
4046             else:
4047                 direction = 'out'
4048                 scl = 1/scl
4049             # get the limits of the axes
4050             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4051                 np.transpose([self.get_xlim(), self.get_ylim()]))
4052             # set the range
4053             xwidth = xmax - xmin
4054             ywidth = ymax - ymin
4055             xcen = (xmax + xmin)*.5
4056             ycen = (ymax + ymin)*.5
4057             xzc = (xp*(scl - 1) + xcen)/scl
4058             yzc = (yp*(scl - 1) + ycen)/scl
4059             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4060                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4061         elif len(bbox) != 4:
4062             # should be len 3 or 4 but nothing else
4063             _api.warn_external(
4064                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4065                 "of length 3 or 4. Ignoring the view change.")
4066             return
4067 
4068         # Original limits.
4069         xmin0, xmax0 = self.get_xbound()
4070         ymin0, ymax0 = self.get_ybound()
4071         # The zoom box in screen coords.
4072         startx, starty, stopx, stopy = bbox
4073         # Convert to data coords.
4074         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4075             [(startx, starty), (stopx, stopy)])
4076         # Clip to axes limits.
4077         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4078         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4079         # Don't double-zoom twinned axes or if zooming only the other axis.
4080         if twinx or mode == "y":
4081             xmin, xmax = xmin0, xmax0
4082         if twiny or mode == "x":
4083             ymin, ymax = ymin0, ymax0
4084 
4085         if direction == "in":
4086             new_xbound = xmin, xmax
4087             new_ybound = ymin, ymax
4088 
4089         elif direction == "out":
4090             x_trf = self.xaxis.get_transform()
4091             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4092                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4093             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4094             # Move original bounds away by
4095             # (factor) x (distance between unzoom box and Axes bbox).
4096             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4097             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4098             # And back to data space.
4099             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4100 
4101             y_trf = self.yaxis.get_transform()
4102             symin0, symax0, symin, symax = y_trf.transform(
4103                 [ymin0, ymax0, ymin, ymax])
4104             factor = (symax0 - symin0) / (symax - symin)
4105             symin1 = symin0 - factor * (symin - symin0)
4106             symax1 = symax0 + factor * (symax0 - symax)
4107             new_ybound = y_trf.inverted().transform([symin1, symax1])
4108 
4109         return new_xbound, new_ybound
4110 
4111     def _set_view_from_bbox(self, bbox, direction='in',
4112                             mode=None, twinx=False, twiny=False):
4113         """
4114         Update view from a selection bbox.
4115 
4116         .. note::
4117 
4118             Intended to be overridden by new projection types, but if not, the
4119             default implementation sets the view limits to the bbox directly.
4120 
4121         Parameters
4122         ----------
4123         bbox : 4-tuple or 3 tuple
4124             * If bbox is a 4 tuple, it is the selected bounding box limits,
4125               in *display* coordinates.
4126             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4127               (xp, yp) is the center of zooming and scl the scale factor to
4128               zoom by.
4129 
4130         direction : str
4131             The direction to apply the bounding box.
4132                 * `'in'` - The bounding box describes the view directly, i.e.,
4133                            it zooms in.
4134                 * `'out'` - The bounding box describes the size to make the
4135                             existing view, i.e., it zooms out.
4136 
4137         mode : str or None
4138             The selection mode, whether to apply the bounding box in only the
4139             `'x'` direction, `'y'` direction or both (`None`).
4140 
4141         twinx : bool
4142             Whether this axis is twinned in the *x*-direction.
4143 
4144         twiny : bool
4145             Whether this axis is twinned in the *y*-direction.
4146         """
4147         new_xbound, new_ybound = self._prepare_view_from_bbox(
4148             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4149         if not twinx and mode != "y":
4150             self.set_xbound(new_xbound)
4151             self.set_autoscalex_on(False)
4152         if not twiny and mode != "x":
4153             self.set_ybound(new_ybound)
4154             self.set_autoscaley_on(False)
4155 
4156     def start_pan(self, x, y, button):
4157         """
4158         Called when a pan operation has started.
4159 
4160         Parameters
4161         ----------
4162         x, y : float
4163             The mouse coordinates in display coords.
4164         button : `.MouseButton`
4165             The pressed mouse button.
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         self._pan_start = types.SimpleNamespace(
4172             lim=self.viewLim.frozen(),
4173             trans=self.transData.frozen(),
4174             trans_inverse=self.transData.inverted().frozen(),
4175             bbox=self.bbox.frozen(),
4176             x=x,
4177             y=y)
4178 
4179     def end_pan(self):
4180         """
4181         Called when a pan operation completes (when the mouse button is up.)
4182 
4183         Notes
4184         -----
4185         This is intended to be overridden by new projection types.
4186         """
4187         del self._pan_start
4188 
4189     def _get_pan_points(self, button, key, x, y):
4190         """
4191         Helper function to return the new points after a pan.
4192 
4193         This helper function returns the points on the axis after a pan has
4194         occurred. This is a convenience method to abstract the pan logic
4195         out of the base setter.
4196         """
4197         def format_deltas(key, dx, dy):
4198             if key == 'control':
4199                 if abs(dx) > abs(dy):
4200                     dy = dx
4201                 else:
4202                     dx = dy
4203             elif key == 'x':
4204                 dy = 0
4205             elif key == 'y':
4206                 dx = 0
4207             elif key == 'shift':
4208                 if 2 * abs(dx) < abs(dy):
4209                     dx = 0
4210                 elif 2 * abs(dy) < abs(dx):
4211                     dy = 0
4212                 elif abs(dx) > abs(dy):
4213                     dy = dy / abs(dy) * abs(dx)
4214                 else:
4215                     dx = dx / abs(dx) * abs(dy)
4216             return dx, dy
4217 
4218         p = self._pan_start
4219         dx = x - p.x
4220         dy = y - p.y
4221         if dx == dy == 0:
4222             return
4223         if button == 1:
4224             dx, dy = format_deltas(key, dx, dy)
4225             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4226         elif button == 3:
4227             try:
4228                 dx = -dx / self.bbox.width
4229                 dy = -dy / self.bbox.height
4230                 dx, dy = format_deltas(key, dx, dy)
4231                 if self.get_aspect() != 'auto':
4232                     dx = dy = 0.5 * (dx + dy)
4233                 alpha = np.power(10.0, (dx, dy))
4234                 start = np.array([p.x, p.y])
4235                 oldpoints = p.lim.transformed(p.trans)
4236                 newpoints = start + alpha * (oldpoints - start)
4237                 result = (mtransforms.Bbox(newpoints)
4238                           .transformed(p.trans_inverse))
4239             except OverflowError:
4240                 _api.warn_external('Overflow while panning')
4241                 return
4242         else:
4243             return
4244 
4245         valid = np.isfinite(result.transformed(p.trans))
4246         points = result.get_points().astype(object)
4247         # Just ignore invalid limits (typically, underflow in log-scale).
4248         points[~valid] = None
4249         return points
4250 
4251     def drag_pan(self, button, key, x, y):
4252         """
4253         Called when the mouse moves during a pan operation.
4254 
4255         Parameters
4256         ----------
4257         button : `.MouseButton`
4258             The pressed mouse button.
4259         key : str or None
4260             The pressed key, if any.
4261         x, y : float
4262             The mouse coordinates in display coords.
4263 
4264         Notes
4265         -----
4266         This is intended to be overridden by new projection types.
4267         """
4268         points = self._get_pan_points(button, key, x, y)
4269         if points is not None:
4270             self.set_xlim(points[:, 0])
4271             self.set_ylim(points[:, 1])
4272 
4273     def get_children(self):
4274         # docstring inherited.
4275         return [
4276             *self._children,
4277             *self.spines.values(),
4278             *self._axis_map.values(),
4279             self.title, self._left_title, self._right_title,
4280             *self.child_axes,
4281             *([self.legend_] if self.legend_ is not None else []),
4282             self.patch,
4283         ]
4284 
4285     def contains(self, mouseevent):
4286         # docstring inherited.
4287         inside, info = self._default_contains(mouseevent)
4288         if inside is not None:
4289             return inside, info
4290         return self.patch.contains(mouseevent)
4291 
4292     def contains_point(self, point):
4293         """
4294         Return whether *point* (pair of pixel coordinates) is inside the Axes
4295         patch.
4296         """
4297         return self.patch.contains_point(point, radius=1.0)
4298 
4299     def get_default_bbox_extra_artists(self):
4300         """
4301         Return a default list of artists that are used for the bounding box
4302         calculation.
4303 
4304         Artists are excluded either by not being visible or
4305         ``artist.set_in_layout(False)``.
4306         """
4307 
4308         artists = self.get_children()
4309 
4310         for axis in self._axis_map.values():
4311             # axis tight bboxes are calculated separately inside
4312             # Axes.get_tightbbox() using for_layout_only=True
4313             artists.remove(axis)
4314         if not (self.axison and self._frameon):
4315             # don't do bbox on spines if frame not on.
4316             for spine in self.spines.values():
4317                 artists.remove(spine)
4318 
4319         artists.remove(self.title)
4320         artists.remove(self._left_title)
4321         artists.remove(self._right_title)
4322 
4323         # always include types that do not internally implement clipping
4324         # to Axes. may have clip_on set to True and clip_box equivalent
4325         # to ax.bbox but then ignore these properties during draws.
4326         noclip = (_AxesBase, maxis.Axis,
4327                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4328         return [a for a in artists if a.get_visible() and a.get_in_layout()
4329                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4330 
4331     @_api.make_keyword_only("3.8", "call_axes_locator")
4332     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4333                       bbox_extra_artists=None, *, for_layout_only=False):
4334         """
4335         Return the tight bounding box of the Axes, including axis and their
4336         decorators (xlabel, title, etc).
4337 
4338         Artists that have ``artist.set_in_layout(False)`` are not included
4339         in the bbox.
4340 
4341         Parameters
4342         ----------
4343         renderer : `.RendererBase` subclass
4344             renderer that will be used to draw the figures (i.e.
4345             ``fig.canvas.get_renderer()``)
4346 
4347         bbox_extra_artists : list of `.Artist` or ``None``
4348             List of artists to include in the tight bounding box.  If
4349             ``None`` (default), then all artist children of the Axes are
4350             included in the tight bounding box.
4351 
4352         call_axes_locator : bool, default: True
4353             If *call_axes_locator* is ``False``, it does not call the
4354             ``_axes_locator`` attribute, which is necessary to get the correct
4355             bounding box. ``call_axes_locator=False`` can be used if the
4356             caller is only interested in the relative size of the tightbbox
4357             compared to the Axes bbox.
4358 
4359         for_layout_only : default: False
4360             The bounding box will *not* include the x-extent of the title and
4361             the xlabel, or the y-extent of the ylabel.
4362 
4363         Returns
4364         -------
4365         `.BboxBase`
4366             Bounding box in figure pixel coordinates.
4367 
4368         See Also
4369         --------
4370         matplotlib.axes.Axes.get_window_extent
4371         matplotlib.axis.Axis.get_tightbbox
4372         matplotlib.spines.Spine.get_window_extent
4373         """
4374 
4375         bb = []
4376         if renderer is None:
4377             renderer = self.figure._get_renderer()
4378 
4379         if not self.get_visible():
4380             return None
4381 
4382         locator = self.get_axes_locator()
4383         self.apply_aspect(
4384             locator(self, renderer) if locator and call_axes_locator else None)
4385 
4386         for axis in self._axis_map.values():
4387             if self.axison and axis.get_visible():
4388                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4389                 if ba:
4390                     bb.append(ba)
4391         self._update_title_position(renderer)
4392         axbbox = self.get_window_extent(renderer)
4393         bb.append(axbbox)
4394 
4395         for title in [self.title, self._left_title, self._right_title]:
4396             if title.get_visible():
4397                 bt = title.get_window_extent(renderer)
4398                 if for_layout_only and bt.width > 0:
4399                     # make the title bbox 1 pixel wide so its width
4400                     # is not accounted for in bbox calculations in
4401                     # tight/constrained_layout
4402                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4403                     bt.x1 = bt.x0 + 1.0
4404                 bb.append(bt)
4405 
4406         bbox_artists = bbox_extra_artists
4407         if bbox_artists is None:
4408             bbox_artists = self.get_default_bbox_extra_artists()
4409 
4410         for a in bbox_artists:
4411             bbox = a.get_tightbbox(renderer)
4412             if (bbox is not None
4413                     and 0 < bbox.width < np.inf
4414                     and 0 < bbox.height < np.inf):
4415                 bb.append(bbox)
4416         return mtransforms.Bbox.union(
4417             [b for b in bb if b.width != 0 or b.height != 0])
4418 
4419     def _make_twin_axes(self, *args, **kwargs):
4420         """Make a twinx Axes of self. This is used for twinx and twiny."""
4421         if 'sharex' in kwargs and 'sharey' in kwargs:
4422             # The following line is added in v2.2 to avoid breaking Seaborn,
4423             # which currently uses this internal API.
4424             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4425                 raise ValueError("Twinned Axes may share only one axis")
4426         ss = self.get_subplotspec()
4427         if ss:
4428             twin = self.figure.add_subplot(ss, *args, **kwargs)
4429         else:
4430             twin = self.figure.add_axes(
4431                 self.get_position(True), *args, **kwargs,
4432                 axes_locator=_TransformedBoundsLocator(
4433                     [0, 0, 1, 1], self.transAxes))
4434         self.set_adjustable('datalim')
4435         twin.set_adjustable('datalim')
4436         self._twinned_axes.join(self, twin)
4437         return twin
4438 
4439     def twinx(self):
4440         """
4441         Create a twin Axes sharing the xaxis.
4442 
4443         Create a new Axes with an invisible x-axis and an independent
4444         y-axis positioned opposite to the original one (i.e. at right). The
4445         x-axis autoscale setting will be inherited from the original
4446         Axes.  To ensure that the tick marks of both y-axes align, see
4447         `~matplotlib.ticker.LinearLocator`.
4448 
4449         Returns
4450         -------
4451         Axes
4452             The newly created Axes instance
4453 
4454         Notes
4455         -----
4456         For those who are 'picking' artists while using twinx, pick
4457         events are only called for the artists in the top-most Axes.
4458         """
4459         ax2 = self._make_twin_axes(sharex=self)
4460         ax2.yaxis.tick_right()
4461         ax2.yaxis.set_label_position('right')
4462         ax2.yaxis.set_offset_position('right')
4463         ax2.set_autoscalex_on(self.get_autoscalex_on())
4464         self.yaxis.tick_left()
4465         ax2.xaxis.set_visible(False)
4466         ax2.patch.set_visible(False)
4467         return ax2
4468 
4469     def twiny(self):
4470         """
4471         Create a twin Axes sharing the yaxis.
4472 
4473         Create a new Axes with an invisible y-axis and an independent
4474         x-axis positioned opposite to the original one (i.e. at top). The
4475         y-axis autoscale setting will be inherited from the original Axes.
4476         To ensure that the tick marks of both x-axes align, see
4477         `~matplotlib.ticker.LinearLocator`.
4478 
4479         Returns
4480         -------
4481         Axes
4482             The newly created Axes instance
4483 
4484         Notes
4485         -----
4486         For those who are 'picking' artists while using twiny, pick
4487         events are only called for the artists in the top-most Axes.
4488         """
4489         ax2 = self._make_twin_axes(sharey=self)
4490         ax2.xaxis.tick_top()
4491         ax2.xaxis.set_label_position('top')
4492         ax2.set_autoscaley_on(self.get_autoscaley_on())
4493         self.xaxis.tick_bottom()
4494         ax2.yaxis.set_visible(False)
4495         ax2.patch.set_visible(False)
4496         return ax2
4497 
4498     def get_shared_x_axes(self):
4499         """Return an immutable view on the shared x-axes Grouper."""
4500         return cbook.GrouperView(self._shared_axes["x"])
4501 
4502     def get_shared_y_axes(self):
4503         """Return an immutable view on the shared y-axes Grouper."""
4504         return cbook.GrouperView(self._shared_axes["y"])
4505 
4506     def label_outer(self):
4507         """
4508         Only show "outer" labels and tick labels.
4509 
4510         x-labels are only kept for subplots on the last row (or first row, if
4511         labels are on the top side); y-labels only for subplots on the first
4512         column (or last column, if labels are on the right side).
4513         """
4514         self._label_outer_xaxis(check_patch=False)
4515         self._label_outer_yaxis(check_patch=False)
4516 
4517     def _label_outer_xaxis(self, *, check_patch):
4518         # see documentation in label_outer.
4519         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4520             return
4521         ss = self.get_subplotspec()
4522         if not ss:
4523             return
4524         label_position = self.xaxis.get_label_position()
4525         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4526             if label_position == "top":
4527                 self.set_xlabel("")
4528             self.xaxis.set_tick_params(which="both", labeltop=False)
4529             if self.xaxis.offsetText.get_position()[1] == 1:
4530                 self.xaxis.offsetText.set_visible(False)
4531         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4532             if label_position == "bottom":
4533                 self.set_xlabel("")
4534             self.xaxis.set_tick_params(which="both", labelbottom=False)
4535             if self.xaxis.offsetText.get_position()[1] == 0:
4536                 self.xaxis.offsetText.set_visible(False)
4537 
4538     def _label_outer_yaxis(self, *, check_patch):
4539         # see documentation in label_outer.
4540         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4541             return
4542         ss = self.get_subplotspec()
4543         if not ss:
4544             return
4545         label_position = self.yaxis.get_label_position()
4546         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4547             if label_position == "left":
4548                 self.set_ylabel("")
4549             self.yaxis.set_tick_params(which="both", labelleft=False)
4550             if self.yaxis.offsetText.get_position()[0] == 0:
4551                 self.yaxis.offsetText.set_visible(False)
4552         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4553             if label_position == "right":
4554                 self.set_ylabel("")
4555             self.yaxis.set_tick_params(which="both", labelright=False)
4556             if self.yaxis.offsetText.get_position()[0] == 1:
4557                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:34:54.163 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
2040     def __call__(self, value, clip=None):
2041         return value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>__call__</method>
<code>
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Colormap</class>
<method>__call__</method>
<code>
683     def __call__(self, X, alpha=None, bytes=False):
684         """
685         Parameters
686         ----------
687         X : float or int, `~numpy.ndarray` or scalar
688             The data value(s) to convert to RGBA.
689             For floats, *X* should be in the interval ``[0.0, 1.0]`` to
690             return the RGBA values ``X*100`` percent along the Colormap line.
691             For integers, *X* should be in the interval ``[0, Colormap.N)`` to
692             return RGBA values *indexed* from the Colormap with index ``X``.
693         alpha : float or array-like or None
694             Alpha must be a scalar between 0 and 1, a sequence of such
695             floats with shape matching X, or None.
696         bytes : bool
697             If False (default), the returned RGBA values will be floats in the
698             interval ``[0, 1]`` otherwise they will be uint8s in the interval
699             ``[0, 255]``.
700 
701         Returns
702         -------
703         Tuple of RGBA values if X is scalar, otherwise an array of
704         RGBA values with a shape of ``X.shape + (4, )``.
705         """
706         if not self._isinit:
707             self._init()
708 
709         xa = np.array(X, copy=True)
710         if not xa.dtype.isnative:
711             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.
712         if xa.dtype.kind == "f":
713             xa *= self.N
714             # xa == 1 (== N after multiplication) is not out of range.
715             xa[xa == self.N] = self.N - 1
716         # Pre-compute the masks before casting to int (which can truncate
717         # negative values to zero or wrap large floats to negative ints).
718         mask_under = xa < 0
719         mask_over = xa >= self.N
720         # If input was masked, get the bad mask from it; else mask out nans.
721         mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(xa)
722         with np.errstate(invalid="ignore"):
723             # We need this cast for unsigned ints as well as floats
724             xa = xa.astype(int)
725         xa[mask_under] = self._i_under
726         xa[mask_over] = self._i_over
727         xa[mask_bad] = self._i_bad
728 
729         lut = self._lut
730         if bytes:
731             lut = (lut * 255).astype(np.uint8)
732 
733         rgba = lut.take(xa, axis=0, mode='clip')
734 
735         if alpha is not None:
736             alpha = np.clip(alpha, 0, 1)
737             if bytes:
738                 alpha *= 255  # Will be cast to uint8 upon assignment.
739             if alpha.shape not in [(), xa.shape]:
740                 raise ValueError(
741                     f"alpha is array-like but its shape {alpha.shape} does "
742                     f"not match that of X {xa.shape}")
743             rgba[..., -1] = alpha
744             # If the "bad" color is all zeros, then ignore alpha input.
745             if (lut[-1] == 0).all():
746                 rgba[mask_bad] = (0, 0, 0, 0)
747 
748         if not np.iterable(X):
749             rgba = tuple(rgba)
750         return rgba

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Normalize</class>
<method>__call__</method>
<code>
1305     def __call__(self, value, clip=None):
1306         """
1307         Normalize *value* data in the ``[vmin, vmax]`` interval into the
1308         ``[0.0, 1.0]`` interval and return it.
1309 
1310         Parameters
1311         ----------
1312         value
1313             Data to normalize.
1314         clip : bool
1315             If ``None``, defaults to ``self.clip`` (which defaults to
1316             ``False``).
1317 
1318         Notes
1319         -----
1320         If not already initialized, ``self.vmin`` and ``self.vmax`` are
1321         initialized using ``self.autoscale_None(value)``.
1322         """
1323         if clip is None:
1324             clip = self.clip
1325 
1326         result, is_scalar = self.process_value(value)
1327 
1328         if self.vmin is None or self.vmax is None:
1329             self.autoscale_None(result)
1330         # Convert at least to float, without losing precision.
1331         (vmin,), _ = self.process_value(self.vmin)
1332         (vmax,), _ = self.process_value(self.vmax)
1333         if vmin == vmax:
1334             result.fill(0)  # Or should it be all masked?  Or 0.5?
1335         elif vmin > vmax:
1336             raise ValueError("minvalue must be less than or equal to maxvalue")
1337         else:
1338             if clip:
1339                 mask = np.ma.getmask(result)
1340                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1341                                      mask=mask)
1342             # ma division is very slow; we can take a shortcut
1343             resdat = result.data
1344             resdat -= vmin
1345             resdat /= (vmax - vmin)
1346             result = np.ma.array(resdat, mask=result.mask, copy=False)
1347         if is_scalar:
1348             result = result[0]
1349         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>TwoSlopeNorm</class>
<method>__call__</method>
<code>
1447     def __call__(self, value, clip=None):
1448         """
1449         Map value to the interval [0, 1]. The clip argument is unused.
1450         """
1451         result, is_scalar = self.process_value(value)
1452         self.autoscale_None(result)  # sets self.vmin, self.vmax if None
1453 
1454         if not self.vmin <= self.vcenter <= self.vmax:
1455             raise ValueError("vmin, vcenter, vmax must increase monotonically")
1456         # note that we must extrapolate for tick locators:
1457         result = np.ma.masked_array(
1458             np.interp(result, [self.vmin, self.vcenter, self.vmax],
1459                       [0, 0.5, 1], left=-np.inf, right=np.inf),
1460             mask=np.ma.getmask(result))
1461         if is_scalar:
1462             result = np.atleast_1d(result)[0]
1463         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>PowerNorm</class>
<method>__call__</method>
<code>
1865     def __call__(self, value, clip=None):
1866         if clip is None:
1867             clip = self.clip
1868 
1869         result, is_scalar = self.process_value(value)
1870 
1871         self.autoscale_None(result)
1872         gamma = self.gamma
1873         vmin, vmax = self.vmin, self.vmax
1874         if vmin > vmax:
1875             raise ValueError("minvalue must be less than or equal to maxvalue")
1876         elif vmin == vmax:
1877             result.fill(0)
1878         else:
1879             if clip:
1880                 mask = np.ma.getmask(result)
1881                 result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),
1882                                      mask=mask)
1883             resdat = result.data
1884             resdat -= vmin
1885             resdat[resdat < 0] = 0
1886             np.power(resdat, gamma, resdat)
1887             resdat /= (vmax - vmin) ** gamma
1888 
1889             result = np.ma.array(resdat, mask=result.mask, copy=False)
1890         if is_scalar:
1891             result = result[0]
1892         return result

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>BoundaryNorm</class>
<method>__call__</method>
<code>
1982     def __call__(self, value, clip=None):
1983         """
1984         This method behaves similarly to `.Normalize.__call__`, except that it
1985         returns integers or arrays of int16.
1986         """
1987         if clip is None:
1988             clip = self.clip
1989 
1990         xx, is_scalar = self.process_value(value)
1991         mask = np.ma.getmaskarray(xx)
1992         # Fill masked values a value above the upper boundary
1993         xx = np.atleast_1d(xx.filled(self.vmax + 1))
1994         if clip:
1995             np.clip(xx, self.vmin, self.vmax, out=xx)
1996             max_col = self.Ncmap - 1
1997         else:
1998             max_col = self.Ncmap
1999         # this gives us the bins in the lookup table in the range
2000         # [0, _n_regions - 1]  (the offset is set in the init)
2001         iret = np.digitize(xx, self.boundaries) - 1 + self._offset
2002         # if we have more colors than regions, stretch the region
2003         # index computed above to full range of the color bins.  This
2004         # will make use of the full range (but skip some of the colors
2005         # in the middle) such that the first region is mapped to the
2006         # first color and the last region is mapped to the last color.
2007         if self.Ncmap > self._n_regions:
2008             if self._n_regions == 1:
2009                 # special case the 1 region case, pick the middle color
2010                 iret[iret == 0] = (self.Ncmap - 1) // 2
2011             else:
2012                 # otherwise linearly remap the values from the region index
2013                 # to the color index spaces
2014                 iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret
2015         # cast to 16bit integers in all cases
2016         iret = iret.astype(np.int16)
2017         iret[xx < self.vmin] = -1
2018         iret[xx >= self.vmax] = max_col
2019         ret = np.ma.array(iret, mask=mask)
2020         if is_scalar:
2021             ret = int(ret[0])  # assume python scalar
2022         return ret

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>NoNorm</class>
<method>__call__</method>
<code>
2040     def __call__(self, value, clip=None):
2041         return value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/colors.py</file>
<class>Norm</class>
<method>__call__</method>
<code>
1682         def __call__(self, value, clip=None):
1683             value, is_scalar = self.process_value(value)
1684             if self.vmin is None or self.vmax is None:
1685                 self.autoscale_None(value)
1686             if self.vmin > self.vmax:
1687                 raise ValueError("vmin must be less or equal to vmax")
1688             if self.vmin == self.vmax:
1689                 return np.full_like(value, 0)
1690             if clip is None:
1691                 clip = self.clip
1692             if clip:
1693                 value = np.clip(value, self.vmin, self.vmax)
1694             t_value = self._trf.transform(value).reshape(np.shape(value))
1695             t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])
1696             if not np.isfinite([t_vmin, t_vmax]).all():
1697                 raise ValueError("Invalid vmin or vmax")
1698             t_value -= t_vmin
1699             t_value /= (t_vmax - t_vmin)
1700             t_value = np.ma.masked_invalid(t_value, copy=False)
1701             return t_value[0] if is_scalar else t_value

</code><intended_behavior>Ensure that when the LogNorm is applied, the __call__ method gracefully handles the transition from a possibly linear norm to a logarithmic one. Specifically, it should validate and process vmin and vmax values to prevent the 'Invalid vmin or vmax' error by considering the nature of logarithmic data scaling.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>autoscale</method>
<code>
2766     def autoscale(self, enable=True, axis='both', tight=None):
2767         """
2768         Autoscale the axis view to the data (toggle).
2769 
2770         Convenience method for simple axis view autoscaling.
2771         It turns autoscaling on or off, and then,
2772         if autoscaling for either axis is on, it performs
2773         the autoscaling on the specified axis or Axes.
2774 
2775         Parameters
2776         ----------
2777         enable : bool or None, default: True
2778             True turns autoscaling on, False turns it off.
2779             None leaves the autoscaling state unchanged.
2780         axis : {'both', 'x', 'y'}, default: 'both'
2781             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2782             to 'z', and 'both' refers to all three axes.)
2783         tight : bool or None, default: None
2784             If True, first set the margins to zero.  Then, this argument is
2785             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2786             its value); see the description of its behavior there.
2787         """
2788         if enable is None:
2789             scalex = True
2790             scaley = True
2791         else:
2792             if axis in ['x', 'both']:
2793                 self.set_autoscalex_on(bool(enable))
2794                 scalex = self.get_autoscalex_on()
2795             else:
2796                 scalex = False
2797             if axis in ['y', 'both']:
2798                 self.set_autoscaley_on(bool(enable))
2799                 scaley = self.get_autoscaley_on()
2800             else:
2801                 scaley = False
2802         if tight and scalex:
2803             self._xmargin = 0
2804         if tight and scaley:
2805             self._ymargin = 0
2806         if scalex:
2807             self._request_autoscale_view("x", tight=tight)
2808         if scaley:
2809             self._request_autoscale_view("y", tight=tight)

</code><intended_behavior>After a norm change to LogNorm, the autoscale method should correctly assess and update the plot's view limits in accordance with the logarithmic scale. This might involve ensuring that data limits are recalculated or interpreted correctly under the new norm, potentially requiring an additional check or recalibration step.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     @_api.delete_parameter("3.6", "args")
800     @_api.delete_parameter("3.6", "kwargs")
801     def get_window_extent(self, renderer=None, *args, **kwargs):
802         """
803         Return the Axes bounding box in display space; *args* and *kwargs*
804         are empty.
805 
806         This bounding box does not include the spines, ticks, ticklabels,
807         or other labels.  For a bounding box including these elements use
808         `~matplotlib.axes.Axes.get_tightbbox`.
809 
810         See Also
811         --------
812         matplotlib.axes.Axes.get_tightbbox
813         matplotlib.axis.Axis.get_tightbbox
814         matplotlib.spines.Spine.get_window_extent
815         """
816         return self.bbox
817 
818     def _init_axis(self):
819         # This is moved out of __init__ because non-separable axes don't use it
820         self.xaxis = maxis.XAxis(self)
821         self.spines.bottom.register_axis(self.xaxis)
822         self.spines.top.register_axis(self.xaxis)
823         self.yaxis = maxis.YAxis(self)
824         self.spines.left.register_axis(self.yaxis)
825         self.spines.right.register_axis(self.yaxis)
826 
827     def set_figure(self, fig):
828         # docstring inherited
829         super().set_figure(fig)
830 
831         self.bbox = mtransforms.TransformedBbox(self._position,
832                                                 fig.transSubfigure)
833         # these will be updated later as data is added
834         self.dataLim = mtransforms.Bbox.null()
835         self._viewLim = mtransforms.Bbox.unit()
836         self.transScale = mtransforms.TransformWrapper(
837             mtransforms.IdentityTransform())
838 
839         self._set_lim_and_transforms()
840 
841     def _unstale_viewLim(self):
842         # We should arrange to store this information once per share-group
843         # instead of on every axis.
844         need_scale = {
845             name: any(ax._stale_viewlims[name]
846                       for ax in self._shared_axes[name].get_siblings(self))
847             for name in self._axis_names}
848         if any(need_scale.values()):
849             for name in need_scale:
850                 for ax in self._shared_axes[name].get_siblings(self):
851                     ax._stale_viewlims[name] = False
852             self.autoscale_view(**{f"scale{name}": scale
853                                    for name, scale in need_scale.items()})
854 
855     @property
856     def viewLim(self):
857         self._unstale_viewLim()
858         return self._viewLim
859 
860     def _request_autoscale_view(self, axis="all", tight=None):
861         """
862         Mark a single axis, or all of them, as stale wrt. autoscaling.
863 
864         No computation is performed until the next autoscaling; thus, separate
865         calls to control individual axises incur negligible performance cost.
866 
867         Parameters
868         ----------
869         axis : str, default: "all"
870             Either an element of ``self._axis_names``, or "all".
871         tight : bool or None, default: None
872         """
873         axis_names = _api.check_getitem(
874             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
875             axis=axis)
876         for name in axis_names:
877             self._stale_viewlims[name] = True
878         if tight is not None:
879             self._tight = tight
880 
881     def _set_lim_and_transforms(self):
882         """
883         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
884         *transData*, *transLimits* and *transAxes* transformations.
885 
886         .. note::
887 
888             This method is primarily used by rectilinear projections of the
889             `~matplotlib.axes.Axes` class, and is meant to be overridden by
890             new kinds of projection Axes that need different transformations
891             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
892             example.)
893         """
894         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
895 
896         # Transforms the x and y axis separately by a scale factor.
897         # It is assumed that this part will have non-linear components
898         # (e.g., for a log scale).
899         self.transScale = mtransforms.TransformWrapper(
900             mtransforms.IdentityTransform())
901 
902         # An affine transformation on the data, generally to limit the
903         # range of the axes
904         self.transLimits = mtransforms.BboxTransformFrom(
905             mtransforms.TransformedBbox(self._viewLim, self.transScale))
906 
907         # The parentheses are important for efficiency here -- they
908         # group the last two (which are usually affines) separately
909         # from the first (which, with log-scaling can be non-affine).
910         self.transData = self.transScale + (self.transLimits + self.transAxes)
911 
912         self._xaxis_transform = mtransforms.blended_transform_factory(
913             self.transData, self.transAxes)
914         self._yaxis_transform = mtransforms.blended_transform_factory(
915             self.transAxes, self.transData)
916 
917     def get_xaxis_transform(self, which='grid'):
918         """
919         Get the transformation used for drawing x-axis labels, ticks
920         and gridlines.  The x-direction is in data coordinates and the
921         y-direction is in axis coordinates.
922 
923         .. note::
924 
925             This transformation is primarily used by the
926             `~matplotlib.axis.Axis` class, and is meant to be
927             overridden by new kinds of projections that may need to
928             place axis elements in different locations.
929 
930         Parameters
931         ----------
932         which : {'grid', 'tick1', 'tick2'}
933         """
934         if which == 'grid':
935             return self._xaxis_transform
936         elif which == 'tick1':
937             # for cartesian projection, this is bottom spine
938             return self.spines.bottom.get_spine_transform()
939         elif which == 'tick2':
940             # for cartesian projection, this is top spine
941             return self.spines.top.get_spine_transform()
942         else:
943             raise ValueError(f'unknown value for which: {which!r}')
944 
945     def get_xaxis_text1_transform(self, pad_points):
946         """
947         Returns
948         -------
949         transform : Transform
950             The transform used for drawing x-axis labels, which will add
951             *pad_points* of padding (in points) between the axis and the label.
952             The x-direction is in data coordinates and the y-direction is in
953             axis coordinates
954         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
955             The text vertical alignment.
956         halign : {'center', 'left', 'right'}
957             The text horizontal alignment.
958 
959         Notes
960         -----
961         This transformation is primarily used by the `~matplotlib.axis.Axis`
962         class, and is meant to be overridden by new kinds of projections that
963         may need to place axis elements in different locations.
964         """
965         labels_align = mpl.rcParams["xtick.alignment"]
966         return (self.get_xaxis_transform(which='tick1') +
967                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
968                                               self.figure.dpi_scale_trans),
969                 "top", labels_align)
970 
971     def get_xaxis_text2_transform(self, pad_points):
972         """
973         Returns
974         -------
975         transform : Transform
976             The transform used for drawing secondary x-axis labels, which will
977             add *pad_points* of padding (in points) between the axis and the
978             label.  The x-direction is in data coordinates and the y-direction
979             is in axis coordinates
980         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
981             The text vertical alignment.
982         halign : {'center', 'left', 'right'}
983             The text horizontal alignment.
984 
985         Notes
986         -----
987         This transformation is primarily used by the `~matplotlib.axis.Axis`
988         class, and is meant to be overridden by new kinds of projections that
989         may need to place axis elements in different locations.
990         """
991         labels_align = mpl.rcParams["xtick.alignment"]
992         return (self.get_xaxis_transform(which='tick2') +
993                 mtransforms.ScaledTranslation(0, pad_points / 72,
994                                               self.figure.dpi_scale_trans),
995                 "bottom", labels_align)
996 
997     def get_yaxis_transform(self, which='grid'):
998         """
999         Get the transformation used for drawing y-axis labels, ticks
1000         and gridlines.  The x-direction is in axis coordinates and the
1001         y-direction is in data coordinates.
1002 
1003         .. note::
1004 
1005             This transformation is primarily used by the
1006             `~matplotlib.axis.Axis` class, and is meant to be
1007             overridden by new kinds of projections that may need to
1008             place axis elements in different locations.
1009 
1010         Parameters
1011         ----------
1012         which : {'grid', 'tick1', 'tick2'}
1013         """
1014         if which == 'grid':
1015             return self._yaxis_transform
1016         elif which == 'tick1':
1017             # for cartesian projection, this is bottom spine
1018             return self.spines.left.get_spine_transform()
1019         elif which == 'tick2':
1020             # for cartesian projection, this is top spine
1021             return self.spines.right.get_spine_transform()
1022         else:
1023             raise ValueError(f'unknown value for which: {which!r}')
1024 
1025     def get_yaxis_text1_transform(self, pad_points):
1026         """
1027         Returns
1028         -------
1029         transform : Transform
1030             The transform used for drawing y-axis labels, which will add
1031             *pad_points* of padding (in points) between the axis and the label.
1032             The x-direction is in axis coordinates and the y-direction is in
1033             data coordinates
1034         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1035             The text vertical alignment.
1036         halign : {'center', 'left', 'right'}
1037             The text horizontal alignment.
1038 
1039         Notes
1040         -----
1041         This transformation is primarily used by the `~matplotlib.axis.Axis`
1042         class, and is meant to be overridden by new kinds of projections that
1043         may need to place axis elements in different locations.
1044         """
1045         labels_align = mpl.rcParams["ytick.alignment"]
1046         return (self.get_yaxis_transform(which='tick1') +
1047                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1048                                               self.figure.dpi_scale_trans),
1049                 labels_align, "right")
1050 
1051     def get_yaxis_text2_transform(self, pad_points):
1052         """
1053         Returns
1054         -------
1055         transform : Transform
1056             The transform used for drawing secondart y-axis labels, which will
1057             add *pad_points* of padding (in points) between the axis and the
1058             label.  The x-direction is in axis coordinates and the y-direction
1059             is in data coordinates
1060         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1061             The text vertical alignment.
1062         halign : {'center', 'left', 'right'}
1063             The text horizontal alignment.
1064 
1065         Notes
1066         -----
1067         This transformation is primarily used by the `~matplotlib.axis.Axis`
1068         class, and is meant to be overridden by new kinds of projections that
1069         may need to place axis elements in different locations.
1070         """
1071         labels_align = mpl.rcParams["ytick.alignment"]
1072         return (self.get_yaxis_transform(which='tick2') +
1073                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1074                                               self.figure.dpi_scale_trans),
1075                 labels_align, "left")
1076 
1077     def _update_transScale(self):
1078         self.transScale.set(
1079             mtransforms.blended_transform_factory(
1080                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1081 
1082     def get_position(self, original=False):
1083         """
1084         Return the position of the Axes within the figure as a `.Bbox`.
1085 
1086         Parameters
1087         ----------
1088         original : bool
1089             If ``True``, return the original position. Otherwise, return the
1090             active position. For an explanation of the positions see
1091             `.set_position`.
1092 
1093         Returns
1094         -------
1095         `.Bbox`
1096 
1097         """
1098         if original:
1099             return self._originalPosition.frozen()
1100         else:
1101             locator = self.get_axes_locator()
1102             if not locator:
1103                 self.apply_aspect()
1104             return self._position.frozen()
1105 
1106     def set_position(self, pos, which='both'):
1107         """
1108         Set the Axes position.
1109 
1110         Axes have two position attributes. The 'original' position is the
1111         position allocated for the Axes. The 'active' position is the
1112         position the Axes is actually drawn at. These positions are usually
1113         the same unless a fixed aspect is set to the Axes. See
1114         `.Axes.set_aspect` for details.
1115 
1116         Parameters
1117         ----------
1118         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1119             The new position of the Axes in `.Figure` coordinates.
1120 
1121         which : {'both', 'active', 'original'}, default: 'both'
1122             Determines which position variables to change.
1123 
1124         See Also
1125         --------
1126         matplotlib.transforms.Bbox.from_bounds
1127         matplotlib.transforms.Bbox.from_extents
1128         """
1129         self._set_position(pos, which=which)
1130         # because this is being called externally to the library we
1131         # don't let it be in the layout.
1132         self.set_in_layout(False)
1133 
1134     def _set_position(self, pos, which='both'):
1135         """
1136         Private version of set_position.
1137 
1138         Call this internally to get the same functionality of `set_position`,
1139         but not to take the axis out of the constrained_layout hierarchy.
1140         """
1141         if not isinstance(pos, mtransforms.BboxBase):
1142             pos = mtransforms.Bbox.from_bounds(*pos)
1143         for ax in self._twinned_axes.get_siblings(self):
1144             if which in ('both', 'active'):
1145                 ax._position.set(pos)
1146             if which in ('both', 'original'):
1147                 ax._originalPosition.set(pos)
1148         self.stale = True
1149 
1150     def reset_position(self):
1151         """
1152         Reset the active position to the original position.
1153 
1154         This undoes changes to the active position (as defined in
1155         `.set_position`) which may have been performed to satisfy fixed-aspect
1156         constraints.
1157         """
1158         for ax in self._twinned_axes.get_siblings(self):
1159             pos = ax.get_position(original=True)
1160             ax.set_position(pos, which='active')
1161 
1162     def set_axes_locator(self, locator):
1163         """
1164         Set the Axes locator.
1165 
1166         Parameters
1167         ----------
1168         locator : Callable[[Axes, Renderer], Bbox]
1169         """
1170         self._axes_locator = locator
1171         self.stale = True
1172 
1173     def get_axes_locator(self):
1174         """
1175         Return the axes_locator.
1176         """
1177         return self._axes_locator
1178 
1179     def _set_artist_props(self, a):
1180         """Set the boilerplate props for artists added to Axes."""
1181         a.set_figure(self.figure)
1182         if not a.is_transform_set():
1183             a.set_transform(self.transData)
1184 
1185         a.axes = self
1186         if a.get_mouseover():
1187             self._mouseover_set.add(a)
1188 
1189     def _gen_axes_patch(self):
1190         """
1191         Returns
1192         -------
1193         Patch
1194             The patch used to draw the background of the Axes.  It is also used
1195             as the clipping path for any data elements on the Axes.
1196 
1197             In the standard Axes, this is a rectangle, but in other projections
1198             it may not be.
1199 
1200         Notes
1201         -----
1202         Intended to be overridden by new projection types.
1203         """
1204         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1205 
1206     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1207         """
1208         Returns
1209         -------
1210         dict
1211             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1212             used to draw Axes spines.
1213 
1214             In the standard Axes, spines are single line segments, but in other
1215             projections they may not be.
1216 
1217         Notes
1218         -----
1219         Intended to be overridden by new projection types.
1220         """
1221         return {side: mspines.Spine.linear_spine(self, side)
1222                 for side in ['left', 'right', 'bottom', 'top']}
1223 
1224     def sharex(self, other):
1225         """
1226         Share the x-axis with *other*.
1227 
1228         This is equivalent to passing ``sharex=other`` when constructing the
1229         Axes, and cannot be used if the x-axis is already being shared with
1230         another Axes.
1231         """
1232         _api.check_isinstance(_AxesBase, other=other)
1233         if self._sharex is not None and other is not self._sharex:
1234             raise ValueError("x-axis is already shared")
1235         self._shared_axes["x"].join(self, other)
1236         self._sharex = other
1237         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1238         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1239         x0, x1 = other.get_xlim()
1240         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1241         self.xaxis._scale = other.xaxis._scale
1242 
1243     def sharey(self, other):
1244         """
1245         Share the y-axis with *other*.
1246 
1247         This is equivalent to passing ``sharey=other`` when constructing the
1248         Axes, and cannot be used if the y-axis is already being shared with
1249         another Axes.
1250         """
1251         _api.check_isinstance(_AxesBase, other=other)
1252         if self._sharey is not None and other is not self._sharey:
1253             raise ValueError("y-axis is already shared")
1254         self._shared_axes["y"].join(self, other)
1255         self._sharey = other
1256         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1257         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1258         y0, y1 = other.get_ylim()
1259         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1260         self.yaxis._scale = other.yaxis._scale
1261 
1262     def __clear(self):
1263         """Clear the Axes."""
1264         # The actual implementation of clear() as long as clear() has to be
1265         # an adapter delegating to the correct implementation.
1266         # The implementation can move back into clear() when the
1267         # deprecation on cla() subclassing expires.
1268 
1269         # stash the current visibility state
1270         if hasattr(self, 'patch'):
1271             patch_visible = self.patch.get_visible()
1272         else:
1273             patch_visible = True
1274 
1275         xaxis_visible = self.xaxis.get_visible()
1276         yaxis_visible = self.yaxis.get_visible()
1277 
1278         for axis in self._axis_map.values():
1279             axis.clear()  # Also resets the scale to linear.
1280         for spine in self.spines.values():
1281             spine.clear()
1282 
1283         self.ignore_existing_data_limits = True
1284         self.callbacks = cbook.CallbackRegistry(
1285             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1286 
1287         # update the minor locator for x and y axis based on rcParams
1288         if mpl.rcParams['xtick.minor.visible']:
1289             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1290         if mpl.rcParams['ytick.minor.visible']:
1291             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1292 
1293         self._xmargin = mpl.rcParams['axes.xmargin']
1294         self._ymargin = mpl.rcParams['axes.ymargin']
1295         self._tight = None
1296         self._use_sticky_edges = True
1297 
1298         self._get_lines = _process_plot_var_args(self)
1299         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1300 
1301         self._gridOn = mpl.rcParams['axes.grid']
1302         old_children, self._children = self._children, []
1303         for chld in old_children:
1304             chld.axes = chld.figure = None
1305         self._mouseover_set = _OrderedSet()
1306         self.child_axes = []
1307         self._current_image = None  # strictly for pyplot via _sci, _gci
1308         self._projection_init = None  # strictly for pyplot.subplot
1309         self.legend_ = None
1310         self.containers = []
1311 
1312         self.grid(False)  # Disable grid on init to use rcParameter
1313         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1314                   axis=mpl.rcParams['axes.grid.axis'])
1315         props = font_manager.FontProperties(
1316             size=mpl.rcParams['axes.titlesize'],
1317             weight=mpl.rcParams['axes.titleweight'])
1318 
1319         y = mpl.rcParams['axes.titley']
1320         if y is None:
1321             y = 1.0
1322             self._autotitlepos = True
1323         else:
1324             self._autotitlepos = False
1325 
1326         self.title = mtext.Text(
1327             x=0.5, y=y, text='',
1328             fontproperties=props,
1329             verticalalignment='baseline',
1330             horizontalalignment='center',
1331             )
1332         self._left_title = mtext.Text(
1333             x=0.0, y=y, text='',
1334             fontproperties=props.copy(),
1335             verticalalignment='baseline',
1336             horizontalalignment='left', )
1337         self._right_title = mtext.Text(
1338             x=1.0, y=y, text='',
1339             fontproperties=props.copy(),
1340             verticalalignment='baseline',
1341             horizontalalignment='right',
1342             )
1343         title_offset_points = mpl.rcParams['axes.titlepad']
1344         # refactor this out so it can be called in ax.set_title if
1345         # pad argument used...
1346         self._set_title_offset_trans(title_offset_points)
1347 
1348         for _title in (self.title, self._left_title, self._right_title):
1349             self._set_artist_props(_title)
1350 
1351         # The patch draws the background of the Axes.  We want this to be below
1352         # the other artists.  We use the frame to draw the edges so we are
1353         # setting the edgecolor to None.
1354         self.patch = self._gen_axes_patch()
1355         self.patch.set_figure(self.figure)
1356         self.patch.set_facecolor(self._facecolor)
1357         self.patch.set_edgecolor('none')
1358         self.patch.set_linewidth(0)
1359         self.patch.set_transform(self.transAxes)
1360 
1361         self.set_axis_on()
1362 
1363         self.xaxis.set_clip_path(self.patch)
1364         self.yaxis.set_clip_path(self.patch)
1365 
1366         self._shared_axes["x"].clean()
1367         self._shared_axes["y"].clean()
1368         if self._sharex is not None:
1369             self.xaxis.set_visible(xaxis_visible)
1370             self.patch.set_visible(patch_visible)
1371         if self._sharey is not None:
1372             self.yaxis.set_visible(yaxis_visible)
1373             self.patch.set_visible(patch_visible)
1374 
1375         # This comes last, as the call to _set_lim may trigger an autoscale (in
1376         # case of shared axes), requiring children to be already set up.
1377         for name, axis in self._axis_map.items():
1378             share = getattr(self, f"_share{name}")
1379             if share is not None:
1380                 getattr(self, f"share{name}")(share)
1381             else:
1382                 axis._set_scale("linear")
1383                 axis._set_lim(0, 1, auto=True)
1384         self._update_transScale()
1385 
1386         self.stale = True
1387 
1388     def clear(self):
1389         """Clear the Axes."""
1390         # Act as an alias, or as the superclass implementation depending on the
1391         # subclass implementation.
1392         if self._subclass_uses_cla:
1393             self.cla()
1394         else:
1395             self.__clear()
1396 
1397     def cla(self):
1398         """Clear the Axes."""
1399         # Act as an alias, or as the superclass implementation depending on the
1400         # subclass implementation.
1401         if self._subclass_uses_cla:
1402             self.__clear()
1403         else:
1404             self.clear()
1405 
1406     class ArtistList(Sequence):
1407         """
1408         A sublist of Axes children based on their type.
1409 
1410         The type-specific children sublists were made immutable in Matplotlib
1411         3.7.  In the future these artist lists may be replaced by tuples. Use
1412         as if this is a tuple already.
1413         """
1414         def __init__(self, axes, prop_name,
1415                      valid_types=None, invalid_types=None):
1416             """
1417             Parameters
1418             ----------
1419             axes : `~matplotlib.axes.Axes`
1420                 The Axes from which this sublist will pull the children
1421                 Artists.
1422             prop_name : str
1423                 The property name used to access this sublist from the Axes;
1424                 used to generate deprecation warnings.
1425             valid_types : list of type, optional
1426                 A list of types that determine which children will be returned
1427                 by this sublist. If specified, then the Artists in the sublist
1428                 must be instances of any of these types. If unspecified, then
1429                 any type of Artist is valid (unless limited by
1430                 *invalid_types*.)
1431             invalid_types : tuple, optional
1432                 A list of types that determine which children will *not* be
1433                 returned by this sublist. If specified, then Artists in the
1434                 sublist will never be an instance of these types. Otherwise, no
1435                 types will be excluded.
1436             """
1437             self._axes = axes
1438             self._prop_name = prop_name
1439             self._type_check = lambda artist: (
1440                 (not valid_types or isinstance(artist, valid_types)) and
1441                 (not invalid_types or not isinstance(artist, invalid_types))
1442             )
1443 
1444         def __repr__(self):
1445             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1446 
1447         def __len__(self):
1448             return sum(self._type_check(artist)
1449                        for artist in self._axes._children)
1450 
1451         def __iter__(self):
1452             for artist in list(self._axes._children):
1453                 if self._type_check(artist):
1454                     yield artist
1455 
1456         def __getitem__(self, key):
1457             return [artist
1458                     for artist in self._axes._children
1459                     if self._type_check(artist)][key]
1460 
1461         def __add__(self, other):
1462             if isinstance(other, (list, _AxesBase.ArtistList)):
1463                 return [*self, *other]
1464             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1465                 return (*self, *other)
1466             return NotImplemented
1467 
1468         def __radd__(self, other):
1469             if isinstance(other, list):
1470                 return other + list(self)
1471             if isinstance(other, tuple):
1472                 return other + tuple(self)
1473             return NotImplemented
1474 
1475     @property
1476     def artists(self):
1477         return self.ArtistList(self, 'artists', invalid_types=(
1478             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1479             mtable.Table, mtext.Text))
1480 
1481     @property
1482     def collections(self):
1483         return self.ArtistList(self, 'collections',
1484                                valid_types=mcoll.Collection)
1485 
1486     @property
1487     def images(self):
1488         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1489 
1490     @property
1491     def lines(self):
1492         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1493 
1494     @property
1495     def patches(self):
1496         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1497 
1498     @property
1499     def tables(self):
1500         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1501 
1502     @property
1503     def texts(self):
1504         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1505 
1506     def get_facecolor(self):
1507         """Get the facecolor of the Axes."""
1508         return self.patch.get_facecolor()
1509 
1510     def set_facecolor(self, color):
1511         """
1512         Set the facecolor of the Axes.
1513 
1514         Parameters
1515         ----------
1516         color : color
1517         """
1518         self._facecolor = color
1519         self.stale = True
1520         return self.patch.set_facecolor(color)
1521 
1522     def _set_title_offset_trans(self, title_offset_points):
1523         """
1524         Set the offset for the title either from :rc:`axes.titlepad`
1525         or from set_title kwarg ``pad``.
1526         """
1527         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1528                 0.0, title_offset_points / 72,
1529                 self.figure.dpi_scale_trans)
1530         for _title in (self.title, self._left_title, self._right_title):
1531             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1532             _title.set_clip_box(None)
1533 
1534     def set_prop_cycle(self, *args, **kwargs):
1535         """
1536         Set the property cycle of the Axes.
1537 
1538         The property cycle controls the style properties such as color,
1539         marker and linestyle of future plot commands. The style properties
1540         of data already added to the Axes are not modified.
1541 
1542         Call signatures::
1543 
1544           set_prop_cycle(cycler)
1545           set_prop_cycle(label=values[, label2=values2[, ...]])
1546           set_prop_cycle(label, values)
1547 
1548         Form 1 sets given `~cycler.Cycler` object.
1549 
1550         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1551         properties simultaneously and set it as the property cycle of the
1552         Axes. If multiple properties are given, their value lists must have
1553         the same length. This is just a shortcut for explicitly creating a
1554         cycler and passing it to the function, i.e. it's short for
1555         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1556 
1557         Form 3 creates a `~cycler.Cycler` for a single property and set it
1558         as the property cycle of the Axes. This form exists for compatibility
1559         with the original `cycler.cycler` interface. Its use is discouraged
1560         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1561 
1562         Parameters
1563         ----------
1564         cycler : Cycler
1565             Set the given Cycler. *None* resets to the cycle defined by the
1566             current style.
1567 
1568         label : str
1569             The property key. Must be a valid `.Artist` property.
1570             For example, 'color' or 'linestyle'. Aliases are allowed,
1571             such as 'c' for 'color' and 'lw' for 'linewidth'.
1572 
1573         values : iterable
1574             Finite-length iterable of the property values. These values
1575             are validated and will raise a ValueError if invalid.
1576 
1577         See Also
1578         --------
1579         matplotlib.rcsetup.cycler
1580             Convenience function for creating validated cyclers for properties.
1581         cycler.cycler
1582             The original function for creating unvalidated cyclers.
1583 
1584         Examples
1585         --------
1586         Setting the property cycle for a single property:
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1589 
1590         Setting the property cycle for simultaneously cycling over multiple
1591         properties (e.g. red circle, green plus, blue cross):
1592 
1593         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1594         ...                   marker=['o', '+', 'x'])
1595 
1596         """
1597         if args and kwargs:
1598             raise TypeError("Cannot supply both positional and keyword "
1599                             "arguments to this method.")
1600         # Can't do `args == (None,)` as that crashes cycler.
1601         if len(args) == 1 and args[0] is None:
1602             prop_cycle = None
1603         else:
1604             prop_cycle = cycler(*args, **kwargs)
1605         self._get_lines.set_prop_cycle(prop_cycle)
1606         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1607 
1608     def get_aspect(self):
1609         """
1610         Return the aspect ratio of the axes scaling.
1611 
1612         This is either "auto" or a float giving the ratio of y/x-scale.
1613         """
1614         return self._aspect
1615 
1616     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1617         """
1618         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1619 
1620         Parameters
1621         ----------
1622         aspect : {'auto', 'equal'} or float
1623             Possible values:
1624 
1625             - 'auto': fill the position rectangle with data.
1626             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1627             - *float*: The displayed size of 1 unit in y-data coordinates will
1628               be *aspect* times the displayed size of 1 unit in x-data
1629               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1630               will be rendered with a height of twice its width.
1631 
1632         adjustable : None or {'box', 'datalim'}, optional
1633             If not ``None``, this defines which parameter will be adjusted to
1634             meet the required aspect. See `.set_adjustable` for further
1635             details.
1636 
1637         anchor : None or str or (float, float), optional
1638             If not ``None``, this defines where the Axes will be drawn if there
1639             is extra space due to aspect constraints. The most common way
1640             to specify the anchor are abbreviations of cardinal directions:
1641 
1642             =====   =====================
1643             value   description
1644             =====   =====================
1645             'C'     centered
1646             'SW'    lower left corner
1647             'S'     middle of bottom edge
1648             'SE'    lower right corner
1649             etc.
1650             =====   =====================
1651 
1652             See `~.Axes.set_anchor` for further details.
1653 
1654         share : bool, default: False
1655             If ``True``, apply the settings to all shared Axes.
1656 
1657         See Also
1658         --------
1659         matplotlib.axes.Axes.set_adjustable
1660             Set how the Axes adjusts to achieve the required aspect ratio.
1661         matplotlib.axes.Axes.set_anchor
1662             Set the position in case of extra space.
1663         """
1664         if cbook._str_equal(aspect, 'equal'):
1665             aspect = 1
1666         if not cbook._str_equal(aspect, 'auto'):
1667             aspect = float(aspect)  # raise ValueError if necessary
1668             if aspect <= 0 or not np.isfinite(aspect):
1669                 raise ValueError("aspect must be finite and positive ")
1670 
1671         if share:
1672             axes = {sibling for name in self._axis_names
1673                     for sibling in self._shared_axes[name].get_siblings(self)}
1674         else:
1675             axes = [self]
1676 
1677         for ax in axes:
1678             ax._aspect = aspect
1679 
1680         if adjustable is None:
1681             adjustable = self._adjustable
1682         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1683 
1684         if anchor is not None:
1685             self.set_anchor(anchor, share=share)
1686         self.stale = True
1687 
1688     def get_adjustable(self):
1689         """
1690         Return whether the Axes will adjust its physical dimension ('box') or
1691         its data limits ('datalim') to achieve the desired aspect ratio.
1692 
1693         See Also
1694         --------
1695         matplotlib.axes.Axes.set_adjustable
1696             Set how the Axes adjusts to achieve the required aspect ratio.
1697         matplotlib.axes.Axes.set_aspect
1698             For a description of aspect handling.
1699         """
1700         return self._adjustable
1701 
1702     def set_adjustable(self, adjustable, share=False):
1703         """
1704         Set how the Axes adjusts to achieve the required aspect ratio.
1705 
1706         Parameters
1707         ----------
1708         adjustable : {'box', 'datalim'}
1709             If 'box', change the physical dimensions of the Axes.
1710             If 'datalim', change the ``x`` or ``y`` data limits.
1711 
1712         share : bool, default: False
1713             If ``True``, apply the settings to all shared Axes.
1714 
1715         See Also
1716         --------
1717         matplotlib.axes.Axes.set_aspect
1718             For a description of aspect handling.
1719 
1720         Notes
1721         -----
1722         Shared Axes (of which twinned Axes are a special case)
1723         impose restrictions on how aspect ratios can be imposed.
1724         For twinned Axes, use 'datalim'.  For Axes that share both
1725         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1726         may be used.  These limitations are partly a requirement
1727         to avoid over-specification, and partly a result of the
1728         particular implementation we are currently using, in
1729         which the adjustments for aspect ratios are done sequentially
1730         and independently on each Axes as it is drawn.
1731         """
1732         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1733         if share:
1734             axs = {sibling for name in self._axis_names
1735                    for sibling in self._shared_axes[name].get_siblings(self)}
1736         else:
1737             axs = [self]
1738         if (adjustable == "datalim"
1739                 and any(getattr(ax.get_data_ratio, "__func__", None)
1740                         != _AxesBase.get_data_ratio
1741                         for ax in axs)):
1742             # Limits adjustment by apply_aspect assumes that the axes' aspect
1743             # ratio can be computed from the data limits and scales.
1744             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1745                              "Axes which override 'get_data_ratio'")
1746         for ax in axs:
1747             ax._adjustable = adjustable
1748         self.stale = True
1749 
1750     def get_box_aspect(self):
1751         """
1752         Return the Axes box aspect, i.e. the ratio of height to width.
1753 
1754         The box aspect is ``None`` (i.e. chosen depending on the available
1755         figure space) unless explicitly specified.
1756 
1757         See Also
1758         --------
1759         matplotlib.axes.Axes.set_box_aspect
1760             for a description of box aspect.
1761         matplotlib.axes.Axes.set_aspect
1762             for a description of aspect handling.
1763         """
1764         return self._box_aspect
1765 
1766     def set_box_aspect(self, aspect=None):
1767         """
1768         Set the Axes box aspect, i.e. the ratio of height to width.
1769 
1770         This defines the aspect of the Axes in figure space and is not to be
1771         confused with the data aspect (see `~.Axes.set_aspect`).
1772 
1773         Parameters
1774         ----------
1775         aspect : float or None
1776             Changes the physical dimensions of the Axes, such that the ratio
1777             of the Axes height to the Axes width in physical units is equal to
1778             *aspect*. Defining a box aspect will change the *adjustable*
1779             property to 'datalim' (see `~.Axes.set_adjustable`).
1780 
1781             *None* will disable a fixed box aspect so that height and width
1782             of the Axes are chosen independently.
1783 
1784         See Also
1785         --------
1786         matplotlib.axes.Axes.set_aspect
1787             for a description of aspect handling.
1788         """
1789         axs = {*self._twinned_axes.get_siblings(self),
1790                *self._twinned_axes.get_siblings(self)}
1791 
1792         if aspect is not None:
1793             aspect = float(aspect)
1794             # when box_aspect is set to other than ´None`,
1795             # adjustable must be "datalim"
1796             for ax in axs:
1797                 ax.set_adjustable("datalim")
1798 
1799         for ax in axs:
1800             ax._box_aspect = aspect
1801             ax.stale = True
1802 
1803     def get_anchor(self):
1804         """
1805         Get the anchor location.
1806 
1807         See Also
1808         --------
1809         matplotlib.axes.Axes.set_anchor
1810             for a description of the anchor.
1811         matplotlib.axes.Axes.set_aspect
1812             for a description of aspect handling.
1813         """
1814         return self._anchor
1815 
1816     def set_anchor(self, anchor, share=False):
1817         """
1818         Define the anchor location.
1819 
1820         The actual drawing area (active position) of the Axes may be smaller
1821         than the Bbox (original position) when a fixed aspect is required. The
1822         anchor defines where the drawing area will be located within the
1823         available space.
1824 
1825         Parameters
1826         ----------
1827         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1828             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1829             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1830             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1831             for (*x*, *y*) coordinates, as shown in the following diagram::
1832 
1833                ┌─────────────────┬─────────────────┬─────────────────┐
1834                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1835                ├─────────────────┼─────────────────┼─────────────────┤
1836                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1837                ├─────────────────┼─────────────────┼─────────────────┤
1838                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1839                └─────────────────┴─────────────────┴─────────────────┘
1840 
1841         share : bool, default: False
1842             If ``True``, apply the settings to all shared Axes.
1843 
1844         See Also
1845         --------
1846         matplotlib.axes.Axes.set_aspect
1847             for a description of aspect handling.
1848         """
1849         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1850             raise ValueError('argument must be among %s' %
1851                              ', '.join(mtransforms.Bbox.coefs))
1852         if share:
1853             axes = {sibling for name in self._axis_names
1854                     for sibling in self._shared_axes[name].get_siblings(self)}
1855         else:
1856             axes = [self]
1857         for ax in axes:
1858             ax._anchor = anchor
1859 
1860         self.stale = True
1861 
1862     def get_data_ratio(self):
1863         """
1864         Return the aspect ratio of the scaled data.
1865 
1866         Notes
1867         -----
1868         This method is intended to be overridden by new projection types.
1869         """
1870         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1871         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1872         xsize = max(abs(txmax - txmin), 1e-30)
1873         ysize = max(abs(tymax - tymin), 1e-30)
1874         return ysize / xsize
1875 
1876     def apply_aspect(self, position=None):
1877         """
1878         Adjust the Axes for a specified data aspect ratio.
1879 
1880         Depending on `.get_adjustable` this will modify either the
1881         Axes box (position) or the view limits. In the former case,
1882         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1883 
1884         Parameters
1885         ----------
1886         position : None or .Bbox
1887             If not ``None``, this defines the position of the
1888             Axes within the figure as a Bbox. See `~.Axes.get_position`
1889             for further details.
1890 
1891         Notes
1892         -----
1893         This is called automatically when each Axes is drawn.  You may need
1894         to call it yourself if you need to update the Axes position and/or
1895         view limits before the Figure is drawn.
1896 
1897         See Also
1898         --------
1899         matplotlib.axes.Axes.set_aspect
1900             For a description of aspect ratio handling.
1901         matplotlib.axes.Axes.set_adjustable
1902             Set how the Axes adjusts to achieve the required aspect ratio.
1903         matplotlib.axes.Axes.set_anchor
1904             Set the position in case of extra space.
1905         """
1906         if position is None:
1907             position = self.get_position(original=True)
1908 
1909         aspect = self.get_aspect()
1910 
1911         if aspect == 'auto' and self._box_aspect is None:
1912             self._set_position(position, which='active')
1913             return
1914 
1915         trans = self.get_figure().transSubfigure
1916         bb = mtransforms.Bbox.unit().transformed(trans)
1917         # this is the physical aspect of the panel (or figure):
1918         fig_aspect = bb.height / bb.width
1919 
1920         if self._adjustable == 'box':
1921             if self in self._twinned_axes:
1922                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1923                                    "twinned Axes; use 'datalim' instead")
1924             box_aspect = aspect * self.get_data_ratio()
1925             pb = position.frozen()
1926             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1927             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1928             return
1929 
1930         # The following is only seen if self._adjustable == 'datalim'
1931         if self._box_aspect is not None:
1932             pb = position.frozen()
1933             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1934             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1935             if aspect == "auto":
1936                 return
1937 
1938         # reset active to original in case it had been changed by prior use
1939         # of 'box'
1940         if self._box_aspect is None:
1941             self._set_position(position, which='active')
1942         else:
1943             position = pb1.anchored(self.get_anchor(), pb)
1944 
1945         x_trf = self.xaxis.get_transform()
1946         y_trf = self.yaxis.get_transform()
1947         xmin, xmax = x_trf.transform(self.get_xbound())
1948         ymin, ymax = y_trf.transform(self.get_ybound())
1949         xsize = max(abs(xmax - xmin), 1e-30)
1950         ysize = max(abs(ymax - ymin), 1e-30)
1951 
1952         box_aspect = fig_aspect * (position.height / position.width)
1953         data_ratio = box_aspect / aspect
1954 
1955         y_expander = data_ratio * xsize / ysize - 1
1956         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1957         if abs(y_expander) < 0.005:
1958             return
1959 
1960         dL = self.dataLim
1961         x0, x1 = x_trf.transform(dL.intervalx)
1962         y0, y1 = y_trf.transform(dL.intervaly)
1963         xr = 1.05 * (x1 - x0)
1964         yr = 1.05 * (y1 - y0)
1965 
1966         xmarg = xsize - xr
1967         ymarg = ysize - yr
1968         Ysize = data_ratio * xsize
1969         Xsize = ysize / data_ratio
1970         Xmarg = Xsize - xr
1971         Ymarg = Ysize - yr
1972         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1973         xm = 0
1974         ym = 0
1975 
1976         shared_x = self in self._shared_axes["x"]
1977         shared_y = self in self._shared_axes["y"]
1978 
1979         if shared_x and shared_y:
1980             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1981                                "axis('equal') are not allowed when both axes "
1982                                "are shared.  Try set_aspect(..., "
1983                                "adjustable='box').")
1984 
1985         # If y is shared, then we are only allowed to change x, etc.
1986         if shared_y:
1987             adjust_y = False
1988         else:
1989             if xmarg > xm and ymarg > ym:
1990                 adjy = ((Ymarg > 0 and y_expander < 0) or
1991                         (Xmarg < 0 and y_expander > 0))
1992             else:
1993                 adjy = y_expander > 0
1994             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1995 
1996         if adjust_y:
1997             yc = 0.5 * (ymin + ymax)
1998             y0 = yc - Ysize / 2.0
1999             y1 = yc + Ysize / 2.0
2000             self.set_ybound(y_trf.inverted().transform([y0, y1]))
2001         else:
2002             xc = 0.5 * (xmin + xmax)
2003             x0 = xc - Xsize / 2.0
2004             x1 = xc + Xsize / 2.0
2005             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2006 
2007     def axis(self, arg=None, /, *, emit=True, **kwargs):
2008         """
2009         Convenience method to get or set some axis properties.
2010 
2011         Call signatures::
2012 
2013           xmin, xmax, ymin, ymax = axis()
2014           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2015           xmin, xmax, ymin, ymax = axis(option)
2016           xmin, xmax, ymin, ymax = axis(**kwargs)
2017 
2018         Parameters
2019         ----------
2020         xmin, xmax, ymin, ymax : float, optional
2021             The axis limits to be set.  This can also be achieved using ::
2022 
2023                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2024 
2025         option : bool or str
2026             If a bool, turns axis lines and labels on or off. If a string,
2027             possible values are:
2028 
2029             ======== ==========================================================
2030             Value    Description
2031             ======== ==========================================================
2032             'on'     Turn on axis lines and labels. Same as ``True``.
2033             'off'    Turn off axis lines and labels. Same as ``False``.
2034             'equal'  Set equal scaling (i.e., make circles circular) by
2035                      changing axis limits. This is the same as
2036                      ``ax.set_aspect('equal', adjustable='datalim')``.
2037                      Explicit data limits may not be respected in this case.
2038             'scaled' Set equal scaling (i.e., make circles circular) by
2039                      changing dimensions of the plot box. This is the same as
2040                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2041                      Additionally, further autoscaling will be disabled.
2042             'tight'  Set limits just large enough to show all data, then
2043                      disable further autoscaling.
2044             'auto'   Automatic scaling (fill plot box with data).
2045             'image'  'scaled' with axis limits equal to data limits.
2046             'square' Square plot; similar to 'scaled', but initially forcing
2047                      ``xmax-xmin == ymax-ymin``.
2048             ======== ==========================================================
2049 
2050         emit : bool, default: True
2051             Whether observers are notified of the axis limit change.
2052             This option is passed on to `~.Axes.set_xlim` and
2053             `~.Axes.set_ylim`.
2054 
2055         Returns
2056         -------
2057         xmin, xmax, ymin, ymax : float
2058             The axis limits.
2059 
2060         See Also
2061         --------
2062         matplotlib.axes.Axes.set_xlim
2063         matplotlib.axes.Axes.set_ylim
2064         """
2065         if isinstance(arg, (str, bool)):
2066             if arg is True:
2067                 arg = 'on'
2068             if arg is False:
2069                 arg = 'off'
2070             arg = arg.lower()
2071             if arg == 'on':
2072                 self.set_axis_on()
2073             elif arg == 'off':
2074                 self.set_axis_off()
2075             elif arg in [
2076                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2077                 self.set_autoscale_on(True)
2078                 self.set_aspect('auto')
2079                 self.autoscale_view(tight=False)
2080                 if arg == 'equal':
2081                     self.set_aspect('equal', adjustable='datalim')
2082                 elif arg == 'scaled':
2083                     self.set_aspect('equal', adjustable='box', anchor='C')
2084                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2085                 elif arg == 'tight':
2086                     self.autoscale_view(tight=True)
2087                     self.set_autoscale_on(False)
2088                 elif arg == 'image':
2089                     self.autoscale_view(tight=True)
2090                     self.set_autoscale_on(False)
2091                     self.set_aspect('equal', adjustable='box', anchor='C')
2092                 elif arg == 'square':
2093                     self.set_aspect('equal', adjustable='box', anchor='C')
2094                     self.set_autoscale_on(False)
2095                     xlim = self.get_xlim()
2096                     ylim = self.get_ylim()
2097                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2098                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2099                                   emit=emit, auto=False)
2100                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2101                                   emit=emit, auto=False)
2102             else:
2103                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2104                                  "try 'on' or 'off'")
2105         else:
2106             if arg is not None:
2107                 try:
2108                     xmin, xmax, ymin, ymax = arg
2109                 except (TypeError, ValueError) as err:
2110                     raise TypeError('the first argument to axis() must be an '
2111                                     'iterable of the form '
2112                                     '[xmin, xmax, ymin, ymax]') from err
2113             else:
2114                 xmin = kwargs.pop('xmin', None)
2115                 xmax = kwargs.pop('xmax', None)
2116                 ymin = kwargs.pop('ymin', None)
2117                 ymax = kwargs.pop('ymax', None)
2118             xauto = (None  # Keep autoscale state as is.
2119                      if xmin is None and xmax is None
2120                      else False)  # Turn off autoscale.
2121             yauto = (None
2122                      if ymin is None and ymax is None
2123                      else False)
2124             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2125             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2126         if kwargs:
2127             raise _api.kwarg_error("axis", kwargs)
2128         return (*self.get_xlim(), *self.get_ylim())
2129 
2130     def get_legend(self):
2131         """Return the `.Legend` instance, or None if no legend is defined."""
2132         return self.legend_
2133 
2134     def get_images(self):
2135         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2136         return cbook.silent_list('AxesImage', self.images)
2137 
2138     def get_lines(self):
2139         """Return a list of lines contained by the Axes."""
2140         return cbook.silent_list('Line2D', self.lines)
2141 
2142     def get_xaxis(self):
2143         """
2144         [*Discouraged*] Return the XAxis instance.
2145 
2146         .. admonition:: Discouraged
2147 
2148             The use of this function is discouraged. You should instead
2149             directly access the attribute ``ax.xaxis``.
2150         """
2151         return self.xaxis
2152 
2153     def get_yaxis(self):
2154         """
2155         [*Discouraged*] Return the YAxis instance.
2156 
2157         .. admonition:: Discouraged
2158 
2159             The use of this function is discouraged. You should instead
2160             directly access the attribute ``ax.yaxis``.
2161         """
2162         return self.yaxis
2163 
2164     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2165     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2166     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2167     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2168 
2169     # Adding and tracking artists
2170 
2171     def _sci(self, im):
2172         """
2173         Set the current image.
2174 
2175         This image will be the target of colormap functions like
2176         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2177         current image is an attribute of the current Axes.
2178         """
2179         _api.check_isinstance(
2180             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2181             im=im)
2182         if isinstance(im, mpl.contour.ContourSet):
2183             if im.collections[0] not in self._children:
2184                 raise ValueError("ContourSet must be in current Axes")
2185         elif im not in self._children:
2186             raise ValueError("Argument must be an image, collection, or "
2187                              "ContourSet in this Axes")
2188         self._current_image = im
2189 
2190     def _gci(self):
2191         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2192         return self._current_image
2193 
2194     def has_data(self):
2195         """
2196         Return whether any artists have been added to the Axes.
2197 
2198         This should not be used to determine whether the *dataLim*
2199         need to be updated, and may not actually be useful for
2200         anything.
2201         """
2202         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2203                                   mlines.Line2D, mpatches.Patch))
2204                    for a in self._children)
2205 
2206     def add_artist(self, a):
2207         """
2208         Add an `.Artist` to the Axes; return the artist.
2209 
2210         Use `add_artist` only for artists for which there is no dedicated
2211         "add" method; and if necessary, use a method such as `update_datalim`
2212         to manually update the dataLim if the artist is to be included in
2213         autoscaling.
2214 
2215         If no ``transform`` has been specified when creating the artist (e.g.
2216         ``artist.get_transform() == None``) then the transform is set to
2217         ``ax.transData``.
2218         """
2219         a.axes = self
2220         self._children.append(a)
2221         a._remove_method = self._children.remove
2222         self._set_artist_props(a)
2223         a.set_clip_path(self.patch)
2224         self.stale = True
2225         return a
2226 
2227     def add_child_axes(self, ax):
2228         """
2229         Add an `.AxesBase` to the Axes' children; return the child Axes.
2230 
2231         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2232         """
2233 
2234         # normally Axes have themselves as the Axes, but these need to have
2235         # their parent...
2236         # Need to bypass the getter...
2237         ax._axes = self
2238         ax.stale_callback = martist._stale_axes_callback
2239 
2240         self.child_axes.append(ax)
2241         ax._remove_method = self.child_axes.remove
2242         self.stale = True
2243         return ax
2244 
2245     def add_collection(self, collection, autolim=True):
2246         """
2247         Add a `.Collection` to the Axes; return the collection.
2248         """
2249         _api.check_isinstance(mcoll.Collection, collection=collection)
2250         label = collection.get_label()
2251         if not label:
2252             collection.set_label(f'_child{len(self._children)}')
2253         self._children.append(collection)
2254         collection._remove_method = self._children.remove
2255         self._set_artist_props(collection)
2256 
2257         if collection.get_clip_path() is None:
2258             collection.set_clip_path(self.patch)
2259 
2260         if autolim:
2261             # Make sure viewLim is not stale (mostly to match
2262             # pre-lazy-autoscale behavior, which is not really better).
2263             self._unstale_viewLim()
2264             datalim = collection.get_datalim(self.transData)
2265             points = datalim.get_points()
2266             if not np.isinf(datalim.minpos).all():
2267                 # By definition, if minpos (minimum positive value) is set
2268                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2269                 # and minpos would be superfluous. However, we add minpos to
2270                 # the call so that self.dataLim will update its own minpos.
2271                 # This ensures that log scales see the correct minimum.
2272                 points = np.concatenate([points, [datalim.minpos]])
2273             self.update_datalim(points)
2274 
2275         self.stale = True
2276         return collection
2277 
2278     def add_image(self, image):
2279         """
2280         Add an `.AxesImage` to the Axes; return the image.
2281         """
2282         _api.check_isinstance(mimage.AxesImage, image=image)
2283         self._set_artist_props(image)
2284         if not image.get_label():
2285             image.set_label(f'_child{len(self._children)}')
2286         self._children.append(image)
2287         image._remove_method = self._children.remove
2288         self.stale = True
2289         return image
2290 
2291     def _update_image_limits(self, image):
2292         xmin, xmax, ymin, ymax = image.get_extent()
2293         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2294 
2295     def add_line(self, line):
2296         """
2297         Add a `.Line2D` to the Axes; return the line.
2298         """
2299         _api.check_isinstance(mlines.Line2D, line=line)
2300         self._set_artist_props(line)
2301         if line.get_clip_path() is None:
2302             line.set_clip_path(self.patch)
2303 
2304         self._update_line_limits(line)
2305         if not line.get_label():
2306             line.set_label(f'_child{len(self._children)}')
2307         self._children.append(line)
2308         line._remove_method = self._children.remove
2309         self.stale = True
2310         return line
2311 
2312     def _add_text(self, txt):
2313         """
2314         Add a `.Text` to the Axes; return the text.
2315         """
2316         _api.check_isinstance(mtext.Text, txt=txt)
2317         self._set_artist_props(txt)
2318         self._children.append(txt)
2319         txt._remove_method = self._children.remove
2320         self.stale = True
2321         return txt
2322 
2323     def _update_line_limits(self, line):
2324         """
2325         Figures out the data limit of the given line, updating self.dataLim.
2326         """
2327         path = line.get_path()
2328         if path.vertices.size == 0:
2329             return
2330 
2331         line_trf = line.get_transform()
2332 
2333         if line_trf == self.transData:
2334             data_path = path
2335         elif any(line_trf.contains_branch_seperately(self.transData)):
2336             # Compute the transform from line coordinates to data coordinates.
2337             trf_to_data = line_trf - self.transData
2338             # If transData is affine we can use the cached non-affine component
2339             # of line's path (since the non-affine part of line_trf is
2340             # entirely encapsulated in trf_to_data).
2341             if self.transData.is_affine:
2342                 line_trans_path = line._get_transformed_path()
2343                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2344                 data_path = trf_to_data.transform_path_affine(na_path)
2345             else:
2346                 data_path = trf_to_data.transform_path(path)
2347         else:
2348             # For backwards compatibility we update the dataLim with the
2349             # coordinate range of the given path, even though the coordinate
2350             # systems are completely different. This may occur in situations
2351             # such as when ax.transAxes is passed through for absolute
2352             # positioning.
2353             data_path = path
2354 
2355         if not data_path.vertices.size:
2356             return
2357 
2358         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2359         if self.name != "rectilinear":
2360             # This block is mostly intended to handle axvline in polar plots,
2361             # for which updatey would otherwise be True.
2362             if updatex and line_trf == self.get_yaxis_transform():
2363                 updatex = False
2364             if updatey and line_trf == self.get_xaxis_transform():
2365                 updatey = False
2366         self.dataLim.update_from_path(data_path,
2367                                       self.ignore_existing_data_limits,
2368                                       updatex=updatex, updatey=updatey)
2369         self.ignore_existing_data_limits = False
2370 
2371     def add_patch(self, p):
2372         """
2373         Add a `.Patch` to the Axes; return the patch.
2374         """
2375         _api.check_isinstance(mpatches.Patch, p=p)
2376         self._set_artist_props(p)
2377         if p.get_clip_path() is None:
2378             p.set_clip_path(self.patch)
2379         self._update_patch_limits(p)
2380         self._children.append(p)
2381         p._remove_method = self._children.remove
2382         return p
2383 
2384     def _update_patch_limits(self, patch):
2385         """Update the data limits for the given patch."""
2386         # hist can add zero height Rectangles, which is useful to keep
2387         # the bins, counts and patches lined up, but it throws off log
2388         # scaling.  We'll ignore rects with zero height or width in
2389         # the auto-scaling
2390 
2391         # cannot check for '==0' since unitized data may not compare to zero
2392         # issue #2150 - we update the limits if patch has non zero width
2393         # or height.
2394         if (isinstance(patch, mpatches.Rectangle) and
2395                 ((not patch.get_width()) and (not patch.get_height()))):
2396             return
2397         p = patch.get_path()
2398         # Get all vertices on the path
2399         # Loop through each segment to get extrema for Bezier curve sections
2400         vertices = []
2401         for curve, code in p.iter_bezier(simplify=False):
2402             # Get distance along the curve of any extrema
2403             _, dzeros = curve.axis_aligned_extrema()
2404             # Calculate vertices of start, end and any extrema in between
2405             vertices.append(curve([0, *dzeros, 1]))
2406 
2407         if len(vertices):
2408             vertices = np.row_stack(vertices)
2409 
2410         patch_trf = patch.get_transform()
2411         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2412         if not (updatex or updatey):
2413             return
2414         if self.name != "rectilinear":
2415             # As in _update_line_limits, but for axvspan.
2416             if updatex and patch_trf == self.get_yaxis_transform():
2417                 updatex = False
2418             if updatey and patch_trf == self.get_xaxis_transform():
2419                 updatey = False
2420         trf_to_data = patch_trf - self.transData
2421         xys = trf_to_data.transform(vertices)
2422         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2423 
2424     def add_table(self, tab):
2425         """
2426         Add a `.Table` to the Axes; return the table.
2427         """
2428         _api.check_isinstance(mtable.Table, tab=tab)
2429         self._set_artist_props(tab)
2430         self._children.append(tab)
2431         tab.set_clip_path(self.patch)
2432         tab._remove_method = self._children.remove
2433         return tab
2434 
2435     def add_container(self, container):
2436         """
2437         Add a `.Container` to the Axes' containers; return the container.
2438         """
2439         label = container.get_label()
2440         if not label:
2441             container.set_label('_container%d' % len(self.containers))
2442         self.containers.append(container)
2443         container._remove_method = self.containers.remove
2444         return container
2445 
2446     def _unit_change_handler(self, axis_name, event=None):
2447         """
2448         Process axis units changes: requests updates to data and view limits.
2449         """
2450         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2451             return functools.partial(
2452                 self._unit_change_handler, axis_name, event=object())
2453         _api.check_in_list(self._axis_map, axis_name=axis_name)
2454         for line in self.lines:
2455             line.recache_always()
2456         self.relim()
2457         self._request_autoscale_view(axis_name)
2458 
2459     def relim(self, visible_only=False):
2460         """
2461         Recompute the data limits based on current artists.
2462 
2463         At present, `.Collection` instances are not supported.
2464 
2465         Parameters
2466         ----------
2467         visible_only : bool, default: False
2468             Whether to exclude invisible artists.
2469         """
2470         # Collections are deliberately not supported (yet); see
2471         # the TODO note in artists.py.
2472         self.dataLim.ignore(True)
2473         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2474         self.ignore_existing_data_limits = True
2475 
2476         for artist in self._children:
2477             if not visible_only or artist.get_visible():
2478                 if isinstance(artist, mlines.Line2D):
2479                     self._update_line_limits(artist)
2480                 elif isinstance(artist, mpatches.Patch):
2481                     self._update_patch_limits(artist)
2482                 elif isinstance(artist, mimage.AxesImage):
2483                     self._update_image_limits(artist)
2484 
2485     def update_datalim(self, xys, updatex=True, updatey=True):
2486         """
2487         Extend the `~.Axes.dataLim` Bbox to include the given points.
2488 
2489         If no data is set currently, the Bbox will ignore its limits and set
2490         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2491         compute the bounds of the union of its current data and the data in
2492         *xys*.
2493 
2494         Parameters
2495         ----------
2496         xys : 2D array-like
2497             The points to include in the data limits Bbox. This can be either
2498             a list of (x, y) tuples or a Nx2 array.
2499 
2500         updatex, updatey : bool, default: True
2501             Whether to update the x/y limits.
2502         """
2503         xys = np.asarray(xys)
2504         if not np.any(np.isfinite(xys)):
2505             return
2506         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2507                                          updatex=updatex, updatey=updatey)
2508         self.ignore_existing_data_limits = False
2509 
2510     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2511         """
2512         Set axis units based on *datasets* and *kwargs*, and optionally apply
2513         unit conversions to *datasets*.
2514 
2515         Parameters
2516         ----------
2517         datasets : list
2518             List of (axis_name, dataset) pairs (where the axis name is defined
2519             as in `._axis_map`).  Individual datasets can also be None
2520             (which gets passed through).
2521         kwargs : dict
2522             Other parameters from which unit info (i.e., the *xunits*,
2523             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2524             polar) entries) is popped, if present.  Note that this dict is
2525             mutated in-place!
2526         convert : bool, default: True
2527             Whether to return the original datasets or the converted ones.
2528 
2529         Returns
2530         -------
2531         list
2532             Either the original datasets if *convert* is False, or the
2533             converted ones if *convert* is True (the default).
2534         """
2535         # The API makes datasets a list of pairs rather than an axis_name to
2536         # dataset mapping because it is sometimes necessary to process multiple
2537         # datasets for a single axis, and concatenating them may be tricky
2538         # (e.g. if some are scalars, etc.).
2539         datasets = datasets or []
2540         kwargs = kwargs or {}
2541         axis_map = self._axis_map
2542         for axis_name, data in datasets:
2543             try:
2544                 axis = axis_map[axis_name]
2545             except KeyError:
2546                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2547             # Update from data if axis is already set but no unit is set yet.
2548             if (axis is not None and
2549                     data is not None and
2550                     not axis._have_units_and_converter()):
2551                 axis.update_units(data)
2552         for axis_name, axis in axis_map.items():
2553             # Return if no axis is set.
2554             if axis is None:
2555                 continue
2556             # Check for units in the kwargs, and if present update axis.
2557             units = kwargs.pop(f"{axis_name}units", axis.units)
2558             if self.name == "polar":
2559                 # Special case: polar supports "thetaunits"/"runits".
2560                 polar_units = {"x": "thetaunits", "y": "runits"}
2561                 units = kwargs.pop(polar_units[axis_name], units)
2562             if units != axis.units and units is not None:
2563                 axis.set_units(units)
2564                 # If the units being set imply a different converter,
2565                 # we need to update again.
2566                 for dataset_axis_name, data in datasets:
2567                     if dataset_axis_name == axis_name and data is not None:
2568                         axis.update_units(data)
2569         return [axis_map[axis_name].convert_units(data)
2570                 if convert and data is not None else data
2571                 for axis_name, data in datasets]
2572 
2573     def in_axes(self, mouseevent):
2574         """
2575         Return whether the given event (in display coords) is in the Axes.
2576         """
2577         return self.patch.contains(mouseevent)[0]
2578 
2579     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2580     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2581     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2582     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2583 
2584     def get_autoscale_on(self):
2585         """Return True if each axis is autoscaled, False otherwise."""
2586         return all(axis._get_autoscale_on()
2587                    for axis in self._axis_map.values())
2588 
2589     def set_autoscale_on(self, b):
2590         """
2591         Set whether autoscaling is applied to each axis on the next draw or
2592         call to `.Axes.autoscale_view`.
2593 
2594         Parameters
2595         ----------
2596         b : bool
2597         """
2598         for axis in self._axis_map.values():
2599             axis._set_autoscale_on(b)
2600 
2601     @property
2602     def use_sticky_edges(self):
2603         """
2604         When autoscaling, whether to obey all `Artist.sticky_edges`.
2605 
2606         Default is ``True``.
2607 
2608         Setting this to ``False`` ensures that the specified margins
2609         will be applied, even if the plot includes an image, for
2610         example, which would otherwise force a view limit to coincide
2611         with its data limit.
2612 
2613         The changing this property does not change the plot until
2614         `autoscale` or `autoscale_view` is called.
2615         """
2616         return self._use_sticky_edges
2617 
2618     @use_sticky_edges.setter
2619     def use_sticky_edges(self, b):
2620         self._use_sticky_edges = bool(b)
2621         # No effect until next autoscaling, which will mark the Axes as stale.
2622 
2623     def set_xmargin(self, m):
2624         """
2625         Set padding of X data limits prior to autoscaling.
2626 
2627         *m* times the data interval will be added to each end of that interval
2628         before it is used in autoscaling.  If *m* is negative, this will clip
2629         the data range instead of expanding it.
2630 
2631         For example, if your data is in the range [0, 2], a margin of 0.1 will
2632         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2633         of [0.2, 1.8].
2634 
2635         Parameters
2636         ----------
2637         m : float greater than -0.5
2638         """
2639         if m <= -0.5:
2640             raise ValueError("margin must be greater than -0.5")
2641         self._xmargin = m
2642         self._request_autoscale_view("x")
2643         self.stale = True
2644 
2645     def set_ymargin(self, m):
2646         """
2647         Set padding of Y data limits prior to autoscaling.
2648 
2649         *m* times the data interval will be added to each end of that interval
2650         before it is used in autoscaling.  If *m* is negative, this will clip
2651         the data range instead of expanding it.
2652 
2653         For example, if your data is in the range [0, 2], a margin of 0.1 will
2654         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2655         of [0.2, 1.8].
2656 
2657         Parameters
2658         ----------
2659         m : float greater than -0.5
2660         """
2661         if m <= -0.5:
2662             raise ValueError("margin must be greater than -0.5")
2663         self._ymargin = m
2664         self._request_autoscale_view("y")
2665         self.stale = True
2666 
2667     def margins(self, *margins, x=None, y=None, tight=True):
2668         """
2669         Set or retrieve autoscaling margins.
2670 
2671         The padding added to each limit of the Axes is the *margin*
2672         times the data interval. All input parameters must be floats
2673         within the range [0, 1]. Passing both positional and keyword
2674         arguments is invalid and will raise a TypeError. If no
2675         arguments (positional or otherwise) are provided, the current
2676         margins will remain in place and simply be returned.
2677 
2678         Specifying any margin changes only the autoscaling; for example,
2679         if *xmargin* is not None, then *xmargin* times the X data
2680         interval will be added to each end of that interval before
2681         it is used in autoscaling.
2682 
2683         Parameters
2684         ----------
2685         *margins : float, optional
2686             If a single positional argument is provided, it specifies
2687             both margins of the x-axis and y-axis limits. If two
2688             positional arguments are provided, they will be interpreted
2689             as *xmargin*, *ymargin*. If setting the margin on a single
2690             axis is desired, use the keyword arguments described below.
2691 
2692         x, y : float, optional
2693             Specific margin values for the x-axis and y-axis,
2694             respectively. These cannot be used with positional
2695             arguments, but can be used individually to alter on e.g.,
2696             only the y-axis.
2697 
2698         tight : bool or None, default: True
2699             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2700             which is executed after a margin is changed; the default
2701             here is *True*, on the assumption that when margins are
2702             specified, no additional padding to match tick marks is
2703             usually desired.  Setting *tight* to *None* preserves
2704             the previous setting.
2705 
2706         Returns
2707         -------
2708         xmargin, ymargin : float
2709 
2710         Notes
2711         -----
2712         If a previously used Axes method such as :meth:`pcolor` has set
2713         :attr:`use_sticky_edges` to `True`, only the limits not set by
2714         the "sticky artists" will be modified. To force all of the
2715         margins to be set, set :attr:`use_sticky_edges` to `False`
2716         before calling :meth:`margins`.
2717         """
2718 
2719         if margins and (x is not None or y is not None):
2720             raise TypeError('Cannot pass both positional and keyword '
2721                             'arguments for x and/or y.')
2722         elif len(margins) == 1:
2723             x = y = margins[0]
2724         elif len(margins) == 2:
2725             x, y = margins
2726         elif margins:
2727             raise TypeError('Must pass a single positional argument for all '
2728                             'margins, or one for each margin (x, y).')
2729 
2730         if x is None and y is None:
2731             if tight is not True:
2732                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2733             return self._xmargin, self._ymargin
2734 
2735         if tight is not None:
2736             self._tight = tight
2737         if x is not None:
2738             self.set_xmargin(x)
2739         if y is not None:
2740             self.set_ymargin(y)
2741 
2742     def set_rasterization_zorder(self, z):
2743         """
2744         Set the zorder threshold for rasterization for vector graphics output.
2745 
2746         All artists with a zorder below the given value will be rasterized if
2747         they support rasterization.
2748 
2749         This setting is ignored for pixel-based output.
2750 
2751         See also :doc:`/gallery/misc/rasterization_demo`.
2752 
2753         Parameters
2754         ----------
2755         z : float or None
2756             The zorder below which artists are rasterized.
2757             If ``None`` rasterization based on zorder is deactivated.
2758         """
2759         self._rasterization_zorder = z
2760         self.stale = True
2761 
2762     def get_rasterization_zorder(self):
2763         """Return the zorder value below which artists will be rasterized."""
2764         return self._rasterization_zorder
2765 
2766     def autoscale(self, enable=True, axis='both', tight=None):
2767         """
2768         Autoscale the axis view to the data (toggle).
2769 
2770         Convenience method for simple axis view autoscaling.
2771         It turns autoscaling on or off, and then,
2772         if autoscaling for either axis is on, it performs
2773         the autoscaling on the specified axis or Axes.
2774 
2775         Parameters
2776         ----------
2777         enable : bool or None, default: True
2778             True turns autoscaling on, False turns it off.
2779             None leaves the autoscaling state unchanged.
2780         axis : {'both', 'x', 'y'}, default: 'both'
2781             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2782             to 'z', and 'both' refers to all three axes.)
2783         tight : bool or None, default: None
2784             If True, first set the margins to zero.  Then, this argument is
2785             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2786             its value); see the description of its behavior there.
2787         """
2788         if enable is None:
2789             scalex = True
2790             scaley = True
2791         else:
2792             if axis in ['x', 'both']:
2793                 self.set_autoscalex_on(bool(enable))
2794                 scalex = self.get_autoscalex_on()
2795             else:
2796                 scalex = False
2797             if axis in ['y', 'both']:
2798                 self.set_autoscaley_on(bool(enable))
2799                 scaley = self.get_autoscaley_on()
2800             else:
2801                 scaley = False
2802         if tight and scalex:
2803             self._xmargin = 0
2804         if tight and scaley:
2805             self._ymargin = 0
2806         if scalex:
2807             self._request_autoscale_view("x", tight=tight)
2808         if scaley:
2809             self._request_autoscale_view("y", tight=tight)
2810 
2811     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2812         """
2813         Autoscale the view limits using the data limits.
2814 
2815         Parameters
2816         ----------
2817         tight : bool or None
2818             If *True*, only expand the axis limits using the margins.  Note
2819             that unlike for `autoscale`, ``tight=True`` does *not* set the
2820             margins to zero.
2821 
2822             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2823             after expansion by the margins, further expand the axis limits
2824             using the axis major locator.
2825 
2826             If None (the default), reuse the value set in the previous call to
2827             `autoscale_view` (the initial value is False, but the default style
2828             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2829             behaves like True).
2830 
2831         scalex : bool, default: True
2832             Whether to autoscale the x-axis.
2833 
2834         scaley : bool, default: True
2835             Whether to autoscale the y-axis.
2836 
2837         Notes
2838         -----
2839         The autoscaling preserves any preexisting axis direction reversal.
2840 
2841         The data limits are not updated automatically when artist data are
2842         changed after the artist has been added to an Axes instance.  In that
2843         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2844         autoscale_view.
2845 
2846         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2847         not be changed by autoscale_view().
2848         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2849         """
2850         if tight is not None:
2851             self._tight = bool(tight)
2852 
2853         x_stickies = y_stickies = np.array([])
2854         if self.use_sticky_edges:
2855             if self._xmargin and scalex and self.get_autoscalex_on():
2856                 x_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.x
2858                     for ax in self._shared_axes["x"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860             if self._ymargin and scaley and self.get_autoscaley_on():
2861                 y_stickies = np.sort(np.concatenate([
2862                     artist.sticky_edges.y
2863                     for ax in self._shared_axes["y"].get_siblings(self)
2864                     for artist in ax.get_children()]))
2865         if self.get_xscale() == 'log':
2866             x_stickies = x_stickies[x_stickies > 0]
2867         if self.get_yscale() == 'log':
2868             y_stickies = y_stickies[y_stickies > 0]
2869 
2870         def handle_single_axis(
2871                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2872 
2873             if not (scale and axis._get_autoscale_on()):
2874                 return  # nothing to do...
2875 
2876             shared = shared_axes.get_siblings(self)
2877             # Base autoscaling on finite data limits when there is at least one
2878             # finite data limit among all the shared_axes and intervals.
2879             values = [val for ax in shared
2880                       for val in getattr(ax.dataLim, f"interval{name}")
2881                       if np.isfinite(val)]
2882             if values:
2883                 x0, x1 = (min(values), max(values))
2884             elif getattr(self._viewLim, f"mutated{name}")():
2885                 # No data, but explicit viewLims already set:
2886                 # in mutatedx or mutatedy.
2887                 return
2888             else:
2889                 x0, x1 = (-np.inf, np.inf)
2890             # If x0 and x1 are nonfinite, get default limits from the locator.
2891             locator = axis.get_major_locator()
2892             x0, x1 = locator.nonsingular(x0, x1)
2893             # Find the minimum minpos for use in the margin calculation.
2894             minimum_minpos = min(
2895                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2896 
2897             # Prevent margin addition from crossing a sticky value.  A small
2898             # tolerance must be added due to floating point issues with
2899             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2900             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2901             # datasets where all values are tiny (less than 1e-8).
2902             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2903             # Index of largest element < x0 + tol, if any.
2904             i0 = stickies.searchsorted(x0 + tol) - 1
2905             x0bound = stickies[i0] if i0 != -1 else None
2906             # Index of smallest element > x1 - tol, if any.
2907             i1 = stickies.searchsorted(x1 - tol)
2908             x1bound = stickies[i1] if i1 != len(stickies) else None
2909 
2910             # Add the margin in figure space and then transform back, to handle
2911             # non-linear scales.
2912             transform = axis.get_transform()
2913             inverse_trans = transform.inverted()
2914             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2915             x0t, x1t = transform.transform([x0, x1])
2916             delta = (x1t - x0t) * margin
2917             if not np.isfinite(delta):
2918                 delta = 0  # If a bound isn't finite, set margin to zero.
2919             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2920 
2921             # Apply sticky bounds.
2922             if x0bound is not None:
2923                 x0 = max(x0, x0bound)
2924             if x1bound is not None:
2925                 x1 = min(x1, x1bound)
2926 
2927             if not self._tight:
2928                 x0, x1 = locator.view_limits(x0, x1)
2929             set_bound(x0, x1)
2930             # End of definition of internal function 'handle_single_axis'.
2931 
2932         handle_single_axis(
2933             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2934             x_stickies, self.set_xbound)
2935         handle_single_axis(
2936             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2937             y_stickies, self.set_ybound)
2938 
2939     def _update_title_position(self, renderer):
2940         """
2941         Update the title position based on the bounding box enclosing
2942         all the ticklabels and x-axis spine and xlabel...
2943         """
2944         if self._autotitlepos is not None and not self._autotitlepos:
2945             _log.debug('title position was updated manually, not adjusting')
2946             return
2947 
2948         titles = (self.title, self._left_title, self._right_title)
2949 
2950         # Need to check all our twins too, and all the children as well.
2951         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2952         for ax in self.child_axes:  # Child positions must be updated first.
2953             locator = ax.get_axes_locator()
2954             ax.apply_aspect(locator(self, renderer) if locator else None)
2955 
2956         for title in titles:
2957             x, _ = title.get_position()
2958             # need to start again in case of window resizing
2959             title.set_position((x, 1.0))
2960             top = -np.inf
2961             for ax in axs:
2962                 bb = None
2963                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2964                         or ax.xaxis.get_label_position() == 'top'):
2965                     bb = ax.xaxis.get_tightbbox(renderer)
2966                 if bb is None:
2967                     if 'outline' in ax.spines:
2968                         # Special case for colorbars:
2969                         bb = ax.spines['outline'].get_window_extent()
2970                     else:
2971                         bb = ax.get_window_extent(renderer)
2972                 top = max(top, bb.ymax)
2973                 if title.get_text():
2974                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2975                     if ax.yaxis.offsetText.get_text():
2976                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2977                         if bb.intersection(title.get_tightbbox(renderer), bb):
2978                             top = bb.ymax
2979             if top < 0:
2980                 # the top of Axes is not even on the figure, so don't try and
2981                 # automatically place it.
2982                 _log.debug('top of Axes not in the figure, so title not moved')
2983                 return
2984             if title.get_window_extent(renderer).ymin < top:
2985                 _, y = self.transAxes.inverted().transform((0, top))
2986                 title.set_position((x, y))
2987                 # empirically, this doesn't always get the min to top,
2988                 # so we need to adjust again.
2989                 if title.get_window_extent(renderer).ymin < top:
2990                     _, y = self.transAxes.inverted().transform(
2991                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2992                     title.set_position((x, y))
2993 
2994         ymax = max(title.get_position()[1] for title in titles)
2995         for title in titles:
2996             # now line up all the titles at the highest baseline.
2997             x, _ = title.get_position()
2998             title.set_position((x, ymax))
2999 
3000     # Drawing
3001     @martist.allow_rasterization
3002     def draw(self, renderer):
3003         # docstring inherited
3004         if renderer is None:
3005             raise RuntimeError('No renderer defined')
3006         if not self.get_visible():
3007             return
3008         self._unstale_viewLim()
3009 
3010         renderer.open_group('axes', gid=self.get_gid())
3011 
3012         # prevent triggering call backs during the draw process
3013         self._stale = True
3014 
3015         # loop over self and child Axes...
3016         locator = self.get_axes_locator()
3017         self.apply_aspect(locator(self, renderer) if locator else None)
3018 
3019         artists = self.get_children()
3020         artists.remove(self.patch)
3021 
3022         # the frame draws the edges around the Axes patch -- we
3023         # decouple these so the patch can be in the background and the
3024         # frame in the foreground. Do this before drawing the axis
3025         # objects so that the spine has the opportunity to update them.
3026         if not (self.axison and self._frameon):
3027             for spine in self.spines.values():
3028                 artists.remove(spine)
3029 
3030         self._update_title_position(renderer)
3031 
3032         if not self.axison:
3033             for _axis in self._axis_map.values():
3034                 artists.remove(_axis)
3035 
3036         if not self.figure.canvas.is_saving():
3037             artists = [
3038                 a for a in artists
3039                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3040         artists = sorted(artists, key=attrgetter('zorder'))
3041 
3042         # rasterize artists with negative zorder
3043         # if the minimum zorder is negative, start rasterization
3044         rasterization_zorder = self._rasterization_zorder
3045 
3046         if (rasterization_zorder is not None and
3047                 artists and artists[0].zorder < rasterization_zorder):
3048             split_index = np.searchsorted(
3049                 [art.zorder for art in artists],
3050                 rasterization_zorder, side='right'
3051             )
3052             artists_rasterized = artists[:split_index]
3053             artists = artists[split_index:]
3054         else:
3055             artists_rasterized = []
3056 
3057         if self.axison and self._frameon:
3058             if artists_rasterized:
3059                 artists_rasterized = [self.patch] + artists_rasterized
3060             else:
3061                 artists = [self.patch] + artists
3062 
3063         if artists_rasterized:
3064             _draw_rasterized(self.figure, artists_rasterized, renderer)
3065 
3066         mimage._draw_list_compositing_images(
3067             renderer, self, artists, self.figure.suppressComposite)
3068 
3069         renderer.close_group('axes')
3070         self.stale = False
3071 
3072     def draw_artist(self, a):
3073         """
3074         Efficiently redraw a single artist.
3075         """
3076         a.draw(self.figure.canvas.get_renderer())
3077 
3078     def redraw_in_frame(self):
3079         """
3080         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3081         """
3082         with ExitStack() as stack:
3083             for artist in [*self._axis_map.values(),
3084                            self.title, self._left_title, self._right_title]:
3085                 stack.enter_context(artist._cm_set(visible=False))
3086             self.draw(self.figure.canvas.get_renderer())
3087 
3088     @_api.deprecated("3.6", alternative="Axes.figure.canvas.get_renderer()")
3089     def get_renderer_cache(self):
3090         return self.figure.canvas.get_renderer()
3091 
3092     # Axes rectangle characteristics
3093 
3094     def get_frame_on(self):
3095         """Get whether the Axes rectangle patch is drawn."""
3096         return self._frameon
3097 
3098     def set_frame_on(self, b):
3099         """
3100         Set whether the Axes rectangle patch is drawn.
3101 
3102         Parameters
3103         ----------
3104         b : bool
3105         """
3106         self._frameon = b
3107         self.stale = True
3108 
3109     def get_axisbelow(self):
3110         """
3111         Get whether axis ticks and gridlines are above or below most artists.
3112 
3113         Returns
3114         -------
3115         bool or 'line'
3116 
3117         See Also
3118         --------
3119         set_axisbelow
3120         """
3121         return self._axisbelow
3122 
3123     def set_axisbelow(self, b):
3124         """
3125         Set whether axis ticks and gridlines are above or below most artists.
3126 
3127         This controls the zorder of the ticks and gridlines. For more
3128         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3129 
3130         Parameters
3131         ----------
3132         b : bool or 'line'
3133             Possible values:
3134 
3135             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3136             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3137               (e.g. rectangles, with default zorder = 1) but still below lines
3138               and markers (with their default zorder = 2).
3139             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3140               and lines / markers.
3141 
3142         See Also
3143         --------
3144         get_axisbelow
3145         """
3146         # Check that b is True, False or 'line'
3147         self._axisbelow = axisbelow = validate_axisbelow(b)
3148         zorder = {
3149             True: 0.5,
3150             'line': 1.5,
3151             False: 2.5,
3152         }[axisbelow]
3153         for axis in self._axis_map.values():
3154             axis.set_zorder(zorder)
3155         self.stale = True
3156 
3157     @_docstring.dedent_interpd
3158     def grid(self, visible=None, which='major', axis='both', **kwargs):
3159         """
3160         Configure the grid lines.
3161 
3162         Parameters
3163         ----------
3164         visible : bool or None, optional
3165             Whether to show the grid lines.  If any *kwargs* are supplied, it
3166             is assumed you want the grid on and *visible* will be set to True.
3167 
3168             If *visible* is *None* and there are no *kwargs*, this toggles the
3169             visibility of the lines.
3170 
3171         which : {'major', 'minor', 'both'}, optional
3172             The grid lines to apply the changes on.
3173 
3174         axis : {'both', 'x', 'y'}, optional
3175             The axis to apply the changes on.
3176 
3177         **kwargs : `.Line2D` properties
3178             Define the line properties of the grid, e.g.::
3179 
3180                 grid(color='r', linestyle='-', linewidth=2)
3181 
3182             Valid keyword arguments are:
3183 
3184             %(Line2D:kwdoc)s
3185 
3186         Notes
3187         -----
3188         The axis is drawn as a unit, so the effective zorder for drawing the
3189         grid is determined by the zorder of each axis, not by the zorder of the
3190         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3191         use `.set_axisbelow` or, for more control, call the
3192         `~.Artist.set_zorder` method of each axis.
3193         """
3194         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3195         if axis in ['x', 'both']:
3196             self.xaxis.grid(visible, which=which, **kwargs)
3197         if axis in ['y', 'both']:
3198             self.yaxis.grid(visible, which=which, **kwargs)
3199 
3200     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3201                          useOffset=None, useLocale=None, useMathText=None):
3202         r"""
3203         Configure the `.ScalarFormatter` used by default for linear Axes.
3204 
3205         If a parameter is not set, the corresponding property of the formatter
3206         is left unchanged.
3207 
3208         Parameters
3209         ----------
3210         axis : {'x', 'y', 'both'}, default: 'both'
3211             The axis to configure.  Only major ticks are affected.
3212 
3213         style : {'sci', 'scientific', 'plain'}
3214             Whether to use scientific notation.
3215             The formatter default is to use scientific notation.
3216 
3217         scilimits : pair of ints (m, n)
3218             Scientific notation is used only for numbers outside the range
3219             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3220             configured to use scientific notation at all).  Use (0, 0) to
3221             include all numbers.  Use (m, m) where m != 0 to fix the order of
3222             magnitude to 10\ :sup:`m`.
3223             The formatter default is :rc:`axes.formatter.limits`.
3224 
3225         useOffset : bool or float
3226             If True, the offset is calculated as needed.
3227             If False, no offset is used.
3228             If a numeric value, it sets the offset.
3229             The formatter default is :rc:`axes.formatter.useoffset`.
3230 
3231         useLocale : bool
3232             Whether to format the number using the current locale or using the
3233             C (English) locale.  This affects e.g. the decimal separator.  The
3234             formatter default is :rc:`axes.formatter.use_locale`.
3235 
3236         useMathText : bool
3237             Render the offset and scientific notation in mathtext.
3238             The formatter default is :rc:`axes.formatter.use_mathtext`.
3239 
3240         Raises
3241         ------
3242         AttributeError
3243             If the current formatter is not a `.ScalarFormatter`.
3244         """
3245         style = style.lower()
3246         axis = axis.lower()
3247         if scilimits is not None:
3248             try:
3249                 m, n = scilimits
3250                 m + n + 1  # check that both are numbers
3251             except (ValueError, TypeError) as err:
3252                 raise ValueError("scilimits must be a sequence of 2 integers"
3253                                  ) from err
3254         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3255         is_sci_style = _api.check_getitem(STYLES, style=style)
3256         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3257                     'both': list(self._axis_map.values())}
3258         axises = _api.check_getitem(axis_map, axis=axis)
3259         try:
3260             for axis in axises:
3261                 if is_sci_style is not None:
3262                     axis.major.formatter.set_scientific(is_sci_style)
3263                 if scilimits is not None:
3264                     axis.major.formatter.set_powerlimits(scilimits)
3265                 if useOffset is not None:
3266                     axis.major.formatter.set_useOffset(useOffset)
3267                 if useLocale is not None:
3268                     axis.major.formatter.set_useLocale(useLocale)
3269                 if useMathText is not None:
3270                     axis.major.formatter.set_useMathText(useMathText)
3271         except AttributeError as err:
3272             raise AttributeError(
3273                 "This method only works with the ScalarFormatter") from err
3274 
3275     def locator_params(self, axis='both', tight=None, **kwargs):
3276         """
3277         Control behavior of major tick locators.
3278 
3279         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3280         is called automatically after the parameters are changed.
3281 
3282         Parameters
3283         ----------
3284         axis : {'both', 'x', 'y'}, default: 'both'
3285             The axis on which to operate.  (For 3D Axes, *axis* can also be
3286             set to 'z', and 'both' refers to all three axes.)
3287         tight : bool or None, optional
3288             Parameter passed to `~.Axes.autoscale_view`.
3289             Default is None, for no change.
3290 
3291         Other Parameters
3292         ----------------
3293         **kwargs
3294             Remaining keyword arguments are passed to directly to the
3295             ``set_params()`` method of the locator. Supported keywords depend
3296             on the type of the locator. See for example
3297             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3298             used by default for linear.
3299 
3300         Examples
3301         --------
3302         When plotting small subplots, one might want to reduce the maximum
3303         number of ticks and use tight bounds, for example::
3304 
3305             ax.locator_params(tight=True, nbins=4)
3306 
3307         """
3308         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3309         for name in self._axis_names:
3310             if axis in [name, "both"]:
3311                 loc = self._axis_map[name].get_major_locator()
3312                 loc.set_params(**kwargs)
3313                 self._request_autoscale_view(name, tight=tight)
3314         self.stale = True
3315 
3316     def tick_params(self, axis='both', **kwargs):
3317         """
3318         Change the appearance of ticks, tick labels, and gridlines.
3319 
3320         Tick properties that are not explicitly set using the keyword
3321         arguments remain unchanged unless *reset* is True. For the current
3322         style settings, see `.Axis.get_tick_params`.
3323 
3324         Parameters
3325         ----------
3326         axis : {'x', 'y', 'both'}, default: 'both'
3327             The axis to which the parameters are applied.
3328         which : {'major', 'minor', 'both'}, default: 'major'
3329             The group of ticks to which the parameters are applied.
3330         reset : bool, default: False
3331             Whether to reset the ticks to defaults before updating them.
3332 
3333         Other Parameters
3334         ----------------
3335         direction : {'in', 'out', 'inout'}
3336             Puts ticks inside the Axes, outside the Axes, or both.
3337         length : float
3338             Tick length in points.
3339         width : float
3340             Tick width in points.
3341         color : color
3342             Tick color.
3343         pad : float
3344             Distance in points between tick and label.
3345         labelsize : float or str
3346             Tick label font size in points or as a string (e.g., 'large').
3347         labelcolor : color
3348             Tick label color.
3349         colors : color
3350             Tick color and label color.
3351         zorder : float
3352             Tick and label zorder.
3353         bottom, top, left, right : bool
3354             Whether to draw the respective ticks.
3355         labelbottom, labeltop, labelleft, labelright : bool
3356             Whether to draw the respective tick labels.
3357         labelrotation : float
3358             Tick label rotation
3359         grid_color : color
3360             Gridline color.
3361         grid_alpha : float
3362             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3363         grid_linewidth : float
3364             Width of gridlines in points.
3365         grid_linestyle : str
3366             Any valid `.Line2D` line style spec.
3367 
3368         Examples
3369         --------
3370         ::
3371 
3372             ax.tick_params(direction='out', length=6, width=2, colors='r',
3373                            grid_color='r', grid_alpha=0.5)
3374 
3375         This will make all major ticks be red, pointing out of the box,
3376         and with dimensions 6 points by 2 points.  Tick labels will
3377         also be red.  Gridlines will be red and translucent.
3378 
3379         """
3380         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3381         if axis in ['x', 'both']:
3382             xkw = dict(kwargs)
3383             xkw.pop('left', None)
3384             xkw.pop('right', None)
3385             xkw.pop('labelleft', None)
3386             xkw.pop('labelright', None)
3387             self.xaxis.set_tick_params(**xkw)
3388         if axis in ['y', 'both']:
3389             ykw = dict(kwargs)
3390             ykw.pop('top', None)
3391             ykw.pop('bottom', None)
3392             ykw.pop('labeltop', None)
3393             ykw.pop('labelbottom', None)
3394             self.yaxis.set_tick_params(**ykw)
3395 
3396     def set_axis_off(self):
3397         """
3398         Turn the x- and y-axis off.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = False
3403         self.stale = True
3404 
3405     def set_axis_on(self):
3406         """
3407         Turn the x- and y-axis on.
3408 
3409         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3410         """
3411         self.axison = True
3412         self.stale = True
3413 
3414     # data limits, ticks, tick labels, and formatting
3415 
3416     def get_xlabel(self):
3417         """
3418         Get the xlabel text string.
3419         """
3420         label = self.xaxis.get_label()
3421         return label.get_text()
3422 
3423     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3424                    loc=None, **kwargs):
3425         """
3426         Set the label for the x-axis.
3427 
3428         Parameters
3429         ----------
3430         xlabel : str
3431             The label text.
3432 
3433         labelpad : float, default: :rc:`axes.labelpad`
3434             Spacing in points from the Axes bounding box including ticks
3435             and tick labels.  If None, the previous value is left as is.
3436 
3437         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3438             The label position. This is a high-level alternative for passing
3439             parameters *x* and *horizontalalignment*.
3440 
3441         Other Parameters
3442         ----------------
3443         **kwargs : `.Text` properties
3444             `.Text` properties control the appearance of the label.
3445 
3446         See Also
3447         --------
3448         text : Documents the properties supported by `.Text`.
3449         """
3450         if labelpad is not None:
3451             self.xaxis.labelpad = labelpad
3452         protected_kw = ['x', 'horizontalalignment', 'ha']
3453         if {*kwargs} & {*protected_kw}:
3454             if loc is not None:
3455                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3456                                 f"its corresponding low level keyword "
3457                                 f"arguments ({protected_kw}) are also "
3458                                 f"supplied")
3459 
3460         else:
3461             loc = (loc if loc is not None
3462                    else mpl.rcParams['xaxis.labellocation'])
3463             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3464 
3465             x = {
3466                 'left': 0,
3467                 'center': 0.5,
3468                 'right': 1,
3469             }[loc]
3470             kwargs.update(x=x, horizontalalignment=loc)
3471 
3472         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3473 
3474     def invert_xaxis(self):
3475         """
3476         Invert the x-axis.
3477 
3478         See Also
3479         --------
3480         xaxis_inverted
3481         get_xlim, set_xlim
3482         get_xbound, set_xbound
3483         """
3484         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3485 
3486     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3487 
3488     def get_xbound(self):
3489         """
3490         Return the lower and upper x-axis bounds, in increasing order.
3491 
3492         See Also
3493         --------
3494         set_xbound
3495         get_xlim, set_xlim
3496         invert_xaxis, xaxis_inverted
3497         """
3498         left, right = self.get_xlim()
3499         if left < right:
3500             return left, right
3501         else:
3502             return right, left
3503 
3504     def set_xbound(self, lower=None, upper=None):
3505         """
3506         Set the lower and upper numerical bounds of the x-axis.
3507 
3508         This method will honor axis inversion regardless of parameter order.
3509         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3510 
3511         Parameters
3512         ----------
3513         lower, upper : float or None
3514             The lower and upper bounds. If *None*, the respective axis bound
3515             is not modified.
3516 
3517         See Also
3518         --------
3519         get_xbound
3520         get_xlim, set_xlim
3521         invert_xaxis, xaxis_inverted
3522         """
3523         if upper is None and np.iterable(lower):
3524             lower, upper = lower
3525 
3526         old_lower, old_upper = self.get_xbound()
3527         if lower is None:
3528             lower = old_lower
3529         if upper is None:
3530             upper = old_upper
3531 
3532         self.set_xlim(sorted((lower, upper),
3533                              reverse=bool(self.xaxis_inverted())),
3534                       auto=None)
3535 
3536     def get_xlim(self):
3537         """
3538         Return the x-axis view limits.
3539 
3540         Returns
3541         -------
3542         left, right : (float, float)
3543             The current x-axis limits in data coordinates.
3544 
3545         See Also
3546         --------
3547         .Axes.set_xlim
3548         set_xbound, get_xbound
3549         invert_xaxis, xaxis_inverted
3550 
3551         Notes
3552         -----
3553         The x-axis may be inverted, in which case the *left* value will
3554         be greater than the *right* value.
3555         """
3556         return tuple(self.viewLim.intervalx)
3557 
3558     def _validate_converted_limits(self, limit, convert):
3559         """
3560         Raise ValueError if converted limits are non-finite.
3561 
3562         Note that this function also accepts None as a limit argument.
3563 
3564         Returns
3565         -------
3566         The limit value after call to convert(), or None if limit is None.
3567         """
3568         if limit is not None:
3569             converted_limit = convert(limit)
3570             if (isinstance(converted_limit, Real)
3571                     and not np.isfinite(converted_limit)):
3572                 raise ValueError("Axis limits cannot be NaN or Inf")
3573             return converted_limit
3574 
3575     @_api.make_keyword_only("3.6", "emit")
3576     def set_xlim(self, left=None, right=None, emit=True, auto=False,
3577                  *, xmin=None, xmax=None):
3578         """
3579         Set the x-axis view limits.
3580 
3581         Parameters
3582         ----------
3583         left : float, optional
3584             The left xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587             The left and right xlims may also be passed as the tuple
3588             (*left*, *right*) as the first positional argument (or as
3589             the *left* keyword argument).
3590 
3591             .. ACCEPTS: (bottom: float, top: float)
3592 
3593         right : float, optional
3594             The right xlim in data coordinates. Passing *None* leaves the
3595             limit unchanged.
3596 
3597         emit : bool, default: True
3598             Whether to notify observers of limit change.
3599 
3600         auto : bool or None, default: False
3601             Whether to turn on autoscaling of the x-axis. True turns on,
3602             False turns off, None leaves unchanged.
3603 
3604         xmin, xmax : float, optional
3605             They are equivalent to left and right respectively, and it is an
3606             error to pass both *xmin* and *left* or *xmax* and *right*.
3607 
3608         Returns
3609         -------
3610         left, right : (float, float)
3611             The new x-axis limits in data coordinates.
3612 
3613         See Also
3614         --------
3615         get_xlim
3616         set_xbound, get_xbound
3617         invert_xaxis, xaxis_inverted
3618 
3619         Notes
3620         -----
3621         The *left* value may be greater than the *right* value, in which
3622         case the x-axis values will decrease from left to right.
3623 
3624         Examples
3625         --------
3626         >>> set_xlim(left, right)
3627         >>> set_xlim((left, right))
3628         >>> left, right = set_xlim(left, right)
3629 
3630         One limit may be left unchanged.
3631 
3632         >>> set_xlim(right=right_lim)
3633 
3634         Limits may be passed in reverse order to flip the direction of
3635         the x-axis. For example, suppose *x* represents the number of
3636         years before present. The x-axis limits might be set like the
3637         following so 5000 years ago is on the left of the plot and the
3638         present is on the right.
3639 
3640         >>> set_xlim(5000, 0)
3641         """
3642         if right is None and np.iterable(left):
3643             left, right = left
3644         if xmin is not None:
3645             if left is not None:
3646                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3647             left = xmin
3648         if xmax is not None:
3649             if right is not None:
3650                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3651             right = xmax
3652         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3653 
3654     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3655     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3656     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3657     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3658     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3659     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3660     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3661     set_xticklabels = _axis_method_wrapper(
3662         "xaxis", "set_ticklabels",
3663         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3664 
3665     def get_ylabel(self):
3666         """
3667         Get the ylabel text string.
3668         """
3669         label = self.yaxis.get_label()
3670         return label.get_text()
3671 
3672     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3673                    loc=None, **kwargs):
3674         """
3675         Set the label for the y-axis.
3676 
3677         Parameters
3678         ----------
3679         ylabel : str
3680             The label text.
3681 
3682         labelpad : float, default: :rc:`axes.labelpad`
3683             Spacing in points from the Axes bounding box including ticks
3684             and tick labels.  If None, the previous value is left as is.
3685 
3686         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3687             The label position. This is a high-level alternative for passing
3688             parameters *y* and *horizontalalignment*.
3689 
3690         Other Parameters
3691         ----------------
3692         **kwargs : `.Text` properties
3693             `.Text` properties control the appearance of the label.
3694 
3695         See Also
3696         --------
3697         text : Documents the properties supported by `.Text`.
3698         """
3699         if labelpad is not None:
3700             self.yaxis.labelpad = labelpad
3701         protected_kw = ['y', 'horizontalalignment', 'ha']
3702         if {*kwargs} & {*protected_kw}:
3703             if loc is not None:
3704                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3705                                 f"its corresponding low level keyword "
3706                                 f"arguments ({protected_kw}) are also "
3707                                 f"supplied")
3708 
3709         else:
3710             loc = (loc if loc is not None
3711                    else mpl.rcParams['yaxis.labellocation'])
3712             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3713 
3714             y, ha = {
3715                 'bottom': (0, 'left'),
3716                 'center': (0.5, 'center'),
3717                 'top': (1, 'right')
3718             }[loc]
3719             kwargs.update(y=y, horizontalalignment=ha)
3720 
3721         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3722 
3723     def invert_yaxis(self):
3724         """
3725         Invert the y-axis.
3726 
3727         See Also
3728         --------
3729         yaxis_inverted
3730         get_ylim, set_ylim
3731         get_ybound, set_ybound
3732         """
3733         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3734 
3735     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3736 
3737     def get_ybound(self):
3738         """
3739         Return the lower and upper y-axis bounds, in increasing order.
3740 
3741         See Also
3742         --------
3743         set_ybound
3744         get_ylim, set_ylim
3745         invert_yaxis, yaxis_inverted
3746         """
3747         bottom, top = self.get_ylim()
3748         if bottom < top:
3749             return bottom, top
3750         else:
3751             return top, bottom
3752 
3753     def set_ybound(self, lower=None, upper=None):
3754         """
3755         Set the lower and upper numerical bounds of the y-axis.
3756 
3757         This method will honor axis inversion regardless of parameter order.
3758         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3759 
3760         Parameters
3761         ----------
3762         lower, upper : float or None
3763             The lower and upper bounds. If *None*, the respective axis bound
3764             is not modified.
3765 
3766         See Also
3767         --------
3768         get_ybound
3769         get_ylim, set_ylim
3770         invert_yaxis, yaxis_inverted
3771         """
3772         if upper is None and np.iterable(lower):
3773             lower, upper = lower
3774 
3775         old_lower, old_upper = self.get_ybound()
3776         if lower is None:
3777             lower = old_lower
3778         if upper is None:
3779             upper = old_upper
3780 
3781         self.set_ylim(sorted((lower, upper),
3782                              reverse=bool(self.yaxis_inverted())),
3783                       auto=None)
3784 
3785     def get_ylim(self):
3786         """
3787         Return the y-axis view limits.
3788 
3789         Returns
3790         -------
3791         bottom, top : (float, float)
3792             The current y-axis limits in data coordinates.
3793 
3794         See Also
3795         --------
3796         .Axes.set_ylim
3797         set_ybound, get_ybound
3798         invert_yaxis, yaxis_inverted
3799 
3800         Notes
3801         -----
3802         The y-axis may be inverted, in which case the *bottom* value
3803         will be greater than the *top* value.
3804         """
3805         return tuple(self.viewLim.intervaly)
3806 
3807     @_api.make_keyword_only("3.6", "emit")
3808     def set_ylim(self, bottom=None, top=None, emit=True, auto=False,
3809                  *, ymin=None, ymax=None):
3810         """
3811         Set the y-axis view limits.
3812 
3813         Parameters
3814         ----------
3815         bottom : float, optional
3816             The bottom ylim in data coordinates. Passing *None* leaves the
3817             limit unchanged.
3818 
3819             The bottom and top ylims may also be passed as the tuple
3820             (*bottom*, *top*) as the first positional argument (or as
3821             the *bottom* keyword argument).
3822 
3823             .. ACCEPTS: (bottom: float, top: float)
3824 
3825         top : float, optional
3826             The top ylim in data coordinates. Passing *None* leaves the
3827             limit unchanged.
3828 
3829         emit : bool, default: True
3830             Whether to notify observers of limit change.
3831 
3832         auto : bool or None, default: False
3833             Whether to turn on autoscaling of the y-axis. *True* turns on,
3834             *False* turns off, *None* leaves unchanged.
3835 
3836         ymin, ymax : float, optional
3837             They are equivalent to bottom and top respectively, and it is an
3838             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3839 
3840         Returns
3841         -------
3842         bottom, top : (float, float)
3843             The new y-axis limits in data coordinates.
3844 
3845         See Also
3846         --------
3847         get_ylim
3848         set_ybound, get_ybound
3849         invert_yaxis, yaxis_inverted
3850 
3851         Notes
3852         -----
3853         The *bottom* value may be greater than the *top* value, in which
3854         case the y-axis values will decrease from *bottom* to *top*.
3855 
3856         Examples
3857         --------
3858         >>> set_ylim(bottom, top)
3859         >>> set_ylim((bottom, top))
3860         >>> bottom, top = set_ylim(bottom, top)
3861 
3862         One limit may be left unchanged.
3863 
3864         >>> set_ylim(top=top_lim)
3865 
3866         Limits may be passed in reverse order to flip the direction of
3867         the y-axis. For example, suppose ``y`` represents depth of the
3868         ocean in m. The y-axis limits might be set like the following
3869         so 5000 m depth is at the bottom of the plot and the surface,
3870         0 m, is at the top.
3871 
3872         >>> set_ylim(5000, 0)
3873         """
3874         if top is None and np.iterable(bottom):
3875             bottom, top = bottom
3876         if ymin is not None:
3877             if bottom is not None:
3878                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3879             bottom = ymin
3880         if ymax is not None:
3881             if top is not None:
3882                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3883             top = ymax
3884         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3885 
3886     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3887     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3888     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3889     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3890     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3891     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3892     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3893     set_yticklabels = _axis_method_wrapper(
3894         "yaxis", "set_ticklabels",
3895         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3896 
3897     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3898     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3899 
3900     def format_xdata(self, x):
3901         """
3902         Return *x* formatted as an x-value.
3903 
3904         This function will use the `.fmt_xdata` attribute if it is not None,
3905         else will fall back on the xaxis major formatter.
3906         """
3907         return (self.fmt_xdata if self.fmt_xdata is not None
3908                 else self.xaxis.get_major_formatter().format_data_short)(x)
3909 
3910     def format_ydata(self, y):
3911         """
3912         Return *y* formatted as a y-value.
3913 
3914         This function will use the `.fmt_ydata` attribute if it is not None,
3915         else will fall back on the yaxis major formatter.
3916         """
3917         return (self.fmt_ydata if self.fmt_ydata is not None
3918                 else self.yaxis.get_major_formatter().format_data_short)(y)
3919 
3920     def format_coord(self, x, y):
3921         """Return a format string formatting the *x*, *y* coordinates."""
3922         return "x={} y={}".format(
3923             "???" if x is None else self.format_xdata(x),
3924             "???" if y is None else self.format_ydata(y),
3925         )
3926 
3927     def minorticks_on(self):
3928         """
3929         Display minor ticks on the Axes.
3930 
3931         Displaying minor ticks may reduce performance; you may turn them off
3932         using `minorticks_off()` if drawing speed is a problem.
3933         """
3934         for ax in (self.xaxis, self.yaxis):
3935             scale = ax.get_scale()
3936             if scale == 'log':
3937                 s = ax._scale
3938                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3939             elif scale == 'symlog':
3940                 s = ax._scale
3941                 ax.set_minor_locator(
3942                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3943             else:
3944                 ax.set_minor_locator(mticker.AutoMinorLocator())
3945 
3946     def minorticks_off(self):
3947         """Remove minor ticks from the Axes."""
3948         self.xaxis.set_minor_locator(mticker.NullLocator())
3949         self.yaxis.set_minor_locator(mticker.NullLocator())
3950 
3951     # Interactive manipulation
3952 
3953     def can_zoom(self):
3954         """
3955         Return whether this Axes supports the zoom box button functionality.
3956         """
3957         return True
3958 
3959     def can_pan(self):
3960         """
3961         Return whether this Axes supports any pan/zoom button functionality.
3962         """
3963         return True
3964 
3965     def get_navigate(self):
3966         """
3967         Get whether the Axes responds to navigation commands.
3968         """
3969         return self._navigate
3970 
3971     def set_navigate(self, b):
3972         """
3973         Set whether the Axes responds to navigation toolbar commands.
3974 
3975         Parameters
3976         ----------
3977         b : bool
3978         """
3979         self._navigate = b
3980 
3981     def get_navigate_mode(self):
3982         """
3983         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3984         """
3985         return self._navigate_mode
3986 
3987     def set_navigate_mode(self, b):
3988         """
3989         Set the navigation toolbar button status.
3990 
3991         .. warning::
3992             This is not a user-API function.
3993 
3994         """
3995         self._navigate_mode = b
3996 
3997     def _get_view(self):
3998         """
3999         Save information required to reproduce the current view.
4000 
4001         Called before a view is changed, such as during a pan or zoom
4002         initiated by the user. You may return any information you deem
4003         necessary to describe the view.
4004 
4005         .. note::
4006 
4007             Intended to be overridden by new projection types, but if not, the
4008             default implementation saves the view limits. You *must* implement
4009             :meth:`_set_view` if you implement this method.
4010         """
4011         xmin, xmax = self.get_xlim()
4012         ymin, ymax = self.get_ylim()
4013         return xmin, xmax, ymin, ymax
4014 
4015     def _set_view(self, view):
4016         """
4017         Apply a previously saved view.
4018 
4019         Called when restoring a view, such as with the navigation buttons.
4020 
4021         .. note::
4022 
4023             Intended to be overridden by new projection types, but if not, the
4024             default implementation restores the view limits. You *must*
4025             implement :meth:`_get_view` if you implement this method.
4026         """
4027         xmin, xmax, ymin, ymax = view
4028         self.set_xlim((xmin, xmax))
4029         self.set_ylim((ymin, ymax))
4030 
4031     def _prepare_view_from_bbox(self, bbox, direction='in',
4032                                 mode=None, twinx=False, twiny=False):
4033         """
4034         Helper function to prepare the new bounds from a bbox.
4035 
4036         This helper function returns the new x and y bounds from the zoom
4037         bbox. This a convenience method to abstract the bbox logic
4038         out of the base setter.
4039         """
4040         if len(bbox) == 3:
4041             xp, yp, scl = bbox  # Zooming code
4042             if scl == 0:  # Should not happen
4043                 scl = 1.
4044             if scl > 1:
4045                 direction = 'in'
4046             else:
4047                 direction = 'out'
4048                 scl = 1/scl
4049             # get the limits of the axes
4050             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4051                 np.transpose([self.get_xlim(), self.get_ylim()]))
4052             # set the range
4053             xwidth = xmax - xmin
4054             ywidth = ymax - ymin
4055             xcen = (xmax + xmin)*.5
4056             ycen = (ymax + ymin)*.5
4057             xzc = (xp*(scl - 1) + xcen)/scl
4058             yzc = (yp*(scl - 1) + ycen)/scl
4059             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4060                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4061         elif len(bbox) != 4:
4062             # should be len 3 or 4 but nothing else
4063             _api.warn_external(
4064                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4065                 "of length 3 or 4. Ignoring the view change.")
4066             return
4067 
4068         # Original limits.
4069         xmin0, xmax0 = self.get_xbound()
4070         ymin0, ymax0 = self.get_ybound()
4071         # The zoom box in screen coords.
4072         startx, starty, stopx, stopy = bbox
4073         # Convert to data coords.
4074         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4075             [(startx, starty), (stopx, stopy)])
4076         # Clip to axes limits.
4077         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4078         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4079         # Don't double-zoom twinned axes or if zooming only the other axis.
4080         if twinx or mode == "y":
4081             xmin, xmax = xmin0, xmax0
4082         if twiny or mode == "x":
4083             ymin, ymax = ymin0, ymax0
4084 
4085         if direction == "in":
4086             new_xbound = xmin, xmax
4087             new_ybound = ymin, ymax
4088 
4089         elif direction == "out":
4090             x_trf = self.xaxis.get_transform()
4091             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4092                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4093             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4094             # Move original bounds away by
4095             # (factor) x (distance between unzoom box and Axes bbox).
4096             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4097             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4098             # And back to data space.
4099             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4100 
4101             y_trf = self.yaxis.get_transform()
4102             symin0, symax0, symin, symax = y_trf.transform(
4103                 [ymin0, ymax0, ymin, ymax])
4104             factor = (symax0 - symin0) / (symax - symin)
4105             symin1 = symin0 - factor * (symin - symin0)
4106             symax1 = symax0 + factor * (symax0 - symax)
4107             new_ybound = y_trf.inverted().transform([symin1, symax1])
4108 
4109         return new_xbound, new_ybound
4110 
4111     def _set_view_from_bbox(self, bbox, direction='in',
4112                             mode=None, twinx=False, twiny=False):
4113         """
4114         Update view from a selection bbox.
4115 
4116         .. note::
4117 
4118             Intended to be overridden by new projection types, but if not, the
4119             default implementation sets the view limits to the bbox directly.
4120 
4121         Parameters
4122         ----------
4123         bbox : 4-tuple or 3 tuple
4124             * If bbox is a 4 tuple, it is the selected bounding box limits,
4125               in *display* coordinates.
4126             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4127               (xp, yp) is the center of zooming and scl the scale factor to
4128               zoom by.
4129 
4130         direction : str
4131             The direction to apply the bounding box.
4132                 * `'in'` - The bounding box describes the view directly, i.e.,
4133                            it zooms in.
4134                 * `'out'` - The bounding box describes the size to make the
4135                             existing view, i.e., it zooms out.
4136 
4137         mode : str or None
4138             The selection mode, whether to apply the bounding box in only the
4139             `'x'` direction, `'y'` direction or both (`None`).
4140 
4141         twinx : bool
4142             Whether this axis is twinned in the *x*-direction.
4143 
4144         twiny : bool
4145             Whether this axis is twinned in the *y*-direction.
4146         """
4147         new_xbound, new_ybound = self._prepare_view_from_bbox(
4148             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4149         if not twinx and mode != "y":
4150             self.set_xbound(new_xbound)
4151             self.set_autoscalex_on(False)
4152         if not twiny and mode != "x":
4153             self.set_ybound(new_ybound)
4154             self.set_autoscaley_on(False)
4155 
4156     def start_pan(self, x, y, button):
4157         """
4158         Called when a pan operation has started.
4159 
4160         Parameters
4161         ----------
4162         x, y : float
4163             The mouse coordinates in display coords.
4164         button : `.MouseButton`
4165             The pressed mouse button.
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         self._pan_start = types.SimpleNamespace(
4172             lim=self.viewLim.frozen(),
4173             trans=self.transData.frozen(),
4174             trans_inverse=self.transData.inverted().frozen(),
4175             bbox=self.bbox.frozen(),
4176             x=x,
4177             y=y)
4178 
4179     def end_pan(self):
4180         """
4181         Called when a pan operation completes (when the mouse button is up.)
4182 
4183         Notes
4184         -----
4185         This is intended to be overridden by new projection types.
4186         """
4187         del self._pan_start
4188 
4189     def _get_pan_points(self, button, key, x, y):
4190         """
4191         Helper function to return the new points after a pan.
4192 
4193         This helper function returns the points on the axis after a pan has
4194         occurred. This is a convenience method to abstract the pan logic
4195         out of the base setter.
4196         """
4197         def format_deltas(key, dx, dy):
4198             if key == 'control':
4199                 if abs(dx) > abs(dy):
4200                     dy = dx
4201                 else:
4202                     dx = dy
4203             elif key == 'x':
4204                 dy = 0
4205             elif key == 'y':
4206                 dx = 0
4207             elif key == 'shift':
4208                 if 2 * abs(dx) < abs(dy):
4209                     dx = 0
4210                 elif 2 * abs(dy) < abs(dx):
4211                     dy = 0
4212                 elif abs(dx) > abs(dy):
4213                     dy = dy / abs(dy) * abs(dx)
4214                 else:
4215                     dx = dx / abs(dx) * abs(dy)
4216             return dx, dy
4217 
4218         p = self._pan_start
4219         dx = x - p.x
4220         dy = y - p.y
4221         if dx == dy == 0:
4222             return
4223         if button == 1:
4224             dx, dy = format_deltas(key, dx, dy)
4225             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4226         elif button == 3:
4227             try:
4228                 dx = -dx / self.bbox.width
4229                 dy = -dy / self.bbox.height
4230                 dx, dy = format_deltas(key, dx, dy)
4231                 if self.get_aspect() != 'auto':
4232                     dx = dy = 0.5 * (dx + dy)
4233                 alpha = np.power(10.0, (dx, dy))
4234                 start = np.array([p.x, p.y])
4235                 oldpoints = p.lim.transformed(p.trans)
4236                 newpoints = start + alpha * (oldpoints - start)
4237                 result = (mtransforms.Bbox(newpoints)
4238                           .transformed(p.trans_inverse))
4239             except OverflowError:
4240                 _api.warn_external('Overflow while panning')
4241                 return
4242         else:
4243             return
4244 
4245         valid = np.isfinite(result.transformed(p.trans))
4246         points = result.get_points().astype(object)
4247         # Just ignore invalid limits (typically, underflow in log-scale).
4248         points[~valid] = None
4249         return points
4250 
4251     def drag_pan(self, button, key, x, y):
4252         """
4253         Called when the mouse moves during a pan operation.
4254 
4255         Parameters
4256         ----------
4257         button : `.MouseButton`
4258             The pressed mouse button.
4259         key : str or None
4260             The pressed key, if any.
4261         x, y : float
4262             The mouse coordinates in display coords.
4263 
4264         Notes
4265         -----
4266         This is intended to be overridden by new projection types.
4267         """
4268         points = self._get_pan_points(button, key, x, y)
4269         if points is not None:
4270             self.set_xlim(points[:, 0])
4271             self.set_ylim(points[:, 1])
4272 
4273     def get_children(self):
4274         # docstring inherited.
4275         return [
4276             *self._children,
4277             *self.spines.values(),
4278             *self._axis_map.values(),
4279             self.title, self._left_title, self._right_title,
4280             *self.child_axes,
4281             *([self.legend_] if self.legend_ is not None else []),
4282             self.patch,
4283         ]
4284 
4285     def contains(self, mouseevent):
4286         # docstring inherited.
4287         inside, info = self._default_contains(mouseevent)
4288         if inside is not None:
4289             return inside, info
4290         return self.patch.contains(mouseevent)
4291 
4292     def contains_point(self, point):
4293         """
4294         Return whether *point* (pair of pixel coordinates) is inside the Axes
4295         patch.
4296         """
4297         return self.patch.contains_point(point, radius=1.0)
4298 
4299     def get_default_bbox_extra_artists(self):
4300         """
4301         Return a default list of artists that are used for the bounding box
4302         calculation.
4303 
4304         Artists are excluded either by not being visible or
4305         ``artist.set_in_layout(False)``.
4306         """
4307 
4308         artists = self.get_children()
4309 
4310         for axis in self._axis_map.values():
4311             # axis tight bboxes are calculated separately inside
4312             # Axes.get_tightbbox() using for_layout_only=True
4313             artists.remove(axis)
4314         if not (self.axison and self._frameon):
4315             # don't do bbox on spines if frame not on.
4316             for spine in self.spines.values():
4317                 artists.remove(spine)
4318 
4319         artists.remove(self.title)
4320         artists.remove(self._left_title)
4321         artists.remove(self._right_title)
4322 
4323         # always include types that do not internally implement clipping
4324         # to Axes. may have clip_on set to True and clip_box equivalent
4325         # to ax.bbox but then ignore these properties during draws.
4326         noclip = (_AxesBase, maxis.Axis,
4327                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4328         return [a for a in artists if a.get_visible() and a.get_in_layout()
4329                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4330 
4331     @_api.make_keyword_only("3.8", "call_axes_locator")
4332     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4333                       bbox_extra_artists=None, *, for_layout_only=False):
4334         """
4335         Return the tight bounding box of the Axes, including axis and their
4336         decorators (xlabel, title, etc).
4337 
4338         Artists that have ``artist.set_in_layout(False)`` are not included
4339         in the bbox.
4340 
4341         Parameters
4342         ----------
4343         renderer : `.RendererBase` subclass
4344             renderer that will be used to draw the figures (i.e.
4345             ``fig.canvas.get_renderer()``)
4346 
4347         bbox_extra_artists : list of `.Artist` or ``None``
4348             List of artists to include in the tight bounding box.  If
4349             ``None`` (default), then all artist children of the Axes are
4350             included in the tight bounding box.
4351 
4352         call_axes_locator : bool, default: True
4353             If *call_axes_locator* is ``False``, it does not call the
4354             ``_axes_locator`` attribute, which is necessary to get the correct
4355             bounding box. ``call_axes_locator=False`` can be used if the
4356             caller is only interested in the relative size of the tightbbox
4357             compared to the Axes bbox.
4358 
4359         for_layout_only : default: False
4360             The bounding box will *not* include the x-extent of the title and
4361             the xlabel, or the y-extent of the ylabel.
4362 
4363         Returns
4364         -------
4365         `.BboxBase`
4366             Bounding box in figure pixel coordinates.
4367 
4368         See Also
4369         --------
4370         matplotlib.axes.Axes.get_window_extent
4371         matplotlib.axis.Axis.get_tightbbox
4372         matplotlib.spines.Spine.get_window_extent
4373         """
4374 
4375         bb = []
4376         if renderer is None:
4377             renderer = self.figure._get_renderer()
4378 
4379         if not self.get_visible():
4380             return None
4381 
4382         locator = self.get_axes_locator()
4383         self.apply_aspect(
4384             locator(self, renderer) if locator and call_axes_locator else None)
4385 
4386         for axis in self._axis_map.values():
4387             if self.axison and axis.get_visible():
4388                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4389                 if ba:
4390                     bb.append(ba)
4391         self._update_title_position(renderer)
4392         axbbox = self.get_window_extent(renderer)
4393         bb.append(axbbox)
4394 
4395         for title in [self.title, self._left_title, self._right_title]:
4396             if title.get_visible():
4397                 bt = title.get_window_extent(renderer)
4398                 if for_layout_only and bt.width > 0:
4399                     # make the title bbox 1 pixel wide so its width
4400                     # is not accounted for in bbox calculations in
4401                     # tight/constrained_layout
4402                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4403                     bt.x1 = bt.x0 + 1.0
4404                 bb.append(bt)
4405 
4406         bbox_artists = bbox_extra_artists
4407         if bbox_artists is None:
4408             bbox_artists = self.get_default_bbox_extra_artists()
4409 
4410         for a in bbox_artists:
4411             bbox = a.get_tightbbox(renderer)
4412             if (bbox is not None
4413                     and 0 < bbox.width < np.inf
4414                     and 0 < bbox.height < np.inf):
4415                 bb.append(bbox)
4416         return mtransforms.Bbox.union(
4417             [b for b in bb if b.width != 0 or b.height != 0])
4418 
4419     def _make_twin_axes(self, *args, **kwargs):
4420         """Make a twinx Axes of self. This is used for twinx and twiny."""
4421         if 'sharex' in kwargs and 'sharey' in kwargs:
4422             # The following line is added in v2.2 to avoid breaking Seaborn,
4423             # which currently uses this internal API.
4424             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4425                 raise ValueError("Twinned Axes may share only one axis")
4426         ss = self.get_subplotspec()
4427         if ss:
4428             twin = self.figure.add_subplot(ss, *args, **kwargs)
4429         else:
4430             twin = self.figure.add_axes(
4431                 self.get_position(True), *args, **kwargs,
4432                 axes_locator=_TransformedBoundsLocator(
4433                     [0, 0, 1, 1], self.transAxes))
4434         self.set_adjustable('datalim')
4435         twin.set_adjustable('datalim')
4436         self._twinned_axes.join(self, twin)
4437         return twin
4438 
4439     def twinx(self):
4440         """
4441         Create a twin Axes sharing the xaxis.
4442 
4443         Create a new Axes with an invisible x-axis and an independent
4444         y-axis positioned opposite to the original one (i.e. at right). The
4445         x-axis autoscale setting will be inherited from the original
4446         Axes.  To ensure that the tick marks of both y-axes align, see
4447         `~matplotlib.ticker.LinearLocator`.
4448 
4449         Returns
4450         -------
4451         Axes
4452             The newly created Axes instance
4453 
4454         Notes
4455         -----
4456         For those who are 'picking' artists while using twinx, pick
4457         events are only called for the artists in the top-most Axes.
4458         """
4459         ax2 = self._make_twin_axes(sharex=self)
4460         ax2.yaxis.tick_right()
4461         ax2.yaxis.set_label_position('right')
4462         ax2.yaxis.set_offset_position('right')
4463         ax2.set_autoscalex_on(self.get_autoscalex_on())
4464         self.yaxis.tick_left()
4465         ax2.xaxis.set_visible(False)
4466         ax2.patch.set_visible(False)
4467         return ax2
4468 
4469     def twiny(self):
4470         """
4471         Create a twin Axes sharing the yaxis.
4472 
4473         Create a new Axes with an invisible y-axis and an independent
4474         x-axis positioned opposite to the original one (i.e. at top). The
4475         y-axis autoscale setting will be inherited from the original Axes.
4476         To ensure that the tick marks of both x-axes align, see
4477         `~matplotlib.ticker.LinearLocator`.
4478 
4479         Returns
4480         -------
4481         Axes
4482             The newly created Axes instance
4483 
4484         Notes
4485         -----
4486         For those who are 'picking' artists while using twiny, pick
4487         events are only called for the artists in the top-most Axes.
4488         """
4489         ax2 = self._make_twin_axes(sharey=self)
4490         ax2.xaxis.tick_top()
4491         ax2.xaxis.set_label_position('top')
4492         ax2.set_autoscaley_on(self.get_autoscaley_on())
4493         self.xaxis.tick_bottom()
4494         ax2.yaxis.set_visible(False)
4495         ax2.patch.set_visible(False)
4496         return ax2
4497 
4498     def get_shared_x_axes(self):
4499         """Return an immutable view on the shared x-axes Grouper."""
4500         return cbook.GrouperView(self._shared_axes["x"])
4501 
4502     def get_shared_y_axes(self):
4503         """Return an immutable view on the shared y-axes Grouper."""
4504         return cbook.GrouperView(self._shared_axes["y"])
4505 
4506     def label_outer(self):
4507         """
4508         Only show "outer" labels and tick labels.
4509 
4510         x-labels are only kept for subplots on the last row (or first row, if
4511         labels are on the top side); y-labels only for subplots on the first
4512         column (or last column, if labels are on the right side).
4513         """
4514         self._label_outer_xaxis(check_patch=False)
4515         self._label_outer_yaxis(check_patch=False)
4516 
4517     def _label_outer_xaxis(self, *, check_patch):
4518         # see documentation in label_outer.
4519         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4520             return
4521         ss = self.get_subplotspec()
4522         if not ss:
4523             return
4524         label_position = self.xaxis.get_label_position()
4525         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4526             if label_position == "top":
4527                 self.set_xlabel("")
4528             self.xaxis.set_tick_params(which="both", labeltop=False)
4529             if self.xaxis.offsetText.get_position()[1] == 1:
4530                 self.xaxis.offsetText.set_visible(False)
4531         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4532             if label_position == "bottom":
4533                 self.set_xlabel("")
4534             self.xaxis.set_tick_params(which="both", labelbottom=False)
4535             if self.xaxis.offsetText.get_position()[1] == 0:
4536                 self.xaxis.offsetText.set_visible(False)
4537 
4538     def _label_outer_yaxis(self, *, check_patch):
4539         # see documentation in label_outer.
4540         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4541             return
4542         ss = self.get_subplotspec()
4543         if not ss:
4544             return
4545         label_position = self.yaxis.get_label_position()
4546         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4547             if label_position == "left":
4548                 self.set_ylabel("")
4549             self.yaxis.set_tick_params(which="both", labelleft=False)
4550             if self.yaxis.offsetText.get_position()[0] == 0:
4551                 self.yaxis.offsetText.set_visible(False)
4552         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4553             if label_position == "right":
4554                 self.set_ylabel("")
4555             self.yaxis.set_tick_params(which="both", labelright=False)
4556             if self.yaxis.offsetText.get_position()[0] == 1:
4557                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:34:54.163 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:34:54.163 | INFO     | Search-only: skipping patch selection
2025-10-17 14:34:54.323 | INFO     | Task matplotlib__matplotlib-25079 completed successfully.
2025-10-17 14:34:54.324 | INFO     | No patch generated. You can try running ACR again.
