{
    "django__django-11740": {
        "django/db/migrations/autodetector.py": [
            {
                "hunk": [
                    "+            dependencies = []"
                ],
                "start_lineno": 915,
                "end_lineno": 915
            },
            {
                "hunk": [
                    "+                dependencies.extend(self._get_dependencies_for_foreign_key(new_field))"
                ],
                "start_lineno": 942,
                "end_lineno": 942
            },
            {
                "hunk": [
                    "-                        )",
                    "+                        ),",
                    "+                        dependencies=dependencies,"
                ],
                "start_lineno": 973,
                "end_lineno": 973
            }
        ]
    },
    "sympy__sympy-13309": {
        "sympy/functions/elementary/miscellaneous.py": [
            {
                "hunk": [
                    "-from sympy.core.relational import Equality",
                    "+from sympy.core.relational import Equality, Relational"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "+def _minmax_as_Piecewise(op, *args):",
                    "+    # helper for Min/Max rewrite as Piecewise",
                    "+    from sympy.functions.elementary.piecewise import Piecewise",
                    "+    ec = []",
                    "+    for i, a in enumerate(args):",
                    "+        c = []",
                    "+        for j in range(i + 1, len(args)):",
                    "+            c.append(Relational(a, args[j], op))",
                    "+        ec.append((a, And(*c)))",
                    "+    return Piecewise(*ec)",
                    "+",
                    "+"
                ],
                "start_lineno": 21,
                "end_lineno": 21
            },
            {
                "hunk": [
                    "+    def _eval_rewrite_as_Piecewise(self, *args):",
                    "+        return _minmax_as_Piecewise('>=', *args)",
                    "+"
                ],
                "start_lineno": 617,
                "end_lineno": 617
            },
            {
                "hunk": [
                    "+    def _eval_rewrite_as_Piecewise(self, *args):",
                    "+        return _minmax_as_Piecewise('<=', *args)",
                    "+"
                ],
                "start_lineno": 677,
                "end_lineno": 677
            }
        ]
    },
    "django__django-16578": {
        "django/db/models/constraints.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "+from django.utils.deprecation import RemovedInDjango60Warning"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "-    def __init__(self, name, violation_error_message=None):",
                    "+    # RemovedInDjango60Warning: When the deprecation ends, replace with:",
                    "+    # def __init__(self, *, name, violation_error_message=None):",
                    "+    def __init__(self, *args, name=None, violation_error_message=None):",
                    "+        # RemovedInDjango60Warning.",
                    "+        if name is None and not args:",
                    "+            raise TypeError(",
                    "+                f\"{self.__class__.__name__}.__init__() missing 1 required keyword-only \"",
                    "+                f\"argument: 'name'\"",
                    "+            )",
                    "         self.name = name",
                    "         if violation_error_message is not None:",
                    "             self.violation_error_message = violation_error_message",
                    "         else:",
                    "             self.violation_error_message = self.default_violation_error_message",
                    "+        # RemovedInDjango60Warning.",
                    "+        if args:",
                    "+            warnings.warn(",
                    "+                f\"Passing positional arguments to {self.__class__.__name__} is \"",
                    "+                f\"deprecated.\",",
                    "+                RemovedInDjango60Warning,",
                    "+                stacklevel=2,",
                    "+            )",
                    "+            for arg, attr in zip(args, [\"name\", \"violation_error_message\"]):",
                    "+                if arg:",
                    "+                    setattr(self, attr, arg)"
                ],
                "start_lineno": 21,
                "end_lineno": 26
            },
            {
                "hunk": [
                    "-        super().__init__(name, violation_error_message=violation_error_message)",
                    "+        super().__init__(name=name, violation_error_message=violation_error_message)"
                ],
                "start_lineno": 70,
                "end_lineno": 70
            },
            {
                "hunk": [
                    "-        super().__init__(name, violation_error_message=violation_error_message)",
                    "+        super().__init__(name=name, violation_error_message=violation_error_message)"
                ],
                "start_lineno": 189,
                "end_lineno": 189
            }
        ]
    },
    "django__django-13023": {
        "django/db/models/fields/__init__.py": [
            {
                "hunk": [
                    "-        except decimal.InvalidOperation:",
                    "+        except (decimal.InvalidOperation, TypeError, ValueError):"
                ],
                "start_lineno": 1504,
                "end_lineno": 1504
            }
        ]
    },
    "django__django-14802": {
        "django/core/cache/backends/base.py": [
            {
                "hunk": [
                    "+    def validate_key(self, key):",
                    "+        \"\"\"",
                    "+        Warn about keys that would not be portable to the memcached",
                    "+        backend. This encourages (but does not force) writing backend-portable",
                    "+        cache code.",
                    "+        \"\"\"",
                    "+        for warning in memcache_key_warnings(key):",
                    "+            warnings.warn(warning, CacheKeyWarning)",
                    "+",
                    "+    def make_and_validate_key(self, key, version=None):",
                    "+        \"\"\"Helper to make and validate keys.\"\"\"",
                    "+        key = self.make_key(key, version=version)",
                    "+        self.validate_key(key)",
                    "+        return key",
                    "+"
                ],
                "start_lineno": 108,
                "end_lineno": 108
            },
            {
                "hunk": [
                    "-    def validate_key(self, key):",
                    "-        \"\"\"",
                    "-        Warn about keys that would not be portable to the memcached",
                    "-        backend. This encourages (but does not force) writing backend-portable",
                    "-        cache code.",
                    "-        \"\"\"",
                    "-        for warning in memcache_key_warnings(key):",
                    "-            warnings.warn(warning, CacheKeyWarning)",
                    "-"
                ],
                "start_lineno": 243,
                "end_lineno": 251
            }
        ],
        "django/core/cache/backends/db.py": [
            {
                "hunk": [
                    "-        key_map = {}",
                    "-        for key in keys:",
                    "-            self.validate_key(key)",
                    "-            key_map[self.make_key(key, version)] = key",
                    "+        key_map = {self.make_and_validate_key(key, version=version): key for key in keys}"
                ],
                "start_lineno": 57,
                "end_lineno": 60
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         self._base_set('set', key, value, timeout)",
                    " ",
                    "     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         return self._base_set('add', key, value, timeout)",
                    " ",
                    "     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 98,
                "end_lineno": 109
            },
            {
                "hunk": [
                    "-        self.validate_key(key)",
                    "-        return self._base_delete_many([self.make_key(key, version)])",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "+        return self._base_delete_many([key])",
                    " ",
                    "     def delete_many(self, keys, version=None):",
                    "-        key_list = []",
                    "-        for key in keys:",
                    "-            self.validate_key(key)",
                    "-            key_list.append(self.make_key(key, version))",
                    "-        self._base_delete_many(key_list)",
                    "+        keys = [self.make_and_validate_key(key, version=version) for key in keys]",
                    "+        self._base_delete_many(keys)"
                ],
                "start_lineno": 199,
                "end_lineno": 207
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 230,
                "end_lineno": 231
            }
        ],
        "django/core/cache/backends/dummy.py": [
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)",
                    "         return True",
                    " ",
                    "     def get(self, key, default=None, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)",
                    "         return default",
                    " ",
                    "     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)",
                    " ",
                    "     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)",
                    "         return False",
                    " ",
                    "     def delete(self, key, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)",
                    "         return False",
                    " ",
                    "     def has_key(self, key, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 11,
                "end_lineno": 36
            }
        ],
        "django/core/cache/backends/filebased.py": [
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 130,
                "end_lineno": 131
            }
        ],
        "django/core/cache/backends/locmem.py": [
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 26,
                "end_lineno": 27
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 36,
                "end_lineno": 37
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         pickled = pickle.dumps(value, self.pickle_protocol)",
                    "         with self._lock:",
                    "             self._set(key, pickled, timeout)",
                    " ",
                    "     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 54,
                "end_lineno": 62
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 70,
                "end_lineno": 71
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 85,
                "end_lineno": 86
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 116,
                "end_lineno": 117
            }
        ],
        "django/core/cache/backends/memcached.py": [
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         return self._cache.add(key, value, self.get_backend_timeout(timeout))",
                    " ",
                    "     def get(self, key, default=None, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         return self._cache.get(key, default)",
                    " ",
                    "     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):",
                    "             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)",
                    "             self._cache.delete(key)",
                    " ",
                    "     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))",
                    " ",
                    "     def delete(self, key, version=None):",
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)",
                    "         return bool(self._cache.delete(key))",
                    " ",
                    "     def get_many(self, keys, version=None):",
                    "-        key_map = {self.make_key(key, version=version): key for key in keys}",
                    "-        for key in key_map:",
                    "-            self.validate_key(key)",
                    "+        key_map = {self.make_and_validate_key(key, version=version): key for key in keys}"
                ],
                "start_lineno": 70,
                "end_lineno": 99
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 108,
                "end_lineno": 109
            },
            {
                "hunk": [
                    "-            safe_key = self.make_key(key, version=version)",
                    "-            self.validate_key(safe_key)",
                    "+            safe_key = self.make_and_validate_key(key, version=version)",
                    "             safe_data[safe_key] = value",
                    "             original_keys[safe_key] = key",
                    "         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))",
                    "         return [original_keys[k] for k in failed_keys]",
                    " ",
                    "     def delete_many(self, keys, version=None):",
                    "-        keys = [self.make_key(key, version=version) for key in keys]",
                    "-        for key in keys:",
                    "-            self.validate_key(key)",
                    "+        keys = [self.make_and_validate_key(key, version=version) for key in keys]"
                ],
                "start_lineno": 129,
                "end_lineno": 139
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 170,
                "end_lineno": 171
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 184,
                "end_lineno": 185
            },
            {
                "hunk": [
                    "-        key = self.make_key(key, version=version)",
                    "-        self.validate_key(key)",
                    "+        key = self.make_and_validate_key(key, version=version)"
                ],
                "start_lineno": 203,
                "end_lineno": 204
            }
        ]
    },
    "scikit-learn__scikit-learn-13017": {
        "sklearn/compose/_column_transformer.py": [
            {
                "hunk": [
                    "-    if _check_key_type(key, int):",
                    "-        if isinstance(key, int):",
                    "-            return [key]",
                    "-        elif isinstance(key, slice):",
                    "-            return list(range(n_columns)[key])",
                    "-        else:",
                    "-            return list(key)",
                    "-",
                    "+    if (_check_key_type(key, int)",
                    "+            or hasattr(key, 'dtype') and np.issubdtype(key.dtype, np.bool_)):",
                    "+        # Convert key into positive indexes",
                    "+        idx = np.arange(n_columns)[key]",
                    "+        return np.atleast_1d(idx).tolist()"
                ],
                "start_lineno": 631,
                "end_lineno": 638
            },
            {
                "hunk": [
                    "-",
                    "-    elif hasattr(key, 'dtype') and np.issubdtype(key.dtype, np.bool_):",
                    "-        # boolean mask",
                    "-        return list(np.arange(n_columns)[key])"
                ],
                "start_lineno": 661,
                "end_lineno": 664
            }
        ]
    },
    "sympy__sympy-13971": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-        return (r\"\\left\\[\"",
                    "+        return (r\"\\left[\"",
                    "               + r\", \".join(self._print(el) for el in printset)",
                    "-              + r\"\\right\\]\")",
                    "+              + r\"\\right]\")"
                ],
                "start_lineno": 1660,
                "end_lineno": 1662
            }
        ]
    },
    "scikit-learn__scikit-learn-12585": {
        "sklearn/base.py": [
            {
                "hunk": [
                    "-    elif not hasattr(estimator, 'get_params'):",
                    "+    elif not hasattr(estimator, 'get_params') or isinstance(estimator, type):"
                ],
                "start_lineno": 51,
                "end_lineno": 51
            }
        ]
    },
    "scikit-learn__scikit-learn-12983": {
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"Losses and corresponding default initial estimators for gradient boosting",
                    "+decision trees.",
                    "+\"\"\"",
                    "+",
                    "+from abc import ABCMeta",
                    "+from abc import abstractmethod",
                    "+",
                    "+import numpy as np",
                    "+from scipy.special import expit",
                    "+",
                    "+from ..tree._tree import TREE_LEAF",
                    "+from ..utils.fixes import logsumexp",
                    "+from ..utils.stats import _weighted_percentile",
                    "+from ..dummy import DummyClassifier",
                    "+from ..dummy import DummyRegressor",
                    "+",
                    "+",
                    "+class LossFunction(metaclass=ABCMeta):",
                    "+    \"\"\"Abstract base class for various loss functions.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+",
                    "+    Attributes",
                    "+    ----------",
                    "+    K : int",
                    "+        The number of regression trees to be induced;",
                    "+        1 for regression and binary classification;",
                    "+        ``n_classes`` for multi-class classification.",
                    "+    \"\"\"",
                    "+",
                    "+    is_multi_class = False",
                    "+",
                    "+    def __init__(self, n_classes):",
                    "+        self.K = n_classes",
                    "+",
                    "+    def init_estimator(self):",
                    "+        \"\"\"Default ``init`` estimator for loss function. \"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    @abstractmethod",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the loss.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves).",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+",
                    "+    @abstractmethod",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the negative gradient.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+",
                    "+    def update_terminal_regions(self, tree, X, y, residual, raw_predictions,",
                    "+                                sample_weight, sample_mask,",
                    "+                                learning_rate=0.1, k=0):",
                    "+        \"\"\"Update the terminal regions (=leaves) of the given tree and",
                    "+        updates the current predictions of the model. Traverses tree",
                    "+        and invokes template method `_update_terminal_region`.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        tree : tree.Tree",
                    "+            The tree object.",
                    "+        X : 2d array, shape (n, m)",
                    "+            The data array.",
                    "+        y : 1d array, shape (n,)",
                    "+            The target labels.",
                    "+        residual : 1d array, shape (n,)",
                    "+            The residuals (usually the negative gradient).",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        sample_weight : 1d array, shape (n,)",
                    "+            The weight of each sample.",
                    "+        sample_mask : 1d array, shape (n,)",
                    "+            The sample mask to be used.",
                    "+        learning_rate : float, default=0.1",
                    "+            Learning rate shrinks the contribution of each tree by",
                    "+             ``learning_rate``.",
                    "+        k : int, default=0",
                    "+            The index of the estimator being updated.",
                    "+",
                    "+        \"\"\"",
                    "+        # compute leaf for each sample in ``X``.",
                    "+        terminal_regions = tree.apply(X)",
                    "+",
                    "+        # mask all which are not in sample mask.",
                    "+        masked_terminal_regions = terminal_regions.copy()",
                    "+        masked_terminal_regions[~sample_mask] = -1",
                    "+",
                    "+        # update each leaf (= perform line search)",
                    "+        for leaf in np.where(tree.children_left == TREE_LEAF)[0]:",
                    "+            self._update_terminal_region(tree, masked_terminal_regions,",
                    "+                                         leaf, X, y, residual,",
                    "+                                         raw_predictions[:, k], sample_weight)",
                    "+",
                    "+        # update predictions (both in-bag and out-of-bag)",
                    "+        raw_predictions[:, k] += \\",
                    "+            learning_rate * tree.value[:, 0, 0].take(terminal_regions, axis=0)",
                    "+",
                    "+    @abstractmethod",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        \"\"\"Template method for updating terminal regions (i.e., leaves).\"\"\"",
                    "+",
                    "+    @abstractmethod",
                    "+    def get_init_raw_predictions(self, X, estimator):",
                    "+        \"\"\"Return the initial raw predictions.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        X : 2d array, shape (n_samples, n_features)",
                    "+            The data array.",
                    "+        estimator : estimator instance",
                    "+            The estimator to use to compute the predictions.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The initial raw predictions. K is equal to 1 for binary",
                    "+            classification and regression, and equal to the number of classes",
                    "+            for multiclass classification. ``raw_predictions`` is casted",
                    "+            into float64.",
                    "+        \"\"\"",
                    "+        pass",
                    "+",
                    "+",
                    "+class RegressionLossFunction(LossFunction, metaclass=ABCMeta):",
                    "+    \"\"\"Base class for regression loss functions.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+    \"\"\"",
                    "+    def __init__(self, n_classes):",
                    "+        if n_classes != 1:",
                    "+            raise ValueError(\"``n_classes`` must be 1 for regression but \"",
                    "+                             \"was %r\" % n_classes)",
                    "+        super().__init__(n_classes)",
                    "+",
                    "+    def check_init_estimator(self, estimator):",
                    "+        \"\"\"Make sure estimator has the required fit and predict methods.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        estimator : estimator instance",
                    "+            The init estimator to check.",
                    "+        \"\"\"",
                    "+        if not (hasattr(estimator, 'fit') and hasattr(estimator, 'predict')):",
                    "+            raise ValueError(",
                    "+                \"The init parameter must be a valid estimator and \"",
                    "+                \"support both fit and predict.\"",
                    "+            )",
                    "+",
                    "+    def get_init_raw_predictions(self, X, estimator):",
                    "+        predictions = estimator.predict(X)",
                    "+        return predictions.reshape(-1, 1).astype(np.float64)",
                    "+",
                    "+",
                    "+class LeastSquaresError(RegressionLossFunction):",
                    "+    \"\"\"Loss function for least squares (LS) estimation.",
                    "+    Terminal regions do not need to be updated for least squares.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+    \"\"\"",
                    "+",
                    "+    def init_estimator(self):",
                    "+        return DummyRegressor(strategy='mean')",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the least squares loss.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw_predictions (i.e. values from the tree leaves).",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        if sample_weight is None:",
                    "+            return np.mean((y - raw_predictions.ravel()) ** 2)",
                    "+        else:",
                    "+            return (1 / sample_weight.sum() * np.sum(",
                    "+                sample_weight * ((y - raw_predictions.ravel()) ** 2)))",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the negative gradient.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : 1d array, shape (n_samples,)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+        return y - raw_predictions.ravel()",
                    "+",
                    "+    def update_terminal_regions(self, tree, X, y, residual, raw_predictions,",
                    "+                                sample_weight, sample_mask,",
                    "+                                learning_rate=0.1, k=0):",
                    "+        \"\"\"Least squares does not need to update terminal regions.",
                    "+",
                    "+        But it has to update the predictions.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        tree : tree.Tree",
                    "+            The tree object.",
                    "+        X : 2d array, shape (n, m)",
                    "+            The data array.",
                    "+        y : 1d array, shape (n,)",
                    "+            The target labels.",
                    "+        residual : 1d array, shape (n,)",
                    "+            The residuals (usually the negative gradient).",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        sample_weight : 1d array, shape (n,)",
                    "+            The weight of each sample.",
                    "+        sample_mask : 1d array, shape (n,)",
                    "+            The sample mask to be used.",
                    "+        learning_rate : float, default=0.1",
                    "+            Learning rate shrinks the contribution of each tree by",
                    "+             ``learning_rate``.",
                    "+        k : int, default=0",
                    "+            The index of the estimator being updated.",
                    "+        \"\"\"",
                    "+        # update predictions",
                    "+        raw_predictions[:, k] += learning_rate * tree.predict(X).ravel()",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        pass",
                    "+",
                    "+",
                    "+class LeastAbsoluteError(RegressionLossFunction):",
                    "+    \"\"\"Loss function for least absolute deviation (LAD) regression.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes",
                    "+    \"\"\"",
                    "+    def init_estimator(self):",
                    "+        return DummyRegressor(strategy='quantile', quantile=.5)",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the least absolute error.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : array, shape (n_samples, K)",
                    "+            The raw_predictions (i.e. values from the tree leaves).",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        if sample_weight is None:",
                    "+            return np.abs(y - raw_predictions.ravel()).mean()",
                    "+        else:",
                    "+            return (1 / sample_weight.sum() * np.sum(",
                    "+                sample_weight * np.abs(y - raw_predictions.ravel())))",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the negative gradient.",
                    "+",
                    "+        1.0 if y - raw_predictions > 0.0 else -1.0",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        return 2 * (y - raw_predictions > 0) - 1",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        \"\"\"LAD updates terminal regions to median estimates.\"\"\"",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+        diff = (y.take(terminal_region, axis=0) -",
                    "+                raw_predictions.take(terminal_region, axis=0))",
                    "+        tree.value[leaf, 0, 0] = _weighted_percentile(diff, sample_weight,",
                    "+                                                      percentile=50)",
                    "+",
                    "+",
                    "+class HuberLossFunction(RegressionLossFunction):",
                    "+    \"\"\"Huber loss function for robust regression.",
                    "+",
                    "+    M-Regression proposed in Friedman 2001.",
                    "+",
                    "+    References",
                    "+    ----------",
                    "+    J. Friedman, Greedy Function Approximation: A Gradient Boosting",
                    "+    Machine, The Annals of Statistics, Vol. 29, No. 5, 2001.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+",
                    "+    alpha : float, default=0.9",
                    "+        Percentile at which to extract score.",
                    "+    \"\"\"",
                    "+",
                    "+    def __init__(self, n_classes, alpha=0.9):",
                    "+        super().__init__(n_classes)",
                    "+        self.alpha = alpha",
                    "+        self.gamma = None",
                    "+",
                    "+    def init_estimator(self):",
                    "+        return DummyRegressor(strategy='quantile', quantile=.5)",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the Huber loss.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        diff = y - raw_predictions",
                    "+        gamma = self.gamma",
                    "+        if gamma is None:",
                    "+            if sample_weight is None:",
                    "+                gamma = np.percentile(np.abs(diff), self.alpha * 100)",
                    "+            else:",
                    "+                gamma = _weighted_percentile(np.abs(diff), sample_weight,",
                    "+                                             self.alpha * 100)",
                    "+",
                    "+        gamma_mask = np.abs(diff) <= gamma",
                    "+        if sample_weight is None:",
                    "+            sq_loss = np.sum(0.5 * diff[gamma_mask] ** 2)",
                    "+            lin_loss = np.sum(gamma * (np.abs(diff[~gamma_mask]) -",
                    "+                                       gamma / 2))",
                    "+            loss = (sq_loss + lin_loss) / y.shape[0]",
                    "+        else:",
                    "+            sq_loss = np.sum(0.5 * sample_weight[gamma_mask] *",
                    "+                             diff[gamma_mask] ** 2)",
                    "+            lin_loss = np.sum(gamma * sample_weight[~gamma_mask] *",
                    "+                              (np.abs(diff[~gamma_mask]) - gamma / 2))",
                    "+            loss = (sq_loss + lin_loss) / sample_weight.sum()",
                    "+        return loss",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, sample_weight=None,",
                    "+                          **kargs):",
                    "+        \"\"\"Compute the negative gradient.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        diff = y - raw_predictions",
                    "+        if sample_weight is None:",
                    "+            gamma = np.percentile(np.abs(diff), self.alpha * 100)",
                    "+        else:",
                    "+            gamma = _weighted_percentile(np.abs(diff), sample_weight,",
                    "+                                         self.alpha * 100)",
                    "+        gamma_mask = np.abs(diff) <= gamma",
                    "+        residual = np.zeros((y.shape[0],), dtype=np.float64)",
                    "+        residual[gamma_mask] = diff[gamma_mask]",
                    "+        residual[~gamma_mask] = gamma * np.sign(diff[~gamma_mask])",
                    "+        self.gamma = gamma",
                    "+        return residual",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+        gamma = self.gamma",
                    "+        diff = (y.take(terminal_region, axis=0)",
                    "+                - raw_predictions.take(terminal_region, axis=0))",
                    "+        median = _weighted_percentile(diff, sample_weight, percentile=50)",
                    "+        diff_minus_median = diff - median",
                    "+        tree.value[leaf, 0] = median + np.mean(",
                    "+            np.sign(diff_minus_median) *",
                    "+            np.minimum(np.abs(diff_minus_median), gamma))",
                    "+",
                    "+",
                    "+class QuantileLossFunction(RegressionLossFunction):",
                    "+    \"\"\"Loss function for quantile regression.",
                    "+",
                    "+    Quantile regression allows to estimate the percentiles",
                    "+    of the conditional distribution of the target.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+",
                    "+    alpha : float, optional (default = 0.9)",
                    "+        The percentile.",
                    "+    \"\"\"",
                    "+    def __init__(self, n_classes, alpha=0.9):",
                    "+        super().__init__(n_classes)",
                    "+        self.alpha = alpha",
                    "+        self.percentile = alpha * 100",
                    "+",
                    "+    def init_estimator(self):",
                    "+        return DummyRegressor(strategy='quantile', quantile=self.alpha)",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the Quantile loss.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        diff = y - raw_predictions",
                    "+        alpha = self.alpha",
                    "+",
                    "+        mask = y > raw_predictions",
                    "+        if sample_weight is None:",
                    "+            loss = (alpha * diff[mask].sum() -",
                    "+                    (1 - alpha) * diff[~mask].sum()) / y.shape[0]",
                    "+        else:",
                    "+            loss = ((alpha * np.sum(sample_weight[mask] * diff[mask]) -",
                    "+                    (1 - alpha) * np.sum(sample_weight[~mask] *",
                    "+                                         diff[~mask])) / sample_weight.sum())",
                    "+        return loss",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the negative gradient.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw_predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+        alpha = self.alpha",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        mask = y > raw_predictions",
                    "+        return (alpha * mask) - ((1 - alpha) * ~mask)",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        diff = (y.take(terminal_region, axis=0)",
                    "+                - raw_predictions.take(terminal_region, axis=0))",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+",
                    "+        val = _weighted_percentile(diff, sample_weight, self.percentile)",
                    "+        tree.value[leaf, 0] = val",
                    "+",
                    "+",
                    "+class ClassificationLossFunction(LossFunction, metaclass=ABCMeta):",
                    "+    \"\"\"Base class for classification loss functions. \"\"\"",
                    "+",
                    "+    def _raw_prediction_to_proba(self, raw_predictions):",
                    "+        \"\"\"Template method to convert raw predictions into probabilities.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        probas : 2d array, shape (n_samples, K)",
                    "+            The predicted probabilities.",
                    "+        \"\"\"",
                    "+",
                    "+    @abstractmethod",
                    "+    def _raw_prediction_to_decision(self, raw_predictions):",
                    "+        \"\"\"Template method to convert raw predictions to decisions.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        encoded_predictions : 2d array, shape (n_samples, K)",
                    "+            The predicted encoded labels.",
                    "+        \"\"\"",
                    "+",
                    "+    def check_init_estimator(self, estimator):",
                    "+        \"\"\"Make sure estimator has fit and predict_proba methods.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        estimator : estimator instance",
                    "+            The init estimator to check.",
                    "+        \"\"\"",
                    "+        if not (hasattr(estimator, 'fit') and",
                    "+                hasattr(estimator, 'predict_proba')):",
                    "+            raise ValueError(",
                    "+                \"The init parameter must be a valid estimator \"",
                    "+                \"and support both fit and predict_proba.\"",
                    "+            )",
                    "+",
                    "+",
                    "+class BinomialDeviance(ClassificationLossFunction):",
                    "+    \"\"\"Binomial deviance loss function for binary classification.",
                    "+",
                    "+    Binary classification is a special case; here, we only need to",
                    "+    fit one tree instead of ``n_classes`` trees.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+    \"\"\"",
                    "+    def __init__(self, n_classes):",
                    "+        if n_classes != 2:",
                    "+            raise ValueError(\"{0:s} requires 2 classes; got {1:d} class(es)\"",
                    "+                             .format(self.__class__.__name__, n_classes))",
                    "+        # we only need to fit one tree for binary clf.",
                    "+        super().__init__(n_classes=1)",
                    "+",
                    "+    def init_estimator(self):",
                    "+        # return the most common class, taking into account the samples",
                    "+        # weights",
                    "+        return DummyClassifier(strategy='prior')",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the deviance (= 2 * negative log-likelihood).",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        sample_weight : 1d array , shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        # logaddexp(0, v) == log(1.0 + exp(v))",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        if sample_weight is None:",
                    "+            return -2 * np.mean((y * raw_predictions) -",
                    "+                                np.logaddexp(0, raw_predictions))",
                    "+        else:",
                    "+            return (-2 / sample_weight.sum() * np.sum(",
                    "+                sample_weight * ((y * raw_predictions) -",
                    "+                                 np.logaddexp(0, raw_predictions))))",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the residual (= negative gradient).",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw_predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+        return y - expit(raw_predictions.ravel())",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        \"\"\"Make a single Newton-Raphson step.",
                    "+",
                    "+        our node estimate is given by:",
                    "+",
                    "+            sum(w * (y - prob)) / sum(w * prob * (1 - prob))",
                    "+",
                    "+        we take advantage that: y - prob = residual",
                    "+        \"\"\"",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        residual = residual.take(terminal_region, axis=0)",
                    "+        y = y.take(terminal_region, axis=0)",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+",
                    "+        numerator = np.sum(sample_weight * residual)",
                    "+        denominator = np.sum(sample_weight *",
                    "+                             (y - residual) * (1 - y + residual))",
                    "+",
                    "+        # prevents overflow and division by zero",
                    "+        if abs(denominator) < 1e-150:",
                    "+            tree.value[leaf, 0, 0] = 0.0",
                    "+        else:",
                    "+            tree.value[leaf, 0, 0] = numerator / denominator",
                    "+",
                    "+    def _raw_prediction_to_proba(self, raw_predictions):",
                    "+        proba = np.ones((raw_predictions.shape[0], 2), dtype=np.float64)",
                    "+        proba[:, 1] = expit(raw_predictions.ravel())",
                    "+        proba[:, 0] -= proba[:, 1]",
                    "+        return proba",
                    "+",
                    "+    def _raw_prediction_to_decision(self, raw_predictions):",
                    "+        proba = self._raw_prediction_to_proba(raw_predictions)",
                    "+        return np.argmax(proba, axis=1)",
                    "+",
                    "+    def get_init_raw_predictions(self, X, estimator):",
                    "+        probas = estimator.predict_proba(X)",
                    "+        proba_pos_class = probas[:, 1]",
                    "+        eps = np.finfo(np.float32).eps",
                    "+        proba_pos_class = np.clip(proba_pos_class, eps, 1 - eps)",
                    "+        # log(x / (1 - x)) is the inverse of the sigmoid (expit) function",
                    "+        raw_predictions = np.log(proba_pos_class / (1 - proba_pos_class))",
                    "+        return raw_predictions.reshape(-1, 1).astype(np.float64)",
                    "+",
                    "+",
                    "+class MultinomialDeviance(ClassificationLossFunction):",
                    "+    \"\"\"Multinomial deviance loss function for multi-class classification.",
                    "+",
                    "+    For multi-class classification we need to fit ``n_classes`` trees at",
                    "+    each stage.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+    \"\"\"",
                    "+",
                    "+    is_multi_class = True",
                    "+",
                    "+    def __init__(self, n_classes):",
                    "+        if n_classes < 3:",
                    "+            raise ValueError(\"{0:s} requires more than 2 classes.\".format(",
                    "+                self.__class__.__name__))",
                    "+        super().__init__(n_classes)",
                    "+",
                    "+    def init_estimator(self):",
                    "+        return DummyClassifier(strategy='prior')",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the Multinomial deviance.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        # create one-hot label encoding",
                    "+        Y = np.zeros((y.shape[0], self.K), dtype=np.float64)",
                    "+        for k in range(self.K):",
                    "+            Y[:, k] = y == k",
                    "+",
                    "+        if sample_weight is None:",
                    "+            return np.sum(-1 * (Y * raw_predictions).sum(axis=1) +",
                    "+                          logsumexp(raw_predictions, axis=1))",
                    "+        else:",
                    "+            return np.sum(",
                    "+                -1 * sample_weight * (Y * raw_predictions).sum(axis=1) +",
                    "+                logsumexp(raw_predictions, axis=1))",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, k=0, **kwargs):",
                    "+        \"\"\"Compute negative gradient for the ``k``-th class.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            The target labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw_predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+",
                    "+        k : int, optional default=0",
                    "+            The index of the class.",
                    "+        \"\"\"",
                    "+        return y - np.nan_to_num(np.exp(raw_predictions[:, k] -",
                    "+                                        logsumexp(raw_predictions, axis=1)))",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        \"\"\"Make a single Newton-Raphson step. \"\"\"",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        residual = residual.take(terminal_region, axis=0)",
                    "+        y = y.take(terminal_region, axis=0)",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+",
                    "+        numerator = np.sum(sample_weight * residual)",
                    "+        numerator *= (self.K - 1) / self.K",
                    "+",
                    "+        denominator = np.sum(sample_weight * (y - residual) *",
                    "+                             (1 - y + residual))",
                    "+",
                    "+        # prevents overflow and division by zero",
                    "+        if abs(denominator) < 1e-150:",
                    "+            tree.value[leaf, 0, 0] = 0.0",
                    "+        else:",
                    "+            tree.value[leaf, 0, 0] = numerator / denominator",
                    "+",
                    "+    def _raw_prediction_to_proba(self, raw_predictions):",
                    "+        return np.nan_to_num(",
                    "+            np.exp(raw_predictions -",
                    "+                   (logsumexp(raw_predictions, axis=1)[:, np.newaxis])))",
                    "+",
                    "+    def _raw_prediction_to_decision(self, raw_predictions):",
                    "+        proba = self._raw_prediction_to_proba(raw_predictions)",
                    "+        return np.argmax(proba, axis=1)",
                    "+",
                    "+    def get_init_raw_predictions(self, X, estimator):",
                    "+        probas = estimator.predict_proba(X)",
                    "+        eps = np.finfo(np.float32).eps",
                    "+        probas = np.clip(probas, eps, 1 - eps)",
                    "+        raw_predictions = np.log(probas).astype(np.float64)",
                    "+        return raw_predictions",
                    "+",
                    "+",
                    "+class ExponentialLoss(ClassificationLossFunction):",
                    "+    \"\"\"Exponential loss function for binary classification.",
                    "+",
                    "+    Same loss as AdaBoost.",
                    "+",
                    "+    References",
                    "+    ----------",
                    "+    Greg Ridgeway, Generalized Boosted Models: A guide to the gbm package, 2007",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    n_classes : int",
                    "+        Number of classes.",
                    "+    \"\"\"",
                    "+    def __init__(self, n_classes):",
                    "+        if n_classes != 2:",
                    "+            raise ValueError(\"{0:s} requires 2 classes; got {1:d} class(es)\"",
                    "+                             .format(self.__class__.__name__, n_classes))",
                    "+        # we only need to fit one tree for binary clf.",
                    "+        super().__init__(n_classes=1)",
                    "+",
                    "+    def init_estimator(self):",
                    "+        return DummyClassifier(strategy='prior')",
                    "+",
                    "+    def __call__(self, y, raw_predictions, sample_weight=None):",
                    "+        \"\"\"Compute the exponential loss",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble.",
                    "+",
                    "+        sample_weight : 1d array, shape (n_samples,), optional",
                    "+            Sample weights.",
                    "+        \"\"\"",
                    "+        raw_predictions = raw_predictions.ravel()",
                    "+        if sample_weight is None:",
                    "+            return np.mean(np.exp(-(2. * y - 1.) * raw_predictions))",
                    "+        else:",
                    "+            return (1.0 / sample_weight.sum() * np.sum(",
                    "+                sample_weight * np.exp(-(2 * y - 1) * raw_predictions)))",
                    "+",
                    "+    def negative_gradient(self, y, raw_predictions, **kargs):",
                    "+        \"\"\"Compute the residual (= negative gradient).",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        y : 1d array, shape (n_samples,)",
                    "+            True labels.",
                    "+",
                    "+        raw_predictions : 2d array, shape (n_samples, K)",
                    "+            The raw predictions (i.e. values from the tree leaves) of the",
                    "+            tree ensemble at iteration ``i - 1``.",
                    "+        \"\"\"",
                    "+        y_ = -(2. * y - 1.)",
                    "+        return y_ * np.exp(y_ * raw_predictions.ravel())",
                    "+",
                    "+    def _update_terminal_region(self, tree, terminal_regions, leaf, X, y,",
                    "+                                residual, raw_predictions, sample_weight):",
                    "+        terminal_region = np.where(terminal_regions == leaf)[0]",
                    "+        raw_predictions = raw_predictions.take(terminal_region, axis=0)",
                    "+        y = y.take(terminal_region, axis=0)",
                    "+        sample_weight = sample_weight.take(terminal_region, axis=0)",
                    "+",
                    "+        y_ = 2. * y - 1.",
                    "+",
                    "+        numerator = np.sum(y_ * sample_weight * np.exp(-y_ * raw_predictions))",
                    "+        denominator = np.sum(sample_weight * np.exp(-y_ * raw_predictions))",
                    "+",
                    "+        # prevents overflow and division by zero",
                    "+        if abs(denominator) < 1e-150:",
                    "+            tree.value[leaf, 0, 0] = 0.0",
                    "+        else:",
                    "+            tree.value[leaf, 0, 0] = numerator / denominator",
                    "+",
                    "+    def _raw_prediction_to_proba(self, raw_predictions):",
                    "+        proba = np.ones((raw_predictions.shape[0], 2), dtype=np.float64)",
                    "+        proba[:, 1] = expit(2.0 * raw_predictions.ravel())",
                    "+        proba[:, 0] -= proba[:, 1]",
                    "+        return proba",
                    "+",
                    "+    def _raw_prediction_to_decision(self, raw_predictions):",
                    "+        return (raw_predictions.ravel() >= 0).astype(np.int)",
                    "+",
                    "+    def get_init_raw_predictions(self, X, estimator):",
                    "+        probas = estimator.predict_proba(X)",
                    "+        proba_pos_class = probas[:, 1]",
                    "+        eps = np.finfo(np.float32).eps",
                    "+        proba_pos_class = np.clip(proba_pos_class, eps, 1 - eps)",
                    "+        # according to The Elements of Statistical Learning sec. 10.5, the",
                    "+        # minimizer of the exponential loss is .5 * log odds ratio. So this is",
                    "+        # the equivalent to .5 * binomial_deviance.get_init_raw_predictions()",
                    "+        raw_predictions = .5 * np.log(proba_pos_class / (1 - proba_pos_class))",
                    "+        return raw_predictions.reshape(-1, 1).astype(np.float64)",
                    "+",
                    "+",
                    "+LOSS_FUNCTIONS = {",
                    "+    'ls': LeastSquaresError,",
                    "+    'lad': LeastAbsoluteError,",
                    "+    'huber': HuberLossFunction,",
                    "+    'quantile': QuantileLossFunction,",
                    "+    'deviance': None,    # for both, multinomial and binomial",
                    "+    'exponential': ExponentialLoss,",
                    "+}"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "sklearn/ensemble/gradient_boosting.py": [
            {
                "hunk": [
                    "+from ..base import BaseEstimator",
                    "+from ..base import is_classifier"
                ],
                "start_lineno": 29,
                "end_lineno": 29
            },
            {
                "hunk": [
                    "+from . import _gb_losses"
                ],
                "start_lineno": 47,
                "end_lineno": 47
            },
            {
                "hunk": [
                    "+# FIXME: 0.23",
                    "+# All the losses and corresponding init estimators have been moved to the",
                    "+# _losses module in 0.21. We deprecate them and keep them here for now in case",
                    "+# someone has imported them. None of these losses can be used as a parameter",
                    "+# to a GBDT estimator anyway (loss param only accepts strings).",
                    "+",
                    "+@deprecated(\"QuantileEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 61,
                "end_lineno": 61
            },
            {
                "hunk": [
                    "+@deprecated(\"MeanEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 114,
                "end_lineno": 114
            },
            {
                "hunk": [
                    "+@deprecated(\"LogOddsEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 155,
                "end_lineno": 155
            },
            {
                "hunk": [
                    "+@deprecated(\"ScaledLogOddsEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")",
                    " class ScaledLogOddsEstimator(LogOddsEstimator):",
                    "     \"\"\"Log odds ratio scaled by 0.5 -- for exponential loss. \"\"\"",
                    "     scale = 0.5",
                    " ",
                    " ",
                    "+@deprecated(\"PriorProbablityEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 205,
                "end_lineno": 209
            },
            {
                "hunk": [
                    "+@deprecated(\"Using ZeroEstimator is deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")",
                    " class ZeroEstimator:",
                    "-    \"\"\"An estimator that simply predicts zero. \"\"\"",
                    "+    \"\"\"An estimator that simply predicts zero.",
                    "+",
                    "+    .. deprecated:: 0.21",
                    "+        Using ``ZeroEstimator`` or ``init='zero'`` is deprecated in version",
                    "+        0.21 and will be removed in version 0.23.",
                    "+",
                    "+    \"\"\""
                ],
                "start_lineno": 253,
                "end_lineno": 254
            },
            {
                "hunk": [
                    "+    def predict_proba(self, X):",
                    "+        return self.predict(X)",
                    "+",
                    " ",
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 298,
                "end_lineno": 298
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 406,
                "end_lineno": 406
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 421,
                "end_lineno": 421
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 504,
                "end_lineno": 504
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 560,
                "end_lineno": 560
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 663,
                "end_lineno": 663
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 740,
                "end_lineno": 740
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 758,
                "end_lineno": 758
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 849,
                "end_lineno": 849
            },
            {
                "hunk": [
                    "+@deprecated(\"All Losses in sklearn.ensemble.gradient_boosting are \"",
                    "+            \"deprecated in version \"",
                    "+            \"0.21 and will be removed in version 0.23.\")"
                ],
                "start_lineno": 944,
                "end_lineno": 944
            },
            {
                "hunk": [
                    "-LOSS_FUNCTIONS = {'ls': LeastSquaresError,",
                    "-                  'lad': LeastAbsoluteError,",
                    "-                  'huber': HuberLossFunction,",
                    "-                  'quantile': QuantileLossFunction,",
                    "-                  'deviance': None,    # for both, multinomial and binomial",
                    "-                  'exponential': ExponentialLoss,",
                    "-                  }",
                    "-",
                    "-",
                    "-INIT_ESTIMATORS = {'zero': ZeroEstimator}",
                    "-",
                    "-",
                    "-class VerboseReporter:",
                    "+class VerboseReporter(object):"
                ],
                "start_lineno": 1031,
                "end_lineno": 1043
            },
            {
                "hunk": [
                    "-    def _fit_stage(self, i, X, y, y_pred, sample_weight, sample_mask,",
                    "+    def _fit_stage(self, i, X, y, raw_predictions, sample_weight, sample_mask,"
                ],
                "start_lineno": 1154,
                "end_lineno": 1154
            },
            {
                "hunk": [
                    "-        # Need to pass a copy of y_pred to negative_gradient() because y_pred",
                    "-        # is partially updated at the end of the loop in",
                    "-        # update_terminal_regions(), and gradients need to be evaluated at",
                    "+        # Need to pass a copy of raw_predictions to negative_gradient()",
                    "+        # because raw_predictions is partially updated at the end of the loop",
                    "+        # in update_terminal_regions(), and gradients need to be evaluated at",
                    "         # iteration i - 1.",
                    "-        y_pred_copy = y_pred.copy()",
                    "+        raw_predictions_copy = raw_predictions.copy()",
                    " ",
                    "         for k in range(loss.K):",
                    "             if loss.is_multi_class:",
                    "                 y = np.array(original_y == k, dtype=np.float64)",
                    " ",
                    "-            residual = loss.negative_gradient(y, y_pred_copy, k=k,",
                    "+            residual = loss.negative_gradient(y, raw_predictions_copy, k=k,"
                ],
                "start_lineno": 1162,
                "end_lineno": 1172
            },
            {
                "hunk": [
                    "-            loss.update_terminal_regions(tree.tree_, X, y, residual, y_pred,",
                    "-                                         sample_weight, sample_mask,",
                    "-                                         learning_rate=self.learning_rate, k=k)",
                    "+            loss.update_terminal_regions(",
                    "+                tree.tree_, X, y, residual, raw_predictions, sample_weight,",
                    "+                sample_mask, learning_rate=self.learning_rate, k=k)",
                    " ",
                    "             # add tree to ensemble",
                    "             self.estimators_[i, k] = tree",
                    " ",
                    "-        return y_pred",
                    "+        return raw_predictions"
                ],
                "start_lineno": 1199,
                "end_lineno": 1206
            },
            {
                "hunk": [
                    "-                or self.loss not in LOSS_FUNCTIONS):",
                    "+                or self.loss not in _gb_losses.LOSS_FUNCTIONS):",
                    "             raise ValueError(\"Loss '{0:s}' not supported. \".format(self.loss))",
                    " ",
                    "         if self.loss == 'deviance':",
                    "-            loss_class = (MultinomialDeviance",
                    "+            loss_class = (_gb_losses.MultinomialDeviance",
                    "                           if len(self.classes_) > 2",
                    "-                          else BinomialDeviance)",
                    "+                          else _gb_losses.BinomialDeviance)",
                    "         else:",
                    "-            loss_class = LOSS_FUNCTIONS[self.loss]",
                    "+            loss_class = _gb_losses.LOSS_FUNCTIONS[self.loss]"
                ],
                "start_lineno": 1219,
                "end_lineno": 1227
            },
            {
                "hunk": [
                    "-            if isinstance(self.init, str):",
                    "-                if self.init not in INIT_ESTIMATORS:",
                    "-                    raise ValueError('init=\"%s\" is not supported' % self.init)",
                    "-            else:",
                    "-                if (not hasattr(self.init, 'fit')",
                    "-                        or not hasattr(self.init, 'predict')):",
                    "-                    raise ValueError(\"init=%r must be valid BaseEstimator \"",
                    "-                                     \"and support both fit and \"",
                    "-                                     \"predict\" % self.init)",
                    "+            # init must be an estimator or 'zero'",
                    "+            if isinstance(self.init, BaseEstimator):",
                    "+                self.loss_.check_init_estimator(self.init)",
                    "+            elif not (isinstance(self.init, str) and self.init == 'zero'):",
                    "+                raise ValueError(",
                    "+                    \"The init parameter must be an estimator or 'zero'. \"",
                    "+                    \"Got init={}\".format(self.init)",
                    "+                )"
                ],
                "start_lineno": 1239,
                "end_lineno": 1247
            },
            {
                "hunk": [
                    "-        if self.init is None:",
                    "+        self.init_ = self.init",
                    "+        if self.init_ is None:",
                    "             self.init_ = self.loss_.init_estimator()",
                    "-        elif isinstance(self.init, str):",
                    "-            self.init_ = INIT_ESTIMATORS[self.init]()",
                    "-        else:",
                    "-            self.init_ = self.init"
                ],
                "start_lineno": 1296,
                "end_lineno": 1301
            },
            {
                "hunk": [
                    "-        if sample_weight is None:",
                    "+",
                    "+        sample_weight_is_none = sample_weight is None",
                    "+        if sample_weight_is_none:",
                    "             sample_weight = np.ones(n_samples, dtype=np.float32)",
                    "         else:",
                    "             sample_weight = column_or_1d(sample_weight, warn=True)",
                    "+            sample_weight_is_none = False"
                ],
                "start_lineno": 1399,
                "end_lineno": 1402
            },
            {
                "hunk": [
                    "+            if is_classifier(self):",
                    "+                if self.n_classes_ != np.unique(y).shape[0]:",
                    "+                    # We choose to error here. The problem is that the init",
                    "+                    # estimator would be trained on y, which has some missing",
                    "+                    # classes now, so its predictions would not have the",
                    "+                    # correct shape.",
                    "+                    raise ValueError(",
                    "+                        'The training data after the early stopping split '",
                    "+                        'is missing some classes. Try using another random '",
                    "+                        'seed.'",
                    "+                    )"
                ],
                "start_lineno": 1413,
                "end_lineno": 1413
            },
            {
                "hunk": [
                    "-            # fit initial model - FIXME make sample_weight optional",
                    "-            self.init_.fit(X, y, sample_weight)",
                    "+            # fit initial model and initialize raw predictions",
                    "+            if self.init_ == 'zero':",
                    "+                raw_predictions = np.zeros(shape=(X.shape[0], self.loss_.K),",
                    "+                                           dtype=np.float64)",
                    "+            else:",
                    "+                try:",
                    "+                    self.init_.fit(X, y, sample_weight=sample_weight)",
                    "+                except TypeError:",
                    "+                    if sample_weight_is_none:",
                    "+                        self.init_.fit(X, y)",
                    "+                    else:",
                    "+                        raise ValueError(",
                    "+                            \"The initial estimator {} does not support sample \"",
                    "+                            \"weights.\".format(self.init_.__class__.__name__))",
                    "+",
                    "+                raw_predictions = \\",
                    "+                    self.loss_.get_init_raw_predictions(X, self.init_)",
                    "+",
                    " ",
                    "-            # init predictions",
                    "-            y_pred = self.init_.predict(X)"
                ],
                "start_lineno": 1422,
                "end_lineno": 1426
            },
            {
                "hunk": [
                    "-            y_pred = self._decision_function(X)",
                    "+            raw_predictions = self._raw_predict(X)"
                ],
                "start_lineno": 1446,
                "end_lineno": 1446
            },
            {
                "hunk": [
                    "-        n_stages = self._fit_stages(X, y, y_pred, sample_weight, self._rng,",
                    "-                                    X_val, y_val, sample_weight_val,",
                    "-                                    begin_at_stage, monitor, X_idx_sorted)",
                    "+        n_stages = self._fit_stages(",
                    "+            X, y, raw_predictions, sample_weight, self._rng, X_val, y_val,",
                    "+            sample_weight_val, begin_at_stage, monitor, X_idx_sorted)"
                ],
                "start_lineno": 1465,
                "end_lineno": 1467
            },
            {
                "hunk": [
                    "-    def _fit_stages(self, X, y, y_pred, sample_weight, random_state,",
                    "+    def _fit_stages(self, X, y, raw_predictions, sample_weight, random_state,"
                ],
                "start_lineno": 1479,
                "end_lineno": 1479
            },
            {
                "hunk": [
                    "-            y_val_pred_iter = self._staged_decision_function(X_val)",
                    "+            y_val_pred_iter = self._staged_raw_predict(X_val)"
                ],
                "start_lineno": 1513,
                "end_lineno": 1513
            },
            {
                "hunk": [
                    "-                                      y_pred[~sample_mask],",
                    "+                                      raw_predictions[~sample_mask],",
                    "                                       sample_weight[~sample_mask])",
                    " ",
                    "             # fit next stage of trees",
                    "-            y_pred = self._fit_stage(i, X, y, y_pred, sample_weight,",
                    "-                                     sample_mask, random_state, X_idx_sorted,",
                    "-                                     X_csc, X_csr)",
                    "+            raw_predictions = self._fit_stage(",
                    "+                i, X, y, raw_predictions, sample_weight, sample_mask,",
                    "+                random_state, X_idx_sorted, X_csc, X_csr)",
                    " ",
                    "             # track deviance (= loss)",
                    "             if do_oob:",
                    "                 self.train_score_[i] = loss_(y[sample_mask],",
                    "-                                             y_pred[sample_mask],",
                    "+                                             raw_predictions[sample_mask],",
                    "                                              sample_weight[sample_mask])",
                    "                 self.oob_improvement_[i] = (",
                    "                     old_oob_score - loss_(y[~sample_mask],",
                    "-                                          y_pred[~sample_mask],",
                    "+                                          raw_predictions[~sample_mask],",
                    "                                           sample_weight[~sample_mask]))",
                    "             else:",
                    "                 # no need to fancy index w/ no subsampling",
                    "-                self.train_score_[i] = loss_(y, y_pred, sample_weight)",
                    "+                self.train_score_[i] = loss_(y, raw_predictions, sample_weight)"
                ],
                "start_lineno": 1525,
                "end_lineno": 1544
            },
            {
                "hunk": [
                    "-    def _init_decision_function(self, X):",
                    "-        \"\"\"Check input and compute prediction of ``init``. \"\"\"",
                    "+    def _raw_predict_init(self, X):",
                    "+        \"\"\"Check input and compute raw predictions of the init estimtor.\"\"\"",
                    "         self._check_initialized()",
                    "         X = self.estimators_[0, 0]._validate_X_predict(X, check_input=True)",
                    "         if X.shape[1] != self.n_features_:",
                    "             raise ValueError(\"X.shape[1] should be {0:d}, not {1:d}.\".format(",
                    "                 self.n_features_, X.shape[1]))",
                    "-        score = self.init_.predict(X).astype(np.float64)",
                    "-        return score",
                    "-",
                    "-    def _decision_function(self, X):",
                    "-        # for use in inner loop, not raveling the output in single-class case,",
                    "-        # not doing input validation.",
                    "-        score = self._init_decision_function(X)",
                    "-        predict_stages(self.estimators_, X, self.learning_rate, score)",
                    "-        return score",
                    "+        if self.init_ == 'zero':",
                    "+            raw_predictions = np.zeros(shape=(X.shape[0], self.loss_.K),",
                    "+                                       dtype=np.float64)",
                    "+        else:",
                    "+            raw_predictions = self.loss_.get_init_raw_predictions(",
                    "+                X, self.init_).astype(np.float64)",
                    "+        return raw_predictions",
                    " ",
                    "+    def _raw_predict(self, X):",
                    "+        \"\"\"Return the sum of the trees raw predictions (+ init estimator).\"\"\"",
                    "+        raw_predictions = self._raw_predict_init(X)",
                    "+        predict_stages(self.estimators_, X, self.learning_rate,",
                    "+                       raw_predictions)",
                    "+        return raw_predictions",
                    " ",
                    "-    def _staged_decision_function(self, X):",
                    "-        \"\"\"Compute decision function of ``X`` for each iteration.",
                    "+    def _staged_raw_predict(self, X):",
                    "+        \"\"\"Compute raw predictions of ``X`` for each iteration."
                ],
                "start_lineno": 1575,
                "end_lineno": 1594
            },
            {
                "hunk": [
                    "-        score : generator of array, shape (n_samples, k)",
                    "-            The decision function of the input samples. The order of the",
                    "+        raw_predictions : generator of array, shape (n_samples, k)",
                    "+            The raw predictions of the input samples. The order of the",
                    "             classes corresponds to that in the attribute `classes_`.",
                    "             Regression and binary classification are special cases with",
                    "             ``k == 1``, otherwise ``k==n_classes``.",
                    "         \"\"\"",
                    "         X = check_array(X, dtype=DTYPE, order=\"C\",  accept_sparse='csr')",
                    "-        score = self._init_decision_function(X)",
                    "+        raw_predictions = self._raw_predict_init(X)",
                    "         for i in range(self.estimators_.shape[0]):",
                    "-            predict_stage(self.estimators_, i, X, self.learning_rate, score)",
                    "-            yield score.copy()",
                    "+            predict_stage(self.estimators_, i, X, self.learning_rate,",
                    "+                          raw_predictions)",
                    "+            yield raw_predictions.copy()"
                ],
                "start_lineno": 1608,
                "end_lineno": 1618
            },
            {
                "hunk": [
                    "-    init : estimator, optional",
                    "-        An estimator object that is used to compute the initial",
                    "-        predictions. ``init`` has to provide ``fit`` and ``predict``.",
                    "-        If None it uses ``loss.init_estimator``.",
                    "+    init : estimator or 'zero', optional (default=None)",
                    "+        An estimator object that is used to compute the initial predictions.",
                    "+        ``init`` has to provide `fit` and `predict_proba`. If 'zero', the",
                    "+        initial raw predictions are set to zero. By default, a",
                    "+        ``DummyEstimator`` predicting the classes priors is used."
                ],
                "start_lineno": 1796,
                "end_lineno": 1799
            },
            {
                "hunk": [
                    "-            The decision function of the input samples. The order of the",
                    "-            classes corresponds to that in the attribute `classes_`.",
                    "-            Regression and binary classification produce an array of shape",
                    "-            [n_samples].",
                    "+            The decision function of the input samples, which corresponds to",
                    "+            the raw values predicted from the trees of the ensemble . The",
                    "+            order of the classes corresponds to that in the attribute",
                    "+            `classes_`. Regression and binary classification produce an",
                    "+            array of shape [n_samples].",
                    "         \"\"\"",
                    "         X = check_array(X, dtype=DTYPE, order=\"C\",  accept_sparse='csr')",
                    "-        score = self._decision_function(X)",
                    "-        if score.shape[1] == 1:",
                    "-            return score.ravel()",
                    "-        return score",
                    "+        raw_predictions = self._raw_predict(X)",
                    "+        if raw_predictions.shape[1] == 1:",
                    "+            return raw_predictions.ravel()",
                    "+        return raw_predictions"
                ],
                "start_lineno": 1987,
                "end_lineno": 1996
            },
            {
                "hunk": [
                    "-            The decision function of the input samples. The order of the",
                    "+            The decision function of the input samples, which corresponds to",
                    "+            the raw values predicted from the trees of the ensemble . The",
                    "             classes corresponds to that in the attribute `classes_`.",
                    "             Regression and binary classification are special cases with",
                    "             ``k == 1``, otherwise ``k==n_classes``.",
                    "         \"\"\"",
                    "-        yield from self._staged_decision_function(X)",
                    "+        yield from self._staged_raw_predict(X)"
                ],
                "start_lineno": 2014,
                "end_lineno": 2019
            },
            {
                "hunk": [
                    "-        score = self.decision_function(X)",
                    "-        decisions = self.loss_._score_to_decision(score)",
                    "-        return self.classes_.take(decisions, axis=0)",
                    "+        raw_predictions = self.decision_function(X)",
                    "+        encoded_labels = \\",
                    "+            self.loss_._raw_prediction_to_decision(raw_predictions)",
                    "+        return self.classes_.take(encoded_labels, axis=0)"
                ],
                "start_lineno": 2036,
                "end_lineno": 2038
            },
            {
                "hunk": [
                    "-        for score in self._staged_decision_function(X):",
                    "-            decisions = self.loss_._score_to_decision(score)",
                    "-            yield self.classes_.take(decisions, axis=0)",
                    "+        for raw_predictions in self._staged_raw_predict(X):",
                    "+            encoded_labels = \\",
                    "+                self.loss_._raw_prediction_to_decision(raw_predictions)",
                    "+            yield self.classes_.take(encoded_labels, axis=0)"
                ],
                "start_lineno": 2058,
                "end_lineno": 2060
            },
            {
                "hunk": [
                    "-        score = self.decision_function(X)",
                    "+        raw_predictions = self.decision_function(X)",
                    "         try:",
                    "-            return self.loss_._score_to_proba(score)",
                    "+            return self.loss_._raw_prediction_to_proba(raw_predictions)"
                ],
                "start_lineno": 2083,
                "end_lineno": 2085
            },
            {
                "hunk": [
                    "-            for score in self._staged_decision_function(X):",
                    "-                yield self.loss_._score_to_proba(score)",
                    "+            for raw_predictions in self._staged_raw_predict(X):",
                    "+                yield self.loss_._raw_prediction_to_proba(raw_predictions)"
                ],
                "start_lineno": 2135,
                "end_lineno": 2136
            },
            {
                "hunk": [
                    "-    init : estimator, optional (default=None)",
                    "-        An estimator object that is used to compute the initial",
                    "-        predictions. ``init`` has to provide ``fit`` and ``predict``.",
                    "-        If None it uses ``loss.init_estimator``.",
                    "+    init : estimator or 'zero', optional (default=None)",
                    "+        An estimator object that is used to compute the initial predictions.",
                    "+        ``init`` has to provide `fit` and `predict`. If 'zero', the initial",
                    "+        raw predictions are set to zero. By default a ``DummyEstimator`` is",
                    "+        used, predicting either the average target value (for loss='ls'), or",
                    "+        a quantile for the other losses."
                ],
                "start_lineno": 2254,
                "end_lineno": 2257
            },
            {
                "hunk": [
                    "-        return self._decision_function(X).ravel()",
                    "+        # In regression we can directly return the raw value from the trees.",
                    "+        return self._raw_predict(X).ravel()"
                ],
                "start_lineno": 2429,
                "end_lineno": 2429
            },
            {
                "hunk": [
                    "-        for y in self._staged_decision_function(X):",
                    "-            yield y.ravel()",
                    "+        for raw_predictions in self._staged_raw_predict(X):",
                    "+            yield raw_predictions.ravel()"
                ],
                "start_lineno": 2449,
                "end_lineno": 2450
            }
        ]
    },
    "astropy__astropy-6938": {
        "astropy/io/fits/fitsrec.py": [
            {
                "hunk": [
                    "-            output_field.replace(encode_ascii('E'), encode_ascii('D'))",
                    "+            output_field[:] = output_field.replace(b'E', b'D')"
                ],
                "start_lineno": 1264,
                "end_lineno": 1264
            }
        ]
    },
    "django__django-13265": {
        "django/db/migrations/autodetector.py": [
            {
                "hunk": [
                    "+        self.generate_altered_order_with_respect_to()",
                    "         self.generate_altered_unique_together()",
                    "         self.generate_altered_index_together()",
                    "         self.generate_added_indexes()",
                    "         self.generate_added_constraints()",
                    "         self.generate_altered_db_table()",
                    "-        self.generate_altered_order_with_respect_to()"
                ],
                "start_lineno": 185,
                "end_lineno": 190
            },
            {
                "hunk": [
                    "+            if order_with_respect_to:",
                    "+                self.add_operation(",
                    "+                    app_label,",
                    "+                    operations.AlterOrderWithRespectTo(",
                    "+                        name=model_name,",
                    "+                        order_with_respect_to=order_with_respect_to,",
                    "+                    ),",
                    "+                    dependencies=[",
                    "+                        (app_label, model_name, order_with_respect_to, True),",
                    "+                        (app_label, model_name, None, True),",
                    "+                    ]",
                    "+                )"
                ],
                "start_lineno": 616,
                "end_lineno": 616
            },
            {
                "hunk": [
                    "-            if order_with_respect_to:",
                    "-                self.add_operation(",
                    "-                    app_label,",
                    "-                    operations.AlterOrderWithRespectTo(",
                    "-                        name=model_name,",
                    "-                        order_with_respect_to=order_with_respect_to,",
                    "-                    ),",
                    "-                    dependencies=[",
                    "-                        (app_label, model_name, order_with_respect_to, True),",
                    "-                        (app_label, model_name, None, True),",
                    "-                    ]",
                    "-                )",
                    "-"
                ],
                "start_lineno": 657,
                "end_lineno": 669
            }
        ]
    },
    "django__django-13551": {
        "django/contrib/auth/tokens.py": [
            {
                "hunk": [
                    "-        Hash the user's primary key and some user state that's sure to change",
                    "-        after a password reset to produce a token that invalidated when it's",
                    "-        used:",
                    "+        Hash the user's primary key, email (if available), and some user state",
                    "+        that's sure to change after a password reset to produce a token that is",
                    "+        invalidated when it's used:"
                ],
                "start_lineno": 81,
                "end_lineno": 83
            },
            {
                "hunk": [
                    "-        return str(user.pk) + user.password + str(login_timestamp) + str(timestamp)",
                    "+        email_field = user.get_email_field_name()",
                    "+        email = getattr(user, email_field, '') or ''",
                    "+        return f'{user.pk}{user.password}{login_timestamp}{timestamp}{email}'"
                ],
                "start_lineno": 97,
                "end_lineno": 97
            }
        ]
    },
    "astropy__astropy-12842": {
        "astropy/time/core.py": [
            {
                "hunk": [
                    "-__all__ = ['TimeBase', 'Time', 'TimeDelta', 'TimeInfo', 'update_leap_seconds',",
                    "+__all__ = ['TimeBase', 'Time', 'TimeDelta', 'TimeInfo', 'TimeInfoBase', 'update_leap_seconds',"
                ],
                "start_lineno": 37,
                "end_lineno": 37
            },
            {
                "hunk": [
                    "-class TimeInfo(MixinInfo):",
                    "+class TimeInfoBase(MixinInfo):",
                    "     \"\"\"",
                    "     Container for meta information like name, description, format.  This is",
                    "     required when the object is used as a mixin column within a table, but can",
                    "     be used as a general way to store meta information.",
                    "+",
                    "+    This base class is common between TimeInfo and TimeDeltaInfo."
                ],
                "start_lineno": 113,
                "end_lineno": 117
            },
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 136,
                "end_lineno": 136
            },
            {
                "hunk": [
                    "-    def _construct_from_dict_base(self, map):",
                    "+    def _construct_from_dict(self, map):"
                ],
                "start_lineno": 185,
                "end_lineno": 185
            },
            {
                "hunk": [
                    "-    def _construct_from_dict(self, map):",
                    "-        delta_ut1_utc = map.pop('_delta_ut1_utc', None)",
                    "-        delta_tdb_tt = map.pop('_delta_tdb_tt', None)",
                    "-",
                    "-        out = self._construct_from_dict_base(map)",
                    "-",
                    "-        if delta_ut1_utc is not None:",
                    "-            out._delta_ut1_utc = delta_ut1_utc",
                    "-        if delta_tdb_tt is not None:",
                    "-            out._delta_tdb_tt = delta_tdb_tt",
                    "-",
                    "-        return out",
                    "-"
                ],
                "start_lineno": 204,
                "end_lineno": 216
            },
            {
                "hunk": [
                    "-class TimeDeltaInfo(TimeInfo):",
                    "-    _represent_as_dict_extra_attrs = ('format', 'scale')",
                    "+class TimeInfo(TimeInfoBase):",
                    "+    \"\"\"",
                    "+    Container for meta information like name, description, format.  This is",
                    "+    required when the object is used as a mixin column within a table, but can",
                    "+    be used as a general way to store meta information.",
                    "+    \"\"\"",
                    "+    def _represent_as_dict(self, attrs=None):",
                    "+        \"\"\"Get the values for the parent ``attrs`` and return as a dict.",
                    "+",
                    "+        By default, uses '_represent_as_dict_attrs'.",
                    "+        \"\"\"",
                    "+        map = super()._represent_as_dict(attrs=attrs)",
                    "+",
                    "+        # TODO: refactor these special cases into the TimeFormat classes?",
                    "+",
                    "+        # The datetime64 format requires special handling for ECSV (see #12840).",
                    "+        # The `value` has numpy dtype datetime64 but this is not an allowed",
                    "+        # datatype for ECSV. Instead convert to a string representation.",
                    "+        if (self._serialize_context == 'ecsv'",
                    "+                and map['format'] == 'datetime64'",
                    "+                and 'value' in map):",
                    "+            map['value'] = map['value'].astype('U')",
                    "+",
                    "+        # The datetime format is serialized as ISO with no loss of precision.",
                    "+        if map['format'] == 'datetime' and 'value' in map:",
                    "+            map['value'] = np.vectorize(lambda x: x.isoformat())(map['value'])",
                    "+",
                    "+        return map",
                    " ",
                    "     def _construct_from_dict(self, map):",
                    "-        return self._construct_from_dict_base(map)",
                    "+        # See comment above. May need to convert string back to datetime64.",
                    "+        # Note that _serialize_context is not set here so we just look for the",
                    "+        # string value directly.",
                    "+        if (map['format'] == 'datetime64'",
                    "+                and 'value' in map",
                    "+                and map['value'].dtype.kind == 'U'):",
                    "+            map['value'] = map['value'].astype('datetime64')",
                    "+",
                    "+        # Convert back to datetime objects for datetime format.",
                    "+        if map['format'] == 'datetime' and 'value' in map:",
                    "+            from datetime import datetime",
                    "+            map['value'] = np.vectorize(datetime.fromisoformat)(map['value'])",
                    "+",
                    "+        delta_ut1_utc = map.pop('_delta_ut1_utc', None)",
                    "+        delta_tdb_tt = map.pop('_delta_tdb_tt', None)",
                    "+",
                    "+        out = super()._construct_from_dict(map)",
                    "+",
                    "+        if delta_ut1_utc is not None:",
                    "+            out._delta_ut1_utc = delta_ut1_utc",
                    "+        if delta_tdb_tt is not None:",
                    "+            out._delta_tdb_tt = delta_tdb_tt",
                    "+",
                    "+        return out",
                    "+",
                    "+",
                    "+class TimeDeltaInfo(TimeInfoBase):",
                    "+    \"\"\"",
                    "+    Container for meta information like name, description, format.  This is",
                    "+    required when the object is used as a mixin column within a table, but can",
                    "+    be used as a general way to store meta information.",
                    "+    \"\"\"",
                    "+    _represent_as_dict_extra_attrs = ('format', 'scale')"
                ],
                "start_lineno": 279,
                "end_lineno": 283
            },
            {
                "hunk": [
                    "-        \"\"\"",
                    "+        \"\"\"  # noqa"
                ],
                "start_lineno": 1818,
                "end_lineno": 1818
            },
            {
                "hunk": [
                    "-        \"\"\"  # docstring is formatted below",
                    "+        \"\"\"  # noqa (docstring is formatted below)"
                ],
                "start_lineno": 1880,
                "end_lineno": 1880
            },
            {
                "hunk": [
                    "-        \"\"\"",
                    "+        \"\"\"  # noqa"
                ],
                "start_lineno": 1932,
                "end_lineno": 1932
            },
            {
                "hunk": [
                    "-                 @ rotation_matrix(theta+sp, 'z', unit=u.radian))",
                    "+                 @ rotation_matrix(theta + sp, 'z', unit=u.radian))"
                ],
                "start_lineno": 1959,
                "end_lineno": 1959
            },
            {
                "hunk": [
                    "-        from astropy.utils import iers"
                ],
                "start_lineno": 2784,
                "end_lineno": 2784
            }
        ],
        "astropy/time/formats.py": [
            {
                "hunk": [
                    "-        if hasattr(val1, 'to') and hasattr(val1, 'unit'):",
                    "+        if hasattr(val1, 'to') and hasattr(val1, 'unit') and val1.unit is not None:"
                ],
                "start_lineno": 1748,
                "end_lineno": 1748
            }
        ]
    },
    "pytest-dev__pytest-7158": {
        "src/_pytest/skipping.py": [
            {
                "hunk": [
                    "-        filename, line = item.location[:2]",
                    "-        rep.longrepr = filename, line + 1, reason",
                    "+        filename, line = item.reportinfo()[:2]",
                    "+        rep.longrepr = str(filename), line + 1, reason"
                ],
                "start_lineno": 171,
                "end_lineno": 172
            }
        ]
    },
    "django__django-11707": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    def __getstate__(self):",
                    "+        state = super().__getstate__()",
                    "+        state.pop('_constructor_args', None)",
                    "+        return state",
                    "+"
                ],
                "start_lineno": 1022,
                "end_lineno": 1022
            }
        ]
    },
    "sphinx-doc__sphinx-7351": {
        "sphinx/project.py": [
            {
                "hunk": [
                    "+from glob import glob"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "-                if os.access(os.path.join(self.srcdir, filename), os.R_OK):",
                    "+                if docname in self.docnames:",
                    "+                    pattern = os.path.join(self.srcdir, docname) + '.*'",
                    "+                    files = [relpath(f, self.srcdir) for f in glob(pattern)]",
                    "+                    logger.warning(__('multiple files found for the document \"%s\": %r\\n'",
                    "+                                      'Use %r for the build.'),",
                    "+                                   docname, files, self.doc2path(docname), once=True)",
                    "+                elif os.access(os.path.join(self.srcdir, filename), os.R_OK):"
                ],
                "start_lineno": 58,
                "end_lineno": 58
            }
        ],
        "sphinx/util/logging.py": [
            {
                "hunk": [
                    "+    KEYWORDS = ['type', 'subtype', 'location', 'nonl', 'color', 'once']"
                ],
                "start_lineno": 121,
                "end_lineno": 121
            },
            {
                "hunk": [
                    "-        if 'type' in kwargs:",
                    "-            extra['type'] = kwargs.pop('type')",
                    "-        if 'subtype' in kwargs:",
                    "-            extra['subtype'] = kwargs.pop('subtype')",
                    "-        if 'location' in kwargs:",
                    "-            extra['location'] = kwargs.pop('location')",
                    "-        if 'nonl' in kwargs:",
                    "-            extra['nonl'] = kwargs.pop('nonl')",
                    "-        if 'color' in kwargs:",
                    "-            extra['color'] = kwargs.pop('color')",
                    "+        for keyword in self.KEYWORDS:",
                    "+            if keyword in kwargs:",
                    "+                extra[keyword] = kwargs.pop(keyword)"
                ],
                "start_lineno": 134,
                "end_lineno": 143
            },
            {
                "hunk": [
                    "+class OnceFilter(logging.Filter):",
                    "+    \"\"\"Show the message only once.\"\"\"",
                    "+",
                    "+    def __init__(self, name: str = '') -> None:",
                    "+        super().__init__(name)",
                    "+        self.messages = {}  # type: Dict[str, List]",
                    "+",
                    "+    def filter(self, record: logging.LogRecord) -> bool:",
                    "+        once = getattr(record, 'once', '')",
                    "+        if not once:",
                    "+            return True",
                    "+        else:",
                    "+            params = self.messages.setdefault(record.msg, [])",
                    "+            if record.args in params:",
                    "+                return False",
                    "+",
                    "+            params.append(record.args)",
                    "+            return True",
                    "+",
                    "+"
                ],
                "start_lineno": 449,
                "end_lineno": 449
            },
            {
                "hunk": [
                    "+    warning_handler.addFilter(OnceFilter())"
                ],
                "start_lineno": 566,
                "end_lineno": 566
            }
        ]
    },
    "pytest-dev__pytest-6202": {
        "src/_pytest/python.py": [
            {
                "hunk": [
                    "-        s = \".\".join(parts)",
                    "-        return s.replace(\".[\", \"[\")",
                    "+        return \".\".join(parts)"
                ],
                "start_lineno": 288,
                "end_lineno": 289
            }
        ]
    },
    "matplotlib__matplotlib-25746": {
        "lib/matplotlib/axes/_base.py": [
            {
                "hunk": [
                    "+        labelfontfamily : str",
                    "+            Tick label font."
                ],
                "start_lineno": 3340,
                "end_lineno": 3340
            }
        ],
        "lib/matplotlib/axis.py": [
            {
                "hunk": [
                    "+        labelfontfamily=None,"
                ],
                "start_lineno": 67,
                "end_lineno": 67
            },
            {
                "hunk": [
                    "-            rotation=self._labelrotation[1])",
                    "+            fontfamily=labelfontfamily, rotation=self._labelrotation[1])",
                    "         self.label2 = mtext.Text(",
                    "             np.nan, np.nan,",
                    "             fontsize=labelsize, color=labelcolor, visible=label2On,",
                    "-            rotation=self._labelrotation[1])",
                    "+            fontfamily=labelfontfamily, rotation=self._labelrotation[1])"
                ],
                "start_lineno": 177,
                "end_lineno": 181
            },
            {
                "hunk": [
                    "-                    if k in ['labelsize', 'labelcolor']}",
                    "+                    if k in ['labelsize', 'labelcolor', 'labelfontfamily']}"
                ],
                "start_lineno": 379,
                "end_lineno": 379
            },
            {
                "hunk": [
                    "-            'labelsize', 'labelcolor', 'zorder', 'gridOn',",
                    "+            'labelsize', 'labelcolor', 'labelfontfamily', 'zorder', 'gridOn',"
                ],
                "start_lineno": 1039,
                "end_lineno": 1039
            }
        ]
    },
    "sphinx-doc__sphinx-8801": {
        "sphinx/ext/autodoc/importer.py": [
            {
                "hunk": [
                    "+            try:",
                    "+                modname = safe_getattr(cls, '__module__')",
                    "+                qualname = safe_getattr(cls, '__qualname__')",
                    "+                analyzer = ModuleAnalyzer.for_module(modname)",
                    "+                analyzer.analyze()",
                    "+            except AttributeError:",
                    "+                qualname = None",
                    "+                analyzer = None",
                    "+            except PycodeError:",
                    "+                analyzer = None",
                    "+",
                    "             # annotation only member (ex. attr: int)",
                    "             for name in getannotations(cls):",
                    "                 name = unmangle(cls, name)",
                    "                 if name and name not in members:",
                    "-                    members[name] = ObjectMember(name, INSTANCEATTR, class_=cls)",
                    "+                    if analyzer and (qualname, name) in analyzer.attr_docs:",
                    "+                        docstring = '\\n'.join(analyzer.attr_docs[qualname, name])",
                    "+                    else:",
                    "+                        docstring = None",
                    "+",
                    "+                    members[name] = ObjectMember(name, INSTANCEATTR, class_=cls,",
                    "+                                                 docstring=docstring)",
                    " ",
                    "             # append instance attributes (cf. self.attr1) if analyzer knows",
                    "-            try:",
                    "-                modname = safe_getattr(cls, '__module__')",
                    "-                qualname = safe_getattr(cls, '__qualname__')",
                    "-                analyzer = ModuleAnalyzer.for_module(modname)",
                    "-                analyzer.analyze()",
                    "+            if analyzer:",
                    "                 for (ns, name), docstring in analyzer.attr_docs.items():",
                    "                     if ns == qualname and name not in members:",
                    "                         members[name] = ObjectMember(name, INSTANCEATTR, class_=cls,",
                    "                                                      docstring='\\n'.join(docstring))",
                    "-            except (AttributeError, PycodeError):",
                    "-                pass"
                ],
                "start_lineno": 297,
                "end_lineno": 314
            }
        ]
    },
    "sympy__sympy-16493": {
        "sympy/tensor/tensor.py": [
            {
                "hunk": [
                    "-    def replace_with_arrays(self, replacement_dict, indices):",
                    "+    def replace_with_arrays(self, replacement_dict, indices=None):"
                ],
                "start_lineno": 2113,
                "end_lineno": 2113
            },
            {
                "hunk": [
                    "-            the index order with respect to which the array is read.",
                    "+            the index order with respect to which the array is read. The",
                    "+            original index order will be used if no value is passed."
                ],
                "start_lineno": 2125,
                "end_lineno": 2125
            },
            {
                "hunk": [
                    "+",
                    "+        Since 'indices' is optional, we can also call replace_with_arrays by",
                    "+        this way if no specific index order is needed:",
                    "+",
                    "+        >>> A(i).replace_with_arrays({A(i): [1, 2]})",
                    "+        [1, 2]",
                    "+",
                    "         >>> expr = A(i)*A(j)",
                    "-        >>> expr.replace_with_arrays({A(i): [1, 2]}, [i, j])",
                    "+        >>> expr.replace_with_arrays({A(i): [1, 2]})",
                    "         [[1, 2], [2, 4]]",
                    " ",
                    "         For contractions, specify the metric of the ``TensorIndexType``, which",
                    "         in this case is ``L``, in its covariant form:",
                    " ",
                    "         >>> expr = A(i)*A(-i)",
                    "-        >>> expr.replace_with_arrays({A(i): [1, 2], L: diag(1, -1)}, [])",
                    "+        >>> expr.replace_with_arrays({A(i): [1, 2], L: diag(1, -1)})"
                ],
                "start_lineno": 2139,
                "end_lineno": 2147
            },
            {
                "hunk": [
                    "-        >>> expr.replace_with_arrays({H(i, j): [[a, b], [c, d]]}, [i, j])",
                    "+        >>> expr.replace_with_arrays({H(i, j): [[a, b], [c, d]]})",
                    "         [[a, b/2 + c/2], [b/2 + c/2, d]]",
                    " ",
                    "         Anti-symmetrization of an array:",
                    " ",
                    "         >>> expr = H(i, j)/2 - H(j, i)/2",
                    "         >>> repl = {H(i, j): [[a, b], [c, d]]}",
                    "-        >>> expr.replace_with_arrays(repl, [i, j])",
                    "+        >>> expr.replace_with_arrays(repl)"
                ],
                "start_lineno": 2155,
                "end_lineno": 2162
            },
            {
                "hunk": [
                    "+        indices = indices or []"
                ],
                "start_lineno": 2173,
                "end_lineno": 2173
            }
        ]
    },
    "sympy__sympy-21931": {
        "sympy/calculus/singularities.py": [
            {
                "hunk": [
                    "-    FiniteSet(-1)",
                    "+    {-1}",
                    "     >>> singularities(1/(y**2 + 1), y)",
                    "-    FiniteSet(I, -I)",
                    "+    {-I, I}",
                    "     >>> singularities(1/(y**3 + 1), y)",
                    "-    FiniteSet(-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2)",
                    "+    {-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}",
                    "     >>> singularities(log(x), x)",
                    "-    FiniteSet(0)",
                    "+    {0}"
                ],
                "start_lineno": 76,
                "end_lineno": 82
            }
        ],
        "sympy/calculus/util.py": [
            {
                "hunk": [
                    "-    FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)",
                    "+    {pi/2, 3*pi/2, 5*pi/2, 7*pi/2}"
                ],
                "start_lineno": 738,
                "end_lineno": 738
            },
            {
                "hunk": [
                    "-        FiniteSet(1, 2)",
                    "+        {1, 2}"
                ],
                "start_lineno": 1495,
                "end_lineno": 1495
            }
        ],
        "sympy/categories/baseclasses.py": [
            {
                "hunk": [
                    "-        Class(FiniteSet(Object(\"A\"), Object(\"B\")))",
                    "+        Class({Object(\"A\"), Object(\"B\")})"
                ],
                "start_lineno": 525,
                "end_lineno": 525
            },
            {
                "hunk": [
                    "-        FiniteSet(unique)",
                    "+        {unique}"
                ],
                "start_lineno": 730,
                "end_lineno": 730
            },
            {
                "hunk": [
                    "-        FiniteSet(Object(\"A\"), Object(\"B\"), Object(\"C\"))",
                    "+        {Object(\"A\"), Object(\"B\"), Object(\"C\")}"
                ],
                "start_lineno": 862,
                "end_lineno": 862
            }
        ],
        "sympy/combinatorics/partitions.py": [
            {
                "hunk": [
                    "-        Partition(FiniteSet(1, 2), FiniteSet(3))",
                    "+        Partition({3}, {1, 2})"
                ],
                "start_lineno": 43,
                "end_lineno": 43
            },
            {
                "hunk": [
                    "-        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))",
                    "+        Partition({4, 5}, {1, 2, 3})"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "-        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))",
                    "+        Partition({4, 5}, {1, 2, 3})"
                ],
                "start_lineno": 62,
                "end_lineno": 62
            },
            {
                "hunk": [
                    "-        [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]",
                    "+        [Partition({1, 2}), Partition({1}, {2}), Partition({1, x}), Partition({3, 4}), Partition({0, 1, 2, 3})]"
                ],
                "start_lineno": 108,
                "end_lineno": 108
            },
            {
                "hunk": [
                    "-        Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))",
                    "+        Partition({3}, {4}, {5}, {1, 2})"
                ],
                "start_lineno": 254,
                "end_lineno": 254
            },
            {
                "hunk": [
                    "-        Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))",
                    "+        Partition({c}, {a, d}, {b, e})",
                    "         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))",
                    "-        Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))",
                    "+        Partition({e}, {a, c}, {b, d})",
                    "         >>> a = Partition([1, 4], [2], [3, 5])",
                    "         >>> Partition.from_rgs(a.RGS, a.members)",
                    "-        Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))",
                    "+        Partition({2}, {1, 4}, {3, 5})"
                ],
                "start_lineno": 285,
                "end_lineno": 290
            }
        ],
        "sympy/combinatorics/polyhedron.py": [
            {
                "hunk": [
                    "-            FiniteSet((0, 1, 2))",
                    "+            {(0, 1, 2)}",
                    "             >>> Polyhedron(list('abc'), [(1, 0, 2)]).faces",
                    "-            FiniteSet((0, 1, 2))",
                    "+            {(0, 1, 2)}"
                ],
                "start_lineno": 55,
                "end_lineno": 57
            },
            {
                "hunk": [
                    "-        FiniteSet((0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3))",
                    "+        {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}"
                ],
                "start_lineno": 101,
                "end_lineno": 101
            },
            {
                "hunk": [
                    "-        FiniteSet((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7))",
                    "+        {(0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7)}"
                ],
                "start_lineno": 374,
                "end_lineno": 374
            },
            {
                "hunk": [
                    "-        FiniteSet((0, 1), (0, 2), (1, 2))",
                    "+        {(0, 1), (0, 2), (1, 2)}"
                ],
                "start_lineno": 501,
                "end_lineno": 501
            }
        ],
        "sympy/core/function.py": [
            {
                "hunk": [
                    "-        FiniteSet(1)",
                    "+        {1}",
                    "         >>> Function('f', nargs=(2, 1)).nargs",
                    "-        FiniteSet(1, 2)",
                    "+        {1, 2}"
                ],
                "start_lineno": 234,
                "end_lineno": 236
            },
            {
                "hunk": [
                    "-    FiniteSet(2)",
                    "+    {2}"
                ],
                "start_lineno": 1006,
                "end_lineno": 1006
            },
            {
                "hunk": [
                    "-    FiniteSet(1, 2)",
                    "+    {1, 2}"
                ],
                "start_lineno": 1017,
                "end_lineno": 1017
            }
        ],
        "sympy/logic/boolalg.py": [
            {
                "hunk": [
                    "-        FiniteSet(0)",
                    "+        {0}"
                ],
                "start_lineno": 144,
                "end_lineno": 144
            }
        ],
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "+from sympy.sets.sets import FiniteSet"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "+    def _print_FiniteSet(self, s):",
                    "+        items = sorted(s, key=default_sort_key)",
                    "+",
                    "+        args = ', '.join(self._print(item) for item in items)",
                    "+        if any(item.has(FiniteSet) for item in items):",
                    "+            return 'FiniteSet({})'.format(args)",
                    "+        return '{{{}}}'.format(args)",
                    "+",
                    "+    def _print_Partition(self, s):",
                    "+        items = sorted(s, key=default_sort_key)",
                    "+",
                    "+        args = ', '.join(self._print(arg) for arg in items)",
                    "+        return 'Partition({})'.format(args)",
                    "+"
                ],
                "start_lineno": 799,
                "end_lineno": 799
            }
        ],
        "sympy/sets/conditionset.py": [
            {
                "hunk": [
                    "-    ConditionSet(x, x < 1, FiniteSet(y, z))",
                    "+    ConditionSet(x, x < 1, {y, z})"
                ],
                "start_lineno": 63,
                "end_lineno": 63
            }
        ],
        "sympy/sets/fancysets.py": [
            {
                "hunk": [
                    "-    FiniteSet(1, 4, 9)",
                    "+    {1, 4, 9}"
                ],
                "start_lineno": 309,
                "end_lineno": 309
            },
            {
                "hunk": [
                    "-    FiniteSet(0)",
                    "+    {0}"
                ],
                "start_lineno": 331,
                "end_lineno": 331
            },
            {
                "hunk": [
                    "-    FiniteSet(0, pi)",
                    "+    {0, pi}"
                ],
                "start_lineno": 1024,
                "end_lineno": 1024
            },
            {
                "hunk": [
                    "-        CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))",
                    "+        CartesianComplexRegion(ProductSet(Interval(0, 1), {0}))"
                ],
                "start_lineno": 1303,
                "end_lineno": 1303
            }
        ],
        "sympy/sets/powerset.py": [
            {
                "hunk": [
                    "-    PowerSet(FiniteSet(1, 2, 3))",
                    "+    PowerSet({1, 2, 3})"
                ],
                "start_lineno": 44,
                "end_lineno": 44
            },
            {
                "hunk": [
                    "-    FiniteSet(FiniteSet(1), FiniteSet(1, 2), FiniteSet(1, 3),",
                    "-            FiniteSet(1, 2, 3), FiniteSet(2), FiniteSet(2, 3),",
                    "-            FiniteSet(3), EmptySet)",
                    "+    FiniteSet(EmptySet, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3})"
                ],
                "start_lineno": 61,
                "end_lineno": 63
            }
        ],
        "sympy/sets/sets.py": [
            {
                "hunk": [
                    "-        Union(FiniteSet(3), Interval.Lopen(1, 2))",
                    "+        Union({3}, Interval.Lopen(1, 2))"
                ],
                "start_lineno": 104,
                "end_lineno": 104
            },
            {
                "hunk": [
                    "-        FiniteSet(EmptySet)",
                    "+        {EmptySet}"
                ],
                "start_lineno": 495,
                "end_lineno": 495
            },
            {
                "hunk": [
                    "-        FiniteSet(0, 1)",
                    "+        {0, 1}",
                    "         >>> Interval(0, 1, True, False).boundary",
                    "-        FiniteSet(0, 1)",
                    "+        {0, 1}"
                ],
                "start_lineno": 561,
                "end_lineno": 563
            },
            {
                "hunk": [
                    "-    ProductSet(Interval(0, 5), FiniteSet(1, 2, 3))",
                    "+    ProductSet(Interval(0, 5), {1, 2, 3})"
                ],
                "start_lineno": 714,
                "end_lineno": 714
            },
            {
                "hunk": [
                    "-    FiniteSet(0, 2)",
                    "+    {0, 2}"
                ],
                "start_lineno": 1549,
                "end_lineno": 1549
            },
            {
                "hunk": [
                    "-    FiniteSet(1, 2, 3, 4)",
                    "+    {1, 2, 3, 4}",
                    "     >>> 3 in FiniteSet(1, 2, 3, 4)",
                    "     True",
                    " ",
                    "     >>> members = [1, 2, 3, 4]",
                    "     >>> f = FiniteSet(*members)",
                    "     >>> f",
                    "-    FiniteSet(1, 2, 3, 4)",
                    "+    {1, 2, 3, 4}",
                    "     >>> f - FiniteSet(2)",
                    "-    FiniteSet(1, 3, 4)",
                    "+    {1, 3, 4}",
                    "     >>> f + FiniteSet(2, 5)",
                    "-    FiniteSet(1, 2, 3, 4, 5)",
                    "+    {1, 2, 3, 4, 5}"
                ],
                "start_lineno": 1751,
                "end_lineno": 1762
            },
            {
                "hunk": [
                    "-    FiniteSet(1, 2, 4, 5)",
                    "+    {1, 2, 4, 5}"
                ],
                "start_lineno": 1982,
                "end_lineno": 1982
            },
            {
                "hunk": [
                    "-    DisjointUnion(FiniteSet(1, 2, 3), Interval(0, 5))",
                    "+    DisjointUnion({1, 2, 3}, Interval(0, 5))",
                    "     >>> DisjointUnion(A, B).rewrite(Union)",
                    "-    Union(ProductSet(FiniteSet(1, 2, 3), FiniteSet(0)), ProductSet(Interval(0, 5), FiniteSet(1)))",
                    "+    Union(ProductSet({1, 2, 3}, {0}), ProductSet(Interval(0, 5), {1}))",
                    "     >>> C = FiniteSet(Symbol('x'), Symbol('y'), Symbol('z'))",
                    "     >>> DisjointUnion(C, C)",
                    "-    DisjointUnion(FiniteSet(x, y, z), FiniteSet(x, y, z))",
                    "+    DisjointUnion({x, y, z}, {x, y, z})",
                    "     >>> DisjointUnion(C, C).rewrite(Union)",
                    "-    ProductSet(FiniteSet(x, y, z), FiniteSet(0, 1))",
                    "+    ProductSet({x, y, z}, {0, 1})"
                ],
                "start_lineno": 2053,
                "end_lineno": 2060
            }
        ],
        "sympy/solvers/inequalities.py": [
            {
                "hunk": [
                    "-    [FiniteSet(0)]",
                    "+    [{0}]",
                    " ",
                    "     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')",
                    "     [Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]",
                    " ",
                    "     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')",
                    "-    [FiniteSet(-1), FiniteSet(1)]",
                    "+    [{-1}, {1}]"
                ],
                "start_lineno": 31,
                "end_lineno": 37
            },
            {
                "hunk": [
                    "-    FiniteSet(1)",
                    "+    {1}"
                ],
                "start_lineno": 143,
                "end_lineno": 143
            }
        ],
        "sympy/solvers/solveset.py": [
            {
                "hunk": [
                    "-    (x, Intersection(FiniteSet(log(y)), Reals))",
                    "+    (x, Intersection({log(y)}, Reals))",
                    " ",
                    "     When does exp(x) == 1?",
                    " ",
                    "     >>> invert_complex(exp(x), 1, x)",
                    "     (x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))",
                    "     >>> invert_real(exp(x), 1, x)",
                    "-    (x, FiniteSet(0))",
                    "+    (x, {0})"
                ],
                "start_lineno": 147,
                "end_lineno": 154
            },
            {
                "hunk": [
                    "-    FiniteSet(0, log(2))",
                    "+    {0, log(2)}"
                ],
                "start_lineno": 917,
                "end_lineno": 917
            },
            {
                "hunk": [
                    "-    ConditionSet(x, (a > 0) & (b > 0), FiniteSet(0))",
                    "+    ConditionSet(x, (a > 0) & (b > 0), {0})",
                    "     >>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)",
                    "-    FiniteSet(-3*log(2)/(-2*log(3) + log(2)))",
                    "+    {-3*log(2)/(-2*log(3) + log(2))}",
                    "     >>> solve_expo(2**x - 4**x, 0, x, S.Reals)",
                    "-    FiniteSet(0)",
                    "+    {0}"
                ],
                "start_lineno": 1495,
                "end_lineno": 1499
            },
            {
                "hunk": [
                    "-    FiniteSet(sqrt(10), -sqrt(10))",
                    "+    {-sqrt(10), sqrt(10)}"
                ],
                "start_lineno": 1657,
                "end_lineno": 1657
            },
            {
                "hunk": [
                    "-    FiniteSet(-(log(3) + 3*log(5))/(-log(5) + 2*log(3)))",
                    "+    {-(log(3) + 3*log(5))/(-log(5) + 2*log(3))}"
                ],
                "start_lineno": 1903,
                "end_lineno": 1903
            },
            {
                "hunk": [
                    "-    FiniteSet(0)",
                    "+    {0}",
                    "     >>> solveset_real(exp(x) - 1, x)",
                    "-    FiniteSet(0)",
                    "+    {0}"
                ],
                "start_lineno": 2145,
                "end_lineno": 2147
            },
            {
                "hunk": [
                    "-    FiniteSet((-1, 2, 0))",
                    "+    {(-1, 2, 0)}"
                ],
                "start_lineno": 2676,
                "end_lineno": 2676
            },
            {
                "hunk": [
                    "-    FiniteSet((z - 1, 2 - 2*z, z))",
                    "+    {(z - 1, 2 - 2*z, z)}",
                    " ",
                    "     If no symbols are given, internally generated symbols will be used.",
                    "     The `tau0` in the 3rd position indicates (as before) that the 3rd",
                    "     variable -- whatever it's named -- can take on any value:",
                    " ",
                    "     >>> linsolve((A, b))",
                    "-    FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))",
                    "+    {(tau0 - 1, 2 - 2*tau0, tau0)}",
                    " ",
                    "     * List of Equations as input",
                    " ",
                    "     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]",
                    "     >>> linsolve(Eqns, x, y, z)",
                    "-    FiniteSet((1, -2, -2))",
                    "+    {(1, -2, -2)}"
                ],
                "start_lineno": 2687,
                "end_lineno": 2700
            },
            {
                "hunk": [
                    "-    FiniteSet((3/10, 2/5, 0))",
                    "+    {(3/10, 2/5, 0)}",
                    " ",
                    "     * Solve for symbolic coefficients",
                    " ",
                    "     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')",
                    "     >>> eqns = [a*x + b*y - c, d*x + e*y - f]",
                    "     >>> linsolve(eqns, x, y)",
                    "-    FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))",
                    "+    {((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}",
                    " ",
                    "     * A degenerate system returns solution as set of given",
                    "       symbols.",
                    " ",
                    "     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))",
                    "     >>> linsolve(system, x, y)",
                    "-    FiniteSet((x, y))",
                    "+    {(x, y)}"
                ],
                "start_lineno": 2711,
                "end_lineno": 2725
            },
            {
                "hunk": [
                    "-    FiniteSet((1, 1))",
                    "+    {(1, 1)}"
                ],
                "start_lineno": 2736,
                "end_lineno": 2736
            },
            {
                "hunk": [
                    "-    FiniteSet((-1, 1))",
                    "+    {(-1, 1)}",
                    " ",
                    "     * when you want soln should not satisfy eq `x + 1 = 0`",
                    " ",
                    "     >>> substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])",
                    "     EmptySet",
                    "     >>> substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])",
                    "-    FiniteSet((1, -1))",
                    "+    {(1, -1)}",
                    "     >>> substitution([x + y - 1, y - x**2 + 5], [x, y])",
                    "-    FiniteSet((-3, 4), (2, -1))",
                    "+    {(-3, 4), (2, -1)}",
                    " ",
                    "     * Returns both real and complex solution",
                    " ",
                    "     >>> x, y, z = symbols('x, y, z')",
                    "     >>> from sympy import exp, sin",
                    "     >>> substitution([exp(x) - sin(y), y**2 - 4], [x, y])",
                    "-    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),",
                    "-            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))",
                    "+    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),",
                    "+     (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}",
                    " ",
                    "     >>> eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]",
                    "     >>> substitution(eqs, [y, z])",
                    "-    FiniteSet((-log(3), sqrt(-exp(2*x) - sin(log(3)))),",
                    "-    (-log(3), -sqrt(-exp(2*x) - sin(log(3)))),",
                    "-    (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "-       ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),",
                    "-    (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "-       ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)))",
                    "+    {(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),",
                    "+     (-log(3), sqrt(-exp(2*x) - sin(log(3)))),",
                    "+     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "+      ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),",
                    "+     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "+      ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}"
                ],
                "start_lineno": 2909,
                "end_lineno": 2935
            },
            {
                "hunk": [
                    "-    FiniteSet((-1, -1), (-1/2, -2), (1/2, 2), (1, 1))",
                    "+    {(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}"
                ],
                "start_lineno": 3530,
                "end_lineno": 3530
            },
            {
                "hunk": [
                    "-    FiniteSet((2 - y, y))",
                    "+    {(2 - y, y)}"
                ],
                "start_lineno": 3549,
                "end_lineno": 3549
            },
            {
                "hunk": [
                    "-    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),",
                    "-            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))",
                    "-",
                    "+    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),",
                    "+     (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}"
                ],
                "start_lineno": 3557,
                "end_lineno": 3559
            },
            {
                "hunk": [
                    "-    FiniteSet((-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I))",
                    "+    {(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}"
                ],
                "start_lineno": 3567,
                "end_lineno": 3567
            },
            {
                "hunk": [
                    "-    FiniteSet((3*z - 5, 4 - z, z))",
                    "+    {(3*z - 5, 4 - z, z)}"
                ],
                "start_lineno": 3576,
                "end_lineno": 3576
            },
            {
                "hunk": [
                    "-    FiniteSet((191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20))",
                    "+    {(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}",
                    "     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])",
                    "-    FiniteSet((1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5)))",
                    "+    {(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}",
                    "     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])",
                    "-    FiniteSet((2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5)))",
                    "+    {(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}"
                ],
                "start_lineno": 3584,
                "end_lineno": 3588
            }
        ],
        "sympy/stats/rv_interface.py": [
            {
                "hunk": [
                    "-    FiniteSet(3)",
                    "+    {3}",
                    "     >>> D = Die('D')",
                    "     >>> median(D)",
                    "-    FiniteSet(3, 4)",
                    "+    {3, 4}"
                ],
                "start_lineno": 414,
                "end_lineno": 417
            }
        ],
        "sympy/stats/stochastic_process_types.py": [
            {
                "hunk": [
                    "-    FiniteSet(0, 1, 2)",
                    "+    {0, 1, 2}"
                ],
                "start_lineno": 819,
                "end_lineno": 819
            },
            {
                "hunk": [
                    "-    FiniteSet(0, 1)",
                    "+    {0, 1}"
                ],
                "start_lineno": 1492,
                "end_lineno": 1492
            },
            {
                "hunk": [
                    "-    FiniteSet(0, 1)",
                    "+    {0, 1}"
                ],
                "start_lineno": 1616,
                "end_lineno": 1616
            }
        ],
        "sympy/vector/implicitregion.py": [
            {
                "hunk": [
                    "-    FiniteSet((0, 0, 0))",
                    "+    {(0, 0, 0)}"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            },
            {
                "hunk": [
                    "-        FiniteSet((1, 1))",
                    "+        {(1, 1)}"
                ],
                "start_lineno": 291,
                "end_lineno": 291
            },
            {
                "hunk": [
                    "-        FiniteSet((0, 0, 0))",
                    "+        {(0, 0, 0)}"
                ],
                "start_lineno": 314,
                "end_lineno": 314
            }
        ]
    },
    "sympy__sympy-15151": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-        tex = self._print(expr.base)+'_{%s}' % ','.join(",
                    "+        tex_base = self._print(expr.base)",
                    "+        tex = '{'+tex_base+'}'+'_{%s}' % ','.join("
                ],
                "start_lineno": 610,
                "end_lineno": 610
            }
        ]
    },
    "django__django-15347": {
        "django/contrib/messages/storage/cookie.py": [
            {
                "hunk": [
                    "-            if obj.extra_tags:",
                    "+            if obj.extra_tags is not None:"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            }
        ]
    },
    "scikit-learn__scikit-learn-24145": {
        "sklearn/preprocessing/_polynomial.py": [
            {
                "hunk": [
                    "+from ..utils.fixes import sp_version, parse_version",
                    " from ..utils.validation import check_is_fitted, FLOAT_DTYPES, _check_sample_weight",
                    " from ..utils.validation import _check_feature_names_in",
                    " from ..utils._param_validation import Interval, StrOptions",
                    " from ..utils.stats import _weighted_percentile",
                    "-from ..utils.fixes import sp_version, parse_version"
                ],
                "start_lineno": 16,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-# TODO:",
                    "-# - sparse support (either scipy or own cython solution)?"
                ],
                "start_lineno": 577,
                "end_lineno": 578
            },
            {
                "hunk": [
                    "-        Order of output array. 'F' order is faster to compute, but may slow",
                    "-        down subsequent estimators.",
                    "+        Order of output array in the dense case. `'F'` order is faster to compute, but",
                    "+        may slow down subsequent estimators.",
                    "+",
                    "+    sparse_output : bool, default=False",
                    "+        Will return sparse CSR matrix if set True else will return an array. This",
                    "+        option is only available with `scipy>=1.8`.",
                    "+",
                    "+        .. versionadded:: 1.2"
                ],
                "start_lineno": 638,
                "end_lineno": 639
            },
            {
                "hunk": [
                    "+        \"sparse_output\": [\"boolean\"],"
                ],
                "start_lineno": 702,
                "end_lineno": 702
            },
            {
                "hunk": [
                    "+        sparse_output=False,"
                ],
                "start_lineno": 713,
                "end_lineno": 713
            },
            {
                "hunk": [
                    "+        self.sparse_output = sparse_output"
                ],
                "start_lineno": 720,
                "end_lineno": 720
            },
            {
                "hunk": [
                    "+        if self.sparse_output and sp_version < parse_version(\"1.8.0\"):",
                    "+            raise ValueError(",
                    "+                \"Option sparse_output=True is only available with scipy>=1.8.0, \"",
                    "+                f\"but here scipy=={sp_version} is used.\"",
                    "+            )",
                    "+"
                ],
                "start_lineno": 846,
                "end_lineno": 846
            },
            {
                "hunk": [
                    "-        XBS : ndarray of shape (n_samples, n_features * n_splines)",
                    "+        XBS : {ndarray, sparse matrix} of shape (n_samples, n_features * n_splines)"
                ],
                "start_lineno": 937,
                "end_lineno": 937
            },
            {
                "hunk": [
                    "+        # TODO: Remove this condition, once scipy 1.10 is the minimum version.",
                    "+        #       Only scipy => 1.10 supports design_matrix(.., extrapolate=..).",
                    "+        #       The default (implicit in scipy < 1.10) is extrapolate=False.",
                    "+        scipy_1_10 = sp_version >= parse_version(\"1.10.0\")",
                    "+        # Note: self.bsplines_[0].extrapolate is True for extrapolation in",
                    "+        # [\"periodic\", \"continue\"]",
                    "+        if scipy_1_10:",
                    "+            use_sparse = self.sparse_output",
                    "+            kwargs_extrapolate = {\"extrapolate\": self.bsplines_[0].extrapolate}",
                    "+        else:",
                    "+            use_sparse = self.sparse_output and not self.bsplines_[0].extrapolate",
                    "+            kwargs_extrapolate = dict()",
                    "+"
                ],
                "start_lineno": 949,
                "end_lineno": 949
            },
            {
                "hunk": [
                    "-        XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)",
                    "+        if use_sparse:",
                    "+            output_list = []",
                    "+        else:",
                    "+            XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)"
                ],
                "start_lineno": 956,
                "end_lineno": 956
            },
            {
                "hunk": [
                    "-                XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)",
                    "-",
                    "-            else:",
                    "-                xmin = spl.t[degree]",
                    "-                xmax = spl.t[-degree - 1]",
                    "+                if use_sparse:",
                    "+                    XBS_sparse = BSpline.design_matrix(",
                    "+                        x, spl.t, spl.k, **kwargs_extrapolate",
                    "+                    )",
                    "+                    if self.extrapolation == \"periodic\":",
                    "+                        # See the construction of coef in fit. We need to add the last",
                    "+                        # degree spline basis function to the first degree ones and",
                    "+                        # then drop the last ones.",
                    "+                        # Note: See comment about SparseEfficiencyWarning below.",
                    "+                        XBS_sparse = XBS_sparse.tolil()",
                    "+                        XBS_sparse[:, :degree] += XBS_sparse[:, -degree:]",
                    "+                        XBS_sparse = XBS_sparse[:, :-degree]",
                    "+                else:",
                    "+                    XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)",
                    "+            else:  # extrapolation in (\"constant\", \"linear\")",
                    "+                xmin, xmax = spl.t[degree], spl.t[-degree - 1]",
                    "+                # spline values at boundaries",
                    "+                f_min, f_max = spl(xmin), spl(xmax)",
                    "                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)",
                    "-                XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])",
                    "+                if use_sparse:",
                    "+                    mask_inv = ~mask",
                    "+                    x = X[:, i].copy()",
                    "+                    # Set some arbitrary values outside boundary that will be reassigned",
                    "+                    # later.",
                    "+                    x[mask_inv] = spl.t[self.degree]",
                    "+                    XBS_sparse = BSpline.design_matrix(x, spl.t, spl.k)",
                    "+                    # Note: Without converting to lil_matrix we would get:",
                    "+                    # scipy.sparse._base.SparseEfficiencyWarning: Changing the sparsity",
                    "+                    # structure of a csr_matrix is expensive. lil_matrix is more",
                    "+                    # efficient.",
                    "+                    if np.any(mask_inv):",
                    "+                        XBS_sparse = XBS_sparse.tolil()",
                    "+                        XBS_sparse[mask_inv, :] = 0",
                    "+                else:",
                    "+                    XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])",
                    " ",
                    "             # Note for extrapolation:",
                    "             # 'continue' is already returned as is by scipy BSplines",
                    "             if self.extrapolation == \"error\":",
                    "                 # BSpline with extrapolate=False does not raise an error, but",
                    "-                # output np.nan.",
                    "-                if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):",
                    "+                # outputs np.nan.",
                    "+                if (use_sparse and np.any(np.isnan(XBS_sparse.data))) or (",
                    "+                    not use_sparse",
                    "+                    and np.any(",
                    "+                        np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])",
                    "+                    )",
                    "+                ):"
                ],
                "start_lineno": 975,
                "end_lineno": 988
            },
            {
                "hunk": [
                    "-                # spline values at boundaries",
                    "-                f_min = spl(xmin)",
                    "-                f_max = spl(xmax)",
                    "                 mask = X[:, i] < xmin",
                    "                 if np.any(mask):",
                    "-                    XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[",
                    "-                        :degree",
                    "-                    ]",
                    "+                    if use_sparse:",
                    "+                        # Note: See comment about SparseEfficiencyWarning above.",
                    "+                        XBS_sparse = XBS_sparse.tolil()",
                    "+                        XBS_sparse[mask, :degree] = f_min[:degree]",
                    "+",
                    "+                    else:",
                    "+                        XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[",
                    "+                            :degree",
                    "+                        ]",
                    " ",
                    "                 mask = X[:, i] > xmax",
                    "                 if np.any(mask):",
                    "-                    XBS[",
                    "-                        mask,",
                    "-                        ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),",
                    "-                    ] = f_max[-degree:]",
                    "+                    if use_sparse:",
                    "+                        # Note: See comment about SparseEfficiencyWarning above.",
                    "+                        XBS_sparse = XBS_sparse.tolil()",
                    "+                        XBS_sparse[mask, -degree:] = f_max[-degree:]",
                    "+                    else:",
                    "+                        XBS[",
                    "+                            mask,",
                    "+                            ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),",
                    "+                        ] = f_max[-degree:]"
                ],
                "start_lineno": 998,
                "end_lineno": 1012
            },
            {
                "hunk": [
                    "-                # spline values at boundaries",
                    "-                f_min, f_max = spl(xmin), spl(xmax)"
                ],
                "start_lineno": 1021,
                "end_lineno": 1022
            },
            {
                "hunk": [
                    "-                        XBS[mask, i * n_splines + j] = (",
                    "-                            f_min[j] + (X[mask, i] - xmin) * fp_min[j]",
                    "-                        )",
                    "+                        linear_extr = f_min[j] + (X[mask, i] - xmin) * fp_min[j]",
                    "+                        if use_sparse:",
                    "+                            # Note: See comment about SparseEfficiencyWarning above.",
                    "+                            XBS_sparse = XBS_sparse.tolil()",
                    "+                            XBS_sparse[mask, j] = linear_extr",
                    "+                        else:",
                    "+                            XBS[mask, i * n_splines + j] = linear_extr",
                    " ",
                    "                     mask = X[:, i] > xmax",
                    "                     if np.any(mask):",
                    "                         k = n_splines - 1 - j",
                    "-                        XBS[mask, i * n_splines + k] = (",
                    "-                            f_max[k] + (X[mask, i] - xmax) * fp_max[k]",
                    "-                        )",
                    "+                        linear_extr = f_max[k] + (X[mask, i] - xmax) * fp_max[k]",
                    "+                        if use_sparse:",
                    "+                            # Note: See comment about SparseEfficiencyWarning above.",
                    "+                            XBS_sparse = XBS_sparse.tolil()",
                    "+                            XBS_sparse[mask, k : k + 1] = linear_extr[:, None]",
                    "+                        else:",
                    "+                            XBS[mask, i * n_splines + k] = linear_extr",
                    "+",
                    "+            if use_sparse:",
                    "+                if not sparse.isspmatrix_csr(XBS_sparse):",
                    "+                    XBS_sparse = XBS_sparse.tocsr()",
                    "+                output_list.append(XBS_sparse)",
                    "+",
                    "+        if use_sparse:",
                    "+            # TODO: Remove this conditional error when the minimum supported version of",
                    "+            # SciPy is 1.9.2",
                    "+            # `scipy.sparse.hstack` breaks in scipy<1.9.2",
                    "+            # when `n_features_out_ > max_int32`",
                    "+            max_int32 = np.iinfo(np.int32).max",
                    "+            all_int32 = True",
                    "+            for mat in output_list:",
                    "+                all_int32 &= mat.indices.dtype == np.int32",
                    "+            if (",
                    "+                sp_version < parse_version(\"1.9.2\")",
                    "+                and self.n_features_out_ > max_int32",
                    "+                and all_int32",
                    "+            ):",
                    "+                raise ValueError(",
                    "+                    \"In scipy versions `<1.9.2`, the function `scipy.sparse.hstack`\"",
                    "+                    \" produces negative columns when:\\n1. The output shape contains\"",
                    "+                    \" `n_cols` too large to be represented by a 32bit signed\"",
                    "+                    \" integer.\\n. All sub-matrices to be stacked have indices of\"",
                    "+                    \" dtype `np.int32`.\\nTo avoid this error, either use a version\"",
                    "+                    \" of scipy `>=1.9.2` or alter the `SplineTransformer`\"",
                    "+                    \" transformer to produce fewer than 2^31 output features\"",
                    "+                )",
                    "+            XBS = sparse.hstack(output_list)",
                    "+        elif self.sparse_output:",
                    "+            # TODO: Remove ones scipy 1.10 is the minimum version. See comments above.",
                    "+            XBS = sparse.csr_matrix(XBS)"
                ],
                "start_lineno": 1033,
                "end_lineno": 1042
            }
        ]
    },
    "sphinx-doc__sphinx-9461": {
        "sphinx/domains/python.py": [
            {
                "hunk": [
                    "+        'classmethod': directives.flag,"
                ],
                "start_lineno": 855,
                "end_lineno": 855
            },
            {
                "hunk": [
                    "-        prefix = ['property']",
                    "+        prefix = []",
                    "         if 'abstractmethod' in self.options:",
                    "-            prefix.insert(0, 'abstract')",
                    "+            prefix.append('abstract')",
                    "+        if 'classmethod' in self.options:",
                    "+            prefix.append('class')",
                    " ",
                    "+        prefix.append('property')"
                ],
                "start_lineno": 868,
                "end_lineno": 871
            }
        ],
        "sphinx/ext/autodoc/__init__.py": [
            {
                "hunk": [
                    "-                         self.parent, self.object_name)",
                    "+                         self.object, membername)"
                ],
                "start_lineno": 721,
                "end_lineno": 721
            },
            {
                "hunk": [
                    "-        return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)",
                    "+        if isinstance(parent, ClassDocumenter):",
                    "+            if inspect.isproperty(member):",
                    "+                return True",
                    "+            else:",
                    "+                __dict__ = safe_getattr(parent.object, '__dict__', {})",
                    "+                obj = __dict__.get(membername)",
                    "+                return isinstance(obj, classmethod) and inspect.isproperty(obj.__func__)",
                    "+        else:",
                    "+            return False",
                    "+",
                    "+    def import_object(self, raiseerror: bool = False) -> bool:",
                    "+        \"\"\"Check the exisitence of uninitialized instance attribute when failed to import",
                    "+        the attribute.\"\"\"",
                    "+        ret = super().import_object(raiseerror)",
                    "+        if ret and not inspect.isproperty(self.object):",
                    "+            __dict__ = safe_getattr(self.parent, '__dict__', {})",
                    "+            obj = __dict__.get(self.objpath[-1])",
                    "+            if isinstance(obj, classmethod) and inspect.isproperty(obj.__func__):",
                    "+                self.object = obj.__func__",
                    "+                self.isclassmethod = True",
                    "+                return True",
                    "+            else:",
                    "+                return False",
                    "+",
                    "+        self.isclassmethod = False",
                    "+        return ret"
                ],
                "start_lineno": 2664,
                "end_lineno": 2664
            },
            {
                "hunk": [
                    "+        if self.isclassmethod:",
                    "+            self.add_line('   :classmethod:', sourcename)"
                ],
                "start_lineno": 2678,
                "end_lineno": 2678
            }
        ],
        "sphinx/util/inspect.py": [
            {
                "hunk": [
                    "-def isclassmethod(obj: Any) -> bool:",
                    "+def isclassmethod(obj: Any, cls: Any = None, name: str = None) -> bool:",
                    "     \"\"\"Check if the object is classmethod.\"\"\"",
                    "     if isinstance(obj, classmethod):",
                    "         return True",
                    "     elif inspect.ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):",
                    "         return True",
                    "+    elif cls and name:",
                    "+        for basecls in getmro(cls):",
                    "+            meth = basecls.__dict__.get(name)",
                    "+            if meth:",
                    "+                return isclassmethod(meth)"
                ],
                "start_lineno": 248,
                "end_lineno": 253
            },
            {
                "hunk": [
                    "+    if cls and name and isclassmethod(obj, cls, name):",
                    "+        for basecls in getmro(cls):",
                    "+            meth = basecls.__dict__.get(name)",
                    "+            if meth:",
                    "+                return getdoc(meth.__func__)",
                    "+"
                ],
                "start_lineno": 840,
                "end_lineno": 840
            }
        ]
    },
    "sphinx-doc__sphinx-8620": {
        "sphinx/builders/html/transforms.py": [
            {
                "hunk": [
                    "-        <literal class=\"kbd\">",
                    "+        <literal class=\"kbd compound\">"
                ],
                "start_lineno": 31,
                "end_lineno": 31
            },
            {
                "hunk": [
                    "+            node['classes'].append('compound')"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            }
        ]
    },
    "sympy__sympy-23729": {
        "sympy/printing/julia.py": [
            {
                "hunk": [
                    "-            elif item.is_Rational and item is not S.Infinity:",
                    "-                if item.p != 1:",
                    "-                    a.append(Rational(item.p))",
                    "-                if item.q != 1:",
                    "-                    b.append(Rational(item.q))",
                    "+            elif item.is_Rational and item is not S.Infinity and item.p == 1:",
                    "+                # Save the Rational type in julia Unless the numerator is 1.",
                    "+                # For example:",
                    "+                # julia_code(Rational(3, 7)*x) --> (3 // 7) * x",
                    "+                # julia_code(x/3) --> x / 3 but not x * (1 // 3)",
                    "+                b.append(Rational(item.q))"
                ],
                "start_lineno": 156,
                "end_lineno": 160
            },
            {
                "hunk": [
                    "-                r = r + mulsym + a_str[i]",
                    "+                r = \"%s %s %s\" % (r, mulsym, a_str[i])",
                    "             return r",
                    " ",
                    "         if not b:",
                    "             return sign + multjoin(a, a_str)",
                    "         elif len(b) == 1:",
                    "             divsym = '/' if b[0].is_number else './'",
                    "-            return sign + multjoin(a, a_str) + divsym + b_str[0]",
                    "+            return \"%s %s %s\" % (sign+multjoin(a, a_str), divsym, b_str[0])",
                    "         else:",
                    "             divsym = '/' if all(bi.is_number for bi in b) else './'",
                    "-            return (sign + multjoin(a, a_str) +",
                    "-                    divsym + \"(%s)\" % multjoin(b, b_str))",
                    "+            return \"%s %s (%s)\" % (sign + multjoin(a, a_str), divsym, multjoin(b, b_str))"
                ],
                "start_lineno": 180,
                "end_lineno": 191
            },
            {
                "hunk": [
                    "-                return \"1\" + sym + \"sqrt(%s)\" % self._print(expr.base)",
                    "+                return \"1 %s sqrt(%s)\" % (sym, self._print(expr.base))",
                    "             if expr.exp == -S.One:",
                    "                 sym = '/' if expr.base.is_number else './'",
                    "-                return \"1\" + sym + \"%s\" % self.parenthesize(expr.base, PREC)",
                    "+                return  \"1 %s %s\" % (sym, self.parenthesize(expr.base, PREC))",
                    " ",
                    "-        return '%s%s%s' % (self.parenthesize(expr.base, PREC), powsymbol,",
                    "+        return '%s %s %s' % (self.parenthesize(expr.base, PREC), powsymbol,",
                    "                            self.parenthesize(expr.exp, PREC))",
                    " ",
                    " ",
                    "     def _print_MatPow(self, expr):",
                    "         PREC = precedence(expr)",
                    "-        return '%s^%s' % (self.parenthesize(expr.base, PREC),",
                    "+        return '%s ^ %s' % (self.parenthesize(expr.base, PREC),"
                ],
                "start_lineno": 210,
                "end_lineno": 221
            },
            {
                "hunk": [
                    "-        return '.*'.join([self.parenthesize(arg, precedence(expr))",
                    "+        return ' .* '.join([self.parenthesize(arg, precedence(expr))"
                ],
                "start_lineno": 398,
                "end_lineno": 398
            },
            {
                "hunk": [
                    "-    # Note: as of 2015, Julia doesn't have spherical Bessel functions",
                    "+    def _print_Rational(self, expr):",
                    "+        if expr.q == 1:",
                    "+            return str(expr.p)",
                    "+        return \"%s // %s\" % (expr.p, expr.q)",
                    "+",
                    "+    # Note: as of 2022, Julia doesn't have spherical Bessel functions"
                ],
                "start_lineno": 408,
                "end_lineno": 408
            },
            {
                "hunk": [
                    "+    def _print_MatMul(self, expr):",
                    "+        c, m = expr.as_coeff_mmul()",
                    "+",
                    "+        sign = \"\"",
                    "+        if c.is_number:",
                    "+            re, im = c.as_real_imag()",
                    "+            if im.is_zero and re.is_negative:",
                    "+                expr = _keep_coeff(-c, m)",
                    "+                sign = \"-\"",
                    "+            elif re.is_zero and im.is_negative:",
                    "+                expr = _keep_coeff(-c, m)",
                    "+                sign = \"-\"",
                    "+",
                    "+        return sign + ' * '.join(",
                    "+            (self.parenthesize(arg, precedence(expr)) for arg in expr.args)",
                    "+        )",
                    "+"
                ],
                "start_lineno": 459,
                "end_lineno": 459
            },
            {
                "hunk": [
                    "-    'x.^5/120 - x.^3/6 + x'",
                    "+    'x .^ 5 / 120 - x .^ 3 / 6 + x'",
                    " ",
                    "     >>> from sympy import Rational, ceiling",
                    "     >>> x, y, tau = symbols(\"x, y, tau\")",
                    "     >>> julia_code((2*tau)**Rational(7, 2))",
                    "-    '8*sqrt(2)*tau.^(7/2)'",
                    "+    '8 * sqrt(2) * tau .^ (7 // 2)'",
                    " ",
                    "     Note that element-wise (Hadamard) operations are used by default between",
                    "     symbols.  This is because its possible in Julia to write \"vectorized\"",
                    "     code.  It is harmless if the values are scalars.",
                    " ",
                    "     >>> julia_code(sin(pi*x*y), assign_to=\"s\")",
                    "-    's = sin(pi*x.*y)'",
                    "+    's = sin(pi * x .* y)'"
                ],
                "start_lineno": 533,
                "end_lineno": 545
            },
            {
                "hunk": [
                    "-    '(3*pi)*A^3'",
                    "+    '(3 * pi) * A ^ 3'"
                ],
                "start_lineno": 554,
                "end_lineno": 554
            },
            {
                "hunk": [
                    "-    '(x.^2.*y)*A^3'",
                    "+    '(x .^ 2 .* y) * A ^ 3'"
                ],
                "start_lineno": 565,
                "end_lineno": 565
            },
            {
                "hunk": [
                    "-    'A = [x.^2 sin(x) ceil(x)]'",
                    "+    'A = [x .^ 2 sin(x) ceil(x)]'"
                ],
                "start_lineno": 574,
                "end_lineno": 574
            },
            {
                "hunk": [
                    "-    'A = [x.^2 ((x > 0) ? (x + 1) : (x)) sin(x)]'",
                    "+    'A = [x .^ 2 ((x > 0) ? (x + 1) : (x)) sin(x)]'"
                ],
                "start_lineno": 592,
                "end_lineno": 592
            },
            {
                "hunk": [
                    "-    'Dy[i] = (y[i + 1] - y[i])./(t[i + 1] - t[i])'",
                    "+    'Dy[i] = (y[i + 1] - y[i]) ./ (t[i + 1] - t[i])'"
                ],
                "start_lineno": 624,
                "end_lineno": 624
            }
        ]
    },
    "sympy__sympy-16943": {
        "sympy/series/formal.py": [
            {
                "hunk": [
                    "-        return None",
                    "+        k = Dummy('k')",
                    "+        ak = sequence(Coeff(f, x, k), (k, 1, oo))",
                    "+        xk = sequence(x**k, (k, 0, oo))",
                    "+        ind = f.coeff(x, 0)",
                    "+        return ak, xk, ind"
                ],
                "start_lineno": 782,
                "end_lineno": 782
            },
            {
                "hunk": [
                    "+class Coeff(Function):",
                    "+    \"\"\"",
                    "+    Coeff(p, x, n) represents the nth coefficient of the polynomial p in x",
                    "+    \"\"\"",
                    "+    @classmethod",
                    "+    def eval(cls, p, x, n):",
                    "+        if p.is_polynomial(x) and n.is_integer:",
                    "+            return p.coeff(x, n)",
                    "+",
                    "+"
                ],
                "start_lineno": 904,
                "end_lineno": 904
            }
        ]
    },
    "django__django-15277": {
        "django/db/models/fields/__init__.py": [
            {
                "hunk": [
                    "-        self.validators.append(validators.MaxLengthValidator(self.max_length))",
                    "+        if self.max_length is not None:",
                    "+            self.validators.append(validators.MaxLengthValidator(self.max_length))"
                ],
                "start_lineno": 1013,
                "end_lineno": 1013
            }
        ]
    },
    "django__django-14026": {
        "django/contrib/postgres/aggregates/general.py": [
            {
                "hunk": [
                    "+import warnings",
                    "+",
                    " from django.contrib.postgres.fields import ArrayField",
                    " from django.db.models import Aggregate, BooleanField, JSONField, Value",
                    "+from django.utils.deprecation import RemovedInDjango50Warning"
                ],
                "start_lineno": 1,
                "end_lineno": 2
            },
            {
                "hunk": [
                    "-class ArrayAgg(OrderableAggMixin, Aggregate):",
                    "+# RemovedInDjango50Warning",
                    "+NOT_PROVIDED = object()",
                    "+",
                    "+",
                    "+class DeprecatedConvertValueMixin:",
                    "+    def __init__(self, *expressions, default=NOT_PROVIDED, **extra):",
                    "+        if default is NOT_PROVIDED:",
                    "+            default = None",
                    "+            self._default_provided = False",
                    "+        else:",
                    "+            self._default_provided = True",
                    "+        super().__init__(*expressions, default=default, **extra)",
                    "+",
                    "+    def convert_value(self, value, expression, connection):",
                    "+        if value is None and not self._default_provided:",
                    "+            warnings.warn(self.deprecation_msg, category=RemovedInDjango50Warning)",
                    "+            return self.deprecation_value",
                    "+        return value",
                    "+",
                    "+",
                    "+class ArrayAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):",
                    "     function = 'ARRAY_AGG'",
                    "     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
                    "     allow_distinct = True",
                    " ",
                    "+    # RemovedInDjango50Warning",
                    "+    deprecation_value = property(lambda self: [])",
                    "+    deprecation_msg = (",
                    "+        'In Django 5.0, ArrayAgg() will return None instead of an empty list '",
                    "+        'if there are no rows. Pass default=None to opt into the new behavior '",
                    "+        'and silence this warning or default=Value([]) to keep the previous '",
                    "+        'behavior.'",
                    "+    )",
                    "+",
                    "     @property",
                    "     def output_field(self):",
                    "         return ArrayField(self.source_expressions[0].output_field)",
                    " ",
                    "-    def convert_value(self, value, expression, connection):",
                    "-        if not value:",
                    "-            return []",
                    "-        return value",
                    "-"
                ],
                "start_lineno": 11,
                "end_lineno": 24
            },
            {
                "hunk": [
                    "-class JSONBAgg(OrderableAggMixin, Aggregate):",
                    "+class JSONBAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):",
                    "     function = 'JSONB_AGG'",
                    "     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
                    "     allow_distinct = True",
                    "     output_field = JSONField()",
                    " ",
                    "-    def convert_value(self, value, expression, connection):",
                    "-        if not value:",
                    "-            return '[]'",
                    "-        return value",
                    "+    # RemovedInDjango50Warning",
                    "+    deprecation_value = '[]'",
                    "+    deprecation_msg = (",
                    "+        \"In Django 5.0, JSONBAgg() will return None instead of an empty list \"",
                    "+        \"if there are no rows. Pass default=None to opt into the new behavior \"",
                    "+        \"and silence this warning or default=Value('[]') to keep the previous \"",
                    "+        \"behavior.\"",
                    "+    )",
                    " ",
                    " ",
                    "-class StringAgg(OrderableAggMixin, Aggregate):",
                    "+class StringAgg(DeprecatedConvertValueMixin, OrderableAggMixin, Aggregate):",
                    "     function = 'STRING_AGG'",
                    "     template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
                    "     allow_distinct = True",
                    " ",
                    "+    # RemovedInDjango50Warning",
                    "+    deprecation_value = ''",
                    "+    deprecation_msg = (",
                    "+        \"In Django 5.0, StringAgg() will return None instead of an empty \"",
                    "+        \"string if there are no rows. Pass default=None to opt into the new \"",
                    "+        \"behavior and silence this warning or default=Value('') to keep the \"",
                    "+        \"previous behavior.\"",
                    "+    )",
                    "+",
                    "     def __init__(self, expression, delimiter, **extra):",
                    "         delimiter_expr = Value(str(delimiter))",
                    "         super().__init__(expression, delimiter_expr, **extra)",
                    "-",
                    "-    def convert_value(self, value, expression, connection):",
                    "-        if not value:",
                    "-            return ''",
                    "-        return value"
                ],
                "start_lineno": 44,
                "end_lineno": 68
            }
        ],
        "django/contrib/postgres/aggregates/statistics.py": [
            {
                "hunk": [
                    "-    def __init__(self, y, x, output_field=None, filter=None):",
                    "+    def __init__(self, y, x, output_field=None, filter=None, default=None):",
                    "         if not x or not y:",
                    "             raise ValueError('Both y and x must be provided.')",
                    "-        super().__init__(y, x, output_field=output_field, filter=filter)",
                    "+        super().__init__(y, x, output_field=output_field, filter=filter, default=default)"
                ],
                "start_lineno": 12,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-    def __init__(self, y, x, sample=False, filter=None):",
                    "+    def __init__(self, y, x, sample=False, filter=None, default=None):",
                    "         self.function = 'COVAR_SAMP' if sample else 'COVAR_POP'",
                    "-        super().__init__(y, x, filter=filter)",
                    "+        super().__init__(y, x, filter=filter, default=default)"
                ],
                "start_lineno": 23,
                "end_lineno": 25
            }
        ],
        "django/db/backends/mysql/features.py": [
            {
                "hunk": [
                    "+        if not self.connection.mysql_is_mariadb and self.connection.mysql_version < (8,):",
                    "+            skips.update({",
                    "+                'Casting to datetime/time is not supported by MySQL < 8.0. (#30224)': {",
                    "+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_python',",
                    "+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_python',",
                    "+                },",
                    "+                'MySQL < 8.0 returns string type instead of datetime/time. (#30224)': {",
                    "+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_time_from_database',",
                    "+                    'aggregation.tests.AggregateTestCase.test_aggregation_default_using_datetime_from_database',",
                    "+                },",
                    "+            })"
                ],
                "start_lineno": 91,
                "end_lineno": 91
            }
        ],
        "django/db/models/aggregates.py": [
            {
                "hunk": [
                    "+from django.db.models.functions.comparison import Coalesce"
                ],
                "start_lineno": 7,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "-    def __init__(self, *expressions, distinct=False, filter=None, **extra):",
                    "+    def __init__(self, *expressions, distinct=False, filter=None, default=None, **extra):",
                    "         if distinct and not self.allow_distinct:",
                    "             raise TypeError(\"%s does not allow distinct.\" % self.__class__.__name__)",
                    "+        if default is not None and self.empty_aggregate_value is not None:",
                    "+            raise TypeError(f'{self.__class__.__name__} does not allow default.')",
                    "         self.distinct = distinct",
                    "         self.filter = filter",
                    "+        self.default = default"
                ],
                "start_lineno": 25,
                "end_lineno": 29
            },
            {
                "hunk": [
                    "-        return c",
                    "+        if (default := c.default) is None:",
                    "+            return c",
                    "+        if hasattr(default, 'resolve_expression'):",
                    "+            default = default.resolve_expression(query, allow_joins, reuse, summarize)",
                    "+        c.default = None  # Reset the default argument before wrapping.",
                    "+        return Coalesce(c, default, output_field=c._output_field_or_none)"
                ],
                "start_lineno": 59,
                "end_lineno": 59
            }
        ]
    },
    "django__django-15671": {
        "django/forms/formsets.py": [
            {
                "hunk": [
                    "-from django.utils.translation import ngettext",
                    "+from django.utils.translation import ngettext_lazy"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+        \"too_many_forms\": ngettext_lazy(",
                    "+            \"Please submit at most %(num)d form.\",",
                    "+            \"Please submit at most %(num)d forms.\",",
                    "+            \"num\",",
                    "+        ),",
                    "+        \"too_few_forms\": ngettext_lazy(",
                    "+            \"Please submit at least %(num)d form.\",",
                    "+            \"Please submit at least %(num)d forms.\",",
                    "+            \"num\",",
                    "+        ),"
                ],
                "start_lineno": 64,
                "end_lineno": 64
            },
            {
                "hunk": [
                    "-                    ngettext(",
                    "-                        \"Please submit at most %d form.\",",
                    "-                        \"Please submit at most %d forms.\",",
                    "-                        self.max_num,",
                    "-                    )",
                    "-                    % self.max_num,",
                    "+                    self.error_messages[\"too_many_forms\"] % {\"num\": self.max_num},"
                ],
                "start_lineno": 428,
                "end_lineno": 433
            },
            {
                "hunk": [
                    "-                    ngettext(",
                    "-                        \"Please submit at least %d form.\",",
                    "-                        \"Please submit at least %d forms.\",",
                    "-                        self.min_num,",
                    "-                    )",
                    "-                    % self.min_num,",
                    "+                    self.error_messages[\"too_few_forms\"] % {\"num\": self.min_num},"
                ],
                "start_lineno": 444,
                "end_lineno": 449
            }
        ]
    },
    "matplotlib__matplotlib-20584": {
        "lib/matplotlib/collections.py": [
            {
                "hunk": [
                    "-            vertices = [vertex for vertex, _ in path.iter_segments()]",
                    "+            vertices = [",
                    "+                vertex",
                    "+                for vertex, _",
                    "+                # Never simplify here, we want to get the data-space values",
                    "+                # back and there in no way to know the \"right\" simplification",
                    "+                # threshold so never try.",
                    "+                in path.iter_segments(simplify=False)",
                    "+            ]"
                ],
                "start_lineno": 1464,
                "end_lineno": 1464
            }
        ]
    },
    "django__django-14558": {
        "django/forms/fields.py": [
            {
                "hunk": [
                    "+        if data is None:",
                    "+            return None"
                ],
                "start_lineno": 1254,
                "end_lineno": 1254
            }
        ]
    },
    "astropy__astropy-13033": {
        "astropy/timeseries/core.py": [
            {
                "hunk": [
                    "+        def as_scalar_or_list_str(obj):",
                    "+            if not hasattr(obj, \"__len__\"):",
                    "+                return f\"'{obj}'\"",
                    "+            elif len(obj) == 1:",
                    "+                return f\"'{obj[0]}'\"",
                    "+            else:",
                    "+                return str(obj)"
                ],
                "start_lineno": 58,
                "end_lineno": 58
            },
            {
                "hunk": [
                    "-                raise ValueError(\"{} object is invalid - expected '{}' \"",
                    "-                                 \"as the first column{} but found '{}'\"",
                    "-                                 .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))",
                    "+                raise ValueError(\"{} object is invalid - expected {} \"",
                    "+                                 \"as the first column{} but found {}\"",
                    "+                                 .format(self.__class__.__name__, as_scalar_or_list_str(required_columns),",
                    "+                                            plural, as_scalar_or_list_str(self.colnames[:len(required_columns)])))"
                ],
                "start_lineno": 79,
                "end_lineno": 81
            }
        ]
    },
    "django__django-14584": {
        "django/db/backends/utils.py": [
            {
                "hunk": [
                    "-                '(%.3f) %s; args=%s',",
                    "+                '(%.3f) %s; args=%s; alias=%s',",
                    "                 duration,",
                    "                 sql,",
                    "                 params,",
                    "-                extra={'duration': duration, 'sql': sql, 'params': params},",
                    "+                self.db.alias,",
                    "+                extra={'duration': duration, 'sql': sql, 'params': params, 'alias': self.db.alias},"
                ],
                "start_lineno": 124,
                "end_lineno": 128
            }
        ]
    },
    "django__django-11991": {
        "django/contrib/gis/db/backends/postgis/schema.py": [
            {
                "hunk": [
                    "+            include='',"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            }
        ],
        "django/contrib/postgres/indexes.py": [
            {
                "hunk": [
                    "+    def check_supported(self, schema_editor):",
                    "+        if self.include and not schema_editor.connection.features.supports_covering_gist_indexes:",
                    "+            raise NotSupportedError('Covering GiST indexes requires PostgreSQL 12+.')",
                    "+"
                ],
                "start_lineno": 183,
                "end_lineno": 183
            }
        ],
        "django/db/backends/base/features.py": [
            {
                "hunk": [
                    "+    # Does the backend support covering indexes (CREATE INDEX ... INCLUDE ...)?",
                    "+    supports_covering_indexes = False"
                ],
                "start_lineno": 280,
                "end_lineno": 280
            }
        ],
        "django/db/backends/base/schema.py": [
            {
                "hunk": [
                    "-    sql_create_index = \"CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s%(condition)s\"",
                    "-    sql_create_unique_index = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s\"",
                    "+    sql_create_index = \"CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(extra)s%(condition)s\"",
                    "+    sql_create_unique_index = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(include)s%(condition)s\""
                ],
                "start_lineno": 87,
                "end_lineno": 88
            },
            {
                "hunk": [
                    "+    def _index_include_sql(self, model, columns):",
                    "+        if not columns or not self.connection.features.supports_covering_indexes:",
                    "+            return ''",
                    "+        return Statement(",
                    "+            ' INCLUDE (%(columns)s)',",
                    "+            columns=Columns(model._meta.db_table, columns, self.quote_name),",
                    "+        )",
                    "+",
                    "     def _create_index_sql(self, model, fields, *, name=None, suffix='', using='',",
                    "                           db_tablespace=None, col_suffixes=(), sql=None, opclasses=(),",
                    "-                          condition=None):",
                    "+                          condition=None, include=None):"
                ],
                "start_lineno": 959,
                "end_lineno": 961
            },
            {
                "hunk": [
                    "+            include=self._index_include_sql(model, include),"
                ],
                "start_lineno": 986,
                "end_lineno": 986
            },
            {
                "hunk": [
                    "-    def _unique_sql(self, model, fields, name, condition=None, deferrable=None):",
                    "+    def _unique_sql(self, model, fields, name, condition=None, deferrable=None, include=None):",
                    "         if (",
                    "             deferrable and",
                    "             not self.connection.features.supports_deferrable_unique_constraints",
                    "         ):",
                    "             return None",
                    "-        if condition:",
                    "-            # Databases support conditional unique constraints via a unique",
                    "-            # index.",
                    "-            sql = self._create_unique_sql(model, fields, name=name, condition=condition)",
                    "+        if condition or include:",
                    "+            # Databases support conditional and covering unique constraints via",
                    "+            # a unique index.",
                    "+            sql = self._create_unique_sql(",
                    "+                model,",
                    "+                fields,",
                    "+                name=name,",
                    "+                condition=condition,",
                    "+                include=include,",
                    "+            )"
                ],
                "start_lineno": 1086,
                "end_lineno": 1095
            },
            {
                "hunk": [
                    "-    def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None):",
                    "+    def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None, include=None):",
                    "         if (",
                    "-            deferrable and",
                    "-            not self.connection.features.supports_deferrable_unique_constraints",
                    "+            (",
                    "+                deferrable and",
                    "+                not self.connection.features.supports_deferrable_unique_constraints",
                    "+            ) or",
                    "+            (condition and not self.connection.features.supports_partial_indexes) or",
                    "+            (include and not self.connection.features.supports_covering_indexes)"
                ],
                "start_lineno": 1108,
                "end_lineno": 1111
            },
            {
                "hunk": [
                    "-        if condition:",
                    "-            if not self.connection.features.supports_partial_indexes:",
                    "-                return None",
                    "+        if condition or include:"
                ],
                "start_lineno": 1124,
                "end_lineno": 1126
            },
            {
                "hunk": [
                    "+            include=self._index_include_sql(model, include),",
                    "         )",
                    " ",
                    "-    def _delete_unique_sql(self, model, name, condition=None, deferrable=None):",
                    "+    def _delete_unique_sql(self, model, name, condition=None, deferrable=None, include=None):",
                    "         if (",
                    "-            deferrable and",
                    "-            not self.connection.features.supports_deferrable_unique_constraints",
                    "+            (",
                    "+                deferrable and",
                    "+                not self.connection.features.supports_deferrable_unique_constraints",
                    "+            ) or",
                    "+            (condition and not self.connection.features.supports_partial_indexes) or",
                    "+            (include and not self.connection.features.supports_covering_indexes)",
                    "         ):",
                    "             return None",
                    "-        if condition:",
                    "-            return (",
                    "-                self._delete_constraint_sql(self.sql_delete_index, model, name)",
                    "-                if self.connection.features.supports_partial_indexes else None",
                    "-            )",
                    "-        return self._delete_constraint_sql(self.sql_delete_unique, model, name)",
                    "+        if condition or include:",
                    "+            sql = self.sql_delete_index",
                    "+        else:",
                    "+            sql = self.sql_delete_unique",
                    "+        return self._delete_constraint_sql(sql, model, name)"
                ],
                "start_lineno": 1137,
                "end_lineno": 1150
            }
        ],
        "django/db/backends/postgresql/features.py": [
            {
                "hunk": [
                    "+    supports_covering_indexes = property(operator.attrgetter('is_postgresql_11'))",
                    "+    supports_covering_gist_indexes = property(operator.attrgetter('is_postgresql_12'))"
                ],
                "start_lineno": 85,
                "end_lineno": 85
            }
        ],
        "django/db/backends/postgresql/schema.py": [
            {
                "hunk": [
                    "-    sql_create_index = \"CREATE INDEX %(name)s ON %(table)s%(using)s (%(columns)s)%(extra)s%(condition)s\"",
                    "+    sql_create_index = (",
                    "+        'CREATE INDEX %(name)s ON %(table)s%(using)s '",
                    "+        '(%(columns)s)%(include)s%(extra)s%(condition)s'",
                    "+    )",
                    "     sql_create_index_concurrently = (",
                    "-        \"CREATE INDEX CONCURRENTLY %(name)s ON %(table)s%(using)s (%(columns)s)%(extra)s%(condition)s\"",
                    "+        'CREATE INDEX CONCURRENTLY %(name)s ON %(table)s%(using)s '",
                    "+        '(%(columns)s)%(include)s%(extra)s%(condition)s'"
                ],
                "start_lineno": 15,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-        condition=None, concurrently=False,",
                    "+        condition=None, concurrently=False, include=None,",
                    "     ):",
                    "         sql = self.sql_create_index if not concurrently else self.sql_create_index_concurrently",
                    "         return super()._create_index_sql(",
                    "             model, fields, name=name, suffix=suffix, using=using, db_tablespace=db_tablespace,",
                    "             col_suffixes=col_suffixes, sql=sql, opclasses=opclasses, condition=condition,",
                    "+            include=include,"
                ],
                "start_lineno": 200,
                "end_lineno": 205
            }
        ],
        "django/db/models/base.py": [
            {
                "hunk": [
                    "-            if (",
                    "+            if not (",
                    "                 connection.features.supports_partial_indexes or",
                    "                 'supports_partial_indexes' in cls._meta.required_db_features",
                    "-            ):",
                    "-                continue",
                    "-            if any(index.condition is not None for index in cls._meta.indexes):",
                    "+            ) and any(index.condition is not None for index in cls._meta.indexes):"
                ],
                "start_lineno": 1617,
                "end_lineno": 1622
            },
            {
                "hunk": [
                    "+            if not (",
                    "+                connection.features.supports_covering_indexes or",
                    "+                'supports_covering_indexes' in cls._meta.required_db_features",
                    "+            ) and any(index.include for index in cls._meta.indexes):",
                    "+                errors.append(",
                    "+                    checks.Warning(",
                    "+                        '%s does not support indexes with non-key columns.'",
                    "+                        % connection.display_name,",
                    "+                        hint=(",
                    "+                            \"Non-key columns will be ignored. Silence this \"",
                    "+                            \"warning if you don't care about it.\"",
                    "+                        ),",
                    "+                        obj=cls,",
                    "+                        id='models.W040',",
                    "+                    )",
                    "+                )",
                    "         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]",
                    "+        fields += [include for index in cls._meta.indexes for include in index.include]"
                ],
                "start_lineno": 1635,
                "end_lineno": 1635
            },
            {
                "hunk": [
                    "-            fields = (",
                    "-                field",
                    "+            if not (",
                    "+                connection.features.supports_covering_indexes or",
                    "+                'supports_covering_indexes' in cls._meta.required_db_features",
                    "+            ) and any(",
                    "+                isinstance(constraint, UniqueConstraint) and constraint.include",
                    "+                for constraint in cls._meta.constraints",
                    "+            ):",
                    "+                errors.append(",
                    "+                    checks.Warning(",
                    "+                        '%s does not support unique constraints with non-key '",
                    "+                        'columns.' % connection.display_name,",
                    "+                        hint=(",
                    "+                            \"A constraint won't be created. Silence this \"",
                    "+                            \"warning if you don't care about it.\"",
                    "+                        ),",
                    "+                        obj=cls,",
                    "+                        id='models.W039',",
                    "+                    )",
                    "+                )",
                    "+            fields = chain.from_iterable(",
                    "+                (*constraint.fields, *constraint.include)",
                    "                 for constraint in cls._meta.constraints if isinstance(constraint, UniqueConstraint)",
                    "-                for field in constraint.fields"
                ],
                "start_lineno": 1929,
                "end_lineno": 1932
            }
        ],
        "django/db/models/constraints.py": [
            {
                "hunk": [
                    "-    def __init__(self, *, fields, name, condition=None, deferrable=None):",
                    "+    def __init__(self, *, fields, name, condition=None, deferrable=None, include=None):"
                ],
                "start_lineno": 80,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "+        if not isinstance(include, (type(None), list, tuple)):",
                    "+            raise ValueError('UniqueConstraint.include must be a list or tuple.')",
                    "         self.fields = tuple(fields)",
                    "         self.condition = condition",
                    "         self.deferrable = deferrable",
                    "+        self.include = tuple(include) if include else ()"
                ],
                "start_lineno": 93,
                "end_lineno": 95
            },
            {
                "hunk": [
                    "+        include = [model._meta.get_field(field_name).column for field_name in self.include]",
                    "         condition = self._get_condition_sql(model, schema_editor)",
                    "         return schema_editor._unique_sql(",
                    "             model, fields, self.name, condition=condition,",
                    "-            deferrable=self.deferrable,",
                    "+            deferrable=self.deferrable, include=include,",
                    "         )",
                    " ",
                    "     def create_sql(self, model, schema_editor):",
                    "         fields = [model._meta.get_field(field_name).column for field_name in self.fields]",
                    "+        include = [model._meta.get_field(field_name).column for field_name in self.include]",
                    "         condition = self._get_condition_sql(model, schema_editor)",
                    "         return schema_editor._create_unique_sql(",
                    "             model, fields, self.name, condition=condition,",
                    "-            deferrable=self.deferrable,",
                    "+            deferrable=self.deferrable, include=include,",
                    "         )",
                    " ",
                    "     def remove_sql(self, model, schema_editor):",
                    "         condition = self._get_condition_sql(model, schema_editor)",
                    "+        include = [model._meta.get_field(field_name).column for field_name in self.include]",
                    "         return schema_editor._delete_unique_sql(",
                    "             model, self.name, condition=condition, deferrable=self.deferrable,",
                    "+            include=include,",
                    "         )",
                    " ",
                    "     def __repr__(self):",
                    "-        return '<%s: fields=%r name=%r%s%s>' % (",
                    "+        return '<%s: fields=%r name=%r%s%s%s>' % (",
                    "             self.__class__.__name__, self.fields, self.name,",
                    "             '' if self.condition is None else ' condition=%s' % self.condition,",
                    "             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,",
                    "+            '' if not self.include else ' include=%s' % repr(self.include),"
                ],
                "start_lineno": 109,
                "end_lineno": 133
            },
            {
                "hunk": [
                    "-                self.deferrable == other.deferrable",
                    "+                self.deferrable == other.deferrable and",
                    "+                self.include == other.include"
                ],
                "start_lineno": 142,
                "end_lineno": 142
            },
            {
                "hunk": [
                    "+        if self.include:",
                    "+            kwargs['include'] = self.include"
                ],
                "start_lineno": 153,
                "end_lineno": 153
            }
        ],
        "django/db/models/indexes.py": [
            {
                "hunk": [
                    "-    def __init__(self, *, fields=(), name=None, db_tablespace=None, opclasses=(), condition=None):",
                    "+    def __init__(",
                    "+        self,",
                    "+        *,",
                    "+        fields=(),",
                    "+        name=None,",
                    "+        db_tablespace=None,",
                    "+        opclasses=(),",
                    "+        condition=None,",
                    "+        include=None,",
                    "+    ):"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "+        if include and not name:",
                    "+            raise ValueError('A covering index must be named.')",
                    "+        if not isinstance(include, (type(None), list, tuple)):",
                    "+            raise ValueError('Index.include must be a list or tuple.')"
                ],
                "start_lineno": 29,
                "end_lineno": 29
            },
            {
                "hunk": [
                    "+        self.include = tuple(include) if include else ()"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            },
            {
                "hunk": [
                    "+        include = [model._meta.get_field(field_name).column for field_name in self.include]",
                    "         col_suffixes = [order[1] for order in self.fields_orders]",
                    "         condition = self._get_condition_sql(model, schema_editor)",
                    "         return schema_editor._create_index_sql(",
                    "             model, fields, name=self.name, using=using, db_tablespace=self.db_tablespace,",
                    "             col_suffixes=col_suffixes, opclasses=self.opclasses, condition=condition,",
                    "-            **kwargs,",
                    "+            include=include, **kwargs,"
                ],
                "start_lineno": 51,
                "end_lineno": 56
            },
            {
                "hunk": [
                    "+        if self.include:",
                    "+            kwargs['include'] = self.include"
                ],
                "start_lineno": 72,
                "end_lineno": 72
            },
            {
                "hunk": [
                    "-        return \"<%s: fields='%s'%s>\" % (",
                    "+        return \"<%s: fields='%s'%s%s>\" % (",
                    "             self.__class__.__name__, ', '.join(self.fields),",
                    "             '' if self.condition is None else ', condition=%s' % self.condition,",
                    "+            '' if not self.include else \", include='%s'\" % ', '.join(self.include),"
                ],
                "start_lineno": 109,
                "end_lineno": 111
            }
        ]
    },
    "pallets__flask-4935": {
        "src/flask/blueprints.py": [
            {
                "hunk": [
                    "+        .. versionchanged:: 2.3",
                    "+            Nested blueprints now correctly apply subdomains.",
                    "+"
                ],
                "start_lineno": 361,
                "end_lineno": 361
            },
            {
                "hunk": [
                    "+            bp_subdomain = bp_options.get(\"subdomain\")",
                    "+",
                    "+            if bp_subdomain is None:",
                    "+                bp_subdomain = blueprint.subdomain",
                    "+",
                    "+            if state.subdomain is not None and bp_subdomain is not None:",
                    "+                bp_options[\"subdomain\"] = bp_subdomain + \".\" + state.subdomain",
                    "+            elif bp_subdomain is not None:",
                    "+                bp_options[\"subdomain\"] = bp_subdomain",
                    "+            elif state.subdomain is not None:",
                    "+                bp_options[\"subdomain\"] = state.subdomain"
                ],
                "start_lineno": 456,
                "end_lineno": 456
            }
        ]
    },
    "django__django-13281": {
        "django/db/models/base.py": [
            {
                "hunk": [
                    "-        return self.__dict__",
                    "+        state = self.__dict__.copy()",
                    "+        state['_state'] = copy.copy(state['_state'])",
                    "+        state['_state'].fields_cache = state['_state'].fields_cache.copy()",
                    "+        return state"
                ],
                "start_lineno": 549,
                "end_lineno": 549
            }
        ]
    },
    "django__django-13199": {
        "django/contrib/messages/storage/cookie.py": [
            {
                "hunk": [
                    "-            response.delete_cookie(self.cookie_name, domain=settings.SESSION_COOKIE_DOMAIN)",
                    "+            response.delete_cookie(",
                    "+                self.cookie_name,",
                    "+                domain=settings.SESSION_COOKIE_DOMAIN,",
                    "+                samesite=settings.SESSION_COOKIE_SAMESITE,",
                    "+            )"
                ],
                "start_lineno": 92,
                "end_lineno": 92
            }
        ],
        "django/contrib/sessions/middleware.py": [
            {
                "hunk": [
                    "+                samesite=settings.SESSION_COOKIE_SAMESITE,"
                ],
                "start_lineno": 41,
                "end_lineno": 41
            }
        ],
        "django/http/response.py": [
            {
                "hunk": [
                    "-    def delete_cookie(self, key, path='/', domain=None):",
                    "+    def delete_cookie(self, key, path='/', domain=None, samesite=None):",
                    "         # Most browsers ignore the Set-Cookie header if the cookie name starts",
                    "         # with __Host- or __Secure- and the cookie doesn't use the secure flag.",
                    "         secure = key.startswith(('__Secure-', '__Host-'))",
                    "         self.set_cookie(",
                    "             key, max_age=0, path=path, domain=domain, secure=secure,",
                    "-            expires='Thu, 01 Jan 1970 00:00:00 GMT',",
                    "+            expires='Thu, 01 Jan 1970 00:00:00 GMT', samesite=samesite,"
                ],
                "start_lineno": 212,
                "end_lineno": 218
            }
        ]
    },
    "pytest-dev__pytest-5404": {
        "src/_pytest/doctest.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 6,
                "end_lineno": 6
            },
            {
                "hunk": [
                    "+from _pytest.warning_types import PytestWarning"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-            if stop is None:",
                    "-                return real_unwrap(obj, stop=_is_mocked)",
                    "-            else:",
                    "+            try:",
                    "+                if stop is None or stop is _is_mocked:",
                    "+                    return real_unwrap(obj, stop=_is_mocked)",
                    "                 return real_unwrap(obj, stop=lambda obj: _is_mocked(obj) or stop(obj))",
                    "+            except Exception as e:",
                    "+                warnings.warn(",
                    "+                    \"Got %r when unwrapping %r.  This is usually caused \"",
                    "+                    \"by a violation of Python's object protocol; see e.g. \"",
                    "+                    \"https://github.com/pytest-dev/pytest/issues/5080\" % (e, obj),",
                    "+                    PytestWarning,",
                    "+                )",
                    "+                raise"
                ],
                "start_lineno": 371,
                "end_lineno": 374
            }
        ]
    },
    "sphinx-doc__sphinx-9654": {
        "sphinx/ext/autodoc/__init__.py": [
            {
                "hunk": [
                    "-            if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):",
                    "+            if inspect.getorigbases(self.object):"
                ],
                "start_lineno": 1654,
                "end_lineno": 1654
            }
        ],
        "sphinx/util/inspect.py": [
            {
                "hunk": [
                    "+def getorigbases(obj: Any) -> Optional[Tuple[Any, ...]]:",
                    "+    \"\"\"Get __orig_bases__ from *obj* safely.\"\"\"",
                    "+    if not inspect.isclass(obj):",
                    "+        return None",
                    "+",
                    "+    # Get __orig_bases__ from obj.__dict__ to avoid accessing the parent's __orig_bases__.",
                    "+    # refs: https://github.com/sphinx-doc/sphinx/issues/9607",
                    "+    __dict__ = safe_getattr(obj, '__dict__', {})",
                    "+    __orig_bases__ = __dict__.get('__orig_bases__')",
                    "+    if isinstance(__orig_bases__, tuple) and len(__orig_bases__) > 0:",
                    "+        return __orig_bases__",
                    "+    else:",
                    "+        return None",
                    "+",
                    "+"
                ],
                "start_lineno": 190,
                "end_lineno": 190
            }
        ]
    },
    "scikit-learn__scikit-learn-13915": {
        "sklearn/__init__.py": [
            {
                "hunk": [
                    "-__version__ = '0.21.1'",
                    "+__version__ = '0.21.2'"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            }
        ],
        "sklearn/cross_decomposition/pls_.py": [
            {
                "hunk": [
                    "+        Y_eps = np.finfo(Yk.dtype).eps"
                ],
                "start_lineno": 288,
                "end_lineno": 288
            },
            {
                "hunk": [
                    "+                # Replace columns that are all close to zero with zeros",
                    "+                Yk_mask = np.all(np.abs(Yk) < 10 * Y_eps, axis=0)",
                    "+                Yk[:, Yk_mask] = 0.0",
                    "+"
                ],
                "start_lineno": 296,
                "end_lineno": 296
            }
        ],
        "sklearn/experimental/enable_iterative_imputer.py": [
            {
                "hunk": [
                    "-The API and results of this estimators might change without any deprecation",
                    "+The API and results of this estimator might change without any deprecation"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            }
        ],
        "sklearn/metrics/classification.py": [
            {
                "hunk": [
                    "-    The `beta` parameter determines the weight of precision in the combined",
                    "+    The `beta` parameter determines the weight of recall in the combined"
                ],
                "start_lineno": 1069,
                "end_lineno": 1069
            }
        ],
        "sklearn/metrics/pairwise.py": [
            {
                "hunk": [
                    "-def _euclidean_distances_upcast(X, XX=None, Y=None, YY=None):",
                    "+def _euclidean_distances_upcast(X, XX=None, Y=None, YY=None, batch_size=None):"
                ],
                "start_lineno": 286,
                "end_lineno": 286
            },
            {
                "hunk": [
                    "-    x_density = X.nnz / np.prod(X.shape) if issparse(X) else 1",
                    "-    y_density = Y.nnz / np.prod(Y.shape) if issparse(Y) else 1",
                    "-",
                    "-    # Allow 10% more memory than X, Y and the distance matrix take (at least",
                    "-    # 10MiB)",
                    "-    maxmem = max(",
                    "-        ((x_density * n_samples_X + y_density * n_samples_Y) * n_features",
                    "-         + (x_density * n_samples_X * y_density * n_samples_Y)) / 10,",
                    "-        10 * 2 ** 17)",
                    "-",
                    "-    # The increase amount of memory in 8-byte blocks is:",
                    "-    # - x_density * batch_size * n_features (copy of chunk of X)",
                    "-    # - y_density * batch_size * n_features (copy of chunk of Y)",
                    "-    # - batch_size * batch_size (chunk of distance matrix)",
                    "-    # Hence x\u00b2 + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem",
                    "-    #                                 xd=x_density and yd=y_density",
                    "-    tmp = (x_density + y_density) * n_features",
                    "-    batch_size = (-tmp + np.sqrt(tmp ** 2 + 4 * maxmem)) / 2",
                    "-    batch_size = max(int(batch_size), 1)",
                    "-",
                    "-    x_batches = gen_batches(X.shape[0], batch_size)",
                    "-    y_batches = gen_batches(Y.shape[0], batch_size)",
                    "+    if batch_size is None:",
                    "+        x_density = X.nnz / np.prod(X.shape) if issparse(X) else 1",
                    "+        y_density = Y.nnz / np.prod(Y.shape) if issparse(Y) else 1",
                    "+",
                    "+        # Allow 10% more memory than X, Y and the distance matrix take (at",
                    "+        # least 10MiB)",
                    "+        maxmem = max(",
                    "+            ((x_density * n_samples_X + y_density * n_samples_Y) * n_features",
                    "+             + (x_density * n_samples_X * y_density * n_samples_Y)) / 10,",
                    "+            10 * 2 ** 17)",
                    "+",
                    "+        # The increase amount of memory in 8-byte blocks is:",
                    "+        # - x_density * batch_size * n_features (copy of chunk of X)",
                    "+        # - y_density * batch_size * n_features (copy of chunk of Y)",
                    "+        # - batch_size * batch_size (chunk of distance matrix)",
                    "+        # Hence x\u00b2 + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem",
                    "+        #                                 xd=x_density and yd=y_density",
                    "+        tmp = (x_density + y_density) * n_features",
                    "+        batch_size = (-tmp + np.sqrt(tmp ** 2 + 4 * maxmem)) / 2",
                    "+        batch_size = max(int(batch_size), 1)",
                    "+",
                    "+    x_batches = gen_batches(n_samples_X, batch_size)"
                ],
                "start_lineno": 301,
                "end_lineno": 322
            },
            {
                "hunk": [
                    "+        y_batches = gen_batches(n_samples_Y, batch_size)",
                    "+"
                ],
                "start_lineno": 331,
                "end_lineno": 331
            }
        ],
        "sklearn/preprocessing/_encoders.py": [
            {
                "hunk": [
                    "-                \"instead. 'n_values=n' corresponds to 'categories=[range(n)]'.\"",
                    "+                \"instead. 'n_values=n' corresponds to \"",
                    "+                \"'categories=[range(n)] * n_features'.\""
                ],
                "start_lineno": 370,
                "end_lineno": 370
            },
            {
                "hunk": [
                    "+            if self.drop is not None:",
                    "+                names.pop(self.drop_idx_[i])"
                ],
                "start_lineno": 850,
                "end_lineno": 850
            }
        ],
        "sklearn/utils/sparsefuncs.py": [
            {
                "hunk": [
                    "+",
                    "+    # reduceat tries casts X.indptr to intp, which errors",
                    "+    # if it is int64 on a 32 bit system.",
                    "+    # Reinitializing prevents this where possible, see #13737",
                    "+    X = type(X)((X.data, X.indices, X.indptr), shape=X.shape)"
                ],
                "start_lineno": 344,
                "end_lineno": 344
            }
        ]
    },
    "sympy__sympy-20442": {
        "sympy/physics/units/util.py": [
            {
                "hunk": [
                    "+from sympy.matrices.common import NonInvertibleMatrixError"
                ],
                "start_lineno": 7,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "-    res_exponents = camat.solve_least_squares(exprmat, method=None)",
                    "+    try:",
                    "+        res_exponents = camat.solve(exprmat)",
                    "+    except NonInvertibleMatrixError:",
                    "+        return None",
                    "+"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            }
        ]
    },
    "django__django-16037": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    def get_group_by_cols(self, alias=None):",
                    "+        # self.query only gets limited to a single row in the .exists() call",
                    "+        # from self.as_sql() so deferring to Query.get_group_by_cols() is",
                    "+        # inappropriate.",
                    "+        if alias is None:",
                    "+            return [self]",
                    "+        return super().get_group_by_cols(alias)",
                    "+"
                ],
                "start_lineno": 1504,
                "end_lineno": 1504
            }
        ],
        "django/db/models/sql/compiler.py": [
            {
                "hunk": [
                    "-            sql, params = self.compile(expr)",
                    "+            try:",
                    "+                sql, params = self.compile(expr)",
                    "+            except EmptyResultSet:",
                    "+                continue"
                ],
                "start_lineno": 163,
                "end_lineno": 163
            }
        ]
    },
    "django__django-13460": {
        "django/templatetags/i18n.py": [
            {
                "hunk": [
                    "+from decimal import Decimal",
                    "+"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "+            if not isinstance(count, (Decimal, float, int)):",
                    "+                raise TemplateSyntaxError(",
                    "+                    \"%r argument to %r tag must be a number.\"",
                    "+                    % (self.countervar, self.tag_name)",
                    "+                )"
                ],
                "start_lineno": 138,
                "end_lineno": 138
            }
        ]
    },
    "mwaskom__seaborn-3216": {
        "seaborn/_compat.py": [
            {
                "hunk": [
                    "+        # _version_predates(mpl, 3.6)",
                    "         if engine == \"tight\":",
                    "             fig.set_tight_layout(True)",
                    "         elif engine == \"constrained\":",
                    "             fig.set_constrained_layout(True)",
                    "+        elif engine == \"none\":",
                    "+            fig.set_tight_layout(False)",
                    "+            fig.set_constrained_layout(False)"
                ],
                "start_lineno": 152,
                "end_lineno": 155
            }
        ],
        "seaborn/_core/plot.py": [
            {
                "hunk": [
                    "-        engine_default = None if p._target is not None else \"tight\"",
                    "-        layout_engine = p._layout_spec.get(\"engine\", engine_default)",
                    "-        set_layout_engine(self._figure, layout_engine)",
                    "+        if (engine := p._layout_spec.get(\"engine\", default)) is not default:",
                    "+            # None is a valid arg for Figure.set_layout_engine, hence `default`",
                    "+            set_layout_engine(self._figure, engine)",
                    "+        elif p._target is None:",
                    "+            # Don't modify the layout engine if the user supplied their own",
                    "+            # matplotlib figure and didn't specify an engine through Plot",
                    "+            # TODO switch default to \"constrained\"?",
                    "+            set_layout_engine(self._figure, \"tight\")"
                ],
                "start_lineno": 1665,
                "end_lineno": 1667
            }
        ]
    },
    "django__django-15382": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        sql, params = super().as_sql(",
                    "-            compiler,",
                    "-            connection,",
                    "-            template=template,",
                    "-            query=query,",
                    "-            **extra_context,",
                    "-        )",
                    "+        try:",
                    "+            sql, params = super().as_sql(",
                    "+                compiler,",
                    "+                connection,",
                    "+                template=template,",
                    "+                query=query,",
                    "+                **extra_context,",
                    "+            )",
                    "+        except EmptyResultSet:",
                    "+            if self.negated:",
                    "+                return '', ()",
                    "+            raise"
                ],
                "start_lineno": 1214,
                "end_lineno": 1220
            }
        ]
    },
    "sympy__sympy-13852": {
        "sympy/functions/special/zeta_functions.py": [
            {
                "hunk": [
                    "-from sympy.core import Function, S, sympify, pi",
                    "+from sympy.core import Function, S, sympify, pi, I",
                    " from sympy.core.function import ArgumentIndexError",
                    " from sympy.core.compatibility import range",
                    " from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic",
                    " from sympy.functions.elementary.exponential import log",
                    "-",
                    "+from sympy.functions.elementary.miscellaneous import sqrt"
                ],
                "start_lineno": 4,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-    -log(z*exp_polar(-I*pi) + 1)",
                    "+    -log(-z + 1)"
                ],
                "start_lineno": 256,
                "end_lineno": 256
            },
            {
                "hunk": [
                    "-            return 0",
                    "+            return S.Zero",
                    "+        elif s == 2:",
                    "+            if z == S.Half:",
                    "+                return pi**2/12 - log(2)**2/2",
                    "+            elif z == 2:",
                    "+                return pi**2/4 - I*pi*log(2)",
                    "+            elif z == -(sqrt(5) - 1)/2:",
                    "+                return -pi**2/15 + log((sqrt(5)-1)/2)**2/2",
                    "+            elif z == -(sqrt(5) + 1)/2:",
                    "+                return -pi**2/10 - log((sqrt(5)+1)/2)**2",
                    "+            elif z == (3 - sqrt(5))/2:",
                    "+                return pi**2/15 - log((sqrt(5)-1)/2)**2",
                    "+            elif z == (sqrt(5) - 1)/2:",
                    "+                return pi**2/10 - log((sqrt(5)-1)/2)**2",
                    "+        # For s = 0 or -1 use explicit formulas to evaluate, but",
                    "+        # automatically expanding polylog(1, z) to -log(1-z) seems undesirable",
                    "+        # for summation methods based on hypergeometric functions",
                    "+        elif s == 0:",
                    "+            return z/(1 - z)",
                    "+        elif s == -1:",
                    "+            return z/(1 - z)**2"
                ],
                "start_lineno": 279,
                "end_lineno": 279
            },
            {
                "hunk": [
                    "-            return -log(1 + exp_polar(-I*pi)*z)",
                    "+            return -log(1 - z)"
                ],
                "start_lineno": 294,
                "end_lineno": 294
            }
        ]
    },
    "scikit-learn__scikit-learn-9274": {
        "sklearn/neural_network/multilayer_perceptron.py": [
            {
                "hunk": [
                    "-                 n_iter_no_change):",
                    "+                 n_iter_no_change, max_fun):"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "+        self.max_fun = max_fun"
                ],
                "start_lineno": 78,
                "end_lineno": 78
            },
            {
                "hunk": [
                    "-        self.n_iter_ += 1"
                ],
                "start_lineno": 175,
                "end_lineno": 175
            },
            {
                "hunk": [
                    "+        if self.max_fun <= 0:",
                    "+            raise ValueError(\"max_fun must be > 0, got %s.\" % self.max_fun)"
                ],
                "start_lineno": 384,
                "end_lineno": 384
            },
            {
                "hunk": [
                    "-            maxfun=self.max_iter,",
                    "+            maxfun=self.max_fun,",
                    "+            maxiter=self.max_iter,",
                    "             iprint=iprint,",
                    "             pgtol=self.tol,",
                    "             args=(X, y, activations, deltas, coef_grads, intercept_grads))",
                    "+        self.n_iter_ = d['nit']",
                    "+        if d['warnflag'] == 1:",
                    "+            if d['nit'] >= self.max_iter:",
                    "+                warnings.warn(",
                    "+                    \"LBFGS Optimizer: Maximum iterations (%d) \"",
                    "+                    \"reached and the optimization hasn't converged yet.\"",
                    "+                    % self.max_iter, ConvergenceWarning)",
                    "+            if d['funcalls'] >= self.max_fun:",
                    "+                warnings.warn(",
                    "+                    \"LBFGS Optimizer: Maximum function evaluations (%d) \"",
                    "+                    \"reached and the optimization hasn't converged yet.\"",
                    "+                    % self.max_fun, ConvergenceWarning)",
                    "+        elif d['warnflag'] == 2:",
                    "+            warnings.warn(",
                    "+                \"LBFGS Optimizer: Optimization hasn't converged yet, \"",
                    "+                \"cause of LBFGS stopping: %s.\"",
                    "+                % d['task'], ConvergenceWarning)",
                    "+"
                ],
                "start_lineno": 462,
                "end_lineno": 465
            },
            {
                "hunk": [
                    "+    max_fun : int, optional, default 15000",
                    "+        Only used when solver='lbfgs'. Maximum number of loss function calls.",
                    "+        The solver iterates until convergence (determined by 'tol'), number",
                    "+        of iterations reaches max_iter, or this number of loss function calls.",
                    "+        Note that number of loss function calls will be greater than or equal",
                    "+        to the number of iterations for the `MLPClassifier`.",
                    "+",
                    "+        .. versionadded:: 0.22",
                    "+"
                ],
                "start_lineno": 836,
                "end_lineno": 836
            },
            {
                "hunk": [
                    "-                 epsilon=1e-8, n_iter_no_change=10):",
                    "-",
                    "+                 epsilon=1e-8, n_iter_no_change=10, max_fun=15000):"
                ],
                "start_lineno": 901,
                "end_lineno": 902
            },
            {
                "hunk": [
                    "-            n_iter_no_change=n_iter_no_change)",
                    "+            n_iter_no_change=n_iter_no_change, max_fun=max_fun)"
                ],
                "start_lineno": 915,
                "end_lineno": 915
            },
            {
                "hunk": [
                    "+    max_fun : int, optional, default 15000",
                    "+        Only used when solver='lbfgs'. Maximum number of function calls.",
                    "+        The solver iterates until convergence (determined by 'tol'), number",
                    "+        of iterations reaches max_iter, or this number of function calls.",
                    "+        Note that number of function calls will be greater than or equal to",
                    "+        the number of iterations for the MLPRegressor.",
                    "+",
                    "+        .. versionadded:: 0.22",
                    "+"
                ],
                "start_lineno": 1219,
                "end_lineno": 1219
            },
            {
                "hunk": [
                    "-                 epsilon=1e-8, n_iter_no_change=10):",
                    "-",
                    "+                 epsilon=1e-8, n_iter_no_change=10, max_fun=15000):"
                ],
                "start_lineno": 1282,
                "end_lineno": 1283
            },
            {
                "hunk": [
                    "-            n_iter_no_change=n_iter_no_change)",
                    "+            n_iter_no_change=n_iter_no_change, max_fun=max_fun)"
                ],
                "start_lineno": 1296,
                "end_lineno": 1296
            }
        ]
    },
    "scikit-learn__scikit-learn-14125": {
        "sklearn/utils/multiclass.py": [
            {
                "hunk": [
                    "-    sparseseries = (y.__class__.__name__ == 'SparseSeries')",
                    "-    if sparseseries:",
                    "-        raise ValueError(\"y cannot be class 'SparseSeries'.\")",
                    "+    sparse_pandas = (y.__class__.__name__ in ['SparseSeries', 'SparseArray'])",
                    "+    if sparse_pandas:",
                    "+        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")"
                ],
                "start_lineno": 243,
                "end_lineno": 245
            }
        ]
    },
    "django__django-13297": {
        "django/views/generic/base.py": [
            {
                "hunk": [
                    "-from django.utils.functional import SimpleLazyObject",
                    "+from django.utils.functional import lazy"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "-        @SimpleLazyObject"
                ],
                "start_lineno": 172,
                "end_lineno": 172
            },
            {
                "hunk": [
                    "-        context_kwargs[key] = access_value",
                    "+        context_kwargs[key] = lazy(access_value, type(value))()"
                ],
                "start_lineno": 181,
                "end_lineno": 181
            }
        ]
    },
    "django__django-13012": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    def get_group_by_cols(self, alias=None):",
                    "+        return self.expression.get_group_by_cols(alias=alias)",
                    "+"
                ],
                "start_lineno": 866,
                "end_lineno": 866
            }
        ]
    },
    "sympy__sympy-18477": {
        "sympy/printing/glsl.py": [
            {
                "hunk": [
                    "-        'reserved_word_suffix': '_'",
                    "+        'reserved_word_suffix': '_',"
                ],
                "start_lineno": 56,
                "end_lineno": 56
            }
        ],
        "sympy/printing/jscode.py": [
            {
                "hunk": [
                    "-        'contract': True",
                    "+        'contract': True,"
                ],
                "start_lineno": 60,
                "end_lineno": 60
            }
        ],
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+        \"full_prec\": False,"
                ],
                "start_lineno": 128,
                "end_lineno": 128
            },
            {
                "hunk": [
                    "+        \"min\": None,",
                    "+        \"max\": None,"
                ],
                "start_lineno": 147,
                "end_lineno": 147
            },
            {
                "hunk": [
                    "-        str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)",
                    "+        strip = False if self._settings['full_prec'] else True",
                    "+        low = self._settings[\"min\"] if \"min\" in self._settings else None",
                    "+        high = self._settings[\"max\"] if \"max\" in self._settings else None",
                    "+        str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)"
                ],
                "start_lineno": 417,
                "end_lineno": 417
            },
            {
                "hunk": [
                    "-def latex(expr, fold_frac_powers=False, fold_func_brackets=False,",
                    "-          fold_short_frac=None, inv_trig_style=\"abbreviated\",",
                    "+def latex(expr, full_prec=False, min=None, max=None, fold_frac_powers=False,",
                    "+          fold_func_brackets=False, fold_short_frac=None, inv_trig_style=\"abbreviated\","
                ],
                "start_lineno": 2553,
                "end_lineno": 2554
            },
            {
                "hunk": [
                    "+    full_prec: boolean, optional",
                    "+        If set to True, a floating point number is printed with full precision."
                ],
                "start_lineno": 2564,
                "end_lineno": 2564
            },
            {
                "hunk": [
                    "+    min: Integer or None, optional",
                    "+        Sets the lower bound for the exponent to print floating point numbers in",
                    "+        fixed-point format.",
                    "+    max: Integer or None, optional",
                    "+        Sets the upper bound for the exponent to print floating point numbers in",
                    "+        fixed-point format."
                ],
                "start_lineno": 2631,
                "end_lineno": 2631
            },
            {
                "hunk": [
                    "+        'full_prec': full_prec,"
                ],
                "start_lineno": 2742,
                "end_lineno": 2742
            },
            {
                "hunk": [
                    "+        'min': min,",
                    "+        'max': max,"
                ],
                "start_lineno": 2761,
                "end_lineno": 2761
            }
        ],
        "sympy/printing/pycode.py": [
            {
                "hunk": [
                    "-        standard='python3'",
                    "+        standard='python3',"
                ],
                "start_lineno": 95,
                "end_lineno": 95
            }
        ],
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "+        \"min\": None,",
                    "+        \"max\": None,"
                ],
                "start_lineno": 27,
                "end_lineno": 27
            },
            {
                "hunk": [
                    "-        rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip)",
                    "+        low = self._settings[\"min\"] if \"min\" in self._settings else None",
                    "+        high = self._settings[\"max\"] if \"max\" in self._settings else None",
                    "+        rv = mlib_to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)"
                ],
                "start_lineno": 694,
                "end_lineno": 694
            }
        ]
    },
    "django__django-12796": {
        "django/core/management/commands/makemigrations.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-from django.db import DEFAULT_DB_ALIAS, connections, router",
                    "+from django.db import DEFAULT_DB_ALIAS, OperationalError, connections, router"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "-                loader.check_consistent_history(connection)",
                    "-",
                    "+                try:",
                    "+                    loader.check_consistent_history(connection)",
                    "+                except OperationalError as error:",
                    "+                    warnings.warn(",
                    "+                        \"Got an error checking a consistent migration history \"",
                    "+                        \"performed for database connection '%s': %s.\"",
                    "+                        % (alias, error),",
                    "+                        RuntimeWarning,",
                    "+                    )"
                ],
                "start_lineno": 101,
                "end_lineno": 102
            }
        ]
    },
    "sphinx-doc__sphinx-9104": {
        "sphinx/domains/python.py": [
            {
                "hunk": [
                    "-        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+)'",
                    "+        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\.\\.\\.)'"
                ],
                "start_lineno": 307,
                "end_lineno": 307
            }
        ]
    },
    "sphinx-doc__sphinx-8058": {
        "sphinx/builders/gettext.py": [
            {
                "hunk": [
                    "-    app.add_config_value('gettext_compact', True, 'gettext')",
                    "+    app.add_config_value('gettext_compact', True, 'gettext', Any)"
                ],
                "start_lineno": 319,
                "end_lineno": 319
            }
        ],
        "sphinx/util/i18n.py": [
            {
                "hunk": [
                    "-from typing import Callable, Generator, List, Set, Tuple",
                    "+from typing import Callable, Generator, List, Set, Tuple, Union"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-def docname_to_domain(docname: str, compation: bool) -> str:",
                    "+def docname_to_domain(docname: str, compation: Union[bool, str]) -> str:",
                    "     \"\"\"Convert docname to domain for catalogs.\"\"\"",
                    "+    if isinstance(compation, str):",
                    "+        return compation"
                ],
                "start_lineno": 131,
                "end_lineno": 132
            }
        ]
    },
    "sympy__sympy-17271": {
        "sympy/functions/elementary/integers.py": [
            {
                "hunk": [
                    "+from sympy.core.logic import fuzzy_or",
                    " from sympy.core.numbers import Integer",
                    "-from sympy.core.relational import Gt, Lt, Ge, Le",
                    "+from sympy.core.relational import Gt, Lt, Ge, Le, Relational",
                    " from sympy.core.symbol import Symbol",
                    "+from sympy.core.sympify import _sympify"
                ],
                "start_lineno": 6,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "+        if other is S.Infinity and self.is_finite:",
                    "+            return S.true"
                ],
                "start_lineno": 158,
                "end_lineno": 158
            },
            {
                "hunk": [
                    "+        if other is S.NegativeInfinity and self.is_real:",
                    "+            return S.true"
                ],
                "start_lineno": 247,
                "end_lineno": 247
            },
            {
                "hunk": [
                    "-                    return None",
                    "+                    return S.NaN"
                ],
                "start_lineno": 312,
                "end_lineno": 312
            },
            {
                "hunk": [
                    "+            # Check if other < 0",
                    "+            if other.is_extended_negative:",
                    "+                return S.false",
                    "+            # Check if other >= 1",
                    "+            res = self._value_one_or_more(other)",
                    "+            if res is not None:",
                    "+                return S.false",
                    "+",
                    "+    def _eval_is_finite(self):",
                    "+        return True",
                    "+",
                    "+    def _eval_is_real(self):",
                    "+        return self.args[0].is_extended_real",
                    "+",
                    "+    def _eval_is_imaginary(self):",
                    "+        return self.args[0].is_imaginary",
                    "+",
                    "+    def _eval_is_integer(self):",
                    "+        return self.args[0].is_integer",
                    "+",
                    "+    def _eval_is_zero(self):",
                    "+        return fuzzy_or([self.args[0].is_zero, self.args[0].is_integer])",
                    "+",
                    "+    def _eval_is_negative(self):",
                    "+        return False",
                    "+",
                    "+    def __ge__(self, other):",
                    "+        if self.is_extended_real:",
                    "+            other = _sympify(other)",
                    "+            # Check if other <= 0",
                    "+            if other.is_extended_nonpositive:",
                    "+                return S.true",
                    "+            # Check if other >= 1",
                    "+            res = self._value_one_or_more(other)",
                    "+            if res is not None:",
                    "+                return not(res)",
                    "+        return Ge(self, other, evaluate=False)",
                    "+",
                    "+    def __gt__(self, other):",
                    "+        if self.is_extended_real:",
                    "+            other = _sympify(other)",
                    "+            # Check if other < 0",
                    "+            res = self._value_one_or_more(other)",
                    "+            if res is not None:",
                    "+                return not(res)",
                    "+            # Check if other >= 1",
                    "+            if other.is_extended_negative:",
                    "+                return S.true",
                    "+        return Gt(self, other, evaluate=False)",
                    "+",
                    "+    def __le__(self, other):",
                    "+        if self.is_extended_real:",
                    "+            other = _sympify(other)",
                    "+            # Check if other < 0",
                    "+            if other.is_extended_negative:",
                    "+                return S.false",
                    "+            # Check if other >= 1",
                    "+            res = self._value_one_or_more(other)",
                    "+            if res is not None:",
                    "+                return res",
                    "+        return Le(self, other, evaluate=False)",
                    "+",
                    "+    def __lt__(self, other):",
                    "+        if self.is_extended_real:",
                    "+            other = _sympify(other)",
                    "+            # Check if other <= 0",
                    "+            if other.is_extended_nonpositive:",
                    "+                return S.false",
                    "+            # Check if other >= 1",
                    "+            res = self._value_one_or_more(other)",
                    "+            if res is not None:",
                    "+                return res",
                    "+        return Lt(self, other, evaluate=False)",
                    "+",
                    "+    def _value_one_or_more(self, other):",
                    "+        if other.is_extended_real:",
                    "+            if other.is_number:",
                    "+                res = other >= 1",
                    "+                if res and not isinstance(res, Relational):",
                    "+                    return S.true",
                    "+            if other.is_integer and other.is_positive:",
                    "+                return S.true"
                ],
                "start_lineno": 346,
                "end_lineno": 346
            }
        ],
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+    def _print_frac(self, expr, exp=None):",
                    "+        if exp is None:",
                    "+            return r\"\\operatorname{frac}{\\left(%s\\right)}\" % self._print(expr.args[0])",
                    "+        else:",
                    "+            return r\"\\operatorname{frac}{\\left(%s\\right)}^{%s}\" % (",
                    "+                    self._print(expr.args[0]), self._print(exp))",
                    "+"
                ],
                "start_lineno": 1736,
                "end_lineno": 1736
            }
        ]
    },
    "django__django-11163": {
        "django/forms/models.py": [
            {
                "hunk": [
                    "-        if fields and f.name not in fields:",
                    "+        if fields is not None and f.name not in fields:"
                ],
                "start_lineno": 86,
                "end_lineno": 86
            }
        ]
    },
    "astropy__astropy-13462": {
        "astropy/time/utils.py": [
            {
                "hunk": [
                    "-    extra, frac = two_sum(sum12, -day)",
                    "-    frac += extra + err12",
                    "-    # Our fraction can now have gotten >0.5 or <-0.5, which means we would",
                    "-    # loose one bit of precision. So, correct for that.",
                    "-    excess = np.round(frac)",
                    "+    # Calculate remaining fraction. This can have gotten >0.5 or <-0.5, which means",
                    "+    # we would lose one bit of precision. So, correct for that.  Here, we need",
                    "+    # particular care for the case that frac=0.5 and check>0 or frac=-0.5 and check<0,",
                    "+    # since in that case if check is large enough, rounding was done the wrong way.",
                    "+    frac, check = two_sum(sum12 - day, err12)",
                    "+    excess = np.where(frac * np.sign(check) != 0.5, np.round(frac),",
                    "+                      np.round(frac+2*check))",
                    "     day += excess",
                    "-    extra, frac = two_sum(sum12, -day)",
                    "-    frac += extra + err12",
                    "+    frac = sum12 - day",
                    "+    frac += err12"
                ],
                "start_lineno": 63,
                "end_lineno": 70
            }
        ]
    },
    "pytest-dev__pytest-7468": {
        "src/_pytest/logging.py": [
            {
                "hunk": [
                    "+        if log_file != os.devnull:",
                    "+            directory = os.path.dirname(os.path.abspath(log_file))",
                    "+            if not os.path.isdir(directory):",
                    "+                os.makedirs(directory)",
                    "+",
                    "         self.log_file_handler = _FileHandler(log_file, mode=\"w\", encoding=\"UTF-8\")",
                    "         log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")",
                    "         log_file_date_format = get_option_ini(",
                    "             config, \"log_file_date_format\", \"log_date_format\"",
                    "         )",
                    "+"
                ],
                "start_lineno": 534,
                "end_lineno": 538
            }
        ]
    },
    "sphinx-doc__sphinx-8269": {
        "sphinx/builders/linkcheck.py": [
            {
                "hunk": [
                    "+                    response.raise_for_status()"
                ],
                "start_lineno": 169,
                "end_lineno": 169
            }
        ]
    },
    "sympy__sympy-13369": {
        "sympy/polys/polyroots.py": [
            {
                "hunk": [
                    "+                        else:",
                    "+                            for r in _try_heuristics(f):",
                    "+                                _update_dict(result, r, 1)"
                ],
                "start_lineno": 1015,
                "end_lineno": 1015
            }
        ]
    },
    "django__django-15342": {
        "django/db/migrations/state.py": [
            {
                "hunk": [
                    "-        field_name = (",
                    "-            self.options['order_with_respect_to']",
                    "-            if field_name == '_order'",
                    "-            else field_name",
                    "-        )",
                    "+        if field_name == '_order':",
                    "+            field_name = self.options.get('order_with_respect_to', field_name)"
                ],
                "start_lineno": 688,
                "end_lineno": 692
            }
        ]
    },
    "django__django-11177": {
        "django/utils/autoreload.py": [
            {
                "hunk": [
                    "-    if termios:",
                    "-        fd = sys.stdin",
                    "-        if fd.isatty():",
                    "-            attr_list = termios.tcgetattr(fd)",
                    "-            if not attr_list[3] & termios.ECHO:",
                    "-                attr_list[3] |= termios.ECHO",
                    "-                if hasattr(signal, 'SIGTTOU'):",
                    "-                    old_handler = signal.signal(signal.SIGTTOU, signal.SIG_IGN)",
                    "-                else:",
                    "-                    old_handler = None",
                    "-                termios.tcsetattr(fd, termios.TCSANOW, attr_list)",
                    "-                if old_handler is not None:",
                    "-                    signal.signal(signal.SIGTTOU, old_handler)",
                    "+    \"\"\"",
                    "+    Ensure that echo mode is enabled. Some tools such as PDB disable",
                    "+    it which causes usability issues after reload.",
                    "+    \"\"\"",
                    "+    if not termios or not sys.stdin.isatty():",
                    "+        return",
                    "+    attr_list = termios.tcgetattr(sys.stdin)",
                    "+    if not attr_list[3] & termios.ECHO:",
                    "+        attr_list[3] |= termios.ECHO",
                    "+        if hasattr(signal, 'SIGTTOU'):",
                    "+            old_handler = signal.signal(signal.SIGTTOU, signal.SIG_IGN)",
                    "+        else:",
                    "+            old_handler = None",
                    "+        termios.tcsetattr(sys.stdin, termios.TCSANOW, attr_list)",
                    "+        if old_handler is not None:",
                    "+            signal.signal(signal.SIGTTOU, old_handler)"
                ],
                "start_lineno": 81,
                "end_lineno": 93
            },
            {
                "hunk": [
                    "-        get_resolver().urlconf_module",
                    "+        try:",
                    "+            get_resolver().urlconf_module",
                    "+        except Exception:",
                    "+            # Loading the urlconf can result in errors during development.",
                    "+            # If this occurs then swallow the error and continue.",
                    "+            pass"
                ],
                "start_lineno": 272,
                "end_lineno": 272
            },
            {
                "hunk": [
                    "-        state, previous_timestamp = {}, time.time()",
                    "+        mtimes = {}",
                    "         while True:",
                    "-            state.update(self.loop_files(state, previous_timestamp))",
                    "-            previous_timestamp = time.time()",
                    "+            for filepath, mtime in self.snapshot_files():",
                    "+                old_time = mtimes.get(filepath)",
                    "+                if old_time is None:",
                    "+                    logger.debug('File %s first seen with mtime %s', filepath, mtime)",
                    "+                    mtimes[filepath] = mtime",
                    "+                    continue",
                    "+                elif mtime > old_time:",
                    "+                    logger.debug('File %s previous mtime: %s, current mtime: %s', filepath, old_time, mtime)",
                    "+                    self.notify_file_changed(filepath)",
                    "+",
                    "             time.sleep(self.SLEEP_TIME)",
                    "             yield",
                    " ",
                    "-    def loop_files(self, previous_times, previous_timestamp):",
                    "-        updated_times = {}",
                    "-        for path, mtime in self.snapshot_files():",
                    "-            previous_time = previous_times.get(path)",
                    "-            # If there are overlapping globs, a file may be iterated twice.",
                    "-            if path in updated_times:",
                    "-                continue",
                    "-            # A new file has been detected. This could happen due to it being",
                    "-            # imported at runtime and only being polled now, or because the",
                    "-            # file was just created. Compare the file's mtime to the",
                    "-            # previous_timestamp and send a notification if it was created",
                    "-            # since the last poll.",
                    "-            is_newly_created = previous_time is None and mtime > previous_timestamp",
                    "-            is_changed = previous_time is not None and previous_time != mtime",
                    "-            if is_newly_created or is_changed:",
                    "-                logger.debug('File %s. is_changed: %s, is_new: %s', path, is_changed, is_newly_created)",
                    "-                logger.debug('File %s previous mtime: %s, current mtime: %s', path, previous_time, mtime)",
                    "-                self.notify_file_changed(path)",
                    "-                updated_times[path] = mtime",
                    "-        return updated_times",
                    "-",
                    "     def snapshot_files(self):",
                    "+        # watched_files may produce duplicate paths if globs overlap.",
                    "+        seen_files = set()",
                    "         for file in self.watched_files():",
                    "+            if file in seen_files:",
                    "+                continue",
                    "             try:",
                    "                 mtime = file.stat().st_mtime",
                    "             except OSError:",
                    "                 # This is thrown when the file does not exist.",
                    "                 continue",
                    "+            seen_files.add(file)"
                ],
                "start_lineno": 319,
                "end_lineno": 353
            },
            {
                "hunk": [
                    "-    django_main_thread = threading.Thread(target=main_func, args=args, kwargs=kwargs)",
                    "+    django_main_thread = threading.Thread(target=main_func, args=args, kwargs=kwargs, name='django-main-thread')"
                ],
                "start_lineno": 559,
                "end_lineno": 559
            }
        ]
    },
    "django__django-13212": {
        "django/core/validators.py": [
            {
                "hunk": [
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 51,
                "end_lineno": 51
            },
            {
                "hunk": [
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})",
                    "         # Check if the scheme is valid.",
                    "         scheme = value.split('://')[0].lower()",
                    "         if scheme not in self.schemes:",
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 103,
                "end_lineno": 107
            },
            {
                "hunk": [
                    "-                    raise ValidationError(self.message, code=self.code)",
                    "+                    raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 118,
                "end_lineno": 118
            },
            {
                "hunk": [
                    "-                    raise ValidationError(self.message, code=self.code)",
                    "+                    raise ValidationError(self.message, code=self.code, params={'value': value})",
                    " ",
                    "         # The maximum length of a full host name is 253 characters per RFC 1034",
                    "         # section 3.1. It's defined to be 255 bytes or less, but this includes",
                    "         # one byte for the length of the name and one byte for the trailing dot",
                    "         # that's used to indicate absolute names in DNS.",
                    "         if len(urlsplit(value).netloc) > 253:",
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 135,
                "end_lineno": 142
            },
            {
                "hunk": [
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})",
                    " ",
                    "         user_part, domain_part = value.rsplit('@', 1)",
                    " ",
                    "         if not self.user_regex.match(user_part):",
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 211,
                "end_lineno": 216
            },
            {
                "hunk": [
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 228,
                "end_lineno": 228
            },
            {
                "hunk": [
                    "-        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')",
                    "+        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid', params={'value': value})",
                    " ",
                    " ",
                    " def validate_ipv6_address(value):",
                    "     if not is_valid_ipv6_address(value):",
                    "-        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')",
                    "+        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid', params={'value': value})"
                ],
                "start_lineno": 275,
                "end_lineno": 280
            },
            {
                "hunk": [
                    "-            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')",
                    "+            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid', params={'value': value})"
                ],
                "start_lineno": 290,
                "end_lineno": 290
            },
            {
                "hunk": [
                    "-            raise ValidationError(self.messages['invalid'])",
                    "+            raise ValidationError(self.messages['invalid'], code='invalid', params={'value': value})"
                ],
                "start_lineno": 441,
                "end_lineno": 441
            },
            {
                "hunk": [
                    "-                params={'max': self.max_digits},",
                    "+                params={'max': self.max_digits, 'value': value},",
                    "             )",
                    "         if self.decimal_places is not None and decimals > self.decimal_places:",
                    "             raise ValidationError(",
                    "                 self.messages['max_decimal_places'],",
                    "                 code='max_decimal_places',",
                    "-                params={'max': self.decimal_places},",
                    "+                params={'max': self.decimal_places, 'value': value},",
                    "             )",
                    "         if (self.max_digits is not None and self.decimal_places is not None and",
                    "                 whole_digits > (self.max_digits - self.decimal_places)):",
                    "             raise ValidationError(",
                    "                 self.messages['max_whole_digits'],",
                    "                 code='max_whole_digits',",
                    "-                params={'max': (self.max_digits - self.decimal_places)},",
                    "+                params={'max': (self.max_digits - self.decimal_places), 'value': value},"
                ],
                "start_lineno": 463,
                "end_lineno": 476
            },
            {
                "hunk": [
                    "-                    'allowed_extensions': ', '.join(self.allowed_extensions)",
                    "+                    'allowed_extensions': ', '.join(self.allowed_extensions),",
                    "+                    'value': value,"
                ],
                "start_lineno": 512,
                "end_lineno": 512
            },
            {
                "hunk": [
                    "-            raise ValidationError(self.message, code=self.code)",
                    "+            raise ValidationError(self.message, code=self.code, params={'value': value})"
                ],
                "start_lineno": 553,
                "end_lineno": 553
            }
        ],
        "django/forms/fields.py": [
            {
                "hunk": [
                    "-    def validate(self, value):",
                    "-        super().validate(value)",
                    "-        if value in self.empty_values:",
                    "-            return",
                    "-        if not value.is_finite():",
                    "-            raise ValidationError(self.error_messages['invalid'], code='invalid')",
                    "-"
                ],
                "start_lineno": 353,
                "end_lineno": 359
            }
        ]
    },
    "pydata__xarray-7019": {
        "xarray/backends/api.py": [
            {
                "hunk": [
                    "-from typing import TYPE_CHECKING, Any, Callable, Final, Literal, Union, cast, overload",
                    "+from typing import (",
                    "+    TYPE_CHECKING,",
                    "+    Any,",
                    "+    Callable,",
                    "+    Final,",
                    "+    Literal,",
                    "+    Union,",
                    "+    cast,",
                    "+    overload,",
                    "+)"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+from xarray.core.daskmanager import DaskManager",
                    " from xarray.core.dataarray import DataArray",
                    " from xarray.core.dataset import Dataset, _get_chunk, _maybe_chunk",
                    " from xarray.core.indexes import Index",
                    "+from xarray.core.parallelcompat import guess_chunkmanager"
                ],
                "start_lineno": 23,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "+        T_Chunks,"
                ],
                "start_lineno": 41,
                "end_lineno": 41
            },
            {
                "hunk": [
                    "-    T_Chunks = Union[int, dict[Any, Any], Literal[\"auto\"], None]"
                ],
                "start_lineno": 51,
                "end_lineno": 51
            },
            {
                "hunk": [
                    "+    chunked_array_type,",
                    "+    from_array_kwargs,",
                    "     **extra_tokens,",
                    " ):",
                    "-    from dask.base import tokenize",
                    "+    chunkmanager = guess_chunkmanager(chunked_array_type)",
                    "+",
                    "+    # TODO refactor to move this dask-specific logic inside the DaskManager class",
                    "+    if isinstance(chunkmanager, DaskManager):",
                    "+        from dask.base import tokenize",
                    " ",
                    "-    mtime = _get_mtime(filename_or_obj)",
                    "-    token = tokenize(filename_or_obj, mtime, engine, chunks, **extra_tokens)",
                    "-    name_prefix = f\"open_dataset-{token}\"",
                    "+        mtime = _get_mtime(filename_or_obj)",
                    "+        token = tokenize(filename_or_obj, mtime, engine, chunks, **extra_tokens)",
                    "+        name_prefix = \"open_dataset-\"",
                    "+    else:",
                    "+        # not used",
                    "+        token = (None,)",
                    "+        name_prefix = None",
                    " ",
                    "     variables = {}",
                    "     for name, var in backend_ds.variables.items():",
                    "-        var_chunks = _get_chunk(var, chunks)",
                    "+        var_chunks = _get_chunk(var, chunks, chunkmanager)"
                ],
                "start_lineno": 300,
                "end_lineno": 310
            },
            {
                "hunk": [
                    "+            chunked_array_type=chunkmanager,",
                    "+            from_array_kwargs=from_array_kwargs.copy(),"
                ],
                "start_lineno": 319,
                "end_lineno": 319
            },
            {
                "hunk": [
                    "+    chunked_array_type,",
                    "+    from_array_kwargs,"
                ],
                "start_lineno": 331,
                "end_lineno": 331
            },
            {
                "hunk": [
                    "+            chunked_array_type,",
                    "+            from_array_kwargs,"
                ],
                "start_lineno": 349,
                "end_lineno": 349
            },
            {
                "hunk": [
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 376,
                "end_lineno": 376
            },
            {
                "hunk": [
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce this datasets' arrays to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        For example if :py:func:`dask.array.Array` objects are used for chunking, additional kwargs will be passed",
                    "+        to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 468,
                "end_lineno": 468
            },
            {
                "hunk": [
                    "+    if from_array_kwargs is None:",
                    "+        from_array_kwargs = {}",
                    "+"
                ],
                "start_lineno": 511,
                "end_lineno": 511
            },
            {
                "hunk": [
                    "+        chunked_array_type,",
                    "+        from_array_kwargs,"
                ],
                "start_lineno": 539,
                "end_lineno": 539
            },
            {
                "hunk": [
                    "-    engine: T_Engine = None,",
                    "-    chunks: T_Chunks = None,",
                    "+    engine: T_Engine | None = None,",
                    "+    chunks: T_Chunks | None = None,"
                ],
                "start_lineno": 549,
                "end_lineno": 550
            },
            {
                "hunk": [
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 561,
                "end_lineno": 561
            },
            {
                "hunk": [
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce the underlying data array to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        For example if :py:func:`dask.array.Array` objects are used for chunking, additional kwargs will be passed",
                    "+        to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 655,
                "end_lineno": 655
            },
            {
                "hunk": [
                    "+        chunked_array_type=chunked_array_type,",
                    "+        from_array_kwargs=from_array_kwargs,"
                ],
                "start_lineno": 698,
                "end_lineno": 698
            },
            {
                "hunk": [
                    "-    chunks: T_Chunks = None,",
                    "+    chunks: T_Chunks | None = None,"
                ],
                "start_lineno": 729,
                "end_lineno": 729
            },
            {
                "hunk": [
                    "-    engine: T_Engine = None,",
                    "+    engine: T_Engine | None = None,"
                ],
                "start_lineno": 739,
                "end_lineno": 739
            },
            {
                "hunk": [
                    "+    chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1493,
                "end_lineno": 1493
            },
            {
                "hunk": [
                    "+    chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1515,
                "end_lineno": 1515
            },
            {
                "hunk": [
                    "+    chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1534,
                "end_lineno": 1534
            },
            {
                "hunk": [
                    "-    writes = writer.sync(compute=compute)",
                    "+    writes = writer.sync(",
                    "+        compute=compute, chunkmanager_store_kwargs=chunkmanager_store_kwargs",
                    "+    )"
                ],
                "start_lineno": 1655,
                "end_lineno": 1655
            }
        ],
        "xarray/backends/common.py": [
            {
                "hunk": [
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.parallelcompat import get_chunked_array_type",
                    "+from xarray.core.pycompat import is_chunked_array"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "-        if is_duck_dask_array(source):",
                    "+        if is_chunked_array(source):"
                ],
                "start_lineno": 156,
                "end_lineno": 156
            },
            {
                "hunk": [
                    "-    def sync(self, compute=True):",
                    "+    def sync(self, compute=True, chunkmanager_store_kwargs=None):",
                    "         if self.sources:",
                    "-            import dask.array as da",
                    "+            chunkmanager = get_chunked_array_type(*self.sources)",
                    " ",
                    "             # TODO: consider wrapping targets with dask.delayed, if this makes",
                    "             # for any discernible difference in perforance, e.g.,",
                    "             # targets = [dask.delayed(t) for t in self.targets]",
                    " ",
                    "-            delayed_store = da.store(",
                    "+            if chunkmanager_store_kwargs is None:",
                    "+                chunkmanager_store_kwargs = {}",
                    "+",
                    "+            delayed_store = chunkmanager.store(",
                    "                 self.sources,",
                    "                 self.targets,",
                    "                 lock=self.lock,",
                    "                 compute=compute,",
                    "                 flush=True,",
                    "                 regions=self.regions,",
                    "+                **chunkmanager_store_kwargs,"
                ],
                "start_lineno": 166,
                "end_lineno": 180
            }
        ],
        "xarray/backends/plugins.py": [
            {
                "hunk": [
                    "-):",
                    "+) -> str | type[BackendEntrypoint]:"
                ],
                "start_lineno": 149,
                "end_lineno": 149
            }
        ],
        "xarray/backends/zarr.py": [
            {
                "hunk": [
                    "+from xarray.core.parallelcompat import guess_chunkmanager"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 719,
                "end_lineno": 719
            },
            {
                "hunk": [
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce this datasets' arrays to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict, optional",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        Defaults to {'manager': 'dask'}, meaning additional kwargs will be passed eventually to",
                    "+        :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 803,
                "end_lineno": 803
            },
            {
                "hunk": [
                    "+    if from_array_kwargs is None:",
                    "+        from_array_kwargs = {}",
                    "+",
                    "     if chunks == \"auto\":",
                    "         try:",
                    "-            import dask.array  # noqa",
                    "+            guess_chunkmanager(",
                    "+                chunked_array_type",
                    "+            )  # attempt to import that parallel backend",
                    " ",
                    "             chunks = {}",
                    "-        except ImportError:",
                    "+        except ValueError:"
                ],
                "start_lineno": 820,
                "end_lineno": 825
            },
            {
                "hunk": [
                    "+        chunked_array_type=chunked_array_type,",
                    "+        from_array_kwargs=from_array_kwargs,"
                ],
                "start_lineno": 854,
                "end_lineno": 854
            }
        ],
        "xarray/coding/strings.py": [
            {
                "hunk": [
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.parallelcompat import get_chunked_array_type, is_chunked_array"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-    if is_duck_dask_array(arr):",
                    "-        import dask.array as da",
                    "+    if is_chunked_array(arr):",
                    "+        chunkmanager = get_chunked_array_type(arr)",
                    " ",
                    "-        return da.map_blocks(",
                    "+        return chunkmanager.map_blocks("
                ],
                "start_lineno": 137,
                "end_lineno": 140
            },
            {
                "hunk": [
                    "-    if is_duck_dask_array(arr):",
                    "-        import dask.array as da",
                    "+    if is_chunked_array(arr):",
                    "+        chunkmanager = get_chunked_array_type(arr)"
                ],
                "start_lineno": 172,
                "end_lineno": 173
            },
            {
                "hunk": [
                    "-        return da.map_blocks(",
                    "+        return chunkmanager.map_blocks("
                ],
                "start_lineno": 182,
                "end_lineno": 182
            }
        ],
        "xarray/coding/variables.py": [
            {
                "hunk": [
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.parallelcompat import get_chunked_array_type",
                    "+from xarray.core.pycompat import is_chunked_array"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            },
            {
                "hunk": [
                    "-        assert not is_duck_dask_array(array)",
                    "+        assert not is_chunked_array(array)"
                ],
                "start_lineno": 60,
                "end_lineno": 60
            },
            {
                "hunk": [
                    "-    if is_duck_dask_array(array):",
                    "-        import dask.array as da",
                    "+    if is_chunked_array(array):",
                    "+        chunkmanager = get_chunked_array_type(array)",
                    " ",
                    "-        return da.map_blocks(func, array, dtype=dtype)",
                    "+        return chunkmanager.map_blocks(func, array, dtype=dtype)"
                ],
                "start_lineno": 161,
                "end_lineno": 164
            },
            {
                "hunk": [
                    "-            data = data.astype(dtype=dtype, copy=True)",
                    "+            data = duck_array_ops.astype(data, dtype=dtype, copy=True)"
                ],
                "start_lineno": 333,
                "end_lineno": 333
            },
            {
                "hunk": [
                    "-            data = duck_array_ops.around(data).astype(signed_dtype)",
                    "+            data = duck_array_ops.astype(duck_array_ops.around(data), signed_dtype)"
                ],
                "start_lineno": 380,
                "end_lineno": 380
            }
        ],
        "xarray/core/common.py": [
            {
                "hunk": [
                    "+from xarray.core.parallelcompat import get_chunked_array_type, guess_chunkmanager",
                    " from xarray.core.pdcompat import _convert_base_to_offset",
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.pycompat import is_chunked_array"
                ],
                "start_lineno": 16,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "+        T_Chunks,"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            },
            {
                "hunk": [
                    "-    def __array__(self: Any, dtype: DTypeLike = None) -> np.ndarray:",
                    "+    def __array__(self: Any, dtype: DTypeLike | None = None) -> np.ndarray:"
                ],
                "start_lineno": 162,
                "end_lineno": 162
            },
            {
                "hunk": [
                    "-    other: DataArray, fill_value: Any, dtype: DTypeLikeSave = None",
                    "+    other: DataArray,",
                    "+    fill_value: Any,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> DataArray:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def full_like(",
                    "-    other: Dataset, fill_value: Any, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset,",
                    "+    fill_value: Any,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def full_like(",
                    "-    other: Variable, fill_value: Any, dtype: DTypeLikeSave = None",
                    "+    other: Variable,",
                    "+    fill_value: Any,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Variable:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def full_like(",
                    "-    other: Dataset | DataArray, fill_value: Any, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray,",
                    "+    fill_value: Any,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = {},",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1399,
                "end_lineno": 1420
            },
            {
                "hunk": [
                    "-    dtype: DTypeMaybeMapping = None,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1429,
                "end_lineno": 1429
            },
            {
                "hunk": [
                    "-    dtype: DTypeMaybeMapping = None,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset | DataArray | Variable:",
                    "-    \"\"\"Return a new object with the same shape and type as a given object.",
                    "+    \"\"\"",
                    "+    Return a new object with the same shape and type as a given object.",
                    "+",
                    "+    Returned object will be chunked if if the given object is chunked, or if chunks or chunked_array_type are specified."
                ],
                "start_lineno": 1437,
                "end_lineno": 1439
            },
            {
                "hunk": [
                    "+    chunks : int, \"auto\", tuple of int or mapping of Hashable to int, optional",
                    "+        Chunk sizes along each dimension, e.g., ``5``, ``\"auto\"``, ``(5, 5)`` or",
                    "+        ``{\"x\": 5, \"y\": 5}``.",
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce the underlying data array to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict, optional",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+        to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 1452,
                "end_lineno": 1452
            },
            {
                "hunk": [
                    "-                v.variable, fill_value.get(k, dtypes.NA), dtype_.get(k, None)",
                    "+                v.variable,",
                    "+                fill_value.get(k, dtypes.NA),",
                    "+                dtype_.get(k, None),",
                    "+                chunks,",
                    "+                chunked_array_type,",
                    "+                from_array_kwargs,"
                ],
                "start_lineno": 1565,
                "end_lineno": 1565
            },
            {
                "hunk": [
                    "-            _full_like_variable(other.variable, fill_value, dtype),",
                    "+            _full_like_variable(",
                    "+                other.variable,",
                    "+                fill_value,",
                    "+                dtype,",
                    "+                chunks,",
                    "+                chunked_array_type,",
                    "+                from_array_kwargs,",
                    "+            ),"
                ],
                "start_lineno": 1574,
                "end_lineno": 1574
            },
            {
                "hunk": [
                    "-        return _full_like_variable(other, fill_value, dtype)",
                    "+        return _full_like_variable(",
                    "+            other, fill_value, dtype, chunks, chunked_array_type, from_array_kwargs",
                    "+        )",
                    "     else:",
                    "         raise TypeError(\"Expected DataArray, Dataset, or Variable\")",
                    " ",
                    " ",
                    " def _full_like_variable(",
                    "-    other: Variable, fill_value: Any, dtype: DTypeLike = None",
                    "+    other: Variable,",
                    "+    fill_value: Any,",
                    "+    dtype: DTypeLike | None = None,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1583,
                "end_lineno": 1589
            },
            {
                "hunk": [
                    "-    if is_duck_dask_array(other.data):",
                    "-        import dask.array",
                    "+    if (",
                    "+        is_chunked_array(other.data)",
                    "+        or chunked_array_type is not None",
                    "+        or chunks is not None",
                    "+    ):",
                    "+        if chunked_array_type is None:",
                    "+            chunkmanager = get_chunked_array_type(other.data)",
                    "+        else:",
                    "+            chunkmanager = guess_chunkmanager(chunked_array_type)",
                    " ",
                    "         if dtype is None:",
                    "             dtype = other.dtype",
                    "-        data = dask.array.full(",
                    "-            other.shape, fill_value, dtype=dtype, chunks=other.data.chunks",
                    "+",
                    "+        if from_array_kwargs is None:",
                    "+            from_array_kwargs = {}",
                    "+",
                    "+        data = chunkmanager.array_api.full(",
                    "+            other.shape,",
                    "+            fill_value,",
                    "+            dtype=dtype,",
                    "+            chunks=chunks if chunks else other.data.chunks,",
                    "+            **from_array_kwargs,"
                ],
                "start_lineno": 1597,
                "end_lineno": 1603
            },
            {
                "hunk": [
                    "-def zeros_like(other: DataArray, dtype: DTypeLikeSave = None) -> DataArray:",
                    "+def zeros_like(",
                    "+    other: DataArray,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> DataArray:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    "-def zeros_like(other: Dataset, dtype: DTypeMaybeMapping = None) -> Dataset:",
                    "+def zeros_like(",
                    "+    other: Dataset,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> Dataset:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    "-def zeros_like(other: Variable, dtype: DTypeLikeSave = None) -> Variable:",
                    "+def zeros_like(",
                    "+    other: Variable,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> Variable:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def zeros_like(",
                    "-    other: Dataset | DataArray, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset | DataArray:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def zeros_like(",
                    "-    other: Dataset | DataArray | Variable, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray | Variable,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset | DataArray | Variable:",
                    "     ...",
                    " ",
                    " ",
                    " def zeros_like(",
                    "-    other: Dataset | DataArray | Variable, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray | Variable,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1612,
                "end_lineno": 1641
            },
            {
                "hunk": [
                    "+    chunks : int, \"auto\", tuple of int or mapping of Hashable to int, optional",
                    "+        Chunk sizes along each dimension, e.g., ``5``, ``\"auto\"``, ``(5, 5)`` or",
                    "+        ``{\"x\": 5, \"y\": 5}``.",
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce the underlying data array to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict, optional",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+        to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 1652,
                "end_lineno": 1652
            },
            {
                "hunk": [
                    "-    return full_like(other, 0, dtype)",
                    "+    return full_like(",
                    "+        other,",
                    "+        0,",
                    "+        dtype,",
                    "+        chunks=chunks,",
                    "+        chunked_array_type=chunked_array_type,",
                    "+        from_array_kwargs=from_array_kwargs,",
                    "+    )",
                    " ",
                    " ",
                    " @overload",
                    "-def ones_like(other: DataArray, dtype: DTypeLikeSave = None) -> DataArray:",
                    "+def ones_like(",
                    "+    other: DataArray,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> DataArray:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    "-def ones_like(other: Dataset, dtype: DTypeMaybeMapping = None) -> Dataset:",
                    "+def ones_like(",
                    "+    other: Dataset,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> Dataset:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    "-def ones_like(other: Variable, dtype: DTypeLikeSave = None) -> Variable:",
                    "+def ones_like(",
                    "+    other: Variable,",
                    "+    dtype: DTypeLikeSave | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    "+) -> Variable:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def ones_like(",
                    "-    other: Dataset | DataArray, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset | DataArray:",
                    "     ...",
                    " ",
                    " ",
                    " @overload",
                    " def ones_like(",
                    "-    other: Dataset | DataArray | Variable, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray | Variable,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,",
                    " ) -> Dataset | DataArray | Variable:",
                    "     ...",
                    " ",
                    " ",
                    " def ones_like(",
                    "-    other: Dataset | DataArray | Variable, dtype: DTypeMaybeMapping = None",
                    "+    other: Dataset | DataArray | Variable,",
                    "+    dtype: DTypeMaybeMapping | None = None,",
                    "+    *,",
                    "+    chunks: T_Chunks = None,",
                    "+    chunked_array_type: str | None = None,",
                    "+    from_array_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1695,
                "end_lineno": 1728
            },
            {
                "hunk": [
                    "+    chunks : int, \"auto\", tuple of int or mapping of Hashable to int, optional",
                    "+        Chunk sizes along each dimension, e.g., ``5``, ``\"auto\"``, ``(5, 5)`` or",
                    "+        ``{\"x\": 5, \"y\": 5}``.",
                    "+    chunked_array_type: str, optional",
                    "+        Which chunked array type to coerce the underlying data array to.",
                    "+        Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+        Experimental API that should not be relied upon.",
                    "+    from_array_kwargs: dict, optional",
                    "+        Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+        chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+        For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+        to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 1739,
                "end_lineno": 1739
            },
            {
                "hunk": [
                    "-    return full_like(other, 1, dtype)",
                    "+    return full_like(",
                    "+        other,",
                    "+        1,",
                    "+        dtype,",
                    "+        chunks=chunks,",
                    "+        chunked_array_type=chunked_array_type,",
                    "+        from_array_kwargs=from_array_kwargs,",
                    "+    )"
                ],
                "start_lineno": 1774,
                "end_lineno": 1774
            }
        ],
        "xarray/core/computation.py": [
            {
                "hunk": [
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.parallelcompat import get_chunked_array_type",
                    "+from xarray.core.pycompat import is_chunked_array, is_duck_dask_array"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            },
            {
                "hunk": [
                    "-    if any(is_duck_dask_array(array) for array in input_data):",
                    "+    if any(is_chunked_array(array) for array in input_data):",
                    "         if dask == \"forbidden\":",
                    "             raise ValueError(",
                    "-                \"apply_ufunc encountered a dask array on an \"",
                    "-                \"argument, but handling for dask arrays has not \"",
                    "+                \"apply_ufunc encountered a chunked array on an \"",
                    "+                \"argument, but handling for chunked arrays has not \"",
                    "                 \"been enabled. Either set the ``dask`` argument \"",
                    "                 \"or load your data into memory first with \"",
                    "                 \"``.load()`` or ``.compute()``\"",
                    "             )",
                    "         elif dask == \"parallelized\":",
                    "+            chunkmanager = get_chunked_array_type(*input_data)",
                    "+"
                ],
                "start_lineno": 678,
                "end_lineno": 687
            },
            {
                "hunk": [
                    "-                    if is_duck_dask_array(data):",
                    "+                    if is_chunked_array(data):"
                ],
                "start_lineno": 700,
                "end_lineno": 700
            },
            {
                "hunk": [
                    "-                                    \"fix, either rechunk into a single dask array chunk along \"",
                    "+                                    \"fix, either rechunk into a single array chunk along \""
                ],
                "start_lineno": 708,
                "end_lineno": 708
            },
            {
                "hunk": [
                    "-                import dask.array as da",
                    "-",
                    "-                res = da.apply_gufunc(",
                    "+                res = chunkmanager.apply_gufunc("
                ],
                "start_lineno": 735,
                "end_lineno": 737
            },
            {
                "hunk": [
                    "-                \"unknown setting for dask array handling in \"",
                    "-                \"apply_ufunc: {}\".format(dask)",
                    "+                \"unknown setting for chunked array handling in \" f\"apply_ufunc: {dask}\""
                ],
                "start_lineno": 752,
                "end_lineno": 753
            },
            {
                "hunk": [
                    "-    if any(is_duck_dask_array(arg) for arg in args):",
                    "+    if any(is_chunked_array(arg) for arg in args):"
                ],
                "start_lineno": 815,
                "end_lineno": 815
            },
            {
                "hunk": [
                    "-            return x.astype(float)",
                    "+            return duck_array_ops.astype(x, dtype=float)"
                ],
                "start_lineno": 2016,
                "end_lineno": 2016
            },
            {
                "hunk": [
                    "-    # Handle dask arrays.",
                    "-    if is_duck_dask_array(array.data):",
                    "-        import dask.array",
                    "-",
                    "+    # Handle chunked arrays (e.g. dask).",
                    "+    if is_chunked_array(array.data):",
                    "+        chunkmanager = get_chunked_array_type(array.data)",
                    "         chunks = dict(zip(array.dims, array.chunks))",
                    "-        dask_coord = dask.array.from_array(array[dim].data, chunks=chunks[dim])",
                    "+        dask_coord = chunkmanager.from_array(array[dim].data, chunks=chunks[dim])"
                ],
                "start_lineno": 2064,
                "end_lineno": 2069
            },
            {
                "hunk": [
                    "-    # Run dask.array.core.unify_chunks",
                    "-    from dask.array.core import unify_chunks",
                    "-",
                    "-    _, dask_data = unify_chunks(*unify_chunks_args)",
                    "-    dask_data_iter = iter(dask_data)",
                    "+    chunkmanager = get_chunked_array_type(*[arg for arg in unify_chunks_args])",
                    "+    _, chunked_data = chunkmanager.unify_chunks(*unify_chunks_args)",
                    "+    chunked_data_iter = iter(chunked_data)",
                    "     out: list[Dataset | DataArray] = []",
                    "     for obj, ds in zip(objects, datasets):",
                    "         for k, v in ds._variables.items():",
                    "             if v.chunks is not None:",
                    "-                ds._variables[k] = v.copy(data=next(dask_data_iter))",
                    "+                ds._variables[k] = v.copy(data=next(chunked_data_iter))"
                ],
                "start_lineno": 2156,
                "end_lineno": 2165
            }
        ],
        "xarray/core/dask_array_ops.py": [
            {
                "hunk": [
                    "-from functools import partial",
                    "-",
                    "-from numpy.core.multiarray import normalize_axis_index  # type: ignore[attr-defined]",
                    "-"
                ],
                "start_lineno": 3,
                "end_lineno": 6
            },
            {
                "hunk": [
                    "-",
                    "-",
                    "-def _first_last_wrapper(array, *, axis, op, keepdims):",
                    "-    return op(array, axis, keepdims=keepdims)",
                    "-",
                    "-",
                    "-def _first_or_last(darray, axis, op):",
                    "-    import dask.array",
                    "-",
                    "-    # This will raise the same error message seen for numpy",
                    "-    axis = normalize_axis_index(axis, darray.ndim)",
                    "-",
                    "-    wrapped_op = partial(_first_last_wrapper, op=op)",
                    "-    return dask.array.reduction(",
                    "-        darray,",
                    "-        chunk=wrapped_op,",
                    "-        aggregate=wrapped_op,",
                    "-        axis=axis,",
                    "-        dtype=darray.dtype,",
                    "-        keepdims=False,  # match numpy version",
                    "-    )",
                    "-",
                    "-",
                    "-def nanfirst(darray, axis):",
                    "-    from xarray.core.duck_array_ops import nanfirst",
                    "-",
                    "-    return _first_or_last(darray, axis, op=nanfirst)",
                    "-",
                    "-",
                    "-def nanlast(darray, axis):",
                    "-    from xarray.core.duck_array_ops import nanlast",
                    "-",
                    "-    return _first_or_last(darray, axis, op=nanlast)"
                ],
                "start_lineno": 99,
                "end_lineno": 131
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"",
                    "+The code in this module is an experiment in going from N=1 to N=2 parallel computing frameworks in xarray.",
                    "+It could later be used as the basis for a public interface allowing any N frameworks to interoperate with xarray,",
                    "+but for now it is just a private experiment.",
                    "+\"\"\"",
                    "+from __future__ import annotations",
                    "+",
                    "+import functools",
                    "+import sys",
                    "+from abc import ABC, abstractmethod",
                    "+from collections.abc import Iterable, Sequence",
                    "+from importlib.metadata import EntryPoint, entry_points",
                    "+from typing import (",
                    "+    TYPE_CHECKING,",
                    "+    Any,",
                    "+    Callable,",
                    "+    Generic,",
                    "+    TypeVar,",
                    "+)",
                    "+",
                    "+import numpy as np",
                    "+",
                    "+from xarray.core.pycompat import is_chunked_array",
                    "+",
                    "+T_ChunkedArray = TypeVar(\"T_ChunkedArray\")",
                    "+",
                    "+if TYPE_CHECKING:",
                    "+    from xarray.core.types import T_Chunks, T_NormalizedChunks",
                    "+",
                    "+",
                    "+@functools.lru_cache(maxsize=1)",
                    "+def list_chunkmanagers() -> dict[str, ChunkManagerEntrypoint]:",
                    "+    \"\"\"",
                    "+    Return a dictionary of available chunk managers and their ChunkManagerEntrypoint objects.",
                    "+",
                    "+    Notes",
                    "+    -----",
                    "+    # New selection mechanism introduced with Python 3.10. See GH6514.",
                    "+    \"\"\"",
                    "+    if sys.version_info >= (3, 10):",
                    "+        entrypoints = entry_points(group=\"xarray.chunkmanagers\")",
                    "+    else:",
                    "+        entrypoints = entry_points().get(\"xarray.chunkmanagers\", ())",
                    "+",
                    "+    return load_chunkmanagers(entrypoints)",
                    "+",
                    "+",
                    "+def load_chunkmanagers(",
                    "+    entrypoints: Sequence[EntryPoint],",
                    "+) -> dict[str, ChunkManagerEntrypoint]:",
                    "+    \"\"\"Load entrypoints and instantiate chunkmanagers only once.\"\"\"",
                    "+",
                    "+    loaded_entrypoints = {",
                    "+        entrypoint.name: entrypoint.load() for entrypoint in entrypoints",
                    "+    }",
                    "+",
                    "+    available_chunkmanagers = {",
                    "+        name: chunkmanager()",
                    "+        for name, chunkmanager in loaded_entrypoints.items()",
                    "+        if chunkmanager.available",
                    "+    }",
                    "+    return available_chunkmanagers",
                    "+",
                    "+",
                    "+def guess_chunkmanager(",
                    "+    manager: str | ChunkManagerEntrypoint | None,",
                    "+) -> ChunkManagerEntrypoint:",
                    "+    \"\"\"",
                    "+    Get namespace of chunk-handling methods, guessing from what's available.",
                    "+",
                    "+    If the name of a specific ChunkManager is given (e.g. \"dask\"), then use that.",
                    "+    Else use whatever is installed, defaulting to dask if there are multiple options.",
                    "+    \"\"\"",
                    "+",
                    "+    chunkmanagers = list_chunkmanagers()",
                    "+",
                    "+    if manager is None:",
                    "+        if len(chunkmanagers) == 1:",
                    "+            # use the only option available",
                    "+            manager = next(iter(chunkmanagers.keys()))",
                    "+        else:",
                    "+            # default to trying to use dask",
                    "+            manager = \"dask\"",
                    "+",
                    "+    if isinstance(manager, str):",
                    "+        if manager not in chunkmanagers:",
                    "+            raise ValueError(",
                    "+                f\"unrecognized chunk manager {manager} - must be one of: {list(chunkmanagers)}\"",
                    "+            )",
                    "+",
                    "+        return chunkmanagers[manager]",
                    "+    elif isinstance(manager, ChunkManagerEntrypoint):",
                    "+        # already a valid ChunkManager so just pass through",
                    "+        return manager",
                    "+    else:",
                    "+        raise TypeError(",
                    "+            f\"manager must be a string or instance of ChunkManagerEntrypoint, but received type {type(manager)}\"",
                    "+        )",
                    "+",
                    "+",
                    "+def get_chunked_array_type(*args) -> ChunkManagerEntrypoint:",
                    "+    \"\"\"",
                    "+    Detects which parallel backend should be used for given set of arrays.",
                    "+",
                    "+    Also checks that all arrays are of same chunking type (i.e. not a mix of cubed and dask).",
                    "+    \"\"\"",
                    "+",
                    "+    # TODO this list is probably redundant with something inside xarray.apply_ufunc",
                    "+    ALLOWED_NON_CHUNKED_TYPES = {int, float, np.ndarray}",
                    "+",
                    "+    chunked_arrays = [",
                    "+        a",
                    "+        for a in args",
                    "+        if is_chunked_array(a) and type(a) not in ALLOWED_NON_CHUNKED_TYPES",
                    "+    ]",
                    "+",
                    "+    # Asserts all arrays are the same type (or numpy etc.)",
                    "+    chunked_array_types = {type(a) for a in chunked_arrays}",
                    "+    if len(chunked_array_types) > 1:",
                    "+        raise TypeError(",
                    "+            f\"Mixing chunked array types is not supported, but received multiple types: {chunked_array_types}\"",
                    "+        )",
                    "+    elif len(chunked_array_types) == 0:",
                    "+        raise TypeError(\"Expected a chunked array but none were found\")",
                    "+",
                    "+    # iterate over defined chunk managers, seeing if each recognises this array type",
                    "+    chunked_arr = chunked_arrays[0]",
                    "+    chunkmanagers = list_chunkmanagers()",
                    "+    selected = [",
                    "+        chunkmanager",
                    "+        for chunkmanager in chunkmanagers.values()",
                    "+        if chunkmanager.is_chunked_array(chunked_arr)",
                    "+    ]",
                    "+    if not selected:",
                    "+        raise TypeError(",
                    "+            f\"Could not find a Chunk Manager which recognises type {type(chunked_arr)}\"",
                    "+        )",
                    "+    elif len(selected) >= 2:",
                    "+        raise TypeError(f\"Multiple ChunkManagers recognise type {type(chunked_arr)}\")",
                    "+    else:",
                    "+        return selected[0]",
                    "+",
                    "+",
                    "+class ChunkManagerEntrypoint(ABC, Generic[T_ChunkedArray]):",
                    "+    \"\"\"",
                    "+    Adapter between a particular parallel computing framework and xarray.",
                    "+",
                    "+    Attributes",
                    "+    ----------",
                    "+    array_cls",
                    "+        Type of the array class this parallel computing framework provides.",
                    "+",
                    "+        Parallel frameworks need to provide an array class that supports the array API standard.",
                    "+        Used for type checking.",
                    "+    \"\"\"",
                    "+",
                    "+    array_cls: type[T_ChunkedArray]",
                    "+    available: bool = True",
                    "+",
                    "+    @abstractmethod",
                    "+    def __init__(self) -> None:",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def is_chunked_array(self, data: Any) -> bool:",
                    "+        return isinstance(data, self.array_cls)",
                    "+",
                    "+    @abstractmethod",
                    "+    def chunks(self, data: T_ChunkedArray) -> T_NormalizedChunks:",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    @abstractmethod",
                    "+    def normalize_chunks(",
                    "+        self,",
                    "+        chunks: T_Chunks | T_NormalizedChunks,",
                    "+        shape: tuple[int, ...] | None = None,",
                    "+        limit: int | None = None,",
                    "+        dtype: np.dtype | None = None,",
                    "+        previous_chunks: T_NormalizedChunks | None = None,",
                    "+    ) -> T_NormalizedChunks:",
                    "+        \"\"\"Called by open_dataset\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    @abstractmethod",
                    "+    def from_array(",
                    "+        self, data: np.ndarray, chunks: T_Chunks, **kwargs",
                    "+    ) -> T_ChunkedArray:",
                    "+        \"\"\"Called when .chunk is called on an xarray object that is not already chunked.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def rechunk(",
                    "+        self,",
                    "+        data: T_ChunkedArray,",
                    "+        chunks: T_NormalizedChunks | tuple[int, ...] | T_Chunks,",
                    "+        **kwargs,",
                    "+    ) -> T_ChunkedArray:",
                    "+        \"\"\"Called when .chunk is called on an xarray object that is already chunked.\"\"\"",
                    "+        return data.rechunk(chunks, **kwargs)  # type: ignore[attr-defined]",
                    "+",
                    "+    @abstractmethod",
                    "+    def compute(self, *data: T_ChunkedArray, **kwargs) -> tuple[np.ndarray, ...]:",
                    "+        \"\"\"Used anytime something needs to computed, including multiple arrays at once.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    @property",
                    "+    def array_api(self) -> Any:",
                    "+        \"\"\"Return the array_api namespace following the python array API standard.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def reduction(",
                    "+        self,",
                    "+        arr: T_ChunkedArray,",
                    "+        func: Callable,",
                    "+        combine_func: Callable | None = None,",
                    "+        aggregate_func: Callable | None = None,",
                    "+        axis: int | Sequence[int] | None = None,",
                    "+        dtype: np.dtype | None = None,",
                    "+        keepdims: bool = False,",
                    "+    ) -> T_ChunkedArray:",
                    "+        \"\"\"Used in some reductions like nanfirst, which is used by groupby.first\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    @abstractmethod",
                    "+    def apply_gufunc(",
                    "+        self,",
                    "+        func: Callable,",
                    "+        signature: str,",
                    "+        *args: Any,",
                    "+        axes: Sequence[tuple[int, ...]] | None = None,",
                    "+        keepdims: bool = False,",
                    "+        output_dtypes: Sequence[np.typing.DTypeLike] | None = None,",
                    "+        vectorize: bool | None = None,",
                    "+        **kwargs,",
                    "+    ):",
                    "+        \"\"\"",
                    "+        Called inside xarray.apply_ufunc, so must be supplied for vast majority of xarray computations to be supported.",
                    "+        \"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def map_blocks(",
                    "+        self,",
                    "+        func: Callable,",
                    "+        *args: Any,",
                    "+        dtype: np.typing.DTypeLike | None = None,",
                    "+        chunks: tuple[int, ...] | None = None,",
                    "+        drop_axis: int | Sequence[int] | None = None,",
                    "+        new_axis: int | Sequence[int] | None = None,",
                    "+        **kwargs,",
                    "+    ):",
                    "+        \"\"\"Called in elementwise operations, but notably not called in xarray.map_blocks.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def blockwise(",
                    "+        self,",
                    "+        func: Callable,",
                    "+        out_ind: Iterable,",
                    "+        *args: Any,  # can't type this as mypy assumes args are all same type, but dask blockwise args alternate types",
                    "+        adjust_chunks: dict[Any, Callable] | None = None,",
                    "+        new_axes: dict[Any, int] | None = None,",
                    "+        align_arrays: bool = True,",
                    "+        **kwargs,",
                    "+    ):",
                    "+        \"\"\"Called by some niche functions in xarray.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def unify_chunks(",
                    "+        self,",
                    "+        *args: Any,  # can't type this as mypy assumes args are all same type, but dask unify_chunks args alternate types",
                    "+        **kwargs,",
                    "+    ) -> tuple[dict[str, T_NormalizedChunks], list[T_ChunkedArray]]:",
                    "+        \"\"\"Called by xr.unify_chunks.\"\"\"",
                    "+        raise NotImplementedError()",
                    "+",
                    "+    def store(",
                    "+        self,",
                    "+        sources: T_ChunkedArray | Sequence[T_ChunkedArray],",
                    "+        targets: Any,",
                    "+        **kwargs: dict[str, Any],",
                    "+    ):",
                    "+        \"\"\"Used when writing to any backend.\"\"\"",
                    "+        raise NotImplementedError()"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "xarray/core/dataarray.py": [
            {
                "hunk": [
                    "+    from xarray.core.parallelcompat import ChunkManagerEntrypoint"
                ],
                "start_lineno": 80,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "+        chunked_array_type: str | ChunkManagerEntrypoint | None = None,",
                    "+        from_array_kwargs=None,"
                ],
                "start_lineno": 1267,
                "end_lineno": 1267
            },
            {
                "hunk": [
                    "-        lock : optional",
                    "+        lock : bool, default: False",
                    "             Passed on to :py:func:`dask.array.from_array`, if the array is not",
                    "             already as dask array.",
                    "-        inline_array: optional",
                    "+        inline_array: bool, default: False",
                    "             Passed on to :py:func:`dask.array.from_array`, if the array is not",
                    "             already as dask array.",
                    "+        chunked_array_type: str, optional",
                    "+            Which chunked array type to coerce the underlying data array to.",
                    "+            Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEntryPoint` system.",
                    "+            Experimental API that should not be relied upon.",
                    "+        from_array_kwargs: dict, optional",
                    "+            Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+            chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+            For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+            to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 1288,
                "end_lineno": 1293
            },
            {
                "hunk": [
                    "+            chunked_array_type=chunked_array_type,",
                    "+            from_array_kwargs=from_array_kwargs,"
                ],
                "start_lineno": 1331,
                "end_lineno": 1331
            }
        ],
        "xarray/core/dataset.py": [
            {
                "hunk": [
                    "+from xarray.core.daskmanager import DaskManager"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "-from xarray.core.pycompat import array_type, is_duck_array, is_duck_dask_array",
                    "+from xarray.core.parallelcompat import (",
                    "+    get_chunked_array_type,",
                    "+    guess_chunkmanager,",
                    "+)",
                    "+from xarray.core.pycompat import (",
                    "+    array_type,",
                    "+    is_chunked_array,",
                    "+    is_duck_array,",
                    "+    is_duck_dask_array,",
                    "+)"
                ],
                "start_lineno": 76,
                "end_lineno": 76
            },
            {
                "hunk": [
                    "+    from xarray.core.parallelcompat import ChunkManagerEntrypoint"
                ],
                "start_lineno": 110,
                "end_lineno": 110
            },
            {
                "hunk": [
                    "-def _get_chunk(var, chunks):",
                    "+def _get_chunk(var: Variable, chunks, chunkmanager: ChunkManagerEntrypoint):",
                    "     \"\"\"",
                    "     Return map from each dim to chunk sizes, accounting for backend's preferred chunks.",
                    "     \"\"\"",
                    " ",
                    "-    import dask.array as da",
                    "-"
                ],
                "start_lineno": 205,
                "end_lineno": 211
            },
            {
                "hunk": [
                    "-    chunk_shape = da.core.normalize_chunks(",
                    "+",
                    "+    chunk_shape = chunkmanager.normalize_chunks("
                ],
                "start_lineno": 228,
                "end_lineno": 228
            },
            {
                "hunk": [
                    "-                if isinstance(preferred_chunk_sizes, Number)",
                    "+                if isinstance(preferred_chunk_sizes, int)"
                ],
                "start_lineno": 245,
                "end_lineno": 245
            },
            {
                "hunk": [
                    "-                    \"The specified Dask chunks separate the stored chunks along \"",
                    "+                    \"The specified chunks separate the stored chunks along \""
                ],
                "start_lineno": 256,
                "end_lineno": 256
            },
            {
                "hunk": [
                    "+    chunked_array_type: str | ChunkManagerEntrypoint | None = None,",
                    "+    from_array_kwargs=None,",
                    " ):",
                    "-    from dask.base import tokenize",
                    "-",
                    "     if chunks is not None:",
                    "         chunks = {dim: chunks[dim] for dim in var.dims if dim in chunks}",
                    "+",
                    "     if var.ndim:",
                    "-        # when rechunking by different amounts, make sure dask names change",
                    "-        # by provinding chunks as an input to tokenize.",
                    "-        # subtle bugs result otherwise. see GH3350",
                    "-        token2 = tokenize(name, token if token else var._data, chunks)",
                    "-        name2 = f\"{name_prefix}{name}-{token2}\"",
                    "-        var = var.chunk(chunks, name=name2, lock=lock, inline_array=inline_array)",
                    "+        chunked_array_type = guess_chunkmanager(",
                    "+            chunked_array_type",
                    "+        )  # coerce string to ChunkManagerEntrypoint type",
                    "+        if isinstance(chunked_array_type, DaskManager):",
                    "+            from dask.base import tokenize",
                    "+",
                    "+            # when rechunking by different amounts, make sure dask names change",
                    "+            # by providing chunks as an input to tokenize.",
                    "+            # subtle bugs result otherwise. see GH3350",
                    "+            token2 = tokenize(name, token if token else var._data, chunks)",
                    "+            name2 = f\"{name_prefix}{name}-{token2}\"",
                    "+",
                    "+            from_array_kwargs = utils.consolidate_dask_from_array_kwargs(",
                    "+                from_array_kwargs,",
                    "+                name=name2,",
                    "+                lock=lock,",
                    "+                inline_array=inline_array,",
                    "+            )",
                    "+",
                    "+        var = var.chunk(",
                    "+            chunks,",
                    "+            chunked_array_type=chunked_array_type,",
                    "+            from_array_kwargs=from_array_kwargs,",
                    "+        )"
                ],
                "start_lineno": 273,
                "end_lineno": 284
            },
            {
                "hunk": [
                    "-            k: v._data for k, v in self.variables.items() if is_duck_dask_array(v._data)",
                    "+            k: v._data for k, v in self.variables.items() if is_chunked_array(v._data)",
                    "         }",
                    "         if lazy_data:",
                    "-            import dask.array as da",
                    "+            chunkmanager = get_chunked_array_type(*lazy_data.values())",
                    " ",
                    "-            # evaluate all the dask arrays simultaneously",
                    "-            evaluated_data = da.compute(*lazy_data.values(), **kwargs)",
                    "+            # evaluate all the chunked arrays simultaneously",
                    "+            evaluated_data = chunkmanager.compute(*lazy_data.values(), **kwargs)"
                ],
                "start_lineno": 746,
                "end_lineno": 752
            },
            {
                "hunk": [
                    "-            new_value[name] = val.astype(var_k.dtype, copy=False)",
                    "+            new_value[name] = duck_array_ops.astype(val, dtype=var_k.dtype, copy=False)"
                ],
                "start_lineno": 1578,
                "end_lineno": 1578
            },
            {
                "hunk": [
                    "+        chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1948,
                "end_lineno": 1948
            },
            {
                "hunk": [
                    "+        chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1969,
                "end_lineno": 1969
            },
            {
                "hunk": [
                    "+        chunkmanager_store_kwargs: dict[str, Any] | None = None,"
                ],
                "start_lineno": 1987,
                "end_lineno": 1987
            },
            {
                "hunk": [
                    "+        chunkmanager_store_kwargs : dict, optional",
                    "+            Additional keyword arguments passed on to the `ChunkManager.store` method used to store",
                    "+            chunked arrays. For example for a dask array additional kwargs will be passed eventually to",
                    "+            :py:func:`dask.array.store()`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 2075,
                "end_lineno": 2075
            },
            {
                "hunk": [
                    "+            chunkmanager_store_kwargs=chunkmanager_store_kwargs,"
                ],
                "start_lineno": 2120,
                "end_lineno": 2120
            },
            {
                "hunk": [
                    "+        chunked_array_type: str | ChunkManagerEntrypoint | None = None,",
                    "+        from_array_kwargs=None,"
                ],
                "start_lineno": 2208,
                "end_lineno": 2208
            },
            {
                "hunk": [
                    "+        chunked_array_type: str, optional",
                    "+            Which chunked array type to coerce this datasets' arrays to.",
                    "+            Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEnetryPoint` system.",
                    "+            Experimental API that should not be relied upon.",
                    "+        from_array_kwargs: dict, optional",
                    "+            Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+            chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+            For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+            to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 2235,
                "end_lineno": 2235
            },
            {
                "hunk": [
                    "+        chunkmanager = guess_chunkmanager(chunked_array_type)",
                    "+        if from_array_kwargs is None:",
                    "+            from_array_kwargs = {}",
                    "+",
                    "         variables = {",
                    "-            k: _maybe_chunk(k, v, chunks, token, lock, name_prefix)",
                    "+            k: _maybe_chunk(",
                    "+                k,",
                    "+                v,",
                    "+                chunks,",
                    "+                token,",
                    "+                lock,",
                    "+                name_prefix,",
                    "+                inline_array=inline_array,",
                    "+                chunked_array_type=chunkmanager,",
                    "+                from_array_kwargs=from_array_kwargs.copy(),",
                    "+            )"
                ],
                "start_lineno": 2269,
                "end_lineno": 2270
            },
            {
                "hunk": [
                    "-                        v = v.astype(\"datetime64[ns]\")",
                    "+                        v = duck_array_ops.astype(v, dtype=\"datetime64[ns]\")"
                ],
                "start_lineno": 2308,
                "end_lineno": 2308
            }
        ],
        "xarray/core/duck_array_ops.py": [
            {
                "hunk": [
                    "+from functools import partial"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "+from numpy.core.multiarray import normalize_axis_index  # type: ignore[attr-defined]",
                    " from numpy.lib.stride_tricks import sliding_window_view  # noqa",
                    " ",
                    " from xarray.core import dask_array_ops, dtypes, nputils",
                    "-from xarray.core.nputils import nanfirst, nanlast",
                    "+from xarray.core.parallelcompat import get_chunked_array_type, is_chunked_array"
                ],
                "start_lineno": 32,
                "end_lineno": 35
            },
            {
                "hunk": [
                    "-        if is_duck_dask_array(values):",
                    "-            return dask_array_ops.nanfirst(values, axis)",
                    "+        if is_chunked_array(values):",
                    "+            return chunked_nanfirst(values, axis)",
                    "         else:",
                    "-            return nanfirst(values, axis)",
                    "+            return nputils.nanfirst(values, axis)"
                ],
                "start_lineno": 643,
                "end_lineno": 646
            },
            {
                "hunk": [
                    "-        if is_duck_dask_array(values):",
                    "-            return dask_array_ops.nanlast(values, axis)",
                    "+        if is_chunked_array(values):",
                    "+            return chunked_nanlast(values, axis)",
                    "         else:",
                    "-            return nanlast(values, axis)",
                    "+            return nputils.nanlast(values, axis)"
                ],
                "start_lineno": 654,
                "end_lineno": 657
            },
            {
                "hunk": [
                    "+",
                    "+",
                    "+def _first_last_wrapper(array, *, axis, op, keepdims):",
                    "+    return op(array, axis, keepdims=keepdims)",
                    "+",
                    "+",
                    "+def _chunked_first_or_last(darray, axis, op):",
                    "+    chunkmanager = get_chunked_array_type(darray)",
                    "+",
                    "+    # This will raise the same error message seen for numpy",
                    "+    axis = normalize_axis_index(axis, darray.ndim)",
                    "+",
                    "+    wrapped_op = partial(_first_last_wrapper, op=op)",
                    "+    return chunkmanager.reduction(",
                    "+        darray,",
                    "+        func=wrapped_op,",
                    "+        aggregate_func=wrapped_op,",
                    "+        axis=axis,",
                    "+        dtype=darray.dtype,",
                    "+        keepdims=False,  # match numpy version",
                    "+    )",
                    "+",
                    "+",
                    "+def chunked_nanfirst(darray, axis):",
                    "+    return _chunked_first_or_last(darray, axis, op=nputils.nanfirst)",
                    "+",
                    "+",
                    "+def chunked_nanlast(darray, axis):",
                    "+    return _chunked_first_or_last(darray, axis, op=nputils.nanlast)"
                ],
                "start_lineno": 676,
                "end_lineno": 676
            }
        ],
        "xarray/core/indexing.py": [
            {
                "hunk": [
                    "+from xarray.core.parallelcompat import get_chunked_array_type, is_chunked_array"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-def _dask_array_with_chunks_hint(array, chunks):",
                    "-    \"\"\"Create a dask array using the chunks hint for dimensions of size > 1.\"\"\"",
                    "-    import dask.array as da",
                    "+def _chunked_array_with_chunks_hint(array, chunks, chunkmanager):",
                    "+    \"\"\"Create a chunked array using the chunks hint for dimensions of size > 1.\"\"\"",
                    " ",
                    "     if len(chunks) < array.ndim:",
                    "         raise ValueError(\"not enough chunks in hint\")",
                    "     new_chunks = []",
                    "     for chunk, size in zip(chunks, array.shape):",
                    "         new_chunks.append(chunk if size > 1 else (1,))",
                    "-    return da.from_array(array, new_chunks)",
                    "+    return chunkmanager.from_array(array, new_chunks)"
                ],
                "start_lineno": 1145,
                "end_lineno": 1154
            },
            {
                "hunk": [
                    "-            if is_duck_dask_array(data):",
                    "-                new_keys.append(_dask_array_with_chunks_hint(k, chunks_hint))",
                    "+            if is_chunked_array(data):",
                    "+                chunkmanager = get_chunked_array_type(data)",
                    "+                new_keys.append(",
                    "+                    _chunked_array_with_chunks_hint(k, chunks_hint, chunkmanager)",
                    "+                )"
                ],
                "start_lineno": 1168,
                "end_lineno": 1169
            }
        ],
        "xarray/core/missing.py": [
            {
                "hunk": [
                    "-from xarray.core.pycompat import is_duck_dask_array",
                    "+from xarray.core.parallelcompat import get_chunked_array_type, is_chunked_array"
                ],
                "start_lineno": 18,
                "end_lineno": 18
            },
            {
                "hunk": [
                    "-    if is_duck_dask_array(var):",
                    "-        import dask.array as da",
                    "+    if is_chunked_array(var):",
                    "+        chunkmanager = get_chunked_array_type(var)"
                ],
                "start_lineno": 696,
                "end_lineno": 697
            },
            {
                "hunk": [
                    "-        _, rechunked = da.unify_chunks(*args)",
                    "+        _, rechunked = chunkmanager.unify_chunks(*args)"
                ],
                "start_lineno": 719,
                "end_lineno": 719
            },
            {
                "hunk": [
                    "-        return da.blockwise(",
                    "-            _dask_aware_interpnd,",
                    "+        return chunkmanager.blockwise(",
                    "+            _chunked_aware_interpnd,"
                ],
                "start_lineno": 744,
                "end_lineno": 745
            },
            {
                "hunk": [
                    "-def _dask_aware_interpnd(var, *coords, interp_func, interp_kwargs, localize=True):",
                    "-    \"\"\"Wrapper for `_interpnd` through `blockwise`",
                    "+def _chunked_aware_interpnd(var, *coords, interp_func, interp_kwargs, localize=True):",
                    "+    \"\"\"Wrapper for `_interpnd` through `blockwise` for chunked arrays."
                ],
                "start_lineno": 788,
                "end_lineno": 789
            }
        ],
        "xarray/core/nanops.py": [
            {
                "hunk": [
                    "+    astype,"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-        result = where(null_mask, fill_value, result.astype(dtype))",
                    "+        result = where(null_mask, fill_value, astype(result, dtype))"
                ],
                "start_lineno": 25,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "-    squared = (value.astype(value_mean.dtype) - value_mean) ** 2",
                    "+    squared = (astype(value, value_mean.dtype) - value_mean) ** 2"
                ],
                "start_lineno": 143,
                "end_lineno": 143
            }
        ],
        "xarray/core/pycompat.py": [
            {
                "hunk": [
                    "-    ModType = Literal[\"dask\", \"pint\", \"cupy\", \"sparse\"]",
                    "+    ModType = Literal[\"dask\", \"pint\", \"cupy\", \"sparse\", \"cubed\"]"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-        duck_array_module: ModuleType | None = None",
                    "+        duck_array_module: ModuleType | None"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            },
            {
                "hunk": [
                    "+            elif mod == \"cubed\":",
                    "+                duck_array_type = (duck_array_module.Array,)"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            },
            {
                "hunk": [
                    "+def is_chunked_array(x) -> bool:",
                    "+    return is_duck_dask_array(x) or (is_duck_array(x) and hasattr(x, \"chunks\"))",
                    "+",
                    "+"
                ],
                "start_lineno": 84,
                "end_lineno": 84
            }
        ],
        "xarray/core/rolling.py": [
            {
                "hunk": [
                    "-        result = self.sum(keep_attrs=False, **kwargs) / self.count(",
                    "-            keep_attrs=False",
                    "-        ).astype(self.obj.dtype, copy=False)",
                    "+        result = self.sum(keep_attrs=False, **kwargs) / duck_array_ops.astype(",
                    "+            self.count(keep_attrs=False), dtype=self.obj.dtype, copy=False",
                    "+        )"
                ],
                "start_lineno": 161,
                "end_lineno": 163
            }
        ],
        "xarray/core/types.py": [
            {
                "hunk": [
                    "+    try:",
                    "+        from cubed import Array as CubedArray",
                    "+    except ImportError:",
                    "+        CubedArray = np.ndarray",
                    "+",
                    "+    try:",
                    "+        from zarr.core import Array as ZarrArray",
                    "+    except ImportError:",
                    "+        ZarrArray = np.ndarray",
                    "+"
                ],
                "start_lineno": 36,
                "end_lineno": 36
            },
            {
                "hunk": [
                    "+T_Chunks = Union[int, dict[Any, Any], Literal[\"auto\"], None]",
                    "+T_NormalizedChunks = tuple[tuple[int, ...], ...]",
                    "+"
                ],
                "start_lineno": 108,
                "end_lineno": 108
            }
        ],
        "xarray/core/utils.py": [
            {
                "hunk": [
                    "+",
                    "+",
                    "+def consolidate_dask_from_array_kwargs(",
                    "+    from_array_kwargs: dict,",
                    "+    name: str | None = None,",
                    "+    lock: bool | None = None,",
                    "+    inline_array: bool | None = None,",
                    "+) -> dict:",
                    "+    \"\"\"",
                    "+    Merge dask-specific kwargs with arbitrary from_array_kwargs dict.",
                    "+",
                    "+    Temporary function, to be deleted once explicitly passing dask-specific kwargs to .chunk() is deprecated.",
                    "+    \"\"\"",
                    "+",
                    "+    from_array_kwargs = _resolve_doubly_passed_kwarg(",
                    "+        from_array_kwargs,",
                    "+        kwarg_name=\"name\",",
                    "+        passed_kwarg_value=name,",
                    "+        default=None,",
                    "+        err_msg_dict_name=\"from_array_kwargs\",",
                    "+    )",
                    "+    from_array_kwargs = _resolve_doubly_passed_kwarg(",
                    "+        from_array_kwargs,",
                    "+        kwarg_name=\"lock\",",
                    "+        passed_kwarg_value=lock,",
                    "+        default=False,",
                    "+        err_msg_dict_name=\"from_array_kwargs\",",
                    "+    )",
                    "+    from_array_kwargs = _resolve_doubly_passed_kwarg(",
                    "+        from_array_kwargs,",
                    "+        kwarg_name=\"inline_array\",",
                    "+        passed_kwarg_value=inline_array,",
                    "+        default=False,",
                    "+        err_msg_dict_name=\"from_array_kwargs\",",
                    "+    )",
                    "+",
                    "+    return from_array_kwargs",
                    "+",
                    "+",
                    "+def _resolve_doubly_passed_kwarg(",
                    "+    kwargs_dict: dict,",
                    "+    kwarg_name: str,",
                    "+    passed_kwarg_value: str | bool | None,",
                    "+    default: bool | None,",
                    "+    err_msg_dict_name: str,",
                    "+) -> dict:",
                    "+    # if in kwargs_dict but not passed explicitly then just pass kwargs_dict through unaltered",
                    "+    if kwarg_name in kwargs_dict and passed_kwarg_value is None:",
                    "+        pass",
                    "+    # if passed explicitly but not in kwargs_dict then use that",
                    "+    elif kwarg_name not in kwargs_dict and passed_kwarg_value is not None:",
                    "+        kwargs_dict[kwarg_name] = passed_kwarg_value",
                    "+    # if in neither then use default",
                    "+    elif kwarg_name not in kwargs_dict and passed_kwarg_value is None:",
                    "+        kwargs_dict[kwarg_name] = default",
                    "+    # if in both then raise",
                    "+    else:",
                    "+        raise ValueError(",
                    "+            f\"argument {kwarg_name} cannot be passed both as a keyword argument and within \"",
                    "+            f\"the {err_msg_dict_name} dictionary\"",
                    "+        )",
                    "+",
                    "+    return kwargs_dict"
                ],
                "start_lineno": 1205,
                "end_lineno": 1205
            }
        ],
        "xarray/core/variable.py": [
            {
                "hunk": [
                    "+from xarray.core.parallelcompat import (",
                    "+    get_chunked_array_type,",
                    "+    guess_chunkmanager,",
                    "+)",
                    " from xarray.core.pycompat import (",
                    "     array_type,",
                    "     integer_types,",
                    "     is_0d_dask_array,",
                    "+    is_chunked_array,"
                ],
                "start_lineno": 29,
                "end_lineno": 32
            },
            {
                "hunk": [
                    "+    from xarray.core.parallelcompat import ChunkManagerEntrypoint"
                ],
                "start_lineno": 57,
                "end_lineno": 57
            },
            {
                "hunk": [
                    "-        return data.astype(nanosecond_precision_dtype)",
                    "+        return duck_array_ops.astype(data, nanosecond_precision_dtype)",
                    "     elif dtype.kind == \"m\" and dtype != np.dtype(\"timedelta64[ns]\"):",
                    "         utils.emit_user_level_warning(NON_NANOSECOND_WARNING.format(case=\"timedelta\"))",
                    "-        return data.astype(\"timedelta64[ns]\")",
                    "+        return duck_array_ops.astype(data, \"timedelta64[ns]\")"
                ],
                "start_lineno": 197,
                "end_lineno": 200
            },
            {
                "hunk": [
                    "-    def dtype(self):",
                    "+    def dtype(self) -> np.dtype:"
                ],
                "start_lineno": 371,
                "end_lineno": 371
            },
            {
                "hunk": [
                    "-    def shape(self):",
                    "+    def shape(self) -> tuple[int, ...]:"
                ],
                "start_lineno": 383,
                "end_lineno": 383
            },
            {
                "hunk": [
                    "-        if is_duck_dask_array(self._data):",
                    "-            self._data = as_compatible_data(self._data.compute(**kwargs))",
                    "+        if is_chunked_array(self._data):",
                    "+            chunkmanager = get_chunked_array_type(self._data)",
                    "+            loaded_data, *_ = chunkmanager.compute(self._data, **kwargs)",
                    "+            self._data = as_compatible_data(loaded_data)"
                ],
                "start_lineno": 536,
                "end_lineno": 537
            },
            {
                "hunk": [
                    "-        lock: bool = False,",
                    "-        inline_array: bool = False,",
                    "+        lock: bool | None = None,",
                    "+        inline_array: bool | None = None,",
                    "+        chunked_array_type: str | ChunkManagerEntrypoint | None = None,",
                    "+        from_array_kwargs=None,"
                ],
                "start_lineno": 1169,
                "end_lineno": 1170
            },
            {
                "hunk": [
                    "-        lock : optional",
                    "+        lock : bool, default: False",
                    "             Passed on to :py:func:`dask.array.from_array`, if the array is not",
                    "             already as dask array.",
                    "-        inline_array: optional",
                    "+        inline_array : bool, default: False",
                    "             Passed on to :py:func:`dask.array.from_array`, if the array is not",
                    "             already as dask array.",
                    "+        chunked_array_type: str, optional",
                    "+            Which chunked array type to coerce this datasets' arrays to.",
                    "+            Defaults to 'dask' if installed, else whatever is registered via the `ChunkManagerEntrypoint` system.",
                    "+            Experimental API that should not be relied upon.",
                    "+        from_array_kwargs: dict, optional",
                    "+            Additional keyword arguments passed on to the `ChunkManagerEntrypoint.from_array` method used to create",
                    "+            chunked arrays, via whichever chunk manager is specified through the `chunked_array_type` kwarg.",
                    "+            For example, with dask as the default chunked array type, this method would pass additional kwargs",
                    "+            to :py:func:`dask.array.from_array`. Experimental API that should not be relied upon."
                ],
                "start_lineno": 1191,
                "end_lineno": 1196
            },
            {
                "hunk": [
                    "-        import dask.array as da"
                ],
                "start_lineno": 1212,
                "end_lineno": 1212
            },
            {
                "hunk": [
                    "+            # TODO we shouldn't assume here that other chunkmanagers can handle these types",
                    "+            # TODO should we call normalize_chunks here?"
                ],
                "start_lineno": 1223,
                "end_lineno": 1223
            },
            {
                "hunk": [
                    "+        chunkmanager = guess_chunkmanager(chunked_array_type)",
                    "+",
                    "+        if from_array_kwargs is None:",
                    "+            from_array_kwargs = {}",
                    "+",
                    "+        # TODO deprecate passing these dask-specific arguments explicitly. In future just pass everything via from_array_kwargs",
                    "+        _from_array_kwargs = utils.consolidate_dask_from_array_kwargs(",
                    "+            from_array_kwargs,",
                    "+            name=name,",
                    "+            lock=lock,",
                    "+            inline_array=inline_array,",
                    "+        )",
                    "+",
                    "         data = self._data",
                    "-        if is_duck_dask_array(data):",
                    "-            data = data.rechunk(chunks)",
                    "+        if chunkmanager.is_chunked_array(data):",
                    "+            data = chunkmanager.rechunk(data, chunks)  # type: ignore[arg-type]"
                ],
                "start_lineno": 1230,
                "end_lineno": 1232
            },
            {
                "hunk": [
                    "-                # All of our lazily loaded backend array classes should use NumPy",
                    "-                # array operations.",
                    "-                kwargs = {\"meta\": np.ndarray}",
                    "-            else:",
                    "-                kwargs = {}",
                    "-",
                    "             if utils.is_dict_like(chunks):",
                    "-                chunks = tuple(chunks.get(n, s) for n, s in enumerate(self.shape))",
                    "+                chunks = tuple(chunks.get(n, s) for n, s in enumerate(data.shape))",
                    " ",
                    "-            data = da.from_array(",
                    "-                data, chunks, name=name, lock=lock, inline_array=inline_array, **kwargs",
                    "+            data = chunkmanager.from_array(",
                    "+                data,",
                    "+                chunks,  # type: ignore[arg-type]",
                    "+                **_from_array_kwargs,"
                ],
                "start_lineno": 1247,
                "end_lineno": 1257
            },
            {
                "hunk": [
                    "-            data = data.compute()",
                    "+            chunkmanager = get_chunked_array_type(data)",
                    "+            data, *_ = chunkmanager.compute(data)"
                ],
                "start_lineno": 1269,
                "end_lineno": 1269
            },
            {
                "hunk": [
                    "-    def chunk(self, chunks={}, name=None, lock=False, inline_array=False):",
                    "+    def chunk(",
                    "+        self,",
                    "+        chunks={},",
                    "+        name=None,",
                    "+        lock=False,",
                    "+        inline_array=False,",
                    "+        chunked_array_type=None,",
                    "+        from_array_kwargs=None,",
                    "+    ):"
                ],
                "start_lineno": 2906,
                "end_lineno": 2906
            }
        ],
        "xarray/core/weighted.py": [
            {
                "hunk": [
                    "-                mask, self.weights.astype(int), dim=dim, skipna=False",
                    "+                mask,",
                    "+                duck_array_ops.astype(self.weights, dtype=int),",
                    "+                dim=dim,",
                    "+                skipna=False,"
                ],
                "start_lineno": 241,
                "end_lineno": 241
            }
        ]
    },
    "scikit-learn__scikit-learn-10508": {
        "sklearn/preprocessing/label.py": [
            {
                "hunk": [
                    "+        # transform of empty array is empty array",
                    "+        if _num_samples(y) == 0:",
                    "+            return np.array([])"
                ],
                "start_lineno": 129,
                "end_lineno": 129
            },
            {
                "hunk": [
                    "+        y = column_or_1d(y, warn=True)",
                    "+        # inverse transform of empty array is empty array",
                    "+        if _num_samples(y) == 0:",
                    "+            return np.array([])"
                ],
                "start_lineno": 150,
                "end_lineno": 150
            }
        ]
    },
    "pylint-dev__pylint-4551": {
        "pylint/pyreverse/diagrams.py": [
            {
                "hunk": [
                    "-                isinstance(node, astroid.ClassDef)",
                    "+                isinstance(node, (astroid.ClassDef, astroid.Name, astroid.Subscript))"
                ],
                "start_lineno": 125,
                "end_lineno": 125
            }
        ],
        "pylint/pyreverse/inspector.py": [
            {
                "hunk": [
                    "-        try:",
                    "-            if not hasattr(frame, \"locals_type\"):",
                    "-                # If the frame doesn't have a locals_type yet,",
                    "-                # it means it wasn't yet visited. Visit it now",
                    "-                # to add what's missing from it.",
                    "-                if isinstance(frame, astroid.ClassDef):",
                    "-                    self.visit_classdef(frame)",
                    "-                elif isinstance(frame, astroid.FunctionDef):",
                    "-                    self.visit_functiondef(frame)",
                    "-                else:",
                    "-                    self.visit_module(frame)",
                    "-",
                    "-            current = frame.locals_type[node.name]",
                    "-            values = set(node.infer())",
                    "-            frame.locals_type[node.name] = list(set(current) | values)",
                    "-        except astroid.InferenceError:",
                    "-            pass",
                    "+        if not hasattr(frame, \"locals_type\"):",
                    "+            # If the frame doesn't have a locals_type yet,",
                    "+            # it means it wasn't yet visited. Visit it now",
                    "+            # to add what's missing from it.",
                    "+            if isinstance(frame, astroid.ClassDef):",
                    "+                self.visit_classdef(frame)",
                    "+            elif isinstance(frame, astroid.FunctionDef):",
                    "+                self.visit_functiondef(frame)",
                    "+            else:",
                    "+                self.visit_module(frame)",
                    "+",
                    "+        current = frame.locals_type[node.name]",
                    "+        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))"
                ],
                "start_lineno": 208,
                "end_lineno": 224
            },
            {
                "hunk": [
                    "-        try:",
                    "-            values = set(node.infer())",
                    "-            current = set(parent.instance_attrs_type[node.attrname])",
                    "-            parent.instance_attrs_type[node.attrname] = list(current | values)",
                    "-        except astroid.InferenceError:",
                    "-            pass",
                    "+        current = set(parent.instance_attrs_type[node.attrname])",
                    "+        parent.instance_attrs_type[node.attrname] = list(",
                    "+            current | utils.infer_node(node)",
                    "+        )"
                ],
                "start_lineno": 232,
                "end_lineno": 237
            }
        ],
        "pylint/pyreverse/utils.py": [
            {
                "hunk": [
                    "+from typing import Optional, Union",
                    "+",
                    "+import astroid"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "+",
                    "+",
                    "+def get_annotation_label(ann: Union[astroid.Name, astroid.Subscript]) -> str:",
                    "+    label = \"\"",
                    "+    if isinstance(ann, astroid.Subscript):",
                    "+        label = ann.as_string()",
                    "+    elif isinstance(ann, astroid.Name):",
                    "+        label = ann.name",
                    "+    return label",
                    "+",
                    "+",
                    "+def get_annotation(",
                    "+    node: Union[astroid.AssignAttr, astroid.AssignName]",
                    "+) -> Optional[Union[astroid.Name, astroid.Subscript]]:",
                    "+    \"\"\"return the annotation for `node`\"\"\"",
                    "+    ann = None",
                    "+    if isinstance(node.parent, astroid.AnnAssign):",
                    "+        ann = node.parent.annotation",
                    "+    elif isinstance(node, astroid.AssignAttr):",
                    "+        init_method = node.parent.parent",
                    "+        try:",
                    "+            annotations = dict(zip(init_method.locals, init_method.args.annotations))",
                    "+            ann = annotations.get(node.parent.value.name)",
                    "+        except AttributeError:",
                    "+            pass",
                    "+    else:",
                    "+        return ann",
                    "+",
                    "+    try:",
                    "+        default, *_ = node.infer()",
                    "+    except astroid.InferenceError:",
                    "+        default = \"\"",
                    "+",
                    "+    label = get_annotation_label(ann)",
                    "+    if ann:",
                    "+        label = (",
                    "+            rf\"Optional[{label}]\"",
                    "+            if getattr(default, \"value\", \"value\") is None",
                    "+            and not label.startswith(\"Optional\")",
                    "+            else label",
                    "+        )",
                    "+    if label:",
                    "+        ann.name = label",
                    "+    return ann",
                    "+",
                    "+",
                    "+def infer_node(node: Union[astroid.AssignAttr, astroid.AssignName]) -> set:",
                    "+    \"\"\"Return a set containing the node annotation if it exists",
                    "+    otherwise return a set of the inferred types using the NodeNG.infer method\"\"\"",
                    "+",
                    "+    ann = get_annotation(node)",
                    "+    if ann:",
                    "+        return {ann}",
                    "+    try:",
                    "+        return set(node.infer())",
                    "+    except astroid.InferenceError:",
                    "+        return set()"
                ],
                "start_lineno": 216,
                "end_lineno": 216
            }
        ],
        "pylint/pyreverse/writer.py": [
            {
                "hunk": [
                    "-from pylint.pyreverse.utils import is_exception",
                    "+from pylint.pyreverse.utils import get_annotation_label, is_exception"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "+                return_type = (",
                    "+                    f\": {get_annotation_label(func.returns)}\" if func.returns else \"\"",
                    "+                )",
                    "+",
                    "                 if func.args.args:",
                    "-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]",
                    "+                    args = [arg for arg in func.args.args if arg.name != \"self\"]",
                    "                 else:",
                    "                     args = []",
                    "-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))",
                    "+",
                    "+                annotations = dict(zip(args, func.args.annotations[1:]))",
                    "+                for arg in args:",
                    "+                    annotation_label = \"\"",
                    "+                    ann = annotations.get(arg)",
                    "+                    if ann:",
                    "+                        annotation_label = get_annotation_label(ann)",
                    "+                    annotations[arg] = annotation_label",
                    "+",
                    "+                args = \", \".join(",
                    "+                    f\"{arg.name}: {ann}\" if ann else f\"{arg.name}\"",
                    "+                    for arg, ann in annotations.items()",
                    "+                )",
                    "+",
                    "+                label = fr\"{label}{func.name}({args}){return_type}\\l\""
                ],
                "start_lineno": 137,
                "end_lineno": 141
            }
        ]
    },
    "pytest-dev__pytest-7352": {
        "src/_pytest/pathlib.py": [
            {
                "hunk": [
                    "+import contextlib"
                ],
                "start_lineno": 2,
                "end_lineno": 2
            },
            {
                "hunk": [
                    "-            lock.unlink()",
                    "-            return True",
                    "-        else:",
                    "-            return False",
                    "+            # wa want to ignore any errors while trying to remove the lock such as:",
                    "+            # - PermissionDenied, like the file permissions have changed since the lock creation",
                    "+            # - FileNotFoundError, in case another pytest process got here first.",
                    "+            # and any other cause of failure.",
                    "+            with contextlib.suppress(OSError):",
                    "+                lock.unlink()",
                    "+                return True",
                    "+        return False"
                ],
                "start_lineno": 293,
                "end_lineno": 296
            }
        ]
    },
    "sympy__sympy-18605": {
        "sympy/tensor/indexed.py": [
            {
                "hunk": [
                    "-from sympy.core.logic import fuzzy_bool",
                    "+from sympy.core.logic import fuzzy_bool, fuzzy_not"
                ],
                "start_lineno": 114,
                "end_lineno": 114
            },
            {
                "hunk": [
                    "-            if not (range.is_integer or range is S.Infinity):",
                    "+            if range is not S.Infinity and fuzzy_not(range.is_integer):"
                ],
                "start_lineno": 666,
                "end_lineno": 666
            }
        ]
    },
    "django__django-15828": {
        "django/contrib/postgres/constraints.py": [
            {
                "hunk": [
                    "+                and self.violation_error_message == other.violation_error_message"
                ],
                "start_lineno": 180,
                "end_lineno": 180
            }
        ],
        "django/db/models/constraints.py": [
            {
                "hunk": [
                    "-    violation_error_message = _(\"Constraint \u201c%(name)s\u201d is violated.\")",
                    "+    default_violation_error_message = _(\"Constraint \u201c%(name)s\u201d is violated.\")",
                    "+    violation_error_message = None",
                    " ",
                    "     def __init__(self, name, violation_error_message=None):",
                    "         self.name = name",
                    "         if violation_error_message is not None:",
                    "             self.violation_error_message = violation_error_message",
                    "+        else:",
                    "+            self.violation_error_message = self.default_violation_error_message"
                ],
                "start_lineno": 17,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "-        return (path, (), {\"name\": self.name})",
                    "+        kwargs = {\"name\": self.name}",
                    "+        if (",
                    "+            self.violation_error_message is not None",
                    "+            and self.violation_error_message != self.default_violation_error_message",
                    "+        ):",
                    "+            kwargs[\"violation_error_message\"] = self.violation_error_message",
                    "+        return (path, (), kwargs)"
                ],
                "start_lineno": 46,
                "end_lineno": 46
            },
            {
                "hunk": [
                    "-            return self.name == other.name and self.check == other.check",
                    "+            return (",
                    "+                self.name == other.name",
                    "+                and self.check == other.check",
                    "+                and self.violation_error_message == other.violation_error_message",
                    "+            )"
                ],
                "start_lineno": 97,
                "end_lineno": 97
            },
            {
                "hunk": [
                    "+                and self.violation_error_message == other.violation_error_message"
                ],
                "start_lineno": 276,
                "end_lineno": 276
            }
        ]
    },
    "sympy__sympy-20264": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+            # special case for (1/x)^(-y) and (-1/-x)^(-y), issue 20252",
                    "+            if expr.base.is_Rational and \\",
                    "+                    expr.base.p*expr.base.q == abs(expr.base.q):",
                    "+                if expr.exp == -1:",
                    "+                    return r\"\\frac{1}{\\frac{%s}{%s}}\" % (expr.base.p, expr.base.q)",
                    "+                else:",
                    "+                    return r\"\\frac{1}{(\\frac{%s}{%s})^{%s}}\" % (expr.base.p, expr.base.q, abs(expr.exp))"
                ],
                "start_lineno": 647,
                "end_lineno": 647
            }
        ]
    },
    "django__django-12198": {
        "django/contrib/auth/__init__.py": [
            {
                "hunk": [
                    "+        backend_signature = inspect.signature(backend.authenticate)",
                    "         try:",
                    "-            inspect.getcallargs(backend.authenticate, request, **credentials)",
                    "+            backend_signature.bind(request, **credentials)"
                ],
                "start_lineno": 66,
                "end_lineno": 67
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-                try:",
                    "-                    inspect.getcallargs(annotation.get_group_by_cols, alias=alias)",
                    "-                except TypeError:",
                    "+                signature = inspect.signature(annotation.get_group_by_cols)",
                    "+                if 'alias' not in signature.parameters:"
                ],
                "start_lineno": 1919,
                "end_lineno": 1921
            }
        ],
        "django/template/base.py": [
            {
                "hunk": [
                    "+import inspect",
                    " import logging",
                    " import re",
                    " from enum import Enum",
                    "-from inspect import getcallargs, getfullargspec, unwrap"
                ],
                "start_lineno": 53,
                "end_lineno": 56
            },
            {
                "hunk": [
                    "-        func = unwrap(func)",
                    "+        func = inspect.unwrap(func)",
                    " ",
                    "-        args, _, _, defaults, _, _, _ = getfullargspec(func)",
                    "+        args, _, _, defaults, _, _, _ = inspect.getfullargspec(func)"
                ],
                "start_lineno": 710,
                "end_lineno": 712
            },
            {
                "hunk": [
                    "+                            signature = inspect.signature(current)",
                    "                             try:",
                    "-                                getcallargs(current)",
                    "+                                signature.bind()"
                ],
                "start_lineno": 860,
                "end_lineno": 861
            }
        ]
    },
    "pydata__xarray-6599": {
        "xarray/core/computation.py": [
            {
                "hunk": [
                    "-        if x.dtype.kind in \"mM\":",
                    "+        if x.dtype.kind == \"M\":",
                    "+            # datetimes"
                ],
                "start_lineno": 1936,
                "end_lineno": 1936
            },
            {
                "hunk": [
                    "+        elif x.dtype.kind == \"m\":",
                    "+            # timedeltas",
                    "+            return x.astype(float)"
                ],
                "start_lineno": 1944,
                "end_lineno": 1944
            }
        ]
    },
    "django__django-10914": {
        "django/conf/global_settings.py": [
            {
                "hunk": [
                    "-FILE_UPLOAD_PERMISSIONS = None",
                    "+FILE_UPLOAD_PERMISSIONS = 0o644"
                ],
                "start_lineno": 307,
                "end_lineno": 307
            }
        ]
    },
    "sympy__sympy-11831": {
        "sympy/sets/sets.py": [
            {
                "hunk": [
                    "+    def __bool__(self):",
                    "+        return all([bool(s) for s in self.args])",
                    "+",
                    "+    __nonzero__ = __bool__",
                    "+"
                ],
                "start_lineno": 668,
                "end_lineno": 668
            }
        ]
    },
    "django__django-15521": {
        "django/core/management/commands/makemessages.py": [
            {
                "hunk": [
                    "+def is_valid_locale(locale):",
                    "+    return re.match(r\"^[a-z]+$\", locale) or re.match(r\"^[a-z]+_[A-Z].*$\", locale)",
                    "+",
                    "+"
                ],
                "start_lineno": 43,
                "end_lineno": 43
            },
            {
                "hunk": [
                    "-                if \"-\" in locale:",
                    "-                    self.stdout.write(",
                    "-                        \"invalid locale %s, did you mean %s?\"",
                    "-                        % (",
                    "-                            locale,",
                    "-                            locale.replace(\"-\", \"_\"),",
                    "-                        ),",
                    "+                if not is_valid_locale(locale):",
                    "+                    # Try to guess what valid locale it could be",
                    "+                    # Valid examples are: en_GB, shi_Latn_MA and nl_NL-x-informal",
                    "+",
                    "+                    # Search for characters followed by a non character (i.e. separator)",
                    "+                    match = re.match(",
                    "+                        r\"^(?P<language>[a-zA-Z]+)\"",
                    "+                        r\"(?P<separator>[^a-zA-Z])\"",
                    "+                        r\"(?P<territory>.+)$\",",
                    "+                        locale,",
                    "                     )",
                    "+                    if match:",
                    "+                        locale_parts = match.groupdict()",
                    "+                        language = locale_parts[\"language\"].lower()",
                    "+                        territory = (",
                    "+                            locale_parts[\"territory\"][:2].upper()",
                    "+                            + locale_parts[\"territory\"][2:]",
                    "+                        )",
                    "+                        proposed_locale = f\"{language}_{territory}\"",
                    "+                    else:",
                    "+                        # It could be a language in uppercase",
                    "+                        proposed_locale = locale.lower()",
                    "+",
                    "+                    # Recheck if the proposed locale is valid",
                    "+                    if is_valid_locale(proposed_locale):",
                    "+                        self.stdout.write(",
                    "+                            \"invalid locale %s, did you mean %s?\"",
                    "+                            % (",
                    "+                                locale,",
                    "+                                proposed_locale,",
                    "+                            ),",
                    "+                        )",
                    "+                    else:",
                    "+                        self.stdout.write(\"invalid locale %s\" % locale)",
                    "+"
                ],
                "start_lineno": 430,
                "end_lineno": 437
            }
        ]
    },
    "django__django-12915": {
        "django/contrib/staticfiles/handlers.py": [
            {
                "hunk": [
                    "+from asgiref.sync import sync_to_async",
                    "+"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "+    async def get_response_async(self, request):",
                    "+        try:",
                    "+            return await sync_to_async(self.serve)(request)",
                    "+        except Http404 as e:",
                    "+            return await sync_to_async(response_for_exception)(request, e)",
                    "+"
                ],
                "start_lineno": 55,
                "end_lineno": 55
            }
        ]
    },
    "django__django-14313": {
        "django/contrib/admin/options.py": [
            {
                "hunk": [
                    "-        use_distinct = False",
                    "+        may_have_duplicates = False"
                ],
                "start_lineno": 1022,
                "end_lineno": 1022
            },
            {
                "hunk": [
                    "-            use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)",
                    "-",
                    "-        return queryset, use_distinct",
                    "+            may_have_duplicates |= any(",
                    "+                lookup_needs_distinct(self.opts, search_spec)",
                    "+                for search_spec in orm_lookups",
                    "+            )",
                    "+        return queryset, may_have_duplicates"
                ],
                "start_lineno": 1033,
                "end_lineno": 1035
            }
        ],
        "django/contrib/admin/views/main.py": [
            {
                "hunk": [
                    "-from django.db.models import F, Field, ManyToOneRel, OrderBy",
                    "+from django.db.models import Exists, F, Field, ManyToOneRel, OrderBy, OuterRef"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-        use_distinct = False",
                    "+        may_have_duplicates = False"
                ],
                "start_lineno": 125,
                "end_lineno": 125
            },
            {
                "hunk": [
                    "-                    use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)",
                    "+                    may_have_duplicates |= lookup_needs_distinct(self.lookup_opts, field_path)"
                ],
                "start_lineno": 160,
                "end_lineno": 160
            },
            {
                "hunk": [
                    "-                use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)",
                    "+                may_have_duplicates |= lookup_needs_distinct(self.lookup_opts, key)",
                    "             return (",
                    "-                filter_specs, bool(filter_specs), lookup_params, use_distinct,",
                    "+                filter_specs, bool(filter_specs), lookup_params, may_have_duplicates,"
                ],
                "start_lineno": 206,
                "end_lineno": 208
            },
            {
                "hunk": [
                    "-            filters_use_distinct,",
                    "+            filters_may_have_duplicates,"
                ],
                "start_lineno": 448,
                "end_lineno": 448
            },
            {
                "hunk": [
                    "-        if not qs.query.select_related:",
                    "-            qs = self.apply_select_related(qs)",
                    "-",
                    "-        # Set ordering.",
                    "-        ordering = self.get_ordering(request, qs)",
                    "-        qs = qs.order_by(*ordering)",
                    "-",
                    "         # Apply search results",
                    "-        qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)",
                    "+        qs, search_may_have_duplicates = self.model_admin.get_search_results(",
                    "+            request, qs, self.query,",
                    "+        )"
                ],
                "start_lineno": 475,
                "end_lineno": 483
            },
            {
                "hunk": [
                    "-        if filters_use_distinct | search_use_distinct:",
                    "-            return qs.distinct()",
                    "-        else:",
                    "-            return qs",
                    "+        if filters_may_have_duplicates | search_may_have_duplicates:",
                    "+            qs = qs.filter(pk=OuterRef('pk'))",
                    "+            qs = self.root_queryset.filter(Exists(qs))",
                    "+",
                    "+        # Set ordering.",
                    "+        ordering = self.get_ordering(request, qs)",
                    "+        qs = qs.order_by(*ordering)",
                    "+",
                    "+        if not qs.query.select_related:",
                    "+            qs = self.apply_select_related(qs)",
                    "+",
                    "+        return qs"
                ],
                "start_lineno": 491,
                "end_lineno": 494
            }
        ],
        "django/db/models/sql/compiler.py": [
            {
                "hunk": [
                    "+    @classmethod",
                    "+    def _expr_refs_base_model(cls, expr, base_model):",
                    "+        if isinstance(expr, Query):",
                    "+            return expr.model == base_model",
                    "+        if not hasattr(expr, 'get_source_expressions'):",
                    "+            return False",
                    "+        return any(",
                    "+            cls._expr_refs_base_model(source_expr, base_model)",
                    "+            for source_expr in expr.get_source_expressions()",
                    "+        )",
                    "+",
                    "+    @cached_property",
                    "+    def contains_self_reference_subquery(self):",
                    "+        return any(",
                    "+            self._expr_refs_base_model(expr, self.query.model)",
                    "+            for expr in chain(self.query.annotations.values(), self.query.where.children)",
                    "+        )",
                    "+"
                ],
                "start_lineno": 1455,
                "end_lineno": 1455
            },
            {
                "hunk": [
                    "-        if self.single_alias:",
                    "+        if self.single_alias and not self.contains_self_reference_subquery:"
                ],
                "start_lineno": 1469,
                "end_lineno": 1469
            }
        ]
    },
    "matplotlib__matplotlib-24627": {
        "lib/matplotlib/axes/_base.py": [
            {
                "hunk": [
                    "-        self._children = []",
                    "+        old_children, self._children = self._children, []",
                    "+        for chld in old_children:",
                    "+            chld.axes = chld.figure = None"
                ],
                "start_lineno": 1318,
                "end_lineno": 1318
            }
        ]
    },
    "pydata__xarray-4802": {
        "xarray/coding/variables.py": [
            {
                "hunk": [
                    "-                scale_factor = scale_factor.item()",
                    "+                scale_factor = np.asarray(scale_factor).item()",
                    "             if np.ndim(add_offset) > 0:",
                    "-                add_offset = add_offset.item()",
                    "+                add_offset = np.asarray(add_offset).item()"
                ],
                "start_lineno": 273,
                "end_lineno": 275
            }
        ]
    },
    "pytest-dev__pytest-10343": {
        "src/_pytest/warning_types.py": [
            {
                "hunk": [
                    "-",
                    "-    warnings.warn_explicit(",
                    "-        message,",
                    "-        type(message),",
                    "-        filename=filename,",
                    "-        module=module,",
                    "-        registry=mod_globals.setdefault(\"__warningregistry__\", {}),",
                    "-        lineno=lineno,",
                    "-    )",
                    "+    try:",
                    "+        warnings.warn_explicit(",
                    "+            message,",
                    "+            type(message),",
                    "+            filename=filename,",
                    "+            module=module,",
                    "+            registry=mod_globals.setdefault(\"__warningregistry__\", {}),",
                    "+            lineno=lineno,",
                    "+        )",
                    "+    except Warning as w:",
                    "+        # If warnings are errors (e.g. -Werror), location information gets lost, so we add it to the message.",
                    "+        raise type(w)(f\"{w}\\n at {filename}:{lineno}\") from None"
                ],
                "start_lineno": 161,
                "end_lineno": 169
            }
        ]
    },
    "sympy__sympy-13259": {
        "sympy/functions/elementary/hyperbolic.py": [
            {
                "hunk": [
                    "+from sympy.core.add import Add"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "+def _peeloff_ipi(arg):",
                    "+    \"\"\"",
                    "+    Split ARG into two parts, a \"rest\" and a multiple of I*pi/2.",
                    "+    This assumes ARG to be an Add.",
                    "+    The multiple of I*pi returned in the second position is always a Rational.",
                    "+",
                    "+    Examples",
                    "+    ========",
                    "+",
                    "+    >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel",
                    "+    >>> from sympy import pi, I",
                    "+    >>> from sympy.abc import x, y",
                    "+    >>> peel(x + I*pi/2)",
                    "+    (x, I*pi/2)",
                    "+    >>> peel(x + I*2*pi/3 + I*pi*y)",
                    "+    (x + I*pi*y + I*pi/6, I*pi/2)",
                    "+    \"\"\"",
                    "+    for a in Add.make_args(arg):",
                    "+        if a == S.Pi*S.ImaginaryUnit:",
                    "+            K = S.One",
                    "+            break",
                    "+        elif a.is_Mul:",
                    "+            K, p = a.as_two_terms()",
                    "+            if p == S.Pi*S.ImaginaryUnit and K.is_Rational:",
                    "+                break",
                    "+    else:",
                    "+        return arg, S.Zero",
                    "+",
                    "+    m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit",
                    "+    m2 = K*S.Pi*S.ImaginaryUnit - m1",
                    "+    return arg - m2, m2",
                    "+",
                    "+"
                ],
                "start_lineno": 36,
                "end_lineno": 36
            },
            {
                "hunk": [
                    "+            if arg.is_Add:",
                    "+                x, m = _peeloff_ipi(arg)",
                    "+                if m:",
                    "+                    return sinh(m)*cosh(x) + cosh(m)*sinh(x)",
                    "+"
                ],
                "start_lineno": 92,
                "end_lineno": 92
            },
            {
                "hunk": [
                    "+            if arg.is_Add:",
                    "+                x, m = _peeloff_ipi(arg)",
                    "+                if m:",
                    "+                    return cosh(m)*cosh(x) + sinh(m)*sinh(x)",
                    "+"
                ],
                "start_lineno": 246,
                "end_lineno": 246
            },
            {
                "hunk": [
                    "+            if arg.is_Add:",
                    "+                x, m = _peeloff_ipi(arg)",
                    "+                if m:",
                    "+                    tanhm = tanh(m)",
                    "+                    if tanhm is S.ComplexInfinity:",
                    "+                        return coth(x)",
                    "+                    else: # tanhm == 0",
                    "+                        return tanh(x)",
                    "+"
                ],
                "start_lineno": 401,
                "end_lineno": 401
            },
            {
                "hunk": [
                    "+            if arg.is_Add:",
                    "+                x, m = _peeloff_ipi(arg)",
                    "+                if m:",
                    "+                    cothm = coth(m)",
                    "+                    if cotm is S.ComplexInfinity:",
                    "+                        return coth(x)",
                    "+                    else: # cothm == 0",
                    "+                        return tanh(x)",
                    "+"
                ],
                "start_lineno": 533,
                "end_lineno": 533
            }
        ],
        "sympy/functions/elementary/trigonometric.py": [
            {
                "hunk": [
                    "-                tanx = tan(x)",
                    "                 if tanm is S.ComplexInfinity:",
                    "                     return -cot(x)",
                    "-                return (tanm + tanx)/(1 - tanm*tanx)",
                    "+                else: # tanm == 0",
                    "+                    return tan(x)"
                ],
                "start_lineno": 1021,
                "end_lineno": 1024
            },
            {
                "hunk": [
                    "-                if cotm == 0:",
                    "-                    return -tan(x)",
                    "-                cotx = cot(x)",
                    "                 if cotm is S.ComplexInfinity:",
                    "-                    return cotx",
                    "-                if cotm.is_Rational:",
                    "-                    return (cotm*cotx - 1) / (cotm + cotx)",
                    "-            return None",
                    "+                    return cot(x)",
                    "+                else: # cotm == 0",
                    "+                    return -tan(x)"
                ],
                "start_lineno": 1303,
                "end_lineno": 1310
            }
        ],
        "sympy/simplify/fu.py": [
            {
                "hunk": [
                    "-    cosh, sinh, tanh, coth, HyperbolicFunction)",
                    "+    cosh, sinh, tanh, coth, sech, csch, HyperbolicFunction)"
                ],
                "start_lineno": 198,
                "end_lineno": 198
            },
            {
                "hunk": [
                    "+        elif rv.func is sech:",
                    "+            return sec(a)",
                    "+        elif rv.func is csch:",
                    "+            return csc(a)/I"
                ],
                "start_lineno": 2052,
                "end_lineno": 2052
            },
            {
                "hunk": [
                    "-        a = rv.args[0].xreplace({d: S.One})",
                    "+        const, x = rv.args[0].as_independent(d, as_Add=True)",
                    "+        a = x.xreplace({d: S.One}) + const*I"
                ],
                "start_lineno": 2077,
                "end_lineno": 2077
            },
            {
                "hunk": [
                    "-            return 1/cosh(a)",
                    "+            return sech(a)",
                    "         elif rv.func is csc:",
                    "-            return I/sinh(a)",
                    "+            return csch(a)*I"
                ],
                "start_lineno": 2087,
                "end_lineno": 2089
            }
        ]
    },
    "pydata__xarray-3156": {
        "xarray/core/groupby.py": [
            {
                "hunk": [
                    "+            if len(group) == 0:",
                    "+                raise ValueError(\"{} must not be empty\".format(group.name))",
                    "+"
                ],
                "start_lineno": 235,
                "end_lineno": 235
            }
        ]
    },
    "sphinx-doc__sphinx-7889": {
        "sphinx/ext/autodoc/mock.py": [
            {
                "hunk": [
                    "-    def __getitem__(self, key: str) -> \"_MockObject\":",
                    "-        return _make_subclass(key, self.__display_name__, self.__class__)()",
                    "+    def __getitem__(self, key: Any) -> \"_MockObject\":",
                    "+        return _make_subclass(str(key), self.__display_name__, self.__class__)()"
                ],
                "start_lineno": 55,
                "end_lineno": 56
            }
        ]
    },
    "matplotlib__matplotlib-25624": {
        "lib/matplotlib/figure.py": [
            {
                "hunk": [
                    "-            self.set_layout_engine(None)",
                    "+            self.set_layout_engine('none')"
                ],
                "start_lineno": 3518,
                "end_lineno": 3518
            }
        ]
    },
    "django__django-14493": {
        "django/contrib/staticfiles/storage.py": [
            {
                "hunk": [
                    "+        substitutions = False"
                ],
                "start_lineno": 263,
                "end_lineno": 263
            }
        ]
    },
    "psf__requests-1888": {
        "requests/sessions.py": [
            {
                "hunk": [
                    "-from .utils import to_key_val_list, default_headers",
                    "+from .utils import to_key_val_list, default_headers, to_native_string"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-            prepared_request.url = url",
                    "+            prepared_request.url = to_native_string(url)"
                ],
                "start_lineno": 124,
                "end_lineno": 124
            }
        ]
    },
    "matplotlib__matplotlib-23111": {
        "lib/matplotlib/cbook/__init__.py": [
            {
                "hunk": [
                    "-        delta = np.spacing(value)",
                    "+        delta = abs(np.spacing(value))"
                ],
                "start_lineno": 2161,
                "end_lineno": 2161
            }
        ]
    },
    "mwaskom__seaborn-2457": {
        "seaborn/relational.py": [
            {
                "hunk": [
                    "-    units=None, estimator=\"mean\", ci=None, n_boot=1000, seed=None,",
                    "+    units=None, estimator=\"mean\", ci=\"deprecated\", n_boot=1000, seed=None,"
                ],
                "start_lineno": 610,
                "end_lineno": 610
            }
        ],
        "seaborn/utils.py": [
            {
                "hunk": [
                    "-    if ci is not None:",
                    "-        if ci == \"sd\":",
                    "+    if ci != \"deprecated\":",
                    "+        if ci is None:",
                    "+            errorbar = None",
                    "+        elif ci == \"sd\":",
                    "             errorbar = \"sd\"",
                    "-            msg = \"use `errorbar='sd'` for same effect.\"",
                    "         else:",
                    "             errorbar = (\"ci\", ci)",
                    "-            msg = f\"use `errorbar=('ci', {ci})` for same effect.\"",
                    "-        msg = f\"The `ci` parameter is deprecated; {msg}\"",
                    "+        msg = (",
                    "+            \"The `ci` parameter is deprecated; \"",
                    "+            f\"use `errorbar={repr(errorbar)}` for same effect.\"",
                    "+        )"
                ],
                "start_lineno": 718,
                "end_lineno": 725
            }
        ]
    },
    "django__django-13233": {
        "django/db/models/fields/files.py": [
            {
                "hunk": [
                    "+    def contribute_to_class(self, cls, name, **kwargs):",
                    "+        super().contribute_to_class(cls, name, **kwargs)",
                    "+        setattr(cls, self.attname, self.descriptor_class(self))",
                    "+"
                ],
                "start_lineno": 302,
                "end_lineno": 302
            }
        ]
    },
    "pydata__xarray-4827": {
        "xarray/core/combine.py": [
            {
                "hunk": [
                    "-    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\",
                    "-                    default: \"drop\"",
                    "+    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\",
                    "+                     \"override\"}, default: \"drop\"",
                    "         String indicating how to combine attrs of the objects being merged:",
                    " ",
                    "         - \"drop\": empty attrs on returned Dataset.",
                    "         - \"identical\": all attrs must be the same on every object.",
                    "         - \"no_conflicts\": attrs from all objects are combined, any that have",
                    "           the same name must also have the same value.",
                    "+        - \"drop_conflicts\": attrs from all objects are combined, any that have",
                    "+          the same name but different values are dropped."
                ],
                "start_lineno": 415,
                "end_lineno": 422
            },
            {
                "hunk": [
                    "-    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\",
                    "-                    default: \"drop\"",
                    "+    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\",
                    "+                     \"override\"}, default: \"drop\"",
                    "         String indicating how to combine attrs of the objects being merged:",
                    " ",
                    "         - \"drop\": empty attrs on returned Dataset.",
                    "         - \"identical\": all attrs must be the same on every object.",
                    "         - \"no_conflicts\": attrs from all objects are combined, any that have",
                    "           the same name must also have the same value.",
                    "+        - \"drop_conflicts\": attrs from all objects are combined, any that have",
                    "+          the same name but different values are dropped."
                ],
                "start_lineno": 628,
                "end_lineno": 635
            }
        ],
        "xarray/core/concat.py": [
            {
                "hunk": [
                    "-    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\",
                    "-                    default: \"override\"",
                    "+    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\",
                    "+                     \"override\"}, default: \"override\"",
                    "         String indicating how to combine attrs of the objects being merged:",
                    " ",
                    "         - \"drop\": empty attrs on returned Dataset.",
                    "         - \"identical\": all attrs must be the same on every object.",
                    "         - \"no_conflicts\": attrs from all objects are combined, any that have",
                    "           the same name must also have the same value.",
                    "+        - \"drop_conflicts\": attrs from all objects are combined, any that have",
                    "+          the same name but different values are dropped."
                ],
                "start_lineno": 145,
                "end_lineno": 152
            }
        ],
        "xarray/core/merge.py": [
            {
                "hunk": [
                    "-from .utils import Frozen, compat_dict_union, dict_equiv",
                    "+from .utils import Frozen, compat_dict_union, dict_equiv, equivalent"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            },
            {
                "hunk": [
                    "+    elif combine_attrs == \"drop_conflicts\":",
                    "+        result = {}",
                    "+        dropped_keys = set()",
                    "+        for attrs in variable_attrs:",
                    "+            result.update(",
                    "+                {",
                    "+                    key: value",
                    "+                    for key, value in attrs.items()",
                    "+                    if key not in result and key not in dropped_keys",
                    "+                }",
                    "+            )",
                    "+            result = {",
                    "+                key: value",
                    "+                for key, value in result.items()",
                    "+                if key not in attrs or equivalent(attrs[key], value)",
                    "+            }",
                    "+            dropped_keys |= {key for key in attrs if key not in result}",
                    "+        return result"
                ],
                "start_lineno": 516,
                "end_lineno": 516
            },
            {
                "hunk": [
                    "-    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, optional",
                    "+    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\",
                    "+                     \"override\"}, optional"
                ],
                "start_lineno": 559,
                "end_lineno": 559
            },
            {
                "hunk": [
                    "-    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"override\"}, \\",
                    "-                    default: \"drop\"",
                    "+    combine_attrs : {\"drop\", \"identical\", \"no_conflicts\", \"drop_conflicts\", \\",
                    "+                     \"override\"}, default: \"drop\"",
                    "         String indicating how to combine attrs of the objects being merged:",
                    " ",
                    "         - \"drop\": empty attrs on returned Dataset.",
                    "         - \"identical\": all attrs must be the same on every object.",
                    "         - \"no_conflicts\": attrs from all objects are combined, any that have",
                    "           the same name must also have the same value.",
                    "+        - \"drop_conflicts\": attrs from all objects are combined, any that have",
                    "+          the same name but different values are dropped."
                ],
                "start_lineno": 671,
                "end_lineno": 678
            }
        ]
    },
    "sympy__sympy-24353": {
        "setup.py": [
            {
                "hunk": [
                    "-    python setup.py clean -> will clean all trash (*.pyc and stuff)",
                    "     python setup.py test  -> will run the complete test suite",
                    "-    python setup.py bench -> will run the complete benchmark suite",
                    "-    python setup.py audit -> will run pyflakes checker on source code"
                ],
                "start_lineno": 19,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "-class audit(Command):",
                    "-    \"\"\"Audits SymPy's source code for following issues:",
                    "-        - Names which are used but not defined or used before they are defined.",
                    "-        - Names which are redefined without having been used.",
                    "-    \"\"\"",
                    "-",
                    "-    description = \"Audit SymPy source with PyFlakes\"",
                    "-    user_options = []",
                    "-",
                    "-    def initialize_options(self):",
                    "-        self.all = None",
                    "-",
                    "-    def finalize_options(self):",
                    "-        pass",
                    "-",
                    "-    def run(self):",
                    "-        try:",
                    "-            import pyflakes.scripts.pyflakes as flakes",
                    "-        except ImportError:",
                    "-            print(\"In order to run the audit, you need to have PyFlakes installed.\")",
                    "-            sys.exit(-1)",
                    "-        dirs = (os.path.join(*d) for d in (m.split('.') for m in modules))",
                    "-        warns = 0",
                    "-        for dir in dirs:",
                    "-            for filename in os.listdir(dir):",
                    "-                if filename.endswith('.py') and filename != '__init__.py':",
                    "-                    warns += flakes.checkPath(os.path.join(dir, filename))",
                    "-        if warns > 0:",
                    "-            print(\"Audit finished with total %d warnings\" % warns)",
                    "-",
                    "-",
                    "-class clean(Command):",
                    "-    \"\"\"Cleans *.pyc and debian trashs, so you should get the same copy as",
                    "-    is in the VCS.",
                    "-    \"\"\"",
                    "-",
                    "-    description = \"remove build files\"",
                    "-    user_options = [(\"all\", \"a\", \"the same\")]",
                    "-",
                    "-    def initialize_options(self):",
                    "-        self.all = None",
                    "-",
                    "-    def finalize_options(self):",
                    "-        pass",
                    "-",
                    "-    def run(self):",
                    "-        curr_dir = os.getcwd()",
                    "-        for root, dirs, files in os.walk(dir_setup):",
                    "-            for file in files:",
                    "-                if file.endswith('.pyc') and os.path.isfile:",
                    "-                    os.remove(os.path.join(root, file))",
                    "-",
                    "-        os.chdir(dir_setup)",
                    "-        names = [\"python-build-stamp-2.4\", \"MANIFEST\", \"build\",",
                    "-                 \"dist\", \"doc/_build\", \"sample.tex\"]",
                    "-",
                    "-        for f in names:",
                    "-            if os.path.isfile(f):",
                    "-                os.remove(f)",
                    "-            elif os.path.isdir(f):",
                    "-                shutil.rmtree(f)",
                    "-",
                    "-        for name in glob.glob(os.path.join(dir_setup, \"doc\", \"src\", \"modules\",",
                    "-                                           \"physics\", \"vector\", \"*.pdf\")):",
                    "-            if os.path.isfile(name):",
                    "-                os.remove(name)",
                    "-",
                    "-        os.chdir(curr_dir)",
                    "-"
                ],
                "start_lineno": 171,
                "end_lineno": 239
            },
            {
                "hunk": [
                    "-class run_benchmarks(Command):",
                    "-    \"\"\"Runs all SymPy benchmarks\"\"\"",
                    "-",
                    "-    description = \"run all benchmarks\"",
                    "-    user_options = []  # distutils complains if this is not here.",
                    "-",
                    "-    def __init__(self, *args):",
                    "-        self.args = args[0]  # so we can pass it to other classes",
                    "-        Command.__init__(self, *args)",
                    "-",
                    "-    def initialize_options(self):  # distutils wants this",
                    "-        pass",
                    "-",
                    "-    def finalize_options(self):    # this too",
                    "-        pass",
                    "-",
                    "-    # we use py.test like architecture:",
                    "-    #",
                    "-    # o collector   -- collects benchmarks",
                    "-    # o runner      -- executes benchmarks",
                    "-    # o presenter   -- displays benchmarks results",
                    "-    #",
                    "-    # this is done in sympy.utilities.benchmarking on top of py.test",
                    "-    def run(self):",
                    "-        from sympy.utilities import benchmarking",
                    "-        benchmarking.main(['sympy'])",
                    "-",
                    "-"
                ],
                "start_lineno": 263,
                "end_lineno": 290
            },
            {
                "hunk": [
                    "-                    'bench': run_benchmarks,",
                    "-                    'clean': clean,",
                    "-                    'audit': audit,"
                ],
                "start_lineno": 452,
                "end_lineno": 454
            }
        ],
        "sympy/utilities/benchmarking.py": [
            {
                "hunk": [
                    "-\"\"\"",
                    "-.. deprecated:: 1.6",
                    "-",
                    "-   sympy.utilities.benchmarking has been renamed to sympy.testing.benchmarking.",
                    "-\"\"\"",
                    "-from sympy.utilities.exceptions import sympy_deprecation_warning",
                    "-",
                    "-sympy_deprecation_warning(\"The sympy.utilities.benchmarking submodule is deprecated. Use sympy.testing.benchmarking instead.\",",
                    "-    deprecated_since_version=\"1.6\",",
                    "-    active_deprecations_target=\"deprecated-sympy-utilities-submodules\")",
                    "-",
                    "-from sympy.testing.benchmarking import *  # noqa:F401"
                ],
                "start_lineno": 1,
                "end_lineno": 12
            }
        ]
    },
    "matplotlib__matplotlib-26101": {
        "lib/matplotlib/markers.py": [
            {
                "hunk": [
                    "-        xmin, ymin = text.vertices.min(axis=0)",
                    "-        xmax, ymax = text.vertices.max(axis=0)",
                    "-        width = xmax - xmin",
                    "-        height = ymax - ymin",
                    "-        max_dim = max(width, height)",
                    "-        self._transform = Affine2D() \\",
                    "-            .translate(-xmin + 0.5 * -width, -ymin + 0.5 * -height) \\",
                    "-            .scale(1.0 / max_dim)",
                    "+        bbox = text.get_extents()",
                    "+        max_dim = max(bbox.width, bbox.height)",
                    "+        self._transform = (",
                    "+            Affine2D()",
                    "+            .translate(-bbox.xmin + 0.5 * -bbox.width, -bbox.ymin + 0.5 * -bbox.height)",
                    "+            .scale(1.0 / max_dim))"
                ],
                "start_lineno": 512,
                "end_lineno": 519
            }
        ]
    },
    "sphinx-doc__sphinx-7615": {
        "sphinx/transforms/__init__.py": [
            {
                "hunk": [
                    "+from sphinx.util import docutils"
                ],
                "start_lineno": 26,
                "end_lineno": 26
            },
            {
                "hunk": [
                    "-",
                    "-        texttype = {True: 'literal',  # \"literal\" text is not changed:",
                    "-                    False: 'plain'}",
                    "         for txtnode in txtnodes:",
                    "-            notsmartquotable = not is_smartquotable(txtnode)",
                    "-            yield (texttype[notsmartquotable], txtnode.astext())",
                    "+            if is_smartquotable(txtnode):",
                    "+                if docutils.__version_info__ >= (0, 16):",
                    "+                    # SmartQuotes uses backslash escapes instead of null-escapes",
                    "+                    text = re.sub(r'(?<=\\x00)([-\\\\\\'\".`])', r'\\\\\\1', str(txtnode))",
                    "+                else:",
                    "+                    text = txtnode.astext()",
                    "+",
                    "+                yield ('plain', text)",
                    "+            else:",
                    "+                # skip smart quotes",
                    "+                yield ('literal', txtnode.astext())"
                ],
                "start_lineno": 363,
                "end_lineno": 368
            }
        ]
    },
    "scikit-learn__scikit-learn-13877": {
        "sklearn/metrics/pairwise.py": [
            {
                "hunk": [
                    "+    X, Y, dtype = _return_float_dtype(X, Y)",
                    " ",
                    "     if effective_n_jobs(n_jobs) == 1:",
                    "         return func(X, Y, **kwds)",
                    " ",
                    "     # enforce a threading backend to prevent data communication overhead",
                    "     fd = delayed(_dist_wrapper)",
                    "-    ret = np.empty((X.shape[0], Y.shape[0]), dtype=X.dtype, order='F')",
                    "+    ret = np.empty((X.shape[0], Y.shape[0]), dtype=dtype, order='F')",
                    "     Parallel(backend=\"threading\", n_jobs=n_jobs)(",
                    "         fd(func, ret, s, X, Y[s], **kwds)",
                    "         for s in gen_even_slices(_num_samples(Y), effective_n_jobs(n_jobs)))",
                    " ",
                    "+    if (X is Y or Y is None) and func is euclidean_distances:",
                    "+        # zeroing diagonal for euclidean norm.",
                    "+        # TODO: do it also for other norms.",
                    "+        np.fill_diagonal(ret, 0)",
                    "+"
                ],
                "start_lineno": 1185,
                "end_lineno": 1195
            }
        ]
    },
    "django__django-16952": {
        "django/db/models/base.py": [
            {
                "hunk": [
                    "+        # Check that parent links in diamond-shaped MTI models don't clash.",
                    "+        for parent_link in cls._meta.parents.values():",
                    "+            if not parent_link:",
                    "+                continue",
                    "+            clash = used_fields.get(parent_link.name) or None",
                    "+            if clash:",
                    "+                errors.append(",
                    "+                    checks.Error(",
                    "+                        f\"The field '{parent_link.name}' clashes with the field \"",
                    "+                        f\"'{clash.name}' from model '{clash.model._meta}'.\",",
                    "+                        obj=cls,",
                    "+                        id=\"models.E006\",",
                    "+                    )",
                    "+                )",
                    "+"
                ],
                "start_lineno": 1778,
                "end_lineno": 1778
            }
        ],
        "django/db/models/options.py": [
            {
                "hunk": [
                    "-        seen_models=None,",
                    "+        topmost_call=True,"
                ],
                "start_lineno": 867,
                "end_lineno": 867
            },
            {
                "hunk": [
                    "-        # We must keep track of which models we have already seen. Otherwise we",
                    "-        # could include the same field multiple times from different models.",
                    "-        topmost_call = seen_models is None",
                    "-        if topmost_call:",
                    "-            seen_models = set()",
                    "-        seen_models.add(self.model)",
                    "-"
                ],
                "start_lineno": 888,
                "end_lineno": 894
            },
            {
                "hunk": [
                    "+            # In diamond inheritance it is possible that we see the same model",
                    "+            # from two different routes. In that case, avoid adding fields from",
                    "+            # the same parent again.",
                    "+            parent_fields = set()",
                    "             for parent in self.parents:",
                    "-                # In diamond inheritance it is possible that we see the same",
                    "-                # model from two different routes. In that case, avoid adding",
                    "-                # fields from the same parent again.",
                    "-                if parent in seen_models:",
                    "-                    continue"
                ],
                "start_lineno": 909,
                "end_lineno": 914
            },
            {
                "hunk": [
                    "-                    seen_models=seen_models,",
                    "+                    topmost_call=False,",
                    "                 ):",
                    "                     if (",
                    "                         not getattr(obj, \"parent_link\", False)",
                    "                         or obj.model == self.concrete_model",
                    "-                    ):",
                    "+                    ) and obj not in parent_fields:",
                    "                         fields.append(obj)",
                    "+                        parent_fields.add(obj)",
                    "+"
                ],
                "start_lineno": 925,
                "end_lineno": 931
            }
        ]
    },
    "sphinx-doc__sphinx-10614": {
        "sphinx/ext/inheritance_diagram.py": [
            {
                "hunk": [
                    "-            if graphviz_output_format == 'SVG':",
                    "-                urls[child['reftitle']] = \"../\" + child.get('refuri')",
                    "+            # Construct the name from the URI if the reference is external via intersphinx",
                    "+            if not child.get('internal', True):",
                    "+                refname = child['refuri'].rsplit('#', 1)[-1]",
                    "             else:",
                    "-                urls[child['reftitle']] = child.get('refuri')",
                    "+                refname = child['reftitle']",
                    "+",
                    "+            urls[refname] = child.get('refuri')",
                    "         elif child.get('refid') is not None:",
                    "             if graphviz_output_format == 'SVG':",
                    "-                urls[child['reftitle']] = '../' + current_filename + '#' + child.get('refid')",
                    "+                urls[child['reftitle']] = current_filename + '#' + child.get('refid')"
                ],
                "start_lineno": 415,
                "end_lineno": 421
            }
        ]
    },
    "pydata__xarray-5033": {
        "xarray/backends/api.py": [
            {
                "hunk": [
                    "-        \"pseudonetcdf\", \"zarr\"}, optional",
                    "+        \"pseudonetcdf\", \"zarr\"} or subclass of xarray.backends.BackendEntrypoint, optional",
                    "         Engine to use when reading files. If not provided, the default engine",
                    "         is chosen based on available dependencies, with a preference for",
                    "-        \"netcdf4\".",
                    "+        \"netcdf4\". A custom backend class (a subclass of ``BackendEntrypoint``)",
                    "+        can also be used."
                ],
                "start_lineno": 378,
                "end_lineno": 381
            }
        ],
        "xarray/backends/plugins.py": [
            {
                "hunk": [
                    "-from .common import BACKEND_ENTRYPOINTS",
                    "+from .common import BACKEND_ENTRYPOINTS, BackendEntrypoint"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-    \"\"\"Select open_dataset method based on current engine\"\"\"",
                    "-    engines = list_engines()",
                    "-    if engine not in engines:",
                    "-        raise ValueError(",
                    "-            f\"unrecognized engine {engine} must be one of: {list(engines)}\"",
                    "+    \"\"\"Select open_dataset method based on current engine.\"\"\"",
                    "+    if isinstance(engine, str):",
                    "+        engines = list_engines()",
                    "+        if engine not in engines:",
                    "+            raise ValueError(",
                    "+                f\"unrecognized engine {engine} must be one of: {list(engines)}\"",
                    "+            )",
                    "+        backend = engines[engine]",
                    "+    elif isinstance(engine, type) and issubclass(engine, BackendEntrypoint):",
                    "+        backend = engine",
                    "+    else:",
                    "+        raise TypeError(",
                    "+            (",
                    "+                \"engine must be a string or a subclass of \"",
                    "+                f\"xarray.backends.BackendEntrypoint: {engine}\"",
                    "+            )",
                    "         )",
                    "-    return engines[engine]",
                    "+",
                    "+    return backend"
                ],
                "start_lineno": 116,
                "end_lineno": 122
            }
        ]
    },
    "sphinx-doc__sphinx-8697": {
        "sphinx/environment/__init__.py": [
            {
                "hunk": [
                    "+import posixpath"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            },
            {
                "hunk": [
                    "-        # the path.abspath() might seem redundant, but otherwise artifacts",
                    "-        # such as \"..\" will remain in the path",
                    "-        return rel_fn, path.abspath(path.join(self.srcdir, rel_fn))",
                    "+",
                    "+        return (posixpath.normpath(rel_fn),",
                    "+                path.normpath(path.join(self.srcdir, rel_fn)))"
                ],
                "start_lineno": 359,
                "end_lineno": 361
            }
        ]
    },
    "astropy__astropy-8005": {
        "astropy/units/equivalencies.py": [
            {
                "hunk": [
                    "-    T_cmb :  `~astropy.units.Quantity` with temperature units (default Planck15 value)",
                    "-        The CMB temperature at z=0",
                    "+    T_cmb :  `~astropy.units.Quantity` with temperature units or None",
                    "+        The CMB temperature at z=0.  If `None`, the default cosmology will be",
                    "+        used to get this temperature."
                ],
                "start_lineno": 594,
                "end_lineno": 595
            },
            {
                "hunk": [
                    "+        >>> from astropy.cosmology import Planck15",
                    "         >>> freq = 143 * u.GHz",
                    "-        >>> equiv = u.thermodynamic_temperature(freq)",
                    "+        >>> equiv = u.thermodynamic_temperature(freq, Planck15.Tcmb0)"
                ],
                "start_lineno": 612,
                "end_lineno": 613
            },
            {
                "hunk": [
                    "-        from ..cosmology import Planck15",
                    "-        T_cmb = Planck15.Tcmb0",
                    "+        from ..cosmology import default_cosmology",
                    "+        T_cmb = default_cosmology.get().Tcmb0"
                ],
                "start_lineno": 621,
                "end_lineno": 622
            }
        ]
    },
    "scikit-learn__scikit-learn-12827": {
        "sklearn/preprocessing/data.py": [
            {
                "hunk": [
                    "-    The transformation is applied on each feature independently.",
                    "-    The cumulative distribution function of a feature is used to project the",
                    "-    original values. Features values of new/unseen data that fall below",
                    "-    or above the fitted range will be mapped to the bounds of the output",
                    "+    The transformation is applied on each feature independently. First an",
                    "+    estimate of the cumulative distribution function of a feature is",
                    "+    used to map the original values to a uniform distribution. The obtained",
                    "+    values are then mapped to the desired output distribution using the",
                    "+    associated quantile function. Features values of new/unseen data that fall",
                    "+    below or above the fitted range will be mapped to the bounds of the output"
                ],
                "start_lineno": 1998,
                "end_lineno": 2001
            },
            {
                "hunk": [
                    "-        if self.output_distribution == 'normal':",
                    "-            output_distribution = 'norm'",
                    "-        else:",
                    "-            output_distribution = self.output_distribution",
                    "-        output_distribution = getattr(stats, output_distribution)",
                    "+        output_distribution = self.output_distribution"
                ],
                "start_lineno": 2201,
                "end_lineno": 2205
            },
            {
                "hunk": [
                    "-            #  for inverse transform, match a uniform PDF",
                    "+            #  for inverse transform, match a uniform distribution",
                    "             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings",
                    "-                X_col = output_distribution.cdf(X_col)",
                    "+                if output_distribution == 'normal':",
                    "+                    X_col = stats.norm.cdf(X_col)",
                    "+                # else output distribution is already a uniform distribution",
                    "+",
                    "         # find index for lower and higher bounds",
                    "         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings",
                    "-            lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <",
                    "-                                lower_bound_x)",
                    "-            upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >",
                    "-                                upper_bound_x)",
                    "+            if output_distribution == 'normal':",
                    "+                lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <",
                    "+                                    lower_bound_x)",
                    "+                upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >",
                    "+                                    upper_bound_x)",
                    "+            if output_distribution == 'uniform':",
                    "+                lower_bounds_idx = (X_col == lower_bound_x)",
                    "+                upper_bounds_idx = (X_col == upper_bound_x)"
                ],
                "start_lineno": 2217,
                "end_lineno": 2225
            },
            {
                "hunk": [
                    "-        # for forward transform, match the output PDF",
                    "+        # for forward transform, match the output distribution",
                    "         if not inverse:",
                    "             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings",
                    "-                X_col = output_distribution.ppf(X_col)",
                    "-            # find the value to clip the data to avoid mapping to",
                    "-            # infinity. Clip such that the inverse transform will be",
                    "-            # consistent",
                    "-            clip_min = output_distribution.ppf(BOUNDS_THRESHOLD -",
                    "-                                               np.spacing(1))",
                    "-            clip_max = output_distribution.ppf(1 - (BOUNDS_THRESHOLD -",
                    "-                                                    np.spacing(1)))",
                    "-            X_col = np.clip(X_col, clip_min, clip_max)",
                    "+                if output_distribution == 'normal':",
                    "+                    X_col = stats.norm.ppf(X_col)",
                    "+                    # find the value to clip the data to avoid mapping to",
                    "+                    # infinity. Clip such that the inverse transform will be",
                    "+                    # consistent",
                    "+                    clip_min = stats.norm.ppf(BOUNDS_THRESHOLD - np.spacing(1))",
                    "+                    clip_max = stats.norm.ppf(1 - (BOUNDS_THRESHOLD -",
                    "+                                                   np.spacing(1)))",
                    "+                    X_col = np.clip(X_col, clip_min, clip_max)",
                    "+                # else output distribution is uniform and the ppf is the",
                    "+                # identity function so we let X_col unchanged"
                ],
                "start_lineno": 2247,
                "end_lineno": 2258
            },
            {
                "hunk": [
                    "-        # check the output PDF",
                    "+        # check the output distribution"
                ],
                "start_lineno": 2275,
                "end_lineno": 2275
            },
            {
                "hunk": [
                    "-    The transformation is applied on each feature independently.",
                    "-    The cumulative distribution function of a feature is used to project the",
                    "-    original values. Features values of new/unseen data that fall below",
                    "-    or above the fitted range will be mapped to the bounds of the output",
                    "+    The transformation is applied on each feature independently. First an",
                    "+    estimate of the cumulative distribution function of a feature is",
                    "+    used to map the original values to a uniform distribution. The obtained",
                    "+    values are then mapped to the desired output distribution using the",
                    "+    associated quantile function. Features values of new/unseen data that fall",
                    "+    below or above the fitted range will be mapped to the bounds of the output"
                ],
                "start_lineno": 2382,
                "end_lineno": 2385
            }
        ]
    },
    "django__django-16255": {
        "django/contrib/sitemaps/__init__.py": [
            {
                "hunk": [
                    "-                return max([self.lastmod(item) for item in self.items()])",
                    "+                return max([self.lastmod(item) for item in self.items()], default=None)"
                ],
                "start_lineno": 170,
                "end_lineno": 170
            }
        ]
    },
    "matplotlib__matplotlib-25425": {
        "lib/matplotlib/image.py": [
            {
                "hunk": [
                    "-            size = self.get_size()",
                    "-            return f\"{type(self).__name__}(size={size!r})\"",
                    "+            shape = self.get_shape()",
                    "+            return f\"{type(self).__name__}(shape={shape!r})\""
                ],
                "start_lineno": 278,
                "end_lineno": 279
            },
            {
                "hunk": [
                    "+        return self.get_shape()[:2]",
                    "+",
                    "+    def get_shape(self):",
                    "+        \"\"\"",
                    "+        Return the shape of the image as tuple (numrows, numcols, channels).",
                    "+        \"\"\"",
                    "         if self._A is None:",
                    "             raise RuntimeError('You must first set the image array')",
                    " ",
                    "-        return self._A.shape[:2]",
                    "+        return self._A.shape"
                ],
                "start_lineno": 289,
                "end_lineno": 292
            }
        ]
    },
    "django__django-12049": {
        "django/db/migrations/executor.py": [
            {
                "hunk": [
                    "+        fold_identifier_case = self.connection.features.ignores_table_name_case",
                    "         with self.connection.cursor() as cursor:",
                    "-            existing_table_names = self.connection.introspection.table_names(cursor)",
                    "+            existing_table_names = set(self.connection.introspection.table_names(cursor))",
                    "+            if fold_identifier_case:",
                    "+                existing_table_names = {name.casefold() for name in existing_table_names}"
                ],
                "start_lineno": 332,
                "end_lineno": 333
            },
            {
                "hunk": [
                    "-                if model._meta.db_table not in existing_table_names:",
                    "+                db_table = model._meta.db_table",
                    "+                if fold_identifier_case:",
                    "+                    db_table = db_table.casefold()",
                    "+                if db_table not in existing_table_names:"
                ],
                "start_lineno": 344,
                "end_lineno": 344
            },
            {
                "hunk": [
                    "-                    if field.remote_field.through._meta.db_table not in existing_table_names:",
                    "+                    through_db_table = field.remote_field.through._meta.db_table",
                    "+                    if fold_identifier_case:",
                    "+                        through_db_table = through_db_table.casefold()",
                    "+                    if through_db_table not in existing_table_names:",
                    "                         return False, project_state",
                    "                     else:",
                    "                         found_add_field_migration = True",
                    "                         continue",
                    "-",
                    "-                column_names = [",
                    "-                    column.name for column in",
                    "-                    self.connection.introspection.get_table_description(self.connection.cursor(), table)",
                    "-                ]",
                    "-                if field.column not in column_names:",
                    "+                columns = self.connection.introspection.get_table_description(",
                    "+                    self.connection.cursor(),",
                    "+                    table,",
                    "+                )",
                    "+                for column in columns:",
                    "+                    field_column = field.column",
                    "+                    column_name = column.name",
                    "+                    if fold_identifier_case:",
                    "+                        column_name = column_name.casefold()",
                    "+                        field_column = field_column.casefold()",
                    "+                    if column_name == field_column:",
                    "+                        found_add_field_migration = True",
                    "+                        break",
                    "+                else:",
                    "                     return False, project_state",
                    "-                found_add_field_migration = True"
                ],
                "start_lineno": 361,
                "end_lineno": 373
            }
        ]
    },
    "django__django-16983": {
        "django/contrib/admin/checks.py": [
            {
                "hunk": [
                    "+            elif not field.remote_field.through._meta.auto_created:",
                    "+                return [",
                    "+                    checks.Error(",
                    "+                        f\"The value of '{label}' cannot include the ManyToManyField \"",
                    "+                        f\"'{field_name}', because that field manually specifies a \"",
                    "+                        f\"relationship model.\",",
                    "+                        obj=obj.__class__,",
                    "+                        id=\"admin.E013\",",
                    "+                    )",
                    "+                ]"
                ],
                "start_lineno": 536,
                "end_lineno": 536
            }
        ]
    },
    "django__django-13616": {
        "django/core/management/commands/makemessages.py": [
            {
                "hunk": [
                    "-                    'Unable to find a locale path to store translations for '",
                    "-                    'file %s' % file_path",
                    "+                    \"Unable to find a locale path to store translations for \"",
                    "+                    \"file %s. Make sure the 'locale' directory exist in an \"",
                    "+                    \"app or LOCALE_PATHS setting is set.\" % file_path"
                ],
                "start_lineno": 586,
                "end_lineno": 587
            }
        ]
    },
    "django__django-15525": {
        "django/core/serializers/base.py": [
            {
                "hunk": [
                    "-        natural_key = Model(**data).natural_key()",
                    "+        obj = Model(**data)",
                    "+        obj._state.db = db",
                    "+        natural_key = obj.natural_key()"
                ],
                "start_lineno": 339,
                "end_lineno": 339
            }
        ]
    },
    "pytest-dev__pytest-5221": {
        "src/_pytest/python.py": [
            {
                "hunk": [
                    "+        tw.write(argname, green=True)",
                    "+        if fixturedef.scope != \"function\":",
                    "+            tw.write(\" [%s scope]\" % fixturedef.scope, cyan=True)",
                    "         if verbose > 0:",
                    "-            funcargspec = \"%s -- %s\" % (argname, bestrel)",
                    "-        else:",
                    "-            funcargspec = argname",
                    "-        tw.line(funcargspec, green=True)",
                    "+            tw.write(\" -- %s\" % bestrel, yellow=True)",
                    "+        tw.write(\"\\n\")",
                    "         loc = getlocation(fixturedef.func, curdir)",
                    "         doc = fixturedef.func.__doc__ or \"\"",
                    "         if doc:",
                    "             write_docstring(tw, doc)",
                    "         else:",
                    "             tw.line(\"    %s: no docstring available\" % (loc,), red=True)",
                    "+        tw.line()"
                ],
                "start_lineno": 1345,
                "end_lineno": 1355
            }
        ]
    },
    "django__django-16369": {
        "django/contrib/sitemaps/__init__.py": [
            {
                "hunk": [
                    "+    def get_languages_for_item(self, item):",
                    "+        \"\"\"Languages for which this item is displayed.\"\"\"",
                    "+        return self._languages()",
                    "+"
                ],
                "start_lineno": 95,
                "end_lineno": 95
            },
            {
                "hunk": [
                    "-                for lang_code in self._languages()",
                    "                 for item in self.items()",
                    "+                for lang_code in self.get_languages_for_item(item)"
                ],
                "start_lineno": 106,
                "end_lineno": 107
            },
            {
                "hunk": [
                    "-                for lang_code in self._languages():",
                    "+                item_languages = self.get_languages_for_item(item[0])",
                    "+                for lang_code in item_languages:"
                ],
                "start_lineno": 204,
                "end_lineno": 204
            },
            {
                "hunk": [
                    "-                if self.x_default:",
                    "+                if self.x_default and settings.LANGUAGE_CODE in item_languages:"
                ],
                "start_lineno": 212,
                "end_lineno": 212
            }
        ]
    },
    "pydata__xarray-4098": {
        "xarray/core/groupby.py": [
            {
                "hunk": [
                    "-            raise ValueError(\"`group` must have a name\")",
                    "+            group.name = \"group\""
                ],
                "start_lineno": 324,
                "end_lineno": 324
            }
        ]
    },
    "django__django-16429": {
        "django/utils/timesince.py": [
            {
                "hunk": [
                    "+            tzinfo=d.tzinfo,"
                ],
                "start_lineno": 100,
                "end_lineno": 100
            }
        ]
    },
    "mwaskom__seaborn-2389": {
        "seaborn/matrix.py": [
            {
                "hunk": [
                    "-    to_rgb = mpl.colors.colorConverter.to_rgb",
                    "-",
                    "-    if isinstance(colors, pd.DataFrame):",
                    "-        # Convert dataframe",
                    "-        return pd.DataFrame({col: colors[col].map(to_rgb)",
                    "-                            for col in colors})",
                    "-    elif isinstance(colors, pd.Series):",
                    "-        return colors.map(to_rgb)",
                    "-    else:",
                    "-        try:",
                    "-            to_rgb(colors[0])",
                    "-            # If this works, there is only one level of colors",
                    "-            return list(map(to_rgb, colors))",
                    "-        except ValueError:",
                    "-            # If we get here, we have nested lists",
                    "-            return [list(map(to_rgb, l)) for l in colors]",
                    "+    to_rgb = mpl.colors.to_rgb",
                    "+",
                    "+    try:",
                    "+        to_rgb(colors[0])",
                    "+        # If this works, there is only one level of colors",
                    "+        return list(map(to_rgb, colors))",
                    "+    except ValueError:",
                    "+        # If we get here, we have nested lists",
                    "+        return [list(map(to_rgb, l)) for l in colors]"
                ],
                "start_lineno": 41,
                "end_lineno": 56
            },
            {
                "hunk": [
                    "-class _HeatMapper(object):",
                    "+class _HeatMapper:"
                ],
                "start_lineno": 96,
                "end_lineno": 96
            },
            {
                "hunk": [
                    "-        # Get the positions and used label for the ticks",
                    "-        nx, ny = data.T.shape",
                    "-"
                ],
                "start_lineno": 135,
                "end_lineno": 137
            },
            {
                "hunk": [
                    "-                # Replace na's with background color",
                    "+                # Replace na's with white color",
                    "                 # TODO We should set these to transparent instead",
                    "-                colors = colors.fillna('white')",
                    "+                colors = colors.astype(object).fillna('white')"
                ],
                "start_lineno": 892,
                "end_lineno": 894
            }
        ]
    },
    "django__django-12121": {
        "django/urls/resolvers.py": [
            {
                "hunk": [
                    "+                match = True",
                    "                 for k, v in candidate_subs.items():",
                    "                     if k in converters:",
                    "-                        text_candidate_subs[k] = converters[k].to_url(v)",
                    "+                        try:",
                    "+                            text_candidate_subs[k] = converters[k].to_url(v)",
                    "+                        except ValueError:",
                    "+                            match = False",
                    "+                            break",
                    "                     else:",
                    "                         text_candidate_subs[k] = str(v)",
                    "+                if not match:",
                    "+                    continue"
                ],
                "start_lineno": 635,
                "end_lineno": 639
            }
        ]
    },
    "sphinx-doc__sphinx-8684": {
        "sphinx/directives/code.py": [
            {
                "hunk": [
                    "+import textwrap"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "+from sphinx.directives import optional_int"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "-        return lines",
                    "+        return textwrap.dedent(''.join(lines)).splitlines(True)"
                ],
                "start_lineno": 71,
                "end_lineno": 71
            },
            {
                "hunk": [
                    "-        'dedent': int,",
                    "+        'dedent': optional_int,"
                ],
                "start_lineno": 120,
                "end_lineno": 120
            },
            {
                "hunk": [
                    "-        'dedent': int,",
                    "+        'dedent': optional_int,"
                ],
                "start_lineno": 394,
                "end_lineno": 394
            }
        ]
    },
    "django__django-11612": {
        "django/db/backends/postgresql/schema.py": [
            {
                "hunk": [
                    "+from django.db.backends.utils import strip_quotes"
                ],
                "start_lineno": 5,
                "end_lineno": 5
            },
            {
                "hunk": [
                    "-        table = model._meta.db_table",
                    "+        table = strip_quotes(model._meta.db_table)",
                    "         if new_type.lower() in (\"serial\", \"bigserial\"):",
                    "-            column = new_field.column",
                    "+            column = strip_quotes(new_field.column)"
                ],
                "start_lineno": 70,
                "end_lineno": 72
            }
        ],
        "django/db/backends/sqlite3/schema.py": [
            {
                "hunk": [
                    "+from django.db.backends.utils import strip_quotes"
                ],
                "start_lineno": 7,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "-            'db_table': 'new__%s' % model._meta.db_table,",
                    "+            'db_table': 'new__%s' % strip_quotes(model._meta.db_table),"
                ],
                "start_lineno": 266,
                "end_lineno": 266
            }
        ]
    },
    "django__django-16082": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+            Combinable.MOD,"
                ],
                "start_lineno": 536,
                "end_lineno": 536
            }
        ]
    },
    "django__django-14681": {
        "django/middleware/csrf.py": [
            {
                "hunk": [
                    "+from django.http import UnreadablePostError"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "-            except OSError:",
                    "+            except UnreadablePostError:"
                ],
                "start_lineno": 345,
                "end_lineno": 345
            }
        ]
    },
    "pydata__xarray-3305": {
        "xarray/core/dataset.py": [
            {
                "hunk": [
                    "-                            q, dim=reduce_dims, interpolation=interpolation",
                    "+                            q,",
                    "+                            dim=reduce_dims,",
                    "+                            interpolation=interpolation,",
                    "+                            keep_attrs=keep_attrs,"
                ],
                "start_lineno": 4771,
                "end_lineno": 4771
            }
        ],
        "xarray/core/variable.py": [
            {
                "hunk": [
                    "-    def quantile(self, q, dim=None, interpolation=\"linear\"):",
                    "+    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):"
                ],
                "start_lineno": 1595,
                "end_lineno": 1595
            },
            {
                "hunk": [
                    "+        keep_attrs : bool, optional",
                    "+            If True, the variable's attributes (`attrs`) will be copied from",
                    "+            the original object to the new one.  If False (default), the new",
                    "+            object will be returned without attributes."
                ],
                "start_lineno": 1618,
                "end_lineno": 1618
            },
            {
                "hunk": [
                    "-             dimensions that remain after the reduction of the array.",
                    "+            dimensions that remain after the reduction of the array."
                ],
                "start_lineno": 1626,
                "end_lineno": 1626
            },
            {
                "hunk": [
                    "-        # only add the quantile dimension if q is array like",
                    "+        # Only add the quantile dimension if q is array-like",
                    "         if q.ndim != 0:",
                    "             new_dims = [\"quantile\"] + new_dims",
                    " ",
                    "         qs = np.nanpercentile(",
                    "             self.data, q * 100.0, axis=axis, interpolation=interpolation",
                    "         )",
                    "-        return Variable(new_dims, qs)",
                    "+",
                    "+        if keep_attrs is None:",
                    "+            keep_attrs = _get_keep_attrs(default=False)",
                    "+        attrs = self._attrs if keep_attrs else None",
                    "+",
                    "+        return Variable(new_dims, qs, attrs)"
                ],
                "start_lineno": 1654,
                "end_lineno": 1661
            }
        ]
    },
    "sympy__sympy-17038": {
        "sympy/core/power.py": [
            {
                "hunk": [
                    "-    if n < 17984395633462800708566937239552:",
                    "-        return int(_sqrt(n))",
                    "-    return integer_nthroot(int(n), 2)[0]",
                    "+    if n < 0:",
                    "+        raise ValueError(\"n must be nonnegative\")",
                    "+    n = int(n)",
                    "+",
                    "+    # Fast path: with IEEE 754 binary64 floats and a correctly-rounded",
                    "+    # math.sqrt, int(math.sqrt(n)) works for any integer n satisfying 0 <= n <",
                    "+    # 4503599761588224 = 2**52 + 2**27. But Python doesn't guarantee either",
                    "+    # IEEE 754 format floats *or* correct rounding of math.sqrt, so check the",
                    "+    # answer and fall back to the slow method if necessary.",
                    "+    if n < 4503599761588224:",
                    "+        s = int(_sqrt(n))",
                    "+        if 0 <= n - s*s <= 2*s:",
                    "+            return s",
                    "+",
                    "+    return integer_nthroot(n, 2)[0]"
                ],
                "start_lineno": 25,
                "end_lineno": 27
            }
        ]
    },
    "django__django-12407": {
        "django/template/loader_tags.py": [
            {
                "hunk": [
                    "-            # If not, try the cache and get_template().",
                    "-            template_name = template",
                    "+            # If not, try the cache and select_template().",
                    "+            template_name = template or ()",
                    "+            if isinstance(template_name, str):",
                    "+                template_name = (template_name,)",
                    "+            else:",
                    "+                template_name = tuple(template_name)",
                    "             cache = context.render_context.dicts[0].setdefault(self, {})",
                    "             template = cache.get(template_name)",
                    "             if template is None:",
                    "-                template = context.template.engine.get_template(template_name)",
                    "+                template = context.template.engine.select_template(template_name)"
                ],
                "start_lineno": 171,
                "end_lineno": 176
            }
        ]
    },
    "django__django-13325": {
        "django/core/cache/backends/locmem.py": [
            {
                "hunk": [
                    "+        self.validate_key(key)"
                ],
                "start_lineno": 62,
                "end_lineno": 62
            }
        ],
        "django/core/cache/backends/memcached.py": [
            {
                "hunk": [
                    "+        self.validate_key(key)"
                ],
                "start_lineno": 84,
                "end_lineno": 84
            },
            {
                "hunk": [
                    "-        self._cache.delete_multi(self.make_key(key, version=version) for key in keys)",
                    "+        keys = [self.make_key(key, version=version) for key in keys]",
                    "+        for key in keys:",
                    "+            self.validate_key(key)",
                    "+        self._cache.delete_multi(keys)"
                ],
                "start_lineno": 148,
                "end_lineno": 148
            },
            {
                "hunk": [
                    "+        self.validate_key(key)"
                ],
                "start_lineno": 176,
                "end_lineno": 176
            },
            {
                "hunk": [
                    "+        self.validate_key(key)"
                ],
                "start_lineno": 189,
                "end_lineno": 189
            },
            {
                "hunk": [
                    "+        self.validate_key(key)"
                ],
                "start_lineno": 204,
                "end_lineno": 204
            }
        ]
    },
    "django__django-11389": {
        "django/contrib/sessions/backends/base.py": [
            {
                "hunk": [
                    "+    def get_session_cookie_age(self):",
                    "+        return settings.SESSION_COOKIE_AGE",
                    "+"
                ],
                "start_lineno": 209,
                "end_lineno": 209
            },
            {
                "hunk": [
                    "-            return settings.SESSION_COOKIE_AGE",
                    "+            return self.get_session_cookie_age()"
                ],
                "start_lineno": 228,
                "end_lineno": 228
            },
            {
                "hunk": [
                    "-        expiry = expiry or settings.SESSION_COOKIE_AGE   # Checks both None and 0 cases",
                    "+        expiry = expiry or self.get_session_cookie_age()"
                ],
                "start_lineno": 252,
                "end_lineno": 252
            }
        ],
        "django/contrib/sessions/backends/file.py": [
            {
                "hunk": [
                    "-            self._last_modification() + datetime.timedelta(seconds=settings.SESSION_COOKIE_AGE)",
                    "+            self._last_modification() + datetime.timedelta(seconds=self.get_session_cookie_age())"
                ],
                "start_lineno": 72,
                "end_lineno": 72
            }
        ],
        "django/contrib/sessions/backends/signed_cookies.py": [
            {
                "hunk": [
                    "-from django.conf import settings"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "-                max_age=settings.SESSION_COOKIE_AGE,",
                    "+                max_age=self.get_session_cookie_age(),"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            }
        ]
    },
    "scikit-learn__scikit-learn-26400": {
        "sklearn/preprocessing/_data.py": [
            {
                "hunk": [
                    "+        mask = np.isnan(x)",
                    "+        if np.all(mask):",
                    "+            raise ValueError(\"Column must not be all nan.\")",
                    "+",
                    "         # the computation of lambda is influenced by NaNs so we need to",
                    "         # get rid of them",
                    "-        _, lmbda = stats.boxcox(x[~np.isnan(x)], lmbda=None)",
                    "+        _, lmbda = stats.boxcox(x[~mask], lmbda=None)"
                ],
                "start_lineno": 3314,
                "end_lineno": 3316
            }
        ]
    },
    "django__django-16485": {
        "django/template/defaultfilters.py": [
            {
                "hunk": [
                    "-    if not m and p < 0:",
                    "+    if not m and p <= 0:"
                ],
                "start_lineno": 171,
                "end_lineno": 171
            }
        ]
    },
    "django__django-10957": {
        "django/utils/translation/__init__.py": [
            {
                "hunk": [
                    "+import warnings",
                    " from contextlib import ContextDecorator",
                    " ",
                    " from django.utils.autoreload import autoreload_started, file_changed",
                    "+from django.utils.deprecation import RemovedInDjango40Warning"
                ],
                "start_lineno": 5,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "-ugettext_noop = gettext_noop",
                    "+def ugettext_noop(message):",
                    "+    \"\"\"",
                    "+    A legacy compatibility wrapper for Unicode handling on Python 2.",
                    "+    Alias of gettext_noop() since Django 2.0.",
                    "+    \"\"\"",
                    "+    warnings.warn(",
                    "+        'django.utils.translation.ugettext_noop() is deprecated in favor of '",
                    "+        'django.utils.translation.gettext_noop().',",
                    "+        RemovedInDjango40Warning, stacklevel=2,",
                    "+    )",
                    "+    return gettext_noop(message)",
                    " ",
                    " ",
                    " def gettext(message):",
                    "     return _trans.gettext(message)",
                    " ",
                    " ",
                    "-# An alias since Django 2.0",
                    "-ugettext = gettext",
                    "+def ugettext(message):",
                    "+    \"\"\"",
                    "+    A legacy compatibility wrapper for Unicode handling on Python 2.",
                    "+    Alias of gettext() since Django 2.0.",
                    "+    \"\"\"",
                    "+    warnings.warn(",
                    "+        'django.utils.translation.ugettext() is deprecated in favor of '",
                    "+        'django.utils.translation.gettext().',",
                    "+        RemovedInDjango40Warning, stacklevel=2,",
                    "+    )",
                    "+    return gettext(message)",
                    " ",
                    " ",
                    " def ngettext(singular, plural, number):",
                    "     return _trans.ngettext(singular, plural, number)",
                    " ",
                    " ",
                    "-# An alias since Django 2.0",
                    "-ungettext = ngettext",
                    "+def ungettext(singular, plural, number):",
                    "+    \"\"\"",
                    "+    A legacy compatibility wrapper for Unicode handling on Python 2.",
                    "+    Alias of ngettext() since Django 2.0.",
                    "+    \"\"\"",
                    "+    warnings.warn(",
                    "+        'django.utils.translation.ungettext() is deprecated in favor of '",
                    "+        'django.utils.translation.ngettext().',",
                    "+        RemovedInDjango40Warning, stacklevel=2,",
                    "+    )",
                    "+    return ngettext(singular, plural, number)"
                ],
                "start_lineno": 75,
                "end_lineno": 91
            },
            {
                "hunk": [
                    "-gettext_lazy = ugettext_lazy = lazy(gettext, str)",
                    "+gettext_lazy = lazy(gettext, str)",
                    " pgettext_lazy = lazy(pgettext, str)",
                    " ",
                    " ",
                    "+def ugettext_lazy(message):",
                    "+    \"\"\"",
                    "+    A legacy compatibility wrapper for Unicode handling on Python 2. Has been",
                    "+    Alias of gettext_lazy since Django 2.0.",
                    "+    \"\"\"",
                    "+    warnings.warn(",
                    "+        'django.utils.translation.ugettext_lazy() is deprecated in favor of '",
                    "+        'django.utils.translation.gettext_lazy().',",
                    "+        RemovedInDjango40Warning, stacklevel=2,",
                    "+    )",
                    "+    return gettext_lazy(message)",
                    "+",
                    "+"
                ],
                "start_lineno": 102,
                "end_lineno": 105
            },
            {
                "hunk": [
                    "-# An alias since Django 2.0",
                    "-ungettext_lazy = ngettext_lazy",
                    "+def ungettext_lazy(singular, plural, number=None):",
                    "+    \"\"\"",
                    "+    A legacy compatibility wrapper for Unicode handling on Python 2.",
                    "+    An alias of ungettext_lazy() since Django 2.0.",
                    "+    \"\"\"",
                    "+    warnings.warn(",
                    "+        'django.utils.translation.ungettext_lazy() is deprecated in favor of '",
                    "+        'django.utils.translation.ngettext_lazy().',",
                    "+        RemovedInDjango40Warning, stacklevel=2,",
                    "+    )",
                    "+    return ngettext_lazy(singular, plural, number)"
                ],
                "start_lineno": 161,
                "end_lineno": 162
            }
        ]
    },
    "django__django-11446": {
        "django/views/defaults.py": [
            {
                "hunk": [
                    "+ERROR_PAGE_TEMPLATE = \"\"\"",
                    "+<!doctype html>",
                    "+<html lang=\"en\">",
                    "+<head>",
                    "+  <title>%(title)s</title>",
                    "+</head>",
                    "+<body>",
                    "+  <h1>%(title)s</h1><p>%(details)s</p>",
                    "+</body>",
                    "+</html>",
                    "+\"\"\""
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "-            '<h1>Not Found</h1>'",
                    "-            '<p>The requested resource was not found on this server.</p>')",
                    "+            ERROR_PAGE_TEMPLATE % {",
                    "+                'title': 'Not Found',",
                    "+                'details': 'The requested resource was not found on this server.',",
                    "+            },",
                    "+        )"
                ],
                "start_lineno": 58,
                "end_lineno": 59
            },
            {
                "hunk": [
                    "-        return HttpResponseServerError('<h1>Server Error (500)</h1>', content_type='text/html')",
                    "+        return HttpResponseServerError(",
                    "+            ERROR_PAGE_TEMPLATE % {'title': 'Server Error (500)', 'details': ''},",
                    "+            content_type='text/html',",
                    "+        )"
                ],
                "start_lineno": 79,
                "end_lineno": 79
            },
            {
                "hunk": [
                    "-        return HttpResponseBadRequest('<h1>Bad Request (400)</h1>', content_type='text/html')",
                    "+        return HttpResponseBadRequest(",
                    "+            ERROR_PAGE_TEMPLATE % {'title': 'Bad Request (400)', 'details': ''},",
                    "+            content_type='text/html',",
                    "+        )"
                ],
                "start_lineno": 97,
                "end_lineno": 97
            },
            {
                "hunk": [
                    "-        return HttpResponseForbidden('<h1>403 Forbidden</h1>', content_type='text/html')",
                    "+        return HttpResponseForbidden(",
                    "+            ERROR_PAGE_TEMPLATE % {'title': '403 Forbidden', 'details': ''},",
                    "+            content_type='text/html',",
                    "+        )"
                ],
                "start_lineno": 122,
                "end_lineno": 122
            }
        ]
    },
    "sympy__sympy-11438": {
        "sympy/solvers/diophantine.py": [
            {
                "hunk": [
                    "-            all(k.is_Pow for k in coeff if k != 1)):",
                    "+            all(k.is_Pow and k.exp == total_degree for k in coeff if k != 1)):"
                ],
                "start_lineno": 405,
                "end_lineno": 405
            }
        ]
    },
    "sympy__sympy-18698": {
        "sympy/polys/polytools.py": [
            {
                "hunk": [
                    "-from functools import wraps",
                    "+from functools import wraps, reduce",
                    "+from operator import mul"
                ],
                "start_lineno": 5,
                "end_lineno": 5
            },
            {
                "hunk": [
                    "-        if arg.is_Mul:",
                    "-            args.extend(arg.args)",
                    "-            continue",
                    "-        if arg.is_Pow:",
                    "+        elif arg.is_Pow:"
                ],
                "start_lineno": 5908,
                "end_lineno": 5911
            },
            {
                "hunk": [
                    "+    if method == 'sqf':",
                    "+        factors = [(reduce(mul, (f for f, _ in factors if _ == k)), k)",
                    "+                   for k in set(i for _, i in factors)]"
                ],
                "start_lineno": 5952,
                "end_lineno": 5952
            }
        ]
    },
    "scikit-learn__scikit-learn-8554": {
        "sklearn/manifold/isomap.py": [
            {
                "hunk": [
                    "-        X = check_array(X)",
                    "+        X = check_array(X, accept_sparse='csr')"
                ],
                "start_lineno": 103,
                "end_lineno": 103
            }
        ],
        "sklearn/manifold/locally_linear.py": [
            {
                "hunk": [
                    "-    X : {array-like, sparse matrix, BallTree, KDTree, NearestNeighbors}",
                    "+    X : {array-like, NearestNeighbors}",
                    "         Sample data, shape = (n_samples, n_features), in the form of a",
                    "-        numpy array, sparse array, precomputed tree, or NearestNeighbors",
                    "-        object.",
                    "+        numpy array or a NearestNeighbors object."
                ],
                "start_lineno": 72,
                "end_lineno": 75
            },
            {
                "hunk": [
                    "-    X : {array-like, sparse matrix, BallTree, KDTree, NearestNeighbors}",
                    "+    X : {array-like, NearestNeighbors}",
                    "         Sample data, shape = (n_samples, n_features), in the form of a",
                    "-        numpy array, sparse array, precomputed tree, or NearestNeighbors",
                    "-        object.",
                    "+        numpy array or a NearestNeighbors object."
                ],
                "start_lineno": 197,
                "end_lineno": 200
            }
        ]
    },
    "matplotlib__matplotlib-26024": {
        "lib/matplotlib/_mathtext_data.py": [
            {
                "hunk": [
                    "-    'leftangle'                : 10216,",
                    "-    'rightangle'               : 10217,"
                ],
                "start_lineno": 1011,
                "end_lineno": 1012
            },
            {
                "hunk": [
                    "-    'dagger'                   : 8224",
                    "+    'dagger'                   : 8224,",
                    "+    'increment'                : 8710,",
                    "+    'smallin'                  : 8714,",
                    "+    'notsmallowns'             : 8716,",
                    "+    'smallowns'                : 8717,",
                    "+    'QED'                      : 8718,",
                    "+    'rightangle'               : 8735,",
                    "+    'smallintclockwise'        : 8753,",
                    "+    'smallvarointclockwise'    : 8754,",
                    "+    'smallointctrcclockwise'   : 8755,",
                    "+    'ratio'                    : 8758,",
                    "+    'minuscolon'               : 8761,",
                    "+    'dotsminusdots'            : 8762,",
                    "+    'sinewave'                 : 8767,",
                    "+    'simneqq'                  : 8774,",
                    "+    'nlesssim'                 : 8820,",
                    "+    'ngtrsim'                  : 8821,",
                    "+    'nlessgtr'                 : 8824,",
                    "+    'ngtrless'                 : 8825,",
                    "+    'cupleftarrow'             : 8844,",
                    "+    'oequal'                   : 8860,",
                    "+    'rightassert'              : 8870,",
                    "+    'rightModels'              : 8875,",
                    "+    'hermitmatrix'             : 8889,",
                    "+    'barvee'                   : 8893,",
                    "+    'measuredrightangle'       : 8894,",
                    "+    'varlrtriangle'            : 8895,",
                    "+    'equalparallel'            : 8917,",
                    "+    'npreccurlyeq'             : 8928,",
                    "+    'nsucccurlyeq'             : 8929,",
                    "+    'nsqsubseteq'              : 8930,",
                    "+    'nsqsupseteq'              : 8931,",
                    "+    'sqsubsetneq'              : 8932,",
                    "+    'sqsupsetneq'              : 8933,",
                    "+    'disin'                    : 8946,",
                    "+    'varisins'                 : 8947,",
                    "+    'isins'                    : 8948,",
                    "+    'isindot'                  : 8949,",
                    "+    'varisinobar'              : 8950,",
                    "+    'isinobar'                 : 8951,",
                    "+    'isinvb'                   : 8952,",
                    "+    'isinE'                    : 8953,",
                    "+    'nisd'                     : 8954,",
                    "+    'varnis'                   : 8955,",
                    "+    'nis'                      : 8956,",
                    "+    'varniobar'                : 8957,",
                    "+    'niobar'                   : 8958,",
                    "+    'bagmember'                : 8959,",
                    "+    'triangle'                 : 9651"
                ],
                "start_lineno": 1035,
                "end_lineno": 1035
            }
        ]
    },
    "pytest-dev__pytest-5205": {
        "src/_pytest/junitxml.py": [
            {
                "hunk": [
                    "+def _check_record_param_type(param, v):",
                    "+    \"\"\"Used by record_testsuite_property to check that the given parameter name is of the proper",
                    "+    type\"\"\"",
                    "+    __tracebackhide__ = True",
                    "+    if not isinstance(v, six.string_types):",
                    "+        msg = \"{param} parameter needs to be a string, but {g} given\"",
                    "+        raise TypeError(msg.format(param=param, g=type(v).__name__))",
                    "+",
                    "+",
                    "+@pytest.fixture(scope=\"session\")",
                    "+def record_testsuite_property(request):",
                    "+    \"\"\"",
                    "+    Records a new ``<property>`` tag as child of the root ``<testsuite>``. This is suitable to",
                    "+    writing global information regarding the entire test suite, and is compatible with ``xunit2`` JUnit family.",
                    "+",
                    "+    This is a ``session``-scoped fixture which is called with ``(name, value)``. Example:",
                    "+",
                    "+    .. code-block:: python",
                    "+",
                    "+        def test_foo(record_testsuite_property):",
                    "+            record_testsuite_property(\"ARCH\", \"PPC\")",
                    "+            record_testsuite_property(\"STORAGE_TYPE\", \"CEPH\")",
                    "+",
                    "+    ``name`` must be a string, ``value`` will be converted to a string and properly xml-escaped.",
                    "+    \"\"\"",
                    "+",
                    "+    __tracebackhide__ = True",
                    "+",
                    "+    def record_func(name, value):",
                    "+        \"\"\"noop function in case --junitxml was not passed in the command-line\"\"\"",
                    "+        __tracebackhide__ = True",
                    "+        _check_record_param_type(\"name\", name)",
                    "+",
                    "+    xml = getattr(request.config, \"_xml\", None)",
                    "+    if xml is not None:",
                    "+        record_func = xml.add_global_property  # noqa",
                    "+    return record_func",
                    "+",
                    "+"
                ],
                "start_lineno": 348,
                "end_lineno": 348
            },
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 447,
                "end_lineno": 447
            },
            {
                "hunk": [
                    "-        self.global_properties.append((str(name), bin_xml_escape(value)))",
                    "+        __tracebackhide__ = True",
                    "+        _check_record_param_type(\"name\", name)",
                    "+        self.global_properties.append((name, bin_xml_escape(value)))"
                ],
                "start_lineno": 635,
                "end_lineno": 635
            }
        ]
    },
    "scikit-learn__scikit-learn-13328": {
        "sklearn/linear_model/huber.py": [
            {
                "hunk": [
                    "-            X, y, copy=False, accept_sparse=['csr'], y_numeric=True)",
                    "+            X, y, copy=False, accept_sparse=['csr'], y_numeric=True,",
                    "+            dtype=[np.float64, np.float32])"
                ],
                "start_lineno": 254,
                "end_lineno": 254
            }
        ]
    },
    "sphinx-doc__sphinx-7440": {
        "sphinx/domains/std.py": [
            {
                "hunk": [
                    "-    std.note_object('term', termtext.lower(), node_id, location=term)",
                    "+    std.note_object('term', termtext, node_id, location=term)"
                ],
                "start_lineno": 308,
                "end_lineno": 308
            },
            {
                "hunk": [
                    "-        'term':    XRefRole(lowercase=True, innernodeclass=nodes.inline,",
                    "+        'term':    XRefRole(innernodeclass=nodes.inline,"
                ],
                "start_lineno": 568,
                "end_lineno": 568
            }
        ]
    },
    "sphinx-doc__sphinx-9260": {
        "sphinx/builders/linkcheck.py": [
            {
                "hunk": [
                    "-from urllib.parse import unquote, urlparse",
                    "+from urllib.parse import unquote, urlparse, urlunparse"
                ],
                "start_lineno": 24,
                "end_lineno": 24
            },
            {
                "hunk": [
                    "+            newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)",
                    "+            if newuri:",
                    "+                uri = newuri",
                    "+"
                ],
                "start_lineno": 630,
                "end_lineno": 630
            },
            {
                "hunk": [
                    "+                newuri = self.app.emit_firstresult('linkcheck-process-uri', uri)",
                    "+                if newuri:",
                    "+                    uri = newuri",
                    "+",
                    "                 lineno = get_node_line(imgnode)",
                    "                 uri_info = Hyperlink(uri, self.env.docname, lineno)",
                    "                 if uri not in hyperlinks:",
                    "                     hyperlinks[uri] = uri_info",
                    " ",
                    " ",
                    "+def rewrite_github_anchor(app: Sphinx, uri: str) -> Optional[str]:",
                    "+    \"\"\"Rewrite anchor name of the hyperlink to github.com",
                    "+",
                    "+    The hyperlink anchors in github.com are dynamically generated.  This rewrites",
                    "+    them before checking and makes them comparable.",
                    "+    \"\"\"",
                    "+    parsed = urlparse(uri)",
                    "+    if parsed.hostname == \"github.com\" and parsed.fragment:",
                    "+        prefixed = parsed.fragment.startswith('user-content-')",
                    "+        if not prefixed:",
                    "+            fragment = f'user-content-{parsed.fragment}'",
                    "+            return urlunparse(parsed._replace(fragment=fragment))",
                    "+    return None",
                    "+",
                    "+"
                ],
                "start_lineno": 639,
                "end_lineno": 644
            },
            {
                "hunk": [
                    "+    app.add_event('linkcheck-process-uri')",
                    "+    app.connect('linkcheck-process-uri', rewrite_github_anchor)",
                    "+"
                ],
                "start_lineno": 661,
                "end_lineno": 661
            }
        ]
    },
    "mwaskom__seaborn-3394": {
        "seaborn/_core/plot.py": [
            {
                "hunk": [
                    "-            # Now the transformed data series are complete, set update the layer data",
                    "+            # Now the transformed data series are complete, update the layer data",
                    "             for layer, new_series in zip(layers, transformed_data):",
                    "                 layer_df = layer[\"data\"].frame",
                    "                 if var in layer_df:",
                    "-                    layer_df[var] = new_series",
                    "+                    layer_df[var] = pd.to_numeric(new_series)"
                ],
                "start_lineno": 1395,
                "end_lineno": 1399
            }
        ],
        "seaborn/_core/rules.py": [
            {
                "hunk": [
                    "+    # Now drop nulls to simplify further type inference",
                    "+    vector = vector.dropna()",
                    "+"
                ],
                "start_lineno": 77,
                "end_lineno": 77
            },
            {
                "hunk": [
                    "-            boolean_vector = bool(np.isin(vector.dropna(), [0, 1]).all())",
                    "+            boolean_vector = bool(np.isin(vector, [0, 1]).all())"
                ],
                "start_lineno": 97,
                "end_lineno": 97
            }
        ],
        "seaborn/_oldcore.py": [
            {
                "hunk": [
                    "-                    comp = pd.to_numeric(converter.convert_units(orig))",
                    "+                    comp = pd.to_numeric(converter.convert_units(orig)).astype(float)"
                ],
                "start_lineno": 1131,
                "end_lineno": 1131
            },
            {
                "hunk": [
                    "+    # At this point, drop nans to simplify further type inference",
                    "+    vector = vector.dropna()",
                    "+"
                ],
                "start_lineno": 1508,
                "end_lineno": 1508
            },
            {
                "hunk": [
                    "-        if np.isin(vector.dropna(), [0, 1]).all():",
                    "+        if np.isin(vector, [0, 1]).all():"
                ],
                "start_lineno": 1520,
                "end_lineno": 1520
            }
        ]
    },
    "astropy__astropy-13933": {
        "astropy/coordinates/angles.py": [
            {
                "hunk": [
                    "+import functools"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-        return u.hourangle if unit is u.hour else unit",
                    "+        return u.hourangle if unit == u.hour else unit"
                ],
                "start_lineno": 160,
                "end_lineno": 160
            },
            {
                "hunk": [
                    "-            If `True`, a decimal representation will be used, otherwise",
                    "-            the returned string will be in sexagesimal form.",
                    "+            If `False`, the returned string will be in sexagesimal form",
                    "+            if possible (for units of degrees or hourangle).  If `True`,",
                    "+            a decimal representation will be used. In that case, no unit",
                    "+            will be appended if ``format`` is not explicitly given."
                ],
                "start_lineno": 214,
                "end_lineno": 215
            },
            {
                "hunk": [
                    "-            None: {",
                    "+            'generic': {"
                ],
                "start_lineno": 277,
                "end_lineno": 277
            },
            {
                "hunk": [
                    "-",
                    "-        if sep == 'fromunit':",
                    "-            if format not in separators:",
                    "-                raise ValueError(f\"Unknown format '{format}'\")",
                    "-            seps = separators[format]",
                    "-            if unit in seps:",
                    "-                sep = seps[unit]",
                    "+        # Default separators are as for generic.",
                    "+        separators[None] = separators['generic']",
                    " ",
                    "         # Create an iterator so we can format each element of what",
                    "         # might be an array.",
                    "-        if unit is u.degree:",
                    "-            if decimal:",
                    "-                values = self.degree",
                    "-                if precision is not None:",
                    "-                    func = (\"{0:0.\" + str(precision) + \"f}\").format",
                    "-                else:",
                    "-                    func = '{:g}'.format",
                    "-            else:",
                    "-                if sep == 'fromunit':",
                    "-                    sep = 'dms'",
                    "-                values = self.degree",
                    "-                func = lambda x: form.degrees_to_string(",
                    "-                    x, precision=precision, sep=sep, pad=pad,",
                    "-                    fields=fields)",
                    "-",
                    "-        elif unit is u.hourangle:",
                    "-            if decimal:",
                    "-                values = self.hour",
                    "-                if precision is not None:",
                    "-                    func = (\"{0:0.\" + str(precision) + \"f}\").format",
                    "-                else:",
                    "-                    func = '{:g}'.format",
                    "-            else:",
                    "-                if sep == 'fromunit':",
                    "-                    sep = 'hms'",
                    "-                values = self.hour",
                    "-                func = lambda x: form.hours_to_string(",
                    "-                    x, precision=precision, sep=sep, pad=pad,",
                    "-                    fields=fields)",
                    "-",
                    "-        elif unit.is_equivalent(u.radian):",
                    "-            if decimal:",
                    "-                values = self.to_value(unit)",
                    "-                if precision is not None:",
                    "-                    func = (\"{0:1.\" + str(precision) + \"f}\").format",
                    "-                else:",
                    "-                    func = \"{:g}\".format",
                    "-            elif sep == 'fromunit':",
                    "-                values = self.to_value(unit)",
                    "+        if not decimal and (unit_is_deg := unit == u.degree",
                    "+                            or unit == u.hourangle):",
                    "+            # Sexagesimal.",
                    "+            if sep == 'fromunit':",
                    "+                if format not in separators:",
                    "+                    raise ValueError(f\"Unknown format '{format}'\")",
                    "+                sep = separators[format][unit]",
                    "+            func = functools.partial(",
                    "+                form.degrees_to_string if unit_is_deg else form.hours_to_string,",
                    "+                precision=precision, sep=sep, pad=pad, fields=fields)",
                    "+        else:",
                    "+            if sep != 'fromunit':",
                    "+                raise ValueError(f\"'{unit}' can not be represented in sexagesimal notation\")",
                    "+            func = (\"{:g}\" if precision is None else f\"{{0:0.{precision}f}}\").format",
                    "+            if not (decimal and format is None):  # Don't add unit by default for decimal.",
                    "                 unit_string = unit.to_string(format=format)",
                    "                 if format == 'latex' or format == 'latex_inline':",
                    "                     unit_string = unit_string[1:-1]",
                    "-",
                    "-                if precision is not None:",
                    "-                    def plain_unit_format(val):",
                    "-                        return (\"{0:0.\" + str(precision) + \"f}{1}\").format(",
                    "-                            val, unit_string)",
                    "-                    func = plain_unit_format",
                    "-                else:",
                    "-                    def plain_unit_format(val):",
                    "-                        return f\"{val:g}{unit_string}\"",
                    "-                    func = plain_unit_format",
                    "-            else:",
                    "-                raise ValueError(",
                    "-                    f\"'{unit.name}' can not be represented in sexagesimal notation\")",
                    "-",
                    "-        else:",
                    "-            raise u.UnitsError(",
                    "-                \"The unit value provided is not an angular unit.\")",
                    "+                format_func = func",
                    "+                func = lambda x: format_func(x) + unit_string"
                ],
                "start_lineno": 290,
                "end_lineno": 358
            },
            {
                "hunk": [
                    "+        values = self.to_value(unit)"
                ],
                "start_lineno": 373,
                "end_lineno": 373
            },
            {
                "hunk": [
                    "+        # For speed, compare using \"is\", which is not strictly guaranteed to hold,",
                    "+        # but if it doesn't we'll just convert correctly in the 'else' clause."
                ],
                "start_lineno": 584,
                "end_lineno": 584
            }
        ],
        "astropy/visualization/wcsaxes/formatter_locator.py": [
            {
                "hunk": [
                    "-                # At the moment, the Angle class doesn't have a consistent way",
                    "-                # to always convert angles to strings in decimal form with",
                    "-                # symbols for units (instead of e.g 3arcsec). So as a workaround",
                    "-                # we take advantage of the fact that Angle.to_string converts",
                    "-                # the unit to a string manually when decimal=False and the unit",
                    "-                # is not strictly u.degree or u.hourangle",
                    "                 if self.show_decimal_unit:",
                    "-                    decimal = False"
                ],
                "start_lineno": 397,
                "end_lineno": 404
            },
            {
                "hunk": [
                    "-                            fmt = None",
                    "+                            fmt = 'generic'",
                    "                     unit = CUSTOM_UNITS.get(unit, unit)",
                    "                 else:",
                    "-                    sep = None",
                    "+                    sep = 'fromunit'"
                ],
                "start_lineno": 412,
                "end_lineno": 415
            }
        ]
    },
    "django__django-15037": {
        "django/core/management/commands/inspectdb.py": [
            {
                "hunk": [
                    "+                        ref_db_column, ref_db_table = relations[column_name]",
                    "                         if extra_params.pop('unique', False) or extra_params.get('primary_key'):",
                    "                             rel_type = 'OneToOneField'",
                    "                         else:",
                    "                             rel_type = 'ForeignKey'",
                    "+                            ref_pk_column = connection.introspection.get_primary_key_column(cursor, ref_db_table)",
                    "+                            if ref_pk_column and ref_pk_column != ref_db_column:",
                    "+                                extra_params['to_field'] = ref_db_column",
                    "                         rel_to = (",
                    "-                            \"self\" if relations[column_name][1] == table_name",
                    "-                            else table2model(relations[column_name][1])",
                    "+                            'self' if ref_db_table == table_name",
                    "+                            else table2model(ref_db_table)"
                ],
                "start_lineno": 119,
                "end_lineno": 125
            }
        ]
    },
    "sympy__sympy-12481": {
        "sympy/combinatorics/permutations.py": [
            {
                "hunk": [
                    "-        if has_dups(temp):",
                    "-            if is_cycle:",
                    "-                raise ValueError('there were repeated elements; to resolve '",
                    "-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))",
                    "-            else:",
                    "-                raise ValueError('there were repeated elements.')",
                    "+        if has_dups(temp) and not is_cycle:",
                    "+            raise ValueError('there were repeated elements.')"
                ],
                "start_lineno": 898,
                "end_lineno": 903
            }
        ]
    },
    "sphinx-doc__sphinx-7305": {
        "sphinx/pycode/ast.py": [
            {
                "hunk": [
                    "-from typing import List",
                    "+from typing import Dict, List, Type"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "+OPERATORS = {",
                    "+    ast.Add: \"+\",",
                    "+    ast.And: \"and\",",
                    "+    ast.BitAnd: \"&\",",
                    "+    ast.BitOr: \"|\",",
                    "+    ast.BitXor: \"^\",",
                    "+    ast.Div: \"/\",",
                    "+    ast.FloorDiv: \"//\",",
                    "+    ast.Invert: \"~\",",
                    "+    ast.LShift: \"<<\",",
                    "+    ast.MatMult: \"@\",",
                    "+    ast.Mult: \"*\",",
                    "+    ast.Mod: \"%\",",
                    "+    ast.Not: \"not\",",
                    "+    ast.Pow: \"**\",",
                    "+    ast.Or: \"or\",",
                    "+    ast.RShift: \">>\",",
                    "+    ast.Sub: \"-\",",
                    "+    ast.UAdd: \"+\",",
                    "+    ast.USub: \"-\",",
                    "+}  # type: Dict[Type[ast.AST], str]",
                    "+",
                    "+"
                ],
                "start_lineno": 24,
                "end_lineno": 24
            },
            {
                "hunk": [
                    "+    elif node.__class__ in OPERATORS:",
                    "+        return OPERATORS[node.__class__]"
                ],
                "start_lineno": 44,
                "end_lineno": 44
            },
            {
                "hunk": [
                    "+    elif isinstance(node, ast.BinOp):",
                    "+        return \" \".join(unparse(e) for e in [node.left, node.op, node.right])",
                    "+    elif isinstance(node, ast.BoolOp):",
                    "+        op = \" %s \" % unparse(node.op)",
                    "+        return op.join(unparse(e) for e in node.values)"
                ],
                "start_lineno": 53,
                "end_lineno": 53
            },
            {
                "hunk": [
                    "+    elif isinstance(node, ast.UnaryOp):",
                    "+        return \"%s %s\" % (unparse(node.op), unparse(node.operand))"
                ],
                "start_lineno": 84,
                "end_lineno": 84
            }
        ]
    },
    "django__django-14373": {
        "django/utils/dateformat.py": [
            {
                "hunk": [
                    "-        \"Year, 4 digits; e.g. '1999'\"",
                    "-        return self.data.year",
                    "+        \"\"\"Year, 4 digits with leading zeros; e.g. '1999'.\"\"\"",
                    "+        return '%04d' % self.data.year"
                ],
                "start_lineno": 316,
                "end_lineno": 317
            }
        ]
    },
    "django__django-15423": {
        "django/conf/__init__.py": [
            {
                "hunk": [
                    "-        # Stack index: -1 this line, -2 the caller.",
                    "-        filename, _, _, _ = stack[-2]",
                    "+        # Stack index: -1 this line, -2 the LazyObject __getattribute__(),",
                    "+        # -3 the caller.",
                    "+        filename, _, _, _ = stack[-3]"
                ],
                "start_lineno": 160,
                "end_lineno": 161
            }
        ],
        "django/utils/functional.py": [
            {
                "hunk": [
                    "+    inner._mask_wrapped = False"
                ],
                "start_lineno": 269,
                "end_lineno": 269
            },
            {
                "hunk": [
                    "+    def __getattribute__(self, name):",
                    "+        value = super().__getattribute__(name)",
                    "+        # If attribute is a proxy method, raise an AttributeError to call",
                    "+        # __getattr__() and use the wrapped object method.",
                    "+        if not getattr(value, \"_mask_wrapped\", True):",
                    "+            raise AttributeError",
                    "+        return value",
                    "+"
                ],
                "start_lineno": 289,
                "end_lineno": 289
            }
        ]
    },
    "pylint-dev__pylint-4398": {
        "pylint/lint/pylinter.py": [
            {
                "hunk": [
                    "+            (",
                    "+                \"fail-on\",",
                    "+                {",
                    "+                    \"default\": \"\",",
                    "+                    \"type\": \"csv\",",
                    "+                    \"metavar\": \"<msg ids>\",",
                    "+                    \"help\": \"Return non-zero exit code if any of these messages/categories are detected,\"",
                    "+                    \" even if score is above --fail-under value. Syntax same as enable.\"",
                    "+                    \" Messages specified are enabled, while categories only check already-enabled messages.\",",
                    "+                },",
                    "+            ),"
                ],
                "start_lineno": 267,
                "end_lineno": 267
            },
            {
                "hunk": [
                    "+        self.fail_on_symbols = []"
                ],
                "start_lineno": 453,
                "end_lineno": 453
            },
            {
                "hunk": [
                    "+    def enable_fail_on_messages(self):",
                    "+        \"\"\"enable 'fail on' msgs",
                    "+",
                    "+        Convert values in config.fail_on (which might be msg category, msg id,",
                    "+        or symbol) to specific msgs, then enable and flag them for later.",
                    "+        \"\"\"",
                    "+        fail_on_vals = self.config.fail_on",
                    "+        if not fail_on_vals:",
                    "+            return",
                    "+",
                    "+        fail_on_cats = set()",
                    "+        fail_on_msgs = set()",
                    "+        for val in fail_on_vals:",
                    "+            # If value is a cateogry, add category, else add message",
                    "+            if val in MSG_TYPES:",
                    "+                fail_on_cats.add(val)",
                    "+            else:",
                    "+                fail_on_msgs.add(val)",
                    "+",
                    "+        # For every message in every checker, if cat or msg flagged, enable check",
                    "+        for all_checkers in self._checkers.values():",
                    "+            for checker in all_checkers:",
                    "+                for msg in checker.messages:",
                    "+                    if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:",
                    "+                        # message id/symbol matched, enable and flag it",
                    "+                        self.enable(msg.msgid)",
                    "+                        self.fail_on_symbols.append(msg.symbol)",
                    "+                    elif msg.msgid[0] in fail_on_cats:",
                    "+                        # message starts with a cateogry value, flag (but do not enable) it",
                    "+                        self.fail_on_symbols.append(msg.symbol)",
                    "+",
                    "+    def any_fail_on_issues(self):",
                    "+        return any(x in self.fail_on_symbols for x in self.stats[\"by_msg\"])",
                    "+"
                ],
                "start_lineno": 612,
                "end_lineno": 612
            }
        ],
        "pylint/lint/run.py": [
            {
                "hunk": [
                    "+        # Now that plugins are loaded, get list of all fail_on messages, and enable them",
                    "+        linter.enable_fail_on_messages()",
                    "+"
                ],
                "start_lineno": 371,
                "end_lineno": 371
            },
            {
                "hunk": [
                    "-                if score_value and score_value >= linter.config.fail_under:",
                    "+                if (",
                    "+                    score_value",
                    "+                    and score_value >= linter.config.fail_under",
                    "+                    # detected messages flagged by --fail-on prevent non-zero exit code",
                    "+                    and not linter.any_fail_on_issues()",
                    "+                ):"
                ],
                "start_lineno": 395,
                "end_lineno": 395
            }
        ]
    },
    "django__django-14019": {
        "django/contrib/postgres/constraints.py": [
            {
                "hunk": [
                    "-        return '<%s: index_type=%s, expressions=%s%s%s%s%s>' % (",
                    "+        return '<%s: index_type=%s expressions=%s name=%s%s%s%s%s>' % (",
                    "             self.__class__.__qualname__,",
                    "-            self.index_type,",
                    "-            self.expressions,",
                    "-            '' if self.condition is None else ', condition=%s' % self.condition,",
                    "-            '' if self.deferrable is None else ', deferrable=%s' % self.deferrable,",
                    "-            '' if not self.include else ', include=%s' % repr(self.include),",
                    "-            '' if not self.opclasses else ', opclasses=%s' % repr(self.opclasses),",
                    "+            repr(self.index_type),",
                    "+            repr(self.expressions),",
                    "+            repr(self.name),",
                    "+            '' if self.condition is None else ' condition=%s' % self.condition,",
                    "+            '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,",
                    "+            '' if not self.include else ' include=%s' % repr(self.include),",
                    "+            '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),"
                ],
                "start_lineno": 158,
                "end_lineno": 165
            }
        ],
        "django/db/models/constraints.py": [
            {
                "hunk": [
                    "-        return \"<%s: check='%s' name=%r>\" % (self.__class__.__name__, self.check, self.name)",
                    "+        return '<%s: check=%s name=%s>' % (",
                    "+            self.__class__.__qualname__,",
                    "+            self.check,",
                    "+            repr(self.name),",
                    "+        )"
                ],
                "start_lineno": 61,
                "end_lineno": 61
            },
            {
                "hunk": [
                    "-        return '<%s: fields=%r name=%r%s%s%s%s>' % (",
                    "-            self.__class__.__name__, self.fields, self.name,",
                    "+        return '<%s: fields=%s name=%s%s%s%s%s>' % (",
                    "+            self.__class__.__qualname__,",
                    "+            repr(self.fields),",
                    "+            repr(self.name),"
                ],
                "start_lineno": 164,
                "end_lineno": 165
            }
        ],
        "django/db/models/indexes.py": [
            {
                "hunk": [
                    "-        return '<%s:%s%s%s%s%s>' % (",
                    "-            self.__class__.__name__,",
                    "-            '' if not self.fields else \" fields='%s'\" % ', '.join(self.fields),",
                    "-            '' if not self.expressions else \" expressions='%s'\" % ', '.join([",
                    "-                str(expression) for expression in self.expressions",
                    "-            ]),",
                    "+        return '<%s:%s%s%s%s%s%s%s>' % (",
                    "+            self.__class__.__qualname__,",
                    "+            '' if not self.fields else ' fields=%s' % repr(self.fields),",
                    "+            '' if not self.expressions else ' expressions=%s' % repr(self.expressions),",
                    "+            '' if not self.name else ' name=%s' % repr(self.name),",
                    "+            ''",
                    "+            if self.db_tablespace is None",
                    "+            else ' db_tablespace=%s' % repr(self.db_tablespace),",
                    "             '' if self.condition is None else ' condition=%s' % self.condition,",
                    "-            '' if not self.include else \" include='%s'\" % ', '.join(self.include),",
                    "-            '' if not self.opclasses else \" opclasses='%s'\" % ', '.join(self.opclasses),",
                    "+            '' if not self.include else ' include=%s' % repr(self.include),",
                    "+            '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),"
                ],
                "start_lineno": 172,
                "end_lineno": 180
            }
        ]
    },
    "django__django-10904": {
        "django/contrib/auth/password_validation.py": [
            {
                "hunk": [
                    "-        except IOError:",
                    "+        except OSError:"
                ],
                "start_lineno": 176,
                "end_lineno": 176
            }
        ],
        "django/contrib/gis/gdal/libgdal.py": [
            {
                "hunk": [
                    "-except (AttributeError, EnvironmentError,",
                    "-        ImportError, ImproperlyConfigured):",
                    "+except (AttributeError, ImportError, ImproperlyConfigured, OSError):"
                ],
                "start_lineno": 16,
                "end_lineno": 17
            }
        ],
        "django/contrib/gis/geos/libgeos.py": [
            {
                "hunk": [
                    "-    except (AttributeError, EnvironmentError,",
                    "-            ImportError, ImproperlyConfigured):",
                    "+    except (AttributeError, ImportError, ImproperlyConfigured, OSError):"
                ],
                "start_lineno": 26,
                "end_lineno": 27
            }
        ],
        "django/contrib/sessions/backends/file.py": [
            {
                "hunk": [
                    "-        except (IOError, SuspiciousOperation):",
                    "+        except (OSError, SuspiciousOperation):"
                ],
                "start_lineno": 97,
                "end_lineno": 97
            },
            {
                "hunk": [
                    "-        except (OSError, IOError, EOFError):",
                    "+        except (EOFError, OSError):"
                ],
                "start_lineno": 169,
                "end_lineno": 169
            }
        ],
        "django/contrib/staticfiles/storage.py": [
            {
                "hunk": [
                    "-            except IOError:",
                    "+            except OSError:"
                ],
                "start_lineno": 96,
                "end_lineno": 96
            },
            {
                "hunk": [
                    "-        except IOError:",
                    "+        except OSError:"
                ],
                "start_lineno": 383,
                "end_lineno": 383
            }
        ],
        "django/core/files/move.py": [
            {
                "hunk": [
                    "-    ``IOError``.",
                    "+    ``FileExistsError``."
                ],
                "start_lineno": 38,
                "end_lineno": 38
            },
            {
                "hunk": [
                    "-            raise IOError(\"Destination file %s exists and allow_overwrite is False\" % new_file_name)",
                    "+            raise FileExistsError('Destination file %s exists and allow_overwrite is False.' % new_file_name)"
                ],
                "start_lineno": 46,
                "end_lineno": 46
            }
        ],
        "django/core/files/storage.py": [
            {
                "hunk": [
                    "-            raise IOError(\"%s exists and is not a directory.\" % directory)",
                    "+            raise FileExistsError('%s exists and is not a directory.' % directory)"
                ],
                "start_lineno": 249,
                "end_lineno": 249
            }
        ],
        "django/core/files/temp.py": [
            {
                "hunk": [
                    "-                except (OSError, IOError):",
                    "+                except OSError:"
                ],
                "start_lineno": 53,
                "end_lineno": 53
            }
        ],
        "django/core/mail/backends/smtp.py": [
            {
                "hunk": [
                    "-import socket"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-        except (smtplib.SMTPException, socket.error):",
                    "+        except OSError:"
                ],
                "start_lineno": 72,
                "end_lineno": 72
            }
        ],
        "django/core/management/commands/compilemessages.py": [
            {
                "hunk": [
                    "-    except (IOError, OSError):",
                    "+    except OSError:"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            }
        ],
        "django/core/management/commands/runserver.py": [
            {
                "hunk": [
                    "-        except socket.error as e:",
                    "+        except OSError as e:"
                ],
                "start_lineno": 140,
                "end_lineno": 140
            }
        ],
        "django/core/management/templates.py": [
            {
                "hunk": [
                    "-        except IOError as e:",
                    "+        except OSError as e:"
                ],
                "start_lineno": 260,
                "end_lineno": 260
            },
            {
                "hunk": [
                    "-        except (archive.ArchiveException, IOError) as e:",
                    "+        except (archive.ArchiveException, OSError) as e:"
                ],
                "start_lineno": 315,
                "end_lineno": 315
            }
        ],
        "django/core/servers/basehttp.py": [
            {
                "hunk": [
                    "-    exc_type, exc_value = sys.exc_info()[:2]",
                    "-    return issubclass(exc_type, socket.error) and exc_value.args[0] == 32",
                    "+    exc_type, _, _ = sys.exc_info()",
                    "+    return issubclass(exc_type, BrokenPipeError)"
                ],
                "start_lineno": 54,
                "end_lineno": 55
            },
            {
                "hunk": [
                    "-        except (socket.error, AttributeError):",
                    "+        except (AttributeError, OSError):"
                ],
                "start_lineno": 174,
                "end_lineno": 174
            }
        ],
        "django/http/request.py": [
            {
                "hunk": [
                    "-class UnreadablePostError(IOError):",
                    "+class UnreadablePostError(OSError):"
                ],
                "start_lineno": 25,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "-            except IOError as e:",
                    "+            except OSError as e:"
                ],
                "start_lineno": 287,
                "end_lineno": 287
            },
            {
                "hunk": [
                    "-        except IOError as e:",
                    "+        except OSError as e:",
                    "             raise UnreadablePostError(*e.args) from e",
                    " ",
                    "     def readline(self, *args, **kwargs):",
                    "         self._read_started = True",
                    "         try:",
                    "             return self._stream.readline(*args, **kwargs)",
                    "-        except IOError as e:",
                    "+        except OSError as e:"
                ],
                "start_lineno": 342,
                "end_lineno": 349
            }
        ],
        "django/http/response.py": [
            {
                "hunk": [
                    "-        raise IOError(\"This %s instance is not writable\" % self.__class__.__name__)",
                    "+        raise OSError('This %s instance is not writable' % self.__class__.__name__)",
                    " ",
                    "     def flush(self):",
                    "         pass",
                    " ",
                    "     def tell(self):",
                    "-        raise IOError(\"This %s instance cannot tell its position\" % self.__class__.__name__)",
                    "+        raise OSError('This %s instance cannot tell its position' % self.__class__.__name__)"
                ],
                "start_lineno": 254,
                "end_lineno": 260
            },
            {
                "hunk": [
                    "-        raise IOError(\"This %s instance is not writable\" % self.__class__.__name__)",
                    "+        raise OSError('This %s instance is not writable' % self.__class__.__name__)"
                ],
                "start_lineno": 275,
                "end_lineno": 275
            }
        ],
        "django/middleware/csrf.py": [
            {
                "hunk": [
                    "-                except IOError:",
                    "+                except OSError:"
                ],
                "start_lineno": 296,
                "end_lineno": 296
            }
        ],
        "django/utils/translation/trans_real.py": [
            {
                "hunk": [
                    "-            raise IOError(\"No translation files found for default language %s.\" % settings.LANGUAGE_CODE)",
                    "+            raise OSError('No translation files found for default language %s.' % settings.LANGUAGE_CODE)"
                ],
                "start_lineno": 102,
                "end_lineno": 102
            }
        ],
        "django/views/debug.py": [
            {
                "hunk": [
                    "-            except (OSError, IOError):",
                    "+            except OSError:"
                ],
                "start_lineno": 360,
                "end_lineno": 360
            }
        ]
    },
    "scikit-learn__scikit-learn-14458": {
        "sklearn/linear_model/base.py": [
            {
                "hunk": [
                    "+        X = np.ascontiguousarray(X)"
                ],
                "start_lineno": 94,
                "end_lineno": 94
            }
        ],
        "sklearn/linear_model/ridge.py": [
            {
                "hunk": [
                    "-        y = check_array(y, dtype=X.dtype, ensure_2d=False, order=\"C\")",
                    "+        y = check_array(y, dtype=X.dtype, ensure_2d=False, order=None)"
                ],
                "start_lineno": 412,
                "end_lineno": 412
            }
        ]
    },
    "sympy__sympy-15011": {
        "sympy/utilities/lambdify.py": [
            {
                "hunk": [
                    "-",
                    "     def _preprocess(self, args, expr):",
                    "         \"\"\"Preprocess args, expr to replace arguments that do not map",
                    "         to valid Python identifiers.",
                    " ",
                    "         Returns string form of args, and updated expr.",
                    "         \"\"\"",
                    "-        from sympy import Dummy, Symbol, Function, flatten",
                    "+        from sympy import Dummy, Symbol, MatrixSymbol, Function, flatten"
                ],
                "start_lineno": 703,
                "end_lineno": 710
            },
            {
                "hunk": [
                    "-            elif isinstance(arg, Symbol):",
                    "+            elif isinstance(arg, Symbol) or isinstance(arg, MatrixSymbol):"
                ],
                "start_lineno": 728,
                "end_lineno": 728
            },
            {
                "hunk": [
                    "-                argstrs.append(str(arg))",
                    "+                argrep = self._argrepr(arg)",
                    "+",
                    "+                if dummify:",
                    "+                    dummy = Dummy()",
                    "+                    argstrs.append(self._argrepr(dummy))",
                    "+                    expr = self._subexpr(expr, {arg: dummy})",
                    "+                else:",
                    "+                    argstrs.append(str(arg))"
                ],
                "start_lineno": 742,
                "end_lineno": 742
            }
        ]
    },
    "sympy__sympy-13437": {
        "sympy/functions/combinatorial/numbers.py": [
            {
                "hunk": [
                    "+        if n is S.Infinity:",
                    "+            if k_sym is None:",
                    "+                return S.Infinity",
                    "+            else:",
                    "+                raise ValueError(\"Bell polynomial is not defined\")",
                    "+",
                    "+        if n.is_negative or n.is_integer is False:",
                    "+            raise ValueError(\"a non-negative integer expected\")",
                    "+"
                ],
                "start_lineno": 427,
                "end_lineno": 427
            }
        ]
    },
    "scikit-learn__scikit-learn-10687": {
        "sklearn/linear_model/coordinate_descent.py": [
            {
                "hunk": [
                    "+            self.coef_ = coef_[0]",
                    "+            self.dual_gap_ = dual_gaps_[0]",
                    "+        else:",
                    "+            self.coef_ = coef_",
                    "+            self.dual_gap_ = dual_gaps_",
                    " ",
                    "-        self.coef_, self.dual_gap_ = map(np.squeeze, [coef_, dual_gaps_])"
                ],
                "start_lineno": 765,
                "end_lineno": 766
            }
        ]
    },
    "scikit-learn__scikit-learn-13485": {
        "sklearn/calibration.py": [
            {
                "hunk": [
                    "-                         force_all_finite=False)",
                    "+                         force_all_finite=False, allow_nd=True)"
                ],
                "start_lineno": 134,
                "end_lineno": 134
            }
        ]
    },
    "django__django-11583": {
        "django/utils/autoreload.py": [
            {
                "hunk": [
                    "+        except ValueError as e:",
                    "+            # Network filesystems may return null bytes in file paths.",
                    "+            logger.debug('\"%s\" raised when resolving path: \"%s\"' % (str(e), path))",
                    "+            continue"
                ],
                "start_lineno": 146,
                "end_lineno": 146
            }
        ]
    },
    "django__django-16693": {
        "django/template/context.py": [
            {
                "hunk": [
                    "-            updates.update(processor(self.request))",
                    "+            context = processor(self.request)",
                    "+            try:",
                    "+                updates.update(context)",
                    "+            except TypeError as e:",
                    "+                raise TypeError(",
                    "+                    f\"Context processor {processor.__qualname__} didn't return a \"",
                    "+                    \"dictionary.\"",
                    "+                ) from e",
                    "+"
                ],
                "start_lineno": 254,
                "end_lineno": 254
            }
        ]
    },
    "pydata__xarray-3635": {
        "xarray/core/variable.py": [
            {
                "hunk": [
                    "+        # TODO: remove once numpy >= 1.15.0 is the minimum requirement",
                    "+        if np.count_nonzero(q < 0.0) or np.count_nonzero(q > 1.0):",
                    "+            raise ValueError(\"Quantiles must be in the range [0, 1]\")",
                    "+"
                ],
                "start_lineno": 1734,
                "end_lineno": 1734
            },
            {
                "hunk": [
                    "+",
                    "+            # TODO: use np.nanquantile once numpy >= 1.15.0 is the minimum requirement"
                ],
                "start_lineno": 1742,
                "end_lineno": 1742
            }
        ]
    },
    "psf__requests-2674": {
        "requests/adapters.py": [
            {
                "hunk": [
                    "+from .packages.urllib3.exceptions import ClosedPoolError"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "+        except ClosedPoolError as e:",
                    "+            raise ConnectionError(e, request=request)",
                    "+"
                ],
                "start_lineno": 424,
                "end_lineno": 424
            }
        ]
    },
    "scikit-learn__scikit-learn-13641": {
        "sklearn/feature_extraction/text.py": [
            {
                "hunk": [
                    "+from ..exceptions import ChangedBehaviorWarning"
                ],
                "start_lineno": 34,
                "end_lineno": 34
            },
            {
                "hunk": [
                    "+    def _validate_custom_analyzer(self):",
                    "+        # This is to check if the given custom analyzer expects file or a",
                    "+        # filename instead of data.",
                    "+        # Behavior changed in v0.21, function could be removed in v0.23",
                    "+        import tempfile",
                    "+        with tempfile.NamedTemporaryFile() as f:",
                    "+            fname = f.name",
                    "+        # now we're sure fname doesn't exist",
                    "+",
                    "+        msg = (\"Since v0.21, vectorizers pass the data to the custom analyzer \"",
                    "+               \"and not the file names or the file objects. This warning \"",
                    "+               \"will be removed in v0.23.\")",
                    "+        try:",
                    "+            self.analyzer(fname)",
                    "+        except FileNotFoundError:",
                    "+            warnings.warn(msg, ChangedBehaviorWarning)",
                    "+        except AttributeError as e:",
                    "+            if str(e) == \"'str' object has no attribute 'read'\":",
                    "+                warnings.warn(msg, ChangedBehaviorWarning)",
                    "+        except Exception:",
                    "+            pass",
                    "+",
                    "     def build_analyzer(self):",
                    "         \"\"\"Return a callable that handles preprocessing and tokenization\"\"\"",
                    "         if callable(self.analyzer):",
                    "-            return self.analyzer",
                    "+            if self.input in ['file', 'filename']:",
                    "+                self._validate_custom_analyzer()",
                    "+            return lambda doc: self.analyzer(self.decode(doc))"
                ],
                "start_lineno": 307,
                "end_lineno": 310
            },
            {
                "hunk": [
                    "+        .. versionchanged:: 0.21",
                    "+        Since v0.21, if ``input`` is ``filename`` or ``file``, the data is",
                    "+        first read from the file and then passed to the given callable",
                    "+        analyzer.",
                    "+"
                ],
                "start_lineno": 493,
                "end_lineno": 493
            },
            {
                "hunk": [
                    "+        .. versionchanged:: 0.21",
                    "+        Since v0.21, if ``input`` is ``filename`` or ``file``, the data is",
                    "+        first read from the file and then passed to the given callable",
                    "+        analyzer.",
                    "+"
                ],
                "start_lineno": 748,
                "end_lineno": 748
            },
            {
                "hunk": [
                    "+        .. versionchanged:: 0.21",
                    "+        Since v0.21, if ``input`` is ``filename`` or ``file``, the data is",
                    "+        first read from the file and then passed to the given callable",
                    "+        analyzer.",
                    "+"
                ],
                "start_lineno": 1372,
                "end_lineno": 1372
            }
        ]
    },
    "sphinx-doc__sphinx-7593": {
        "sphinx/builders/html/__init__.py": [
            {
                "hunk": [
                    "+    # load transforms for HTML builder",
                    "+    app.setup_extension('sphinx.builders.html.transforms')",
                    "+"
                ],
                "start_lineno": 1246,
                "end_lineno": 1246
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"",
                    "+    sphinx.builders.html.transforms",
                    "+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
                    "+",
                    "+    Transforms for HTML builder.",
                    "+",
                    "+    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.",
                    "+    :license: BSD, see LICENSE for details.",
                    "+\"\"\"",
                    "+",
                    "+import re",
                    "+from typing import Any, Dict",
                    "+",
                    "+from docutils import nodes",
                    "+",
                    "+from sphinx.application import Sphinx",
                    "+from sphinx.transforms.post_transforms import SphinxPostTransform",
                    "+from sphinx.util.nodes import NodeMatcher",
                    "+",
                    "+",
                    "+class KeyboardTransform(SphinxPostTransform):",
                    "+    \"\"\"Transform :kbd: role to more detailed form.",
                    "+",
                    "+    Before::",
                    "+",
                    "+        <literal class=\"kbd\">",
                    "+            Control-x",
                    "+",
                    "+    After::",
                    "+",
                    "+        <literal class=\"kbd\">",
                    "+            <literal class=\"kbd\">",
                    "+                Control",
                    "+            -",
                    "+            <literal class=\"kbd\">",
                    "+                x",
                    "+    \"\"\"",
                    "+    default_priority = 400",
                    "+    builders = ('html',)",
                    "+    pattern = re.compile(r'(-|\\+|\\^|\\s+)')",
                    "+",
                    "+    def run(self, **kwargs: Any) -> None:",
                    "+        matcher = NodeMatcher(nodes.literal, classes=[\"kbd\"])",
                    "+        for node in self.document.traverse(matcher):  # type: nodes.literal",
                    "+            parts = self.pattern.split(node[-1].astext())",
                    "+            if len(parts) == 1:",
                    "+                continue",
                    "+",
                    "+            node.pop()",
                    "+            while parts:",
                    "+                key = parts.pop(0)",
                    "+                node += nodes.literal('', key, classes=[\"kbd\"])",
                    "+",
                    "+                try:",
                    "+                    # key separator (ex. -, +, ^)",
                    "+                    sep = parts.pop(0)",
                    "+                    node += nodes.Text(sep)",
                    "+                except IndexError:",
                    "+                    pass",
                    "+",
                    "+",
                    "+def setup(app: Sphinx) -> Dict[str, Any]:",
                    "+    app.add_post_transform(KeyboardTransform)",
                    "+",
                    "+    return {",
                    "+        'version': 'builtin',",
                    "+        'parallel_read_safe': True,",
                    "+        'parallel_write_safe': True,",
                    "+    }"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "sphinx/util/nodes.py": [
            {
                "hunk": [
                    "-    def __init__(self, *classes: \"Type[Node]\", **attrs: Any) -> None:",
                    "-        self.classes = classes",
                    "+    def __init__(self, *node_classes: \"Type[Node]\", **attrs: Any) -> None:",
                    "+        self.classes = node_classes"
                ],
                "start_lineno": 65,
                "end_lineno": 66
            }
        ]
    },
    "sympy__sympy-16792": {
        "sympy/utilities/codegen.py": [
            {
                "hunk": [
                    "+",
                    "+        # helper to get dimensions for data for array-like args",
                    "+        def dimensions(s):",
                    "+            return [(S.Zero, dim - 1) for dim in s.shape]",
                    "+"
                ],
                "start_lineno": 698,
                "end_lineno": 698
            },
            {
                "hunk": [
                    "-                dims = []",
                    "                 array = array_symbols[symbol]",
                    "-                for dim in array.shape:",
                    "-                    dims.append((S.Zero, dim - 1))",
                    "-                metadata = {'dimensions': dims}",
                    "+                metadata = {'dimensions': dimensions(array)}"
                ],
                "start_lineno": 706,
                "end_lineno": 710
            },
            {
                "hunk": [
                    "-                    new_args.append(InputArgument(symbol))",
                    "+                    if isinstance(symbol, (IndexedBase, MatrixSymbol)):",
                    "+                        metadata = {'dimensions': dimensions(symbol)}",
                    "+                    else:",
                    "+                        metadata = {}",
                    "+                    new_args.append(InputArgument(symbol, **metadata))"
                ],
                "start_lineno": 742,
                "end_lineno": 742
            }
        ]
    },
    "sympy__sympy-17176": {
        "sympy/logic/boolalg.py": [
            {
                "hunk": [
                    "-    # of times it appeared as a Symbol,",
                    "-    # of times it appeared as a Not(symbol),",
                    "-    # of times it appeared as a Symbol in an And or Or,",
                    "-    # of times it appeared as a Not(Symbol) in an And or Or,",
                    "-    sum of the number of arguments with which it appeared",
                    "-    as a Symbol, counting Symbol as 1 and Not(Symbol) as 2",
                    "-    and counting self as 1",
                    "+    # of times it appeared as a Symbol;",
                    "+    # of times it appeared as a Not(symbol);",
                    "+    # of times it appeared as a Symbol in an And or Or;",
                    "+    # of times it appeared as a Not(Symbol) in an And or Or;",
                    "+    a sorted tuple of tuples, (i, j, k), where i is the number of arguments",
                    "+    in an And or Or with which it appeared as a Symbol, and j is",
                    "+    the number of arguments that were Not(Symbol); k is the number",
                    "+    of times that (i, j) was seen.",
                    "     ]",
                    " ",
                    "     Examples",
                    "     ========",
                    " ",
                    "     >>> from sympy.logic.boolalg import _finger as finger",
                    "-    >>> from sympy import And, Or, Not",
                    "+    >>> from sympy import And, Or, Not, Xor, to_cnf, symbols",
                    "     >>> from sympy.abc import a, b, x, y",
                    "     >>> eq = Or(And(Not(y), a), And(Not(y), b), And(x, y))",
                    "     >>> dict(finger(eq))",
                    "-    {(0, 0, 1, 0, 2): [x], (0, 0, 1, 0, 3): [a, b], (0, 0, 1, 2, 2): [y]}",
                    "+    {(0, 0, 1, 0, ((2, 0, 1),)): [x],",
                    "+    (0, 0, 1, 0, ((2, 1, 1),)): [a, b],",
                    "+    (0, 0, 1, 2, ((2, 0, 1),)): [y]}",
                    "     >>> dict(finger(x & ~y))",
                    "-    {(0, 1, 0, 0, 0): [y], (1, 0, 0, 0, 0): [x]}",
                    "+    {(0, 1, 0, 0, ()): [y], (1, 0, 0, 0, ()): [x]}",
                    "+",
                    "+    In the following, the (5, 2, 6) means that there were 6 Or",
                    "+    functions in which a symbol appeared as itself amongst 5 arguments in",
                    "+    which there were also 2 negated symbols, e.g. ``(a0 | a1 | a2 | ~a3 | ~a4)``",
                    "+    is counted once for a0, a1 and a2.",
                    "+",
                    "+    >>> dict(finger(to_cnf(Xor(*symbols('a:5')))))",
                    "+    {(0, 0, 8, 8, ((5, 0, 1), (5, 2, 6), (5, 4, 1))): [a0, a1, a2, a3, a4]}",
                    " ",
                    "     The equation must not have more than one level of nesting:",
                    " ",
                    "     >>> dict(finger(And(Or(x, y), y)))",
                    "-    {(0, 0, 1, 0, 2): [x], (1, 0, 1, 0, 2): [y]}",
                    "+    {(0, 0, 1, 0, ((2, 0, 1),)): [x], (1, 0, 1, 0, ((2, 0, 1),)): [y]}"
                ],
                "start_lineno": 2374,
                "end_lineno": 2398
            },
            {
                "hunk": [
                    "-    d = dict(list(zip(f, [[0] * 5 for fi in f])))",
                    "+    d = dict(list(zip(f, [[0]*4 + [defaultdict(int)] for fi in f])))",
                    "     for a in eq.args:",
                    "         if a.is_Symbol:",
                    "             d[a][0] += 1",
                    "         elif a.is_Not:",
                    "             d[a.args[0]][1] += 1",
                    "         else:",
                    "-            o = len(a.args) + sum(isinstance(ai, Not) for ai in a.args)",
                    "+            o = len(a.args), sum(isinstance(ai, Not) for ai in a.args)",
                    "             for ai in a.args:",
                    "                 if ai.is_Symbol:",
                    "                     d[ai][2] += 1",
                    "-                    d[ai][-1] += o",
                    "+                    d[ai][-1][o] += 1",
                    "                 elif ai.is_Not:",
                    "                     d[ai.args[0]][3] += 1",
                    "                 else:",
                    "                     raise NotImplementedError('unexpected level of nesting')",
                    "     inv = defaultdict(list)",
                    "     for k, v in ordered(iter(d.items())):",
                    "+        v[-1] = tuple(sorted([i + (j,) for i, j in v[-1].items()]))"
                ],
                "start_lineno": 2407,
                "end_lineno": 2424
            }
        ]
    },
    "django__django-13030": {
        "django/db/models/lookups.py": [
            {
                "hunk": [
                    "+            # Remove None from the list as NULL is never equal to anything.",
                    "             try:",
                    "                 rhs = OrderedSet(self.rhs)",
                    "+                rhs.discard(None)",
                    "             except TypeError:  # Unhashable items in self.rhs",
                    "-                rhs = self.rhs",
                    "+                rhs = [r for r in self.rhs if r is not None]"
                ],
                "start_lineno": 369,
                "end_lineno": 372
            }
        ]
    },
    "psf__requests-3362": {
        "requests/utils.py": [
            {
                "hunk": [
                    "+    encoding = r.encoding",
                    " ",
                    "-    if r.encoding is None:",
                    "-        for item in iterator:",
                    "-            yield item",
                    "-        return",
                    "+    if encoding is None:",
                    "+        encoding = r.apparent_encoding",
                    "+",
                    "+    try:",
                    "+        decoder = codecs.getincrementaldecoder(encoding)(errors='replace')",
                    "+    except (LookupError, TypeError):",
                    "+        # A LookupError is raised if the encoding was not found which could",
                    "+        # indicate a misspelling or similar mistake.",
                    "+        #",
                    "+        # A TypeError can be raised if encoding is None",
                    "+        raise UnicodeError(\"Unable to decode contents with encoding %s.\" % encoding)",
                    " ",
                    "-    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')"
                ],
                "start_lineno": 361,
                "end_lineno": 367
            }
        ]
    },
    "pydata__xarray-5362": {
        "xarray/core/weighted.py": [
            {
                "hunk": [
                    "+    def _check_dim(self, dim: Optional[Union[Hashable, Iterable[Hashable]]]):",
                    "+        \"\"\"raise an error if any dimension is missing\"\"\"",
                    "+",
                    "+        if isinstance(dim, str) or not isinstance(dim, Iterable):",
                    "+            dims = [dim] if dim else []",
                    "+        else:",
                    "+            dims = list(dim)",
                    "+        missing_dims = set(dims) - set(self.obj.dims) - set(self.weights.dims)",
                    "+        if missing_dims:",
                    "+            raise ValueError(",
                    "+                f\"{self.__class__.__name__} does not contain the dimensions: {missing_dims}\"",
                    "+            )",
                    "+"
                ],
                "start_lineno": 122,
                "end_lineno": 122
            },
            {
                "hunk": [
                    "+        self._check_dim(dim)",
                    "+"
                ],
                "start_lineno": 239,
                "end_lineno": 239
            },
            {
                "hunk": [
                    "+        self._check_dim(dim)",
                    "+"
                ],
                "start_lineno": 247,
                "end_lineno": 247
            }
        ]
    },
    "sphinx-doc__sphinx-8202": {
        "sphinx/ext/autodoc/__init__.py": [
            {
                "hunk": [
                    "+",
                    "+                if docstringlines and docstringlines[-1] != '':",
                    "+                    # append a blank line to the end of the docstring",
                    "+                    docstringlines.append('')",
                    "+"
                ],
                "start_lineno": 538,
                "end_lineno": 538
            }
        ]
    },
    "django__django-11428": {
        "django/utils/autoreload.py": [
            {
                "hunk": [
                    "-        raise _exception[0](_exception[1]).with_traceback(_exception[2])",
                    "+        raise _exception[1]"
                ],
                "start_lineno": 77,
                "end_lineno": 77
            }
        ]
    },
    "sympy__sympy-15678": {
        "sympy/geometry/util.py": [
            {
                "hunk": [
                    "+    elif isinstance(y, Function):",
                    "+        pass",
                    "     else:",
                    "-        raise ValueError(\"expecting x-dependent symbol(s) but got: %s\" % y)",
                    "+        raise ValueError(\"expecting x-dependent symbol(s) or function(s) but got: %s\" % y)",
                    " ",
                    "     f = dict([(s, Function(",
                    "         s.name)(x)) for s in eq.free_symbols if s != x and s in dep])",
                    "-    dydx = Function(y.name)(x).diff(x)",
                    "+",
                    "+    if isinstance(y, Symbol):",
                    "+        dydx = Function(y.name)(x).diff(x)",
                    "+    else:",
                    "+        dydx = y.diff(x)",
                    "+"
                ],
                "start_lineno": 573,
                "end_lineno": 578
            }
        ]
    },
    "scikit-learn__scikit-learn-11310": {
        "sklearn/model_selection/_search.py": [
            {
                "hunk": [
                    "+import time"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "+            refit_start_time = time.time()",
                    "             if y is not None:",
                    "                 self.best_estimator_.fit(X, y, **fit_params)",
                    "             else:",
                    "                 self.best_estimator_.fit(X, **fit_params)",
                    "+            refit_end_time = time.time()",
                    "+            self.refit_time_ = refit_end_time - refit_start_time"
                ],
                "start_lineno": 769,
                "end_lineno": 772
            },
            {
                "hunk": [
                    "+    refit_time_ : float",
                    "+        Seconds used for refitting the best model on the whole dataset.",
                    "+",
                    "+        This is present only if ``refit`` is not False.",
                    "+"
                ],
                "start_lineno": 1079,
                "end_lineno": 1079
            },
            {
                "hunk": [
                    "+    refit_time_ : float",
                    "+        Seconds used for refitting the best model on the whole dataset.",
                    "+",
                    "+        This is present only if ``refit`` is not False.",
                    "+"
                ],
                "start_lineno": 1390,
                "end_lineno": 1390
            }
        ]
    },
    "django__django-15742": {
        "django/templatetags/i18n.py": [
            {
                "hunk": [
                    "-from django.utils.safestring import SafeData, mark_safe",
                    "+from django.utils.safestring import SafeData, SafeString, mark_safe"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-            context[self.asvar] = result",
                    "+            context[self.asvar] = SafeString(result)"
                ],
                "start_lineno": 201,
                "end_lineno": 201
            }
        ]
    },
    "sympy__sympy-16858": {
        "sympy/stats/crv_types.py": [
            {
                "hunk": [
                    "+    def set(self):",
                    "+        return Interval(self.a, self.b)",
                    "+"
                ],
                "start_lineno": 166,
                "end_lineno": 166
            },
            {
                "hunk": [
                    "+    set = Interval(0, oo)",
                    "+"
                ],
                "start_lineno": 874,
                "end_lineno": 874
            },
            {
                "hunk": [
                    "+    set = Interval(-oo, oo)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(d1, d2):",
                    "+        _value_check(d1 > 0, \"Degree of freedom d1 must be positive.\")",
                    "+        _value_check(d2 > 0, \"Degree of freedom d2 must be positive.\")",
                    "+"
                ],
                "start_lineno": 1208,
                "end_lineno": 1208
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(a, s, m):",
                    "+        _value_check(a > 0, \"Shape parameter alpha must be positive.\")",
                    "+        _value_check(s > 0, \"Scale parameter s must be positive.\")",
                    "+"
                ],
                "start_lineno": 1279,
                "end_lineno": 1279
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(beta, mu):",
                    "+        _value_check(beta > 0, \"Scale parameter beta must be positive.\")",
                    "+"
                ],
                "start_lineno": 1554,
                "end_lineno": 1554
            },
            {
                "hunk": [
                    "-        return gamma(1 - self.beta*t) * exp(I*self.mu*t)",
                    "+        return gamma(1 - self.beta*t) * exp(self.mu*t)"
                ],
                "start_lineno": 1567,
                "end_lineno": 1567
            },
            {
                "hunk": [
                    "+    set = Interval(-oo, oo)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(mu, b):",
                    "+        _value_check(b > 0, \"Scale parameter b must be positive.\")",
                    "+        _value_check(mu.is_real, \"Location parameter mu should be real\")",
                    "+"
                ],
                "start_lineno": 1768,
                "end_lineno": 1768
            },
            {
                "hunk": [
                    "+    set = Interval(-oo, oo)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(mu, s):",
                    "+        _value_check(s > 0, \"Scale parameter s must be positive.\")",
                    "+"
                ],
                "start_lineno": 1855,
                "end_lineno": 1855
            },
            {
                "hunk": [
                    "-        return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)",
                    "+        return exp(self.mu*t) * beta_fn(1 - self.s*t, 1 + self.s*t)"
                ],
                "start_lineno": 1867,
                "end_lineno": 1867
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(a):",
                    "+        _value_check(a > 0, \"Parameter a must be positive.\")",
                    "+"
                ],
                "start_lineno": 2018,
                "end_lineno": 2018
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(mu, omega):",
                    "+        _value_check(mu >= S.Half, \"Shape parameter mu must be greater than equal to 1/2.\")",
                    "+        _value_check(omega > 0, \"Spread parameter omega must be positive.\")",
                    "+"
                ],
                "start_lineno": 2088,
                "end_lineno": 2088
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(a, b):",
                    "+        _value_check(b > a, \"Parameter b must be in range (%s, oo).\"%(a))",
                    "+"
                ],
                "start_lineno": 2388,
                "end_lineno": 2388
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(sigma):",
                    "+        _value_check(sigma > 0, \"Scale parameter sigma must be positive.\")",
                    "+"
                ],
                "start_lineno": 2556,
                "end_lineno": 2556
            },
            {
                "hunk": [
                    "+    set = Interval(-oo, oo)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(nu):",
                    "+        _value_check(nu > 0, \"Degrees of freedom nu must be positive.\")",
                    "+"
                ],
                "start_lineno": 2693,
                "end_lineno": 2693
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def set(self):",
                    "+        return Interval(self.a, self.d)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(a, b, c, d):",
                    "+        _value_check(a < d, \"Lower bound parameter a < %s. a = %s\"%(d, a))",
                    "+        _value_check((a <= b, b < c),",
                    "+        \"Level start parameter b must be in range [%s, %s). b = %s\"%(a, c, b))",
                    "+        _value_check((b < c, c <= d),",
                    "+        \"Level end parameter c must be in range (%s, %s]. c = %s\"%(b, d, c))",
                    "+        _value_check(d >= c, \"Upper bound parameter d > %s. d = %s\"%(c, d))",
                    "+"
                ],
                "start_lineno": 2773,
                "end_lineno": 2773
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def set(self):",
                    "+        return Interval(self.a, self.b)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(a, b, c):",
                    "+        _value_check(b > a, \"Parameter b > %s. b = %s\"%(a, b))",
                    "+        _value_check((a <= c, c <= b),",
                    "+        \"Parameter c must be in range [%s, %s]. c = %s\"%(a, b, c))",
                    "+"
                ],
                "start_lineno": 2853,
                "end_lineno": 2853
            },
            {
                "hunk": [
                    "-        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (",
                    "+        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c - a) * exp(b * t)) / ("
                ],
                "start_lineno": 2867,
                "end_lineno": 2867
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def set(self):",
                    "+        return Interval(self.left, self.right)",
                    "+",
                    "+    @staticmethod",
                    "+    def check(left, right):",
                    "+        _value_check(left < right, \"Lower limit should be less than Upper limit.\")",
                    "+"
                ],
                "start_lineno": 2943,
                "end_lineno": 2943
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(n):",
                    "+        _value_check((n > 0, n.is_integer),",
                    "+        \"Parameter n must be positive integer.\")",
                    "+"
                ],
                "start_lineno": 3050,
                "end_lineno": 3050
            },
            {
                "hunk": [
                    "+    @staticmethod",
                    "+    def check(R):",
                    "+        _value_check(R > 0, \"Radius R must be positive.\")",
                    "+"
                ],
                "start_lineno": 3295,
                "end_lineno": 3295
            }
        ],
        "sympy/stats/joint_rv_types.py": [
            {
                "hunk": [
                    "-    def check(self, mu, sigma):",
                    "+    @staticmethod",
                    "+    def check(mu, sigma):"
                ],
                "start_lineno": 79,
                "end_lineno": 79
            },
            {
                "hunk": [
                    "-    def check(self, mu, sigma):",
                    "+    @staticmethod",
                    "+    def check(mu, sigma):"
                ],
                "start_lineno": 120,
                "end_lineno": 120
            },
            {
                "hunk": [
                    "-    def check(self, mu, sigma, v):",
                    "+    @staticmethod",
                    "+    def check(mu, sigma, v):"
                ],
                "start_lineno": 154,
                "end_lineno": 154
            },
            {
                "hunk": [
                    "-    def check(self, mu, lamda, alpha, beta):",
                    "+    @staticmethod",
                    "+    def check(mu, lamda, alpha, beta):"
                ],
                "start_lineno": 199,
                "end_lineno": 199
            },
            {
                "hunk": [
                    "-    def check(self, alpha):",
                    "+    @staticmethod",
                    "+    def check(alpha):"
                ],
                "start_lineno": 261,
                "end_lineno": 261
            },
            {
                "hunk": [
                    "-    def check(self, n, theta):",
                    "+    @staticmethod",
                    "+    def check(n, theta):"
                ],
                "start_lineno": 334,
                "end_lineno": 334
            },
            {
                "hunk": [
                    "-    def check(self, n, p):",
                    "+    @staticmethod",
                    "+    def check(n, p):"
                ],
                "start_lineno": 406,
                "end_lineno": 406
            },
            {
                "hunk": [
                    "-    def check(self, k0, p):",
                    "+    @staticmethod",
                    "+    def check(k0, p):"
                ],
                "start_lineno": 474,
                "end_lineno": 474
            }
        ]
    },
    "django__django-15128": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "+        # If lhs and rhs shares the same alias prefix, it is possible to have",
                    "+        # conflicting alias changes like T4 -> T5, T5 -> T6, which might end up",
                    "+        # as T4 -> T6 while combining two querysets. To prevent this, change an",
                    "+        # alias prefix of the rhs and update current aliases accordingly,",
                    "+        # except if the alias is the base table since it must be present in the",
                    "+        # query on both sides.",
                    "+        initial_alias = self.get_initial_alias()",
                    "+        rhs.bump_prefix(self, exclude={initial_alias})",
                    "+"
                ],
                "start_lineno": 575,
                "end_lineno": 575
            },
            {
                "hunk": [
                    "-        # Base table must be present in the query - this is the same",
                    "-        # table on both sides.",
                    "-        self.get_initial_alias()"
                ],
                "start_lineno": 592,
                "end_lineno": 594
            },
            {
                "hunk": [
                    "+        # If keys and values of change_map were to intersect, an alias might be",
                    "+        # updated twice (e.g. T4 -> T5, T5 -> T6, so also T4 -> T6) depending",
                    "+        # on their order in change_map."
                ],
                "start_lineno": 849,
                "end_lineno": 849
            },
            {
                "hunk": [
                    "-    def bump_prefix(self, outer_query):",
                    "+    def bump_prefix(self, other_query, exclude=None):",
                    "         \"\"\"",
                    "         Change the alias prefix to the next letter in the alphabet in a way",
                    "-        that the outer query's aliases and this query's aliases will not",
                    "+        that the other query's aliases and this query's aliases will not",
                    "         conflict. Even tables that previously had no alias will get an alias",
                    "-        after this call.",
                    "+        after this call. To prevent changing aliases use the exclude parameter."
                ],
                "start_lineno": 882,
                "end_lineno": 887
            },
            {
                "hunk": [
                    "-        if self.alias_prefix != outer_query.alias_prefix:",
                    "+        if self.alias_prefix != other_query.alias_prefix:"
                ],
                "start_lineno": 907,
                "end_lineno": 907
            },
            {
                "hunk": [
                    "-        outer_query.subq_aliases = outer_query.subq_aliases.union(self.subq_aliases)",
                    "+        other_query.subq_aliases = other_query.subq_aliases.union(self.subq_aliases)",
                    "+        if exclude is None:",
                    "+            exclude = {}",
                    "         self.change_aliases({",
                    "             alias: '%s%d' % (self.alias_prefix, pos)",
                    "             for pos, alias in enumerate(self.alias_map)",
                    "+            if alias not in exclude"
                ],
                "start_lineno": 925,
                "end_lineno": 928
            }
        ]
    },
    "matplotlib__matplotlib-22865": {
        "lib/matplotlib/colorbar.py": [
            {
                "hunk": [
                    "-        self.dividers.set_segments(",
                    "-            np.dstack([X, Y])[1:-1] if self.drawedges else [])",
                    "+        if self.drawedges:",
                    "+            start_idx = 0 if self._extend_lower() else 1",
                    "+            end_idx = len(X) if self._extend_upper() else -1",
                    "+            self.dividers.set_segments(np.dstack([X, Y])[start_idx:end_idx])",
                    "+        else:",
                    "+            self.dividers.set_segments([])"
                ],
                "start_lineno": 654,
                "end_lineno": 655
            }
        ]
    },
    "sphinx-doc__sphinx-9711": {
        "sphinx/extension.py": [
            {
                "hunk": [
                    "+from packaging.version import InvalidVersion, Version",
                    "+"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            },
            {
                "hunk": [
                    "-        if extension.version == 'unknown version' or reqversion > extension.version:",
                    "+        fulfilled = True",
                    "+        if extension.version == 'unknown version':",
                    "+            fulfilled = False",
                    "+        else:",
                    "+            try:",
                    "+                if Version(reqversion) > Version(extension.version):",
                    "+                    fulfilled = False",
                    "+            except InvalidVersion:",
                    "+                if reqversion > extension.version:",
                    "+                    fulfilled = False",
                    "+",
                    "+        if not fulfilled:"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            }
        ]
    },
    "django__django-16707": {
        "django/utils/functional.py": [
            {
                "hunk": [
                    "-            if cls._delegate_text:",
                    "-                cls.__str__ = cls.__text_cast",
                    "-            elif cls._delegate_bytes:",
                    "+",
                    "+            if cls._delegate_bytes:"
                ],
                "start_lineno": 128,
                "end_lineno": 130
            },
            {
                "hunk": [
                    "-        def __text_cast(self):",
                    "-            return func(*self.__args, **self.__kw)",
                    "-",
                    "         def __bytes_cast(self):",
                    "             return bytes(func(*self.__args, **self.__kw))",
                    " ",
                    "-        def __bytes_cast_encoded(self):",
                    "-            return func(*self.__args, **self.__kw).encode()",
                    "-",
                    "         def __cast(self):",
                    "             if self._delegate_bytes:",
                    "                 return self.__bytes_cast()",
                    "-            elif self._delegate_text:",
                    "-                return self.__text_cast()"
                ],
                "start_lineno": 144,
                "end_lineno": 157
            }
        ]
    },
    "astropy__astropy-12880": {
        "astropy/io/ascii/ecsv.py": [
            {
                "hunk": [
                    "-        # ecsv_version could be constructed here, but it is not currently used.",
                    "+",
                    "+        # Construct ecsv_version for backwards compatibility workarounds.",
                    "+        self.ecsv_version = tuple(int(v or 0) for v in match.groups())"
                ],
                "start_lineno": 132,
                "end_lineno": 132
            },
            {
                "hunk": [
                    "-            if col.dtype not in ECSV_DATATYPES:",
                    "+            # Require col dtype to be a valid ECSV datatype. However, older versions",
                    "+            # of astropy writing ECSV version 0.9 and earlier had inadvertently allowed",
                    "+            # numpy datatypes like datetime64 or object or python str, which are not in the ECSV standard.",
                    "+            # For back-compatibility with those existing older files, allow reading with no error.",
                    "+            if col.dtype not in ECSV_DATATYPES and self.ecsv_version > (0, 9, 0):"
                ],
                "start_lineno": 176,
                "end_lineno": 176
            }
        ]
    },
    "scikit-learn__scikit-learn-14520": {
        "sklearn/feature_extraction/text.py": [
            {
                "hunk": [
                    "-    def transform(self, raw_documents, copy=True):",
                    "+    def transform(self, raw_documents, copy=\"deprecated\"):"
                ],
                "start_lineno": 1732,
                "end_lineno": 1732
            },
            {
                "hunk": [
                    "+            .. deprecated:: 0.22",
                    "+               The `copy` parameter is unused and was deprecated in version",
                    "+               0.22 and will be removed in 0.24. This parameter will be",
                    "+               ignored.",
                    "+"
                ],
                "start_lineno": 1747,
                "end_lineno": 1747
            },
            {
                "hunk": [
                    "+        # FIXME Remove copy parameter support in 0.24",
                    "+        if copy != \"deprecated\":",
                    "+            msg = (\"'copy' param is unused and has been deprecated since \"",
                    "+                   \"version 0.22. Backward compatibility for 'copy' will \"",
                    "+                   \"be removed in 0.24.\")",
                    "+            warnings.warn(msg, DeprecationWarning)"
                ],
                "start_lineno": 1754,
                "end_lineno": 1754
            }
        ]
    },
    "matplotlib__matplotlib-26291": {
        "lib/mpl_toolkits/axes_grid1/inset_locator.py": [
            {
                "hunk": [
                    "+        if renderer is None:",
                    "+            renderer = ax.figure._get_renderer()"
                ],
                "start_lineno": 72,
                "end_lineno": 72
            }
        ]
    },
    "django__django-15324": {
        "django/http/multipartparser.py": [
            {
                "hunk": [
                    "+        # Remove non-printable characters.",
                    "+        file_name = ''.join([char for char in file_name if char.isprintable()])"
                ],
                "start_lineno": 323,
                "end_lineno": 323
            }
        ]
    },
    "scikit-learn__scikit-learn-12834": {
        "sklearn/ensemble/forest.py": [
            {
                "hunk": [
                    "-            predictions = np.zeros((n_samples, self.n_outputs_))",
                    "+            # all dtypes should be the same, so just take the first",
                    "+            class_type = self.classes_[0].dtype",
                    "+            predictions = np.empty((n_samples, self.n_outputs_),",
                    "+                                   dtype=class_type)"
                ],
                "start_lineno": 550,
                "end_lineno": 550
            }
        ]
    },
    "sympy__sympy-15586": {
        "sympy/matrices/expressions/inverse.py": [
            {
                "hunk": [
                    "-    A^-1",
                    "+    A**(-1)",
                    "     >>> A.inverse() == Inverse(A)",
                    "     True",
                    "     >>> (A*B).inverse()",
                    "-    B^-1*A^-1",
                    "+    B**(-1)*A**(-1)",
                    "     >>> Inverse(A*B)",
                    "-    (A*B)^-1",
                    "+    (A*B)**(-1)"
                ],
                "start_lineno": 25,
                "end_lineno": 31
            },
            {
                "hunk": [
                    "-    X^-1",
                    "+    X**(-1)"
                ],
                "start_lineno": 80,
                "end_lineno": 80
            }
        ],
        "sympy/printing/pycode.py": [
            {
                "hunk": [
                    "+    def _print_MatPow(self, expr):",
                    "+        \"Matrix power printer\"",
                    "+        return '{0}({1}, {2})'.format(self._module_format('numpy.linalg.matrix_power'),",
                    "+            self._print(expr.args[0]), self._print(expr.args[1]))",
                    "+",
                    "+    def _print_Inverse(self, expr):",
                    "+        \"Matrix inverse printer\"",
                    "+        return '{0}({1})'.format(self._module_format('numpy.linalg.inv'),",
                    "+            self._print(expr.args[0]))",
                    "+"
                ],
                "start_lineno": 502,
                "end_lineno": 502
            }
        ],
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "-        return \"%s^-1\" % self.parenthesize(I.arg, PRECEDENCE[\"Pow\"])",
                    "+        return \"%s**(-1)\" % self.parenthesize(I.arg, PRECEDENCE[\"Pow\"])"
                ],
                "start_lineno": 212,
                "end_lineno": 212
            }
        ],
        "sympy/utilities/lambdify.py": [
            {
                "hunk": [
                    "-    \"numpy\": (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, (\"import numpy; from numpy import *\",)),",
                    "+    \"numpy\": (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, (\"import numpy; from numpy import *; from numpy.linalg import *\",)),"
                ],
                "start_lineno": 95,
                "end_lineno": 95
            }
        ]
    },
    "sympy__sympy-18189": {
        "sympy/solvers/diophantine.py": [
            {
                "hunk": [
                    "-                            for t in diophantine(eq, param)}",
                    "+                            for t in diophantine(eq, param, permute=permute)}"
                ],
                "start_lineno": 185,
                "end_lineno": 185
            }
        ]
    },
    "django__django-14471": {
        "django/middleware/csrf.py": [
            {
                "hunk": [
                    "-            try:",
                    "-                csrf_token = _sanitize_token(cookie_token)",
                    "-            except InvalidTokenFormat:",
                    "-                csrf_token = _get_new_csrf_token()",
                    "+            # This can raise InvalidTokenFormat.",
                    "+            csrf_token = _sanitize_token(cookie_token)",
                    " ",
                    "             if csrf_token != cookie_token:",
                    "-                # Cookie token needed to be replaced;",
                    "-                # the cookie needs to be reset.",
                    "+                # Then the cookie token had length CSRF_SECRET_LENGTH, so flag",
                    "+                # to replace it with the masked version."
                ],
                "start_lineno": 220,
                "end_lineno": 227
            },
            {
                "hunk": [
                    "-        csrf_token = self._get_token(request)",
                    "+        try:",
                    "+            csrf_token = self._get_token(request)",
                    "+        except InvalidTokenFormat:",
                    "+            csrf_token = _get_new_csrf_token()",
                    "+            request.csrf_cookie_needs_reset = True",
                    "+"
                ],
                "start_lineno": 321,
                "end_lineno": 321
            },
            {
                "hunk": [
                    "-        csrf_token = self._get_token(request)",
                    "+        try:",
                    "+            csrf_token = self._get_token(request)",
                    "+        except InvalidTokenFormat as exc:",
                    "+            return self._reject(request, f'CSRF cookie {exc.reason}.')",
                    "+"
                ],
                "start_lineno": 377,
                "end_lineno": 377
            }
        ]
    },
    "django__django-14855": {
        "django/contrib/admin/helpers.py": [
            {
                "hunk": [
                    "-            url = reverse(url_name, args=[quote(remote_obj.pk)])",
                    "+            url = reverse(",
                    "+                url_name,",
                    "+                args=[quote(remote_obj.pk)],",
                    "+                current_app=self.model_admin.admin_site.name,",
                    "+            )"
                ],
                "start_lineno": 212,
                "end_lineno": 212
            }
        ]
    },
    "sphinx-doc__sphinx-9053": {
        "sphinx/environment/adapters/toctree.py": [
            {
                "hunk": [
                    "-            caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])",
                    "+            caption_node = nodes.title(caption, '', *[nodes.Text(caption)])"
                ],
                "start_lineno": 240,
                "end_lineno": 240
            }
        ],
        "sphinx/writers/html.py": [
            {
                "hunk": [
                    "-        super().visit_title(node)",
                    "+        if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get('toctree'):",
                    "+            self.body.append(self.starttag(node, 'p', '', CLASS='caption'))",
                    "+            self.body.append('<span class=\"caption-text\">')",
                    "+            self.context.append('</span></p>\\n')",
                    "+        else:",
                    "+            super().visit_title(node)"
                ],
                "start_lineno": 407,
                "end_lineno": 407
            }
        ],
        "sphinx/writers/html5.py": [
            {
                "hunk": [
                    "-        super().visit_title(node)",
                    "+        if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get('toctree'):",
                    "+            self.body.append(self.starttag(node, 'p', '', CLASS='caption'))",
                    "+            self.body.append('<span class=\"caption-text\">')",
                    "+            self.context.append('</span></p>\\n')",
                    "+        else:",
                    "+            super().visit_title(node)"
                ],
                "start_lineno": 358,
                "end_lineno": 358
            }
        ]
    },
    "sympy__sympy-20322": {
        "sympy/core/mul.py": [
            {
                "hunk": [
                    "-from .logic import fuzzy_not, _fuzzy_group, fuzzy_and",
                    "+from .logic import fuzzy_not, _fuzzy_group"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "+    # without involving odd/even checks this code would suffice:",
                    "+    #_eval_is_integer = lambda self: _fuzzy_group(",
                    "+    #    (a.is_integer for a in self.args), quick_exit=True)",
                    "     def _eval_is_integer(self):",
                    "-        from sympy import fraction",
                    "-        from sympy.core.numbers import Float",
                    "-",
                    "         is_rational = self._eval_is_rational()",
                    "         if is_rational is False:",
                    "             return False",
                    " ",
                    "-        # use exact=True to avoid recomputing num or den",
                    "-        n, d = fraction(self, exact=True)",
                    "-        if is_rational:",
                    "-            if d is S.One:",
                    "-                return True",
                    "-        if d.is_even:",
                    "-            if d.is_prime:  # literal or symbolic 2",
                    "-                return n.is_even",
                    "-            if n.is_odd:",
                    "-                return False  # true even if d = 0",
                    "-        if n == d:",
                    "-            return fuzzy_and([not bool(self.atoms(Float)),",
                    "-            fuzzy_not(d.is_zero)])",
                    "+        numerators = []",
                    "+        denominators = []",
                    "+        for a in self.args:",
                    "+            if a.is_integer:",
                    "+                numerators.append(a)",
                    "+            elif a.is_Rational:",
                    "+                n, d = a.as_numer_denom()",
                    "+                numerators.append(n)",
                    "+                denominators.append(d)",
                    "+            elif a.is_Pow:",
                    "+                b, e = a.as_base_exp()",
                    "+                if not b.is_integer or not e.is_integer: return",
                    "+                if e.is_negative:",
                    "+                    denominators.append(b)",
                    "+                else:",
                    "+                    # for integer b and positive integer e: a = b**e would be integer",
                    "+                    assert not e.is_positive",
                    "+                    # for self being rational and e equal to zero: a = b**e would be 1",
                    "+                    assert not e.is_zero",
                    "+                    return # sign of e unknown -> self.is_integer cannot be decided",
                    "+            else:",
                    "+                return",
                    "+",
                    "+        if not denominators:",
                    "+            return True",
                    "+",
                    "+        odd = lambda ints: all(i.is_odd for i in ints)",
                    "+        even = lambda ints: any(i.is_even for i in ints)",
                    "+",
                    "+        if odd(numerators) and even(denominators):",
                    "+            return False",
                    "+        elif even(numerators) and denominators == [2]:",
                    "+            return True"
                ],
                "start_lineno": 1265,
                "end_lineno": 1285
            }
        ]
    },
    "pallets__flask-4160": {
        "src/flask/json/__init__.py": [
            {
                "hunk": [
                    "+import decimal"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "-        if isinstance(o, uuid.UUID):",
                    "+        if isinstance(o, (decimal.Decimal, uuid.UUID)):"
                ],
                "start_lineno": 50,
                "end_lineno": 50
            },
            {
                "hunk": [
                    "+    .. versionchanged:: 2.0.2",
                    "+        :class:`decimal.Decimal` is supported by converting to a string.",
                    "+"
                ],
                "start_lineno": 120,
                "end_lineno": 120
            },
            {
                "hunk": [
                    "+    .. versionchanged:: 2.0.2",
                    "+        :class:`decimal.Decimal` is supported by converting to a string.",
                    "+"
                ],
                "start_lineno": 327,
                "end_lineno": 327
            }
        ]
    },
    "scikit-learn__scikit-learn-13447": {
        "sklearn/metrics/ranking.py": [
            {
                "hunk": [
                    "-            out += 1.",
                    "-            continue",
                    "+            aux = 1.",
                    "+        else:",
                    "+            scores_i = y_score[i]",
                    "+            rank = rankdata(scores_i, 'max')[relevant]",
                    "+            L = rankdata(scores_i[relevant], 'max')",
                    "+            aux = (L / rank).mean()",
                    " ",
                    "-        scores_i = y_score[i]",
                    "-        rank = rankdata(scores_i, 'max')[relevant]",
                    "-        L = rankdata(scores_i[relevant], 'max')",
                    "-        aux = (L / rank).mean()"
                ],
                "start_lineno": 731,
                "end_lineno": 737
            }
        ]
    },
    "pydata__xarray-7147": {
        "xarray/conventions.py": [
            {
                "hunk": [
                    "-        new_vars[k] = decode_cf_variable(",
                    "-            k,",
                    "-            v,",
                    "-            concat_characters=concat_characters,",
                    "-            mask_and_scale=mask_and_scale,",
                    "-            decode_times=decode_times,",
                    "-            stack_char_dim=stack_char_dim,",
                    "-            use_cftime=use_cftime,",
                    "-            decode_timedelta=decode_timedelta,",
                    "-        )",
                    "+        try:",
                    "+            new_vars[k] = decode_cf_variable(",
                    "+                k,",
                    "+                v,",
                    "+                concat_characters=concat_characters,",
                    "+                mask_and_scale=mask_and_scale,",
                    "+                decode_times=decode_times,",
                    "+                stack_char_dim=stack_char_dim,",
                    "+                use_cftime=use_cftime,",
                    "+                decode_timedelta=decode_timedelta,",
                    "+            )",
                    "+        except Exception as e:",
                    "+            raise type(e)(f\"Failed to decode variable {k!r}: {e}\")"
                ],
                "start_lineno": 522,
                "end_lineno": 531
            }
        ]
    },
    "django__django-12741": {
        "django/core/management/commands/flush.py": [
            {
                "hunk": [
                    "-                connection.ops.execute_sql_flush(database, sql_list)",
                    "+                connection.ops.execute_sql_flush(sql_list)"
                ],
                "start_lineno": 63,
                "end_lineno": 63
            }
        ],
        "django/db/backends/base/operations.py": [
            {
                "hunk": [
                    "-    def execute_sql_flush(self, using, sql_list):",
                    "+    def execute_sql_flush(self, sql_list):",
                    "         \"\"\"Execute a list of SQL statements to flush the database.\"\"\"",
                    "-        with transaction.atomic(using=using, savepoint=self.connection.features.can_rollback_ddl):",
                    "+        with transaction.atomic(",
                    "+            using=self.connection.alias,",
                    "+            savepoint=self.connection.features.can_rollback_ddl,",
                    "+        ):"
                ],
                "start_lineno": 403,
                "end_lineno": 405
            }
        ]
    },
    "pydata__xarray-6461": {
        "xarray/core/computation.py": [
            {
                "hunk": [
                    "-",
                    "     if keep_attrs is True:",
                    "         # keep the attributes of x, the second parameter, by default to",
                    "         # be consistent with the `where` method of `DataArray` and `Dataset`",
                    "-        keep_attrs = lambda attrs, context: attrs[1]",
                    "+        keep_attrs = lambda attrs, context: getattr(x, \"attrs\", {})"
                ],
                "start_lineno": 1828,
                "end_lineno": 1832
            }
        ]
    },
    "sympy__sympy-12301": {
        "sympy/simplify/cse_main.py": [
            {
                "hunk": [
                    "-                com_func_take = Mul(take, from_dict(com_dict), evaluate=False)",
                    "+                _sum = from_dict(com_dict)",
                    "+                if take == 1:",
                    "+                    com_func_take = _sum",
                    "+                else:",
                    "+                    com_func_take = Mul(take, _sum, evaluate=False)",
                    "             else:",
                    "                 take = igcd(*[func_dicts[k][i] for i in com_dict])",
                    "-                com_func_take = Pow(from_dict(com_dict), take, evaluate=False)",
                    "+                base = from_dict(com_dict)",
                    "+                if take == 1:",
                    "+                    com_func_take = base",
                    "+                else:",
                    "+                    com_func_take = Pow(base, take, evaluate=False)"
                ],
                "start_lineno": 313,
                "end_lineno": 316
            },
            {
                "hunk": [
                    "-    nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]",
                    "     for i in range(len(exprs)):",
                    "         F = reduced_exprs[i].func",
                    "         if not (F is Mul or F is Add):",
                    "             continue",
                    "-        nested = [a for a in exprs[i].args if isinstance(a, F)]",
                    "-        args = []",
                    "-        for a in reduced_exprs[i].args:",
                    "-            if isinstance(a, F):",
                    "-                for ai in a.args:",
                    "-                    if isinstance(ai, F) and ai not in nested:",
                    "-                        args.extend(ai.args)",
                    "-                    else:",
                    "-                        args.append(ai)",
                    "-            else:",
                    "-                args.append(a)",
                    "-        reduced_exprs[i] = F(*args)",
                    "+        if any(isinstance(a, F) for a in reduced_exprs[i].args):",
                    "+            reduced_exprs[i] = F(*reduced_exprs[i].args)"
                ],
                "start_lineno": 549,
                "end_lineno": 565
            }
        ]
    },
    "mwaskom__seaborn-2848": {
        "seaborn/_oldcore.py": [
            {
                "hunk": [
                    "+",
                    "+            if self.norm is None:",
                    "+                # Currently we only get here in scatterplot with hue_order,",
                    "+                # because scatterplot does not consider hue a grouping variable",
                    "+                # So unused hue levels are in the data, but not the lookup table",
                    "+                return (0, 0, 0, 0)",
                    "+"
                ],
                "start_lineno": 152,
                "end_lineno": 152
            }
        ]
    },
    "scikit-learn__scikit-learn-12557": {
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"",
                    "+=========================================================",
                    "+SVM Tie Breaking Example",
                    "+=========================================================",
                    "+Tie breaking is costly if ``decision_function_shape='ovr'``, and therefore it",
                    "+is not enabled by default. This example illustrates the effect of the",
                    "+``break_ties`` parameter for a multiclass classification problem and",
                    "+``decision_function_shape='ovr'``.",
                    "+",
                    "+The two plots differ only in the area in the middle where the classes are",
                    "+tied. If ``break_ties=False``, all input in that area would be classified as",
                    "+one class, whereas if ``break_ties=True``, the tie-breaking mechanism will",
                    "+create a non-convex decision boundary in that area.",
                    "+\"\"\"",
                    "+print(__doc__)",
                    "+",
                    "+",
                    "+# Code source: Andreas Mueller, Adrin Jalali",
                    "+# License: BSD 3 clause",
                    "+",
                    "+",
                    "+import numpy as np",
                    "+import matplotlib.pyplot as plt",
                    "+from sklearn.svm import SVC",
                    "+from sklearn.datasets import make_blobs",
                    "+",
                    "+X, y = make_blobs(random_state=27)",
                    "+",
                    "+fig, sub = plt.subplots(2, 1, figsize=(5, 8))",
                    "+titles = (\"break_ties = False\",",
                    "+          \"break_ties = True\")",
                    "+",
                    "+for break_ties, title, ax in zip((False, True), titles, sub.flatten()):",
                    "+",
                    "+    svm = SVC(kernel=\"linear\", C=1, break_ties=break_ties,",
                    "+              decision_function_shape='ovr').fit(X, y)",
                    "+",
                    "+    xlim = [X[:, 0].min(), X[:, 0].max()]",
                    "+    ylim = [X[:, 1].min(), X[:, 1].max()]",
                    "+",
                    "+    xs = np.linspace(xlim[0], xlim[1], 1000)",
                    "+    ys = np.linspace(ylim[0], ylim[1], 1000)",
                    "+    xx, yy = np.meshgrid(xs, ys)",
                    "+",
                    "+    pred = svm.predict(np.c_[xx.ravel(), yy.ravel()])",
                    "+",
                    "+    colors = [plt.cm.Accent(i) for i in [0, 4, 7]]",
                    "+",
                    "+    points = ax.scatter(X[:, 0], X[:, 1], c=y, cmap=\"Accent\")",
                    "+    classes = [(0, 1), (0, 2), (1, 2)]",
                    "+    line = np.linspace(X[:, 1].min() - 5, X[:, 1].max() + 5)",
                    "+    ax.imshow(-pred.reshape(xx.shape), cmap=\"Accent\", alpha=.2,",
                    "+              extent=(xlim[0], xlim[1], ylim[1], ylim[0]))",
                    "+",
                    "+    for coef, intercept, col in zip(svm.coef_, svm.intercept_, classes):",
                    "+        line2 = -(line * coef[1] + intercept) / coef[0]",
                    "+        ax.plot(line2, line, \"-\", c=colors[col[0]])",
                    "+        ax.plot(line2, line, \"--\", c=colors[col[1]])",
                    "+    ax.set_xlim(xlim)",
                    "+    ax.set_ylim(ylim)",
                    "+    ax.set_title(title)",
                    "+    ax.set_aspect(\"equal\")",
                    "+",
                    "+plt.show()"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "sklearn/model_selection/_search.py": [
            {
                "hunk": [
                    "-           estimator=SVC(C=1.0, cache_size=..., class_weight=..., coef0=...,",
                    "+           estimator=SVC(C=1.0, break_ties=False, cache_size=...,",
                    "+                         class_weight=..., coef0=...,",
                    "                          decision_function_shape='ovr', degree=..., gamma=...,",
                    "-                         kernel='rbf', max_iter=-1, probability=False,",
                    "-                         random_state=None, shrinking=True, tol=...,",
                    "-                         verbose=False),",
                    "+                         kernel='rbf', max_iter=-1,",
                    "+                         probability=False,",
                    "+                         random_state=None, shrinking=True,",
                    "+                         tol=..., verbose=False),"
                ],
                "start_lineno": 986,
                "end_lineno": 990
            }
        ],
        "sklearn/svm/base.py": [
            {
                "hunk": [
                    "-                 max_iter, decision_function_shape, random_state):",
                    "+                 max_iter, decision_function_shape, random_state,",
                    "+                 break_ties):",
                    "         self.decision_function_shape = decision_function_shape",
                    "+        self.break_ties = break_ties"
                ],
                "start_lineno": 504,
                "end_lineno": 505
            },
            {
                "hunk": [
                    "-        y = super().predict(X)",
                    "+        check_is_fitted(self, \"classes_\")",
                    "+        if self.break_ties and self.decision_function_shape == 'ovo':",
                    "+            raise ValueError(\"break_ties must be False when \"",
                    "+                             \"decision_function_shape is 'ovo'\")",
                    "+",
                    "+        if (self.break_ties",
                    "+                and self.decision_function_shape == 'ovr'",
                    "+                and len(self.classes_) > 2):",
                    "+            y = np.argmax(self.decision_function(X), axis=1)",
                    "+        else:",
                    "+            y = super().predict(X)"
                ],
                "start_lineno": 574,
                "end_lineno": 574
            }
        ],
        "sklearn/svm/classes.py": [
            {
                "hunk": [
                    "+    break_ties : bool, optional (default=False)",
                    "+        If true, ``decision_function_shape='ovr'``, and number of classes > 2,",
                    "+        :term:`predict` will break ties according to the confidence values of",
                    "+        :term:`decision_function`; otherwise the first class among the tied",
                    "+        classes is returned. Please note that breaking ties comes at a",
                    "+        relatively high computational cost compared to a simple predict.",
                    "+",
                    "+        .. versionadded:: 0.22",
                    "+"
                ],
                "start_lineno": 524,
                "end_lineno": 524
            },
            {
                "hunk": [
                    "-    SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,",
                    "+    SVC(C=1.0, break_ties=False, cache_size=200, class_weight=None, coef0=0.0,",
                    "         decision_function_shape='ovr', degree=3, gamma='auto', kernel='rbf',",
                    "-        max_iter=-1, probability=False, random_state=None, shrinking=True,",
                    "-        tol=0.001, verbose=False)",
                    "+        max_iter=-1, probability=False,",
                    "+        random_state=None, shrinking=True, tol=0.001, verbose=False)"
                ],
                "start_lineno": 581,
                "end_lineno": 584
            },
            {
                "hunk": [
                    "+                 break_ties=False,"
                ],
                "start_lineno": 614,
                "end_lineno": 614
            },
            {
                "hunk": [
                    "+            break_ties=break_ties,"
                ],
                "start_lineno": 622,
                "end_lineno": 622
            },
            {
                "hunk": [
                    "+    break_ties : bool, optional (default=False)",
                    "+        If true, ``decision_function_shape='ovr'``, and number of classes > 2,",
                    "+        :term:`predict` will break ties according to the confidence values of",
                    "+        :term:`decision_function`; otherwise the first class among the tied",
                    "+        classes is returned. Please note that breaking ties comes at a",
                    "+        relatively high computational cost compared to a simple predict.",
                    "+",
                    "+        .. versionadded:: 0.22",
                    "+"
                ],
                "start_lineno": 710,
                "end_lineno": 710
            },
            {
                "hunk": [
                    "-    NuSVC(cache_size=200, class_weight=None, coef0=0.0,",
                    "+    NuSVC(break_ties=False, cache_size=200, class_weight=None, coef0=0.0,",
                    "           decision_function_shape='ovr', degree=3, gamma='scale', kernel='rbf',",
                    "-          max_iter=-1, nu=0.5, probability=False, random_state=None,",
                    "-          shrinking=True, tol=0.001, verbose=False)",
                    "+          max_iter=-1, nu=0.5, probability=False,",
                    "+          random_state=None, shrinking=True, tol=0.001, verbose=False)"
                ],
                "start_lineno": 753,
                "end_lineno": 756
            },
            {
                "hunk": [
                    "-                 decision_function_shape='ovr', random_state=None):",
                    "+                 decision_function_shape='ovr', break_ties=False,",
                    "+                 random_state=None):"
                ],
                "start_lineno": 781,
                "end_lineno": 781
            },
            {
                "hunk": [
                    "+            break_ties=break_ties,"
                ],
                "start_lineno": 789,
                "end_lineno": 789
            }
        ]
    },
    "matplotlib__matplotlib-21542": {
        "lib/matplotlib/colorbar.py": [
            {
                "hunk": [
                    "+        If string, it supports '%' operator and `str.format` formats:",
                    "+        e.g. ``\"%4.2e\"`` or ``\"{x:.2e}\"``."
                ],
                "start_lineno": 355,
                "end_lineno": 355
            },
            {
                "hunk": [
                    "-            self.formatter = ticker.FormatStrFormatter(format)",
                    "+            # Check format between FormatStrFormatter and StrMethodFormatter",
                    "+            try:",
                    "+                self.formatter = ticker.FormatStrFormatter(format)",
                    "+                _ = self.formatter(0)",
                    "+            except TypeError:",
                    "+                self.formatter = ticker.StrMethodFormatter(format)"
                ],
                "start_lineno": 490,
                "end_lineno": 490
            }
        ]
    },
    "django__django-16139": {
        "django/contrib/auth/forms.py": [
            {
                "hunk": [
                    "-            password.help_text = password.help_text.format(\"../password/\")",
                    "+            password.help_text = password.help_text.format(",
                    "+                f\"../../{self.instance.pk}/password/\"",
                    "+            )"
                ],
                "start_lineno": 166,
                "end_lineno": 166
            }
        ]
    },
    "sympy__sympy-24723": {
        "sympy/stats/matrix_distributions.py": [
            {
                "hunk": [
                    "-        den = (2*pi)**(S(n*p)/2) * Determinant(U)**S(p)/2 * Determinant(V)**S(n)/2",
                    "+        den = (2*pi)**(S(n*p)/2) * Determinant(U)**(S(p)/2) * Determinant(V)**(S(n)/2)"
                ],
                "start_lineno": 453,
                "end_lineno": 453
            },
            {
                "hunk": [
                    "-    2*exp(-Trace((Matrix([",
                    "+    exp(-Trace((Matrix([",
                    "     [-1],",
                    "-    [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/pi",
                    "+    [-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/(2*pi)",
                    "     >>> density(M)([[3, 4]]).doit()",
                    "-    2*exp(-4)/pi",
                    "+    exp(-4)/(2*pi)"
                ],
                "start_lineno": 485,
                "end_lineno": 489
            }
        ]
    },
    "sphinx-doc__sphinx-9999": {
        "sphinx/writers/latex.py": [
            {
                "hunk": [
                    "-        ctx += r'}] \\leavevmode'",
                    "-        self.body.append(r'\\item[{')",
                    "+        ctx += r'}'",
                    "+        self.body.append(r'\\sphinxlineitem{')"
                ],
                "start_lineno": 1095,
                "end_lineno": 1096
            }
        ]
    },
    "django__django-12185": {
        "django/db/models/query_utils.py": [
            {
                "hunk": [
                    "-        clause, joins = query._add_q(self, reuse, allow_joins=allow_joins, split_subq=False)",
                    "+        clause, joins = query._add_q(",
                    "+            self, reuse, allow_joins=allow_joins, split_subq=False,",
                    "+            check_filterable=False,",
                    "+        )"
                ],
                "start_lineno": 103,
                "end_lineno": 103
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-        if not getattr(expression, 'filterable', 'True'):",
                    "+        if not getattr(expression, 'filterable', True):"
                ],
                "start_lineno": 1117,
                "end_lineno": 1117
            },
            {
                "hunk": [
                    "-                     reuse_with_filtered_relation=False):",
                    "+                     reuse_with_filtered_relation=False, check_filterable=True):"
                ],
                "start_lineno": 1193,
                "end_lineno": 1193
            },
            {
                "hunk": [
                    "+                check_filterable=check_filterable,"
                ],
                "start_lineno": 1232,
                "end_lineno": 1232
            },
            {
                "hunk": [
                    "-        self.check_filterable(reffed_expression)",
                    "+        if check_filterable:",
                    "+            self.check_filterable(reffed_expression)"
                ],
                "start_lineno": 1247,
                "end_lineno": 1247
            },
            {
                "hunk": [
                    "-        self.check_filterable(value)",
                    "+        if check_filterable:",
                    "+            self.check_filterable(value)"
                ],
                "start_lineno": 1256,
                "end_lineno": 1256
            },
            {
                "hunk": [
                    "-               current_negated=False, allow_joins=True, split_subq=True):",
                    "+               current_negated=False, allow_joins=True, split_subq=True,",
                    "+               check_filterable=True):"
                ],
                "start_lineno": 1352,
                "end_lineno": 1352
            },
            {
                "hunk": [
                    "-                split_subq=split_subq,",
                    "+                split_subq=split_subq, check_filterable=check_filterable,"
                ],
                "start_lineno": 1364,
                "end_lineno": 1364
            }
        ]
    },
    "pytest-dev__pytest-10552": {
        "src/_pytest/python.py": [
            {
                "hunk": [
                    "-            if isinstance(obj, staticmethod):",
                    "-                # staticmethods need to be unwrapped.",
                    "+            if isinstance(obj, (staticmethod, classmethod)):",
                    "+                # staticmethods and classmethods need to be unwrapped."
                ],
                "start_lineno": 406,
                "end_lineno": 407
            }
        ]
    },
    "pydata__xarray-5682": {
        "xarray/plot/utils.py": [
            {
                "hunk": [
                    "-    return \"\\n\".join(textwrap.wrap(name + extra + units, 30))",
                    "+    # Treat `name` differently if it's a latex sequence",
                    "+    if name.startswith(\"$\") and (name.count(\"$\") % 2 == 0):",
                    "+        return \"$\\n$\".join(",
                    "+            textwrap.wrap(name + extra + units, 60, break_long_words=False)",
                    "+        )",
                    "+    else:",
                    "+        return \"\\n\".join(textwrap.wrap(name + extra + units, 30))"
                ],
                "start_lineno": 493,
                "end_lineno": 493
            }
        ]
    },
    "django__django-13821": {
        "django/db/backends/sqlite3/base.py": [
            {
                "hunk": [
                    "-    if Database.sqlite_version_info < (3, 8, 3):",
                    "-        raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)",
                    "+    if Database.sqlite_version_info < (3, 9, 0):",
                    "+        raise ImproperlyConfigured(",
                    "+            'SQLite 3.9.0 or later is required (found %s).' % Database.sqlite_version",
                    "+        )"
                ],
                "start_lineno": 67,
                "end_lineno": 68
            }
        ]
    },
    "pydata__xarray-6548": {
        "dev/null": [
            {
                "hunk": [
                    "+import numpy as np",
                    "+",
                    "+import xarray as xr",
                    "+",
                    "+from . import parameterized, randn, requires_dask",
                    "+",
                    "+NDEGS = (2, 5, 20)",
                    "+NX = (10**2, 10**6)",
                    "+",
                    "+",
                    "+class Polyval:",
                    "+    def setup(self, *args, **kwargs):",
                    "+        self.xs = {nx: xr.DataArray(randn((nx,)), dims=\"x\", name=\"x\") for nx in NX}",
                    "+        self.coeffs = {",
                    "+            ndeg: xr.DataArray(",
                    "+                randn((ndeg,)), dims=\"degree\", coords={\"degree\": np.arange(ndeg)}",
                    "+            )",
                    "+            for ndeg in NDEGS",
                    "+        }",
                    "+",
                    "+    @parameterized([\"nx\", \"ndeg\"], [NX, NDEGS])",
                    "+    def time_polyval(self, nx, ndeg):",
                    "+        x = self.xs[nx]",
                    "+        c = self.coeffs[ndeg]",
                    "+        xr.polyval(x, c).compute()",
                    "+",
                    "+    @parameterized([\"nx\", \"ndeg\"], [NX, NDEGS])",
                    "+    def peakmem_polyval(self, nx, ndeg):",
                    "+        x = self.xs[nx]",
                    "+        c = self.coeffs[ndeg]",
                    "+        xr.polyval(x, c).compute()",
                    "+",
                    "+",
                    "+class PolyvalDask(Polyval):",
                    "+    def setup(self, *args, **kwargs):",
                    "+        requires_dask()",
                    "+        super().setup(*args, **kwargs)",
                    "+        self.xs = {k: v.chunk({\"x\": 10000}) for k, v in self.xs.items()}"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "xarray/core/computation.py": [
            {
                "hunk": [
                    "+    overload,",
                    " )",
                    " ",
                    " import numpy as np",
                    " ",
                    " from . import dtypes, duck_array_ops, utils",
                    " from .alignment import align, deep_align",
                    "+from .common import zeros_like",
                    "+from .duck_array_ops import datetime_to_numeric"
                ],
                "start_lineno": 20,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "-def polyval(coord, coeffs, degree_dim=\"degree\"):",
                    "+@overload",
                    "+def polyval(coord: DataArray, coeffs: DataArray, degree_dim: Hashable) -> DataArray:",
                    "+    ...",
                    "+",
                    "+",
                    "+@overload",
                    "+def polyval(coord: T_Xarray, coeffs: Dataset, degree_dim: Hashable) -> Dataset:",
                    "+    ...",
                    "+",
                    "+",
                    "+@overload",
                    "+def polyval(coord: Dataset, coeffs: T_Xarray, degree_dim: Hashable) -> Dataset:",
                    "+    ...",
                    "+",
                    "+",
                    "+def polyval(",
                    "+    coord: T_Xarray, coeffs: T_Xarray, degree_dim: Hashable = \"degree\"",
                    "+) -> T_Xarray:",
                    "     \"\"\"Evaluate a polynomial at specific values",
                    " ",
                    "     Parameters",
                    "     ----------",
                    "-    coord : DataArray",
                    "-        The 1D coordinate along which to evaluate the polynomial.",
                    "-    coeffs : DataArray",
                    "-        Coefficients of the polynomials.",
                    "-    degree_dim : str, default: \"degree\"",
                    "+    coord : DataArray or Dataset",
                    "+        Values at which to evaluate the polynomial.",
                    "+    coeffs : DataArray or Dataset",
                    "+        Coefficients of the polynomial.",
                    "+    degree_dim : Hashable, default: \"degree\"",
                    "         Name of the polynomial degree dimension in `coeffs`.",
                    " ",
                    "+    Returns",
                    "+    -------",
                    "+    DataArray or Dataset",
                    "+        Evaluated polynomial.",
                    "+",
                    "     See Also",
                    "     --------",
                    "     xarray.DataArray.polyfit",
                    "-    numpy.polyval",
                    "+    numpy.polynomial.polynomial.polyval",
                    "     \"\"\"",
                    "-    from .dataarray import DataArray",
                    "-    from .missing import get_clean_interp_index",
                    " ",
                    "-    x = get_clean_interp_index(coord, coord.name, strict=False)",
                    "+    if degree_dim not in coeffs._indexes:",
                    "+        raise ValueError(",
                    "+            f\"Dimension `{degree_dim}` should be a coordinate variable with labels.\"",
                    "+        )",
                    "+    if not np.issubdtype(coeffs[degree_dim].dtype, int):",
                    "+        raise ValueError(",
                    "+            f\"Dimension `{degree_dim}` should be of integer dtype. Received {coeffs[degree_dim].dtype} instead.\"",
                    "+        )",
                    "+    max_deg = coeffs[degree_dim].max().item()",
                    "+    coeffs = coeffs.reindex(",
                    "+        {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False",
                    "+    )",
                    "+    coord = _ensure_numeric(coord)",
                    "+",
                    "+    # using Horner's method",
                    "+    # https://en.wikipedia.org/wiki/Horner%27s_method",
                    "+    res = coeffs.isel({degree_dim: max_deg}, drop=True) + zeros_like(coord)",
                    "+    for deg in range(max_deg - 1, -1, -1):",
                    "+        res *= coord",
                    "+        res += coeffs.isel({degree_dim: deg}, drop=True)",
                    " ",
                    "-    deg_coord = coeffs[degree_dim]",
                    "+    return res",
                    " ",
                    "-    lhs = DataArray(",
                    "-        np.vander(x, int(deg_coord.max()) + 1),",
                    "-        dims=(coord.name, degree_dim),",
                    "-        coords={coord.name: coord, degree_dim: np.arange(deg_coord.max() + 1)[::-1]},",
                    "-    )",
                    "-    return (lhs * coeffs).sum(degree_dim)",
                    "+",
                    "+def _ensure_numeric(data: T_Xarray) -> T_Xarray:",
                    "+    \"\"\"Converts all datetime64 variables to float64",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    data : DataArray or Dataset",
                    "+        Variables with possible datetime dtypes.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    DataArray or Dataset",
                    "+        Variables with datetime64 dtypes converted to float64.",
                    "+    \"\"\"",
                    "+    from .dataset import Dataset",
                    "+",
                    "+    def to_floatable(x: DataArray) -> DataArray:",
                    "+        if x.dtype.kind in \"mM\":",
                    "+            return x.copy(",
                    "+                data=datetime_to_numeric(",
                    "+                    x.data,",
                    "+                    offset=np.datetime64(\"1970-01-01\"),",
                    "+                    datetime_unit=\"ns\",",
                    "+                ),",
                    "+            )",
                    "+        return x",
                    "+",
                    "+    if isinstance(data, Dataset):",
                    "+        return data.map(to_floatable)",
                    "+    else:",
                    "+        return to_floatable(data)"
                ],
                "start_lineno": 1846,
                "end_lineno": 1875
            }
        ]
    },
    "django__django-15204": {
        "django/utils/dateparse.py": [
            {
                "hunk": [
                    "-    r'(?:(?P<days>\\d+(.\\d+)?)D)?'",
                    "+    r'(?:(?P<days>\\d+([\\.,]\\d+)?)D)?'",
                    "     r'(?:T'",
                    "-    r'(?:(?P<hours>\\d+(.\\d+)?)H)?'",
                    "-    r'(?:(?P<minutes>\\d+(.\\d+)?)M)?'",
                    "-    r'(?:(?P<seconds>\\d+(.\\d+)?)S)?'",
                    "+    r'(?:(?P<hours>\\d+([\\.,]\\d+)?)H)?'",
                    "+    r'(?:(?P<minutes>\\d+([\\.,]\\d+)?)M)?'",
                    "+    r'(?:(?P<seconds>\\d+([\\.,]\\d+)?)S)?'"
                ],
                "start_lineno": 45,
                "end_lineno": 49
            }
        ]
    },
    "sympy__sympy-20139": {
        "sympy/core/symbol.py": [
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 45,
                "end_lineno": 45
            }
        ],
        "sympy/matrices/expressions/matexpr.py": [
            {
                "hunk": [
                    "+from sympy.core.symbol import Str"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-            name = Symbol(name)",
                    "+            name = Str(name)"
                ],
                "start_lineno": 775,
                "end_lineno": 775
            }
        ],
        "sympy/printing/dot.py": [
            {
                "hunk": [
                    "+    >>> from sympy.core.symbol import Str # noqa: F401"
                ],
                "start_lineno": 38,
                "end_lineno": 38
            },
            {
                "hunk": [
                    "-    \"MatrixSymbol(Symbol('x'), Integer(2), Integer(2))\"",
                    "+    \"MatrixSymbol(Str('x'), Integer(2), Integer(2))\""
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "-    (\"MatrixSymbol(Symbol('x'), Integer(2), Integer(2))\",",
                    "-     (\"Symbol('x')\", 'Integer(2)', 'Integer(2)'))",
                    "+    (\"MatrixSymbol(Str('x'), Integer(2), Integer(2))\",",
                    "+     (\"Str('x')\", 'Integer(2)', 'Integer(2)'))"
                ],
                "start_lineno": 62,
                "end_lineno": 63
            }
        ]
    },
    "astropy__astropy-14413": {
        "astropy/units/format/console.py": [
            {
                "hunk": [
                    "-      2.1798721*10^-18m^2 kg s^-2",
                    "+      2.1798721*10^-18 m^2 kg s^-2"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "+    @classmethod",
                    "+    def _format_mantissa(cls, m):",
                    "+        return m",
                    "+"
                ],
                "start_lineno": 34,
                "end_lineno": 34
            },
            {
                "hunk": [
                    "-            parts.append(m)",
                    "+            parts.append(cls._format_mantissa(m))"
                ],
                "start_lineno": 57,
                "end_lineno": 57
            },
            {
                "hunk": [
                    "+                if s:",
                    "+                    s += \" \""
                ],
                "start_lineno": 73,
                "end_lineno": 73
            },
            {
                "hunk": [
                    "-                    f = f\"{{0:^{len(s)}s}} {{1:^{fraclength}s}}\"",
                    "+                    f = f\"{{0:<{len(s)}s}}{{1:^{fraclength}s}}\""
                ],
                "start_lineno": 87,
                "end_lineno": 87
            }
        ],
        "astropy/units/format/latex.py": [
            {
                "hunk": [
                    "-                s = cls.format_exponential_notation(unit.scale) + r\"\\,\"",
                    "+                s = cls.format_exponential_notation(unit.scale)",
                    " ",
                    "             if len(unit.bases):",
                    "+                if s:",
                    "+                    s += r\"\\,\""
                ],
                "start_lineno": 65,
                "end_lineno": 67
            }
        ],
        "astropy/units/format/unicode_format.py": [
            {
                "hunk": [
                    "-from . import console, utils",
                    "+from . import console"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-      100000kg m\u207b\u00b9 s\u207b\u00b2",
                    "+      100000 kg m\u207b\u00b9 s\u207b\u00b2"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-    def format_exponential_notation(cls, val):",
                    "-        m, ex = utils.split_mantissa_exponent(val)",
                    "-",
                    "-        parts = []",
                    "-        if m:",
                    "-            parts.append(m.replace(\"-\", \"\u2212\"))",
                    "-",
                    "-        if ex:",
                    "-            parts.append(f\"10{cls._format_superscript(ex)}\")",
                    "-",
                    "-        return cls._times.join(parts)",
                    "+    def _format_mantissa(cls, m):",
                    "+        return m.replace(\"-\", \"\u2212\")",
                    " ",
                    "     @classmethod",
                    "     def _format_superscript(cls, number):",
                    "-        mapping = {",
                    "-            \"0\": \"\u2070\",",
                    "-            \"1\": \"\u00b9\",",
                    "-            \"2\": \"\u00b2\",",
                    "-            \"3\": \"\u00b3\",",
                    "-            \"4\": \"\u2074\",",
                    "-            \"5\": \"\u2075\",",
                    "-            \"6\": \"\u2076\",",
                    "-            \"7\": \"\u2077\",",
                    "-            \"8\": \"\u2078\",",
                    "-            \"9\": \"\u2079\",",
                    "-            \"-\": \"\u207b\",",
                    "-            \"\u2212\": \"\u207b\",",
                    "-            # This is actually a \"raised omission bracket\", but it's",
                    "-            # the closest thing I could find to a superscript solidus.",
                    "-            \"/\": \"\u2e0d\",",
                    "-        }",
                    "-        output = []",
                    "-        for c in number:",
                    "-            output.append(mapping[c])",
                    "-        return \"\".join(output)",
                    "+        mapping = str.maketrans(",
                    "+            {",
                    "+                \"0\": \"\u2070\",",
                    "+                \"1\": \"\u00b9\",",
                    "+                \"2\": \"\u00b2\",",
                    "+                \"3\": \"\u00b3\",",
                    "+                \"4\": \"\u2074\",",
                    "+                \"5\": \"\u2075\",",
                    "+                \"6\": \"\u2076\",",
                    "+                \"7\": \"\u2077\",",
                    "+                \"8\": \"\u2078\",",
                    "+                \"9\": \"\u2079\",",
                    "+                \"-\": \"\u207b\",",
                    "+                \"\u2212\": \"\u207b\",",
                    "+                # This is actually a \"raised omission bracket\", but it's",
                    "+                # the closest thing I could find to a superscript solidus.",
                    "+                \"/\": \"\u2e0d\",",
                    "+            }",
                    "+        )",
                    "+        return number.translate(mapping)"
                ],
                "start_lineno": 35,
                "end_lineno": 69
            }
        ]
    },
    "django__django-13170": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-        for lookup in chain((filtered_relation.relation_name,), lookups):",
                    "-            lookup_parts, field_parts, _ = self.solve_lookup_type(lookup)",
                    "+        relation_lookup_parts, relation_field_parts, _ = self.solve_lookup_type(filtered_relation.relation_name)",
                    "+        if relation_lookup_parts:",
                    "+            raise ValueError(",
                    "+                \"FilteredRelation's relation_name cannot contain lookups \"",
                    "+                \"(got %r).\" % filtered_relation.relation_name",
                    "+            )",
                    "+        for lookup in chain(lookups):",
                    "+            lookup_parts, lookup_field_parts, _ = self.solve_lookup_type(lookup)",
                    "             shift = 2 if not lookup_parts else 1",
                    "-            if len(field_parts) > (shift + len(lookup_parts)):",
                    "-                raise ValueError(",
                    "-                    \"FilteredRelation's condition doesn't support nested \"",
                    "-                    \"relations (got %r).\" % lookup",
                    "-                )",
                    "+            lookup_field_path = lookup_field_parts[:-shift]",
                    "+            for idx, lookup_field_part in enumerate(lookup_field_path):",
                    "+                if len(relation_field_parts) > idx:",
                    "+                    if relation_field_parts[idx] != lookup_field_part:",
                    "+                        raise ValueError(",
                    "+                            \"FilteredRelation's condition doesn't support \"",
                    "+                            \"relations outside the %r (got %r).\"",
                    "+                            % (filtered_relation.relation_name, lookup)",
                    "+                        )",
                    "+                else:",
                    "+                    raise ValueError(",
                    "+                        \"FilteredRelation's condition doesn't support nested \"",
                    "+                        \"relations deeper than the relation_name (got %r for \"",
                    "+                        \"%r).\" % (lookup, filtered_relation.relation_name)",
                    "+                    )"
                ],
                "start_lineno": 1422,
                "end_lineno": 1429
            },
            {
                "hunk": [
                    "-                    field = opts.get_field(filtered_relation.relation_name)",
                    "+                    if LOOKUP_SEP in filtered_relation.relation_name:",
                    "+                        parts = filtered_relation.relation_name.split(LOOKUP_SEP)",
                    "+                        filtered_relation_path, field, _, _ = self.names_to_path(",
                    "+                            parts, opts, allow_many, fail_on_missing,",
                    "+                        )",
                    "+                        path.extend(filtered_relation_path[:-1])",
                    "+                    else:",
                    "+                        field = opts.get_field(filtered_relation.relation_name)"
                ],
                "start_lineno": 1462,
                "end_lineno": 1462
            }
        ]
    },
    "matplotlib__matplotlib-23288": {
        "lib/matplotlib/backends/backend_pdf.py": [
            {
                "hunk": [
                    "+def _calculate_quad_point_coordinates(x, y, width, height, angle=0):",
                    "+    \"\"\"",
                    "+    Calculate the coordinates of rectangle when rotated by angle around x, y",
                    "+    \"\"\"",
                    "+",
                    "+    angle = math.radians(-angle)",
                    "+    sin_angle = math.sin(angle)",
                    "+    cos_angle = math.cos(angle)",
                    "+    a = x + height * sin_angle",
                    "+    b = y + height * cos_angle",
                    "+    c = x + width * cos_angle + height * sin_angle",
                    "+    d = y - width * sin_angle + height * cos_angle",
                    "+    e = x + width * cos_angle",
                    "+    f = y - width * sin_angle",
                    "+    return ((x, y), (e, f), (c, d), (a, b))",
                    "+",
                    "+",
                    "+def _get_coordinates_of_block(x, y, width, height, angle=0):",
                    "+    \"\"\"",
                    "+    Get the coordinates of rotated rectangle and rectangle that covers the",
                    "+    rotated rectangle.",
                    "+    \"\"\"",
                    "+",
                    "+    vertices = _calculate_quad_point_coordinates(x, y, width,",
                    "+                                                 height, angle)",
                    "+",
                    "+    # Find min and max values for rectangle",
                    "+    # adjust so that QuadPoints is inside Rect",
                    "+    # PDF docs says that QuadPoints should be ignored if any point lies",
                    "+    # outside Rect, but for Acrobat it is enough that QuadPoints is on the",
                    "+    # border of Rect.",
                    "+",
                    "+    pad = 0.00001 if angle % 90 else 0",
                    "+    min_x = min(v[0] for v in vertices) - pad",
                    "+    min_y = min(v[1] for v in vertices) - pad",
                    "+    max_x = max(v[0] for v in vertices) + pad",
                    "+    max_y = max(v[1] for v in vertices) + pad",
                    "+    return (tuple(itertools.chain.from_iterable(vertices)),",
                    "+            (min_x, min_y, max_x, max_y))",
                    "+",
                    "+",
                    "+def _get_link_annotation(gc, x, y, width, height, angle=0):",
                    "+    \"\"\"",
                    "+    Create a link annotation object for embedding URLs.",
                    "+    \"\"\"",
                    "+    quadpoints, rect = _get_coordinates_of_block(x, y, width, height, angle)",
                    "+    link_annotation = {",
                    "+        'Type': Name('Annot'),",
                    "+        'Subtype': Name('Link'),",
                    "+        'Rect': rect,",
                    "+        'Border': [0, 0, 0],",
                    "+        'A': {",
                    "+            'S': Name('URI'),",
                    "+            'URI': gc.get_url(),",
                    "+        },",
                    "+    }",
                    "+    if angle % 90:",
                    "+        # Add QuadPoints",
                    "+        link_annotation['QuadPoints'] = quadpoints",
                    "+    return link_annotation",
                    "+",
                    "+"
                ],
                "start_lineno": 253,
                "end_lineno": 253
            },
            {
                "hunk": [
                    "-            link_annotation = {",
                    "-                'Type': Name('Annot'),",
                    "-                'Subtype': Name('Link'),",
                    "-                'Rect': (x, y, x + width, y + height),",
                    "-                'Border': [0, 0, 0],",
                    "-                'A': {",
                    "-                    'S': Name('URI'),",
                    "-                    'URI': gc.get_url(),",
                    "-                },",
                    "-            }",
                    "-            self.file._annotations[-1][1].append(link_annotation)",
                    "+            self.file._annotations[-1][1].append(_get_link_annotation(",
                    "+                gc, x, y, width, height, angle))"
                ],
                "start_lineno": 2157,
                "end_lineno": 2167
            },
            {
                "hunk": [
                    "-            link_annotation = {",
                    "-                'Type': Name('Annot'),",
                    "-                'Subtype': Name('Link'),",
                    "-                'Rect': (x, y, x + page.width, y + page.height),",
                    "-                'Border': [0, 0, 0],",
                    "-                'A': {",
                    "-                    'S': Name('URI'),",
                    "-                    'URI': gc.get_url(),",
                    "-                },",
                    "-            }",
                    "-            self.file._annotations[-1][1].append(link_annotation)",
                    "+            self.file._annotations[-1][1].append(_get_link_annotation(",
                    "+                gc, x, y, page.width, page.height, angle))"
                ],
                "start_lineno": 2223,
                "end_lineno": 2233
            },
            {
                "hunk": [
                    "-            link_annotation = {",
                    "-                'Type': Name('Annot'),",
                    "-                'Subtype': Name('Link'),",
                    "-                'Rect': (x, y, x + width / 64, y + height / 64),",
                    "-                'Border': [0, 0, 0],",
                    "-                'A': {",
                    "-                    'S': Name('URI'),",
                    "-                    'URI': gc.get_url(),",
                    "-                },",
                    "-            }",
                    "-            self.file._annotations[-1][1].append(link_annotation)",
                    "+            self.file._annotations[-1][1].append(_get_link_annotation(",
                    "+                gc, x, y, width / 64, height / 64, angle))"
                ],
                "start_lineno": 2333,
                "end_lineno": 2343
            }
        ]
    },
    "matplotlib__matplotlib-20693": {
        "lib/matplotlib/widgets.py": [
            {
                "hunk": [
                    "-        self.artists = []"
                ],
                "start_lineno": 1803,
                "end_lineno": 1803
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def artists(self):",
                    "+        \"\"\"Tuple of the artists of the selector.\"\"\"",
                    "+        handles_artists = getattr(self, '_handles_artists', ())",
                    "+        return (self._selection_artist,) + handles_artists",
                    "+",
                    "+    def set_props(self, **props):",
                    "+        \"\"\"",
                    "+        Set the properties of the selector artist. See the `props` argument",
                    "+        in the selector docstring to know which properties are supported.",
                    "+        \"\"\"",
                    "+        artist = self._selection_artist",
                    "+        props = cbook.normalize_kwargs(props, artist)",
                    "+        artist.set(**props)",
                    "+        if self.useblit:",
                    "+            self.update()",
                    "+        self._props.update(props)",
                    "+",
                    "+    def set_handle_props(self, **handle_props):",
                    "+        \"\"\"",
                    "+        Set the properties of the handles selector artist. See the",
                    "+        `handle_props` argument in the selector docstring to know which",
                    "+        properties are supported.",
                    "+        \"\"\"",
                    "+        if not hasattr(self, '_handles_artists'):",
                    "+            raise NotImplementedError(\"This selector doesn't have handles.\")",
                    "+",
                    "+        artist = self._handles_artists[0]",
                    "+        handle_props = cbook.normalize_kwargs(handle_props, artist)",
                    "+        for handle in self._handles_artists:",
                    "+            handle.set(**handle_props)",
                    "+        if self.useblit:",
                    "+            self.update()",
                    "+        self._handle_props.update(handle_props)",
                    "+"
                ],
                "start_lineno": 2012,
                "end_lineno": 2012
            },
            {
                "hunk": [
                    "-        self._rect = None"
                ],
                "start_lineno": 2117,
                "end_lineno": 2117
            },
            {
                "hunk": [
                    "+        self._edge_handles = None",
                    "         self.drag_from_anywhere = drag_from_anywhere",
                    "         self.ignore_event_outside = ignore_event_outside",
                    " ",
                    "         # Reset canvas so that `new_axes` connects events.",
                    "         self.canvas = None",
                    "-        self.artists = []",
                    "         self.new_axes(ax)",
                    " ",
                    "         # Setup handles",
                    "-        handle_props = {",
                    "+        self._handle_props = {",
                    "             'color': props.get('facecolor', 'r'),",
                    "-            **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}",
                    "+            **cbook.normalize_kwargs(handle_props, Line2D)}",
                    " ",
                    "         if self._interactive:",
                    "             self._edge_order = ['min', 'max']",
                    "-            self._setup_edge_handle(handle_props)",
                    "+            self._setup_edge_handles(self._handle_props)",
                    " ",
                    "         self._active_handle = None",
                    " ",
                    "         # prev attribute is deprecated but we still need to maintain it",
                    "         self._prev = (0, 0)",
                    " ",
                    "-    rect = _api.deprecate_privatize_attribute(\"3.5\")",
                    "+    rect = _api.deprecated(\"3.5\")(",
                    "+        property(lambda self: self._selection_artist)",
                    "+        )"
                ],
                "start_lineno": 2131,
                "end_lineno": 2153
            },
            {
                "hunk": [
                    "-        self._rect = Rectangle((0, 0), w, h,",
                    "-                               transform=trans,",
                    "-                               visible=False,",
                    "-                               **self._props)",
                    "-",
                    "-        self.ax.add_patch(self._rect)",
                    "-        if len(self.artists) > 0:",
                    "-            self.artists[0] = self._rect",
                    "-        else:",
                    "-            self.artists.append(self._rect)",
                    "+        rect_artist = Rectangle((0, 0), w, h,",
                    "+                                transform=trans,",
                    "+                                visible=False,",
                    "+                                **self._props)",
                    "+",
                    "+        self.ax.add_patch(rect_artist)",
                    "+        self._selection_artist = rect_artist",
                    " ",
                    "-    def _setup_edge_handle(self, props):",
                    "+    def _setup_edge_handles(self, props):"
                ],
                "start_lineno": 2188,
                "end_lineno": 2199
            },
            {
                "hunk": [
                    "-        self.artists.extend([line for line in self._edge_handles.artists])",
                    "+",
                    "+    @property",
                    "+    def _handles_artists(self):",
                    "+        if self._edge_handles is not None:",
                    "+            return self._edge_handles.artists",
                    "+        else:",
                    "+            return ()"
                ],
                "start_lineno": 2209,
                "end_lineno": 2209
            },
            {
                "hunk": [
                    "-        if self._interactive and self._rect.get_visible():",
                    "+        if self._interactive and self._selection_artist.get_visible():"
                ],
                "start_lineno": 2231,
                "end_lineno": 2231
            },
            {
                "hunk": [
                    "-            self._rect.remove()",
                    "+            self._selection_artist.remove()",
                    "             if self._interactive:",
                    "                 self._edge_handles.remove()",
                    "-                for artist in self._edge_handles.artists:",
                    "-                    self.artists.remove(artist)",
                    "             self._direction = direction",
                    "             self.new_axes(self.ax)",
                    "             if self._interactive:",
                    "-                self._setup_edge_handle(self._edge_handles._line_props)",
                    "+                self._setup_edge_handles(self._handle_props)"
                ],
                "start_lineno": 2271,
                "end_lineno": 2279
            },
            {
                "hunk": [
                    "-            self._rect.set_visible(False)",
                    "+            self._selection_artist.set_visible(False)"
                ],
                "start_lineno": 2290,
                "end_lineno": 2290
            },
            {
                "hunk": [
                    "-            self._rect.set_x(vmin)",
                    "-            self._rect.set_width(vmax - vmin)",
                    "+            self._selection_artist.set_x(vmin)",
                    "+            self._selection_artist.set_width(vmax - vmin)",
                    "         else:",
                    "-            self._rect.set_y(vmin)",
                    "-            self._rect.set_height(vmax - vmin)",
                    "+            self._selection_artist.set_y(vmin)",
                    "+            self._selection_artist.set_height(vmax - vmin)"
                ],
                "start_lineno": 2378,
                "end_lineno": 2382
            },
            {
                "hunk": [
                    "-        return self._rect.contains(event, radius=0)[0]",
                    "+        return self._selection_artist.contains(event, radius=0)[0]",
                    " ",
                    "     @property",
                    "     def extents(self):",
                    "         \"\"\"Return extents of the span selector.\"\"\"",
                    "         if self.direction == 'horizontal':",
                    "-            vmin = self._rect.get_x()",
                    "-            vmax = vmin + self._rect.get_width()",
                    "+            vmin = self._selection_artist.get_x()",
                    "+            vmax = vmin + self._selection_artist.get_width()",
                    "         else:",
                    "-            vmin = self._rect.get_y()",
                    "-            vmax = vmin + self._rect.get_height()",
                    "+            vmin = self._selection_artist.get_y()",
                    "+            vmax = vmin + self._selection_artist.get_height()"
                ],
                "start_lineno": 2412,
                "end_lineno": 2422
            },
            {
                "hunk": [
                    "-        self._line_props = line_props",
                    " ",
                    "-        self.artists = [line_fun(p, **line_props) for p in positions]",
                    "+        self._artists = [line_fun(p, **line_props) for p in positions]",
                    "+",
                    "+    @property",
                    "+    def artists(self):",
                    "+        return tuple(self._artists)"
                ],
                "start_lineno": 2467,
                "end_lineno": 2469
            },
            {
                "hunk": [
                    "-        for artist in self.artists:",
                    "+        for artist in self._artists:"
                ],
                "start_lineno": 2508,
                "end_lineno": 2508
            },
            {
                "hunk": [
                    "-        self.artist = self._markers"
                ],
                "start_lineno": 2567,
                "end_lineno": 2567
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def artists(self):",
                    "+        return (self._markers, )",
                    "+"
                ],
                "start_lineno": 2577,
                "end_lineno": 2577
            },
            {
                "hunk": [
                    "-        self._to_draw = None"
                ],
                "start_lineno": 2729,
                "end_lineno": 2729
            },
            {
                "hunk": [
                    "-            _props = props",
                    "-            self.visible = _props.pop('visible', self.visible)",
                    "-            self._to_draw = self._shape_klass((0, 0), 0, 1, visible=False,",
                    "-                                              **_props)",
                    "-            self.ax.add_patch(self._to_draw)",
                    "+            self.visible = props.pop('visible', self.visible)",
                    "+            self._props = props",
                    "+            to_draw = self._shape_klass((0, 0), 0, 1, visible=False,",
                    "+                                        **self._props)",
                    "+            self.ax.add_patch(to_draw)"
                ],
                "start_lineno": 2749,
                "end_lineno": 2753
            },
            {
                "hunk": [
                    "-            self.lineprops = lineprops",
                    "-            self._to_draw = Line2D([0, 0], [0, 0], visible=False,",
                    "-                                   **self.lineprops)",
                    "-            self.ax.add_line(self._to_draw)",
                    "+            self._props = lineprops",
                    "+            to_draw = Line2D([0, 0], [0, 0], visible=False, **self._props)",
                    "+            self.ax.add_line(to_draw)",
                    "+",
                    "+        self._selection_artist = to_draw"
                ],
                "start_lineno": 2763,
                "end_lineno": 2766
            },
            {
                "hunk": [
                    "-        handle_props = {",
                    "-            'markeredgecolor': (props or {}).get('edgecolor', 'black'),",
                    "-            **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}",
                    "-",
                    "-        self._corner_order = ['NW', 'NE', 'SE', 'SW']",
                    "-        xc, yc = self.corners",
                    "-        self._corner_handles = ToolHandles(self.ax, xc, yc,",
                    "-                                           marker_props=handle_props,",
                    "-                                           useblit=self.useblit)",
                    "-",
                    "-        self._edge_order = ['W', 'N', 'E', 'S']",
                    "-        xe, ye = self.edge_centers",
                    "-        self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',",
                    "-                                         marker_props=handle_props,",
                    "-                                         useblit=self.useblit)",
                    "-",
                    "-        xc, yc = self.center",
                    "-        self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',",
                    "-                                          marker_props=handle_props,",
                    "-                                          useblit=self.useblit)",
                    "-",
                    "-        self._active_handle = None",
                    "+        if self._interactive:",
                    "+            self._handle_props = {",
                    "+                'markeredgecolor': (self._props or {}).get(",
                    "+                    'edgecolor', 'black'),",
                    "+                **cbook.normalize_kwargs(handle_props, Line2D)}",
                    "+",
                    "+            self._corner_order = ['NW', 'NE', 'SE', 'SW']",
                    "+            xc, yc = self.corners",
                    "+            self._corner_handles = ToolHandles(self.ax, xc, yc,",
                    "+                                               marker_props=self._handle_props,",
                    "+                                               useblit=self.useblit)",
                    "+",
                    "+            self._edge_order = ['W', 'N', 'E', 'S']",
                    "+            xe, ye = self.edge_centers",
                    "+            self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',",
                    "+                                             marker_props=self._handle_props,",
                    "+                                             useblit=self.useblit)",
                    " ",
                    "-        self.artists = [self._to_draw, self._center_handle.artist,",
                    "-                        self._corner_handles.artist,",
                    "-                        self._edge_handles.artist]",
                    "+            xc, yc = self.center",
                    "+            self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',",
                    "+                                              marker_props=self._handle_props,",
                    "+                                              useblit=self.useblit)",
                    " ",
                    "-        if not self._interactive:",
                    "-            self.artists = [self._to_draw]",
                    "+            self._active_handle = None",
                    " ",
                    "         self._extents_on_press = None",
                    " ",
                    "-    to_draw = _api.deprecate_privatize_attribute(\"3.5\")",
                    "+    to_draw = _api.deprecated(\"3.5\")(",
                    "+        property(lambda self: self._selection_artist)",
                    "+        )"
                ],
                "start_lineno": 2777,
                "end_lineno": 2809
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def _handles_artists(self):",
                    "+        return (*self._center_handle.artists, *self._corner_handles.artists,",
                    "+                *self._edge_handles.artists)",
                    "+",
                    "     def _press(self, event):",
                    "         \"\"\"Button press event handler.\"\"\"",
                    "         # make the drawn box/line visible get the click-coordinates,",
                    "         # button, ...",
                    "-        if self._interactive and self._to_draw.get_visible():",
                    "+        if self._interactive and self._selection_artist.get_visible():"
                ],
                "start_lineno": 2821,
                "end_lineno": 2825
            },
            {
                "hunk": [
                    "-            self._to_draw.set_visible(False)",
                    "+            self._selection_artist.set_visible(False)"
                ],
                "start_lineno": 2848,
                "end_lineno": 2848
            },
            {
                "hunk": [
                    "-            x0 = self._to_draw.get_x()",
                    "-            y0 = self._to_draw.get_y()",
                    "-            width = self._to_draw.get_width()",
                    "-            height = self._to_draw.get_height()",
                    "+            x0 = self._selection_artist.get_x()",
                    "+            y0 = self._selection_artist.get_y()",
                    "+            width = self._selection_artist.get_width()",
                    "+            height = self._selection_artist.get_height()",
                    "             return x0, y0, width, height",
                    "         else:",
                    "-            x, y = self._to_draw.get_data()",
                    "+            x, y = self._selection_artist.get_data()"
                ],
                "start_lineno": 2958,
                "end_lineno": 2964
            },
            {
                "hunk": [
                    "-        # Update displayed handles",
                    "-        self._corner_handles.set_data(*self.corners)",
                    "-        self._edge_handles.set_data(*self.edge_centers)",
                    "-        self._center_handle.set_data(*self.center)",
                    "+        if self._interactive:",
                    "+            # Update displayed handles",
                    "+            self._corner_handles.set_data(*self.corners)",
                    "+            self._edge_handles.set_data(*self.edge_centers)",
                    "+            self._center_handle.set_data(*self.center)"
                ],
                "start_lineno": 3005,
                "end_lineno": 3008
            },
            {
                "hunk": [
                    "-            self._to_draw.set_x(xmin)",
                    "-            self._to_draw.set_y(ymin)",
                    "-            self._to_draw.set_width(xmax - xmin)",
                    "-            self._to_draw.set_height(ymax - ymin)",
                    "+            self._selection_artist.set_x(xmin)",
                    "+            self._selection_artist.set_y(ymin)",
                    "+            self._selection_artist.set_width(xmax - xmin)",
                    "+            self._selection_artist.set_height(ymax - ymin)",
                    " ",
                    "         elif self._drawtype == 'line':",
                    "-            self._to_draw.set_data([xmin, xmax], [ymin, ymax])",
                    "+            self._selection_artist.set_data([xmin, xmax], [ymin, ymax])"
                ],
                "start_lineno": 3027,
                "end_lineno": 3033
            },
            {
                "hunk": [
                    "-        return self._to_draw.contains(event, radius=0)[0]",
                    "+        return self._selection_artist.contains(event, radius=0)[0]"
                ],
                "start_lineno": 3077,
                "end_lineno": 3077
            },
            {
                "hunk": [
                    "-        if hasattr(self._to_draw, 'get_verts'):",
                    "+        if hasattr(self._selection_artist, 'get_verts'):",
                    "             xfm = self.ax.transData.inverted()",
                    "-            y, x = xfm.transform(self._to_draw.get_verts()).T",
                    "+            y, x = xfm.transform(self._selection_artist.get_verts()).T",
                    "             return np.array([x, y])",
                    "         else:",
                    "-            return np.array(self._to_draw.get_data())",
                    "+            return np.array(self._selection_artist.get_data())"
                ],
                "start_lineno": 3088,
                "end_lineno": 3093
            },
            {
                "hunk": [
                    "-            self._to_draw.center = center",
                    "-            self._to_draw.width = 2 * a",
                    "-            self._to_draw.height = 2 * b",
                    "+            self._selection_artist.center = center",
                    "+            self._selection_artist.width = 2 * a",
                    "+            self._selection_artist.height = 2 * b",
                    "         else:",
                    "             rad = np.deg2rad(np.arange(31) * 12)",
                    "             x = a * np.cos(rad) + center[0]",
                    "             y = b * np.sin(rad) + center[1]",
                    "-            self._to_draw.set_data(x, y)",
                    "+            self._selection_artist.set_data(x, y)",
                    " ",
                    "     @property",
                    "     def _rect_bbox(self):",
                    "         if self._drawtype == 'box':",
                    "-            x, y = self._to_draw.center",
                    "-            width = self._to_draw.width",
                    "-            height = self._to_draw.height",
                    "+            x, y = self._selection_artist.center",
                    "+            width = self._selection_artist.width",
                    "+            height = self._selection_artist.height",
                    "             return x - width / 2., y - height / 2., width, height",
                    "         else:",
                    "-            x, y = self._to_draw.get_data()",
                    "+            x, y = self._selection_artist.get_data()"
                ],
                "start_lineno": 3127,
                "end_lineno": 3144
            },
            {
                "hunk": [
                    "-        self.line = Line2D([], [], **props)",
                    "-        self.ax.add_line(self.line)",
                    "-        self.artists = [self.line]",
                    "+        line = Line2D([], [], **props)",
                    "+        self.ax.add_line(line)",
                    "+        self._selection_artist = line"
                ],
                "start_lineno": 3199,
                "end_lineno": 3201
            },
            {
                "hunk": [
                    "-        self.line.set_visible(True)",
                    "+        self._selection_artist.set_visible(True)"
                ],
                "start_lineno": 3209,
                "end_lineno": 3209
            },
            {
                "hunk": [
                    "-        self.line.set_data([[], []])",
                    "-        self.line.set_visible(False)",
                    "+        self._selection_artist.set_data([[], []])",
                    "+        self._selection_artist.set_visible(False)",
                    "         self.verts = None",
                    " ",
                    "     def _onmove(self, event):",
                    "         if self.verts is None:",
                    "             return",
                    "         self.verts.append(self._get_data(event))",
                    "-        self.line.set_data(list(zip(*self.verts)))",
                    "+        self._selection_artist.set_data(list(zip(*self.verts)))",
                    "+"
                ],
                "start_lineno": 3219,
                "end_lineno": 3227
            },
            {
                "hunk": [
                    "-        self.line = Line2D(self._xs, self._ys, **props)",
                    "-        self.ax.add_line(self.line)",
                    "+        self._props = props",
                    "+        line = Line2D(self._xs, self._ys, **self._props)",
                    "+        self.ax.add_line(line)",
                    "+        self._selection_artist = line",
                    " ",
                    "         if handle_props is None:",
                    "             handle_props = dict(markeredgecolor='k',",
                    "-                                markerfacecolor=props.get('color', 'k'))",
                    "+                                markerfacecolor=self._props.get('color', 'k'))",
                    "+        self._handle_props = handle_props",
                    "         self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,",
                    "                                             useblit=self.useblit,",
                    "-                                            marker_props=handle_props)",
                    "+                                            marker_props=self._handle_props)",
                    " ",
                    "         self._active_handle_idx = -1",
                    "         self.grab_range = grab_range",
                    " ",
                    "-        self.artists = [self.line, self._polygon_handles.artist]",
                    "         self.set_visible(True)",
                    " ",
                    "+    line = _api.deprecated(\"3.5\")(",
                    "+        property(lambda self: self._selection_artist)",
                    "+        )",
                    "+"
                ],
                "start_lineno": 3315,
                "end_lineno": 3330
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def _handles_artists(self):",
                    "+        return self._polygon_handles.artists",
                    "+"
                ],
                "start_lineno": 3341,
                "end_lineno": 3341
            },
            {
                "hunk": [
                    "-            x0, y0 = self.line.get_transform().transform((self._xs[0],",
                    "-                                                          self._ys[0]))",
                    "+            x0, y0 = self._selection_artist.get_transform().transform(",
                    "+                    (self._xs[0], self._ys[0])",
                    "+                )"
                ],
                "start_lineno": 3440,
                "end_lineno": 3441
            },
            {
                "hunk": [
                    "-        self.line.set_data(self._xs, self._ys)",
                    "+        self._selection_artist.set_data(self._xs, self._ys)"
                ],
                "start_lineno": 3481,
                "end_lineno": 3481
            }
        ]
    },
    "django__django-14311": {
        "django/utils/autoreload.py": [
            {
                "hunk": [
                    "-    if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:",
                    "-        args += ['-m', __main__.__spec__.parent]",
                    "+    if getattr(__main__, '__spec__', None) is not None:",
                    "+        spec = __main__.__spec__",
                    "+        if (spec.name == '__main__' or spec.name.endswith('.__main__')) and spec.parent:",
                    "+            name = spec.parent",
                    "+        else:",
                    "+            name = spec.name",
                    "+        args += ['-m', name]"
                ],
                "start_lineno": 226,
                "end_lineno": 227
            }
        ]
    },
    "pydata__xarray-7101": {
        "xarray/core/coordinates.py": [
            {
                "hunk": [
                    "+        self._data._coord_names.intersection_update(variables)"
                ],
                "start_lineno": 318,
                "end_lineno": 318
            },
            {
                "hunk": [
                    "-                DeprecationWarning,",
                    "+                FutureWarning,"
                ],
                "start_lineno": 444,
                "end_lineno": 444
            }
        ]
    },
    "sympy__sympy-17845": {
        "sympy/calculus/singularities.py": [
            {
                "hunk": [
                    "-    {-1}",
                    "+    FiniteSet(-1)",
                    "     >>> singularities(1/(y**2 + 1), y)",
                    "-    {-I, I}",
                    "+    FiniteSet(I, -I)",
                    "     >>> singularities(1/(y**3 + 1), y)",
                    "-    {-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2}",
                    "+    FiniteSet(-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2)"
                ],
                "start_lineno": 76,
                "end_lineno": 80
            }
        ],
        "sympy/calculus/util.py": [
            {
                "hunk": [
                    "-    {pi/2, 3*pi/2, 5*pi/2, 7*pi/2}",
                    "+    FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)"
                ],
                "start_lineno": 747,
                "end_lineno": 747
            },
            {
                "hunk": [
                    "-        {1, 2}",
                    "+        FiniteSet(1, 2)"
                ],
                "start_lineno": 1553,
                "end_lineno": 1553
            }
        ],
        "sympy/categories/baseclasses.py": [
            {
                "hunk": [
                    "-        Class({Object(\"A\"), Object(\"B\")})",
                    "+        Class(FiniteSet(Object(\"A\"), Object(\"B\")))"
                ],
                "start_lineno": 485,
                "end_lineno": 485
            },
            {
                "hunk": [
                    "-        {unique}",
                    "+        FiniteSet(unique)"
                ],
                "start_lineno": 680,
                "end_lineno": 680
            },
            {
                "hunk": [
                    "-        {Object(\"A\"), Object(\"B\"), Object(\"C\")}",
                    "+        FiniteSet(Object(\"A\"), Object(\"B\"), Object(\"C\"))"
                ],
                "start_lineno": 812,
                "end_lineno": 812
            }
        ],
        "sympy/combinatorics/partitions.py": [
            {
                "hunk": [
                    "-        {{3}, {1, 2}}",
                    "+        Partition(FiniteSet(1, 2), FiniteSet(3))"
                ],
                "start_lineno": 45,
                "end_lineno": 45
            },
            {
                "hunk": [
                    "-        {{4, 5}, {1, 2, 3}}",
                    "+        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))"
                ],
                "start_lineno": 56,
                "end_lineno": 56
            },
            {
                "hunk": [
                    "-        {{4, 5}, {1, 2, 3}}",
                    "+        Partition(FiniteSet(1, 2, 3), FiniteSet(4, 5))"
                ],
                "start_lineno": 64,
                "end_lineno": 64
            },
            {
                "hunk": [
                    "-        [{{1, 2}}, {{1}, {2}}, {{1, x}}, {{3, 4}}, {{0, 1, 2, 3}}]",
                    "+        [Partition(FiniteSet(1, 2)), Partition(FiniteSet(1), FiniteSet(2)), Partition(FiniteSet(1, x)), Partition(FiniteSet(3, 4)), Partition(FiniteSet(0, 1, 2, 3))]"
                ],
                "start_lineno": 110,
                "end_lineno": 110
            },
            {
                "hunk": [
                    "-        {{3}, {4}, {5}, {1, 2}}",
                    "+        Partition(FiniteSet(1, 2), FiniteSet(3), FiniteSet(4), FiniteSet(5))"
                ],
                "start_lineno": 253,
                "end_lineno": 253
            },
            {
                "hunk": [
                    "-        {{c}, {a, d}, {b, e}}",
                    "+        Partition(FiniteSet(c), FiniteSet(a, d), FiniteSet(b, e))",
                    "         >>> Partition.from_rgs([0, 1, 2, 0, 1], list('cbead'))",
                    "-        {{e}, {a, c}, {b, d}}",
                    "+        Partition(FiniteSet(e), FiniteSet(a, c), FiniteSet(b, d))",
                    "         >>> a = Partition([1, 4], [2], [3, 5])",
                    "         >>> Partition.from_rgs(a.RGS, a.members)",
                    "-        {{2}, {1, 4}, {3, 5}}",
                    "+        Partition(FiniteSet(1, 4), FiniteSet(2), FiniteSet(3, 5))"
                ],
                "start_lineno": 281,
                "end_lineno": 286
            }
        ],
        "sympy/combinatorics/polyhedron.py": [
            {
                "hunk": [
                    "-            {(0, 1, 2)}",
                    "+            FiniteSet((0, 1, 2))",
                    "             >>> Polyhedron(list('abc'), [(1, 0, 2)]).faces",
                    "-            {(0, 1, 2)}",
                    "+            FiniteSet((0, 1, 2))"
                ],
                "start_lineno": 50,
                "end_lineno": 52
            },
            {
                "hunk": [
                    "-        {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}",
                    "+        FiniteSet((0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3))"
                ],
                "start_lineno": 95,
                "end_lineno": 95
            },
            {
                "hunk": [
                    "-        {(0, 1), (0, 3), (0, 4), '...', (4, 7), (5, 6), (6, 7)}",
                    "+        FiniteSet((0, 1), (0, 3), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (3, 7), (4, 5), (4, 7), (5, 6), (6, 7))"
                ],
                "start_lineno": 368,
                "end_lineno": 368
            },
            {
                "hunk": [
                    "-        {(0, 1), (0, 2), (1, 2)}",
                    "+        FiniteSet((0, 1), (0, 2), (1, 2))"
                ],
                "start_lineno": 496,
                "end_lineno": 496
            }
        ],
        "sympy/core/function.py": [
            {
                "hunk": [
                    "-        {1}",
                    "+        FiniteSet(1)",
                    "         >>> Function('f', nargs=(2, 1)).nargs",
                    "-        {1, 2}",
                    "+        FiniteSet(1, 2)"
                ],
                "start_lineno": 240,
                "end_lineno": 242
            },
            {
                "hunk": [
                    "-    {2}",
                    "+    FiniteSet(2)"
                ],
                "start_lineno": 975,
                "end_lineno": 975
            },
            {
                "hunk": [
                    "-    {1, 2}",
                    "+    FiniteSet(1, 2)"
                ],
                "start_lineno": 986,
                "end_lineno": 986
            }
        ],
        "sympy/logic/boolalg.py": [
            {
                "hunk": [
                    "-        {0}",
                    "+        FiniteSet(0)"
                ],
                "start_lineno": 134,
                "end_lineno": 134
            }
        ],
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "-    def _print_FiniteSet(self, s):",
                    "-        s = sorted(s, key=default_sort_key)",
                    "-        if len(s) > 10:",
                    "-            printset = s[:3] + ['...'] + s[-3:]",
                    "-        else:",
                    "-            printset = s",
                    "-        return '{' + ', '.join(self._print(el) for el in printset) + '}'",
                    "-"
                ],
                "start_lineno": 152,
                "end_lineno": 159
            }
        ],
        "sympy/sets/conditionset.py": [
            {
                "hunk": [
                    "-    ConditionSet(x, x < 1, {y, z})",
                    "+    ConditionSet(x, x < 1, FiniteSet(y, z))",
                    " ",
                    "     A second substitution is needed to change the dummy symbol, too:",
                    " ",
                    "     >>> _.subs(x, y)",
                    "-    ConditionSet(y, y < 1, {y, z})",
                    "+    ConditionSet(y, y < 1, FiniteSet(y, z))",
                    " ",
                    "     And trying to replace the dummy symbol with anything but a symbol",
                    "     is ignored: the only change possible will be in the base set:",
                    " ",
                    "     >>> ConditionSet(y, y < 1, {y, z}).subs(y, 1)",
                    "-    ConditionSet(y, y < 1, {z})",
                    "+    ConditionSet(y, y < 1, FiniteSet(z))",
                    "     >>> _.subs(y, 1)",
                    "-    ConditionSet(y, y < 1, {z})",
                    "+    ConditionSet(y, y < 1, FiniteSet(z))"
                ],
                "start_lineno": 68,
                "end_lineno": 81
            }
        ],
        "sympy/sets/fancysets.py": [
            {
                "hunk": [
                    "-    {1, 4, 9}",
                    "+    FiniteSet(1, 4, 9)"
                ],
                "start_lineno": 281,
                "end_lineno": 281
            },
            {
                "hunk": [
                    "-    {0}",
                    "+    FiniteSet(0)"
                ],
                "start_lineno": 303,
                "end_lineno": 303
            },
            {
                "hunk": [
                    "-    {0, pi}",
                    "+    FiniteSet(0, pi)"
                ],
                "start_lineno": 924,
                "end_lineno": 924
            },
            {
                "hunk": [
                    "-        CartesianComplexRegion(ProductSet(Interval(0, 1), {0}))",
                    "+        CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))"
                ],
                "start_lineno": 1203,
                "end_lineno": 1203
            }
        ],
        "sympy/sets/powerset.py": [
            {
                "hunk": [
                    "-    PowerSet({1, 2, 3})",
                    "+    PowerSet(FiniteSet(1, 2, 3))"
                ],
                "start_lineno": 46,
                "end_lineno": 46
            },
            {
                "hunk": [
                    "-    {EmptySet, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}",
                    "+    FiniteSet(FiniteSet(1), FiniteSet(1, 2), FiniteSet(1, 3),",
                    "+            FiniteSet(1, 2, 3), FiniteSet(2), FiniteSet(2, 3),",
                    "+            FiniteSet(3), EmptySet)"
                ],
                "start_lineno": 63,
                "end_lineno": 63
            }
        ],
        "sympy/sets/sets.py": [
            {
                "hunk": [
                    "-        Union({3}, Interval.Lopen(1, 2))",
                    "+        Union(FiniteSet(3), Interval.Lopen(1, 2))"
                ],
                "start_lineno": 112,
                "end_lineno": 112
            },
            {
                "hunk": [
                    "-        {EmptySet}",
                    "+        FiniteSet(EmptySet)"
                ],
                "start_lineno": 472,
                "end_lineno": 472
            },
            {
                "hunk": [
                    "-        {0, 1}",
                    "+        FiniteSet(0, 1)",
                    "         >>> Interval(0, 1, True, False).boundary",
                    "-        {0, 1}",
                    "+        FiniteSet(0, 1)"
                ],
                "start_lineno": 535,
                "end_lineno": 537
            },
            {
                "hunk": [
                    "-    ProductSet(Interval(0, 5), {1, 2, 3})",
                    "+    ProductSet(Interval(0, 5), FiniteSet(1, 2, 3))"
                ],
                "start_lineno": 662,
                "end_lineno": 662
            },
            {
                "hunk": [
                    "-    {0, 2}",
                    "+    FiniteSet(0, 2)"
                ],
                "start_lineno": 1495,
                "end_lineno": 1495
            },
            {
                "hunk": [
                    "-    {1, 2, 3, 4}",
                    "+    FiniteSet(1, 2, 3, 4)",
                    "     >>> 3 in FiniteSet(1, 2, 3, 4)",
                    "     True",
                    " ",
                    "     >>> members = [1, 2, 3, 4]",
                    "     >>> f = FiniteSet(*members)",
                    "     >>> f",
                    "-    {1, 2, 3, 4}",
                    "+    FiniteSet(1, 2, 3, 4)",
                    "     >>> f - FiniteSet(2)",
                    "-    {1, 3, 4}",
                    "+    FiniteSet(1, 3, 4)",
                    "     >>> f + FiniteSet(2, 5)",
                    "-    {1, 2, 3, 4, 5}",
                    "+    FiniteSet(1, 2, 3, 4, 5)"
                ],
                "start_lineno": 1686,
                "end_lineno": 1697
            },
            {
                "hunk": [
                    "-    {1, 2, 4, 5}",
                    "+    FiniteSet(1, 2, 4, 5)"
                ],
                "start_lineno": 1896,
                "end_lineno": 1896
            }
        ],
        "sympy/solvers/inequalities.py": [
            {
                "hunk": [
                    "-    [{0}]",
                    "+    [FiniteSet(0)]",
                    " ",
                    "     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '!=')",
                    "     [Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]",
                    " ",
                    "     >>> solve_poly_inequality(Poly(x**2 - 1, x, domain='ZZ'), '==')",
                    "-    [{-1}, {1}]",
                    "+    [FiniteSet(-1), FiniteSet(1)]"
                ],
                "start_lineno": 32,
                "end_lineno": 38
            },
            {
                "hunk": [
                    "-    {1}",
                    "+    FiniteSet(1)"
                ],
                "start_lineno": 144,
                "end_lineno": 144
            }
        ],
        "sympy/solvers/solveset.py": [
            {
                "hunk": [
                    "-    (x, Intersection({log(y)}, Reals))",
                    "+    (x, Intersection(FiniteSet(log(y)), Reals))",
                    " ",
                    "     When does exp(x) == 1?",
                    " ",
                    "     >>> invert_complex(exp(x), 1, x)",
                    "     (x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))",
                    "     >>> invert_real(exp(x), 1, x)",
                    "-    (x, {0})",
                    "+    (x, FiniteSet(0))"
                ],
                "start_lineno": 139,
                "end_lineno": 146
            },
            {
                "hunk": [
                    "-    {0, log(2)}",
                    "+    FiniteSet(0, log(2))"
                ],
                "start_lineno": 808,
                "end_lineno": 808
            },
            {
                "hunk": [
                    "-    ConditionSet(x, (a > 0) & (b > 0), {0})",
                    "+    ConditionSet(x, (a > 0) & (b > 0), FiniteSet(0))",
                    "     >>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)",
                    "-    {-3*log(2)/(-2*log(3) + log(2))}",
                    "+    FiniteSet(-3*log(2)/(-2*log(3) + log(2)))",
                    "     >>> solve_expo(2**x - 4**x, 0, x, S.Reals)",
                    "-    {0}",
                    "+    FiniteSet(0)"
                ],
                "start_lineno": 1368,
                "end_lineno": 1372
            },
            {
                "hunk": [
                    "-    {-sqrt(10), sqrt(10)}",
                    "+    FiniteSet(sqrt(10), -sqrt(10))"
                ],
                "start_lineno": 1528,
                "end_lineno": 1528
            },
            {
                "hunk": [
                    "-    {-(log(3) + 3*log(5))/(-log(5) + 2*log(3))}",
                    "+    FiniteSet(-(log(3) + 3*log(5))/(-log(5) + 2*log(3)))"
                ],
                "start_lineno": 1682,
                "end_lineno": 1682
            },
            {
                "hunk": [
                    "-    {0}",
                    "+    FiniteSet(0)",
                    "     >>> solveset_real(exp(x) - 1, x)",
                    "-    {0}",
                    "+    FiniteSet(0)"
                ],
                "start_lineno": 1924,
                "end_lineno": 1926
            },
            {
                "hunk": [
                    "-    {(-1, 2, 0)}",
                    "+    FiniteSet((-1, 2, 0))"
                ],
                "start_lineno": 2426,
                "end_lineno": 2426
            },
            {
                "hunk": [
                    "-    {(z - 1, 2 - 2*z, z)}",
                    "+    FiniteSet((z - 1, 2 - 2*z, z))",
                    " ",
                    "     If no symbols are given, internally generated symbols will be used.",
                    "     The `tau0` in the 3rd position indicates (as before) that the 3rd",
                    "     variable -- whatever it's named -- can take on any value:",
                    " ",
                    "     >>> linsolve((A, b))",
                    "-    {(tau0 - 1, 2 - 2*tau0, tau0)}",
                    "+    FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))",
                    " ",
                    "     * List of Equations as input",
                    " ",
                    "     >>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]",
                    "     >>> linsolve(Eqns, x, y, z)",
                    "-    {(1, -2, -2)}",
                    "+    FiniteSet((1, -2, -2))"
                ],
                "start_lineno": 2437,
                "end_lineno": 2450
            },
            {
                "hunk": [
                    "-    {(3/10, 2/5, 0)}",
                    "+    FiniteSet((3/10, 2/5, 0))",
                    " ",
                    "     * Solve for symbolic coefficients",
                    " ",
                    "     >>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')",
                    "     >>> eqns = [a*x + b*y - c, d*x + e*y - f]",
                    "     >>> linsolve(eqns, x, y)",
                    "-    {((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}",
                    "+    FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))",
                    " ",
                    "     * A degenerate system returns solution as set of given",
                    "       symbols.",
                    " ",
                    "     >>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))",
                    "     >>> linsolve(system, x, y)",
                    "-    {(x, y)}",
                    "+    FiniteSet((x, y))"
                ],
                "start_lineno": 2461,
                "end_lineno": 2475
            },
            {
                "hunk": [
                    "-    {(1, 1)}",
                    "+    FiniteSet((1, 1))"
                ],
                "start_lineno": 2486,
                "end_lineno": 2486
            },
            {
                "hunk": [
                    "-    {(-1, 1)}",
                    "+    FiniteSet((-1, 1))",
                    " ",
                    "     * when you want soln should not satisfy eq `x + 1 = 0`",
                    " ",
                    "     >>> substitution([x + y], [x], [{y: 1}], [y], set([x + 1]), [y, x])",
                    "     EmptySet",
                    "     >>> substitution([x + y], [x], [{y: 1}], [y], set([x - 1]), [y, x])",
                    "-    {(1, -1)}",
                    "+    FiniteSet((1, -1))",
                    "     >>> substitution([x + y - 1, y - x**2 + 5], [x, y])",
                    "-    {(-3, 4), (2, -1)}",
                    "+    FiniteSet((-3, 4), (2, -1))",
                    " ",
                    "     * Returns both real and complex solution",
                    " ",
                    "     >>> x, y, z = symbols('x, y, z')",
                    "     >>> from sympy import exp, sin",
                    "     >>> substitution([exp(x) - sin(y), y**2 - 4], [x, y])",
                    "-    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),",
                    "-    (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}",
                    "+    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),",
                    "+            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))",
                    " ",
                    "     >>> eqs = [z**2 + exp(2*x) - sin(y), -3 + exp(-y)]",
                    "     >>> substitution(eqs, [y, z])",
                    "-    {(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),",
                    "-    (-log(3), sqrt(-exp(2*x) - sin(log(3)))),",
                    "+    FiniteSet((-log(3), sqrt(-exp(2*x) - sin(log(3)))),",
                    "+    (-log(3), -sqrt(-exp(2*x) - sin(log(3)))),",
                    "     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "-    ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),",
                    "+       ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)),",
                    "     (ImageSet(Lambda(_n, 2*_n*I*pi - log(3)), Integers),",
                    "-    ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers))}",
                    "+       ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi - log(3)))), Integers)))"
                ],
                "start_lineno": 2650,
                "end_lineno": 2676
            },
            {
                "hunk": [
                    "-    {(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}",
                    "+    FiniteSet((-1, -1), (-1/2, -2), (1/2, 2), (1, 1))"
                ],
                "start_lineno": 3257,
                "end_lineno": 3257
            },
            {
                "hunk": [
                    "-    {(2 - y, y)}",
                    "+    FiniteSet((2 - y, y))"
                ],
                "start_lineno": 3276,
                "end_lineno": 3276
            },
            {
                "hunk": [
                    "-    {(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),",
                    "-    (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)}",
                    "+    FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),",
                    "+            (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))",
                    "+"
                ],
                "start_lineno": 3284,
                "end_lineno": 3285
            },
            {
                "hunk": [
                    "-    {(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}",
                    "+    FiniteSet((-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I))"
                ],
                "start_lineno": 3293,
                "end_lineno": 3293
            },
            {
                "hunk": [
                    "-    {(3*z - 5, 4 - z, z)}",
                    "+    FiniteSet((3*z - 5, 4 - z, z))"
                ],
                "start_lineno": 3302,
                "end_lineno": 3302
            },
            {
                "hunk": [
                    "-    {(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}",
                    "+    FiniteSet((191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20))",
                    "     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])",
                    "-    {(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}",
                    "+    FiniteSet((1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5)))",
                    "     >>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])",
                    "-    {(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))}",
                    "+    FiniteSet((2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5)))"
                ],
                "start_lineno": 3310,
                "end_lineno": 3314
            }
        ],
        "sympy/stats/stochastic_process_types.py": [
            {
                "hunk": [
                    "-    {0, 1, 2}",
                    "+    FiniteSet(0, 1, 2)"
                ],
                "start_lineno": 556,
                "end_lineno": 556
            }
        ]
    },
    "django__django-16750": {
        "django/db/models/functions/text.py": [
            {
                "hunk": [
                    "+    output_field = CharField()"
                ],
                "start_lineno": 45,
                "end_lineno": 45
            }
        ]
    },
    "sphinx-doc__sphinx-9229": {
        "sphinx/ext/autodoc/__init__.py": [
            {
                "hunk": [
                    "-            return None",
                    "+            comment = self.get_variable_comment()",
                    "+            if comment:",
                    "+                return []",
                    "+            else:",
                    "+                return None"
                ],
                "start_lineno": 1679,
                "end_lineno": 1679
            },
            {
                "hunk": [
                    "+    def get_variable_comment(self) -> Optional[List[str]]:",
                    "+        try:",
                    "+            key = ('', '.'.join(self.objpath))",
                    "+            analyzer = ModuleAnalyzer.for_module(self.get_real_modname())",
                    "+            analyzer.analyze()",
                    "+            return list(self.analyzer.attr_docs.get(key, []))",
                    "+        except PycodeError:",
                    "+            return None",
                    "+",
                    "     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False",
                    "                     ) -> None:",
                    "-        if self.doc_as_attr:",
                    "+        if self.doc_as_attr and not self.get_variable_comment():"
                ],
                "start_lineno": 1724,
                "end_lineno": 1726
            }
        ]
    },
    "django__django-11525": {
        "django/core/mail/__init__.py": [
            {
                "hunk": [
                    "+    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.ADMINS):",
                    "+        raise ValueError('The ADMINS setting must be a list of 2-tuples.')"
                ],
                "start_lineno": 94,
                "end_lineno": 94
            },
            {
                "hunk": [
                    "+    if not all(isinstance(a, (list, tuple)) and len(a) == 2 for a in settings.MANAGERS):",
                    "+        raise ValueError('The MANAGERS setting must be a list of 2-tuples.')"
                ],
                "start_lineno": 109,
                "end_lineno": 109
            }
        ]
    },
    "pytest-dev__pytest-5808": {
        "src/_pytest/pastebin.py": [
            {
                "hunk": [
                    "-    params = {\"code\": contents, \"lexer\": \"python3\", \"expiry\": \"1week\"}",
                    "+    params = {\"code\": contents, \"lexer\": \"text\", \"expiry\": \"1week\"}"
                ],
                "start_lineno": 68,
                "end_lineno": 68
            }
        ]
    },
    "sympy__sympy-15625": {
        "sympy/core/basic.py": [
            {
                "hunk": [
                    "-        s = latex(self, mode='equation*')",
                    "-        s = s.strip('$')",
                    "-        return \"$$%s$$\" % s",
                    "+        s = latex(self, mode='plain')",
                    "+        return \"$\\\\displaystyle %s$\" % s"
                ],
                "start_lineno": 427,
                "end_lineno": 429
            }
        ],
        "sympy/interactive/printing.py": [
            {
                "hunk": [
                    "+            if latex_mode == 'plain':",
                    "+                s = '$\\\\displaystyle %s$' % s"
                ],
                "start_lineno": 151,
                "end_lineno": 151
            },
            {
                "hunk": [
                    "-            s = s.strip('$')",
                    "-            return '$$%s$$' % s",
                    "+            if latex_mode == 'plain':",
                    "+                return '$\\\\displaystyle %s$' % s",
                    "+            return s"
                ],
                "start_lineno": 174,
                "end_lineno": 175
            },
            {
                "hunk": [
                    "-                  latex_mode='equation*', print_builtin=True,",
                    "+                  latex_mode='plain', print_builtin=True,"
                ],
                "start_lineno": 272,
                "end_lineno": 272
            },
            {
                "hunk": [
                    "-    latex_mode: string, optional, default='equation*'",
                    "+    latex_mode: string, optional, default='plain'"
                ],
                "start_lineno": 328,
                "end_lineno": 328
            }
        ],
        "sympy/matrices/matrices.py": [
            {
                "hunk": [
                    "-        s = latex(self, mode='equation*')",
                    "-        s = s.strip('$')",
                    "-        return \"$$%s$$\" % s",
                    "+        s = latex(self, mode='plain')",
                    "+        return \"$\\\\displaystyle %s$\" % s"
                ],
                "start_lineno": 2055,
                "end_lineno": 2057
            }
        ],
        "sympy/physics/vector/dyadic.py": [
            {
                "hunk": [
                    "-        s = latex(self, mode='equation*')",
                    "-        s = s.strip('$')",
                    "-        return \"$$%s$$\" % s",
                    "+        s = latex(self, mode='plain')",
                    "+        return \"$\\\\displaystyle %s$\" % s"
                ],
                "start_lineno": 390,
                "end_lineno": 392
            }
        ],
        "sympy/physics/vector/vector.py": [
            {
                "hunk": [
                    "-        s = latex(self, mode='equation*')",
                    "-        s = s.strip('$')",
                    "-        return \"$$%s$$\" % s",
                    "+        s = latex(self, mode='plain')",
                    "+        return \"$\\\\displaystyle %s$\" % s"
                ],
                "start_lineno": 466,
                "end_lineno": 468
            }
        ],
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-                    if self._settings['mode'] in ['equation', 'equation*'] \\",
                    "+                    if self._settings['mode'] != 'inline' \\"
                ],
                "start_lineno": 672,
                "end_lineno": 672
            }
        ],
        "sympy/printing/preview.py": [
            {
                "hunk": [
                    "-        latex_string = latex(expr, mode='inline', **latex_settings)",
                    "+        latex_string = ('$\\\\displaystyle ' +",
                    "+                        latex(expr, mode='plain', **latex_settings) +",
                    "+                        '$')"
                ],
                "start_lineno": 183,
                "end_lineno": 183
            }
        ],
        "sympy/tensor/array/ndim_array.py": [
            {
                "hunk": [
                    "-        s = latex(self, mode='equation*')",
                    "-        s = s.strip('$')",
                    "-        return \"$$%s$$\" % s",
                    "+        s = latex(self, mode='plain')",
                    "+        return \"$\\\\displaystyle %s$\" % s"
                ],
                "start_lineno": 310,
                "end_lineno": 312
            }
        ]
    },
    "pydata__xarray-2922": {
        "xarray/core/common.py": [
            {
                "hunk": [
                    "+    def weighted(self, weights):",
                    "+        \"\"\"",
                    "+        Weighted operations.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        weights : DataArray",
                    "+            An array of weights associated with the values in this Dataset.",
                    "+            Each value in the data contributes to the reduction operation",
                    "+            according to its associated weight.",
                    "+",
                    "+        Notes",
                    "+        -----",
                    "+        ``weights`` must be a DataArray and cannot contain missing values.",
                    "+        Missing values can be replaced by ``weights.fillna(0)``.",
                    "+        \"\"\"",
                    "+",
                    "+        return self._weighted_cls(self, weights)",
                    "+"
                ],
                "start_lineno": 748,
                "end_lineno": 748
            }
        ],
        "xarray/core/dataarray.py": [
            {
                "hunk": [
                    "+    weighted,"
                ],
                "start_lineno": 36,
                "end_lineno": 36
            },
            {
                "hunk": [
                    "+    _weighted_cls = weighted.DataArrayWeighted"
                ],
                "start_lineno": 261,
                "end_lineno": 261
            }
        ],
        "xarray/core/dataset.py": [
            {
                "hunk": [
                    "+    weighted,"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            },
            {
                "hunk": [
                    "+    _weighted_cls = weighted.DatasetWeighted"
                ],
                "start_lineno": 460,
                "end_lineno": 460
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+from typing import TYPE_CHECKING, Hashable, Iterable, Optional, Union, overload",
                    "+",
                    "+from .computation import dot",
                    "+from .options import _get_keep_attrs",
                    "+",
                    "+if TYPE_CHECKING:",
                    "+    from .dataarray import DataArray, Dataset",
                    "+",
                    "+_WEIGHTED_REDUCE_DOCSTRING_TEMPLATE = \"\"\"",
                    "+    Reduce this {cls}'s data by a weighted ``{fcn}`` along some dimension(s).",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    dim : str or sequence of str, optional",
                    "+        Dimension(s) over which to apply the weighted ``{fcn}``.",
                    "+    skipna : bool, optional",
                    "+        If True, skip missing values (as marked by NaN). By default, only",
                    "+        skips missing values for float dtypes; other dtypes either do not",
                    "+        have a sentinel missing value (int) or skipna=True has not been",
                    "+        implemented (object, datetime64 or timedelta64).",
                    "+    keep_attrs : bool, optional",
                    "+        If True, the attributes (``attrs``) will be copied from the original",
                    "+        object to the new one.  If False (default), the new object will be",
                    "+        returned without attributes.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    reduced : {cls}",
                    "+        New {cls} object with weighted ``{fcn}`` applied to its data and",
                    "+        the indicated dimension(s) removed.",
                    "+",
                    "+    Notes",
                    "+    -----",
                    "+        Returns {on_zero} if the ``weights`` sum to 0.0 along the reduced",
                    "+        dimension(s).",
                    "+    \"\"\"",
                    "+",
                    "+_SUM_OF_WEIGHTS_DOCSTRING = \"\"\"",
                    "+    Calculate the sum of weights, accounting for missing values in the data",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    dim : str or sequence of str, optional",
                    "+        Dimension(s) over which to sum the weights.",
                    "+    keep_attrs : bool, optional",
                    "+        If True, the attributes (``attrs``) will be copied from the original",
                    "+        object to the new one.  If False (default), the new object will be",
                    "+        returned without attributes.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    reduced : {cls}",
                    "+        New {cls} object with the sum of the weights over the given dimension.",
                    "+    \"\"\"",
                    "+",
                    "+",
                    "+class Weighted:",
                    "+    \"\"\"An object that implements weighted operations.",
                    "+",
                    "+    You should create a Weighted object by using the ``DataArray.weighted`` or",
                    "+    ``Dataset.weighted`` methods.",
                    "+",
                    "+    See Also",
                    "+    --------",
                    "+    Dataset.weighted",
                    "+    DataArray.weighted",
                    "+    \"\"\"",
                    "+",
                    "+    __slots__ = (\"obj\", \"weights\")",
                    "+",
                    "+    @overload",
                    "+    def __init__(self, obj: \"DataArray\", weights: \"DataArray\") -> None:",
                    "+        ...",
                    "+",
                    "+    @overload  # noqa: F811",
                    "+    def __init__(self, obj: \"Dataset\", weights: \"DataArray\") -> None:  # noqa: F811",
                    "+        ...",
                    "+",
                    "+    def __init__(self, obj, weights):  # noqa: F811",
                    "+        \"\"\"",
                    "+        Create a Weighted object",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        obj : DataArray or Dataset",
                    "+            Object over which the weighted reduction operation is applied.",
                    "+        weights : DataArray",
                    "+            An array of weights associated with the values in the obj.",
                    "+            Each value in the obj contributes to the reduction operation",
                    "+            according to its associated weight.",
                    "+",
                    "+        Notes",
                    "+        -----",
                    "+        ``weights`` must be a ``DataArray`` and cannot contain missing values.",
                    "+        Missing values can be replaced by ``weights.fillna(0)``.",
                    "+        \"\"\"",
                    "+",
                    "+        from .dataarray import DataArray",
                    "+",
                    "+        if not isinstance(weights, DataArray):",
                    "+            raise ValueError(\"`weights` must be a DataArray\")",
                    "+",
                    "+        if weights.isnull().any():",
                    "+            raise ValueError(",
                    "+                \"`weights` cannot contain missing values. \"",
                    "+                \"Missing values can be replaced by `weights.fillna(0)`.\"",
                    "+            )",
                    "+",
                    "+        self.obj = obj",
                    "+        self.weights = weights",
                    "+",
                    "+    @staticmethod",
                    "+    def _reduce(",
                    "+        da: \"DataArray\",",
                    "+        weights: \"DataArray\",",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        skipna: Optional[bool] = None,",
                    "+    ) -> \"DataArray\":",
                    "+        \"\"\"reduce using dot; equivalent to (da * weights).sum(dim, skipna)",
                    "+",
                    "+            for internal use only",
                    "+        \"\"\"",
                    "+",
                    "+        # need to infer dims as we use `dot`",
                    "+        if dim is None:",
                    "+            dim = ...",
                    "+",
                    "+        # need to mask invalid values in da, as `dot` does not implement skipna",
                    "+        if skipna or (skipna is None and da.dtype.kind in \"cfO\"):",
                    "+            da = da.fillna(0.0)",
                    "+",
                    "+        # `dot` does not broadcast arrays, so this avoids creating a large",
                    "+        # DataArray (if `weights` has additional dimensions)",
                    "+        # maybe add fasttrack (`(da * weights).sum(dims=dim, skipna=skipna)`)",
                    "+        return dot(da, weights, dims=dim)",
                    "+",
                    "+    def _sum_of_weights(",
                    "+        self, da: \"DataArray\", dim: Optional[Union[Hashable, Iterable[Hashable]]] = None",
                    "+    ) -> \"DataArray\":",
                    "+        \"\"\" Calculate the sum of weights, accounting for missing values \"\"\"",
                    "+",
                    "+        # we need to mask data values that are nan; else the weights are wrong",
                    "+        mask = da.notnull()",
                    "+",
                    "+        sum_of_weights = self._reduce(mask, self.weights, dim=dim, skipna=False)",
                    "+",
                    "+        # 0-weights are not valid",
                    "+        valid_weights = sum_of_weights != 0.0",
                    "+",
                    "+        return sum_of_weights.where(valid_weights)",
                    "+",
                    "+    def _weighted_sum(",
                    "+        self,",
                    "+        da: \"DataArray\",",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        skipna: Optional[bool] = None,",
                    "+    ) -> \"DataArray\":",
                    "+        \"\"\"Reduce a DataArray by a by a weighted ``sum`` along some dimension(s).\"\"\"",
                    "+",
                    "+        return self._reduce(da, self.weights, dim=dim, skipna=skipna)",
                    "+",
                    "+    def _weighted_mean(",
                    "+        self,",
                    "+        da: \"DataArray\",",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        skipna: Optional[bool] = None,",
                    "+    ) -> \"DataArray\":",
                    "+        \"\"\"Reduce a DataArray by a weighted ``mean`` along some dimension(s).\"\"\"",
                    "+",
                    "+        weighted_sum = self._weighted_sum(da, dim=dim, skipna=skipna)",
                    "+",
                    "+        sum_of_weights = self._sum_of_weights(da, dim=dim)",
                    "+",
                    "+        return weighted_sum / sum_of_weights",
                    "+",
                    "+    def _implementation(self, func, dim, **kwargs):",
                    "+",
                    "+        raise NotImplementedError(\"Use `Dataset.weighted` or `DataArray.weighted`\")",
                    "+",
                    "+    def sum_of_weights(",
                    "+        self,",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        keep_attrs: Optional[bool] = None,",
                    "+    ) -> Union[\"DataArray\", \"Dataset\"]:",
                    "+",
                    "+        return self._implementation(",
                    "+            self._sum_of_weights, dim=dim, keep_attrs=keep_attrs",
                    "+        )",
                    "+",
                    "+    def sum(",
                    "+        self,",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        skipna: Optional[bool] = None,",
                    "+        keep_attrs: Optional[bool] = None,",
                    "+    ) -> Union[\"DataArray\", \"Dataset\"]:",
                    "+",
                    "+        return self._implementation(",
                    "+            self._weighted_sum, dim=dim, skipna=skipna, keep_attrs=keep_attrs",
                    "+        )",
                    "+",
                    "+    def mean(",
                    "+        self,",
                    "+        dim: Optional[Union[Hashable, Iterable[Hashable]]] = None,",
                    "+        skipna: Optional[bool] = None,",
                    "+        keep_attrs: Optional[bool] = None,",
                    "+    ) -> Union[\"DataArray\", \"Dataset\"]:",
                    "+",
                    "+        return self._implementation(",
                    "+            self._weighted_mean, dim=dim, skipna=skipna, keep_attrs=keep_attrs",
                    "+        )",
                    "+",
                    "+    def __repr__(self):",
                    "+        \"\"\"provide a nice str repr of our Weighted object\"\"\"",
                    "+",
                    "+        klass = self.__class__.__name__",
                    "+        weight_dims = \", \".join(self.weights.dims)",
                    "+        return f\"{klass} with weights along dimensions: {weight_dims}\"",
                    "+",
                    "+",
                    "+class DataArrayWeighted(Weighted):",
                    "+    def _implementation(self, func, dim, **kwargs):",
                    "+",
                    "+        keep_attrs = kwargs.pop(\"keep_attrs\")",
                    "+        if keep_attrs is None:",
                    "+            keep_attrs = _get_keep_attrs(default=False)",
                    "+",
                    "+        weighted = func(self.obj, dim=dim, **kwargs)",
                    "+",
                    "+        if keep_attrs:",
                    "+            weighted.attrs = self.obj.attrs",
                    "+",
                    "+        return weighted",
                    "+",
                    "+",
                    "+class DatasetWeighted(Weighted):",
                    "+    def _implementation(self, func, dim, **kwargs) -> \"Dataset\":",
                    "+",
                    "+        return self.obj.map(func, dim=dim, **kwargs)",
                    "+",
                    "+",
                    "+def _inject_docstring(cls, cls_name):",
                    "+",
                    "+    cls.sum_of_weights.__doc__ = _SUM_OF_WEIGHTS_DOCSTRING.format(cls=cls_name)",
                    "+",
                    "+    cls.sum.__doc__ = _WEIGHTED_REDUCE_DOCSTRING_TEMPLATE.format(",
                    "+        cls=cls_name, fcn=\"sum\", on_zero=\"0\"",
                    "+    )",
                    "+",
                    "+    cls.mean.__doc__ = _WEIGHTED_REDUCE_DOCSTRING_TEMPLATE.format(",
                    "+        cls=cls_name, fcn=\"mean\", on_zero=\"NaN\"",
                    "+    )",
                    "+",
                    "+",
                    "+_inject_docstring(DataArrayWeighted, \"DataArray\")",
                    "+_inject_docstring(DatasetWeighted, \"Dataset\")"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ]
    },
    "django__django-16670": {
        "django/contrib/staticfiles/handlers.py": [
            {
                "hunk": [
                    "+        # FileResponse is not async compatible.",
                    "+        if response.streaming and not response.is_async:",
                    "+            _iterator = response.streaming_content",
                    "+",
                    "+            async def awrapper():",
                    "+                for part in await sync_to_async(list)(_iterator):",
                    "+                    yield part",
                    "+",
                    "+            response.streaming_content = awrapper()"
                ],
                "start_lineno": 106,
                "end_lineno": 106
            }
        ]
    },
    "sympy__sympy-20639": {
        "sympy/printing/pretty/pretty.py": [
            {
                "hunk": [
                    "-    def _print_nth_root(self, base, expt):",
                    "+    def _print_nth_root(self, base, root):",
                    "         bpretty = self._print(base)",
                    " ",
                    "         # In very simple cases, use a single-char root sign",
                    "         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode",
                    "-            and expt is S.Half and bpretty.height() == 1",
                    "+            and root == 2 and bpretty.height() == 1"
                ],
                "start_lineno": 1905,
                "end_lineno": 1910
            },
            {
                "hunk": [
                    "-        # Make exponent number to put above it",
                    "-        if isinstance(expt, Rational):",
                    "-            exp = str(expt.q)",
                    "-            if exp == '2':",
                    "-                exp = ''",
                    "-        else:",
                    "-            exp = str(expt.args[0])",
                    "-        exp = exp.ljust(2)",
                    "+        # Constructing the number to put on root",
                    "+        rpretty = self._print(root)",
                    "+        # roots look bad if they are not a single line",
                    "+        if rpretty.height() != 1:",
                    "+            return self._print(base)**self._print(1/root)",
                    "+        # If power is half, no number should appear on top of root sign",
                    "+        exp = '' if root == 2 else str(rpretty).ljust(2)"
                ],
                "start_lineno": 1918,
                "end_lineno": 1925
            },
            {
                "hunk": [
                    "-            if n is S.One and d.is_Atom and not e.is_Integer and self._settings['root_notation']:",
                    "-                return self._print_nth_root(b, e)",
                    "+            if n is S.One and d.is_Atom and not e.is_Integer and (e.is_Rational or d.is_Symbol) \\",
                    "+                    and self._settings['root_notation']:",
                    "+                return self._print_nth_root(b, d)"
                ],
                "start_lineno": 1957,
                "end_lineno": 1958
            }
        ]
    },
    "django__django-13606": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        self.query = queryset.query",
                    "+        # Allow the usage of both QuerySet and sql.Query objects.",
                    "+        self.query = getattr(queryset, 'query', queryset)",
                    "         self.extra = extra",
                    "-        # Prevent the QuerySet from being evaluated.",
                    "-        self.queryset = queryset._chain(_result_cache=[], prefetch_done=True)",
                    "         super().__init__(output_field)",
                    " ",
                    "     def __getstate__(self):",
                    "         state = super().__getstate__()",
                    "         args, kwargs = state['_constructor_args']",
                    "         if args:",
                    "-            args = (self.queryset, *args[1:])",
                    "+            args = (self.query, *args[1:])",
                    "         else:",
                    "-            kwargs['queryset'] = self.queryset",
                    "+            kwargs['queryset'] = self.query"
                ],
                "start_lineno": 1086,
                "end_lineno": 1098
            }
        ],
        "django/db/models/lookups.py": [
            {
                "hunk": [
                    "+from django.utils.hashable import make_hashable"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def identity(self):",
                    "+        return self.__class__, self.lhs, self.rhs",
                    "+",
                    "+    def __eq__(self, other):",
                    "+        if not isinstance(other, Lookup):",
                    "+            return NotImplemented",
                    "+        return self.identity == other.identity",
                    "+",
                    "+    def __hash__(self):",
                    "+        return hash(make_hashable(self.identity))",
                    "+"
                ],
                "start_lineno": 146,
                "end_lineno": 146
            }
        ],
        "django/db/models/sql/datastructures.py": [
            {
                "hunk": [
                    "-    def equals(self, other, with_filtered_relation):",
                    "+    @property",
                    "+    def identity(self):",
                    "         return (",
                    "-            isinstance(other, self.__class__) and",
                    "-            self.table_name == other.table_name and",
                    "-            self.parent_alias == other.parent_alias and",
                    "-            self.join_field == other.join_field and",
                    "-            (not with_filtered_relation or self.filtered_relation == other.filtered_relation)",
                    "+            self.__class__,",
                    "+            self.table_name,",
                    "+            self.parent_alias,",
                    "+            self.join_field,",
                    "+            self.filtered_relation,",
                    "         )",
                    " ",
                    "     def __eq__(self, other):",
                    "-        return self.equals(other, with_filtered_relation=True)",
                    "+        if not isinstance(other, Join):",
                    "+            return NotImplemented",
                    "+        return self.identity == other.identity",
                    "+",
                    "+    def __hash__(self):",
                    "+        return hash(self.identity)",
                    "+",
                    "+    def equals(self, other, with_filtered_relation):",
                    "+        if with_filtered_relation:",
                    "+            return self == other",
                    "+        return self.identity[:-1] == other.identity[:-1]"
                ],
                "start_lineno": 117,
                "end_lineno": 127
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def identity(self):",
                    "+        return self.__class__, self.table_name, self.table_alias",
                    "+",
                    "+    def __eq__(self, other):",
                    "+        if not isinstance(other, BaseTable):",
                    "+            return NotImplemented",
                    "+        return self.identity == other.identity",
                    "+",
                    "+    def __hash__(self):",
                    "+        return hash(self.identity)",
                    "+",
                    "     def equals(self, other, with_filtered_relation):",
                    "-        return (",
                    "-            isinstance(self, other.__class__) and",
                    "-            self.table_name == other.table_name and",
                    "-            self.table_alias == other.table_alias",
                    "-        )",
                    "+        return self.identity == other.identity"
                ],
                "start_lineno": 163,
                "end_lineno": 168
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-from django.db.models.expressions import BaseExpression, Col, F, OuterRef, Ref",
                    "+from django.db.models.expressions import (",
                    "+    BaseExpression, Col, Exists, F, OuterRef, Ref, ResolvedOuterRef,",
                    "+)"
                ],
                "start_lineno": 26,
                "end_lineno": 26
            },
            {
                "hunk": [
                    "+from django.utils.hashable import make_hashable"
                ],
                "start_lineno": 42,
                "end_lineno": 42
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def identity(self):",
                    "+        identity = (",
                    "+            (arg, make_hashable(value))",
                    "+            for arg, value in self.__dict__.items()",
                    "+        )",
                    "+        return (self.__class__, *identity)",
                    "+"
                ],
                "start_lineno": 249,
                "end_lineno": 249
            },
            {
                "hunk": [
                    "-            WHERE NOT (pk IN (SELECT parent_id FROM thetable",
                    "-                              WHERE name = 'foo' AND parent_id IS NOT NULL))",
                    "-",
                    "-        It might be worth it to consider using WHERE NOT EXISTS as that has",
                    "-        saner null handling, and is easier for the backend's optimizer to",
                    "-        handle.",
                    "+            WHERE NOT EXISTS(",
                    "+                SELECT 1",
                    "+                FROM child",
                    "+                WHERE name = 'foo' AND child.parent_id = parent.id",
                    "+                LIMIT 1",
                    "+            )"
                ],
                "start_lineno": 1759,
                "end_lineno": 1764
            },
            {
                "hunk": [
                    "-        # Add extra check to make sure the selected field will not be null",
                    "-        # since we are adding an IN <subquery> clause. This prevents the",
                    "-        # database from tripping over IN (...,NULL,...) selects and returning",
                    "-        # nothing",
                    "         col = query.select[0]",
                    "         select_field = col.target",
                    "         alias = col.alias",
                    "-        if self.is_nullable(select_field):",
                    "-            lookup_class = select_field.get_lookup('isnull')",
                    "-            lookup = lookup_class(select_field.get_col(alias), False)",
                    "-            query.where.add(lookup, AND)"
                ],
                "start_lineno": 1780,
                "end_lineno": 1790
            },
            {
                "hunk": [
                    "-        condition, needed_inner = self.build_filter(",
                    "-            ('%s__in' % trimmed_prefix, query),",
                    "-            current_negated=True, branch_negated=True, can_reuse=can_reuse)",
                    "+        lookup_class = select_field.get_lookup('exact')",
                    "+        lookup = lookup_class(col, ResolvedOuterRef(trimmed_prefix))",
                    "+        query.where.add(lookup, AND)",
                    "+        condition, needed_inner = self.build_filter(Exists(query))",
                    "+"
                ],
                "start_lineno": 1804,
                "end_lineno": 1806
            }
        ]
    },
    "pydata__xarray-6999": {
        "xarray/core/dataarray.py": [
            {
                "hunk": [
                    "-            dataset = self._to_temp_dataset().rename(name_dict)",
                    "+            dataset = self._to_temp_dataset()._rename(name_dict)",
                    "             return self._from_temp_dataset(dataset)",
                    "         if utils.hashable(new_name_or_name_dict) and names:",
                    "             # change name + dims/coords",
                    "-            dataset = self._to_temp_dataset().rename(names)",
                    "+            dataset = self._to_temp_dataset()._rename(names)"
                ],
                "start_lineno": 2035,
                "end_lineno": 2039
            }
        ],
        "xarray/core/dataset.py": [
            {
                "hunk": [
                    "+    def _rename(",
                    "+        self: T_Dataset,",
                    "+        name_dict: Mapping[Any, Hashable] | None = None,",
                    "+        **names: Hashable,",
                    "+    ) -> T_Dataset:",
                    "+        \"\"\"Also used internally by DataArray so that the warning (if any)",
                    "+        is raised at the right stack level.",
                    "+        \"\"\"",
                    "+        name_dict = either_dict_or_kwargs(name_dict, names, \"rename\")",
                    "+        for k in name_dict.keys():",
                    "+            if k not in self and k not in self.dims:",
                    "+                raise ValueError(",
                    "+                    f\"cannot rename {k!r} because it is not a \"",
                    "+                    \"variable or dimension in this dataset\"",
                    "+                )",
                    "+",
                    "+            create_dim_coord = False",
                    "+            new_k = name_dict[k]",
                    "+",
                    "+            if k in self.dims and new_k in self._coord_names:",
                    "+                coord_dims = self._variables[name_dict[k]].dims",
                    "+                if coord_dims == (k,):",
                    "+                    create_dim_coord = True",
                    "+            elif k in self._coord_names and new_k in self.dims:",
                    "+                coord_dims = self._variables[k].dims",
                    "+                if coord_dims == (new_k,):",
                    "+                    create_dim_coord = True",
                    "+",
                    "+            if create_dim_coord:",
                    "+                warnings.warn(",
                    "+                    f\"rename {k!r} to {name_dict[k]!r} does not create an index \"",
                    "+                    \"anymore. Try using swap_dims instead or use set_index \"",
                    "+                    \"after rename to create an indexed coordinate.\",",
                    "+                    UserWarning,",
                    "+                    stacklevel=3,",
                    "+                )",
                    "+",
                    "+        variables, coord_names, dims, indexes = self._rename_all(",
                    "+            name_dict=name_dict, dims_dict=name_dict",
                    "+        )",
                    "+        return self._replace(variables, coord_names, dims=dims, indexes=indexes)",
                    "+"
                ],
                "start_lineno": 3563,
                "end_lineno": 3563
            },
            {
                "hunk": [
                    "-        name_dict = either_dict_or_kwargs(name_dict, names, \"rename\")",
                    "-        for k in name_dict.keys():",
                    "-            if k not in self and k not in self.dims:",
                    "-                raise ValueError(",
                    "-                    f\"cannot rename {k!r} because it is not a \"",
                    "-                    \"variable or dimension in this dataset\"",
                    "-                )",
                    "-",
                    "-        variables, coord_names, dims, indexes = self._rename_all(",
                    "-            name_dict=name_dict, dims_dict=name_dict",
                    "-        )",
                    "-        return self._replace(variables, coord_names, dims=dims, indexes=indexes)",
                    "+        return self._rename(name_dict=name_dict, **names)"
                ],
                "start_lineno": 3591,
                "end_lineno": 3602
            }
        ]
    },
    "scikit-learn__scikit-learn-12656": {
        "sklearn/metrics/classification.py": [
            {
                "hunk": [
                    "-    labels : array, shape = [n_labels], optional (default=None)",
                    "+    labels : array, shape = [n_labels], optional (default='deprecated')",
                    "         Integer array of labels. If not provided, labels will be inferred",
                    "         from y_true and y_pred.",
                    " ",
                    "         .. versionadded:: 0.18",
                    "+        .. deprecated:: 0.21",
                    "+           This parameter ``labels`` is deprecated in version 0.21 and will",
                    "+           be removed in version 0.23. Hamming loss uses ``y_true.shape[1]``",
                    "+           for the number of labels when y_true is binary label indicators,",
                    "+           so it is unnecessary for the user to specify."
                ],
                "start_lineno": 1808,
                "end_lineno": 1812
            },
            {
                "hunk": [
                    "-    if labels is None:",
                    "-        labels = unique_labels(y_true, y_pred)",
                    "-    else:",
                    "-        labels = np.asarray(labels)",
                    "+    if labels is not None:",
                    "+        warnings.warn(\"The labels parameter is unused. It was\"",
                    "+                      \" deprecated in version 0.21 and\"",
                    "+                      \" will be removed in version 0.23\",",
                    "+                      DeprecationWarning)"
                ],
                "start_lineno": 1870,
                "end_lineno": 1873
            },
            {
                "hunk": [
                    "-                (y_true.shape[0] * len(labels) * weight_average))",
                    "+                (y_true.shape[0] * y_true.shape[1] * weight_average))"
                ],
                "start_lineno": 1884,
                "end_lineno": 1884
            }
        ]
    },
    "astropy__astropy-13234": {
        "astropy/table/serialize.py": [
            {
                "hunk": [
                    "-        cls = SerializedColumn",
                    "-    elif cls_full_name not in __construct_mixin_classes:",
                    "+        # We're dealing with a SerializedColumn holding columns, stored in",
                    "+        # obj_attrs. For this case, info holds the name (and nothing else).",
                    "+        mixin = SerializedColumn(obj_attrs)",
                    "+        mixin.info.name = info['name']",
                    "+        return mixin",
                    "+",
                    "+    if cls_full_name not in __construct_mixin_classes:",
                    "         raise ValueError(f'unsupported class for construct {cls_full_name}')",
                    "-    else:",
                    "-        mod_name, _, cls_name = cls_full_name.rpartition('.')",
                    "-        module = import_module(mod_name)",
                    "-        cls = getattr(module, cls_name)",
                    " ",
                    "+    mod_name, _, cls_name = cls_full_name.rpartition('.')",
                    "+    module = import_module(mod_name)",
                    "+    cls = getattr(module, cls_name)"
                ],
                "start_lineno": 296,
                "end_lineno": 303
            },
            {
                "hunk": [
                    "-            if 'name' in val:",
                    "+            # A SerializedColumn can just link to a serialized column using a name",
                    "+            # (e.g., time.jd1), or itself be a mixin (e.g., coord.obstime).  Note",
                    "+            # that in principle a mixin could have include a column called 'name',",
                    "+            # hence we check whether the value is actually a string (see gh-13232).",
                    "+            if 'name' in val and isinstance(val['name'], str):"
                ],
                "start_lineno": 345,
                "end_lineno": 345
            },
            {
                "hunk": [
                    "-    # Get the index where to add new column",
                    "-    idx = min(out.colnames.index(name) for name in data_attrs_map)",
                    "+    # The order of data_attrs_map may not match the actual order, as it is set",
                    "+    # by the yaml description.  So, sort names by position in the serialized table.",
                    "+    # Keep the index of the first column, so we can insert the new one there later.",
                    "+    names = sorted(data_attrs_map, key=out.colnames.index)",
                    "+    idx = out.colnames.index(names[0])",
                    " ",
                    "     # Name is the column name in the table (e.g. \"coord.ra\") and",
                    "     # data_attr is the object attribute name  (e.g. \"ra\").  A different",
                    "     # example would be a formatted time object that would have (e.g.)",
                    "     # \"time_col\" and \"value\", respectively.",
                    "-    for name, data_attr in data_attrs_map.items():",
                    "-        obj_attrs[data_attr] = out[name]",
                    "+    for name in names:",
                    "+        obj_attrs[data_attrs_map[name]] = out[name]",
                    "         del out[name]",
                    " ",
                    "     info = obj_attrs.pop('__info__', {})",
                    "-    if len(data_attrs_map) == 1:",
                    "+    if len(names) == 1:",
                    "         # col is the first and only serialized column; in that case, use info",
                    "         # stored on the column. First step is to get that first column which",
                    "         # has been moved from `out` to `obj_attrs` above.",
                    "-        data_attr = next(iter(data_attrs_map.values()))",
                    "-        col = obj_attrs[data_attr]",
                    "+        col = obj_attrs[data_attrs_map[name]]"
                ],
                "start_lineno": 355,
                "end_lineno": 372
            }
        ]
    },
    "sphinx-doc__sphinx-7462": {
        "sphinx/domains/python.py": [
            {
                "hunk": [
                    "-            result = []",
                    "-            for elem in node.elts:",
                    "-                result.extend(unparse(elem))",
                    "-                result.append(addnodes.desc_sig_punctuation('', ', '))",
                    "-            result.pop()",
                    "+            if node.elts:",
                    "+                result = []",
                    "+                for elem in node.elts:",
                    "+                    result.extend(unparse(elem))",
                    "+                    result.append(addnodes.desc_sig_punctuation('', ', '))",
                    "+                result.pop()",
                    "+            else:",
                    "+                result = [addnodes.desc_sig_punctuation('', '('),",
                    "+                          addnodes.desc_sig_punctuation('', ')')]",
                    "+"
                ],
                "start_lineno": 108,
                "end_lineno": 112
            }
        ],
        "sphinx/pycode/ast.py": [
            {
                "hunk": [
                    "-        return \", \".join(unparse(e) for e in node.elts)",
                    "+        if node.elts:",
                    "+            return \", \".join(unparse(e) for e in node.elts)",
                    "+        else:",
                    "+            return \"()\""
                ],
                "start_lineno": 117,
                "end_lineno": 117
            }
        ]
    },
    "django__django-11133": {
        "django/http/response.py": [
            {
                "hunk": [
                    "-        if isinstance(value, bytes):",
                    "+        if isinstance(value, (bytes, memoryview)):"
                ],
                "start_lineno": 232,
                "end_lineno": 232
            }
        ]
    },
    "sympy__sympy-13185": {
        "sympy/simplify/cse_main.py": [
            {
                "hunk": [
                    "+    from sympy.matrices.expressions.matexpr import MatrixElement"
                ],
                "start_lineno": 488,
                "end_lineno": 488
            },
            {
                "hunk": [
                    "-        if isinstance(expr, Basic) and (expr.is_Atom or expr.is_Order):",
                    "+        if isinstance(expr, Basic) and (expr.is_Atom or expr.is_Order or isinstance(expr, MatrixSymbol) or isinstance(expr, MatrixElement)):"
                ],
                "start_lineno": 503,
                "end_lineno": 503
            }
        ]
    },
    "django__django-14717": {
        "django/db/models/fields/__init__.py": [
            {
                "hunk": [
                    "+def _to_naive(value):",
                    "+    if timezone.is_aware(value):",
                    "+        value = timezone.make_naive(value, timezone.utc)",
                    "+    return value",
                    "+",
                    "+",
                    "+def _get_naive_now():",
                    "+    return _to_naive(timezone.now())",
                    "+",
                    "+"
                ],
                "start_lineno": 1106,
                "end_lineno": 1106
            },
            {
                "hunk": [
                    "+    # Concrete subclasses use this in their implementations of",
                    "+    # _check_fix_default_value().",
                    "+    def _check_if_value_fixed(self, value, now=None):",
                    "+        \"\"\"",
                    "+        Check if the given value appears to have been provided as a \"fixed\"",
                    "+        time value, and include a warning in the returned list if it does. The",
                    "+        value argument must be a date object or aware/naive datetime object. If",
                    "+        now is provided, it must be a naive datetime object.",
                    "+        \"\"\"",
                    "+        if now is None:",
                    "+            now = _get_naive_now()",
                    "+        offset = datetime.timedelta(seconds=10)",
                    "+        lower = now - offset",
                    "+        upper = now + offset",
                    "+        if isinstance(value, datetime.datetime):",
                    "+            value = _to_naive(value)",
                    "+        else:",
                    "+            assert isinstance(value, datetime.date)",
                    "+            lower = lower.date()",
                    "+            upper = upper.date()",
                    "+        if lower <= value <= upper:",
                    "+            return [",
                    "+                checks.Warning(",
                    "+                    'Fixed default value provided.',",
                    "+                    hint=(",
                    "+                        'It seems you set a fixed date / time / datetime '",
                    "+                        'value as default for this field. This may not be '",
                    "+                        'what you want. If you want to have the current date '",
                    "+                        'as default, use `django.utils.timezone.now`'",
                    "+                    ),",
                    "+                    obj=self,",
                    "+                    id='fields.W161',",
                    "+                )",
                    "+            ]",
                    "+        return []",
                    "+"
                ],
                "start_lineno": 1137,
                "end_lineno": 1137
            },
            {
                "hunk": [
                    "-        now = timezone.now()",
                    "-        if not timezone.is_naive(now):",
                    "-            now = timezone.make_naive(now, timezone.utc)",
                    "         value = self.default",
                    "         if isinstance(value, datetime.datetime):",
                    "-            if not timezone.is_naive(value):",
                    "-                value = timezone.make_naive(value, timezone.utc)",
                    "-            value = value.date()",
                    "+            value = _to_naive(value).date()",
                    "         elif isinstance(value, datetime.date):",
                    "-            # Nothing to do, as dates don't have tz information",
                    "             pass",
                    "         else:",
                    "             # No explicit date / datetime value -- no checks necessary",
                    "             return []",
                    "-        offset = datetime.timedelta(days=1)",
                    "-        lower = (now - offset).date()",
                    "-        upper = (now + offset).date()",
                    "-        if lower <= value <= upper:",
                    "-            return [",
                    "-                checks.Warning(",
                    "-                    'Fixed default value provided.',",
                    "-                    hint='It seems you set a fixed date / time / datetime '",
                    "-                         'value as default for this field. This may not be '",
                    "-                         'what you want. If you want to have the current date '",
                    "-                         'as default, use `django.utils.timezone.now`',",
                    "-                    obj=self,",
                    "-                    id='fields.W161',",
                    "-                )",
                    "-            ]",
                    "-",
                    "-        return []",
                    "+        # At this point, value is a date object.",
                    "+        return self._check_if_value_fixed(value)"
                ],
                "start_lineno": 1164,
                "end_lineno": 1194
            },
            {
                "hunk": [
                    "-        now = timezone.now()",
                    "-        if not timezone.is_naive(now):",
                    "-            now = timezone.make_naive(now, timezone.utc)",
                    "         value = self.default",
                    "-        if isinstance(value, datetime.datetime):",
                    "-            second_offset = datetime.timedelta(seconds=10)",
                    "-            lower = now - second_offset",
                    "-            upper = now + second_offset",
                    "-            if timezone.is_aware(value):",
                    "-                value = timezone.make_naive(value, timezone.utc)",
                    "-        elif isinstance(value, datetime.date):",
                    "-            second_offset = datetime.timedelta(seconds=10)",
                    "-            lower = now - second_offset",
                    "-            lower = datetime.datetime(lower.year, lower.month, lower.day)",
                    "-            upper = now + second_offset",
                    "-            upper = datetime.datetime(upper.year, upper.month, upper.day)",
                    "-            value = datetime.datetime(value.year, value.month, value.day)",
                    "-        else:",
                    "-            # No explicit date / datetime value -- no checks necessary",
                    "-            return []",
                    "-        if lower <= value <= upper:",
                    "-            return [",
                    "-                checks.Warning(",
                    "-                    'Fixed default value provided.',",
                    "-                    hint='It seems you set a fixed date / time / datetime '",
                    "-                         'value as default for this field. This may not be '",
                    "-                         'what you want. If you want to have the current date '",
                    "-                         'as default, use `django.utils.timezone.now`',",
                    "-                    obj=self,",
                    "-                    id='fields.W161',",
                    "-                )",
                    "-            ]",
                    "-",
                    "+        if isinstance(value, (datetime.datetime, datetime.date)):",
                    "+            return self._check_if_value_fixed(value)",
                    "+        # No explicit date / datetime value -- no checks necessary."
                ],
                "start_lineno": 1304,
                "end_lineno": 1336
            },
            {
                "hunk": [
                    "-        now = timezone.now()",
                    "-        if not timezone.is_naive(now):",
                    "-            now = timezone.make_naive(now, timezone.utc)",
                    "         value = self.default",
                    "         if isinstance(value, datetime.datetime):",
                    "-            second_offset = datetime.timedelta(seconds=10)",
                    "-            lower = now - second_offset",
                    "-            upper = now + second_offset",
                    "-            if timezone.is_aware(value):",
                    "-                value = timezone.make_naive(value, timezone.utc)",
                    "+            now = None",
                    "         elif isinstance(value, datetime.time):",
                    "-            second_offset = datetime.timedelta(seconds=10)",
                    "-            lower = now - second_offset",
                    "-            upper = now + second_offset",
                    "+            now = _get_naive_now()",
                    "+            # This will not use the right date in the race condition where now",
                    "+            # is just before the date change and value is just past 0:00.",
                    "             value = datetime.datetime.combine(now.date(), value)",
                    "-            if timezone.is_aware(value):",
                    "-                value = timezone.make_naive(value, timezone.utc).time()",
                    "         else:",
                    "             # No explicit time / datetime value -- no checks necessary",
                    "             return []",
                    "-        if lower <= value <= upper:",
                    "-            return [",
                    "-                checks.Warning(",
                    "-                    'Fixed default value provided.',",
                    "-                    hint='It seems you set a fixed date / time / datetime '",
                    "-                         'value as default for this field. This may not be '",
                    "-                         'what you want. If you want to have the current date '",
                    "-                         'as default, use `django.utils.timezone.now`',",
                    "-                    obj=self,",
                    "-                    id='fields.W161',",
                    "-                )",
                    "-            ]",
                    "-",
                    "-        return []",
                    "+        # At this point, value is a datetime object.",
                    "+        return self._check_if_value_fixed(value, now=now)"
                ],
                "start_lineno": 2200,
                "end_lineno": 2233
            }
        ]
    },
    "pydata__xarray-4182": {
        "xarray/core/formatting_html.py": [
            {
                "hunk": [
                    "-    collapsed = \"\"",
                    "+    collapsed = \"checked\""
                ],
                "start_lineno": 187,
                "end_lineno": 187
            }
        ]
    },
    "django__django-15031": {
        "django/contrib/admin/filters.py": [
            {
                "hunk": [
                    "+    list_separator = ','"
                ],
                "start_lineno": 121,
                "end_lineno": 121
            },
            {
                "hunk": [
                    "-                self.used_parameters[p] = prepare_lookup_value(p, value)",
                    "+                self.used_parameters[p] = prepare_lookup_value(p, value, self.list_separator)"
                ],
                "start_lineno": 130,
                "end_lineno": 130
            }
        ],
        "django/contrib/admin/utils.py": [
            {
                "hunk": [
                    "-def prepare_lookup_value(key, value):",
                    "+def prepare_lookup_value(key, value, separator=','):",
                    "     \"\"\"",
                    "     Return a lookup value prepared to be used in queryset filtering.",
                    "     \"\"\"",
                    "     # if key ends with __in, split parameter into separate values",
                    "     if key.endswith('__in'):",
                    "-        value = value.split(',')",
                    "+        value = value.split(separator)"
                ],
                "start_lineno": 54,
                "end_lineno": 60
            }
        ]
    },
    "matplotlib__matplotlib-13859": {
        "lib/matplotlib/figure.py": [
            {
                "hunk": [
                    "-        if not np.isfinite(figsize).all():",
                    "-            raise ValueError('figure size must be finite not '",
                    "-                             '{}'.format(figsize))",
                    "+        if not np.isfinite(figsize).all() or (np.array(figsize) <= 0).any():",
                    "+            raise ValueError('figure size must be positive finite not '",
                    "+                             f'{figsize}')"
                ],
                "start_lineno": 348,
                "end_lineno": 350
            },
            {
                "hunk": [
                    "-        if not all(np.isfinite(_) for _ in (w, h)):",
                    "-            raise ValueError('figure size must be finite not '",
                    "-                             '({}, {})'.format(w, h))",
                    "+        size = w, h",
                    "+        if not np.isfinite(size).all() or (np.array(size) <= 0).any():",
                    "+            raise ValueError(f'figure size must be positive finite not {size}')"
                ],
                "start_lineno": 898,
                "end_lineno": 900
            }
        ]
    },
    "django__django-15569": {
        "django/db/models/query_utils.py": [
            {
                "hunk": [
                    "+        cls._clear_cached_lookups()"
                ],
                "start_lineno": 220,
                "end_lineno": 220
            }
        ]
    },
    "sympy__sympy-14180": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+        \"ln_notation\": False,"
                ],
                "start_lineno": 137,
                "end_lineno": 137
            },
            {
                "hunk": [
                    "+    def _print_log(self, expr, exp=None):",
                    "+        if not self._settings[\"ln_notation\"]:",
                    "+            tex = r\"\\log{\\left (%s \\right )}\" % self._print(expr.args[0])",
                    "+        else:",
                    "+            tex = r\"\\ln{\\left (%s \\right )}\" % self._print(expr.args[0])",
                    "+",
                    "+        if exp is not None:",
                    "+            return r\"%s^{%s}\" % (tex, exp)",
                    "+        else:",
                    "+            return tex",
                    "+"
                ],
                "start_lineno": 849,
                "end_lineno": 849
            },
            {
                "hunk": [
                    "-    >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational",
                    "+    >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log"
                ],
                "start_lineno": 2126,
                "end_lineno": 2126
            },
            {
                "hunk": [
                    "+    ln_notation: If set to ``True`` \"\\ln\" is used instead of default \"\\log\"",
                    "+",
                    "+    >>> print(latex(log(10)))",
                    "+    \\log{\\left (10 \\right )}",
                    "+",
                    "+    >>> print(latex(log(10), ln_notation=True))",
                    "+    \\ln{\\left (10 \\right )}",
                    "+"
                ],
                "start_lineno": 2245,
                "end_lineno": 2245
            }
        ]
    },
    "pylint-dev__pylint-5613": {
        "pylint/__init__.py": [
            {
                "hunk": [
                    "+from typing import List, Optional",
                    " ",
                    " from pylint.__pkginfo__ import __version__",
                    " ",
                    " # pylint: disable=import-outside-toplevel",
                    " ",
                    " ",
                    "-def run_pylint():",
                    "+def run_pylint(*, arguments: Optional[List[str]] = None):",
                    "+    \"\"\"Run pylint",
                    "+",
                    "+    Arguments can be a list of strings normally supplied as arguments on the command line",
                    "+    \"\"\"",
                    "     from pylint.lint import Run as PylintRun",
                    " ",
                    "     try:",
                    "-        PylintRun(sys.argv[1:])",
                    "+        PylintRun(arguments or sys.argv[1:])"
                ],
                "start_lineno": 14,
                "end_lineno": 24
            },
            {
                "hunk": [
                    "-def run_pyreverse():",
                    "-    \"\"\"run pyreverse\"\"\"",
                    "+def run_pyreverse(*, arguments: Optional[List[str]] = None):",
                    "+    \"\"\"Run pyreverse",
                    "+",
                    "+    Arguments can be a list of strings normally supplied as arguments on the command line",
                    "+    \"\"\"",
                    "     from pylint.pyreverse.main import Run as PyreverseRun",
                    " ",
                    "-    PyreverseRun(sys.argv[1:])",
                    "+    PyreverseRun(arguments or sys.argv[1:])",
                    "+",
                    " ",
                    "+def run_symilar(*, arguments: Optional[List[str]] = None):",
                    "+    \"\"\"Run symilar",
                    " ",
                    "-def run_symilar():",
                    "-    \"\"\"run symilar\"\"\"",
                    "+    Arguments can be a list of strings normally supplied as arguments on the command line",
                    "+    \"\"\"",
                    "     from pylint.checkers.similar import Run as SimilarRun",
                    " ",
                    "-    SimilarRun(sys.argv[1:])",
                    "+    SimilarRun(arguments or sys.argv[1:])"
                ],
                "start_lineno": 35,
                "end_lineno": 46
            }
        ]
    },
    "matplotlib__matplotlib-25479": {
        "lib/matplotlib/cm.py": [
            {
                "hunk": [
                    "+        # Someone may set the extremes of a builtin colormap and want to register it",
                    "+        # with a different name for future lookups. The object would still have the",
                    "+        # builtin name, so we should update it to the registered name",
                    "+        if self._cmaps[name].name != name:",
                    "+            self._cmaps[name].name = name"
                ],
                "start_lineno": 149,
                "end_lineno": 149
            }
        ],
        "lib/matplotlib/colors.py": [
            {
                "hunk": [
                    "-        if (not isinstance(other, Colormap) or self.name != other.name or",
                    "+        if (not isinstance(other, Colormap) or"
                ],
                "start_lineno": 777,
                "end_lineno": 777
            }
        ]
    },
    "scikit-learn__scikit-learn-11333": {
        "sklearn/utils/metaestimators.py": [
            {
                "hunk": [
                    "-        names, _ = zip(*getattr(self, attr))",
                    "+        items = getattr(self, attr)",
                    "+        names = []",
                    "+        if items:",
                    "+            names, _ = zip(*items)"
                ],
                "start_lineno": 44,
                "end_lineno": 44
            }
        ]
    },
    "scikit-learn__scikit-learn-13472": {
        "sklearn/ensemble/gradient_boosting.py": [
            {
                "hunk": [
                    "-                try:",
                    "-                    self.init_.fit(X, y, sample_weight=sample_weight)",
                    "-                except TypeError:",
                    "-                    if sample_weight_is_none:",
                    "-                        self.init_.fit(X, y)",
                    "-                    else:",
                    "-                        raise ValueError(",
                    "-                            \"The initial estimator {} does not support sample \"",
                    "-                            \"weights.\".format(self.init_.__class__.__name__))",
                    "+                # XXX clean this once we have a support_sample_weight tag",
                    "+                if sample_weight_is_none:",
                    "+                    self.init_.fit(X, y)",
                    "+                else:",
                    "+                    msg = (\"The initial estimator {} does not support sample \"",
                    "+                           \"weights.\".format(self.init_.__class__.__name__))",
                    "+                    try:",
                    "+                        self.init_.fit(X, y, sample_weight=sample_weight)",
                    "+                    except TypeError:  # regular estimator without SW support",
                    "+                        raise ValueError(msg)",
                    "+                    except ValueError as e:",
                    "+                        if 'not enough values to unpack' in str(e):  # pipeline",
                    "+                            raise ValueError(msg) from e",
                    "+                        else:  # regular estimator whose input checking failed",
                    "+                            raise",
                    " ",
                    "                 raw_predictions = \\",
                    "                     self.loss_.get_init_raw_predictions(X, self.init_)",
                    " ",
                    "-"
                ],
                "start_lineno": 1479,
                "end_lineno": 1492
            }
        ]
    },
    "sphinx-doc__sphinx-7738": {
        "sphinx/ext/napoleon/docstring.py": [
            {
                "hunk": [
                    "-        if name.endswith('_'):",
                    "+        if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):"
                ],
                "start_lineno": 321,
                "end_lineno": 321
            }
        ]
    },
    "django__django-12237": {
        "django/utils/text.py": [
            {
                "hunk": [
                    "-    value = re.sub(r'[^\\w\\s-]', '', value).strip().lower()",
                    "+    value = re.sub(r'[^\\w\\s-]', '', value.lower()).strip()"
                ],
                "start_lineno": 405,
                "end_lineno": 405
            }
        ]
    },
    "scikit-learn__scikit-learn-14544": {
        "sklearn/compose/_column_transformer.py": [
            {
                "hunk": [
                    "-",
                    "+import warnings",
                    " from itertools import chain",
                    " ",
                    "+import numbers"
                ],
                "start_lineno": 9,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "+    def _validate_features(self, n_features, feature_names):",
                    "+        \"\"\"Ensures feature counts and names are the same during fit and",
                    "+        transform.",
                    "+",
                    "+        TODO: It should raise an error from v0.24",
                    "+        \"\"\"",
                    "+",
                    "+        if ((self._feature_names_in is None or feature_names is None)",
                    "+                and self._n_features == n_features):",
                    "+            return",
                    "+",
                    "+        neg_col_present = np.any([_is_negative_indexing(col)",
                    "+                                  for col in self._columns])",
                    "+        if neg_col_present and self._n_features != n_features:",
                    "+            raise RuntimeError(\"At least one negative column was used to \"",
                    "+                               \"indicate columns, and the new data's number \"",
                    "+                               \"of columns does not match the data given \"",
                    "+                               \"during fit. \"",
                    "+                               \"Please make sure the data during fit and \"",
                    "+                               \"transform have the same number of columns.\")",
                    "+",
                    "+        if (self._n_features != n_features or",
                    "+                np.any(self._feature_names_in != np.asarray(feature_names))):",
                    "+            warnings.warn(\"Given feature/column names or counts do not match \"",
                    "+                          \"the ones for the data given during fit. This will \"",
                    "+                          \"fail from v0.24.\",",
                    "+                          DeprecationWarning)",
                    "+"
                ],
                "start_lineno": 397,
                "end_lineno": 397
            },
            {
                "hunk": [
                    "+        # TODO: this should be `feature_names_in_` when we start having it",
                    "+        if hasattr(X, \"columns\"):",
                    "+            self._feature_names_in = np.asarray(X.columns)",
                    "+        else:",
                    "+            self._feature_names_in = None"
                ],
                "start_lineno": 473,
                "end_lineno": 473
            },
            {
                "hunk": [
                    "+        if hasattr(X, \"columns\"):",
                    "+            X_feature_names = np.asarray(X.columns)",
                    "+        else:",
                    "+            X_feature_names = None"
                ],
                "start_lineno": 521,
                "end_lineno": 521
            },
            {
                "hunk": [
                    "+        # TODO: remove this mechanism in 0.24, once we enforce strict column",
                    "+        # name order and count. See #14237 for details."
                ],
                "start_lineno": 530,
                "end_lineno": 530
            },
            {
                "hunk": [
                    "+        self._validate_features(X.shape[1], X_feature_names)"
                ],
                "start_lineno": 541,
                "end_lineno": 541
            },
            {
                "hunk": [
                    "+",
                    "+",
                    "+def _is_negative_indexing(key):",
                    "+    # TODO: remove in v0.24",
                    "+    def is_neg(x): return isinstance(x, numbers.Integral) and x < 0",
                    "+    if isinstance(key, slice):",
                    "+        return is_neg(key.start) or is_neg(key.stop)",
                    "+    elif _check_key_type(key, int):",
                    "+        return np.any(np.asarray(key) < 0)",
                    "+    return False"
                ],
                "start_lineno": 710,
                "end_lineno": 710
            }
        ]
    },
    "sympy__sympy-13441": {
        "sympy/core/add.py": [
            {
                "hunk": [
                    "-        Returns lhs - rhs, but treats arguments like symbols, so things like",
                    "-        oo - oo return 0, instead of a nan.",
                    "+        Returns lhs - rhs, but treats oo like a symbol so oo - oo",
                    "+        returns 0, instead of a nan.",
                    "         \"\"\"",
                    "-        from sympy import oo, I, expand_mul",
                    "-        if lhs == oo and rhs == oo or lhs == oo*I and rhs == oo*I:",
                    "-            return S.Zero",
                    "-        return expand_mul(lhs - rhs)",
                    "+        from sympy.core.function import expand_mul",
                    "+        from sympy.core.symbol import Dummy",
                    "+        inf = (S.Infinity, S.NegativeInfinity)",
                    "+        if lhs.has(*inf) or rhs.has(*inf):",
                    "+            oo = Dummy('oo')",
                    "+            reps = {",
                    "+                S.Infinity: oo,",
                    "+                S.NegativeInfinity: -oo}",
                    "+            ireps = dict([(v, k) for k, v in reps.items()])",
                    "+            eq = expand_mul(lhs.xreplace(reps) - rhs.xreplace(reps))",
                    "+            if eq.has(oo):",
                    "+                eq = eq.replace(",
                    "+                    lambda x: x.is_Pow and x.base == oo,",
                    "+                    lambda x: x.base)",
                    "+            return eq.xreplace(ireps)",
                    "+        else:",
                    "+            return expand_mul(lhs - rhs)"
                ],
                "start_lineno": 399,
                "end_lineno": 405
            }
        ],
        "sympy/core/function.py": [
            {
                "hunk": [
                    "-        from sympy.core.symbol import Wild",
                    "+        from sympy.core.evalf import pure_complex",
                    "         if arg.is_Float:",
                    "             return arg._prec",
                    "         if not arg.is_Add:",
                    "             return -1",
                    "-        # Don't use as_real_imag() here, that's too much work",
                    "-        a, b = Wild('a'), Wild('b')",
                    "-        m = arg.match(a + b*S.ImaginaryUnit)",
                    "-        if not m or not (m[a].is_Float or m[b].is_Float):",
                    "+        m = pure_complex(arg)",
                    "+        if m is None or not (m[0].is_Float or m[1].is_Float):",
                    "             return -1",
                    "-        l = [m[i]._prec for i in m if m[i].is_Float]",
                    "+        l = [i._prec for i in m if i.is_Float]"
                ],
                "start_lineno": 459,
                "end_lineno": 469
            }
        ],
        "sympy/core/operations.py": [
            {
                "hunk": [
                    "-           simply removing one or more terms. If modification which result,",
                    "-           for example, in extra 1s being inserted (as when collecting an",
                    "+           simply removing one or more args. If, for example, modifications,",
                    "+           result in extra 1s being inserted (as when collecting an"
                ],
                "start_lineno": 82,
                "end_lineno": 83
            },
            {
                "hunk": [
                    "-        wild_part = []",
                    "-        exact_part = []",
                    "-        for p in ordered(self.args):",
                    "-            if p.has(Wild, WildFunction) and (not expr.has(p)):",
                    "-                # not all Wild should stay Wilds, for example:",
                    "-                # (w2+w3).matches(w1) -> (w1+w3).matches(w1) -> w3.matches(0)",
                    "-                wild_part.append(p)",
                    "-            else:",
                    "-                exact_part.append(p)",
                    "-",
                    "-        if exact_part:",
                    "-            exact = self.func(*exact_part)",
                    "+        from sympy.utilities.iterables import sift",
                    "+        sifted = sift(self.args, lambda p:",
                    "+            p.has(Wild, WildFunction) and not expr.has(p))",
                    "+        wild_part = sifted[True]",
                    "+        exact_part = sifted[False]",
                    "+        if not exact_part:",
                    "+            wild_part = list(ordered(wild_part))",
                    "+        else:",
                    "+            exact = self._new_rawargs(*exact_part)",
                    "             free = expr.free_symbols",
                    "             if free and (exact.free_symbols - free):",
                    "                 # there are symbols in the exact part that are not",
                    "                 # in the expr; but if there are no free symbols, let",
                    "                 # the matching continue",
                    "                 return None",
                    "-            newpattern = self.func(*wild_part)",
                    "             newexpr = self._combine_inverse(expr, exact)",
                    "             if not old and (expr.is_Add or expr.is_Mul):",
                    "                 if newexpr.count_ops() > expr.count_ops():",
                    "                     return None",
                    "+            newpattern = self._new_rawargs(*wild_part)"
                ],
                "start_lineno": 183,
                "end_lineno": 205
            }
        ]
    },
    "sphinx-doc__sphinx-10191": {
        "sphinx/writers/latex.py": [
            {
                "hunk": [
                    "-        if 'referred' in node:",
                    "-            self.body.append(r'\\sphinxstepexplicit ')",
                    "         if self.in_parsed_literal:",
                    "             self.body.append(r'\\begin{footnote}[%s]' % label.astext())",
                    "         else:",
                    "             self.body.append('%' + CR)",
                    "             self.body.append(r'\\begin{footnote}[%s]' % label.astext())",
                    "         if 'referred' in node:",
                    "-            self.body.append(r'\\phantomsection'",
                    "-                             r'\\label{\\thesphinxscope.%s}%%' % label.astext() + CR)",
                    "+            # TODO: in future maybe output a latex macro with backrefs here",
                    "+            pass"
                ],
                "start_lineno": 817,
                "end_lineno": 826
            },
            {
                "hunk": [
                    "-        self.body.append(r'\\begin{footnotetext}[%s]'",
                    "-                         r'\\phantomsection\\label{\\thesphinxscope.%s}%%'",
                    "-                         % (label.astext(), label.astext()) + CR)",
                    "+        self.body.append(r'\\begin{footnotetext}[%s]' % label.astext())"
                ],
                "start_lineno": 1720,
                "end_lineno": 1722
            }
        ]
    },
    "astropy__astropy-14966": {
        "astropy/table/groups.py": [
            {
                "hunk": [
                    "+    # TODO: don't use represent_mixins_as_columns here, but instead ensure that",
                    "+    # keys_sort.argsort(kind=\"stable\") works for all columns (including mixins).",
                    "+",
                    "     # If there is not already an available index and table_keys is a Table then ensure",
                    "     # that all cols (including mixins) are in a form that can sorted with the code below.",
                    "     if not table_index and isinstance(table_keys, Table):",
                    "-        table_keys = represent_mixins_as_columns(table_keys)",
                    "+        table_keys_sort = represent_mixins_as_columns(table_keys)",
                    "+    else:",
                    "+        table_keys_sort = table_keys"
                ],
                "start_lineno": 77,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "-            idx_sort = table_keys.argsort(kind=\"mergesort\")",
                    "+            idx_sort = table_keys_sort.argsort(kind=\"stable\")",
                    "         stable_sort = True",
                    "     except TypeError:",
                    "+        # TODO: is this still needed?",
                    "+",
                    "         # Some versions (likely 1.6 and earlier) of numpy don't support",
                    "         # 'mergesort' for all data types.  MacOSX (Darwin) doesn't have a stable",
                    "         # sort by default, nor does Windows, while Linux does (or appears to).",
                    "-        idx_sort = table_keys.argsort()",
                    "+        idx_sort = table_keys_sort.argsort()"
                ],
                "start_lineno": 88,
                "end_lineno": 94
            },
            {
                "hunk": [
                    "-    if isinstance(keys, Table):",
                    "-        keys = represent_mixins_as_columns(keys)",
                    "-        keys = keys.as_array()",
                    "+    # TODO: don't use represent_mixins_as_columns here, but instead ensure that",
                    "+    # keys_sort.argsort(kind=\"stable\") works for all columns (including mixins).",
                    " ",
                    "-    if not isinstance(keys, np.ndarray):",
                    "-        raise TypeError(f\"Keys input must be numpy array, but got {type(keys)}\")",
                    "+    if isinstance(keys, Table):",
                    "+        keys_sort = represent_mixins_as_columns(keys)",
                    "+    else:",
                    "+        keys_sort = keys",
                    " ",
                    "-    if len(keys) != len(column):",
                    "+    if len(keys_sort) != len(column):",
                    "         raise ValueError(",
                    "             \"Input keys array length {} does not match column length {}\".format(",
                    "                 len(keys), len(column)",
                    "             )",
                    "         )",
                    " ",
                    "-    idx_sort = keys.argsort()",
                    "+    try:",
                    "+        idx_sort = keys_sort.argsort(kind=\"stable\")",
                    "+    except AttributeError:",
                    "+        raise TypeError(",
                    "+            f\"keys input ({keys.__class__.__name__}) must have an `argsort` method\"",
                    "+        )",
                    "+"
                ],
                "start_lineno": 139,
                "end_lineno": 153
            }
        ]
    },
    "django__django-16046": {
        "django/utils/numberformat.py": [
            {
                "hunk": [
                    "+    if number is None or number == \"\":",
                    "+        return mark_safe(number)"
                ],
                "start_lineno": 28,
                "end_lineno": 28
            }
        ]
    },
    "pydata__xarray-4819": {
        "xarray/core/dataarray.py": [
            {
                "hunk": [
                    "+    def drop_isel(self, indexers=None, **indexers_kwargs):",
                    "+        \"\"\"Drop index positions from this DataArray.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        indexers : mapping of hashable to Any",
                    "+            Index locations to drop",
                    "+        **indexers_kwargs : {dim: position, ...}, optional",
                    "+            The keyword arguments form of ``dim`` and ``positions``",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        dropped : DataArray",
                    "+",
                    "+        Raises",
                    "+        ------",
                    "+        IndexError",
                    "+        \"\"\"",
                    "+        dataset = self._to_temp_dataset()",
                    "+        dataset = dataset.drop_isel(indexers=indexers, **indexers_kwargs)",
                    "+        return self._from_temp_dataset(dataset)",
                    "+"
                ],
                "start_lineno": 2250,
                "end_lineno": 2250
            }
        ],
        "xarray/core/dataset.py": [
            {
                "hunk": [
                    "-                index = self.indexes[dim]",
                    "+                index = self.get_index(dim)",
                    "             except KeyError:",
                    "                 raise ValueError(\"dimension %r does not have coordinate labels\" % dim)",
                    "             new_index = index.drop(labels_for_dim, errors=errors)",
                    "             ds = ds.loc[{dim: new_index}]",
                    "         return ds",
                    " ",
                    "+    def drop_isel(self, indexers=None, **indexers_kwargs):",
                    "+        \"\"\"Drop index positions from this Dataset.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        indexers : mapping of hashable to Any",
                    "+            Index locations to drop",
                    "+        **indexers_kwargs : {dim: position, ...}, optional",
                    "+            The keyword arguments form of ``dim`` and ``positions``",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        dropped : Dataset",
                    "+",
                    "+        Raises",
                    "+        ------",
                    "+        IndexError",
                    "+",
                    "+        Examples",
                    "+        --------",
                    "+        >>> data = np.arange(6).reshape(2, 3)",
                    "+        >>> labels = [\"a\", \"b\", \"c\"]",
                    "+        >>> ds = xr.Dataset({\"A\": ([\"x\", \"y\"], data), \"y\": labels})",
                    "+        >>> ds",
                    "+        <xarray.Dataset>",
                    "+        Dimensions:  (x: 2, y: 3)",
                    "+        Coordinates:",
                    "+          * y        (y) <U1 'a' 'b' 'c'",
                    "+        Dimensions without coordinates: x",
                    "+        Data variables:",
                    "+            A        (x, y) int64 0 1 2 3 4 5",
                    "+        >>> ds.drop_isel(y=[0, 2])",
                    "+        <xarray.Dataset>",
                    "+        Dimensions:  (x: 2, y: 1)",
                    "+        Coordinates:",
                    "+          * y        (y) <U1 'b'",
                    "+        Dimensions without coordinates: x",
                    "+        Data variables:",
                    "+            A        (x, y) int64 1 4",
                    "+        >>> ds.drop_isel(y=1)",
                    "+        <xarray.Dataset>",
                    "+        Dimensions:  (x: 2, y: 2)",
                    "+        Coordinates:",
                    "+          * y        (y) <U1 'a' 'c'",
                    "+        Dimensions without coordinates: x",
                    "+        Data variables:",
                    "+            A        (x, y) int64 0 2 3 5",
                    "+        \"\"\"",
                    "+",
                    "+        indexers = either_dict_or_kwargs(indexers, indexers_kwargs, \"drop\")",
                    "+",
                    "+        ds = self",
                    "+        dimension_index = {}",
                    "+        for dim, pos_for_dim in indexers.items():",
                    "+            # Don't cast to set, as it would harm performance when labels",
                    "+            # is a large numpy array",
                    "+            if utils.is_scalar(pos_for_dim):",
                    "+                pos_for_dim = [pos_for_dim]",
                    "+            pos_for_dim = np.asarray(pos_for_dim)",
                    "+            index = self.get_index(dim)",
                    "+            new_index = index.delete(pos_for_dim)",
                    "+            dimension_index[dim] = new_index",
                    "+        ds = ds.loc[dimension_index]",
                    "+        return ds",
                    "+"
                ],
                "start_lineno": 4056,
                "end_lineno": 4062
            }
        ]
    },
    "django__django-15018": {
        "django/core/management/__init__.py": [
            {
                "hunk": [
                    "+            opt_dest_count = sum(v == opt.dest for v in opt_mapping.values())",
                    "+            if opt_dest_count > 1:",
                    "+                raise TypeError(",
                    "+                    f'Cannot pass the dest {opt.dest!r} that matches multiple '",
                    "+                    f'arguments via **options.'",
                    "+                )"
                ],
                "start_lineno": 152,
                "end_lineno": 152
            }
        ]
    },
    "scikit-learn__scikit-learn-10443": {
        "sklearn/feature_extraction/text.py": [
            {
                "hunk": [
                    "-from __future__ import unicode_literals",
                    "+from __future__ import unicode_literals, division"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "-from ..utils.validation import check_is_fitted",
                    "+from ..utils.validation import check_is_fitted, check_array, FLOAT_DTYPES"
                ],
                "start_lineno": 32,
                "end_lineno": 32
            },
            {
                "hunk": [
                    "-        return np.diff(sp.csc_matrix(X, copy=False).indptr)",
                    "+        return np.diff(X.indptr)"
                ],
                "start_lineno": 576,
                "end_lineno": 576
            },
            {
                "hunk": [
                    "+        X = check_array(X, accept_sparse=('csr', 'csc'))",
                    "         if not sp.issparse(X):",
                    "-            X = sp.csc_matrix(X)",
                    "+            X = sp.csr_matrix(X)",
                    "+        dtype = X.dtype if X.dtype in FLOAT_DTYPES else np.float64",
                    "+",
                    "         if self.use_idf:",
                    "             n_samples, n_features = X.shape",
                    "-            df = _document_frequency(X)",
                    "+            df = _document_frequency(X).astype(dtype)"
                ],
                "start_lineno": 1120,
                "end_lineno": 1124
            },
            {
                "hunk": [
                    "-            idf = np.log(float(n_samples) / df) + 1.0",
                    "-            self._idf_diag = sp.spdiags(idf, diags=0, m=n_features,",
                    "-                                        n=n_features, format='csr')",
                    "+            idf = np.log(n_samples / df) + 1",
                    "+            self._idf_diag = sp.diags(idf, offsets=0,",
                    "+                                      shape=(n_features, n_features),",
                    "+                                      format='csr',",
                    "+                                      dtype=dtype)"
                ],
                "start_lineno": 1132,
                "end_lineno": 1134
            },
            {
                "hunk": [
                    "-        if hasattr(X, 'dtype') and np.issubdtype(X.dtype, np.floating):",
                    "-            # preserve float family dtype",
                    "-            X = sp.csr_matrix(X, copy=copy)",
                    "-        else:",
                    "-            # convert counts or binary occurrences to floats",
                    "-            X = sp.csr_matrix(X, dtype=np.float64, copy=copy)",
                    "+        X = check_array(X, accept_sparse='csr', dtype=FLOAT_DTYPES, copy=copy)",
                    "+        if not sp.issparse(X):",
                    "+            X = sp.csr_matrix(X, dtype=np.float64)"
                ],
                "start_lineno": 1154,
                "end_lineno": 1159
            },
            {
                "hunk": [
                    "-                 dtype=np.int64, norm='l2', use_idf=True, smooth_idf=True,",
                    "+                 dtype=np.float64, norm='l2', use_idf=True, smooth_idf=True,"
                ],
                "start_lineno": 1370,
                "end_lineno": 1370
            },
            {
                "hunk": [
                    "+    def _check_params(self):",
                    "+        if self.dtype not in FLOAT_DTYPES:",
                    "+            warnings.warn(\"Only {} 'dtype' should be used. {} 'dtype' will \"",
                    "+                          \"be converted to np.float64.\"",
                    "+                          .format(FLOAT_DTYPES, self.dtype),",
                    "+                          UserWarning)",
                    "+"
                ],
                "start_lineno": 1435,
                "end_lineno": 1435
            },
            {
                "hunk": [
                    "+        self._check_params()"
                ],
                "start_lineno": 1447,
                "end_lineno": 1447
            },
            {
                "hunk": [
                    "+        self._check_params()"
                ],
                "start_lineno": 1467,
                "end_lineno": 1467
            }
        ]
    },
    "django__django-15703": {
        "django/db/migrations/operations/models.py": [
            {
                "hunk": [
                    "+    system_check_deprecated_details = {",
                    "+        \"msg\": (",
                    "+            \"AlterIndexTogether is deprecated. Support for it (except in historical \"",
                    "+            \"migrations) will be removed in Django 5.1.\"",
                    "+        ),",
                    "+        \"id\": \"migrations.W001\",",
                    "+    }",
                    "+"
                ],
                "start_lineno": 618,
                "end_lineno": 618
            }
        ],
        "django/db/models/options.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "+from django.utils.deprecation import RemovedInDjango51Warning"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            },
            {
                "hunk": [
                    "+            if self.index_together:",
                    "+                warnings.warn(",
                    "+                    f\"'index_together' is deprecated. Use 'Meta.indexes' in \"",
                    "+                    f\"{self.label!r} instead.\",",
                    "+                    RemovedInDjango51Warning,",
                    "+                )"
                ],
                "start_lineno": 203,
                "end_lineno": 203
            }
        ]
    },
    "sphinx-doc__sphinx-11109": {
        "sphinx/domains/python.py": [
            {
                "hunk": [
                    "+    short_literals = env.config.python_display_short_literal_types",
                    "+"
                ],
                "start_lineno": 133,
                "end_lineno": 133
            },
            {
                "hunk": [
                    "+            if short_literals and getattr(node.value, 'id', '') == 'Literal':",
                    "+                return _unparse_pep_604_annotation(node)"
                ],
                "start_lineno": 185,
                "end_lineno": 185
            },
            {
                "hunk": [
                    "+    app.add_config_value('python_display_short_literal_types', False, 'env')"
                ],
                "start_lineno": 1514,
                "end_lineno": 1514
            }
        ]
    },
    "sympy__sympy-21259": {
        "sympy/sets/fancysets.py": [
            {
                "hunk": [
                    "-from sympy.core.numbers import oo, Integer",
                    "+from sympy.core.numbers import oo"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-        if self.has(Symbol):",
                    "-            if dif.has(Symbol) or self.step.has(Symbol) or (",
                    "-                    not self.start.is_integer and not self.stop.is_integer):",
                    "-                raise ValueError('invalid method for symbolic range')",
                    "-        if dif.is_infinite:",
                    "-            return S.Infinity",
                    "-        return Integer(abs(dif//self.step))",
                    "+        n = abs(dif // self.step)",
                    "+        if not n.is_Integer:",
                    "+            if n.is_infinite:",
                    "+                return S.Infinity",
                    "+            raise ValueError('invalid method for symbolic range')",
                    "+        return n"
                ],
                "start_lineno": 720,
                "end_lineno": 726
            },
            {
                "hunk": [
                    "-        from sympy.functions.elementary.integers import floor",
                    "         if self.size == 1:",
                    "             return Eq(x, self[0])",
                    "+        elif self.size == 0:",
                    "+            return S.false",
                    "         else:",
                    "-            return And(",
                    "-                Eq(x, floor(x)),",
                    "-                x >= self.inf if self.inf in self else x > self.inf,",
                    "-                x <= self.sup if self.sup in self else x < self.sup)",
                    "+            from sympy.core.mod import Mod",
                    "+            cond = None",
                    "+            if self.start.is_infinite:",
                    "+                if self.stop.is_infinite:",
                    "+                    cond = S.true",
                    "+                else:",
                    "+                    a = self.reversed.start",
                    "+            elif self.start == self.stop:",
                    "+                cond = S.false  # null range",
                    "+            else:",
                    "+                a = self.start",
                    "+            step = abs(self.step)",
                    "+            cond = Eq(Mod(x, step), a % step) if cond is None else cond",
                    "+            return And(cond,",
                    "+                       x >= self.inf if self.inf in self else x > self.inf,",
                    "+                       x <= self.sup if self.sup in self else x < self.sup)"
                ],
                "start_lineno": 913,
                "end_lineno": 920
            }
        ]
    },
    "django__django-15240": {
        "django/core/management/commands/migrate.py": [
            {
                "hunk": [
                    "+        parser.add_argument(",
                    "+            '--prune', action='store_true', dest='prune',",
                    "+            help='Delete nonexistent migrations from the django_migrations table.',",
                    "+        )"
                ],
                "start_lineno": 70,
                "end_lineno": 70
            },
            {
                "hunk": [
                    "+        if options['prune']:",
                    "+            if not options['app_label']:",
                    "+                raise CommandError(",
                    "+                    'Migrations can be pruned only when an app is specified.'",
                    "+                )",
                    "+            if self.verbosity > 0:",
                    "+                self.stdout.write('Pruning migrations:', self.style.MIGRATE_HEADING)",
                    "+            to_prune = set(executor.loader.applied_migrations) - set(executor.loader.disk_migrations)",
                    "+            squashed_migrations_with_deleted_replaced_migrations = [",
                    "+                migration_key",
                    "+                for migration_key, migration_obj in executor.loader.replacements.items()",
                    "+                if any(replaced in to_prune for replaced in migration_obj.replaces)",
                    "+            ]",
                    "+            if squashed_migrations_with_deleted_replaced_migrations:",
                    "+                self.stdout.write(self.style.NOTICE(",
                    "+                    \"  Cannot use --prune because the following squashed \"",
                    "+                    \"migrations have their 'replaces' attributes and may not \"",
                    "+                    \"be recorded as applied:\"",
                    "+                ))",
                    "+                for migration in squashed_migrations_with_deleted_replaced_migrations:",
                    "+                    app, name = migration",
                    "+                    self.stdout.write(f'    {app}.{name}')",
                    "+                self.stdout.write(self.style.NOTICE(",
                    "+                    \"  Re-run 'manage.py migrate' if they are not marked as \"",
                    "+                    \"applied, and remove 'replaces' attributes in their \"",
                    "+                    \"Migration classes.\"",
                    "+                ))",
                    "+            else:",
                    "+                to_prune = sorted(",
                    "+                    migration",
                    "+                    for migration in to_prune",
                    "+                    if migration[0] == app_label",
                    "+                )",
                    "+                if to_prune:",
                    "+                    for migration in to_prune:",
                    "+                        app, name = migration",
                    "+                        if self.verbosity > 0:",
                    "+                            self.stdout.write(self.style.MIGRATE_LABEL(",
                    "+                                f'  Pruning {app}.{name}'",
                    "+                            ), ending='')",
                    "+                        executor.recorder.record_unapplied(app, name)",
                    "+                        if self.verbosity > 0:",
                    "+                            self.stdout.write(self.style.SUCCESS(' OK'))",
                    "+                elif self.verbosity > 0:",
                    "+                    self.stdout.write('  No migrations to prune.')",
                    "+"
                ],
                "start_lineno": 159,
                "end_lineno": 159
            },
            {
                "hunk": [
                    "+        if options['prune']:",
                    "+            return"
                ],
                "start_lineno": 177,
                "end_lineno": 177
            }
        ]
    },
    "sympy__sympy-22934": {
        "sympy/polys/fields.py": [
            {
                "hunk": [
                    "+            elif mapping.get(1/expr) is not None:",
                    "+                return 1/mapping.get(1/expr)"
                ],
                "start_lineno": 256,
                "end_lineno": 256
            }
        ]
    },
    "matplotlib__matplotlib-25794": {
        "lib/matplotlib/axes/_axes.py": [
            {
                "hunk": [
                    "+        # add edgecolors and linewidths to kwargs so they",
                    "+        # can be processed by normailze_kwargs",
                    "+        if edgecolors is not None:",
                    "+            kwargs.update({'edgecolors': edgecolors})",
                    "+        if linewidths is not None:",
                    "+            kwargs.update({'linewidths': linewidths})",
                    "+",
                    "+        kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)",
                    "+        # re direct linewidth and edgecolor so it can be",
                    "+        # further processed by the rest of the function",
                    "+        linewidths = kwargs.pop('linewidth', None)",
                    "+        edgecolors = kwargs.pop('edgecolor', None)"
                ],
                "start_lineno": 4555,
                "end_lineno": 4555
            }
        ]
    },
    "django__django-12153": {
        "django/contrib/auth/migrations/0011_update_proxy_permissions.py": [
            {
                "hunk": [
                    "+    alias = schema_editor.connection.alias"
                ],
                "start_lineno": 26,
                "end_lineno": 26
            },
            {
                "hunk": [
                    "-        concrete_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=True)",
                    "-        proxy_content_type = ContentType.objects.get_for_model(Model, for_concrete_model=False)",
                    "+        content_type_manager = ContentType.objects.db_manager(alias)",
                    "+        concrete_content_type = content_type_manager.get_for_model(Model, for_concrete_model=True)",
                    "+        proxy_content_type = content_type_manager.get_for_model(Model, for_concrete_model=False)",
                    "         old_content_type = proxy_content_type if reverse else concrete_content_type",
                    "         new_content_type = concrete_content_type if reverse else proxy_content_type",
                    "         try:",
                    "-            with transaction.atomic():",
                    "-                Permission.objects.filter(",
                    "+            with transaction.atomic(using=alias):",
                    "+                Permission.objects.using(alias).filter("
                ],
                "start_lineno": 37,
                "end_lineno": 43
            }
        ]
    },
    "sympy__sympy-15609": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-            + '_{%s, %s}' % (expr.i, expr.j)",
                    "+            + '_{%s, %s}' % (",
                    "+            self._print(expr.i),",
                    "+            self._print(expr.j)",
                    "+        )"
                ],
                "start_lineno": 1441,
                "end_lineno": 1441
            }
        ]
    },
    "pydata__xarray-7393": {
        "xarray/core/indexing.py": [
            {
                "hunk": [
                    "+        if dtype is None:",
                    "+            dtype = self.dtype",
                    "         if self.level is not None:",
                    "-            return self.array.get_level_values(self.level).values",
                    "+            return np.asarray(",
                    "+                self.array.get_level_values(self.level).values, dtype=dtype",
                    "+            )"
                ],
                "start_lineno": 1534,
                "end_lineno": 1535
            }
        ]
    },
    "django__django-11692": {
        "django/db/models/sql/compiler.py": [
            {
                "hunk": [
                    "-                    elif not features.supports_slicing_ordering_in_compound:",
                    "+                    elif (",
                    "+                        self.query.subquery or",
                    "+                        not features.supports_slicing_ordering_in_compound",
                    "+                    ):"
                ],
                "start_lineno": 506,
                "end_lineno": 506
            },
            {
                "hunk": [
                    "-        braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'",
                    "+        braces = '{}'",
                    "+        if not self.query.subquery and features.supports_slicing_ordering_in_compound:",
                    "+            braces = '({})'"
                ],
                "start_lineno": 520,
                "end_lineno": 520
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "+        # Resolve combined queries.",
                    "+        if clone.combinator:",
                    "+            clone.combined_queries = tuple([",
                    "+                combined_query.resolve_expression(query, *args, **kwargs)",
                    "+                for combined_query in clone.combined_queries",
                    "+            ])"
                ],
                "start_lineno": 1051,
                "end_lineno": 1051
            }
        ]
    },
    "scikit-learn__scikit-learn-13439": {
        "sklearn/pipeline.py": [
            {
                "hunk": [
                    "+    def __len__(self):",
                    "+        \"\"\"",
                    "+        Returns the length of the Pipeline",
                    "+        \"\"\"",
                    "+        return len(self.steps)",
                    "+"
                ],
                "start_lineno": 202,
                "end_lineno": 202
            }
        ]
    },
    "sphinx-doc__sphinx-9828": {
        "sphinx/application.py": [
            {
                "hunk": [
                    "-                    catalog.write_mo(self.config.language)",
                    "+                    catalog.write_mo(self.config.language,",
                    "+                                     self.config.gettext_allow_fuzzy_translations)"
                ],
                "start_lineno": 287,
                "end_lineno": 287
            }
        ],
        "sphinx/builders/__init__.py": [
            {
                "hunk": [
                    "-            catalog.write_mo(self.config.language)",
                    "+            catalog.write_mo(self.config.language,",
                    "+                             self.config.gettext_allow_fuzzy_translations)"
                ],
                "start_lineno": 220,
                "end_lineno": 220
            }
        ],
        "sphinx/config.py": [
            {
                "hunk": [
                    "+        'gettext_allow_fuzzy_translations': (False, 'gettext', []),"
                ],
                "start_lineno": 106,
                "end_lineno": 106
            }
        ],
        "sphinx/util/i18n.py": [
            {
                "hunk": [
                    "-    def write_mo(self, locale: str) -> None:",
                    "+    def write_mo(self, locale: str, use_fuzzy: bool = False) -> None:"
                ],
                "start_lineno": 62,
                "end_lineno": 62
            },
            {
                "hunk": [
                    "-                write_mo(file_mo, po)",
                    "+                write_mo(file_mo, po, use_fuzzy)"
                ],
                "start_lineno": 72,
                "end_lineno": 72
            }
        ]
    },
    "scikit-learn__scikit-learn-14983": {
        "sklearn/model_selection/_split.py": [
            {
                "hunk": [
                    "+    def __repr__(self):",
                    "+        return _build_repr(self)",
                    "+"
                ],
                "start_lineno": 1166,
                "end_lineno": 1166
            },
            {
                "hunk": [
                    "+                if value is None and hasattr(self, 'cvargs'):",
                    "+                    value = self.cvargs.get(key, None)"
                ],
                "start_lineno": 2161,
                "end_lineno": 2161
            }
        ]
    },
    "astropy__astropy-14182": {
        "astropy/io/ascii/rst.py": [
            {
                "hunk": [
                    "-    start_line = 3"
                ],
                "start_lineno": 30,
                "end_lineno": 30
            },
            {
                "hunk": [
                    "-        ==== ===== ======",
                    "-        Col1  Col2  Col3",
                    "-        ==== ===== ======",
                    "-          1    2.3  Hello",
                    "-          2    4.5  Worlds",
                    "-        ==== ===== ======",
                    "+      >>> from astropy.table import QTable",
                    "+      >>> import astropy.units as u",
                    "+      >>> import sys",
                    "+      >>> tbl = QTable({\"wave\": [350, 950] * u.nm, \"response\": [0.7, 1.2] * u.count})",
                    "+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\")",
                    "+      ===== ========",
                    "+       wave response",
                    "+      ===== ========",
                    "+      350.0      0.7",
                    "+      950.0      1.2",
                    "+      ===== ========",
                    "+",
                    "+    Like other fixed-width formats, when writing a table you can provide ``header_rows``",
                    "+    to specify a list of table rows to output as the header.  For example::",
                    "+",
                    "+      >>> tbl.write(sys.stdout,  format=\"ascii.rst\", header_rows=['name', 'unit'])",
                    "+      ===== ========",
                    "+       wave response",
                    "+         nm       ct",
                    "+      ===== ========",
                    "+      350.0      0.7",
                    "+      950.0      1.2",
                    "+      ===== ========"
                ],
                "start_lineno": 42,
                "end_lineno": 47
            },
            {
                "hunk": [
                    "-    def __init__(self):",
                    "-        super().__init__(delimiter_pad=None, bookend=False)",
                    "+    def __init__(self, header_rows=None):",
                    "+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)",
                    " ",
                    "     def write(self, lines):",
                    "         lines = super().write(lines)",
                    "-        lines = [lines[1]] + lines + [lines[1]]",
                    "+        idx = len(self.header.header_rows)",
                    "+        lines = [lines[idx]] + lines + [lines[idx]]",
                    "         return lines",
                    "+",
                    "+    def read(self, table):",
                    "+        self.data.start_line = 2 + len(self.header.header_rows)",
                    "+        return super().read(table)"
                ],
                "start_lineno": 60,
                "end_lineno": 66
            }
        ]
    },
    "sympy__sympy-13974": {
        "sympy/physics/quantum/tensorproduct.py": [
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 21,
                "end_lineno": 21
            },
            {
                "hunk": [
                    "-    # TensorProducts, like an Add, Pow, Commutator, etc.",
                    "+    # TensorProducts, like an Add, Commutator, etc.",
                    "     # TODO: This only works for the equivalent of single Qbit gates.",
                    "     if not isinstance(e, Mul):",
                    "         return e",
                    "     c_part, nc_part = e.args_cnc()",
                    "     n_nc = len(nc_part)",
                    "-    if n_nc == 0 or n_nc == 1:",
                    "+    if n_nc == 0:",
                    "+        return e",
                    "+    elif n_nc == 1:",
                    "+        if isinstance(nc_part[0], Pow):",
                    "+            return  Mul(*c_part) * tensor_product_simp_Pow(nc_part[0])",
                    "         return e",
                    "     elif e.has(TensorProduct):",
                    "         current = nc_part[0]",
                    "         if not isinstance(current, TensorProduct):",
                    "-            raise TypeError('TensorProduct expected, got: %r' % current)",
                    "+            if isinstance(current, Pow):",
                    "+                if isinstance(current.base, TensorProduct):",
                    "+                    current = tensor_product_simp_Pow(current)",
                    "+            else:",
                    "+                raise TypeError('TensorProduct expected, got: %r' % current)"
                ],
                "start_lineno": 313,
                "end_lineno": 324
            },
            {
                "hunk": [
                    "-                # this won't quite work as we don't want next in the",
                    "-                # TensorProduct",
                    "-                for i in range(len(new_args)):",
                    "-                    new_args[i] = new_args[i] * next",
                    "+                if isinstance(next, Pow):",
                    "+                    if isinstance(next.base, TensorProduct):",
                    "+                        new_tp = tensor_product_simp_Pow(next)",
                    "+                        for i in range(len(new_args)):",
                    "+                            new_args[i] = new_args[i] * new_tp.args[i]",
                    "+                    else:",
                    "+                        raise TypeError('TensorProduct expected, got: %r' % next)",
                    "+                else:",
                    "+                    raise TypeError('TensorProduct expected, got: %r' % next)",
                    "             current = next",
                    "         return Mul(*c_part) * TensorProduct(*new_args)",
                    "+    elif e.has(Pow):",
                    "+        new_args = [ tensor_product_simp_Pow(nc) for nc in nc_part ]",
                    "+        return tensor_product_simp_Mul(Mul(*c_part) * TensorProduct(*new_args))",
                    "     else:",
                    "         return e",
                    " ",
                    "+def tensor_product_simp_Pow(e):",
                    "+    \"\"\"Evaluates ``Pow`` expressions whose base is ``TensorProduct``\"\"\"",
                    "+    if not isinstance(e, Pow):",
                    "+        return e",
                    "+",
                    "+    if isinstance(e.base, TensorProduct):",
                    "+        return TensorProduct(*[ b**e.exp for b in e.base.args])",
                    "+    else:",
                    "+        return e"
                ],
                "start_lineno": 338,
                "end_lineno": 346
            },
            {
                "hunk": [
                    "-        return tensor_product_simp(e.base) ** e.exp",
                    "+        if isinstance(e.base, TensorProduct):",
                    "+            return tensor_product_simp_Pow(e)",
                    "+        else:",
                    "+            return tensor_product_simp(e.base) ** e.exp"
                ],
                "start_lineno": 385,
                "end_lineno": 385
            }
        ]
    },
    "matplotlib__matplotlib-25547": {
        "lib/matplotlib/axes/_axes.py": [
            {
                "hunk": [
                    "-            except StopIteration:",
                    "-                # this means we found no finite element, fall back to first",
                    "-                # element unconditionally",
                    "-                x0 = cbook.safe_first_element(x0)",
                    " ",
                    "             try:",
                    "                 x = cbook._safe_first_finite(xconv)",
                    "             except (TypeError, IndexError, KeyError):",
                    "                 x = xconv",
                    "-            except StopIteration:",
                    "-                # this means we found no finite element, fall back to first",
                    "-                # element unconditionally",
                    "-                x = cbook.safe_first_element(xconv)"
                ],
                "start_lineno": 2211,
                "end_lineno": 2223
            }
        ],
        "lib/matplotlib/cbook.py": [
            {
                "hunk": [
                    "-    Return the first non-None (and optionally finite) element in *obj*.",
                    "+    Return the first finite element in *obj* if one is available and skip_nonfinite is",
                    "+    True. Otherwise return the first element.",
                    " ",
                    "     This is a method for internal use.",
                    " ",
                    "-    This is a type-independent way of obtaining the first non-None element,",
                    "-    supporting both index access and the iterator protocol.",
                    "-    The first non-None element will be obtained when skip_none is True.",
                    "+    This is a type-independent way of obtaining the first finite element, supporting",
                    "+    both index access and the iterator protocol."
                ],
                "start_lineno": 1622,
                "end_lineno": 1628
            },
            {
                "hunk": [
                    "-        return next(val for val in obj if safe_isfinite(val))",
                    "+        return next((val for val in obj if safe_isfinite(val)), safe_first_element(obj))"
                ],
                "start_lineno": 1660,
                "end_lineno": 1660
            }
        ]
    },
    "django__django-13355": {
        "django/forms/widgets.py": [
            {
                "hunk": [
                    "-        combined._css_lists = self._css_lists + other._css_lists",
                    "-        combined._js_lists = self._js_lists + other._js_lists",
                    "+        combined._css_lists = self._css_lists[:]",
                    "+        combined._js_lists = self._js_lists[:]",
                    "+        for item in other._css_lists:",
                    "+            if item and item not in self._css_lists:",
                    "+                combined._css_lists.append(item)",
                    "+        for item in other._js_lists:",
                    "+            if item and item not in self._js_lists:",
                    "+                combined._js_lists.append(item)"
                ],
                "start_lineno": 149,
                "end_lineno": 150
            }
        ]
    },
    "sympy__sympy-13346": {
        "sympy/printing/pycode.py": [
            {
                "hunk": [
                    "-    def _print_Integer(self, e):",
                    "-        return '%s(%d)' % (self._module_format('mpmath.mpf'), e)",
                    "-"
                ],
                "start_lineno": 209,
                "end_lineno": 211
            }
        ]
    },
    "sympy__sympy-14085": {
        "sympy/parsing/sympy_parser.py": [
            {
                "hunk": [
                    "-from .sympy_tokenize import \\",
                    "-    generate_tokens, untokenize, TokenError, \\",
                    "-    NUMBER, STRING, NAME, OP, ENDMARKER",
                    "+from tokenize import (generate_tokens, untokenize, TokenError,",
                    "+    NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN)",
                    " ",
                    " from keyword import iskeyword",
                    " ",
                    " import ast",
                    "-import re",
                    " import unicodedata",
                    " ",
                    " import sympy",
                    " from sympy.core.compatibility import exec_, StringIO",
                    " from sympy.core.basic import Basic",
                    " ",
                    "-_re_repeated = re.compile(r\"^(\\d*)\\.(\\d*)\\[(\\d+)\\]$\")",
                    "-"
                ],
                "start_lineno": 5,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-    prevtoken = ''",
                    "+    nfactorial = 0",
                    "     for toknum, tokval in tokens:",
                    "-        if toknum == OP:",
                    "+        if toknum == ERRORTOKEN:",
                    "             op = tokval",
                    "-",
                    "-            if op == '!!':",
                    "-                if prevtoken == '!' or prevtoken == '!!':",
                    "-                    raise TokenError",
                    "-                result = _add_factorial_tokens('factorial2', result)",
                    "-            elif op == '!':",
                    "-                if prevtoken == '!' or prevtoken == '!!':",
                    "-                    raise TokenError",
                    "-                result = _add_factorial_tokens('factorial', result)",
                    "+            if op == '!':",
                    "+                nfactorial += 1",
                    "             else:",
                    "+                nfactorial = 0",
                    "                 result.append((OP, op))",
                    "         else:",
                    "+            if nfactorial == 1:",
                    "+                result = _add_factorial_tokens('factorial', result)",
                    "+            elif nfactorial == 2:",
                    "+                result = _add_factorial_tokens('factorial2', result)",
                    "+            elif nfactorial > 2:",
                    "+                raise TokenError",
                    "+            nfactorial = 0",
                    "             result.append((toknum, tokval))",
                    "-",
                    "-        prevtoken = tokval",
                    "-"
                ],
                "start_lineno": 592,
                "end_lineno": 611
            },
            {
                "hunk": [
                    "+def repeated_decimals(tokens, local_dict, global_dict):",
                    "+    \"\"\"",
                    "+    Allows 0.2[1] notation to represent the repeated decimal 0.2111... (19/90)",
                    "+",
                    "+    Run this before auto_number.",
                    "+",
                    "+    \"\"\"",
                    "+    result = []",
                    "+",
                    "+    def is_digit(s):",
                    "+        return all(i in '0123456789_' for i in s)",
                    "+",
                    "+    # num will running match any DECIMAL [ INTEGER ]",
                    "+    num = []",
                    "+    for toknum, tokval in tokens:",
                    "+        if toknum == NUMBER:",
                    "+            if (not num and '.' in tokval and 'e' not in tokval.lower() and",
                    "+                'j' not in tokval.lower()):",
                    "+                num.append((toknum, tokval))",
                    "+            elif is_digit(tokval)and  len(num) == 2:",
                    "+                num.append((toknum, tokval))",
                    "+            elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):",
                    "+                # Python 2 tokenizes 00123 as '00', '123'",
                    "+                # Python 3 tokenizes 01289 as '012', '89'",
                    "+                num.append((toknum, tokval))",
                    "+            else:",
                    "+                num = []",
                    "+        elif toknum == OP:",
                    "+            if tokval == '[' and len(num) == 1:",
                    "+                num.append((OP, tokval))",
                    "+            elif tokval == ']' and len(num) >= 3:",
                    "+                num.append((OP, tokval))",
                    "+            elif tokval == '.' and not num:",
                    "+                # handle .[1]",
                    "+                num.append((NUMBER, '0.'))",
                    "+            else:",
                    "+                num = []",
                    "+        else:",
                    "+            num = []",
                    "+",
                    "+        result.append((toknum, tokval))",
                    "+",
                    "+        if num and num[-1][1] == ']':",
                    "+            # pre.post[repetend] = a + b/c + d/e where a = pre, b/c = post,",
                    "+            # and d/e = repetend",
                    "+            result = result[:-len(num)]",
                    "+            pre, post = num[0][1].split('.')",
                    "+            repetend = num[2][1]",
                    "+            if len(num) == 5:",
                    "+                repetend += num[3][1]",
                    "+",
                    "+            pre = pre.replace('_', '')",
                    "+            post = post.replace('_', '')",
                    "+            repetend = repetend.replace('_', '')",
                    "+",
                    "+            zeros = '0'*len(post)",
                    "+            post, repetends = [w.lstrip('0') for w in [post, repetend]]",
                    "+                                        # or else interpreted as octal",
                    "+",
                    "+            a = pre or '0'",
                    "+            b, c = post or '0', '1' + zeros",
                    "+            d, e = repetends, ('9'*len(repetend)) + zeros",
                    "+",
                    "+            seq = [",
                    "+                (OP, '('),",
                    "+                    (NAME, 'Integer'),",
                    "+                    (OP, '('),",
                    "+                        (NUMBER, a),",
                    "+                    (OP, ')'),",
                    "+                    (OP, '+'),",
                    "+                    (NAME, 'Rational'),",
                    "+                    (OP, '('),",
                    "+                        (NUMBER, b),",
                    "+                        (OP, ','),",
                    "+                        (NUMBER, c),",
                    "+                    (OP, ')'),",
                    "+                    (OP, '+'),",
                    "+                    (NAME, 'Rational'),",
                    "+                    (OP, '('),",
                    "+                        (NUMBER, d),",
                    "+                        (OP, ','),",
                    "+                        (NUMBER, e),",
                    "+                    (OP, ')'),",
                    "+                (OP, ')'),",
                    "+            ]",
                    "+            result.extend(seq)",
                    "+            num = []",
                    "+",
                    "+    return result",
                    " ",
                    " def auto_number(tokens, local_dict, global_dict):",
                    "-    \"\"\"Converts numeric literals to use SymPy equivalents.",
                    "+    \"\"\"",
                    "+    Converts numeric literals to use SymPy equivalents.",
                    " ",
                    "-    Complex numbers use ``I``; integer literals use ``Integer``, float",
                    "-    literals use ``Float``, and repeating decimals use ``Rational``.",
                    "+    Complex numbers use ``I``, integer literals use ``Integer``, and float",
                    "+    literals use ``Float``.",
                    " ",
                    "     \"\"\"",
                    "     result = []",
                    "-    prevtoken = ''"
                ],
                "start_lineno": 629,
                "end_lineno": 638
            },
            {
                "hunk": [
                    "-                match = _re_repeated.match(number)",
                    "-",
                    "-                if match is not None:",
                    "-                    # Clear repeating decimals, e.g. 3.4[31] -> (3 + 4/10 + 31/990)",
                    "-                    pre, post, repetend = match.groups()",
                    "-",
                    "-                    zeros = '0'*len(post)",
                    "-                    post, repetends = [w.lstrip('0') for w in [post, repetend]]",
                    "-                                                # or else interpreted as octal",
                    "-",
                    "-                    a = pre or '0'",
                    "-                    b, c = post or '0', '1' + zeros",
                    "-                    d, e = repetends, ('9'*len(repetend)) + zeros",
                    "-",
                    "-                    seq = [",
                    "-                        (OP, '('),",
                    "-                        (NAME,",
                    "-                         'Integer'), (OP, '('), (NUMBER, a), (OP, ')'),",
                    "-                        (OP, '+'),",
                    "-                        (NAME, 'Rational'), (OP, '('), (",
                    "-                            NUMBER, b), (OP, ','), (NUMBER, c), (OP, ')'),",
                    "-                        (OP, '+'),",
                    "-                        (NAME, 'Rational'), (OP, '('), (",
                    "-                            NUMBER, d), (OP, ','), (NUMBER, e), (OP, ')'),",
                    "-                        (OP, ')'),",
                    "-                    ]",
                    "-                else:",
                    "-                    seq = [(NAME, 'Float'), (OP, '('),",
                    "-                           (NUMBER, repr(str(number))), (OP, ')')]",
                    "+                seq = [(NAME, 'Float'), (OP, '('),",
                    "+                    (NUMBER, repr(str(number))), (OP, ')')]"
                ],
                "start_lineno": 651,
                "end_lineno": 679
            },
            {
                "hunk": [
                    "-"
                ],
                "start_lineno": 690,
                "end_lineno": 690
            },
            {
                "hunk": [
                    "-standard_transformations = (lambda_notation, auto_symbol, auto_number, factorial_notation)",
                    "+standard_transformations = (lambda_notation, auto_symbol, repeated_decimals, auto_number,",
                    "+    factorial_notation)"
                ],
                "start_lineno": 779,
                "end_lineno": 779
            }
        ],
        "sympy/parsing/sympy_tokenize.py": [
            {
                "hunk": [
                    "-\"\"\"Tokenization help for Python programs.",
                    "-",
                    "-generate_tokens(readline) is a generator that breaks a stream of",
                    "-text into Python tokens.  It accepts a readline-like method which is called",
                    "-repeatedly to get the next line of input (or \"\" for EOF).  It generates",
                    "-5-tuples with these members:",
                    "-",
                    "-    the token type (see token.py)",
                    "-    the token (a string)",
                    "-    the starting (row, column) indices of the token (a 2-tuple of ints)",
                    "-    the ending (row, column) indices of the token (a 2-tuple of ints)",
                    "-    the original line (string)",
                    "-",
                    "-It is designed to match the working of the Python tokenizer exactly, except",
                    "-that it produces COMMENT tokens for comments and gives type OP for all",
                    "-operators",
                    "-",
                    "-Older entry points",
                    "-    tokenize_loop(readline, tokeneater)",
                    "-    tokenize(readline, tokeneater=printtoken)",
                    "-are the same, except instead of generating tokens, tokeneater is a callback",
                    "-function to which the 5 fields described above are passed as 5 arguments,",
                    "-each time a new token is found.\"\"\"",
                    "-",
                    "-from __future__ import print_function, division",
                    "-",
                    "-__author__ = 'Ka-Ping Yee <ping@lfw.org>'",
                    "-__credits__ = \\",
                    "-    'GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro, Raymond Hettinger'",
                    "-",
                    "-import string",
                    "-import re",
                    "-from token import *",
                    "-",
                    "-import token",
                    "-__all__ = [x for x in dir(token) if x[0] != '_'] + [\"COMMENT\", \"tokenize\",",
                    "-           \"generate_tokens\", \"NL\", \"untokenize\"]",
                    "-del token",
                    "-",
                    "-COMMENT = N_TOKENS",
                    "-tok_name[COMMENT] = 'COMMENT'",
                    "-NL = N_TOKENS + 1",
                    "-tok_name[NL] = 'NL'",
                    "-N_TOKENS += 2",
                    "-",
                    "-",
                    "-def group(*choices):",
                    "-    return '(' + '|'.join(choices) + ')'",
                    "-",
                    "-",
                    "-def any(*choices):",
                    "-    return group(*choices) + '*'",
                    "-",
                    "-",
                    "-def maybe(*choices):",
                    "-    return group(*choices) + '?'",
                    "-",
                    "-Whitespace = r'[ \\f\\t]*'",
                    "-Comment = r'#[^\\r\\n]*'",
                    "-Ignore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)",
                    "-Name = r'[a-zA-Z_]\\w*'",
                    "-",
                    "-Hexnumber = r'0[xX][\\da-fA-F]+[lL]?'",
                    "-Octnumber = r'(0[oO][0-7]+)|(0[0-7]*)[lL]?'",
                    "-Binnumber = r'0[bB][01]+[lL]?'",
                    "-Decnumber = r'[1-9]\\d*[lL]?'",
                    "-Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)",
                    "-Exponent = r'[eE][-+]?\\d+'",
                    "-Pointfloat = group(r'\\d+\\.\\d*', r'\\.\\d+') + maybe(Exponent)",
                    "-Repeatedfloat = r'\\d*\\.\\d*\\[\\d+\\]'",
                    "-Expfloat = r'\\d+' + Exponent",
                    "-Floatnumber = group(Repeatedfloat, Pointfloat, Expfloat)",
                    "-Imagnumber = group(r'\\d+[jJ]', Floatnumber + r'[jJ]')",
                    "-Number = group(Imagnumber, Floatnumber, Intnumber)",
                    "-",
                    "-# Tail end of ' string.",
                    "-Single = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"",
                    "-# Tail end of \" string.",
                    "-Double = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'",
                    "-# Tail end of ''' string.",
                    "-Single3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"",
                    "-# Tail end of \"\"\" string.",
                    "-Double3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'",
                    "-Triple = group(\"[uU]?[rR]?'''\", '[uU]?[rR]?\"\"\"')",
                    "-# Single-line ' or \" string.",
                    "-String = group(r\"[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",",
                    "-               r'[uU]?[rR]?\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')",
                    "-",
                    "-# Because of leftmost-then-longest match semantics, be sure to put the",
                    "-# longest operators first (e.g., if = came before ==, == would get",
                    "-# recognized as two instances of =).",
                    "-Operator = group(r\"\\*\\*=?\", r\">>=?\", r\"<<=?\", r\"<>\", r\"!=\",",
                    "-                 r\"//=?\",",
                    "-                 r\"[+\\-*/%&|^=<>]=?\",",
                    "-                 r\"~\")",
                    "-",
                    "-Bracket = '[][(){}]'",
                    "-Special = group(r'\\r?\\n', r'[:;.,`@]', r'\\!\\!', r'\\!')",
                    "-Funny = group(Operator, Bracket, Special)",
                    "-",
                    "-PlainToken = group(Number, Funny, String, Name)",
                    "-Token = Ignore + PlainToken",
                    "-",
                    "-# First (or only) line of ' or \" string.",
                    "-ContStr = group(r\"[uU]?[rR]?'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +",
                    "-                group(\"'\", r'\\\\\\r?\\n'),",
                    "-                r'[uU]?[rR]?\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +",
                    "-                group('\"', r'\\\\\\r?\\n'))",
                    "-PseudoExtras = group(r'\\\\\\r?\\n', Comment, Triple)",
                    "-PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)",
                    "-",
                    "-tokenprog, pseudoprog, single3prog, double3prog = map(",
                    "-    re.compile, (Token, PseudoToken, Single3, Double3))",
                    "-endprogs = {\"'\": re.compile(Single), '\"': re.compile(Double),",
                    "-            \"'''\": single3prog, '\"\"\"': double3prog,",
                    "-            \"r'''\": single3prog, 'r\"\"\"': double3prog,",
                    "-            \"u'''\": single3prog, 'u\"\"\"': double3prog,",
                    "-            \"ur'''\": single3prog, 'ur\"\"\"': double3prog,",
                    "-            \"R'''\": single3prog, 'R\"\"\"': double3prog,",
                    "-            \"U'''\": single3prog, 'U\"\"\"': double3prog,",
                    "-            \"uR'''\": single3prog, 'uR\"\"\"': double3prog,",
                    "-            \"Ur'''\": single3prog, 'Ur\"\"\"': double3prog,",
                    "-            \"UR'''\": single3prog, 'UR\"\"\"': double3prog,",
                    "-            \"b'''\": single3prog, 'b\"\"\"': double3prog,",
                    "-            \"br'''\": single3prog, 'br\"\"\"': double3prog,",
                    "-            \"B'''\": single3prog, 'B\"\"\"': double3prog,",
                    "-            \"bR'''\": single3prog, 'bR\"\"\"': double3prog,",
                    "-            \"Br'''\": single3prog, 'Br\"\"\"': double3prog,",
                    "-            \"BR'''\": single3prog, 'BR\"\"\"': double3prog,",
                    "-            'r': None, 'R': None, 'u': None, 'U': None,",
                    "-            'b': None, 'B': None}",
                    "-",
                    "-triple_quoted = {}",
                    "-for t in (\"'''\", '\"\"\"',",
                    "-          \"r'''\", 'r\"\"\"', \"R'''\", 'R\"\"\"',",
                    "-          \"u'''\", 'u\"\"\"', \"U'''\", 'U\"\"\"',",
                    "-          \"ur'''\", 'ur\"\"\"', \"Ur'''\", 'Ur\"\"\"',",
                    "-          \"uR'''\", 'uR\"\"\"', \"UR'''\", 'UR\"\"\"',",
                    "-          \"b'''\", 'b\"\"\"', \"B'''\", 'B\"\"\"',",
                    "-          \"br'''\", 'br\"\"\"', \"Br'''\", 'Br\"\"\"',",
                    "-          \"bR'''\", 'bR\"\"\"', \"BR'''\", 'BR\"\"\"'):",
                    "-    triple_quoted[t] = t",
                    "-single_quoted = {}",
                    "-for t in (\"'\", '\"',",
                    "-          \"r'\", 'r\"', \"R'\", 'R\"',",
                    "-          \"u'\", 'u\"', \"U'\", 'U\"',",
                    "-          \"ur'\", 'ur\"', \"Ur'\", 'Ur\"',",
                    "-          \"uR'\", 'uR\"', \"UR'\", 'UR\"',",
                    "-          \"b'\", 'b\"', \"B'\", 'B\"',",
                    "-          \"br'\", 'br\"', \"Br'\", 'Br\"',",
                    "-          \"bR'\", 'bR\"', \"BR'\", 'BR\"' ):",
                    "-    single_quoted[t] = t",
                    "-",
                    "-tabsize = 8",
                    "-",
                    "-",
                    "-class TokenError(Exception):",
                    "-    pass",
                    "-",
                    "-",
                    "-class StopTokenizing(Exception):",
                    "-    pass",
                    "-",
                    "-",
                    "-def printtoken(type, token, srow_scol, erow_ecol, line):  # for testing",
                    "-    srow, scol = srow_scol",
                    "-    erow, ecol = erow_ecol",
                    "-    print(\"%d,%d-%d,%d:\\t%s\\t%s\" % \\",
                    "-        (srow, scol, erow, ecol, tok_name[type], repr(token)))",
                    "-",
                    "-",
                    "-def tokenize(readline, tokeneater=printtoken):",
                    "-    \"\"\"",
                    "-    The tokenize() function accepts two parameters: one representing the",
                    "-    input stream, and one providing an output mechanism for tokenize().",
                    "-",
                    "-    The first parameter, readline, must be a callable object which provides",
                    "-    the same interface as the readline() method of built-in file objects.",
                    "-    Each call to the function should return one line of input as a string.",
                    "-",
                    "-    The second parameter, tokeneater, must also be a callable object. It is",
                    "-    called once for each token, with five arguments, corresponding to the",
                    "-    tuples generated by generate_tokens().",
                    "-    \"\"\"",
                    "-    try:",
                    "-        tokenize_loop(readline, tokeneater)",
                    "-    except StopTokenizing:",
                    "-        pass",
                    "-",
                    "-# backwards compatible interface",
                    "-",
                    "-",
                    "-def tokenize_loop(readline, tokeneater):",
                    "-    for token_info in generate_tokens(readline):",
                    "-        tokeneater(*token_info)",
                    "-",
                    "-",
                    "-class Untokenizer:",
                    "-",
                    "-    def __init__(self):",
                    "-        self.tokens = []",
                    "-        self.prev_row = 1",
                    "-        self.prev_col = 0",
                    "-",
                    "-    def add_whitespace(self, start):",
                    "-        row, col = start",
                    "-        if row > self.prev_row:",
                    "-            raise ValueError(\"row should not be greater than prev_row\")",
                    "-        col_offset = col - self.prev_col",
                    "-        if col_offset:",
                    "-            self.tokens.append(\" \" * col_offset)",
                    "-",
                    "-    def untokenize(self, iterable):",
                    "-        for t in iterable:",
                    "-            if len(t) == 2:",
                    "-                self.compat(t, iterable)",
                    "-                break",
                    "-            tok_type, token, start, end, line = t",
                    "-            self.add_whitespace(start)",
                    "-            self.tokens.append(token)",
                    "-            self.prev_row, self.prev_col = end",
                    "-            if tok_type in (NEWLINE, NL):",
                    "-                self.prev_row += 1",
                    "-                self.prev_col = 0",
                    "-        return \"\".join(self.tokens)",
                    "-",
                    "-    def compat(self, token, iterable):",
                    "-        startline = False",
                    "-        indents = []",
                    "-        toks_append = self.tokens.append",
                    "-        toknum, tokval = token",
                    "-        if toknum in (NAME, NUMBER):",
                    "-            tokval += ' '",
                    "-        if toknum in (NEWLINE, NL):",
                    "-            startline = True",
                    "-        prevstring = False",
                    "-        for tok in iterable:",
                    "-            toknum, tokval = tok[:2]",
                    "-",
                    "-            if toknum in (NAME, NUMBER):",
                    "-                tokval += ' '",
                    "-",
                    "-            # Insert a space between two consecutive strings",
                    "-            if toknum == STRING:",
                    "-                if prevstring:",
                    "-                    tokval = ' ' + tokval",
                    "-                prevstring = True",
                    "-            else:",
                    "-                prevstring = False",
                    "-",
                    "-            if toknum == INDENT:",
                    "-                indents.append(tokval)",
                    "-                continue",
                    "-            elif toknum == DEDENT:",
                    "-                indents.pop()",
                    "-                continue",
                    "-            elif toknum in (NEWLINE, NL):",
                    "-                startline = True",
                    "-            elif startline and indents:",
                    "-                toks_append(indents[-1])",
                    "-                startline = False",
                    "-            toks_append(tokval)",
                    "-",
                    "-",
                    "-def untokenize(iterable):",
                    "-    \"\"\"Transform tokens back into Python source code.",
                    "-",
                    "-    Each element returned by the iterable must be a token sequence",
                    "-    with at least two elements, a token number and token value.  If",
                    "-    only two tokens are passed, the resulting output is poor.",
                    "-",
                    "-    Round-trip invariant for full input:",
                    "-        Untokenized source will match input source exactly",
                    "-",
                    "-    Round-trip invariant for limited intput::",
                    "-",
                    "-        # Output text will tokenize the back to the input",
                    "-        t1 = [tok[:2] for tok in generate_tokens(f.readline)]",
                    "-        newcode = untokenize(t1)",
                    "-        readline = iter(newcode.splitlines(1)).next",
                    "-        t2 = [tok[:2] for tok in generate_tokens(readline)]",
                    "-        if t1 != t2:",
                    "-            raise ValueError(\"t1 should be equal to t2\")",
                    "-    \"\"\"",
                    "-    ut = Untokenizer()",
                    "-    return ut.untokenize(iterable)",
                    "-",
                    "-",
                    "-def generate_tokens(readline):",
                    "-    \"\"\"",
                    "-    The generate_tokens() generator requires one argument, readline, which",
                    "-    must be a callable object which provides the same interface as the",
                    "-    readline() method of built-in file objects. Each call to the function",
                    "-    should return one line of input as a string.  Alternately, readline",
                    "-    can be a callable function terminating with StopIteration::",
                    "-",
                    "-        readline = open(myfile).next    # Example of alternate readline",
                    "-",
                    "-    The generator produces 5-tuples with these members: the token type; the",
                    "-    token string; a 2-tuple (srow, scol) of ints specifying the row and",
                    "-    column where the token begins in the source; a 2-tuple (erow, ecol) of",
                    "-    ints specifying the row and column where the token ends in the source;",
                    "-    and the line on which the token was found. The line passed is the",
                    "-    logical line; continuation lines are included.",
                    "-    \"\"\"",
                    "-    lnum = parenlev = continued = 0",
                    "-    namechars, numchars = string.ascii_letters + '_', '0123456789'",
                    "-    contstr, needcont = '', 0",
                    "-    contline = None",
                    "-    indents = [0]",
                    "-",
                    "-    while 1:                                   # loop over lines in stream",
                    "-        try:",
                    "-            line = readline()",
                    "-        except StopIteration:",
                    "-            line = ''",
                    "-        lnum = lnum + 1",
                    "-        pos, max = 0, len(line)",
                    "-",
                    "-        if contstr:                            # continued string",
                    "-            if not line:",
                    "-                raise TokenError(\"EOF in multi-line string\", strstart)",
                    "-            endmatch = endprog.match(line)",
                    "-            if endmatch:",
                    "-                pos = end = endmatch.end(0)",
                    "-                yield (STRING, contstr + line[:end],",
                    "-                       strstart, (lnum, end), contline + line)",
                    "-                contstr, needcont = '', 0",
                    "-                contline = None",
                    "-            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':",
                    "-                yield (ERRORTOKEN, contstr + line,",
                    "-                       strstart, (lnum, len(line)), contline)",
                    "-                contstr = ''",
                    "-                contline = None",
                    "-                continue",
                    "-            else:",
                    "-                contstr = contstr + line",
                    "-                contline = contline + line",
                    "-                continue",
                    "-",
                    "-        elif parenlev == 0 and not continued:  # new statement",
                    "-            if not line:",
                    "-                break",
                    "-            column = 0",
                    "-            while pos < max:                   # measure leading whitespace",
                    "-                if line[pos] == ' ':",
                    "-                    column = column + 1",
                    "-                elif line[pos] == '\\t':",
                    "-                    column = (column/tabsize + 1)*tabsize",
                    "-                elif line[pos] == '\\f':",
                    "-                    column = 0",
                    "-                else:",
                    "-                    break",
                    "-                pos = pos + 1",
                    "-            if pos == max:",
                    "-                break",
                    "-",
                    "-            if line[pos] in '#\\r\\n':           # skip comments or blank lines",
                    "-                if line[pos] == '#':",
                    "-                    comment_token = line[pos:].rstrip('\\r\\n')",
                    "-                    nl_pos = pos + len(comment_token)",
                    "-                    yield (COMMENT, comment_token,",
                    "-                           (lnum, pos), (lnum, pos + len(comment_token)), line)",
                    "-                    yield (NL, line[nl_pos:],",
                    "-                           (lnum, nl_pos), (lnum, len(line)), line)",
                    "-                else:",
                    "-                    yield ((NL, COMMENT)[line[pos] == '#'], line[pos:],",
                    "-                           (lnum, pos), (lnum, len(line)), line)",
                    "-                continue",
                    "-",
                    "-            if column > indents[-1]:           # count indents or dedents",
                    "-                indents.append(column)",
                    "-                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)",
                    "-            while column < indents[-1]:",
                    "-                if column not in indents:",
                    "-                    raise IndentationError(",
                    "-                        \"unindent does not match any outer indentation level\",",
                    "-                        (\"<tokenize>\", lnum, pos, line))",
                    "-                indents = indents[:-1]",
                    "-                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)",
                    "-",
                    "-        else:                                  # continued statement",
                    "-            if not line:",
                    "-                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))",
                    "-            continued = 0",
                    "-",
                    "-        while pos < max:",
                    "-            pseudomatch = pseudoprog.match(line, pos)",
                    "-            if pseudomatch:                                # scan for tokens",
                    "-                start, end = pseudomatch.span(1)",
                    "-                spos, epos, pos = (lnum, start), (lnum, end), end",
                    "-                token, initial = line[start:end], line[start]",
                    "-",
                    "-                if initial in numchars or \\",
                    "-                        (initial == '.' and token != '.'):      # ordinary number",
                    "-                    yield (NUMBER, token, spos, epos, line)",
                    "-                elif initial in '\\r\\n':",
                    "-                    yield (NL if parenlev > 0 else NEWLINE, token, spos, epos, line)",
                    "-                elif initial == '#':",
                    "-                    if token.endswith(\"\\n\"):",
                    "-                        raise ValueError(\"Token should not end with \\n\")",
                    "-                    yield (COMMENT, token, spos, epos, line)",
                    "-                elif token in triple_quoted:",
                    "-                    endprog = endprogs[token]",
                    "-                    endmatch = endprog.match(line, pos)",
                    "-                    if endmatch:                           # all on one line",
                    "-                        pos = endmatch.end(0)",
                    "-                        token = line[start:pos]",
                    "-                        yield (STRING, token, spos, (lnum, pos), line)",
                    "-                    else:",
                    "-                        strstart = (lnum, start)           # multiple lines",
                    "-                        contstr = line[start:]",
                    "-                        contline = line",
                    "-                        break",
                    "-                elif initial in single_quoted or \\",
                    "-                    token[:2] in single_quoted or \\",
                    "-                        token[:3] in single_quoted:",
                    "-                    if token[-1] == '\\n':                  # continued string",
                    "-                        strstart = (lnum, start)",
                    "-                        endprog = (endprogs[initial] or endprogs[token[1]] or",
                    "-                                   endprogs[token[2]])",
                    "-                        contstr, needcont = line[start:], 1",
                    "-                        contline = line",
                    "-                        break",
                    "-                    else:                                  # ordinary string",
                    "-                        yield (STRING, token, spos, epos, line)",
                    "-                elif initial in namechars:                 # ordinary name",
                    "-                    yield (NAME, token, spos, epos, line)",
                    "-                elif initial == '\\\\':                      # continued stmt",
                    "-                    continued = 1",
                    "-                else:",
                    "-                    if initial in '([{':",
                    "-                        parenlev = parenlev + 1",
                    "-                    elif initial in ')]}':",
                    "-                        parenlev = parenlev - 1",
                    "-                    yield (OP, token, spos, epos, line)",
                    "-            else:",
                    "-                yield (ERRORTOKEN, line[pos],",
                    "-                       (lnum, pos), (lnum, pos + 1), line)",
                    "-                pos = pos + 1",
                    "-",
                    "-    for indent in indents[1:]:                 # pop remaining indent levels",
                    "-        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')",
                    "-    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')",
                    "-",
                    "-if __name__ == '__main__':                     # testing",
                    "-    import sys",
                    "-    if len(sys.argv) > 1:",
                    "-        tokenize(open(sys.argv[1]).readline)",
                    "-    else:",
                    "-        tokenize(sys.stdin.readline)"
                ],
                "start_lineno": 1,
                "end_lineno": 451
            }
        ]
    },
    "django__django-15022": {
        "django/contrib/admin/options.py": [
            {
                "hunk": [
                    "+            term_queries = []"
                ],
                "start_lineno": 1034,
                "end_lineno": 1034
            },
            {
                "hunk": [
                    "-                queryset = queryset.filter(or_queries)",
                    "+                term_queries.append(or_queries)",
                    "+            queryset = queryset.filter(models.Q(*term_queries))"
                ],
                "start_lineno": 1041,
                "end_lineno": 1041
            }
        ]
    },
    "django__django-11808": {
        "django/contrib/messages/storage/base.py": [
            {
                "hunk": [
                    "-        return isinstance(other, Message) and self.level == other.level and \\",
                    "-            self.message == other.message",
                    "+        if not isinstance(other, Message):",
                    "+            return NotImplemented",
                    "+        return self.level == other.level and self.message == other.message"
                ],
                "start_lineno": 28,
                "end_lineno": 29
            }
        ],
        "django/contrib/postgres/constraints.py": [
            {
                "hunk": [
                    "-        return (",
                    "-            isinstance(other, self.__class__) and",
                    "-            self.name == other.name and",
                    "-            self.index_type == other.index_type and",
                    "-            self.expressions == other.expressions and",
                    "-            self.condition == other.condition",
                    "-        )",
                    "+        if isinstance(other, self.__class__):",
                    "+            return (",
                    "+                self.name == other.name and",
                    "+                self.index_type == other.index_type and",
                    "+                self.expressions == other.expressions and",
                    "+                self.condition == other.condition",
                    "+            )",
                    "+        return super().__eq__(other)"
                ],
                "start_lineno": 92,
                "end_lineno": 98
            }
        ],
        "django/core/validators.py": [
            {
                "hunk": [
                    "+        if not isinstance(other, self.__class__):",
                    "+            return NotImplemented",
                    "         return (",
                    "-            isinstance(other, self.__class__) and"
                ],
                "start_lineno": 327,
                "end_lineno": 328
            }
        ],
        "django/db/models/base.py": [
            {
                "hunk": [
                    "-            return False",
                    "+            return NotImplemented"
                ],
                "start_lineno": 525,
                "end_lineno": 525
            }
        ],
        "django/db/models/constraints.py": [
            {
                "hunk": [
                    "-        return (",
                    "-            isinstance(other, CheckConstraint) and",
                    "-            self.name == other.name and",
                    "-            self.check == other.check",
                    "-        )",
                    "+        if isinstance(other, CheckConstraint):",
                    "+            return self.name == other.name and self.check == other.check",
                    "+        return super().__eq__(other)"
                ],
                "start_lineno": 57,
                "end_lineno": 61
            },
            {
                "hunk": [
                    "-        return (",
                    "-            isinstance(other, UniqueConstraint) and",
                    "-            self.name == other.name and",
                    "-            self.fields == other.fields and",
                    "-            self.condition == other.condition",
                    "-        )",
                    "+        if isinstance(other, UniqueConstraint):",
                    "+            return (",
                    "+                self.name == other.name and",
                    "+                self.fields == other.fields and",
                    "+                self.condition == other.condition",
                    "+            )",
                    "+        return super().__eq__(other)"
                ],
                "start_lineno": 109,
                "end_lineno": 114
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        return isinstance(other, BaseExpression) and other.identity == self.identity",
                    "+        if not isinstance(other, BaseExpression):",
                    "+            return NotImplemented",
                    "+        return other.identity == self.identity"
                ],
                "start_lineno": 404,
                "end_lineno": 404
            }
        ],
        "django/db/models/indexes.py": [
            {
                "hunk": [
                    "-        return (self.__class__ == other.__class__) and (self.deconstruct() == other.deconstruct())",
                    "+        if self.__class__ == other.__class__:",
                    "+            return self.deconstruct() == other.deconstruct()",
                    "+        return NotImplemented"
                ],
                "start_lineno": 115,
                "end_lineno": 115
            }
        ],
        "django/db/models/query.py": [
            {
                "hunk": [
                    "-        return isinstance(other, Prefetch) and self.prefetch_to == other.prefetch_to",
                    "+        if not isinstance(other, Prefetch):",
                    "+            return NotImplemented",
                    "+        return self.prefetch_to == other.prefetch_to"
                ],
                "start_lineno": 1546,
                "end_lineno": 1546
            }
        ],
        "django/db/models/query_utils.py": [
            {
                "hunk": [
                    "+        if not isinstance(other, self.__class__):",
                    "+            return NotImplemented",
                    "         return (",
                    "-            isinstance(other, self.__class__) and"
                ],
                "start_lineno": 312,
                "end_lineno": 313
            }
        ],
        "django/template/context.py": [
            {
                "hunk": [
                    "-        return (",
                    "-            isinstance(other, BaseContext) and",
                    "-            # because dictionaries can be put in different order",
                    "-            # we have to flatten them like in templates",
                    "-            self.flatten() == other.flatten()",
                    "-        )",
                    "+        if not isinstance(other, BaseContext):",
                    "+            return NotImplemented",
                    "+        # flatten dictionaries because they can be put in a different order.",
                    "+        return self.flatten() == other.flatten()"
                ],
                "start_lineno": 127,
                "end_lineno": 132
            }
        ]
    },
    "django__django-11810": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "+import copy"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+        if self.select_related is not False:",
                    "+            # Use deepcopy because select_related stores fields in nested",
                    "+            # dicts.",
                    "+            obj.select_related = copy.deepcopy(obj.select_related)"
                ],
                "start_lineno": 327,
                "end_lineno": 327
            }
        ]
    },
    "django__django-12485": {
        "django/http/multipartparser.py": [
            {
                "hunk": [
                    "-            if has_encoding:",
                    "-                encoding, lang, value = value.split(b\"'\")",
                    "-                value = unquote(value.decode(), encoding=encoding.decode())",
                    "             if len(value) >= 2 and value[:1] == value[-1:] == b'\"':",
                    "                 value = value[1:-1]",
                    "                 value = value.replace(b'\\\\\\\\', b'\\\\').replace(b'\\\\\"', b'\"')",
                    "+            if has_encoding:",
                    "+                encoding, lang, value = value.split(b\"'\")",
                    "+                value = unquote(value.decode(), encoding=encoding.decode())"
                ],
                "start_lineno": 667,
                "end_lineno": 672
            }
        ]
    },
    "psf__requests-3718": {
        "requests/models.py": [
            {
                "hunk": [
                    "-            if self.status_code == 0:",
                    "+            if self.status_code == 0 or self.raw is None:"
                ],
                "start_lineno": 772,
                "end_lineno": 772
            }
        ]
    },
    "pytest-dev__pytest-7500": {
        "src/_pytest/pathlib.py": [
            {
                "hunk": [
                    "-    \"\"\"checks if a lock exists and breaks it if its considered dead\"\"\"",
                    "+    \"\"\"checks if `path` is deletable based on whether the lock file is expired\"\"\"",
                    "     if path.is_symlink():",
                    "         return False",
                    "     lock = get_lock_path(path)",
                    "-    if not lock.exists():",
                    "-        return True",
                    "+    try:",
                    "+        if not lock.is_file():",
                    "+            return True",
                    "+    except OSError:",
                    "+        # we might not have access to the lock file at all, in this case assume",
                    "+        # we don't have access to the entire directory (#7491).",
                    "+        return False"
                ],
                "start_lineno": 289,
                "end_lineno": 294
            }
        ]
    },
    "django__django-15380": {
        "django/db/migrations/autodetector.py": [
            {
                "hunk": [
                    "-            new_model_state = self.to_state.models[app_label, old_model_name]",
                    "+            new_model_state = self.to_state.models[app_label, model_name]"
                ],
                "start_lineno": 827,
                "end_lineno": 827
            }
        ]
    },
    "sympy__sympy-11400": {
        "sympy/printing/ccode.py": [
            {
                "hunk": [
                    "+    def _print_Relational(self, expr):",
                    "+        lhs_code = self._print(expr.lhs)",
                    "+        rhs_code = self._print(expr.rhs)",
                    "+        op = expr.rel_op",
                    "+        return (\"{0} {1} {2}\").format(lhs_code, op, rhs_code)",
                    "+",
                    "+    def _print_sinc(self, expr):",
                    "+        from sympy.functions.elementary.trigonometric import sin",
                    "+        from sympy.core.relational import Ne",
                    "+        from sympy.functions import Piecewise",
                    "+        _piecewise = Piecewise(",
                    "+            (sin(expr.args[0]) / expr.args[0], Ne(expr.args[0], 0)), (1, True))",
                    "+        return self._print(_piecewise)",
                    "+"
                ],
                "start_lineno": 234,
                "end_lineno": 234
            }
        ]
    },
    "scikit-learn__scikit-learn-25672": {
        "sklearn/metrics/_ranking.py": [
            {
                "hunk": [
                    "-            \"ndcg_score should not be used on negative y_true values. ndcg_score will\"",
                    "-            \" raise a ValueError on negative y_true values starting from version 1.4.\",",
                    "+            \"ndcg_score should not be used on negative y_true values. ndcg_score\"",
                    "+            \" will raise a ValueError on negative y_true values starting from\"",
                    "+            \" version 1.4.\",",
                    "             FutureWarning,",
                    "         )",
                    "+    if y_true.ndim > 1 and y_true.shape[1] <= 1:",
                    "+        raise ValueError(",
                    "+            \"Computing NDCG is only meaningful when there is more than 1 document. \"",
                    "+            f\"Got {y_true.shape[1]} instead.\"",
                    "+        )"
                ],
                "start_lineno": 1736,
                "end_lineno": 1739
            }
        ]
    },
    "pytest-dev__pytest-8447": {
        "src/_pytest/main.py": [
            {
                "hunk": [
                    "-        session: Session = cls._create(config)",
                    "+        session: Session = cls._create(config=config)"
                ],
                "start_lineno": 487,
                "end_lineno": 487
            }
        ],
        "src/_pytest/nodes.py": [
            {
                "hunk": [
                    "+from inspect import signature",
                    " from pathlib import Path",
                    " from typing import Any",
                    " from typing import Callable",
                    "+from typing import cast"
                ],
                "start_lineno": 3,
                "end_lineno": 5
            },
            {
                "hunk": [
                    "+from _pytest.warning_types import PytestWarning"
                ],
                "start_lineno": 37,
                "end_lineno": 37
            },
            {
                "hunk": [
                    "-        return super().__call__(*k, **kw)",
                    "+        try:",
                    "+            return super().__call__(*k, **kw)",
                    "+        except TypeError:",
                    "+            sig = signature(getattr(self, \"__init__\"))",
                    "+            known_kw = {k: v for k, v in kw.items() if k in sig.parameters}",
                    "+            from .warning_types import PytestDeprecationWarning",
                    "+",
                    "+            warnings.warn(",
                    "+                PytestDeprecationWarning(",
                    "+                    f\"{self} is not using a cooperative constructor and only takes {set(known_kw)}\"",
                    "+                )",
                    "+            )",
                    "+",
                    "+            return super().__call__(*k, **known_kw)"
                ],
                "start_lineno": 128,
                "end_lineno": 128
            },
            {
                "hunk": [
                    "-        fspath: Optional[LEGACY_PATH],",
                    "-        path: Optional[Path],",
                    "-        parent=None,",
                    "+        fspath: Optional[LEGACY_PATH] = None,",
                    "+        path_or_parent: Optional[Union[Path, Node]] = None,",
                    "+        path: Optional[Path] = None,",
                    "+        name: Optional[str] = None,",
                    "+        parent: Optional[Node] = None,",
                    "         config: Optional[Config] = None,",
                    "         session: Optional[\"Session\"] = None,",
                    "         nodeid: Optional[str] = None,",
                    "     ) -> None:",
                    "+        if path_or_parent:",
                    "+            if isinstance(path_or_parent, Node):",
                    "+                assert parent is None",
                    "+                parent = cast(FSCollector, path_or_parent)",
                    "+            elif isinstance(path_or_parent, Path):",
                    "+                assert path is None",
                    "+                path = path_or_parent",
                    "+",
                    "         path, fspath = _imply_path(path, fspath=fspath)",
                    "-        name = path.name",
                    "-        if parent is not None and parent.path != path:",
                    "-            try:",
                    "-                rel = path.relative_to(parent.path)",
                    "-            except ValueError:",
                    "-                pass",
                    "-            else:",
                    "-                name = str(rel)",
                    "-            name = name.replace(os.sep, SEP)",
                    "+        if name is None:",
                    "+            name = path.name",
                    "+            if parent is not None and parent.path != path:",
                    "+                try:",
                    "+                    rel = path.relative_to(parent.path)",
                    "+                except ValueError:",
                    "+                    pass",
                    "+                else:",
                    "+                    name = str(rel)",
                    "+                name = name.replace(os.sep, SEP)",
                    "         self.path = path",
                    " ",
                    "-        session = session or parent.session",
                    "+        if session is None:",
                    "+            assert parent is not None",
                    "+            session = parent.session"
                ],
                "start_lineno": 542,
                "end_lineno": 561
            },
            {
                "hunk": [
                    "-            name, parent, config, session, nodeid=nodeid, fspath=fspath, path=path",
                    "+            name=name,",
                    "+            parent=parent,",
                    "+            config=config,",
                    "+            session=session,",
                    "+            nodeid=nodeid,",
                    "+            path=path,"
                ],
                "start_lineno": 573,
                "end_lineno": 573
            },
            {
                "hunk": [
                    "+    def __init_subclass__(cls) -> None:",
                    "+        problems = \", \".join(",
                    "+            base.__name__ for base in cls.__bases__ if issubclass(base, Collector)",
                    "+        )",
                    "+        if problems:",
                    "+            warnings.warn(",
                    "+                f\"{cls.__name__} is an Item subclass and should not be a collector, \"",
                    "+                f\"however its bases {problems} are collectors.\\n\"",
                    "+                \"Please split the Collectors and the Item into separate node types.\\n\"",
                    "+                \"Pytest Doc example: https://docs.pytest.org/en/latest/example/nonpython.html\\n\"",
                    "+                \"example pull request on a plugin: https://github.com/asmeurer/pytest-flakes/pull/40/\",",
                    "+                PytestWarning,",
                    "+            )",
                    "+"
                ],
                "start_lineno": 613,
                "end_lineno": 613
            },
            {
                "hunk": [
                    "+        **kw,",
                    "     ) -> None:",
                    "-        super().__init__(name, parent, config, session, nodeid=nodeid)",
                    "+        super().__init__(",
                    "+            name=name,",
                    "+            parent=parent,",
                    "+            config=config,",
                    "+            session=session,",
                    "+            nodeid=nodeid,",
                    "+            **kw,",
                    "+        )"
                ],
                "start_lineno": 620,
                "end_lineno": 621
            }
        ]
    },
    "matplotlib__matplotlib-19553": {
        "lib/matplotlib/cm.py": [
            {
                "hunk": [
                    "-        self.norm = None  # So that the setter knows we're initializing.",
                    "+        self._norm = None  # So that the setter knows we're initializing."
                ],
                "start_lineno": 340,
                "end_lineno": 340
            },
            {
                "hunk": [
                    "+        # If the norm's limits are updated self.changed() will be called",
                    "+        # through the callbacks attached to the norm"
                ],
                "start_lineno": 499,
                "end_lineno": 499
            },
            {
                "hunk": [
                    "-        self.changed()"
                ],
                "start_lineno": 508,
                "end_lineno": 508
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def norm(self):",
                    "+        return self._norm",
                    "+",
                    "+    @norm.setter",
                    "+    def norm(self, norm):",
                    "+        _api.check_isinstance((colors.Normalize, None), norm=norm)",
                    "+        if norm is None:",
                    "+            norm = colors.Normalize()",
                    "+",
                    "+        if norm is self.norm:",
                    "+            # We aren't updating anything",
                    "+            return",
                    "+",
                    "+        in_init = self.norm is None",
                    "+        # Remove the current callback and connect to the new one",
                    "+        if not in_init:",
                    "+            self.norm.callbacks.disconnect(self._id_norm)",
                    "+        self._norm = norm",
                    "+        self._id_norm = self.norm.callbacks.connect('changed',",
                    "+                                                    self.changed)",
                    "+        if not in_init:",
                    "+            self.changed()",
                    "+"
                ],
                "start_lineno": 534,
                "end_lineno": 534
            },
            {
                "hunk": [
                    "-        _api.check_isinstance((colors.Normalize, None), norm=norm)",
                    "-        in_init = self.norm is None",
                    "-        if norm is None:",
                    "-            norm = colors.Normalize()",
                    "         self.norm = norm",
                    "-        if not in_init:",
                    "-            self.changed()  # Things are not set up properly yet."
                ],
                "start_lineno": 548,
                "end_lineno": 554
            },
            {
                "hunk": [
                    "+        # If the norm's limits are updated self.changed() will be called",
                    "+        # through the callbacks attached to the norm",
                    "         self.norm.autoscale(self._A)",
                    "-        self.changed()"
                ],
                "start_lineno": 563,
                "end_lineno": 564
            },
            {
                "hunk": [
                    "+        # If the norm's limits are updated self.changed() will be called",
                    "+        # through the callbacks attached to the norm",
                    "         self.norm.autoscale_None(self._A)",
                    "-        self.changed()"
                ],
                "start_lineno": 573,
                "end_lineno": 574
            }
        ],
        "lib/matplotlib/colorbar.py": [
            {
                "hunk": [
                    "+        self.minorlocator = None"
                ],
                "start_lineno": 474,
                "end_lineno": 474
            },
            {
                "hunk": [
                    "-        norm = copy.copy(self.norm)",
                    "+        norm = copy.deepcopy(self.norm)"
                ],
                "start_lineno": 1099,
                "end_lineno": 1099
            }
        ],
        "lib/matplotlib/colors.py": [
            {
                "hunk": [
                    "-        self.vmin = _sanitize_extrema(vmin)",
                    "-        self.vmax = _sanitize_extrema(vmax)",
                    "-        self.clip = clip",
                    "-        self._scale = None  # will default to LinearScale for colorbar",
                    "+        self._vmin = _sanitize_extrema(vmin)",
                    "+        self._vmax = _sanitize_extrema(vmax)",
                    "+        self._clip = clip",
                    "+        self._scale = None",
                    "+        self.callbacks = cbook.CallbackRegistry()",
                    "+",
                    "+    @property",
                    "+    def vmin(self):",
                    "+        return self._vmin",
                    "+",
                    "+    @vmin.setter",
                    "+    def vmin(self, value):",
                    "+        value = _sanitize_extrema(value)",
                    "+        if value != self._vmin:",
                    "+            self._vmin = value",
                    "+            self._changed()",
                    "+",
                    "+    @property",
                    "+    def vmax(self):",
                    "+        return self._vmax",
                    "+",
                    "+    @vmax.setter",
                    "+    def vmax(self, value):",
                    "+        value = _sanitize_extrema(value)",
                    "+        if value != self._vmax:",
                    "+            self._vmax = value",
                    "+            self._changed()",
                    "+",
                    "+    @property",
                    "+    def clip(self):",
                    "+        return self._clip",
                    "+",
                    "+    @clip.setter",
                    "+    def clip(self, value):",
                    "+        if value != self._clip:",
                    "+            self._clip = value",
                    "+            self._changed()",
                    "+",
                    "+    def _changed(self):",
                    "+        \"\"\"",
                    "+        Call this whenever the norm is changed to notify all the",
                    "+        callback listeners to the 'changed' signal.",
                    "+        \"\"\"",
                    "+        self.callbacks.process('changed')"
                ],
                "start_lineno": 1126,
                "end_lineno": 1129
            },
            {
                "hunk": [
                    "-        self.vcenter = vcenter",
                    "+        self._vcenter = vcenter"
                ],
                "start_lineno": 1276,
                "end_lineno": 1276
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def vcenter(self):",
                    "+        return self._vcenter",
                    "+",
                    "+    @vcenter.setter",
                    "+    def vcenter(self, value):",
                    "+        if value != self._vcenter:",
                    "+            self._vcenter = value",
                    "+            self._changed()",
                    "+"
                ],
                "start_lineno": 1284,
                "end_lineno": 1284
            },
            {
                "hunk": [
                    "-        self._vcenter = vcenter",
                    "+        if vcenter != self._vcenter:",
                    "+            self._vcenter = vcenter",
                    "+            self._changed()"
                ],
                "start_lineno": 1390,
                "end_lineno": 1390
            }
        ],
        "lib/matplotlib/contour.py": [
            {
                "hunk": [
                    "+        if not hasattr(self, \"cvalues\"):",
                    "+            # Just return after calling the super() changed function",
                    "+            cm.ScalarMappable.changed(self)",
                    "+            return",
                    "+        # Force an autoscale immediately because self.to_rgba() calls",
                    "+        # autoscale_None() internally with the data passed to it,",
                    "+        # so if vmin/vmax are not set yet, this would override them with",
                    "+        # content from *cvalues* rather than levels like we want",
                    "+        self.norm.autoscale_None(self.levels)"
                ],
                "start_lineno": 1093,
                "end_lineno": 1093
            }
        ],
        "lib/matplotlib/image.py": [
            {
                "hunk": [
                    "-                with cbook._setattr_cm(self.norm,",
                    "-                                       vmin=s_vmin,",
                    "-                                       vmax=s_vmax,",
                    "-                                       ):",
                    "-                    output = self.norm(resampled_masked)",
                    "+                # Block the norm from sending an update signal during the",
                    "+                # temporary vmin/vmax change",
                    "+                with self.norm.callbacks.blocked():",
                    "+                    with cbook._setattr_cm(self.norm,",
                    "+                                           vmin=s_vmin,",
                    "+                                           vmax=s_vmax,",
                    "+                                           ):",
                    "+                        output = self.norm(resampled_masked)"
                ],
                "start_lineno": 540,
                "end_lineno": 544
            }
        ]
    },
    "django__django-13431": {
        "django/db/models/query.py": [
            {
                "hunk": [
                    "-from django.db.models.expressions import Case, Expression, F, Value, When",
                    "+from django.db.models.expressions import Case, Expression, F, Ref, Value, When"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-            if not query.annotations[alias].contains_aggregate:",
                    "+            annotation = query.annotations[alias]",
                    "+            if not annotation.contains_aggregate:",
                    "                 raise TypeError(\"%s is not an aggregate expression\" % alias)",
                    "+            for expr in annotation.get_source_expressions():",
                    "+                if expr.contains_aggregate and isinstance(expr, Ref) and expr.refs in kwargs:",
                    "+                    name = expr.refs",
                    "+                    raise exceptions.FieldError(",
                    "+                        \"Cannot compute %s('%s'): '%s' is an aggregate\"",
                    "+                        % (annotation.name, name, name)",
                    "+                    )"
                ],
                "start_lineno": 389,
                "end_lineno": 390
            }
        ]
    },
    "matplotlib__matplotlib-25346": {
        "lib/matplotlib/text.py": [
            {
                "hunk": [
                    "-        lines = self.get_text().split(\"\\n\")  # Ensures lines is not empty.",
                    "+        lines = self._get_wrapped_text().split(\"\\n\")  # Ensures lines is not empty."
                ],
                "start_lineno": 370,
                "end_lineno": 370
            }
        ]
    },
    "sympy__sympy-21596": {
        "sympy/sets/handlers/intersection.py": [
            {
                "hunk": [
                    "-",
                    "+from sympy.simplify.radsimp import numer"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "+",
                    "+        def _solution_union(exprs, sym):",
                    "+            # return a union of linear solutions to i in expr;",
                    "+            # if i cannot be solved, use a ConditionSet for solution",
                    "+            sols = []",
                    "+            for i in exprs:",
                    "+                x, xis = solve_linear(i, 0, [sym])",
                    "+                if x == sym:",
                    "+                    sols.append(FiniteSet(xis))",
                    "+                else:",
                    "+                    sols.append(ConditionSet(sym, Eq(i, 0)))",
                    "+            return Union(*sols)",
                    "+"
                ],
                "start_lineno": 283,
                "end_lineno": 283
            },
            {
                "hunk": [
                    "-            # univarite imaginary part in same variable",
                    "-            x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])",
                    "-            if x and all(i == n for i in x):",
                    "-                base_set -= FiniteSet(xis)",
                    "-            else:",
                    "-                base_set -= ConditionSet(n, Eq(im, 0), S.Integers)",
                    "+            # univarite imaginary part in same variable;",
                    "+            # use numer instead of as_numer_denom to keep",
                    "+            # this as fast as possible while still handling",
                    "+            # simple cases",
                    "+            base_set &= _solution_union(",
                    "+                Mul.make_args(numer(im)), n)",
                    "         # exclude values that make denominators 0",
                    "-        for i in denoms(f):",
                    "-            if i.has(n):",
                    "-                sol = list(zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]))",
                    "-                if sol != []:",
                    "-                    x, xis = sol",
                    "-                    if x and all(i == n for i in x):",
                    "-                        base_set -= FiniteSet(xis)",
                    "-                else:",
                    "-                    base_set -= ConditionSet(n, Eq(i, 0), S.Integers)",
                    "+        base_set -= _solution_union(denoms(f), n)"
                ],
                "start_lineno": 306,
                "end_lineno": 321
            }
        ]
    },
    "astropy__astropy-7737": {
        "astropy/stats/biweight.py": [
            {
                "hunk": [
                    "+",
                    "+    if axis is None and mad == 0.:",
                    "+        return M  # return median if data is a constant array",
                    "+",
                    "     if axis is not None:",
                    "         mad = np.expand_dims(mad, axis=axis)",
                    "+        const_mask = (mad == 0.)",
                    "+        mad[const_mask] = 1.  # prevent divide by zero",
                    "+"
                ],
                "start_lineno": 105,
                "end_lineno": 106
            },
            {
                "hunk": [
                    "+    # along the input axis if data is constant, d will be zero, thus",
                    "+    # the median value will be returned along that axis"
                ],
                "start_lineno": 114,
                "end_lineno": 114
            },
            {
                "hunk": [
                    "+",
                    "+    if axis is None and mad == 0.:",
                    "+        return 0.  # return zero if data is a constant array",
                    "+",
                    "     if axis is not None:",
                    "         mad = np.expand_dims(mad, axis=axis)",
                    "+        const_mask = (mad == 0.)",
                    "+        mad[const_mask] = 1.  # prevent divide by zero",
                    "+"
                ],
                "start_lineno": 339,
                "end_lineno": 340
            },
            {
                "hunk": [
                    "+",
                    "+    const_mask = (mad == 0.)",
                    "+    mad[const_mask] = 1.  # prevent divide by zero",
                    "+"
                ],
                "start_lineno": 533,
                "end_lineno": 533
            }
        ]
    },
    "django__django-13791": {
        "django/utils/dateparse.py": [
            {
                "hunk": [
                    "+        if match.re == iso8601_duration_re:",
                    "+            days *= sign"
                ],
                "start_lineno": 147,
                "end_lineno": 147
            }
        ]
    },
    "sympy__sympy-18057": {
        "sympy/core/expr.py": [
            {
                "hunk": [
                    "-            other = sympify(other)",
                    "+            other = _sympify(other)"
                ],
                "start_lineno": 124,
                "end_lineno": 124
            }
        ]
    },
    "django__django-13162": {
        "django/core/management/commands/makemigrations.py": [
            {
                "hunk": [
                    "-                migration_name = \"%04i_%s\" % (",
                    "-                    biggest_number + 1,",
                    "-                    self.migration_name or (\"merge_%s\" % get_migration_name_timestamp())",
                    "-                )",
                    "+                parts = ['%04i' % (biggest_number + 1)]",
                    "+                if self.migration_name:",
                    "+                    parts.append(self.migration_name)",
                    "+                else:",
                    "+                    parts.append('merge')",
                    "+                    leaf_names = '_'.join(sorted(migration.name for migration in merge_migrations))",
                    "+                    if len(leaf_names) > 47:",
                    "+                        parts.append(get_migration_name_timestamp())",
                    "+                    else:",
                    "+                        parts.append(leaf_names)",
                    "+                migration_name = '_'.join(parts)"
                ],
                "start_lineno": 298,
                "end_lineno": 301
            }
        ]
    },
    "django__django-11354": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):",
                    "+        # Resolve parents fields used in raw SQL.",
                    "+        for parent in query.model._meta.get_parent_list():",
                    "+            for parent_field in parent._meta.local_fields:",
                    "+                _, column_name = parent_field.get_attname_column()",
                    "+                if column_name.lower() in self.sql.lower():",
                    "+                    query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)",
                    "+                    break",
                    "+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)",
                    "+"
                ],
                "start_lineno": 702,
                "end_lineno": 702
            }
        ]
    },
    "django__django-13822": {
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "-            self.remote_field.related_name = \"_%s_%s_+\" % (cls.__name__.lower(), name)",
                    "+            self.remote_field.related_name = '_%s_%s_%s_+' % (",
                    "+                cls._meta.app_label,",
                    "+                cls.__name__.lower(),",
                    "+                name,",
                    "+            )"
                ],
                "start_lineno": 1617,
                "end_lineno": 1617
            }
        ]
    },
    "pytest-dev__pytest-7499": {
        "src/_pytest/_code/code.py": [
            {
                "hunk": [
                    "-        assert re.search(",
                    "-            regexp, str(self.value)",
                    "-        ), \"Pattern {!r} does not match {!r}\".format(regexp, str(self.value))",
                    "+        msg = \"Regex pattern {!r} does not match {!r}.\"",
                    "+        if regexp == str(self.value):",
                    "+            msg += \" Did you mean to `re.escape()` the regex?\"",
                    "+        assert re.search(regexp, str(self.value)), msg.format(regexp, str(self.value))"
                ],
                "start_lineno": 612,
                "end_lineno": 614
            }
        ]
    },
    "django__django-10924": {
        "django/db/models/fields/__init__.py": [
            {
                "hunk": [
                    "-            'path': self.path,",
                    "+            'path': self.path() if callable(self.path) else self.path,"
                ],
                "start_lineno": 1712,
                "end_lineno": 1712
            }
        ]
    },
    "django__django-14016": {
        "django/db/models/query_utils.py": [
            {
                "hunk": [
                    "-import copy"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-            return copy.deepcopy(self)",
                    "+            _, args, kwargs = self.deconstruct()",
                    "+            return type(self)(*args, **kwargs)",
                    "         # Or if this Q is empty, ignore it and just use `other`.",
                    "         elif not self:",
                    "-            return copy.deepcopy(other)",
                    "+            _, args, kwargs = other.deconstruct()",
                    "+            return type(other)(*args, **kwargs)"
                ],
                "start_lineno": 49,
                "end_lineno": 52
            }
        ]
    },
    "sympy__sympy-15685": {
        "sympy/physics/units/definitions.py": [
            {
                "hunk": [
                    "-# gram; used to define its prefixed units",
                    "-g = gram = grams = Quantity(\"gram\", abbrev=\"g\")",
                    "-gram.set_dimension(mass)",
                    "-gram.set_scale_factor(One)",
                    "-",
                    "-# NOTE: the `kilogram` has scale factor 1000. In SI, kg is a base unit, but",
                    "-# nonetheless we are trying to be compatible with the `kilo` prefix. In a",
                    "-# similar manner, people using CGS or gaussian units could argue that the",
                    "-# `centimeter` rather than `meter` is the fundamental unit for length, but the",
                    "-# scale factor of `centimeter` will be kept as 1/100 to be compatible with the",
                    "-# `centi` prefix.  The current state of the code assumes SI unit dimensions, in",
                    "+# NOTE: the `kilogram` has scale factor of 1 in SI.",
                    "+# The current state of the code assumes SI unit dimensions, in",
                    " # the future this module will be modified in order to be unit system-neutral",
                    " # (that is, support all kinds of unit systems).",
                    " kg = kilogram = kilograms = Quantity(\"kilogram\", abbrev=\"kg\")",
                    " kilogram.set_dimension(mass)",
                    "-kilogram.set_scale_factor(kilo*gram)",
                    "+kilogram.set_scale_factor(One)"
                ],
                "start_lineno": 53,
                "end_lineno": 68
            },
            {
                "hunk": [
                    "+g = gram = grams = Quantity(\"gram\", abbrev=\"g\")",
                    "+gram.set_dimension(mass)",
                    "+gram.set_scale_factor(kilogram/kilo)"
                ],
                "start_lineno": 90,
                "end_lineno": 90
            }
        ]
    },
    "sympy__sympy-16906": {
        "sympy/matrices/expressions/hadamard.py": [
            {
                "hunk": [
                    "-    A.*OneMatrix(2, 2)",
                    "+    A.*1"
                ],
                "start_lineno": 177,
                "end_lineno": 177
            }
        ],
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-    def _print_MatrixSymbol(self, expr):",
                    "-        return self._print_Symbol(expr,",
                    "-                                  style=self._settings['mat_symbol_style'])",
                    "-"
                ],
                "start_lineno": 1411,
                "end_lineno": 1414
            },
            {
                "hunk": [
                    "+    def _print_MatrixSymbol(self, expr):",
                    "+        return self._print_Symbol(expr, style=self._settings[",
                    "+            'mat_symbol_style'])",
                    "+",
                    "     def _print_ZeroMatrix(self, Z):",
                    "-        return r\"\\mathbb{0}\"",
                    "+        return r\"\\mathbb{0}\" if self._settings[",
                    "+            'mat_symbol_style'] == 'plain' else r\"\\mathbf{0}\"",
                    " ",
                    "     def _print_OneMatrix(self, O):",
                    "-        return r\"\\mathbb{1}\"",
                    "+        return r\"\\mathbb{1}\" if self._settings[",
                    "+            'mat_symbol_style'] == 'plain' else r\"\\mathbf{1}\"",
                    " ",
                    "     def _print_Identity(self, I):",
                    "-        return r\"\\mathbb{I}\"",
                    "+        return r\"\\mathbb{I}\" if self._settings[",
                    "+            'mat_symbol_style'] == 'plain' else r\"\\mathbf{I}\""
                ],
                "start_lineno": 1597,
                "end_lineno": 1604
            }
        ],
        "sympy/printing/mathml.py": [
            {
                "hunk": [
                    "+    def _print_OneMatrix(self, Z):",
                    "+        x = self.dom.createElement('mn')",
                    "+        x.appendChild(self.dom.createTextNode('&#x1D7D9'))",
                    "+        return x",
                    "+"
                ],
                "start_lineno": 1687,
                "end_lineno": 1687
            }
        ],
        "sympy/printing/pretty/pretty.py": [
            {
                "hunk": [
                    "+    def _print_Identity(self, expr):",
                    "+        if self._use_unicode:",
                    "+            return prettyForm(u'\\N{MATHEMATICAL DOUBLE-STRUCK CAPITAL I}')",
                    "+        else:",
                    "+            return prettyForm('I')",
                    "+",
                    "+    def _print_ZeroMatrix(self, expr):",
                    "+        if self._use_unicode:",
                    "+            return prettyForm(u'\\N{MATHEMATICAL DOUBLE-STRUCK DIGIT ZERO}')",
                    "+        else:",
                    "+            return prettyForm('0')",
                    "+",
                    "+    def _print_OneMatrix(self, expr):",
                    "+        if self._use_unicode:",
                    "+            return prettyForm(u'\\N{MATHEMATICAL DOUBLE-STRUCK DIGIT ONE}')",
                    "+        else:",
                    "+            return prettyForm('1')",
                    "+"
                ],
                "start_lineno": 848,
                "end_lineno": 848
            }
        ],
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "+    def _print_OneMatrix(self, expr):",
                    "+        return \"1\"",
                    "+"
                ],
                "start_lineno": 726,
                "end_lineno": 726
            }
        ]
    },
    "django__django-11848": {
        "django/utils/http.py": [
            {
                "hunk": [
                    "-            if year < 70:",
                    "-                year += 2000",
                    "+            current_year = datetime.datetime.utcnow().year",
                    "+            current_century = current_year - (current_year % 100)",
                    "+            if year - (current_year % 100) > 50:",
                    "+                # year that appears to be more than 50 years in the future are",
                    "+                # interpreted as representing the past.",
                    "+                year += current_century - 100",
                    "             else:",
                    "-                year += 1900",
                    "+                year += current_century"
                ],
                "start_lineno": 179,
                "end_lineno": 182
            }
        ]
    },
    "pytest-dev__pytest-5479": {
        "src/_pytest/_code/code.py": [
            {
                "hunk": [
                    "-        if not re.search(regexp, str(self.value)):",
                    "-            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)",
                    "+        value = (",
                    "+            text_type(self.value) if isinstance(regexp, text_type) else str(self.value)",
                    "+        )",
                    "+        if not re.search(regexp, value):",
                    "+            raise AssertionError(",
                    "+                u\"Pattern {!r} not found in {!r}\".format(regexp, value)",
                    "+            )"
                ],
                "start_lineno": 575,
                "end_lineno": 576
            }
        ]
    },
    "django__django-12039": {
        "django/db/backends/ddl_references.py": [
            {
                "hunk": [
                    "+            col = self.quote_name(column)",
                    "             try:",
                    "-                return self.quote_name(column) + self.col_suffixes[idx]",
                    "+                suffix = self.col_suffixes[idx]",
                    "+                if suffix:",
                    "+                    col = '{} {}'.format(col, suffix)",
                    "             except IndexError:",
                    "-                return self.quote_name(column)",
                    "+                pass",
                    "+            return col"
                ],
                "start_lineno": 86,
                "end_lineno": 89
            },
            {
                "hunk": [
                    "-                col = '{} {}'.format(col, self.col_suffixes[idx])",
                    "+                suffix = self.col_suffixes[idx]",
                    "+                if suffix:",
                    "+                    col = '{} {}'.format(col, suffix)"
                ],
                "start_lineno": 117,
                "end_lineno": 117
            }
        ]
    },
    "django__django-12519": {
        "django/db/backends/mysql/base.py": [
            {
                "hunk": [
                    "+",
                    "+    @cached_property",
                    "+    def sql_mode(self):",
                    "+        with self.cursor() as cursor:",
                    "+            cursor.execute('SELECT @@sql_mode')",
                    "+            sql_mode = cursor.fetchone()",
                    "+        return set(sql_mode[0].split(',') if sql_mode else ())"
                ],
                "start_lineno": 367,
                "end_lineno": 367
            }
        ],
        "django/db/backends/mysql/validation.py": [
            {
                "hunk": [
                    "-        with self.connection.cursor() as cursor:",
                    "-            cursor.execute(\"SELECT @@sql_mode\")",
                    "-            sql_mode = cursor.fetchone()",
                    "-        modes = set(sql_mode[0].split(',') if sql_mode else ())",
                    "-        if not (modes & {'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES'}):",
                    "+        if not (self.connection.sql_mode & {'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES'}):"
                ],
                "start_lineno": 13,
                "end_lineno": 17
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+from django.db.models.constants import LOOKUP_SEP"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+    def resolve_expression(self, *args, **kwargs):",
                    "+        col = super().resolve_expression(*args, **kwargs)",
                    "+        # FIXME: Rename possibly_multivalued to multivalued and fix detection",
                    "+        # for non-multivalued JOINs (e.g. foreign key fields). This should take",
                    "+        # into account\u00a0only many-to-many and one-to-many relationships.",
                    "+        col.possibly_multivalued = LOOKUP_SEP in self.name",
                    "+        return col",
                    "+"
                ],
                "start_lineno": 562,
                "end_lineno": 562
            },
            {
                "hunk": [
                    "+    possibly_multivalued = False"
                ],
                "start_lineno": 750,
                "end_lineno": 750
            },
            {
                "hunk": [
                    "-        return self.query.get_external_cols()",
                    "+        external_cols = self.query.get_external_cols()",
                    "+        if any(col.possibly_multivalued for col in external_cols):",
                    "+            return [self]",
                    "+        return external_cols"
                ],
                "start_lineno": 1045,
                "end_lineno": 1045
            }
        ]
    },
    "sympy__sympy-21849": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-    def _print_LambertW(self, expr):",
                    "+    def _print_LambertW(self, expr, exp=None):",
                    "+        arg0 = self._print(expr.args[0])",
                    "+        exp = r\"^{%s}\" % (exp,) if exp is not None else \"\"",
                    "         if len(expr.args) == 1:",
                    "-            return r\"W\\left(%s\\right)\" % self._print(expr.args[0])",
                    "-        return r\"W_{%s}\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]))",
                    "+            result = r\"W%s\\left(%s\\right)\" % (exp, arg0)",
                    "+        else:",
                    "+            arg1 = self._print(expr.args[1])",
                    "+            result = \"W{0}_{{{1}}}\\\\left({2}\\\\right)\".format(exp, arg1, arg0)",
                    "+        return result"
                ],
                "start_lineno": 2425,
                "end_lineno": 2429
            }
        ]
    },
    "django__django-13722": {
        "django/contrib/admin/options.py": [
            {
                "hunk": [
                    "+    def get_formset_kwargs(self, request, obj, inline, prefix):",
                    "+        formset_params = {",
                    "+            'instance': obj,",
                    "+            'prefix': prefix,",
                    "+            'queryset': inline.get_queryset(request),",
                    "+        }",
                    "+        if request.method == 'POST':",
                    "+            formset_params.update({",
                    "+                'data': request.POST.copy(),",
                    "+                'files': request.FILES,",
                    "+                'save_as_new': '_saveasnew' in request.POST",
                    "+            })",
                    "+        return formset_params",
                    "+"
                ],
                "start_lineno": 1949,
                "end_lineno": 1949
            },
            {
                "hunk": [
                    "-            formset_params = {",
                    "-                'instance': obj,",
                    "-                'prefix': prefix,",
                    "-                'queryset': inline.get_queryset(request),",
                    "-            }",
                    "-            if request.method == 'POST':",
                    "-                formset_params.update({",
                    "-                    'data': request.POST.copy(),",
                    "-                    'files': request.FILES,",
                    "-                    'save_as_new': '_saveasnew' in request.POST",
                    "-                })",
                    "+            formset_params = self.get_formset_kwargs(request, obj, inline, prefix)"
                ],
                "start_lineno": 1962,
                "end_lineno": 1972
            }
        ]
    },
    "sympy__sympy-21527": {
        "sympy/polys/constructor.py": [
            {
                "hunk": [
                    "-            if is_algebraic(coeff):",
                    "+            elif is_algebraic(coeff):"
                ],
                "start_lineno": 51,
                "end_lineno": 51
            }
        ],
        "sympy/polys/matrices/ddm.py": [
            {
                "hunk": [
                    "-        pivots = ddm_irref(b)",
                    "+        K = a.domain",
                    "+        partial_pivot = K.is_RealField or K.is_ComplexField",
                    "+        pivots = ddm_irref(b, _partial_pivot=partial_pivot)"
                ],
                "start_lineno": 287,
                "end_lineno": 287
            }
        ],
        "sympy/polys/matrices/dense.py": [
            {
                "hunk": [
                    "-def ddm_irref(a):",
                    "+def ddm_irref(a, _partial_pivot=False):"
                ],
                "start_lineno": 88,
                "end_lineno": 88
            },
            {
                "hunk": [
                    "+        # Proper pivoting should be used for all domains for performance",
                    "+        # reasons but it is only strictly needed for RR and CC (and possibly",
                    "+        # other domains like RR(x)). This path is used by DDM.rref() if the",
                    "+        # domain is RR or CC. It uses partial (row) pivoting based on the",
                    "+        # absolute value of the pivot candidates.",
                    "+        if _partial_pivot:",
                    "+            ip = max(range(i, m), key=lambda ip: abs(a[ip][j]))",
                    "+            a[i], a[ip] = a[ip], a[i]",
                    "+"
                ],
                "start_lineno": 100,
                "end_lineno": 100
            }
        ],
        "sympy/polys/matrices/linsolve.py": [
            {
                "hunk": [
                    "+    # sdm_irref has issues with float matrices. This uses the ddm_rref()",
                    "+    # function. When sdm_rref() can handle float matrices reasonably this",
                    "+    # should be removed...",
                    "+    if K.is_RealField or K.is_ComplexField:",
                    "+        Aaug = Aaug.to_ddm().rref()[0].to_sdm()",
                    "+"
                ],
                "start_lineno": 76,
                "end_lineno": 76
            }
        ],
        "sympy/polys/matrices/sdm.py": [
            {
                "hunk": [
                    "+            Ai.pop(j)",
                    "+            Ainz.remove(j)"
                ],
                "start_lineno": 907,
                "end_lineno": 907
            },
            {
                "hunk": [
                    "+            Ak.pop(j)",
                    "+            Aknz.remove(j)"
                ],
                "start_lineno": 941,
                "end_lineno": 941
            }
        ]
    },
    "sympy__sympy-17251": {
        "sympy/functions/elementary/exponential.py": [
            {
                "hunk": [
                    "-            if arg.is_number or arg.is_Symbol:",
                    "-                coeff = arg.coeff(S.Pi*S.ImaginaryUnit)",
                    "-                if coeff:",
                    "-                    if ask(Q.integer(2*coeff)):",
                    "-                        if ask(Q.even(coeff)):",
                    "-                            return S.One",
                    "-                        elif ask(Q.odd(coeff)):",
                    "-                            return S.NegativeOne",
                    "-                        elif ask(Q.even(coeff + S.Half)):",
                    "-                            return -S.ImaginaryUnit",
                    "-                        elif ask(Q.odd(coeff + S.Half)):",
                    "-                            return S.ImaginaryUnit",
                    "+            coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)",
                    "+            if coeff:",
                    "+                if (2*coeff).is_integer:",
                    "+                    if coeff.is_even:",
                    "+                        return S.One",
                    "+                    elif coeff.is_odd:",
                    "+                        return S.NegativeOne",
                    "+                    elif (coeff + S.Half).is_even:",
                    "+                        return -S.ImaginaryUnit",
                    "+                    elif (coeff + S.Half).is_odd:",
                    "+                        return S.ImaginaryUnit",
                    "+                elif coeff.is_Rational:",
                    "+                    ncoeff = coeff % 2 # restrict to [0, 2pi)",
                    "+                    if ncoeff > 1: # restrict to (-pi, pi]",
                    "+                        ncoeff -= 2",
                    "+                    if ncoeff != coeff:",
                    "+                        return cls(ncoeff*S.Pi*S.ImaginaryUnit)"
                ],
                "start_lineno": 253,
                "end_lineno": 264
            },
            {
                "hunk": [
                    "+            argchanged = False",
                    "             for a in arg.args:",
                    "                 if a is S.One:",
                    "                     add.append(a)",
                    "                     continue",
                    "                 newa = cls(a)",
                    "                 if isinstance(newa, cls):",
                    "-                    add.append(a)",
                    "+                    if newa.args[0] != a:",
                    "+                        add.append(newa.args[0])",
                    "+                        argchanged = True",
                    "+                    else:",
                    "+                        add.append(a)",
                    "                 else:",
                    "                     out.append(newa)",
                    "-            if out:",
                    "+            if out or argchanged:"
                ],
                "start_lineno": 295,
                "end_lineno": 304
            }
        ],
        "sympy/physics/matrices.py": [
            {
                "hunk": [
                    "-    [sqrt(3)/3, sqrt(3)*exp(-2*I*pi/3)/3, sqrt(3)*exp(-4*I*pi/3)/3],",
                    "-    [sqrt(3)/3, sqrt(3)*exp(-4*I*pi/3)/3, sqrt(3)*exp(-8*I*pi/3)/3]])",
                    "+    [sqrt(3)/3, sqrt(3)*exp(-2*I*pi/3)/3,  sqrt(3)*exp(2*I*pi/3)/3],",
                    "+    [sqrt(3)/3,  sqrt(3)*exp(2*I*pi/3)/3, sqrt(3)*exp(-2*I*pi/3)/3]])"
                ],
                "start_lineno": 174,
                "end_lineno": 175
            }
        ]
    },
    "django__django-12951": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        if lookups and condition is None:",
                    "-            condition, lookups = Q(**lookups), None",
                    "+        if lookups:",
                    "+            if condition is None:",
                    "+                condition, lookups = Q(**lookups), None",
                    "+            elif getattr(condition, 'conditional', False):",
                    "+                condition, lookups = Q(condition, **lookups), None"
                ],
                "start_lineno": 879,
                "end_lineno": 880
            }
        ]
    },
    "django__django-13371": {
        "django/db/models/query.py": [
            {
                "hunk": [
                    "-from collections import namedtuple",
                    "-from functools import lru_cache"
                ],
                "start_lineno": 8,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-from django.db.models.utils import resolve_callables",
                    "+from django.db.models.utils import create_namedtuple_class, resolve_callables"
                ],
                "start_lineno": 26,
                "end_lineno": 26
            },
            {
                "hunk": [
                    "-    @staticmethod",
                    "-    @lru_cache()",
                    "-    def create_namedtuple_class(*names):",
                    "-        # Cache namedtuple() with @lru_cache() since it's too slow to be",
                    "-        # called for every QuerySet evaluation.",
                    "-        return namedtuple('Row', names)",
                    "-"
                ],
                "start_lineno": 151,
                "end_lineno": 157
            },
            {
                "hunk": [
                    "-        tuple_class = self.create_namedtuple_class(*names)",
                    "+        tuple_class = create_namedtuple_class(*names)"
                ],
                "start_lineno": 165,
                "end_lineno": 165
            }
        ],
        "django/db/models/utils.py": [
            {
                "hunk": [
                    "+import functools",
                    "+from collections import namedtuple",
                    "+",
                    "+"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "+",
                    "+",
                    "+def unpickle_named_row(names, values):",
                    "+    return create_namedtuple_class(*names)(*values)",
                    "+",
                    "+",
                    "+@functools.lru_cache()",
                    "+def create_namedtuple_class(*names):",
                    "+    # Cache type() with @lru_cache() since it's too slow to be called for every",
                    "+    # QuerySet evaluation.",
                    "+    def __reduce__(self):",
                    "+        return unpickle_named_row, (names, tuple(self))",
                    "+",
                    "+    return type('Row', (namedtuple('Row', names),), {'__reduce__': __reduce__})"
                ],
                "start_lineno": 31,
                "end_lineno": 31
            }
        ]
    },
    "django__django-14447": {
        "django/core/cache/backends/db.py": [
            {
                "hunk": [
                    "-                self._cull(db, cursor, now)",
                    "+                self._cull(db, cursor, now, num)"
                ],
                "start_lineno": 131,
                "end_lineno": 131
            },
            {
                "hunk": [
                    "-    def _cull(self, db, cursor, now):",
                    "+    def _cull(self, db, cursor, now, num):"
                ],
                "start_lineno": 250,
                "end_lineno": 250
            },
            {
                "hunk": [
                    "-            cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)",
                    "-            num = cursor.fetchone()[0]",
                    "-            if num > self._max_entries:",
                    "-                cull_num = num // self._cull_frequency",
                    "+            deleted_count = cursor.rowcount",
                    "+            remaining_num = num - deleted_count",
                    "+            if remaining_num > self._max_entries:",
                    "+                cull_num = remaining_num // self._cull_frequency"
                ],
                "start_lineno": 258,
                "end_lineno": 261
            }
        ]
    },
    "sympy__sympy-14774": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-            inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acot\"]",
                    "+            inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\"]"
                ],
                "start_lineno": 743,
                "end_lineno": 743
            }
        ]
    },
    "pydata__xarray-3527": {
        "xarray/core/groupby.py": [
            {
                "hunk": [
                    "+    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):",
                    "+        \"\"\"Compute the qth quantile over each array in the groups and",
                    "+        concatenate them together into a new array.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        q : float in range of [0,1] (or sequence of floats)",
                    "+            Quantile to compute, which must be between 0 and 1",
                    "+            inclusive.",
                    "+        dim : `...`, str or sequence of str, optional",
                    "+            Dimension(s) over which to apply quantile.",
                    "+            Defaults to the grouped dimension.",
                    "+        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}",
                    "+            This optional parameter specifies the interpolation method to",
                    "+            use when the desired quantile lies between two data points",
                    "+            ``i < j``:",
                    "+                * linear: ``i + (j - i) * fraction``, where ``fraction`` is",
                    "+                  the fractional part of the index surrounded by ``i`` and",
                    "+                  ``j``.",
                    "+                * lower: ``i``.",
                    "+                * higher: ``j``.",
                    "+                * nearest: ``i`` or ``j``, whichever is nearest.",
                    "+                * midpoint: ``(i + j) / 2``.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        quantiles : Variable",
                    "+            If `q` is a single quantile, then the result is a",
                    "+            scalar. If multiple percentiles are given, first axis of",
                    "+            the result corresponds to the quantile. In either case a",
                    "+            quantile dimension is added to the return array. The other",
                    "+            dimensions are the dimensions that remain after the",
                    "+            reduction of the array.",
                    "+",
                    "+        See Also",
                    "+        --------",
                    "+        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,",
                    "+        DataArray.quantile",
                    "+        \"\"\"",
                    "+        if dim is None:",
                    "+            dim = self._group_dim",
                    "+",
                    "+        out = self.map(",
                    "+            self._obj.__class__.quantile,",
                    "+            shortcut=False,",
                    "+            q=q,",
                    "+            dim=dim,",
                    "+            interpolation=interpolation,",
                    "+            keep_attrs=keep_attrs,",
                    "+        )",
                    "+",
                    "+        return out",
                    "+"
                ],
                "start_lineno": 560,
                "end_lineno": 560
            },
            {
                "hunk": [
                    "-    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):",
                    "-        \"\"\"Compute the qth quantile over each array in the groups and",
                    "-        concatenate them together into a new array.",
                    "-",
                    "-        Parameters",
                    "-        ----------",
                    "-        q : float in range of [0,1] (or sequence of floats)",
                    "-            Quantile to compute, which must be between 0 and 1",
                    "-            inclusive.",
                    "-        dim : `...`, str or sequence of str, optional",
                    "-            Dimension(s) over which to apply quantile.",
                    "-            Defaults to the grouped dimension.",
                    "-        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}",
                    "-            This optional parameter specifies the interpolation method to",
                    "-            use when the desired quantile lies between two data points",
                    "-            ``i < j``:",
                    "-                * linear: ``i + (j - i) * fraction``, where ``fraction`` is",
                    "-                  the fractional part of the index surrounded by ``i`` and",
                    "-                  ``j``.",
                    "-                * lower: ``i``.",
                    "-                * higher: ``j``.",
                    "-                * nearest: ``i`` or ``j``, whichever is nearest.",
                    "-                * midpoint: ``(i + j) / 2``.",
                    "-",
                    "-        Returns",
                    "-        -------",
                    "-        quantiles : Variable",
                    "-            If `q` is a single quantile, then the result",
                    "-            is a scalar. If multiple percentiles are given, first axis of",
                    "-            the result corresponds to the quantile and a quantile dimension",
                    "-            is added to the return array. The other dimensions are the",
                    "-            dimensions that remain after the reduction of the array.",
                    "-",
                    "-        See Also",
                    "-        --------",
                    "-        numpy.nanpercentile, pandas.Series.quantile, Dataset.quantile,",
                    "-        DataArray.quantile",
                    "-        \"\"\"",
                    "-        if dim is None:",
                    "-            dim = self._group_dim",
                    "-",
                    "-        out = self.map(",
                    "-            self._obj.__class__.quantile,",
                    "-            shortcut=False,",
                    "-            q=q,",
                    "-            dim=dim,",
                    "-            interpolation=interpolation,",
                    "-            keep_attrs=keep_attrs,",
                    "-        )",
                    "-",
                    "-        if np.asarray(q, dtype=np.float64).ndim == 0:",
                    "-            out = out.drop_vars(\"quantile\")",
                    "-        return out",
                    "-"
                ],
                "start_lineno": 740,
                "end_lineno": 793
            }
        ]
    },
    "pytest-dev__pytest-11148": {
        "src/_pytest/pathlib.py": [
            {
                "hunk": [
                    "+        with contextlib.suppress(KeyError):",
                    "+            return sys.modules[module_name]"
                ],
                "start_lineno": 526,
                "end_lineno": 526
            }
        ]
    },
    "django__django-11630": {
        "django/core/checks/model_checks.py": [
            {
                "hunk": [
                    "-from django.core.checks import Error, Tags, register",
                    "+from django.conf import settings",
                    "+from django.core.checks import Error, Tags, Warning, register"
                ],
                "start_lineno": 7,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "+    if settings.DATABASE_ROUTERS:",
                    "+        error_class, error_id = Warning, 'models.W035'",
                    "+        error_hint = (",
                    "+            'You have configured settings.DATABASE_ROUTERS. Verify that %s '",
                    "+            'are correctly routed to separate databases.'",
                    "+        )",
                    "+    else:",
                    "+        error_class, error_id = Error, 'models.E028'",
                    "+        error_hint = None",
                    "     for db_table, model_labels in db_table_models.items():",
                    "         if len(model_labels) != 1:",
                    "+            model_labels_str = ', '.join(model_labels)",
                    "             errors.append(",
                    "-                Error(",
                    "+                error_class(",
                    "                     \"db_table '%s' is used by multiple models: %s.\"",
                    "-                    % (db_table, ', '.join(db_table_models[db_table])),",
                    "+                    % (db_table, model_labels_str),",
                    "                     obj=db_table,",
                    "-                    id='models.E028',",
                    "+                    hint=(error_hint % model_labels_str) if error_hint else None,",
                    "+                    id=error_id,"
                ],
                "start_lineno": 38,
                "end_lineno": 45
            }
        ]
    },
    "django__django-15102": {
        "django/core/management/templates.py": [
            {
                "hunk": [
                    "-                    shutil.copymode(old_path, new_path)",
                    "+                    self.apply_umask(old_path, new_path)"
                ],
                "start_lineno": 184,
                "end_lineno": 184
            },
            {
                "hunk": [
                    "+    def apply_umask(self, old_path, new_path):",
                    "+        current_umask = os.umask(0)",
                    "+        os.umask(current_umask)",
                    "+        current_mode = stat.S_IMODE(os.stat(old_path).st_mode)",
                    "+        os.chmod(new_path, current_mode & ~current_umask)",
                    "+"
                ],
                "start_lineno": 348,
                "end_lineno": 348
            }
        ]
    },
    "pydata__xarray-3406": {
        "xarray/core/groupby.py": [
            {
                "hunk": [
                    "+            if group.isnull().any():",
                    "+                # drop any NaN valued groups.",
                    "+                # also drop obj values where group was NaN",
                    "+                # Use where instead of reindex to account for duplicate coordinate labels.",
                    "+                obj = obj.where(group.notnull(), drop=True)",
                    "+                group = group.dropna(group_dim)",
                    "+"
                ],
                "start_lineno": 364,
                "end_lineno": 364
            }
        ]
    },
    "django__django-15248": {
        "django/contrib/admin/utils.py": [
            {
                "hunk": [
                    "-    collector = NestedObjects(using=using)",
                    "+    collector = NestedObjects(using=using, origin=objs)"
                ],
                "start_lineno": 119,
                "end_lineno": 119
            }
        ],
        "django/contrib/contenttypes/management/commands/remove_stale_contenttypes.py": [
            {
                "hunk": [
                    "-                        collector = NoFastDeleteCollector(using=using)",
                    "+                        collector = NoFastDeleteCollector(using=using, origin=ct)"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            }
        ],
        "django/db/models/base.py": [
            {
                "hunk": [
                    "-        collector = Collector(using=using)",
                    "+        collector = Collector(using=using, origin=self)"
                ],
                "start_lineno": 990,
                "end_lineno": 990
            }
        ],
        "django/db/models/deletion.py": [
            {
                "hunk": [
                    "-    def __init__(self, using):",
                    "+    def __init__(self, using, origin=None):",
                    "         self.using = using",
                    "+        # A Model or QuerySet object.",
                    "+        self.origin = origin"
                ],
                "start_lineno": 79,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "-                        sender=model, instance=obj, using=self.using",
                    "+                        sender=model, instance=obj, using=self.using,",
                    "+                        origin=self.origin,"
                ],
                "start_lineno": 407,
                "end_lineno": 407
            },
            {
                "hunk": [
                    "-                            sender=model, instance=obj, using=self.using",
                    "+                            sender=model, instance=obj, using=self.using,",
                    "+                            origin=self.origin,"
                ],
                "start_lineno": 438,
                "end_lineno": 438
            }
        ],
        "django/db/models/query.py": [
            {
                "hunk": [
                    "-        collector = Collector(using=del_query.db)",
                    "+        collector = Collector(using=del_query.db, origin=self)"
                ],
                "start_lineno": 756,
                "end_lineno": 756
            }
        ]
    },
    "sympy__sympy-16056": {
        "sympy/core/numbers.py": [
            {
                "hunk": [
                    "-        return r\"\\mathrm{NaN}\"",
                    "+        return r\"\\text{NaN}\""
                ],
                "start_lineno": 3144,
                "end_lineno": 3144
            },
            {
                "hunk": [
                    "-        return r\"\\mathrm{TribonacciConstant}\"",
                    "+        return r\"\\text{TribonacciConstant}\""
                ],
                "start_lineno": 3588,
                "end_lineno": 3588
            }
        ],
        "sympy/diffgeom/diffgeom.py": [
            {
                "hunk": [
                    "-        return r'\\mathrm{%s}' % self.name",
                    "+        return r'\\text{%s}' % self.name"
                ],
                "start_lineno": 42,
                "end_lineno": 42
            },
            {
                "hunk": [
                    "-        return r'\\mathrm{%s}_{%s}' % (self.name, self.manifold._latex(printer, *args))",
                    "+        return r'\\text{%s}_{%s}' % (self.name, self.manifold._latex(printer, *args))"
                ],
                "start_lineno": 86,
                "end_lineno": 86
            },
            {
                "hunk": [
                    "-        return r'\\mathrm{%s}^{\\mathrm{%s}}_{%s}' % (",
                    "+        return r'\\text{%s}^{\\text{%s}}_{%s}' % ("
                ],
                "start_lineno": 344,
                "end_lineno": 344
            }
        ],
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+        \"gothic_re_im\": False,"
                ],
                "start_lineno": 142,
                "end_lineno": 142
            },
            {
                "hunk": [
                    "-            return r\"\\left(%s\\right)\" % self._print(item)",
                    "+            return r\"\\left({}\\right)\".format(self._print(item))"
                ],
                "start_lineno": 203,
                "end_lineno": 203
            },
            {
                "hunk": [
                    "-        return r\"\\mathrm{%s}\" % e",
                    "+        return r\"\\text{%s}\" % e",
                    " ",
                    "     _print_BooleanTrue = _print_bool",
                    "     _print_BooleanFalse = _print_bool",
                    " ",
                    "     def _print_NoneType(self, e):",
                    "-        return r\"\\mathrm{%s}\" % e",
                    "+        return r\"\\text{%s}\" % e"
                ],
                "start_lineno": 317,
                "end_lineno": 323
            },
            {
                "hunk": [
                    "-        tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])",
                    "+        if self._settings['gothic_re_im']:",
                    "+            tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])",
                    "+        else:",
                    "+            tex = r\"\\operatorname{{re}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))",
                    " ",
                    "         return self._do_exponent(tex, exp)",
                    " ",
                    "     def _print_im(self, expr, exp=None):",
                    "-        tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])",
                    "+        if self._settings['gothic_re_im']:",
                    "+            tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])",
                    "+        else:",
                    "+            tex = r\"\\operatorname{{im}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))"
                ],
                "start_lineno": 901,
                "end_lineno": 906
            },
            {
                "hunk": [
                    "-        return r\"\\mathrm{tr}\\left(%s \\right)\" % self._print(mat)",
                    "+        return r\"\\operatorname{tr}\\left(%s \\right)\" % self._print(mat)"
                ],
                "start_lineno": 1508,
                "end_lineno": 1508
            },
            {
                "hunk": [
                    "-            return 'Domain: ' + self._print(d.as_boolean())",
                    "+            return '\\\\text{Domain: }' + self._print(d.as_boolean())",
                    "         elif hasattr(d, 'set'):",
                    "-            return ('Domain: ' + self._print(d.symbols) + ' in ' +",
                    "+            return ('\\\\text{Domain: }' + self._print(d.symbols) + '\\\\text{ in }' +",
                    "                     self._print(d.set))",
                    "         elif hasattr(d, 'symbols'):",
                    "-            return 'Domain on ' + self._print(d.symbols)",
                    "+            return '\\\\text{Domain on }' + self._print(d.symbols)"
                ],
                "start_lineno": 1785,
                "end_lineno": 1790
            },
            {
                "hunk": [
                    "+    def _print_UnifiedTransform(self, expr, s, inverse=False):",
                    "+        return r\"\\mathcal{{{}}}{}_{{{}}}\\left[{}\\right]\\left({}\\right)\".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))",
                    "+",
                    "     def _print_MellinTransform(self, expr):",
                    "-        return r\"\\mathcal{M}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'M')",
                    " ",
                    "     def _print_InverseMellinTransform(self, expr):",
                    "-        return r\"\\mathcal{M}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'M', True)",
                    " ",
                    "     def _print_LaplaceTransform(self, expr):",
                    "-        return r\"\\mathcal{L}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'L')",
                    " ",
                    "     def _print_InverseLaplaceTransform(self, expr):",
                    "-        return r\"\\mathcal{L}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'L', True)",
                    " ",
                    "     def _print_FourierTransform(self, expr):",
                    "-        return r\"\\mathcal{F}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'F')",
                    " ",
                    "     def _print_InverseFourierTransform(self, expr):",
                    "-        return r\"\\mathcal{F}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'F', True)",
                    " ",
                    "     def _print_SineTransform(self, expr):",
                    "-        return r\"\\mathcal{SIN}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'SIN')",
                    " ",
                    "     def _print_InverseSineTransform(self, expr):",
                    "-        return r\"\\mathcal{SIN}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'SIN', True)",
                    " ",
                    "     def _print_CosineTransform(self, expr):",
                    "-        return r\"\\mathcal{COS}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'COS')",
                    " ",
                    "     def _print_InverseCosineTransform(self, expr):",
                    "-        return r\"\\mathcal{COS}^{-1}_{%s}\\left[%s\\right]\\left(%s\\right)\" % \\",
                    "-            (self._print(expr.args[1]), self._print(expr.args[0]),",
                    "-             self._print(expr.args[2]))",
                    "+        return self._print_UnifiedTransform(expr, 'COS', True)"
                ],
                "start_lineno": 2076,
                "end_lineno": 2124
            },
            {
                "hunk": [
                    "-        return \"\\\\mathbf{%s}\" % self._print(Symbol(morphism.name))",
                    "+        return r\"\\mathbf{{{}}}\".format(self._print(Symbol(morphism.name)))"
                ],
                "start_lineno": 2168,
                "end_lineno": 2168
            },
            {
                "hunk": [
                    "-        return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))",
                    "+        return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))",
                    " ",
                    "     def _print_FreeModuleElement(self, m):",
                    "         # Print as row vector for convenience, for now.",
                    "-        return r\"\\left[ %s \\right]\" % \",\".join(",
                    "-            '{' + self._print(x) + '}' for x in m)",
                    "+        return r\"\\left[ {} \\right]\".format(\",\".join(",
                    "+            '{' + self._print(x) + '}' for x in m))",
                    " ",
                    "     def _print_SubModule(self, m):",
                    "-        return r\"\\left\\langle %s \\right\\rangle\" % \",\".join(",
                    "-            '{' + self._print(x) + '}' for x in m.gens)",
                    "+        return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(",
                    "+            '{' + self._print(x) + '}' for x in m.gens))",
                    " ",
                    "     def _print_ModuleImplementedIdeal(self, m):",
                    "-        return r\"\\left\\langle %s \\right\\rangle\" % \",\".join(",
                    "-            '{' + self._print(x) + '}' for [x] in m._module.gens)",
                    "+        return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(",
                    "+            '{' + self._print(x) + '}' for [x] in m._module.gens))"
                ],
                "start_lineno": 2201,
                "end_lineno": 2214
            },
            {
                "hunk": [
                    "-        return r\"\\frac{%s}{%s}\" % (self._print(R.ring),",
                    "-                                   self._print(R.base_ideal))",
                    "+        return r\"\\frac{{{}}}{{{}}}\".format(self._print(R.ring),",
                    "+                 self._print(R.base_ideal))",
                    " ",
                    "     def _print_QuotientRingElement(self, x):",
                    "-        return r\"{%s} + {%s}\" % (self._print(x.data),",
                    "-                                 self._print(x.ring.base_ideal))",
                    "+        return r\"{{{}}} + {{{}}}\".format(self._print(x.data),",
                    "+                 self._print(x.ring.base_ideal))",
                    " ",
                    "     def _print_QuotientModuleElement(self, m):",
                    "-        return r\"{%s} + {%s}\" % (self._print(m.data),",
                    "-                                 self._print(m.module.killed_module))",
                    "+        return r\"{{{}}} + {{{}}}\".format(self._print(m.data),",
                    "+                 self._print(m.module.killed_module))",
                    " ",
                    "     def _print_QuotientModule(self, M):",
                    "         # TODO nicer fractions for few generators...",
                    "-        return r\"\\frac{%s}{%s}\" % (self._print(M.base),",
                    "-                                   self._print(M.killed_module))",
                    "+        return r\"\\frac{{{}}}{{{}}}\".format(self._print(M.base),",
                    "+                 self._print(M.killed_module))",
                    " ",
                    "     def _print_MatrixHomomorphism(self, h):",
                    "-        return r\"{%s} : {%s} \\to {%s}\" % (self._print(h._sympy_matrix()),",
                    "-                                          self._print(h.domain),",
                    "-                                          self._print(h.codomain))",
                    "+        return r\"{{{}}} : {{{}}} \\to {{{}}}\".format(self._print(h._sympy_matrix()),",
                    "+            self._print(h.domain), self._print(h.codomain))",
                    " ",
                    "     def _print_BaseScalarField(self, field):",
                    "         string = field._coord_sys._names[field._index]",
                    "-        return r'\\boldsymbol{\\mathrm{%s}}' % self._print(Symbol(string))",
                    "+        return r'\\mathbf{{{}}}'.format(self._print(Symbol(string)))",
                    " ",
                    "     def _print_BaseVectorField(self, field):",
                    "         string = field._coord_sys._names[field._index]",
                    "-        return r'\\partial_{%s}' % self._print(Symbol(string))",
                    "+        return r'\\partial_{{{}}}'.format(self._print(Symbol(string)))",
                    " ",
                    "     def _print_Differential(self, diff):",
                    "         field = diff._form_field",
                    "         if hasattr(field, '_coord_sys'):",
                    "             string = field._coord_sys._names[field._index]",
                    "-            return r'\\mathrm{d}%s' % self._print(Symbol(string))",
                    "+            return r'\\operatorname{{d}}{}'.format(self._print(Symbol(string)))",
                    "         else:",
                    "-            return 'd(%s)' % self._print(field)",
                    "             string = self._print(field)",
                    "-            return r'\\mathrm{d}\\left(%s\\right)' % string",
                    "+            return r'\\operatorname{{d}}\\left({}\\right)'.format(string)",
                    " ",
                    "     def _print_Tr(self, p):",
                    "         # TODO: Handle indices",
                    "         contents = self._print(p.args[0])",
                    "-        return r'\\mbox{Tr}\\left(%s\\right)' % (contents)",
                    "+        return r'\\operatorname{{tr}}\\left({}\\right)'.format(contents)"
                ],
                "start_lineno": 2226,
                "end_lineno": 2268
            },
            {
                "hunk": [
                    "-          mat_symbol_style=\"plain\", imaginary_unit=\"i\"):",
                    "+          mat_symbol_style=\"plain\", imaginary_unit=\"i\", gothic_re_im=False):"
                ],
                "start_lineno": 2350,
                "end_lineno": 2350
            },
            {
                "hunk": [
                    "-        and \"j\". Adding \"b\" or \"t\" in front gives ``\\mathrm`` or ``\\text``, so",
                    "-        \"bi\" leads to ``\\mathrm{i}`` which gives `\\mathrm{i}`.",
                    "+        and \"j\". Adding \"r\" or \"t\" in front gives ``\\mathrm`` or ``\\text``, so",
                    "+        \"ri\" leads to ``\\mathrm{i}`` which gives `\\mathrm{i}`.",
                    "+    gothic_re_im : boolean, optional",
                    "+        If set to ``True``, `\\Re` and `\\Im` is used for ``re`` and ``im``, respectively.",
                    "+        The default is ``False`` leading to `\\operatorname{re}` and `\\operatorname{im}`."
                ],
                "start_lineno": 2411,
                "end_lineno": 2412
            },
            {
                "hunk": [
                    "+        'gothic_re_im': gothic_re_im,"
                ],
                "start_lineno": 2540,
                "end_lineno": 2540
            }
        ]
    },
    "django__django-12497": {
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "-                                'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'",
                    "+                                'use ManyToManyField(\"%s\", through=\"%s\").'"
                ],
                "start_lineno": 1312,
                "end_lineno": 1312
            },
            {
                "hunk": [
                    "-                                'use ForeignKey(\"%s\", symmetrical=False, through=\"%s\").'",
                    "+                                'use ManyToManyField(\"%s\", through=\"%s\").'"
                ],
                "start_lineno": 1332,
                "end_lineno": 1332
            }
        ]
    },
    "scikit-learn__scikit-learn-25232": {
        "sklearn/impute/_iterative.py": [
            {
                "hunk": [
                    "+    fill_value : str or numerical value, default=None",
                    "+        When `strategy=\"constant\"`, `fill_value` is used to replace all",
                    "+        occurrences of missing_values. For string or object data types,",
                    "+        `fill_value` must be a string.",
                    "+        If `None`, `fill_value` will be 0 when imputing numerical",
                    "+        data and \"missing_value\" for strings or object data types.",
                    "+",
                    "+        .. versionadded:: 1.3",
                    "+"
                ],
                "start_lineno": 120,
                "end_lineno": 120
            },
            {
                "hunk": [
                    "+        \"fill_value\": \"no_validation\",  # any object is valid"
                ],
                "start_lineno": 284,
                "end_lineno": 284
            },
            {
                "hunk": [
                    "+        fill_value=None,"
                ],
                "start_lineno": 304,
                "end_lineno": 304
            },
            {
                "hunk": [
                    "+        self.fill_value = fill_value"
                ],
                "start_lineno": 325,
                "end_lineno": 325
            },
            {
                "hunk": [
                    "+                fill_value=self.fill_value,"
                ],
                "start_lineno": 616,
                "end_lineno": 616
            }
        ]
    },
    "pydata__xarray-4683": {
        "doc/conf.py": [
            {
                "hunk": [
                    "+    \"sparse\": (\"https://sparse.pydata.org/en/latest/\", None),"
                ],
                "start_lineno": 421,
                "end_lineno": 421
            }
        ],
        "xarray/core/common.py": [
            {
                "hunk": [
                    "-    def astype(self, dtype, casting=\"unsafe\", copy=True, keep_attrs=True):",
                    "+    def astype(",
                    "+        self: T,",
                    "+        dtype,",
                    "+        *,",
                    "+        order=None,",
                    "+        casting=None,",
                    "+        subok=None,",
                    "+        copy=None,",
                    "+        keep_attrs=True,",
                    "+    ) -> T:"
                ],
                "start_lineno": 1394,
                "end_lineno": 1394
            },
            {
                "hunk": [
                    "+        order : {'C', 'F', 'A', 'K'}, optional",
                    "+            Controls the memory layout order of the result. \u2018C\u2019 means C order,",
                    "+            \u2018F\u2019 means Fortran order, \u2018A\u2019 means \u2018F\u2019 order if all the arrays are",
                    "+            Fortran contiguous, \u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to",
                    "+            the order the array elements appear in memory as possible.",
                    "         casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                    "-            Controls what kind of data casting may occur. Defaults to 'unsafe'",
                    "-            for backwards compatibility.",
                    "+            Controls what kind of data casting may occur.",
                    " ",
                    "             * 'no' means the data types should not be cast at all.",
                    "             * 'equiv' means only byte-order changes are allowed.",
                    "             * 'safe' means only casts which can preserve values are allowed.",
                    "             * 'same_kind' means only safe casts or casts within a kind,",
                    "-                like float64 to float32, are allowed.",
                    "+              like float64 to float32, are allowed.",
                    "             * 'unsafe' means any data conversions may be done.",
                    "+",
                    "+        subok : bool, optional",
                    "+            If True, then sub-classes will be passed-through, otherwise the",
                    "+            returned array will be forced to be a base-class array."
                ],
                "start_lineno": 1403,
                "end_lineno": 1412
            },
            {
                "hunk": [
                    "+        Notes",
                    "+        -----",
                    "+        The ``order``, ``casting``, ``subok`` and ``copy`` arguments are only passed",
                    "+        through to the ``astype`` method of the underlying array when a value",
                    "+        different than ``None`` is supplied.",
                    "+        Make sure to only supply these arguments if the underlying array class",
                    "+        supports them.",
                    "+",
                    "         See also",
                    "         --------",
                    "-        np.ndarray.astype",
                    "+        numpy.ndarray.astype",
                    "         dask.array.Array.astype",
                    "+        sparse.COO.astype",
                    "         \"\"\"",
                    "         from .computation import apply_ufunc",
                    " ",
                    "+        kwargs = dict(order=order, casting=casting, subok=subok, copy=copy)",
                    "+        kwargs = {k: v for k, v in kwargs.items() if v is not None}",
                    "+",
                    "         return apply_ufunc(",
                    "             duck_array_ops.astype,",
                    "             self,",
                    "-            kwargs=dict(dtype=dtype, casting=casting, copy=copy),",
                    "+            dtype,",
                    "+            kwargs=kwargs,"
                ],
                "start_lineno": 1426,
                "end_lineno": 1436
            }
        ],
        "xarray/core/duck_array_ops.py": [
            {
                "hunk": [
                    "-def astype(data, **kwargs):",
                    "+def astype(data, dtype, **kwargs):"
                ],
                "start_lineno": 161,
                "end_lineno": 161
            },
            {
                "hunk": [
                    "-    return data.astype(**kwargs)",
                    "+    return data.astype(dtype, **kwargs)"
                ],
                "start_lineno": 180,
                "end_lineno": 180
            }
        ],
        "xarray/core/variable.py": [
            {
                "hunk": [
                    "-    def astype(self, dtype, casting=\"unsafe\", copy=True, keep_attrs=True):",
                    "+    def astype(",
                    "+        self: VariableType,",
                    "+        dtype,",
                    "+        *,",
                    "+        order=None,",
                    "+        casting=None,",
                    "+        subok=None,",
                    "+        copy=None,",
                    "+        keep_attrs=True,",
                    "+    ) -> VariableType:",
                    "         \"\"\"",
                    "         Copy of the Variable object, with data cast to a specified type.",
                    " ",
                    "         Parameters",
                    "         ----------",
                    "         dtype : str or dtype",
                    "-             Typecode or data-type to which the array is cast.",
                    "+            Typecode or data-type to which the array is cast.",
                    "+        order : {'C', 'F', 'A', 'K'}, optional",
                    "+            Controls the memory layout order of the result. \u2018C\u2019 means C order,",
                    "+            \u2018F\u2019 means Fortran order, \u2018A\u2019 means \u2018F\u2019 order if all the arrays are",
                    "+            Fortran contiguous, \u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to",
                    "+            the order the array elements appear in memory as possible.",
                    "         casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional",
                    "-             Controls what kind of data casting may occur. Defaults to 'unsafe'",
                    "-             for backwards compatibility.",
                    "-",
                    "-             * 'no' means the data types should not be cast at all.",
                    "-             * 'equiv' means only byte-order changes are allowed.",
                    "-             * 'safe' means only casts which can preserve values are allowed.",
                    "-             * 'same_kind' means only safe casts or casts within a kind,",
                    "-                 like float64 to float32, are allowed.",
                    "-             * 'unsafe' means any data conversions may be done.",
                    "+            Controls what kind of data casting may occur.",
                    "+",
                    "+            * 'no' means the data types should not be cast at all.",
                    "+            * 'equiv' means only byte-order changes are allowed.",
                    "+            * 'safe' means only casts which can preserve values are allowed.",
                    "+            * 'same_kind' means only safe casts or casts within a kind,",
                    "+              like float64 to float32, are allowed.",
                    "+            * 'unsafe' means any data conversions may be done.",
                    "+",
                    "+        subok : bool, optional",
                    "+            If True, then sub-classes will be passed-through, otherwise the",
                    "+            returned array will be forced to be a base-class array.",
                    "         copy : bool, optional",
                    "-             By default, astype always returns a newly allocated array. If this",
                    "-             is set to False and the `dtype` requirement is satisfied, the input",
                    "-             array is returned instead of a copy.",
                    "+            By default, astype always returns a newly allocated array. If this",
                    "+            is set to False and the `dtype` requirement is satisfied, the input",
                    "+            array is returned instead of a copy."
                ],
                "start_lineno": 373,
                "end_lineno": 394
            },
            {
                "hunk": [
                    "+        Notes",
                    "+        -----",
                    "+        The ``order``, ``casting``, ``subok`` and ``copy`` arguments are only passed",
                    "+        through to the ``astype`` method of the underlying array when a value",
                    "+        different than ``None`` is supplied.",
                    "+        Make sure to only supply these arguments if the underlying array class",
                    "+        supports them.",
                    "+",
                    "         See also",
                    "         --------",
                    "-        np.ndarray.astype",
                    "+        numpy.ndarray.astype",
                    "         dask.array.Array.astype",
                    "+        sparse.COO.astype",
                    "         \"\"\"",
                    "         from .computation import apply_ufunc",
                    " ",
                    "+        kwargs = dict(order=order, casting=casting, subok=subok, copy=copy)",
                    "+        kwargs = {k: v for k, v in kwargs.items() if v is not None}",
                    "+",
                    "         return apply_ufunc(",
                    "             duck_array_ops.astype,",
                    "             self,",
                    "-            kwargs=dict(dtype=dtype, casting=casting, copy=copy),",
                    "+            dtype,",
                    "+            kwargs=kwargs,"
                ],
                "start_lineno": 404,
                "end_lineno": 414
            }
        ]
    },
    "django__django-13028": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-        if not getattr(expression, 'filterable', True):",
                    "+        if (",
                    "+            hasattr(expression, 'resolve_expression') and",
                    "+            not getattr(expression, 'filterable', True)",
                    "+        ):"
                ],
                "start_lineno": 1127,
                "end_lineno": 1127
            }
        ]
    },
    "django__django-14730": {
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "+        if self.remote_field.symmetrical and self._related_name:",
                    "+            warnings.append(",
                    "+                checks.Warning(",
                    "+                    'related_name has no effect on ManyToManyField '",
                    "+                    'with a symmetrical relationship, e.g. to \"self\".',",
                    "+                    obj=self,",
                    "+                    id='fields.W345',",
                    "+                )",
                    "+            )",
                    "+"
                ],
                "start_lineno": 1261,
                "end_lineno": 1261
            }
        ]
    },
    "django__django-13658": {
        "django/core/management/__init__.py": [
            {
                "hunk": [
                    "-        parser = CommandParser(usage='%(prog)s subcommand [options] [args]', add_help=False, allow_abbrev=False)",
                    "+        parser = CommandParser(",
                    "+            prog=self.prog_name,",
                    "+            usage='%(prog)s subcommand [options] [args]',",
                    "+            add_help=False,",
                    "+            allow_abbrev=False,",
                    "+        )"
                ],
                "start_lineno": 347,
                "end_lineno": 347
            }
        ]
    },
    "matplotlib__matplotlib-26278": {
        "lib/matplotlib/contour.py": [
            {
                "hunk": [
                    "-                 transform=None, negative_linestyles=None,",
                    "+                 transform=None, negative_linestyles=None, clip_path=None,"
                ],
                "start_lineno": 754,
                "end_lineno": 754
            },
            {
                "hunk": [
                    "+            clip_path=clip_path,"
                ],
                "start_lineno": 808,
                "end_lineno": 808
            },
            {
                "hunk": [
                    "+clip_path : `~matplotlib.patches.Patch` or `.Path` or `.TransformedPath`",
                    "+    Set the clip path.  See `~matplotlib.artist.Artist.set_clip_path`.",
                    "+",
                    "+    .. versionadded:: 3.8",
                    "+"
                ],
                "start_lineno": 1873,
                "end_lineno": 1873
            }
        ]
    },
    "pydata__xarray-3095": {
        "xarray/core/indexing.py": [
            {
                "hunk": [
                    "-from typing import Sequence",
                    "+from typing import Any, Tuple, Sequence, Union",
                    " ",
                    " import numpy as np",
                    " import pandas as pd",
                    " ",
                    " from . import duck_array_ops, nputils, utils",
                    "+from .npcompat import DTypeLike"
                ],
                "start_lineno": 6,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "-    \"\"\"Wrap a pandas.Index to preserve dtypes and handle explicit indexing.\"\"\"",
                    "+    \"\"\"Wrap a pandas.Index to preserve dtypes and handle explicit indexing.",
                    "+    \"\"\"",
                    " ",
                    "-    def __init__(self, array, dtype=None):",
                    "+    def __init__(self, array: Any, dtype: DTypeLike = None):"
                ],
                "start_lineno": 1230,
                "end_lineno": 1232
            },
            {
                "hunk": [
                    "+        else:",
                    "+            dtype = np.dtype(dtype)",
                    "         self._dtype = dtype",
                    " ",
                    "     @property",
                    "-    def dtype(self):",
                    "+    def dtype(self) -> np.dtype:",
                    "         return self._dtype",
                    " ",
                    "-    def __array__(self, dtype=None):",
                    "+    def __array__(self, dtype: DTypeLike = None) -> np.ndarray:"
                ],
                "start_lineno": 1244,
                "end_lineno": 1250
            },
            {
                "hunk": [
                    "-    def shape(self):",
                    "+    def shape(self) -> Tuple[int]:",
                    "         # .shape is broken on pandas prior to v0.15.2",
                    "         return (len(self.array),)",
                    " ",
                    "-    def __getitem__(self, indexer):",
                    "+    def __getitem__(",
                    "+            self, indexer",
                    "+    ) -> Union[",
                    "+        NumpyIndexingAdapter,",
                    "+        np.ndarray,",
                    "+        np.datetime64,",
                    "+        np.timedelta64,",
                    "+    ]:"
                ],
                "start_lineno": 1261,
                "end_lineno": 1265
            },
            {
                "hunk": [
                    "-    def transpose(self, order):",
                    "+    def transpose(self, order) -> pd.Index:",
                    "         return self.array  # self.array should be always one-dimensional",
                    " ",
                    "-    def __repr__(self):",
                    "+    def __repr__(self) -> str:",
                    "         return ('%s(array=%r, dtype=%r)'",
                    "                 % (type(self).__name__, self.array, self.dtype))",
                    "+",
                    "+    def copy(self, deep: bool = True) -> 'PandasIndexAdapter':",
                    "+        # Not the same as just writing `self.array.copy(deep=deep)`, as",
                    "+        # shallow copies of the underlying numpy.ndarrays become deep ones",
                    "+        # upon pickling",
                    "+        # >>> len(pickle.dumps((self.array, self.array)))",
                    "+        # 4000281",
                    "+        # >>> len(pickle.dumps((self.array, self.array.copy(deep=False))))",
                    "+        # 8000341",
                    "+        array = self.array.copy(deep=True) if deep else self.array",
                    "+        return PandasIndexAdapter(array, self._dtype)"
                ],
                "start_lineno": 1302,
                "end_lineno": 1307
            }
        ],
        "xarray/core/variable.py": [
            {
                "hunk": [
                    "-            if deep:",
                    "-                # self._data should be a `PandasIndexAdapter` instance at this",
                    "-                # point, which doesn't have a copy method, so make a deep copy",
                    "-                # of the underlying `pandas.MultiIndex` and create a new",
                    "-                # `PandasIndexAdapter` instance with it.",
                    "-                data = PandasIndexAdapter(self._data.array.copy(deep=True))",
                    "-            else:",
                    "-                data = self._data",
                    "+            data = self._data.copy(deep=deep)"
                ],
                "start_lineno": 1945,
                "end_lineno": 1952
            }
        ]
    },
    "astropy__astropy-13469": {
        "astropy/table/table.py": [
            {
                "hunk": [
                    "-            raise ValueError('Datatype coercion is not allowed')",
                    "+            if np.dtype(dtype) != object:",
                    "+                raise ValueError('Datatype coercion is not allowed')",
                    "+",
                    "+            out = np.array(None, dtype=object)",
                    "+            out[()] = self",
                    "+            return out"
                ],
                "start_lineno": 1073,
                "end_lineno": 1073
            }
        ]
    },
    "django__django-13569": {
        "django/db/models/functions/math.py": [
            {
                "hunk": [
                    "+    def get_group_by_cols(self, alias=None):",
                    "+        return []",
                    "+"
                ],
                "start_lineno": 157,
                "end_lineno": 157
            }
        ]
    },
    "sphinx-doc__sphinx-7748": {
        "sphinx/ext/autodoc/__init__.py": [
            {
                "hunk": [
                    "+    _new_docstrings = None  # type: List[List[str]]",
                    "+    _signatures = None      # type: List[str]",
                    " ",
                    "     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:",
                    "         if encoding is not None:",
                    "             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"",
                    "                           \"deprecated.\" % self.__class__.__name__,",
                    "                           RemovedInSphinx40Warning, stacklevel=2)",
                    "+",
                    "+        # candidates of the object name",
                    "+        valid_names = [self.objpath[-1]]  # type: ignore",
                    "+        if isinstance(self, ClassDocumenter):",
                    "+            valid_names.append('__init__')",
                    "+            if hasattr(self.object, '__mro__'):",
                    "+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)",
                    "+",
                    "         docstrings = self.get_doc()",
                    "         self._new_docstrings = docstrings[:]",
                    "+        self._signatures = []",
                    "         result = None",
                    "         for i, doclines in enumerate(docstrings):",
                    "-            # no lines in docstring, no match",
                    "-            if not doclines:",
                    "-                continue",
                    "-            # match first line of docstring against signature RE",
                    "-            match = py_ext_sig_re.match(doclines[0])",
                    "-            if not match:",
                    "-                continue",
                    "-            exmod, path, base, args, retann = match.groups()",
                    "-            # the base name must match ours",
                    "-            valid_names = [self.objpath[-1]]  # type: ignore",
                    "-            if isinstance(self, ClassDocumenter):",
                    "-                valid_names.append('__init__')",
                    "-                if hasattr(self.object, '__mro__'):",
                    "-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)",
                    "-            if base not in valid_names:",
                    "-                continue",
                    "-            # re-prepare docstring to ignore more leading indentation",
                    "-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore",
                    "-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),",
                    "-                                                        tabsize=tab_width)",
                    "-            result = args, retann",
                    "-            # don't look any further",
                    "-            break",
                    "+            for j, line in enumerate(doclines):",
                    "+                if not line:",
                    "+                    # no lines in docstring, no match",
                    "+                    break",
                    "+",
                    "+                if line.endswith('\\\\'):",
                    "+                    multiline = True",
                    "+                    line = line.rstrip('\\\\').rstrip()",
                    "+                else:",
                    "+                    multiline = False",
                    "+",
                    "+                # match first line of docstring against signature RE",
                    "+                match = py_ext_sig_re.match(line)",
                    "+                if not match:",
                    "+                    continue",
                    "+                exmod, path, base, args, retann = match.groups()",
                    "+",
                    "+                # the base name must match ours",
                    "+                if base not in valid_names:",
                    "+                    continue",
                    "+",
                    "+                # re-prepare docstring to ignore more leading indentation",
                    "+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore",
                    "+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),",
                    "+                                                            tabsize=tab_width)",
                    "+",
                    "+                if result is None:",
                    "+                    # first signature",
                    "+                    result = args, retann",
                    "+                else:",
                    "+                    # subsequent signatures",
                    "+                    self._signatures.append(\"(%s) -> %s\" % (args, retann))",
                    "+",
                    "+                if multiline:",
                    "+                    # the signature have multiple signatures on docstring",
                    "+                    continue",
                    "+                else:",
                    "+                    # don't look any further",
                    "+                    break",
                    "+",
                    "+            if result:",
                    "+                # finish the loop when signature found",
                    "+                break",
                    "+"
                ],
                "start_lineno": 1039,
                "end_lineno": 1071
            },
            {
                "hunk": [
                    "-        lines = getattr(self, '_new_docstrings', None)",
                    "-        if lines is not None:",
                    "-            return lines",
                    "+        if self._new_docstrings is not None:",
                    "+            return self._new_docstrings"
                ],
                "start_lineno": 1079,
                "end_lineno": 1081
            },
            {
                "hunk": [
                    "-        return super().format_signature(**kwargs)  # type: ignore",
                    "+        sig = super().format_signature(**kwargs)  # type: ignore",
                    "+        if self._signatures:",
                    "+            return \"\\n\".join([sig] + self._signatures)",
                    "+        else:",
                    "+            return sig"
                ],
                "start_lineno": 1091,
                "end_lineno": 1091
            },
            {
                "hunk": [
                    "+                    documenter.objpath = [None]"
                ],
                "start_lineno": 1173,
                "end_lineno": 1173
            }
        ]
    },
    "django__django-16532": {
        "django/db/migrations/operations/models.py": [
            {
                "hunk": [
                    "-                # Rename the M2M table that's based on this model's name.",
                    "-                old_m2m_model = old_field.remote_field.through",
                    "-                new_m2m_model = new_field.remote_field.through",
                    "-                schema_editor.alter_db_table(",
                    "-                    new_m2m_model,",
                    "-                    old_m2m_model._meta.db_table,",
                    "-                    new_m2m_model._meta.db_table,",
                    "-                )",
                    "-                # Rename the column in the M2M table that's based on this",
                    "-                # model's name.",
                    "-                schema_editor.alter_field(",
                    "-                    new_m2m_model,",
                    "-                    old_m2m_model._meta.get_field(old_model._meta.model_name),",
                    "-                    new_m2m_model._meta.get_field(new_model._meta.model_name),",
                    "+                # Rename columns and the M2M table.",
                    "+                schema_editor._alter_many_to_many(",
                    "+                    new_model,",
                    "+                    old_field,",
                    "+                    new_field,",
                    "+                    strict=False,"
                ],
                "start_lineno": 410,
                "end_lineno": 423
            }
        ]
    },
    "pytest-dev__pytest-5227": {
        "src/_pytest/logging.py": [
            {
                "hunk": [
                    "-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
                    "+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\""
                ],
                "start_lineno": 18,
                "end_lineno": 18
            }
        ]
    },
    "django__django-16041": {
        "django/forms/formsets.py": [
            {
                "hunk": [
                    "-        form = self.form(",
                    "-            auto_id=self.auto_id,",
                    "-            prefix=self.add_prefix(\"__prefix__\"),",
                    "-            empty_permitted=True,",
                    "-            use_required_attribute=False,",
                    "+        form_kwargs = {",
                    "             **self.get_form_kwargs(None),",
                    "-            renderer=self.renderer,",
                    "-        )",
                    "+            \"auto_id\": self.auto_id,",
                    "+            \"prefix\": self.add_prefix(\"__prefix__\"),",
                    "+            \"empty_permitted\": True,",
                    "+            \"use_required_attribute\": False,",
                    "+            \"renderer\": self.renderer,",
                    "+        }",
                    "+        form = self.form(**form_kwargs)"
                ],
                "start_lineno": 260,
                "end_lineno": 267
            }
        ]
    },
    "scikit-learn__scikit-learn-13467": {
        "sklearn/metrics/regression.py": [
            {
                "hunk": [
                    "-                       multioutput='uniform_average'):",
                    "+                       multioutput='uniform_average', squared=True):"
                ],
                "start_lineno": 194,
                "end_lineno": 194
            },
            {
                "hunk": [
                    "+    squared : boolean value, optional (default = True)",
                    "+        If True returns MSE value, if False returns RMSE value.",
                    "+"
                ],
                "start_lineno": 221,
                "end_lineno": 221
            },
            {
                "hunk": [
                    "+    >>> y_true = [3, -0.5, 2, 7]",
                    "+    >>> y_pred = [2.5, 0.0, 2, 8]",
                    "+    >>> mean_squared_error(y_true, y_pred, squared=False)",
                    "+    0.612..."
                ],
                "start_lineno": 234,
                "end_lineno": 234
            },
            {
                "hunk": [
                    "-    return np.average(output_errors, weights=multioutput)",
                    "+    mse = np.average(output_errors, weights=multioutput)",
                    "+    return mse if squared else np.sqrt(mse)"
                ],
                "start_lineno": 256,
                "end_lineno": 256
            }
        ],
        "sklearn/metrics/scorer.py": [
            {
                "hunk": [
                    "+neg_root_mean_squared_error_scorer = make_scorer(mean_squared_error,",
                    "+                                                 greater_is_better=False,",
                    "+                                                 squared=False)"
                ],
                "start_lineno": 498,
                "end_lineno": 498
            },
            {
                "hunk": [
                    "+               neg_root_mean_squared_error=neg_root_mean_squared_error_scorer,"
                ],
                "start_lineno": 552,
                "end_lineno": 552
            }
        ]
    },
    "django__django-14430": {
        "django/contrib/postgres/aggregates/statistics.py": [
            {
                "hunk": [
                    "-",
                    "-    def convert_value(self, value, expression, connection):",
                    "-        return 0 if value is None else value",
                    "+    empty_aggregate_value = 0"
                ],
                "start_lineno": 39,
                "end_lineno": 41
            }
        ],
        "django/db/models/aggregates.py": [
            {
                "hunk": [
                    "+    empty_aggregate_value = None"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            },
            {
                "hunk": [
                    "+    empty_aggregate_value = 0"
                ],
                "start_lineno": 110,
                "end_lineno": 110
            },
            {
                "hunk": [
                    "-    def convert_value(self, value, expression, connection):",
                    "-        return 0 if value is None else value",
                    "-"
                ],
                "start_lineno": 118,
                "end_lineno": 120
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    empty_aggregate_value = NotImplemented"
                ],
                "start_lineno": 156,
                "end_lineno": 156
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def empty_aggregate_value(self):",
                    "+        return self.value",
                    "+"
                ],
                "start_lineno": 798,
                "end_lineno": 798
            }
        ],
        "django/db/models/functions/comparison.py": [
            {
                "hunk": [
                    "+    @property",
                    "+    def empty_aggregate_value(self):",
                    "+        for expression in self.get_source_expressions():",
                    "+            result = expression.empty_aggregate_value",
                    "+            if result is NotImplemented or result is not None:",
                    "+                return result",
                    "+        return None",
                    "+"
                ],
                "start_lineno": 68,
                "end_lineno": 68
            }
        ],
        "django/db/models/sql/compiler.py": [
            {
                "hunk": [
                    "-    def __init__(self, query, connection, using):",
                    "+    def __init__(self, query, connection, using, elide_empty=True):",
                    "         self.query = query",
                    "         self.connection = connection",
                    "         self.using = using",
                    "+        # Some queries, e.g. coalesced aggregation, need to be executed even if",
                    "+        # they would return an empty result set.",
                    "+        self.elide_empty = elide_empty"
                ],
                "start_lineno": 29,
                "end_lineno": 32
            },
            {
                "hunk": [
                    "-            query.get_compiler(self.using, self.connection)",
                    "+            query.get_compiler(self.using, self.connection, self.elide_empty)"
                ],
                "start_lineno": 461,
                "end_lineno": 461
            },
            {
                "hunk": [
                    "-                where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])",
                    "+                try:",
                    "+                    where, w_params = self.compile(self.where) if self.where is not None else ('', [])",
                    "+                except EmptyResultSet:",
                    "+                    if self.elide_empty:",
                    "+                        raise",
                    "+                    # Use a predicate that's always False.",
                    "+                    where, w_params = '0 = 1', []"
                ],
                "start_lineno": 538,
                "end_lineno": 538
            },
            {
                "hunk": [
                    "-            self.using",
                    "+            self.using, elide_empty=self.elide_empty,"
                ],
                "start_lineno": 1655,
                "end_lineno": 1655
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-    def get_compiler(self, using=None, connection=None):",
                    "+    def get_compiler(self, using=None, connection=None, elide_empty=True):",
                    "         if using is None and connection is None:",
                    "             raise ValueError(\"Need either using or connection\")",
                    "         if using:",
                    "             connection = connections[using]",
                    "-        return connection.ops.compiler(self.compiler)(self, connection, using)",
                    "+        return connection.ops.compiler(self.compiler)(self, connection, using, elide_empty)"
                ],
                "start_lineno": 276,
                "end_lineno": 281
            },
            {
                "hunk": [
                    "+        empty_aggregate_result = [",
                    "+            expression.empty_aggregate_value",
                    "+            for expression in outer_query.annotation_select.values()",
                    "+        ]",
                    "+        elide_empty = not any(result is NotImplemented for result in empty_aggregate_result)",
                    "         outer_query.clear_ordering(force=True)",
                    "         outer_query.clear_limits()",
                    "         outer_query.select_for_update = False",
                    "         outer_query.select_related = False",
                    "-        compiler = outer_query.get_compiler(using)",
                    "+        compiler = outer_query.get_compiler(using, elide_empty=elide_empty)",
                    "         result = compiler.execute_sql(SINGLE)",
                    "         if result is None:",
                    "-            result = [None] * len(outer_query.annotation_select)",
                    "+            result = empty_aggregate_result"
                ],
                "start_lineno": 493,
                "end_lineno": 500
            }
        ]
    },
    "sympy__sympy-18137": {
        "sympy/sets/fancysets.py": [
            {
                "hunk": [
                    "-        else:",
                    "-            return other.is_Integer",
                    "-        if (ref - other) % self.step:  # off sequence",
                    "+        else:  # both infinite; step is +/- 1 (enforced by __new__)",
                    "+            return S.true",
                    "+        if self.size == 1:",
                    "+            return Eq(other, self[0])",
                    "+        res = (ref - other) % self.step",
                    "+        if res == S.Zero:",
                    "+            return And(other >= self.inf, other <= self.sup)",
                    "+        elif res.is_Integer:  # off sequence",
                    "             return S.false",
                    "-        return _sympify(other >= self.inf and other <= self.sup)",
                    "+        else:  # symbolic/unsimplified residue modulo step",
                    "+            return None"
                ],
                "start_lineno": 686,
                "end_lineno": 690
            },
            {
                "hunk": [
                    "-        return And(",
                    "-            Eq(x, floor(x)),",
                    "-            x >= self.inf if self.inf in self else x > self.inf,",
                    "-            x <= self.sup if self.sup in self else x < self.sup)",
                    "+        if self.size == 1:",
                    "+            return Eq(x, self[0])",
                    "+        else:",
                    "+            return And(",
                    "+                Eq(x, floor(x)),",
                    "+                x >= self.inf if self.inf in self else x > self.inf,",
                    "+                x <= self.sup if self.sup in self else x < self.sup)"
                ],
                "start_lineno": 902,
                "end_lineno": 905
            }
        ],
        "sympy/sets/handlers/issubset.py": [
            {
                "hunk": [
                    "-from sympy import S",
                    "+from sympy import S, Symbol"
                ],
                "start_lineno": 1,
                "end_lineno": 1
            },
            {
                "hunk": [
                    "+@dispatch(Range, FiniteSet)",
                    "+def is_subset_sets(a_range, b_finiteset): # noqa:F811",
                    "+    try:",
                    "+        a_size = a_range.size",
                    "+    except ValueError:",
                    "+        # symbolic Range of unknown size",
                    "+        return None",
                    "+    if a_size > len(b_finiteset):",
                    "+        return False",
                    "+    elif any(arg.has(Symbol) for arg in a_range.args):",
                    "+        return fuzzy_and(b_finiteset.contains(x) for x in a_range)",
                    "+    else:",
                    "+        # Checking A \\ B == EmptySet is more efficient than repeated naive",
                    "+        # membership checks on an arbitrary FiniteSet.",
                    "+        a_set = set(a_range)",
                    "+        b_remaining = len(b_finiteset)",
                    "+        # Symbolic expressions and numbers of unknown type (integer or not) are",
                    "+        # all counted as \"candidates\", i.e. *potentially* matching some a in",
                    "+        # a_range.",
                    "+        cnt_candidate = 0",
                    "+        for b in b_finiteset:",
                    "+            if b.is_Integer:",
                    "+                a_set.discard(b)",
                    "+            elif fuzzy_not(b.is_integer):",
                    "+                pass",
                    "+            else:",
                    "+                cnt_candidate += 1",
                    "+            b_remaining -= 1",
                    "+            if len(a_set) > b_remaining + cnt_candidate:",
                    "+                return False",
                    "+            if len(a_set) == 0:",
                    "+                return True",
                    "+        return None",
                    "+"
                ],
                "start_lineno": 69,
                "end_lineno": 69
            }
        ],
        "sympy/sets/sets.py": [
            {
                "hunk": [
                    "-        args = list(ordered(set(args), Set._infimum_key))",
                    "+        _args_set = set(args)",
                    "+        args = list(ordered(_args_set, Set._infimum_key))",
                    "         obj = Basic.__new__(cls, *args)",
                    "+        obj._args_set = _args_set"
                ],
                "start_lineno": 1764,
                "end_lineno": 1765
            },
            {
                "hunk": [
                    "-        Relies on Python's set class. This tests for object equality",
                    "-        All inputs are sympified",
                    "+        The actual test is for mathematical equality (as opposed to",
                    "+        syntactical equality). In the worst case all elements of the",
                    "+        set must be checked."
                ],
                "start_lineno": 1833,
                "end_lineno": 1834
            },
            {
                "hunk": [
                    "-        # evaluate=True is needed to override evaluate=False context;",
                    "-        # we need Eq to do the evaluation",
                    "-        return fuzzy_or(fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args)",
                    "+        if other in self._args_set:",
                    "+            return True",
                    "+        else:",
                    "+            # evaluate=True is needed to override evaluate=False context;",
                    "+            # we need Eq to do the evaluation",
                    "+            return fuzzy_or(fuzzy_bool(Eq(e, other, evaluate=True))",
                    "+                for e in self.args)"
                ],
                "start_lineno": 1846,
                "end_lineno": 1848
            }
        ]
    },
    "matplotlib__matplotlib-26469": {
        "lib/matplotlib/backends/backend_pdf.py": [
            {
                "hunk": [
                    "-    __slots__ = ('_file', 'keep_empty')",
                    " ",
                    "-    def __init__(self, filename, keep_empty=True, metadata=None):",
                    "+    _UNSET = object()",
                    "+",
                    "+    def __init__(self, filename, keep_empty=_UNSET, metadata=None):",
                    "         \"\"\"",
                    "         Create a new PdfPages object.",
                    " ",
                    "         Parameters",
                    "         ----------",
                    "         filename : str or path-like or file-like",
                    "-            Plots using `PdfPages.savefig` will be written to a file at this",
                    "-            location. The file is opened at once and any older file with the",
                    "-            same name is overwritten.",
                    "+            Plots using `PdfPages.savefig` will be written to a file at this location.",
                    "+            The file is opened when a figure is saved for the first time (overwriting",
                    "+            any older file with the same name)."
                ],
                "start_lineno": 2672,
                "end_lineno": 2683
            },
            {
                "hunk": [
                    "-        self._file = PdfFile(filename, metadata=metadata)",
                    "-        self.keep_empty = keep_empty",
                    "+        self._filename = filename",
                    "+        self._metadata = metadata",
                    "+        self._file = None",
                    "+        if keep_empty and keep_empty is not self._UNSET:",
                    "+            _api.warn_deprecated(\"3.8\", message=(",
                    "+                \"Keeping empty pdf files is deprecated since %(since)s and support \"",
                    "+                \"will be removed %(removal)s.\"))",
                    "+        self._keep_empty = keep_empty",
                    "+",
                    "+    keep_empty = _api.deprecate_privatize_attribute(\"3.8\")"
                ],
                "start_lineno": 2699,
                "end_lineno": 2700
            },
            {
                "hunk": [
                    "+    def _ensure_file(self):",
                    "+        if self._file is None:",
                    "+            self._file = PdfFile(self._filename, metadata=self._metadata)  # init.",
                    "+        return self._file",
                    "+",
                    "     def close(self):",
                    "         \"\"\"",
                    "         Finalize this object, making the underlying file a complete",
                    "         PDF file.",
                    "         \"\"\"",
                    "-        self._file.finalize()",
                    "-        self._file.close()",
                    "-        if (self.get_pagecount() == 0 and not self.keep_empty and",
                    "-                not self._file.passed_in_file_object):",
                    "-            os.remove(self._file.fh.name)",
                    "-        self._file = None",
                    "+        if self._file is not None:",
                    "+            self._file.finalize()",
                    "+            self._file.close()",
                    "+            self._file = None",
                    "+        elif self._keep_empty:  # True *or* UNSET.",
                    "+            _api.warn_deprecated(\"3.8\", message=(",
                    "+                \"Keeping empty pdf files is deprecated since %(since)s and support \"",
                    "+                \"will be removed %(removal)s.\"))",
                    "+            PdfFile(self._filename, metadata=self._metadata)  # touch the file."
                ],
                "start_lineno": 2708,
                "end_lineno": 2718
            },
            {
                "hunk": [
                    "-        return self._file.infoDict",
                    "+        return self._ensure_file().infoDict"
                ],
                "start_lineno": 2726,
                "end_lineno": 2726
            },
            {
                "hunk": [
                    "-        return len(self._file.pageList)",
                    "+        return len(self._ensure_file().pageList)"
                ],
                "start_lineno": 2753,
                "end_lineno": 2753
            },
            {
                "hunk": [
                    "-        self._file.newTextnote(text, positionRect)",
                    "+        self._ensure_file().newTextnote(text, positionRect)"
                ],
                "start_lineno": 2762,
                "end_lineno": 2762
            },
            {
                "hunk": [
                    "-            file = filename._file",
                    "+            file = filename._ensure_file()"
                ],
                "start_lineno": 2781,
                "end_lineno": 2781
            }
        ],
        "lib/matplotlib/backends/backend_pgf.py": [
            {
                "hunk": [
                    "-from matplotlib import cbook, font_manager as fm",
                    "+from matplotlib import _api, cbook, font_manager as fm"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-    __slots__ = (",
                    "-        '_output_name',",
                    "-        'keep_empty',",
                    "-        '_n_figures',",
                    "-        '_file',",
                    "-        '_info_dict',",
                    "-        '_metadata',",
                    "-    )",
                    " ",
                    "-    def __init__(self, filename, *, keep_empty=True, metadata=None):",
                    "+    _UNSET = object()",
                    "+",
                    "+    def __init__(self, filename, *, keep_empty=_UNSET, metadata=None):"
                ],
                "start_lineno": 877,
                "end_lineno": 886
            },
            {
                "hunk": [
                    "-        self.keep_empty = keep_empty",
                    "+        if keep_empty and keep_empty is not self._UNSET:",
                    "+            _api.warn_deprecated(\"3.8\", message=(",
                    "+                \"Keeping empty pdf files is deprecated since %(since)s and support \"",
                    "+                \"will be removed %(removal)s.\"))",
                    "+        self._keep_empty = keep_empty",
                    "         self._metadata = (metadata or {}).copy()",
                    "         self._info_dict = _create_pdf_info_dict('pgf', self._metadata)",
                    "         self._file = BytesIO()",
                    " ",
                    "+    keep_empty = _api.deprecate_privatize_attribute(\"3.8\")",
                    "+"
                ],
                "start_lineno": 915,
                "end_lineno": 919
            },
            {
                "hunk": [
                    "-        elif self.keep_empty:",
                    "+        elif self._keep_empty:",
                    "+            _api.warn_deprecated(\"3.8\", message=(",
                    "+                \"Keeping empty pdf files is deprecated since %(since)s and support \"",
                    "+                \"will be removed %(removal)s.\"))"
                ],
                "start_lineno": 949,
                "end_lineno": 949
            }
        ]
    },
    "sphinx-doc__sphinx-10323": {
        "sphinx/directives/code.py": [
            {
                "hunk": [
                    "+                       self.dedent_filter,",
                    "                        self.prepend_filter,",
                    "-                       self.append_filter,",
                    "-                       self.dedent_filter]",
                    "+                       self.append_filter]"
                ],
                "start_lineno": 227,
                "end_lineno": 229
            }
        ]
    },
    "django__django-12496": {
        "django/db/models/base.py": [
            {
                "hunk": [
                    "-            self._meta.pk.default and",
                    "-            self._meta.pk.default is not NOT_PROVIDED",
                    "+            meta.pk.default and",
                    "+            meta.pk.default is not NOT_PROVIDED"
                ],
                "start_lineno": 858,
                "end_lineno": 859
            }
        ]
    },
    "astropy__astropy-13838": {
        "astropy/table/pprint.py": [
            {
                "hunk": [
                    "-            trivial_multidims = np.prod(multidims) == 1",
                    "+            multidims_all_ones = np.prod(multidims) == 1",
                    "+            multidims_has_zero = 0 in multidims"
                ],
                "start_lineno": 395,
                "end_lineno": 395
            },
            {
                "hunk": [
                    "-                if trivial_multidims:",
                    "+                if multidims_all_ones:",
                    "                     return format_func(col_format, col[(idx,) + multidim0])",
                    "+                elif multidims_has_zero:",
                    "+                    # Any zero dimension means there is no data to print",
                    "+                    return \"\""
                ],
                "start_lineno": 478,
                "end_lineno": 479
            }
        ]
    },
    "scikit-learn__scikit-learn-15138": {
        "sklearn/ensemble/_stacking.py": [
            {
                "hunk": [
                    "+import scipy.sparse as sparse"
                ],
                "start_lineno": 11,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "-                 stack_method='auto', n_jobs=None, verbose=0):",
                    "+                 stack_method='auto', n_jobs=None, verbose=0,",
                    "+                 passthrough=False):",
                    "         super().__init__(estimators=estimators)",
                    "         self.final_estimator = final_estimator",
                    "         self.cv = cv",
                    "         self.stack_method = stack_method",
                    "         self.n_jobs = n_jobs",
                    "         self.verbose = verbose",
                    "+        self.passthrough = passthrough"
                ],
                "start_lineno": 40,
                "end_lineno": 46
            },
            {
                "hunk": [
                    "-    def _concatenate_predictions(self, predictions):",
                    "-        \"\"\"Concatenate the predictions of each first layer learner.",
                    "+    def _concatenate_predictions(self, X, predictions):",
                    "+        \"\"\"Concatenate the predictions of each first layer learner and",
                    "+        possibly the input dataset `X`.",
                    "+",
                    "+        If `X` is sparse and `self.passthrough` is False, the output of",
                    "+        `transform` will be dense (the predictions). If `X` is sparse",
                    "+        and `self.passthrough` is True, the output of `transform` will",
                    "+        be sparse."
                ],
                "start_lineno": 54,
                "end_lineno": 55
            },
            {
                "hunk": [
                    "-        return np.concatenate(X_meta, axis=1)",
                    "+        if self.passthrough:",
                    "+            X_meta.append(X)",
                    "+            if sparse.issparse(X):",
                    "+                return sparse.hstack(X_meta, format=X.format)",
                    "+",
                    "+        return np.hstack(X_meta)"
                ],
                "start_lineno": 75,
                "end_lineno": 75
            },
            {
                "hunk": [
                    "-        X_meta = self._concatenate_predictions(predictions)",
                    "+        X_meta = self._concatenate_predictions(X, predictions)"
                ],
                "start_lineno": 168,
                "end_lineno": 168
            },
            {
                "hunk": [
                    "-        return self._concatenate_predictions(predictions)",
                    "+        return self._concatenate_predictions(X, predictions)"
                ],
                "start_lineno": 195,
                "end_lineno": 195
            },
            {
                "hunk": [
                    "+    passthrough : bool, default=False",
                    "+        When False, only the predictions of estimators will be used as",
                    "+        training data for `final_estimator`. When True, the",
                    "+        `final_estimator` is trained on the predictions as well as the",
                    "+        original training data.",
                    "+"
                ],
                "start_lineno": 291,
                "end_lineno": 291
            },
            {
                "hunk": [
                    "-                 stack_method='auto', n_jobs=None, verbose=0):",
                    "+                 stack_method='auto', n_jobs=None, passthrough=False,",
                    "+                 verbose=0):",
                    "         super().__init__(",
                    "             estimators=estimators,",
                    "             final_estimator=final_estimator,",
                    "             cv=cv,",
                    "             stack_method=stack_method,",
                    "             n_jobs=n_jobs,",
                    "+            passthrough=passthrough,"
                ],
                "start_lineno": 347,
                "end_lineno": 353
            },
            {
                "hunk": [
                    "+    passthrough : bool, default=False",
                    "+        When False, only the predictions of estimators will be used as",
                    "+        training data for `final_estimator`. When True, the",
                    "+        `final_estimator` is trained on the predictions as well as the",
                    "+        original training data.",
                    "+"
                ],
                "start_lineno": 528,
                "end_lineno": 528
            },
            {
                "hunk": [
                    "-                 verbose=0):",
                    "+                 passthrough=False, verbose=0):",
                    "         super().__init__(",
                    "             estimators=estimators,",
                    "             final_estimator=final_estimator,",
                    "             cv=cv,",
                    "             stack_method=\"predict\",",
                    "             n_jobs=n_jobs,",
                    "+            passthrough=passthrough,"
                ],
                "start_lineno": 572,
                "end_lineno": 578
            }
        ]
    },
    "django__django-16514": {
        "django/contrib/admin/sites.py": [
            {
                "hunk": [
                    "+            \"log_entries\": self.get_log_entries(request),"
                ],
                "start_lineno": 339,
                "end_lineno": 339
            },
            {
                "hunk": [
                    "+    def get_log_entries(self, request):",
                    "+        from django.contrib.admin.models import LogEntry",
                    "+",
                    "+        return LogEntry.objects.select_related(\"content_type\", \"user\")",
                    "+"
                ],
                "start_lineno": 591,
                "end_lineno": 591
            }
        ],
        "django/contrib/admin/templatetags/log.py": [
            {
                "hunk": [
                    "-from django.contrib.admin.models import LogEntry"
                ],
                "start_lineno": 2,
                "end_lineno": 2
            },
            {
                "hunk": [
                    "-        if self.user is None:",
                    "-            entries = LogEntry.objects.all()",
                    "-        else:",
                    "+        entries = context[\"log_entries\"]",
                    "+        if self.user is not None:",
                    "             user_id = self.user",
                    "             if not user_id.isdigit():",
                    "                 user_id = context[self.user].pk",
                    "-            entries = LogEntry.objects.filter(user__pk=user_id)",
                    "-        context[self.varname] = entries.select_related(\"content_type\", \"user\")[",
                    "-            : int(self.limit)",
                    "-        ]",
                    "+            entries = entries.filter(user__pk=user_id)",
                    "+        context[self.varname] = entries[: int(self.limit)]"
                ],
                "start_lineno": 15,
                "end_lineno": 24
            }
        ]
    },
    "scikit-learn__scikit-learn-15495": {
        "sklearn/tree/_classes.py": [
            {
                "hunk": [
                    "+from ..utils.validation import _check_sample_weight"
                ],
                "start_lineno": 35,
                "end_lineno": 35
            },
            {
                "hunk": [
                    "-            if (getattr(sample_weight, \"dtype\", None) != DOUBLE or",
                    "-                    not sample_weight.flags.contiguous):",
                    "-                sample_weight = np.ascontiguousarray(",
                    "-                    sample_weight, dtype=DOUBLE)",
                    "-            if len(sample_weight.shape) > 1:",
                    "-                raise ValueError(\"Sample weights array has more \"",
                    "-                                 \"than one dimension: %d\" %",
                    "-                                 len(sample_weight.shape))",
                    "-            if len(sample_weight) != n_samples:",
                    "-                raise ValueError(\"Number of weights=%d does not match \"",
                    "-                                 \"number of samples=%d\" %",
                    "-                                 (len(sample_weight), n_samples))",
                    "+            sample_weight = _check_sample_weight(sample_weight, X, DOUBLE)"
                ],
                "start_lineno": 269,
                "end_lineno": 280
            }
        ]
    },
    "astropy__astropy-13075": {
        "astropy/cosmology/io/__init__.py": [
            {
                "hunk": [
                    "-from . import cosmology, ecsv, mapping, model, row, table, yaml",
                    "+from . import cosmology, ecsv, html, mapping, model, row, table, yaml  # noqa: F401"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+import astropy.cosmology.units as cu",
                    "+import astropy.units as u",
                    "+from astropy.cosmology.connect import readwrite_registry",
                    "+from astropy.cosmology.core import Cosmology",
                    "+from astropy.cosmology.parameter import Parameter",
                    "+from astropy.table import QTable",
                    "+",
                    "+from .table import from_table, to_table",
                    "+",
                    "+# Format look-up for conversion, {original_name: new_name}",
                    "+# TODO! move this information into the Parameters themselves",
                    "+_FORMAT_TABLE = {",
                    "+    \"H0\": \"$$H_{0}$$\",",
                    "+    \"Om0\": \"$$\\\\Omega_{m,0}$$\",",
                    "+    \"Ode0\": \"$$\\\\Omega_{\\\\Lambda,0}$$\",",
                    "+    \"Tcmb0\": \"$$T_{0}$$\",",
                    "+    \"Neff\": \"$$N_{eff}$$\",",
                    "+    \"m_nu\": \"$$m_{nu}$$\",",
                    "+    \"Ob0\": \"$$\\\\Omega_{b,0}$$\",",
                    "+    \"w0\": \"$$w_{0}$$\",",
                    "+    \"wa\": \"$$w_{a}$$\",",
                    "+    \"wz\": \"$$w_{z}$$\",",
                    "+    \"wp\": \"$$w_{p}$$\",",
                    "+    \"zp\": \"$$z_{p}$$\",",
                    "+}",
                    "+",
                    "+",
                    "+def read_html_table(filename, index=None, *, move_to_meta=False, cosmology=None, latex_names=True, **kwargs):",
                    "+    \"\"\"Read a |Cosmology| from an HTML file.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    filename : path-like or file-like",
                    "+        From where to read the Cosmology.",
                    "+    index : int or str or None, optional",
                    "+        Needed to select the row in tables with multiple rows. ``index`` can be",
                    "+        an integer for the row number or, if the table is indexed by a column,",
                    "+        the value of that column. If the table is not indexed and ``index`` is a",
                    "+        string, the \"name\" column is used as the indexing column.",
                    "+",
                    "+    move_to_meta : bool, optional keyword-only",
                    "+        Whether to move keyword arguments that are not in the Cosmology class'",
                    "+        signature to the Cosmology's metadata. This will only be applied if the",
                    "+        Cosmology does NOT have a keyword-only argument (e.g. ``**kwargs``).",
                    "+        Arguments moved to the metadata will be merged with existing metadata,",
                    "+        preferring specified metadata in the case of a merge conflict (e.g. for",
                    "+        ``Cosmology(meta={'key':10}, key=42)``, the ``Cosmology.meta`` will be",
                    "+        ``{'key': 10}``).",
                    "+    cosmology : str or |Cosmology| class or None, optional keyword-only",
                    "+        The cosmology class (or string name thereof) to use when constructing",
                    "+        the cosmology instance. The class also provides default parameter",
                    "+        values, filling in any non-mandatory arguments missing in 'table'.",
                    "+    latex_names : bool, optional keyword-only",
                    "+        Whether the |Table| (might) have latex column names for the parameters",
                    "+        that need to be mapped to the correct parameter name -- e.g. $$H_{0}$$",
                    "+        to 'H0'. This is `True` by default, but can be turned off (set to",
                    "+        `False`) if there is a known name conflict (e.g. both an 'H0' and",
                    "+        '$$H_{0}$$' column) as this will raise an error. In this case, the",
                    "+        correct name ('H0') is preferred.",
                    "+    **kwargs : Any",
                    "+        Passed to :attr:`astropy.table.QTable.read`. ``format`` is set to",
                    "+        'ascii.html', regardless of input.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    |Cosmology| subclass instance",
                    "+",
                    "+    Raises",
                    "+    ------",
                    "+    ValueError",
                    "+        If the keyword argument 'format' is given and is not \"ascii.html\".",
                    "+    \"\"\"",
                    "+    # Check that the format is 'ascii.html' (or not specified)",
                    "+    format = kwargs.pop(\"format\", \"ascii.html\")",
                    "+    if format != \"ascii.html\":",
                    "+        raise ValueError(f\"format must be 'ascii.html', not {format}\")",
                    "+",
                    "+    # Reading is handled by `QTable`.",
                    "+    with u.add_enabled_units(cu):  # (cosmology units not turned on by default)",
                    "+        table = QTable.read(filename, format=\"ascii.html\", **kwargs)",
                    "+",
                    "+    # Need to map the table's column names to Cosmology inputs (parameter",
                    "+    # names).",
                    "+    # TODO! move the `latex_names` into `from_table`",
                    "+    if latex_names:",
                    "+        table_columns = set(table.colnames)",
                    "+        for name, latex in _FORMAT_TABLE.items():",
                    "+            if latex in table_columns:",
                    "+                table.rename_column(latex, name)",
                    "+",
                    "+    # Build the cosmology from table, using the private backend.",
                    "+    return from_table(table, index=index, move_to_meta=move_to_meta, cosmology=cosmology)",
                    "+",
                    "+",
                    "+def write_html_table(cosmology, file, *, overwrite=False, cls=QTable, latex_names=False, **kwargs):",
                    "+    r\"\"\"Serialize the |Cosmology| into a HTML table.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    cosmology : |Cosmology| subclass instance file : path-like or file-like",
                    "+        Location to save the serialized cosmology.",
                    "+    file : path-like or file-like",
                    "+        Where to write the html table.",
                    "+",
                    "+    overwrite : bool, optional keyword-only",
                    "+        Whether to overwrite the file, if it exists.",
                    "+    cls : |Table| class, optional keyword-only",
                    "+        Astropy |Table| (sub)class to use when writing. Default is |QTable|",
                    "+        class.",
                    "+    latex_names : bool, optional keyword-only",
                    "+        Whether to format the parameters (column) names to latex -- e.g. 'H0' to",
                    "+        $$H_{0}$$.",
                    "+    **kwargs : Any",
                    "+        Passed to ``cls.write``.",
                    "+",
                    "+    Raises",
                    "+    ------",
                    "+    TypeError",
                    "+        If the optional keyword-argument 'cls' is not a subclass of |Table|.",
                    "+    ValueError",
                    "+        If the keyword argument 'format' is given and is not \"ascii.html\".",
                    "+",
                    "+    Notes",
                    "+    -----",
                    "+    A HTML file containing a Cosmology HTML table should have scripts enabling",
                    "+    MathJax.",
                    "+",
                    "+    ::",
                    "+        <script",
                    "+        src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"></script>",
                    "+        <script type=\"text/javascript\" id=\"MathJax-script\" async",
                    "+            src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\">",
                    "+        </script>",
                    "+    \"\"\"",
                    "+    # Check that the format is 'ascii.html' (or not specified)",
                    "+    format = kwargs.pop(\"format\", \"ascii.html\")",
                    "+    if format != \"ascii.html\":",
                    "+        raise ValueError(f\"format must be 'ascii.html', not {format}\")",
                    "+",
                    "+    # Set cosmology_in_meta as false for now since there is no metadata being kept",
                    "+    table = to_table(cosmology, cls=cls, cosmology_in_meta=False)",
                    "+",
                    "+    cosmo_cls = type(cosmology)",
                    "+    for name, col in table.columns.items():",
                    "+        param = getattr(cosmo_cls, name, None)",
                    "+        if not isinstance(param, Parameter) or param.unit in (None, u.one):",
                    "+            continue",
                    "+        # Replace column with unitless version",
                    "+        table.replace_column(name, (col << param.unit).value, copy=False)",
                    "+",
                    "+    # TODO! move the `latex_names` into `to_table`",
                    "+    if latex_names:",
                    "+        new_names = [_FORMAT_TABLE.get(k, k) for k in cosmology.__parameters__]",
                    "+        table.rename_columns(cosmology.__parameters__, new_names)",
                    "+",
                    "+    # Write HTML, using table I/O",
                    "+    table.write(file, overwrite=overwrite, format=\"ascii.html\", **kwargs)",
                    "+",
                    "+",
                    "+def html_identify(origin, filepath, fileobj, *args, **kwargs):",
                    "+    \"\"\"Identify if an object uses the HTML Table format.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    origin : Any",
                    "+        Not used.",
                    "+    filepath : str or Any",
                    "+        From where to read the Cosmology.",
                    "+    fileobj : Any",
                    "+        Not used.",
                    "+    *args : Any",
                    "+        Not used.",
                    "+    **kwargs : Any",
                    "+        Not used.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    bool",
                    "+        If the filepath is a string ending with '.html'.",
                    "+    \"\"\"",
                    "+    return isinstance(filepath, str) and filepath.endswith(\".html\")",
                    "+",
                    "+",
                    "+# ===================================================================",
                    "+# Register",
                    "+",
                    "+readwrite_registry.register_reader(\"ascii.html\", Cosmology, read_html_table)",
                    "+readwrite_registry.register_writer(\"ascii.html\", Cosmology, write_html_table)",
                    "+readwrite_registry.register_identifier(\"ascii.html\", Cosmology, html_identify)"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ]
    },
    "scikit-learn__scikit-learn-11043": {
        "sklearn/preprocessing/_function_transformer.py": [
            {
                "hunk": [
                    "-        func. If validate is false, there will be no input validation.",
                    "-        If it is true, then X will be converted to a 2-dimensional NumPy",
                    "-        array or sparse matrix. If this conversion is not possible or X",
                    "-        contains NaN or infinity, an exception is raised.",
                    "+        ``func``. The possibilities are:",
                    "+",
                    "+        - If False, there is no input validation.",
                    "+        - If True, then X will be converted to a 2-dimensional NumPy array or",
                    "+          sparse matrix. If the conversion is not possible an exception is",
                    "+          raised.",
                    "+",
                    "+        .. deprecated:: 0.20",
                    "+           ``validate=True`` as default will be replaced by",
                    "+           ``validate=False`` in 0.22."
                ],
                "start_lineno": 45,
                "end_lineno": 48
            },
            {
                "hunk": [
                    "-    def __init__(self, func=None, inverse_func=None, validate=True,",
                    "+    def __init__(self, func=None, inverse_func=None, validate=None,"
                ],
                "start_lineno": 75,
                "end_lineno": 75
            },
            {
                "hunk": [
                    "+    def _check_input(self, X):",
                    "+        # FIXME: Future warning to be removed in 0.22",
                    "+        if self.validate is None:",
                    "+            self._validate = True",
                    "+            warnings.warn(\"The default validate=True will be replaced by \"",
                    "+                          \"validate=False in 0.22.\", FutureWarning)",
                    "+        else:",
                    "+            self._validate = self.validate",
                    "+",
                    "+        if self._validate:",
                    "+            return check_array(X, accept_sparse=self.accept_sparse)",
                    "+        return X",
                    "+"
                ],
                "start_lineno": 87,
                "end_lineno": 87
            },
            {
                "hunk": [
                    "-        if self.validate:",
                    "-            X = check_array(X, self.accept_sparse)",
                    "+        X = self._check_input(X)"
                ],
                "start_lineno": 114,
                "end_lineno": 115
            },
            {
                "hunk": [
                    "-        if self.validate:",
                    "-            X = check_array(X, self.accept_sparse)",
                    "+        X = self._check_input(X)"
                ],
                "start_lineno": 168,
                "end_lineno": 169
            }
        ]
    },
    "django__django-14500": {
        "django/db/migrations/executor.py": [
            {
                "hunk": [
                    "-        # For replacement migrations, record individual statuses",
                    "+        # For replacement migrations, also record individual statuses.",
                    "         if migration.replaces:",
                    "             for app_label, name in migration.replaces:",
                    "                 self.recorder.record_unapplied(app_label, name)",
                    "-        else:",
                    "-            self.recorder.record_unapplied(migration.app_label, migration.name)",
                    "+        self.recorder.record_unapplied(migration.app_label, migration.name)"
                ],
                "start_lineno": 253,
                "end_lineno": 258
            }
        ]
    },
    "django__django-12973": {
        "django/contrib/admin/checks.py": [
            {
                "hunk": [
                    "+            hint=(",
                    "+                \"Insert \"",
                    "+                \"'django.contrib.sessions.middleware.SessionMiddleware' \"",
                    "+                \"before \"",
                    "+                \"'django.contrib.auth.middleware.AuthenticationMiddleware'.\"",
                    "+            ),"
                ],
                "start_lineno": 135,
                "end_lineno": 135
            }
        ]
    },
    "sympy__sympy-19637": {
        "sympy/core/sympify.py": [
            {
                "hunk": [
                    "-        hit = kern in s",
                    "+            hit = kern in s",
                    "+        else:",
                    "+            hit = False"
                ],
                "start_lineno": 516,
                "end_lineno": 516
            }
        ]
    },
    "django__django-9003": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-        self.alias_map = {}",
                    "+        self.alias_map = OrderedDict()"
                ],
                "start_lineno": 136,
                "end_lineno": 136
            }
        ]
    },
    "django__django-14983": {
        "django/db/migrations/autodetector.py": [
            {
                "hunk": [
                    "-        it. If no number is found, return None.",
                    "+        it. For a squashed migration such as '0001_squashed_0004\u2026', return the",
                    "+        second number. If no number is found, return None.",
                    "         \"\"\"",
                    "+        if squashed_match := re.search(r'.*_squashed_(\\d+)', name):",
                    "+            return int(squashed_match[1])"
                ],
                "start_lineno": 1332,
                "end_lineno": 1333
            }
        ]
    },
    "sympy__sympy-15599": {
        "sympy/core/mod.py": [
            {
                "hunk": [
                    "-from sympy.core.numbers import nan",
                    "+from sympy.core.numbers import nan, Integer",
                    "+from sympy.core.compatibility import integer_types"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-                    return (p % q)",
                    "+                    return p%q"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            },
            {
                "hunk": [
                    "-                if type(d) is int:",
                    "+                if isinstance(d, integer_types):"
                ],
                "start_lineno": 67,
                "end_lineno": 67
            },
            {
                "hunk": [
                    "+            if q.is_Integer and q is not S.One:",
                    "+                _ = []",
                    "+                for i in non_mod_l:",
                    "+                    if i.is_Integer and (i % q is not S.Zero):",
                    "+                        _.append(i%q)",
                    "+                    else:",
                    "+                        _.append(i)",
                    "+                non_mod_l = _",
                    "+",
                    "+            p = Mul(*(non_mod_l + mod_l))",
                    "+"
                ],
                "start_lineno": 142,
                "end_lineno": 142
            }
        ]
    },
    "pytest-dev__pytest-8641": {
        "src/_pytest/logging.py": [
            {
                "hunk": [
                    "-    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")",
                    "+    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*(?:\\.\\d+)?s)\")"
                ],
                "start_lineno": 62,
                "end_lineno": 62
            }
        ]
    },
    "django__django-16281": {
        "django/db/backends/sqlite3/schema.py": [
            {
                "hunk": [
                    "-        self, model, create_field=None, delete_field=None, alter_field=None",
                    "+        self, model, create_field=None, delete_field=None, alter_fields=None"
                ],
                "start_lineno": 177,
                "end_lineno": 177
            },
            {
                "hunk": [
                    "-        if getattr(create_field, \"primary_key\", False) or (",
                    "-            alter_field and getattr(alter_field[1], \"primary_key\", False)",
                    "+        alter_fields = alter_fields or []",
                    "+        if getattr(create_field, \"primary_key\", False) or any(",
                    "+            getattr(new_field, \"primary_key\", False) for _, new_field in alter_fields",
                    "         ):",
                    "             for name, field in list(body.items()):",
                    "-                if field.primary_key and not (",
                    "+                if field.primary_key and not any(",
                    "                     # Do not remove the old primary key when an altered field",
                    "                     # that introduces a primary key is the same field.",
                    "-                    alter_field",
                    "-                    and name == alter_field[1].name",
                    "+                    name == new_field.name",
                    "+                    for _, new_field in alter_fields"
                ],
                "start_lineno": 216,
                "end_lineno": 224
            },
            {
                "hunk": [
                    "-        if alter_field:",
                    "+        for alter_field in alter_fields:"
                ],
                "start_lineno": 240,
                "end_lineno": 240
            },
            {
                "hunk": [
                    "-        self._remake_table(model, alter_field=(old_field, new_field))",
                    "+        self._remake_table(model, alter_fields=[(old_field, new_field)])"
                ],
                "start_lineno": 460,
                "end_lineno": 460
            },
            {
                "hunk": [
                    "-                alter_field=(",
                    "-                    # The field that points to the target model is needed, so",
                    "-                    # we can tell alter_field to change it - this is",
                    "-                    # m2m_reverse_field_name() (as opposed to m2m_field_name(),",
                    "-                    # which points to our model).",
                    "-                    old_field.remote_field.through._meta.get_field(",
                    "-                        old_field.m2m_reverse_field_name()",
                    "+                alter_fields=[",
                    "+                    (",
                    "+                        # The field that points to the target model is needed,",
                    "+                        # so that table can be remade with the new m2m field -",
                    "+                        # this is m2m_reverse_field_name().",
                    "+                        old_field.remote_field.through._meta.get_field(",
                    "+                            old_field.m2m_reverse_field_name()",
                    "+                        ),",
                    "+                        new_field.remote_field.through._meta.get_field(",
                    "+                            new_field.m2m_reverse_field_name()",
                    "+                        ),",
                    "                     ),",
                    "-                    new_field.remote_field.through._meta.get_field(",
                    "-                        new_field.m2m_reverse_field_name()",
                    "+                    (",
                    "+                        # The field that points to the model itself is needed,",
                    "+                        # so that table can be remade with the new self field -",
                    "+                        # this is m2m_field_name().",
                    "+                        old_field.remote_field.through._meta.get_field(",
                    "+                            old_field.m2m_field_name()",
                    "+                        ),",
                    "+                        new_field.remote_field.through._meta.get_field(",
                    "+                            new_field.m2m_field_name()",
                    "+                        ),",
                    "                     ),",
                    "-                ),",
                    "+                ],"
                ],
                "start_lineno": 498,
                "end_lineno": 509
            }
        ]
    },
    "sphinx-doc__sphinx-7374": {
        "sphinx/builders/_epub_base.py": [
            {
                "hunk": [
                    "+        def update_node_id(node: Element) -> None:",
                    "+            \"\"\"Update IDs of given *node*.\"\"\"",
                    "+            new_ids = []",
                    "+            for node_id in node['ids']:",
                    "+                new_id = self.fix_fragment('', node_id)",
                    "+                if new_id not in new_ids:",
                    "+                    new_ids.append(new_id)",
                    "+            node['ids'] = new_ids",
                    "+"
                ],
                "start_lineno": 262,
                "end_lineno": 262
            },
            {
                "hunk": [
                    "-            for i, node_id in enumerate(target['ids']):",
                    "-                if ':' in node_id:",
                    "-                    target['ids'][i] = self.fix_fragment('', node_id)",
                    "+            update_node_id(target)",
                    " ",
                    "             next_node = target.next_node(ascend=True)  # type: Node",
                    "             if isinstance(next_node, nodes.Element):",
                    "-                for i, node_id in enumerate(next_node['ids']):",
                    "-                    if ':' in node_id:",
                    "-                        next_node['ids'][i] = self.fix_fragment('', node_id)",
                    "+                update_node_id(next_node)",
                    " ",
                    "         for desc_signature in tree.traverse(addnodes.desc_signature):",
                    "-            ids = desc_signature.attributes['ids']",
                    "-            newids = []",
                    "-            for id in ids:",
                    "-                newids.append(self.fix_fragment('', id))",
                    "-            desc_signature.attributes['ids'] = newids",
                    "+            update_node_id(desc_signature)"
                ],
                "start_lineno": 271,
                "end_lineno": 286
            }
        ],
        "sphinx/util/nodes.py": [
            {
                "hunk": [
                    "+    * Allow to use capital alphabet characters"
                ],
                "start_lineno": 448,
                "end_lineno": 448
            },
            {
                "hunk": [
                    "-    id = string.lower()",
                    "-    id = id.translate(_non_id_translate_digraphs)",
                    "+    id = string.translate(_non_id_translate_digraphs)"
                ],
                "start_lineno": 455,
                "end_lineno": 456
            },
            {
                "hunk": [
                    "-_non_id_chars = re.compile('[^a-z0-9._]+')",
                    "+_non_id_chars = re.compile('[^a-zA-Z0-9._]+')"
                ],
                "start_lineno": 467,
                "end_lineno": 467
            }
        ]
    },
    "scikit-learn__scikit-learn-12760": {
        "sklearn/metrics/cluster/unsupervised.py": [
            {
                "hunk": [
                    "-    The score is defined as the ratio of within-cluster distances to",
                    "-    between-cluster distances.",
                    "+    The score is defined as the average similarity measure of each cluster with",
                    "+    its most similar cluster, where similarity is the ratio of within-cluster",
                    "+    distances to between-cluster distances. Thus, clusters which are farther",
                    "+    apart and less dispersed will result in a better score.",
                    "+",
                    "+    The minimum score is zero, with lower values indicating better clustering."
                ],
                "start_lineno": 302,
                "end_lineno": 303
            },
            {
                "hunk": [
                    "-    score = (intra_dists[:, None] + intra_dists) / centroid_distances",
                    "-    score[score == np.inf] = np.nan",
                    "-    return np.mean(np.nanmax(score, axis=1))",
                    "+    centroid_distances[centroid_distances == 0] = np.inf",
                    "+    combined_intra_dists = intra_dists[:, None] + intra_dists",
                    "+    scores = np.max(combined_intra_dists / centroid_distances, axis=1)",
                    "+    return np.mean(scores)"
                ],
                "start_lineno": 350,
                "end_lineno": 352
            }
        ]
    },
    "django__django-14534": {
        "django/forms/boundfield.py": [
            {
                "hunk": [
                    "-        return 'id_%s_%s' % (self.data['name'], self.data['index'])",
                    "+        return self.data['attrs'].get('id')"
                ],
                "start_lineno": 280,
                "end_lineno": 280
            }
        ]
    },
    "sphinx-doc__sphinx-7975": {
        "sphinx/environment/adapters/indexentries.py": [
            {
                "hunk": [
                    "-        # sort the index entries; put all symbols at the front, even those",
                    "-        # following the letters in ASCII, this is where the chr(127) comes from",
                    "-        def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:",
                    "+        # sort the index entries",
                    "+        def keyfunc(entry: Tuple[str, List]) -> Tuple[Tuple[int, str], str]:"
                ],
                "start_lineno": 101,
                "end_lineno": 103
            },
            {
                "hunk": [
                    "+",
                    "             if lckey[0:1].isalpha() or lckey.startswith('_'):",
                    "-                lckey = chr(127) + lckey",
                    "+                # put non-symbol characters at the folloing group (1)",
                    "+                sortkey = (1, lckey)",
                    "+            else:",
                    "+                # put symbols at the front of the index (0)",
                    "+                sortkey = (0, lckey)",
                    "             # ensure a determinstic order *within* letters by also sorting on",
                    "             # the entry itself",
                    "-            return (lckey, entry[0])",
                    "+            return (sortkey, entry[0])"
                ],
                "start_lineno": 111,
                "end_lineno": 115
            }
        ]
    },
    "django__django-17066": {
        "django/db/migrations/serializer.py": [
            {
                "hunk": [
                    "+class BaseUnorderedSequenceSerializer(BaseSequenceSerializer):",
                    "+    def __init__(self, value):",
                    "+        super().__init__(sorted(value, key=repr))",
                    "+",
                    "+"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            },
            {
                "hunk": [
                    "-class FrozensetSerializer(BaseSequenceSerializer):",
                    "+class FrozensetSerializer(BaseUnorderedSequenceSerializer):"
                ],
                "start_lineno": 154,
                "end_lineno": 154
            },
            {
                "hunk": [
                    "-class SetSerializer(BaseSequenceSerializer):",
                    "+class SetSerializer(BaseUnorderedSequenceSerializer):"
                ],
                "start_lineno": 282,
                "end_lineno": 282
            }
        ],
        "django/db/migrations/writer.py": [
            {
                "hunk": [
                    "-        items[\"dependencies\"] = \"\\n\".join(dependencies) + \"\\n\" if dependencies else \"\"",
                    "+        items[\"dependencies\"] = (",
                    "+            \"\\n\".join(sorted(dependencies)) + \"\\n\" if dependencies else \"\"",
                    "+        )"
                ],
                "start_lineno": 157,
                "end_lineno": 157
            }
        ]
    },
    "scikit-learn__scikit-learn-13620": {
        "sklearn/ensemble/gradient_boosting.py": [
            {
                "hunk": [
                    "+            The values of this array sum to 1, unless all trees are single node",
                    "+            trees consisting of only the root node, in which case it will be an",
                    "+            array of zeros.",
                    "         \"\"\"",
                    "         self._check_initialized()",
                    " ",
                    "-        total_sum = np.zeros((self.n_features_, ), dtype=np.float64)",
                    "-        for stage in self.estimators_:",
                    "-            stage_sum = sum(tree.tree_.compute_feature_importances(",
                    "-                normalize=False) for tree in stage) / len(stage)",
                    "-            total_sum += stage_sum",
                    "-",
                    "-        importances = total_sum / total_sum.sum()",
                    "-        return importances",
                    "+        relevant_trees = [tree",
                    "+                          for stage in self.estimators_ for tree in stage",
                    "+                          if tree.tree_.node_count > 1]",
                    "+        if not relevant_trees:",
                    "+            # degenerate case where all trees have only one node",
                    "+            return np.zeros(shape=self.n_features_, dtype=np.float64)",
                    "+",
                    "+        relevant_feature_importances = [",
                    "+            tree.tree_.compute_feature_importances(normalize=False)",
                    "+            for tree in relevant_trees",
                    "+        ]",
                    "+        avg_feature_importances = np.mean(relevant_feature_importances,",
                    "+                                          axis=0, dtype=np.float64)",
                    "+        return avg_feature_importances / np.sum(avg_feature_importances)"
                ],
                "start_lineno": 1712,
                "end_lineno": 1722
            }
        ]
    },
    "django__django-13109": {
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "-        qs = self.remote_field.model._default_manager.using(using).filter(",
                    "+        qs = self.remote_field.model._base_manager.using(using).filter("
                ],
                "start_lineno": 917,
                "end_lineno": 917
            }
        ]
    },
    "django__django-11053": {
        "django/conf/__init__.py": [
            {
                "hunk": [
                    "+            if not name.isupper():",
                    "+                raise TypeError('Setting %r must be uppercase.' % name)"
                ],
                "start_lineno": 107,
                "end_lineno": 107
            },
            {
                "hunk": [
                    "-        if name in self._deleted:",
                    "+        if not name.isupper() or name in self._deleted:"
                ],
                "start_lineno": 201,
                "end_lineno": 201
            }
        ]
    },
    "astropy__astropy-14096": {
        "astropy/coordinates/sky_coordinate.py": [
            {
                "hunk": [
                    "-        # Fail",
                    "-        raise AttributeError(",
                    "-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"",
                    "-        )",
                    "+        # Call __getattribute__; this will give correct exception.",
                    "+        return self.__getattribute__(attr)"
                ],
                "start_lineno": 897,
                "end_lineno": 900
            }
        ]
    },
    "sympy__sympy-13574": {
        "sympy/matrices/dense.py": [
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 1281,
                "end_lineno": 1281
            },
            {
                "hunk": [
                    "-    [0, 68, 43]",
                    "-    [0, 68,  0]",
                    "-    [0, 91, 34]",
                    "+    [77, 70,  0],",
                    "+    [70,  0,  0],",
                    "+    [ 0,  0, 88]",
                    "     \"\"\"",
                    "     if c is None:",
                    "         c = r",
                    "     # Note that ``Random()`` is equivalent to ``Random(None)``",
                    "     prng = prng or random.Random(seed)",
                    "-    if symmetric and r != c:",
                    "-        raise ValueError(",
                    "-            'For symmetric matrices, r must equal c, but %i != %i' % (r, c))",
                    "+",
                    "     if not symmetric:",
                    "         m = Matrix._new(r, c, lambda i, j: prng.randint(min, max))",
                    "-    else:",
                    "-        m = zeros(r)",
                    "-        for i in range(r):",
                    "-            for j in range(i, r):",
                    "-                m[i, j] = prng.randint(min, max)",
                    "-        for i in range(r):",
                    "-            for j in range(i):",
                    "-                m[i, j] = m[j, i]",
                    "-    if percent == 100:",
                    "-        return m",
                    "-    else:",
                    "-        z = int(r*c*percent // 100)",
                    "+        if percent == 100:",
                    "+            return m",
                    "+        z = int(r*c*(100 - percent) // 100)",
                    "         m._mat[:z] = [S.Zero]*z",
                    "         prng.shuffle(m._mat)",
                    "+",
                    "+        return m",
                    "+",
                    "+    # Symmetric case",
                    "+    if r != c:",
                    "+        raise ValueError('For symmetric matrices, r must equal c, but %i != %i' % (r, c))",
                    "+    m = zeros(r)",
                    "+    ij = [(i, j) for i in range(r) for j in range(i, r)]",
                    "+    if percent != 100:",
                    "+        ij = prng.sample(ij, int(len(ij)*percent // 100))",
                    "+",
                    "+    for i, j in ij:",
                    "+        value = prng.randint(min, max)",
                    "+        m[i, j] = m[j, i] = value"
                ],
                "start_lineno": 1389,
                "end_lineno": 1415
            }
        ]
    },
    "sympy__sympy-16281": {
        "sympy/printing/pretty/pretty.py": [
            {
                "hunk": [
                    "-            sign_lines = []",
                    "-            sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)",
                    "-            for i in range(func_height + 1):",
                    "-                sign_lines.append(vertical_chr + (' '*width) + vertical_chr)",
                    "+            sign_lines = [horizontal_chr + corner_chr + (horizontal_chr * (width-2)) + corner_chr + horizontal_chr]",
                    "+            for _ in range(func_height + 1):",
                    "+                sign_lines.append(' ' + vertical_chr + (' ' * (width-2)) + vertical_chr + ' ')"
                ],
                "start_lineno": 494,
                "end_lineno": 497
            }
        ]
    },
    "sympy__sympy-24102": {
        "sympy/parsing/mathematica.py": [
            {
                "hunk": [
                    "-        token_lists = [tokenizer.findall(i) if isinstance(i, str) else [i] for i in code_splits]",
                    "+        token_lists = [tokenizer.findall(i) if isinstance(i, str) and i.isascii() else [i] for i in code_splits]"
                ],
                "start_lineno": 657,
                "end_lineno": 657
            }
        ]
    },
    "sphinx-doc__sphinx-7350": {
        "sphinx/ext/napoleon/docstring.py": [
            {
                "hunk": [
                    "-                lines.extend(['.. attribute:: ' + _name, ''])",
                    "+                lines.append('.. attribute:: ' + _name)",
                    "+                if self._opt and 'noindex' in self._opt:",
                    "+                    lines.append('   :noindex:')",
                    "+                lines.append('')",
                    "+"
                ],
                "start_lineno": 586,
                "end_lineno": 586
            },
            {
                "hunk": [
                    "+            if self._opt and 'noindex' in self._opt:",
                    "+                lines.append('   :noindex:')"
                ],
                "start_lineno": 644,
                "end_lineno": 644
            }
        ]
    },
    "django__django-7188": {
        "django/contrib/auth/apps.py": [
            {
                "hunk": [
                    "-class AuthConfig(AppConfig):",
                    "+class BaseAuthConfig(AppConfig):",
                    "+    \"\"\"",
                    "+    AppConfig which assumes that the auth models don't exist.",
                    "+    \"\"\"",
                    "     name = 'django.contrib.auth'",
                    "     verbose_name = _(\"Authentication and Authorization\")",
                    " ",
                    "     def ready(self):",
                    "+        checks.register(check_user_model, checks.Tags.models)",
                    "+",
                    "+",
                    "+class AuthConfig(BaseAuthConfig):",
                    "+    \"\"\"",
                    "+    The default AppConfig for auth.",
                    "+    \"\"\"",
                    "+",
                    "+    def ready(self):",
                    "+        super(AuthConfig, self).ready()",
                    "         post_migrate.connect(",
                    "             create_permissions,",
                    "             dispatch_uid=\"django.contrib.auth.management.create_permissions\"",
                    "         )",
                    "-        checks.register(check_user_model, checks.Tags.models)"
                ],
                "start_lineno": 10,
                "end_lineno": 19
            }
        ]
    },
    "django__django-13809": {
        "django/core/management/commands/runserver.py": [
            {
                "hunk": [
                    "+        parser.add_argument(",
                    "+            '--skip-checks', action='store_true',",
                    "+            help='Skip system checks.',",
                    "+        )"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "-        self.stdout.write(\"Performing system checks...\\n\\n\")",
                    "-        self.check(display_num_errors=True)",
                    "+        if not options['skip_checks']:",
                    "+            self.stdout.write('Performing system checks...\\n\\n')",
                    "+            self.check(display_num_errors=True)"
                ],
                "start_lineno": 117,
                "end_lineno": 118
            }
        ]
    },
    "sympy__sympy-15971": {
        "sympy/printing/pretty/pretty.py": [
            {
                "hunk": [
                    "+        from sympy.functions.special.zeta_functions import lerchphi",
                    "         from sympy.functions.special.beta_functions import beta",
                    "         from sympy.functions.special.delta_functions import DiracDelta",
                    "         from sympy.functions.special.error_functions import Chi",
                    "         return {KroneckerDelta: [greek_unicode['delta'], 'delta'],",
                    "                 gamma: [greek_unicode['Gamma'], 'Gamma'],",
                    "+                lerchphi: [greek_unicode['Phi'], 'lerchphi'],"
                ],
                "start_lineno": 1373,
                "end_lineno": 1377
            },
            {
                "hunk": [
                    "+    def _print_lerchphi(self, e):",
                    "+        func_name = greek_unicode['Phi'] if self._use_unicode else 'lerchphi'",
                    "+        return self._print_Function(e, func_name=func_name)",
                    "+"
                ],
                "start_lineno": 1397,
                "end_lineno": 1397
            }
        ]
    },
    "django__django-10531": {
        "django/contrib/admin/models.py": [
            {
                "hunk": [
                    "-                        sub_message['changed']['fields'], gettext('and')",
                    "+                        [gettext(field_name) for field_name in sub_message['changed']['fields']], gettext('and')"
                ],
                "start_lineno": 117,
                "end_lineno": 117
            }
        ],
        "django/contrib/admin/utils.py": [
            {
                "hunk": [
                    "+    # Evaluating `form.changed_data` prior to disabling translations is required",
                    "+    # to avoid fields affected by localization from being included incorrectly,",
                    "+    # e.g. where date formats differ such as MM/DD/YYYY vs DD/MM/YYYY.",
                    "+    changed_data = form.changed_data",
                    "+    with translation_override(None):",
                    "+        # Deactivate translations while fetching verbose_name for form",
                    "+        # field labels and using `field_name`, if verbose_name is not provided.",
                    "+        # Translations will happen later on LogEntry access.",
                    "+        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)",
                    "+",
                    "     change_message = []",
                    "     if add:",
                    "         change_message.append({'added': {}})",
                    "     elif form.changed_data:",
                    "-        change_message.append({'changed': {'fields': form.changed_data}})",
                    "-",
                    "+        change_message.append({'changed': {'fields': changed_field_labels}})"
                ],
                "start_lineno": 492,
                "end_lineno": 497
            },
            {
                "hunk": [
                    "-                            'fields': changed_fields,",
                    "+                            'fields': _get_changed_field_labels_from_form(formset.forms[0], changed_fields),"
                ],
                "start_lineno": 513,
                "end_lineno": 513
            },
            {
                "hunk": [
                    "+",
                    "+",
                    "+def _get_changed_field_labels_from_form(form, changed_data):",
                    "+    changed_field_labels = []",
                    "+    for field_name in changed_data:",
                    "+        try:",
                    "+            verbose_field_name = form.fields[field_name].label or field_name",
                    "+        except KeyError:",
                    "+            verbose_field_name = field_name",
                    "+        changed_field_labels.append(str(verbose_field_name))",
                    "+    return changed_field_labels"
                ],
                "start_lineno": 524,
                "end_lineno": 524
            }
        ]
    },
    "matplotlib__matplotlib-22991": {
        "lib/matplotlib/pyplot.py": [
            {
                "hunk": [
                    "-from matplotlib.figure import Figure, figaspect",
                    "+from matplotlib.figure import Figure, FigureBase, figaspect"
                ],
                "start_lineno": 62,
                "end_lineno": 62
            },
            {
                "hunk": [
                    "-    num : int or str or `.Figure`, optional",
                    "+    num : int or str or `.Figure` or `.SubFigure`, optional"
                ],
                "start_lineno": 693,
                "end_lineno": 693
            },
            {
                "hunk": [
                    "-        window title is set to this value.",
                    "+        window title is set to this value.  If num is a ``SubFigure``, its",
                    "+        parent ``Figure`` is activated."
                ],
                "start_lineno": 705,
                "end_lineno": 705
            },
            {
                "hunk": [
                    "-    if isinstance(num, Figure):",
                    "+    if isinstance(num, FigureBase):",
                    "         if num.canvas.manager is None:",
                    "             raise ValueError(\"The passed figure is not managed by pyplot\")",
                    "         _pylab_helpers.Gcf.set_active(num.canvas.manager)",
                    "-        return num",
                    "+        return num.figure"
                ],
                "start_lineno": 756,
                "end_lineno": 760
            }
        ]
    },
    "sympy__sympy-18478": {
        "sympy/core/add.py": [
            {
                "hunk": [
                    "-                if coeff.is_Number:",
                    "+                if coeff.is_Number or isinstance(coeff, AccumBounds):"
                ],
                "start_lineno": 142,
                "end_lineno": 142
            }
        ]
    },
    "scikit-learn__scikit-learn-13010": {
        "sklearn/utils/extmath.py": [
            {
                "hunk": [
                    "+# Use at least float64 for the accumulating functions to avoid precision issue",
                    "+# see https://github.com/numpy/numpy/issues/9393. The float64 is also retained",
                    "+# as it is in case the float overflows",
                    "+def _safe_accumulator_op(op, x, *args, **kwargs):",
                    "+    \"\"\"",
                    "+    This function provides numpy accumulator functions with a float64 dtype",
                    "+    when used on a floating point input. This prevents accumulator overflow on",
                    "+    smaller floating point dtypes.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    op : function",
                    "+        A numpy accumulator function such as np.mean or np.sum",
                    "+    x : numpy array",
                    "+        A numpy array to apply the accumulator function",
                    "+    *args : positional arguments",
                    "+        Positional arguments passed to the accumulator function after the",
                    "+        input x",
                    "+    **kwargs : keyword arguments",
                    "+        Keyword arguments passed to the accumulator function",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    result : The output of the accumulator function passed to this function",
                    "+    \"\"\"",
                    "+    if np.issubdtype(x.dtype, np.floating) and x.dtype.itemsize < 8:",
                    "+        result = op(x, *args, **kwargs, dtype=np.float64)",
                    "+    else:",
                    "+        result = op(x, *args, **kwargs)",
                    "+    return result",
                    "+",
                    "+"
                ],
                "start_lineno": 661,
                "end_lineno": 661
            },
            {
                "hunk": [
                    "-    if np.issubdtype(X.dtype, np.floating) and X.dtype.itemsize < 8:",
                    "-        # Use at least float64 for the accumulator to avoid precision issues;",
                    "-        # see https://github.com/numpy/numpy/issues/9393",
                    "-        new_sum = np.nansum(X, axis=0, dtype=np.float64).astype(X.dtype)",
                    "-    else:",
                    "-        new_sum = np.nansum(X, axis=0)",
                    "+    new_sum = _safe_accumulator_op(np.nansum, X, axis=0)"
                ],
                "start_lineno": 711,
                "end_lineno": 716
            },
            {
                "hunk": [
                    "-        new_unnormalized_variance = np.nanvar(X, axis=0) * new_sample_count",
                    "+        new_unnormalized_variance = (",
                    "+            _safe_accumulator_op(np.nanvar, X, axis=0) * new_sample_count)"
                ],
                "start_lineno": 726,
                "end_lineno": 726
            }
        ],
        "sklearn/utils/validation.py": [
            {
                "hunk": [
                    "+    # validation is also imported in extmath",
                    "+    from .extmath import _safe_accumulator_op",
                    "+",
                    "     if _get_config()['assume_finite']:",
                    "         return",
                    "     X = np.asanyarray(X)",
                    "     # First try an O(n) time, O(1) space solution for the common case that",
                    "     # everything is finite; fall back to O(n) space np.isfinite to prevent",
                    "-    # false positives from overflow in sum method.",
                    "+    # false positives from overflow in sum method. The sum is also calculated",
                    "+    # safely to reduce dtype induced overflows.",
                    "     is_float = X.dtype.kind in 'fc'",
                    "-    if is_float and np.isfinite(X.sum()):",
                    "+    if is_float and (np.isfinite(_safe_accumulator_op(np.sum, X))):"
                ],
                "start_lineno": 37,
                "end_lineno": 44
            }
        ]
    },
    "django__django-11088": {
        "django/db/models/fields/__init__.py": [
            {
                "hunk": [
                    "+    def check(self, **kwargs):",
                    "+        return [*super().check(**kwargs), *self._check_str_default_value()]",
                    "+",
                    "+    def _check_str_default_value(self):",
                    "+        if self.has_default() and isinstance(self.default, str):",
                    "+            return [",
                    "+                checks.Error(",
                    "+                    \"BinaryField's default cannot be a string. Use bytes \"",
                    "+                    \"content instead.\",",
                    "+                    obj=self,",
                    "+                    id='fields.E170',",
                    "+                )",
                    "+            ]",
                    "+        return []",
                    "+"
                ],
                "start_lineno": 2255,
                "end_lineno": 2255
            }
        ]
    },
    "django__django-11099": {
        "django/contrib/auth/validators.py": [
            {
                "hunk": [
                    "-    regex = r'^[\\w.@+-]+$'",
                    "+    regex = r'^[\\w.@+-]+\\Z'"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "-    regex = r'^[\\w.@+-]+$'",
                    "+    regex = r'^[\\w.@+-]+\\Z'"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            }
        ]
    },
    "sphinx-doc__sphinx-7762": {
        "sphinx/builders/linkcheck.py": [
            {
                "hunk": [
                    "-from urllib.parse import unquote",
                    "+from urllib.parse import unquote, urlparse"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "+DEFAULT_REQUEST_HEADERS = {",
                    "+    'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',",
                    "+}",
                    "+",
                    "+"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            },
            {
                "hunk": [
                    "-            'headers': {",
                    "-                'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',",
                    "-            },",
                    "-        }",
                    "+        }  # type: Dict",
                    "         if self.app.config.linkcheck_timeout:",
                    "             kwargs['timeout'] = self.app.config.linkcheck_timeout",
                    " ",
                    "+        def get_request_headers() -> Dict:",
                    "+            url = urlparse(uri)",
                    "+            candidates = [\"%s://%s\" % (url.scheme, url.netloc),",
                    "+                          \"%s://%s/\" % (url.scheme, url.netloc),",
                    "+                          uri,",
                    "+                          \"*\"]",
                    "+",
                    "+            for u in candidates:",
                    "+                if u in self.config.linkcheck_request_headers:",
                    "+                    headers = dict(DEFAULT_REQUEST_HEADERS)",
                    "+                    headers.update(self.config.linkcheck_request_headers[u])",
                    "+                    return headers",
                    "+",
                    "+            return {}",
                    "+"
                ],
                "start_lineno": 110,
                "end_lineno": 116
            },
            {
                "hunk": [
                    "+            # update request headers for the URL",
                    "+            kwargs['headers'] = get_request_headers()",
                    "+"
                ],
                "start_lineno": 142,
                "end_lineno": 142
            },
            {
                "hunk": [
                    "+    app.add_config_value('linkcheck_request_headers', {}, None)"
                ],
                "start_lineno": 340,
                "end_lineno": 340
            }
        ]
    },
    "scikit-learn__scikit-learn-11585": {
        "examples/decomposition/plot_faces_decomposition.py": [
            {
                "hunk": [
                    "-                                      random_state=rng),",
                    "+                                      random_state=rng,",
                    "+                                      normalize_components=True),"
                ],
                "start_lineno": 84,
                "end_lineno": 84
            }
        ],
        "sklearn/decomposition/sparse_pca.py": [
            {
                "hunk": [
                    "+    normalize_components : boolean, optional (default=False)",
                    "+        - if False, use a version of Sparse PCA without components",
                    "+          normalization and without data centering. This is likely a bug and",
                    "+          even though it's the default for backward compatibility,",
                    "+          this should not be used.",
                    "+        - if True, use a version of Sparse PCA with components normalization",
                    "+          and data centering.",
                    "+",
                    "+        .. versionadded:: 0.20",
                    "+",
                    "+        .. deprecated:: 0.22",
                    "+           ``normalize_components`` was added and set to ``False`` for",
                    "+           backward compatibility. It would be set to ``True`` from 0.22",
                    "+           onwards.",
                    "+"
                ],
                "start_lineno": 69,
                "end_lineno": 69
            },
            {
                "hunk": [
                    "+    mean_ : array, shape (n_features,)",
                    "+        Per-feature empirical mean, estimated from the training set.",
                    "+        Equal to ``X.mean(axis=0)``.",
                    "+"
                ],
                "start_lineno": 80,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "-                 V_init=None, verbose=False, random_state=None):",
                    "+                 V_init=None, verbose=False, random_state=None,",
                    "+                 normalize_components=False):"
                ],
                "start_lineno": 88,
                "end_lineno": 88
            },
            {
                "hunk": [
                    "+        self.normalize_components = normalize_components"
                ],
                "start_lineno": 100,
                "end_lineno": 100
            },
            {
                "hunk": [
                    "+",
                    "+        if self.normalize_components:",
                    "+            self.mean_ = X.mean(axis=0)",
                    "+            X = X - self.mean_",
                    "+        else:",
                    "+            warnings.warn(\"normalize_components=False is a \"",
                    "+                          \"backward-compatible setting that implements a \"",
                    "+                          \"non-standard definition of sparse PCA. This \"",
                    "+                          \"compatibility mode will be removed in 0.22.\",",
                    "+                          DeprecationWarning)",
                    "+"
                ],
                "start_lineno": 119,
                "end_lineno": 119
            },
            {
                "hunk": [
                    "+",
                    "+        if self.normalize_components:",
                    "+            components_norm = \\",
                    "+                    np.linalg.norm(self.components_, axis=1)[:, np.newaxis]",
                    "+            components_norm[components_norm == 0] = 1",
                    "+            self.components_ /= components_norm",
                    "+"
                ],
                "start_lineno": 137,
                "end_lineno": 137
            },
            {
                "hunk": [
                    "+",
                    "+        if self.normalize_components:",
                    "+            X = X - self.mean_",
                    "+",
                    "         U = ridge_regression(self.components_.T, X.T, ridge_alpha,",
                    "                              solver='cholesky')",
                    "-        s = np.sqrt((U ** 2).sum(axis=0))",
                    "-        s[s == 0] = 1",
                    "-        U /= s",
                    "+",
                    "+        if not self.normalize_components:",
                    "+            s = np.sqrt((U ** 2).sum(axis=0))",
                    "+            s[s == 0] = 1",
                    "+            U /= s",
                    "+"
                ],
                "start_lineno": 181,
                "end_lineno": 185
            },
            {
                "hunk": [
                    "+    normalize_components : boolean, optional (default=False)",
                    "+        - if False, use a version of Sparse PCA without components",
                    "+          normalization and without data centering. This is likely a bug and",
                    "+          even though it's the default for backward compatibility,",
                    "+          this should not be used.",
                    "+        - if True, use a version of Sparse PCA with components normalization",
                    "+          and data centering.",
                    "+",
                    "+        .. versionadded:: 0.20",
                    "+",
                    "+        .. deprecated:: 0.22",
                    "+           ``normalize_components`` was added and set to ``False`` for",
                    "+           backward compatibility. It would be set to ``True`` from 0.22",
                    "+           onwards.",
                    "+"
                ],
                "start_lineno": 242,
                "end_lineno": 242
            },
            {
                "hunk": [
                    "+    mean_ : array, shape (n_features,)",
                    "+        Per-feature empirical mean, estimated from the training set.",
                    "+        Equal to ``X.mean(axis=0)``.",
                    "+"
                ],
                "start_lineno": 250,
                "end_lineno": 250
            },
            {
                "hunk": [
                    "-                 shuffle=True, n_jobs=1, method='lars', random_state=None):",
                    "+                 shuffle=True, n_jobs=1, method='lars', random_state=None,",
                    "+                 normalize_components=False):",
                    "         super(MiniBatchSparsePCA, self).__init__(",
                    "             n_components=n_components, alpha=alpha, verbose=verbose,",
                    "             ridge_alpha=ridge_alpha, n_jobs=n_jobs, method=method,",
                    "-            random_state=random_state)",
                    "+            random_state=random_state,",
                    "+            normalize_components=normalize_components)"
                ],
                "start_lineno": 258,
                "end_lineno": 262
            },
            {
                "hunk": [
                    "+",
                    "+        if self.normalize_components:",
                    "+            self.mean_ = X.mean(axis=0)",
                    "+            X = X - self.mean_",
                    "+        else:",
                    "+            warnings.warn(\"normalize_components=False is a \"",
                    "+                          \"backward-compatible setting that implements a \"",
                    "+                          \"non-standard definition of sparse PCA. This \"",
                    "+                          \"compatibility mode will be removed in 0.22.\",",
                    "+                          DeprecationWarning)",
                    "+"
                ],
                "start_lineno": 286,
                "end_lineno": 286
            },
            {
                "hunk": [
                    "+",
                    "+        if self.normalize_components:",
                    "+            components_norm = \\",
                    "+                    np.linalg.norm(self.components_, axis=1)[:, np.newaxis]",
                    "+            components_norm[components_norm == 0] = 1",
                    "+            self.components_ /= components_norm",
                    "+"
                ],
                "start_lineno": 301,
                "end_lineno": 301
            }
        ]
    },
    "scikit-learn__scikit-learn-12486": {
        "sklearn/metrics/scorer.py": [
            {
                "hunk": [
                    "-            y_pred = y_pred[:, 1]",
                    "+            if y_pred.shape[1] == 2:",
                    "+                y_pred = y_pred[:, 1]",
                    "+            else:",
                    "+                raise ValueError('got predict_proba of shape {},'",
                    "+                                 ' but need classifier with two'",
                    "+                                 ' classes for {} scoring'.format(",
                    "+                                     y_pred.shape, self._score_func.__name__))"
                ],
                "start_lineno": 129,
                "end_lineno": 129
            },
            {
                "hunk": [
                    "-                    y_pred = y_pred[:, 1]",
                    "+                    if y_pred.shape[1] == 2:",
                    "+                        y_pred = y_pred[:, 1]",
                    "+                    else:",
                    "+                        raise ValueError('got predict_proba of shape {},'",
                    "+                                         ' but need classifier with two'",
                    "+                                         ' classes for {} scoring'.format(",
                    "+                                             y_pred.shape,",
                    "+                                             self._score_func.__name__))"
                ],
                "start_lineno": 186,
                "end_lineno": 186
            }
        ]
    },
    "django__django-13800": {
        "django/contrib/messages/storage/cookie.py": [
            {
                "hunk": [
                    "-    def __init__(self, *args, **kwargs):",
                    "-        kwargs.setdefault('separators', (',', ':'))",
                    "-        super().__init__(*args, **kwargs)",
                    "-"
                ],
                "start_lineno": 17,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "+class MessageSerializer:",
                    "+    def dumps(self, obj):",
                    "+        return json.dumps(",
                    "+            obj,",
                    "+            separators=(',', ':'),",
                    "+            cls=MessageEncoder,",
                    "+        ).encode('latin-1')",
                    "+",
                    "+    def loads(self, data):",
                    "+        return json.loads(data.decode('latin-1'), cls=MessageDecoder)",
                    "+",
                    "+"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            },
            {
                "hunk": [
                    "-            encoder = MessageEncoder()",
                    "-            value = encoder.encode(messages)",
                    "-            return self.signer.sign(value)",
                    "+            return self.signer.sign_object(messages, serializer=MessageSerializer, compress=True)"
                ],
                "start_lineno": 155,
                "end_lineno": 157
            },
            {
                "hunk": [
                    "-            decoded = self.signer.unsign(data)",
                    "+            return self.signer.unsign_object(data, serializer=MessageSerializer)",
                    "+        # RemovedInDjango41Warning: when the deprecation ends, replace with:",
                    "+        #",
                    "+        # except (signing.BadSignature, json.JSONDecodeError):",
                    "+        #     pass",
                    "         except signing.BadSignature:",
                    "             # RemovedInDjango40Warning: when the deprecation ends, replace",
                    "             # with:",
                    "             #   decoded = None.",
                    "             decoded = self._legacy_decode(data)",
                    "+        except json.JSONDecodeError:",
                    "+            decoded = self.signer.unsign(data)",
                    "+",
                    "         if decoded:",
                    "+            # RemovedInDjango41Warning."
                ],
                "start_lineno": 169,
                "end_lineno": 175
            }
        ]
    },
    "django__django-16517": {
        "django/contrib/admindocs/utils.py": [
            {
                "hunk": [
                    "+    # Views and template names are case-sensitive.",
                    "+    is_case_sensitive = rolename in [\"template\", \"view\"]",
                    "+"
                ],
                "start_lineno": 104,
                "end_lineno": 104
            },
            {
                "hunk": [
                    "-                    text.lower(),",
                    "+                    text if is_case_sensitive else text.lower(),"
                ],
                "start_lineno": 114,
                "end_lineno": 114
            }
        ]
    },
    "django__django-14309": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-@deconstructible"
                ],
                "start_lineno": 150,
                "end_lineno": 150
            },
            {
                "hunk": [
                    "+",
                    "+@deconstructible",
                    "+class Expression(BaseExpression, Combinable):",
                    "+    \"\"\"An expression that can be combined with other expressions.\"\"\"",
                    "+"
                ],
                "start_lineno": 392,
                "end_lineno": 392
            },
            {
                "hunk": [
                    "-        if not isinstance(other, BaseExpression):",
                    "+        if not isinstance(other, Expression):"
                ],
                "start_lineno": 412,
                "end_lineno": 412
            },
            {
                "hunk": [
                    "-class Expression(BaseExpression, Combinable):",
                    "-    \"\"\"An expression that can be combined with other expressions.\"\"\"",
                    "-    pass",
                    "-",
                    "-"
                ],
                "start_lineno": 420,
                "end_lineno": 424
            },
            {
                "hunk": [
                    "-class Subquery(Expression):",
                    "+class Subquery(BaseExpression, Combinable):"
                ],
                "start_lineno": 1106,
                "end_lineno": 1106
            },
            {
                "hunk": [
                    "-    def __getstate__(self):",
                    "-        state = super().__getstate__()",
                    "-        args, kwargs = state['_constructor_args']",
                    "-        if args:",
                    "-            args = (self.query, *args[1:])",
                    "-        else:",
                    "-            kwargs['queryset'] = self.query",
                    "-        state['_constructor_args'] = args, kwargs",
                    "-        return state",
                    "-"
                ],
                "start_lineno": 1120,
                "end_lineno": 1129
            },
            {
                "hunk": [
                    "+@deconstructible"
                ],
                "start_lineno": 1206,
                "end_lineno": 1206
            }
        ],
        "django/db/models/query_utils.py": [
            {
                "hunk": [
                    "+import copy"
                ],
                "start_lineno": 8,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-        # If the other Q() is empty, ignore it and just use `self`.",
                    "-        if not other:",
                    "+        if not self:",
                    "+            return other.copy() if hasattr(other, 'copy') else copy.copy(other)",
                    "+        elif isinstance(other, Q) and not other:",
                    "             _, args, kwargs = self.deconstruct()",
                    "             return type(self)(*args, **kwargs)",
                    "-        # Or if this Q is empty, ignore it and just use `other`.",
                    "-        elif not self:",
                    "-            _, args, kwargs = other.deconstruct()",
                    "-            return type(other)(*args, **kwargs)"
                ],
                "start_lineno": 46,
                "end_lineno": 53
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-from django.utils.hashable import make_hashable"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            },
            {
                "hunk": [
                    "-    @property",
                    "-    def identity(self):",
                    "-        identity = (",
                    "-            (arg, make_hashable(value))",
                    "-            for arg, value in self.__dict__.items()",
                    "-        )",
                    "-        return (self.__class__, *identity)",
                    "-"
                ],
                "start_lineno": 253,
                "end_lineno": 260
            }
        ]
    },
    "sphinx-doc__sphinx-9797": {
        "sphinx/util/inspect.py": [
            {
                "hunk": [
                    "-                return getdoc(meth.__func__)",
                    "+                doc = getdoc(meth.__func__)",
                    "+                if doc is not None or not allow_inherited:",
                    "+                    return doc"
                ],
                "start_lineno": 869,
                "end_lineno": 869
            }
        ]
    },
    "scikit-learn__scikit-learn-10397": {
        "sklearn/linear_model/ridge.py": [
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 781,
                "end_lineno": 781
            },
            {
                "hunk": [
                    "+        if np.any(self.alphas < 0):",
                    "+            raise ValueError(\"alphas cannot be negative. \"",
                    "+                             \"Got {} containing some \"",
                    "+                             \"negative value instead.\".format(self.alphas))",
                    "+",
                    "         for i, alpha in enumerate(self.alphas):",
                    "             if error:",
                    "-                out, c = _errors(alpha, y, v, Q, QT_y)",
                    "+                out, c = _errors(float(alpha), y, v, Q, QT_y)",
                    "             else:",
                    "-                out, c = _values(alpha, y, v, Q, QT_y)",
                    "+                out, c = _values(float(alpha), y, v, Q, QT_y)"
                ],
                "start_lineno": 1044,
                "end_lineno": 1048
            },
            {
                "hunk": [
                    "-        self.alphas = alphas",
                    "+        self.alphas = np.asarray(alphas)"
                ],
                "start_lineno": 1088,
                "end_lineno": 1088
            },
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 1331,
                "end_lineno": 1331
            }
        ]
    },
    "django__django-11477": {
        "django/urls/resolvers.py": [
            {
                "hunk": [
                    "-            kwargs = match.groupdict()",
                    "+            kwargs = {k: v for k, v in match.groupdict().items() if v is not None}"
                ],
                "start_lineno": 156,
                "end_lineno": 156
            }
        ]
    },
    "django__django-15738": {
        "django/db/migrations/autodetector.py": [
            {
                "hunk": [
                    "-        # Fields that are foreignkeys/m2ms depend on stuff",
                    "-        dependencies = []",
                    "+        # Adding a field always depends at least on its removal.",
                    "+        dependencies = [(app_label, model_name, field_name, False)]",
                    "+        # Fields that are foreignkeys/m2ms depend on stuff."
                ],
                "start_lineno": 1025,
                "end_lineno": 1026
            }
        ]
    },
    "django__django-14182": {
        "django/db/backends/sqlite3/features.py": [
            {
                "hunk": [
                    "+            \"SQLite doesn't support negative precision for ROUND().\": {",
                    "+                'db_functions.math.test_round.RoundTests.test_null_with_negative_precision',",
                    "+                'db_functions.math.test_round.RoundTests.test_decimal_with_negative_precision',",
                    "+                'db_functions.math.test_round.RoundTests.test_float_with_negative_precision',",
                    "+                'db_functions.math.test_round.RoundTests.test_integer_with_negative_precision',",
                    "+            },"
                ],
                "start_lineno": 68,
                "end_lineno": 68
            }
        ],
        "django/db/models/functions/math.py": [
            {
                "hunk": [
                    "-from django.db.models.expressions import Func",
                    "+from django.db.models.expressions import Func, Value"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-class Round(Transform):",
                    "+class Round(FixDecimalInputMixin, Transform):",
                    "     function = 'ROUND'",
                    "     lookup_name = 'round'",
                    "+    arity = None  # Override Transform's arity=1 to enable passing precision.",
                    "+",
                    "+    def __init__(self, expression, precision=0, **extra):",
                    "+        super().__init__(expression, precision, **extra)",
                    "+",
                    "+    def as_sqlite(self, compiler, connection, **extra_context):",
                    "+        precision = self.get_source_expressions()[1]",
                    "+        if isinstance(precision, Value) and precision.value < 0:",
                    "+            raise ValueError('SQLite does not support negative precision.')",
                    "+        return super().as_sqlite(compiler, connection, **extra_context)",
                    "+",
                    "+    def _resolve_output_field(self):",
                    "+        source = self.get_source_expressions()[0]",
                    "+        return source.output_field"
                ],
                "start_lineno": 161,
                "end_lineno": 163
            }
        ]
    },
    "sympy__sympy-17821": {
        "sympy/core/numbers.py": [
            {
                "hunk": [
                    "+    def _eval_rewrite_as_Sum(self, k_sym=None, symbols=None):",
                    "+        from sympy import Sum, Dummy",
                    "+        if (k_sym is not None) or (symbols is not None):",
                    "+            return self",
                    "+        k = Dummy('k', integer=True, nonnegative=True)",
                    "+        return Sum((-1)**k / (2*k+1)**2, (k, 0, S.Infinity))",
                    "+"
                ],
                "start_lineno": 3832,
                "end_lineno": 3832
            }
        ]
    },
    "django__django-13341": {
        "django/views/generic/base.py": [
            {
                "hunk": [
                    "-import warnings"
                ],
                "start_lineno": 2,
                "end_lineno": 2
            },
            {
                "hunk": [
                    "-from django.utils.deprecation import RemovedInDjango40Warning",
                    "-from django.utils.functional import lazy"
                ],
                "start_lineno": 13,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "-    \"\"\"Render a template.\"\"\"",
                    "+    \"\"\"",
                    "+    Render a template. Pass keyword arguments from the URLconf to the context.",
                    "+    \"\"\"",
                    "     def get(self, request, *args, **kwargs):",
                    "-        # RemovedInDjango40Warning: when the deprecation ends, replace with:",
                    "-        #   context = self.get_context_data()",
                    "-        context_kwargs = _wrap_url_kwargs_with_deprecation_warning(kwargs)",
                    "-        context = self.get_context_data(**context_kwargs)",
                    "+        context = self.get_context_data(**kwargs)",
                    "         return self.render_to_response(context)",
                    " ",
                    " ",
                    "-# RemovedInDjango40Warning",
                    "-def _wrap_url_kwargs_with_deprecation_warning(url_kwargs):",
                    "-    context_kwargs = {}",
                    "-    for key, value in url_kwargs.items():",
                    "-        # Bind into function closure.",
                    "-        def access_value(key=key, value=value):",
                    "-            warnings.warn(",
                    "-                'TemplateView passing URL kwargs to the context is '",
                    "-                'deprecated. Reference %s in your template through '",
                    "-                'view.kwargs instead.' % key,",
                    "-                RemovedInDjango40Warning, stacklevel=2,",
                    "-            )",
                    "-            return value",
                    "-        context_kwargs[key] = lazy(access_value, type(value))()",
                    "-    return context_kwargs",
                    "-",
                    "-"
                ],
                "start_lineno": 158,
                "end_lineno": 183
            }
        ]
    },
    "django__django-8119": {
        "django/db/backends/base/operations.py": [
            {
                "hunk": [
                    "+    def conditional_expression_supported_in_where_clause(self, expression):",
                    "+        \"\"\"",
                    "+        Return True, if the conditional expression is supported in the WHERE",
                    "+        clause.",
                    "+        \"\"\"",
                    "+        return True",
                    "+"
                ],
                "start_lineno": 584,
                "end_lineno": 584
            }
        ],
        "django/db/backends/oracle/operations.py": [
            {
                "hunk": [
                    "+from django.db.models.expressions import Exists, ExpressionWrapper",
                    "+from django.db.models.query_utils import Q"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+",
                    "+    def conditional_expression_supported_in_where_clause(self, expression):",
                    "+        \"\"\"",
                    "+        Oracle supports only EXISTS(...) or filters in the WHERE clause, others",
                    "+        must be compared with True.",
                    "+        \"\"\"",
                    "+        if isinstance(expression, Exists):",
                    "+            return True",
                    "+        if isinstance(expression, ExpressionWrapper) and isinstance(expression.expression, Q):",
                    "+            return True",
                    "+        return False"
                ],
                "start_lineno": 610,
                "end_lineno": 610
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):",
                    "+            return Q(self) & Q(other)"
                ],
                "start_lineno": 93,
                "end_lineno": 93
            },
            {
                "hunk": [
                    "+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):",
                    "+            return Q(self) | Q(other)"
                ],
                "start_lineno": 107,
                "end_lineno": 107
            },
            {
                "hunk": [
                    "+    @property",
                    "+    def conditional(self):",
                    "+        return isinstance(self.output_field, fields.BooleanField)",
                    "+"
                ],
                "start_lineno": 248,
                "end_lineno": 248
            },
            {
                "hunk": [
                    "+    # This isn't a complete conditional expression, must be used in Case().",
                    "+    conditional = False",
                    " ",
                    "     def __init__(self, condition=None, then=None, **lookups):",
                    "         if lookups and condition is None:",
                    "             condition, lookups = Q(**lookups), None",
                    "         if condition is None or not getattr(condition, 'conditional', False) or lookups:",
                    "-            raise TypeError(\"__init__() takes either a Q object or lookups as keyword arguments\")",
                    "+            raise TypeError(",
                    "+                'When() supports a Q object, a boolean expression, or lookups '",
                    "+                'as a condition.'",
                    "+            )"
                ],
                "start_lineno": 876,
                "end_lineno": 881
            },
            {
                "hunk": [
                    "+    conditional = False"
                ],
                "start_lineno": 1093,
                "end_lineno": 1093
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "+        if hasattr(filter_expr, 'resolve_expression') and getattr(filter_expr, 'conditional', False):",
                    "+            if connections[DEFAULT_DB_ALIAS].ops.conditional_expression_supported_in_where_clause(filter_expr):",
                    "+                condition = filter_expr.resolve_expression(self)",
                    "+            else:",
                    "+                # Expression is not supported in the WHERE clause, add",
                    "+                # comparison with True.",
                    "+                condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self), True)",
                    "+            clause = self.where_class()",
                    "+            clause.add(condition, AND)",
                    "+            return clause, []"
                ],
                "start_lineno": 1232,
                "end_lineno": 1232
            }
        ]
    },
    "pydata__xarray-4442": {
        "xarray/core/coordinates.py": [
            {
                "hunk": [
                    "+import numpy as np"
                ],
                "start_lineno": 16,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "-            names = list(ordered_dims)",
                    "-            return pd.MultiIndex.from_product(indexes, names=names)",
                    "+",
                    "+            # compute the sizes of the repeat and tile for the cartesian product",
                    "+            # (taken from pandas.core.reshape.util)",
                    "+            index_lengths = np.fromiter(",
                    "+                (len(index) for index in indexes), dtype=np.intp",
                    "+            )",
                    "+            cumprod_lengths = np.cumproduct(index_lengths)",
                    "+",
                    "+            if cumprod_lengths[-1] != 0:",
                    "+                # sizes of the repeats",
                    "+                repeat_counts = cumprod_lengths[-1] / cumprod_lengths",
                    "+            else:",
                    "+                # if any factor is empty, the cartesian product is empty",
                    "+                repeat_counts = np.zeros_like(cumprod_lengths)",
                    "+",
                    "+            # sizes of the tiles",
                    "+            tile_counts = np.roll(cumprod_lengths, 1)",
                    "+            tile_counts[0] = 1",
                    "+",
                    "+            # loop over the indexes",
                    "+            # for each MultiIndex or Index compute the cartesian product of the codes",
                    "+",
                    "+            code_list = []",
                    "+            level_list = []",
                    "+            names = []",
                    "+",
                    "+            for i, index in enumerate(indexes):",
                    "+                if isinstance(index, pd.MultiIndex):",
                    "+                    codes, levels = index.codes, index.levels",
                    "+                else:",
                    "+                    code, level = pd.factorize(index)",
                    "+                    codes = [code]",
                    "+                    levels = [level]",
                    "+",
                    "+                # compute the cartesian product",
                    "+                code_list += [",
                    "+                    np.tile(np.repeat(code, repeat_counts[i]), tile_counts[i])",
                    "+                    for code in codes",
                    "+                ]",
                    "+                level_list += levels",
                    "+                names += index.names",
                    "+",
                    "+            return pd.MultiIndex(level_list, code_list, names=names)"
                ],
                "start_lineno": 110,
                "end_lineno": 111
            }
        ]
    },
    "sphinx-doc__sphinx-8278": {
        "sphinx/pycode/ast.py": [
            {
                "hunk": [
                    "-def unparse(node: Optional[ast.AST]) -> Optional[str]:",
                    "+def unparse(node: Optional[ast.AST], code: str = '') -> Optional[str]:",
                    "     \"\"\"Unparse an AST to string.\"\"\"",
                    "     if node is None:",
                    "         return None",
                    "     elif isinstance(node, str):",
                    "         return node",
                    "-    return _UnparseVisitor().visit(node)",
                    "+    return _UnparseVisitor(code).visit(node)",
                    " ",
                    " ",
                    " # a greatly cut-down version of `ast._Unparser`",
                    " class _UnparseVisitor(ast.NodeVisitor):",
                    "+    def __init__(self, code: str = '') -> None:",
                    "+        self.code = code"
                ],
                "start_lineno": 61,
                "end_lineno": 71
            },
            {
                "hunk": [
                    "+            elif isinstance(node.value, (int, float, complex)):",
                    "+                if self.code and sys.version_info > (3, 8):",
                    "+                    return ast.get_source_segment(self.code, node)",
                    "+                else:",
                    "+                    return repr(node.value)"
                ],
                "start_lineno": 198,
                "end_lineno": 198
            }
        ],
        "sphinx/util/inspect.py": [
            {
                "hunk": [
                    "-    module = ast.parse('def func' + signature + ': pass')",
                    "+    code = 'def func' + signature + ': pass'",
                    "+    module = ast.parse(code)",
                    "     function = cast(ast.FunctionDef, module.body[0])  # type: ignore",
                    " ",
                    "-    return signature_from_ast(function)",
                    "+    return signature_from_ast(function, code)",
                    " ",
                    " ",
                    "-def signature_from_ast(node: ast.FunctionDef) -> inspect.Signature:",
                    "+def signature_from_ast(node: ast.FunctionDef, code: str = '') -> inspect.Signature:"
                ],
                "start_lineno": 603,
                "end_lineno": 609
            },
            {
                "hunk": [
                    "-                default = ast_unparse(defaults[i])",
                    "+                default = ast_unparse(defaults[i], code)",
                    " ",
                    "-            annotation = ast_unparse(arg.annotation) or Parameter.empty",
                    "+            annotation = ast_unparse(arg.annotation, code) or Parameter.empty"
                ],
                "start_lineno": 629,
                "end_lineno": 631
            },
            {
                "hunk": [
                    "-            default = ast_unparse(defaults[i + posonlyargs])",
                    "+            default = ast_unparse(defaults[i + posonlyargs], code)",
                    " ",
                    "-        annotation = ast_unparse(arg.annotation) or Parameter.empty",
                    "+        annotation = ast_unparse(arg.annotation, code) or Parameter.empty",
                    "         params.append(Parameter(arg.arg, Parameter.POSITIONAL_OR_KEYWORD,",
                    "                                 default=default, annotation=annotation))",
                    " ",
                    "     if args.vararg:",
                    "-        annotation = ast_unparse(args.vararg.annotation) or Parameter.empty",
                    "+        annotation = ast_unparse(args.vararg.annotation, code) or Parameter.empty",
                    "         params.append(Parameter(args.vararg.arg, Parameter.VAR_POSITIONAL,",
                    "                                 annotation=annotation))",
                    " ",
                    "     for i, arg in enumerate(args.kwonlyargs):",
                    "-        default = ast_unparse(args.kw_defaults[i]) or Parameter.empty",
                    "-        annotation = ast_unparse(arg.annotation) or Parameter.empty",
                    "+        default = ast_unparse(args.kw_defaults[i], code) or Parameter.empty",
                    "+        annotation = ast_unparse(arg.annotation, code) or Parameter.empty",
                    "         params.append(Parameter(arg.arg, Parameter.KEYWORD_ONLY, default=default,",
                    "                                 annotation=annotation))",
                    " ",
                    "     if args.kwarg:",
                    "-        annotation = ast_unparse(args.kwarg.annotation) or Parameter.empty",
                    "+        annotation = ast_unparse(args.kwarg.annotation, code) or Parameter.empty",
                    "         params.append(Parameter(args.kwarg.arg, Parameter.VAR_KEYWORD,",
                    "                                 annotation=annotation))",
                    " ",
                    "-    return_annotation = ast_unparse(node.returns) or Parameter.empty",
                    "+    return_annotation = ast_unparse(node.returns, code) or Parameter.empty"
                ],
                "start_lineno": 639,
                "end_lineno": 661
            }
        ]
    },
    "sympy__sympy-21612": {
        "sympy/printing/str.py": [
            {
                "hunk": [
                    "-                            isinstance(item.base, Mul)):",
                    "+                            isinstance(item.base, (Mul, Pow))):"
                ],
                "start_lineno": 336,
                "end_lineno": 336
            }
        ]
    },
    "pytest-dev__pytest-10893": {
        "src/_pytest/pathlib.py": [
            {
                "hunk": [
                    "+import types"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+from typing import Tuple",
                    "+from typing import Type"
                ],
                "start_lineno": 31,
                "end_lineno": 31
            },
            {
                "hunk": [
                    "-def on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:",
                    "+def on_rm_rf_error(",
                    "+    func,",
                    "+    path: str,",
                    "+    excinfo: Union[",
                    "+        BaseException,",
                    "+        Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],",
                    "+    ],",
                    "+    *,",
                    "+    start_path: Path,",
                    "+) -> bool:",
                    "     \"\"\"Handle known read-only errors during rmtree.",
                    " ",
                    "     The returned value is used only by our own tests.",
                    "     \"\"\"",
                    "-    exctype, excvalue = exc[:2]",
                    "+    if isinstance(excinfo, BaseException):",
                    "+        exc = excinfo",
                    "+    else:",
                    "+        exc = excinfo[1]",
                    " ",
                    "     # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).",
                    "     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018",
                    "-    if isinstance(excvalue, FileNotFoundError):",
                    "+    if isinstance(exc, FileNotFoundError):",
                    "         return False",
                    " ",
                    "-    if not isinstance(excvalue, PermissionError):",
                    "+    if not isinstance(exc, PermissionError):",
                    "         warnings.warn(",
                    "-            PytestWarning(f\"(rm_rf) error removing {path}\\n{exctype}: {excvalue}\")",
                    "+            PytestWarning(f\"(rm_rf) error removing {path}\\n{type(exc)}: {exc}\")"
                ],
                "start_lineno": 66,
                "end_lineno": 80
            },
            {
                "hunk": [
                    "-                        func, path, exctype, excvalue",
                    "+                        func, path, type(exc), exc"
                ],
                "start_lineno": 89,
                "end_lineno": 89
            },
            {
                "hunk": [
                    "-    shutil.rmtree(str(path), onerror=onerror)",
                    "+    if sys.version_info >= (3, 12):",
                    "+        shutil.rmtree(str(path), onexc=onerror)",
                    "+    else:",
                    "+        shutil.rmtree(str(path), onerror=onerror)"
                ],
                "start_lineno": 152,
                "end_lineno": 152
            }
        ],
        "src/_pytest/unittest.py": [
            {
                "hunk": [
                    "+    def addDuration(self, testcase: \"unittest.TestCase\", elapsed: float) -> None:",
                    "+        pass",
                    "+"
                ],
                "start_lineno": 301,
                "end_lineno": 301
            }
        ]
    },
    "sympy__sympy-12227": {
        "sympy/core/numbers.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 6,
                "end_lineno": 6
            },
            {
                "hunk": [
                    "+from sympy.utilities.exceptions import SymPyDeprecationWarning",
                    "+"
                ],
                "start_lineno": 30,
                "end_lineno": 30
            },
            {
                "hunk": [
                    "-    def __new__(cls, num, prec=None):",
                    "+    def __new__(cls, num, dps=None, prec=None, precision=None):",
                    "+        if prec is not None:",
                    "+            SymPyDeprecationWarning(",
                    "+                            feature=\"Using 'prec=XX' to denote decimal precision\",",
                    "+                            useinstead=\"'dps=XX' to denote decimal and 'precision=XX' \"\\",
                    "+                                              \"for binary precision\",",
                    "+                            value=\"This is an effort to improve functionality \"\\",
                    "+                                       \"of Float class. \").warn()",
                    "+            dps = prec",
                    "+",
                    "+        if dps is not None and precision is not None:",
                    "+            raise ValueError('Both decimal and binary precision supplied. '",
                    "+                             'Supply only one. ')",
                    "+"
                ],
                "start_lineno": 771,
                "end_lineno": 771
            },
            {
                "hunk": [
                    "-            if prec == None:",
                    "-                prec = num.context.dps",
                    "+            if precision is None:",
                    "+                if dps is None:",
                    "+                    precision = num.context.prec",
                    "             num = num._mpf_",
                    " ",
                    "-        if prec is None:",
                    "+        if dps is None and precision is None:"
                ],
                "start_lineno": 787,
                "end_lineno": 791
            },
            {
                "hunk": [
                    "-        elif prec == '':",
                    "+                    precision = mlib.libmpf.dps_to_prec(dps)",
                    "+        elif precision == '' and dps is None or precision is None and dps == '':"
                ],
                "start_lineno": 806,
                "end_lineno": 806
            },
            {
                "hunk": [
                    "+                        precision = mlib.libmpf.dps_to_prec(dps)",
                    "                     ok = True",
                    "             if ok is None:",
                    "                 raise ValueError('string-float not recognized: %s' % num)",
                    "-        else:",
                    "-            dps = prec",
                    " ",
                    "-        prec = mlib.libmpf.dps_to_prec(dps)",
                    "+        # decimal precision(dps) is set and maybe binary precision(precision)",
                    "+        # as well.From here on binary precision is used to compute the Float.",
                    "+        # Hence, if supplied use binary precision else translate from decimal",
                    "+        # precision.",
                    "+",
                    "+        if precision is None or precision == '':",
                    "+            precision = mlib.libmpf.dps_to_prec(dps)",
                    "+",
                    "         if isinstance(num, float):",
                    "-            _mpf_ = mlib.from_float(num, prec, rnd)",
                    "+            _mpf_ = mlib.from_float(num, precision, rnd)",
                    "         elif isinstance(num, string_types):",
                    "-            _mpf_ = mlib.from_str(num, prec, rnd)",
                    "+            _mpf_ = mlib.from_str(num, precision, rnd)",
                    "         elif isinstance(num, decimal.Decimal):",
                    "             if num.is_finite():",
                    "-                _mpf_ = mlib.from_str(str(num), prec, rnd)",
                    "+                _mpf_ = mlib.from_str(str(num), precision, rnd)"
                ],
                "start_lineno": 821,
                "end_lineno": 834
            },
            {
                "hunk": [
                    "-            _mpf_ = mlib.from_rational(num.p, num.q, prec, rnd)",
                    "+            _mpf_ = mlib.from_rational(num.p, num.q, precision, rnd)"
                ],
                "start_lineno": 845,
                "end_lineno": 845
            },
            {
                "hunk": [
                    "-                    return Float._new(num, prec)",
                    "+                    return Float._new(num, precision)",
                    "                 else:",
                    "-                    return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(prec)",
                    "+                    return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)",
                    "         elif isinstance(num, Float):",
                    "             _mpf_ = num._mpf_",
                    "-            if prec < num._prec:",
                    "-                _mpf_ = mpf_norm(_mpf_, prec)",
                    "+            if precision < num._prec:",
                    "+                _mpf_ = mpf_norm(_mpf_, precision)"
                ],
                "start_lineno": 856,
                "end_lineno": 862
            },
            {
                "hunk": [
                    "-        obj._prec = prec",
                    "+        obj._prec = precision"
                ],
                "start_lineno": 875,
                "end_lineno": 875
            }
        ],
        "sympy/printing/repr.py": [
            {
                "hunk": [
                    "-        dps = prec_to_dps(expr._prec)",
                    "         r = mlib.to_str(expr._mpf_, repr_dps(expr._prec))",
                    "-        return \"%s('%s', prec=%i)\" % (expr.__class__.__name__, r, dps)",
                    "+        return \"%s('%s', precision=%i)\" % (expr.__class__.__name__, r, expr._prec)"
                ],
                "start_lineno": 138,
                "end_lineno": 140
            }
        ]
    },
    "django__django-11543": {
        "django/core/servers/basehttp.py": [
            {
                "hunk": [
                    "+        # Persistent connections require threading server.",
                    "+        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):",
                    "+            self.headers['Connection'] = 'close'"
                ],
                "start_lineno": 104,
                "end_lineno": 104
            }
        ]
    },
    "sympy__sympy-15596": {
        "sympy/calculus/util.py": [
            {
                "hunk": [
                    "-        elif degree(a, symbol) == 1 and symbol not in n.free_symbols:",
                    "-            period = Abs(n / a.diff(symbol))",
                    "+        elif (a.is_polynomial(symbol) and degree(a, symbol) == 1 and",
                    "+            symbol not in n.free_symbols):",
                    "+                period = Abs(n / a.diff(symbol))"
                ],
                "start_lineno": 469,
                "end_lineno": 470
            }
        ],
        "sympy/polys/polytools.py": [
            {
                "hunk": [
                    "+    gen_is_Num = sympify(gen, strict=True).is_Number",
                    "     if f.is_Poly:",
                    "         p = f",
                    "         isNum = p.as_expr().is_Number",
                    "     else:",
                    "         isNum = f.is_Number",
                    "         if not isNum:",
                    "-            p, _ = poly_from_expr(f)",
                    "+            if gen_is_Num:",
                    "+                p, _ = poly_from_expr(f)",
                    "+            else:",
                    "+                p, _ = poly_from_expr(f, gen)",
                    " ",
                    "     if isNum:",
                    "         return S.Zero if f else S.NegativeInfinity",
                    " ",
                    "-    if not sympify(gen, strict=True).is_Number:",
                    "+    if not gen_is_Num:"
                ],
                "start_lineno": 4448,
                "end_lineno": 4459
            }
        ]
    },
    "sphinx-doc__sphinx-9902": {
        "sphinx/domains/python.py": [
            {
                "hunk": [
                    "-def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:",
                    "+def type_to_xref(target: str, env: BuildEnvironment = None) -> addnodes.pending_xref:",
                    "     \"\"\"Convert a type string to a cross reference node.\"\"\"",
                    "-    if text == 'None':",
                    "+    if target == 'None':"
                ],
                "start_lineno": 83,
                "end_lineno": 85
            },
            {
                "hunk": [
                    "+    refspecific = False",
                    "+    if target.startswith('.'):",
                    "+        target = target[1:]",
                    "+        text = target",
                    "+        refspecific = True",
                    "+    elif target.startswith('~'):",
                    "+        target = target[1:]",
                    "+        text = target.split('.')[-1]",
                    "+    else:",
                    "+        text = target",
                    "+"
                ],
                "start_lineno": 96,
                "end_lineno": 96
            },
            {
                "hunk": [
                    "-                        refdomain='py', reftype=reftype, reftarget=text, **kwargs)",
                    "+                        refdomain='py', reftype=reftype, reftarget=target,",
                    "+                        refspecific=refspecific, **kwargs)"
                ],
                "start_lineno": 107,
                "end_lineno": 107
            }
        ]
    },
    "pytest-dev__pytest-7673": {
        "src/_pytest/logging.py": [
            {
                "hunk": [
                    "-        self._initial_handler_level = self.handler.level",
                    "+        if self._initial_handler_level is None:",
                    "+            self._initial_handler_level = self.handler.level"
                ],
                "start_lineno": 442,
                "end_lineno": 442
            }
        ]
    },
    "matplotlib__matplotlib-26122": {
        "galleries/examples/misc/demo_ribbon_box.py": [
            {
                "hunk": [
                    "-              extent=(0, 1, 0, 1), transform=ax.transAxes, aspect=\"auto\")",
                    "+              extent=(0, 1, 0, 1), transform=ax.transAxes)"
                ],
                "start_lineno": 89,
                "end_lineno": 89
            }
        ],
        "lib/matplotlib/axes/_axes.py": [
            {
                "hunk": [
                    "-        image set up the colormapping using the parameters",
                    "+        image, set up the colormapping using the parameters",
                    "         ``cmap='gray', vmin=0, vmax=255``.",
                    " ",
                    "         The number of pixels used to render an image is set by the Axes size",
                    "-        and the *dpi* of the figure. This can lead to aliasing artifacts when",
                    "-        the image is resampled because the displayed image size will usually",
                    "+        and the figure *dpi*. This can lead to aliasing artifacts when",
                    "+        the image is resampled, because the displayed image size will usually"
                ],
                "start_lineno": 5533,
                "end_lineno": 5538
            },
            {
                "hunk": [
                    "-        aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`",
                    "+        aspect : {'equal', 'auto'} or float or None, default: None"
                ],
                "start_lineno": 5573,
                "end_lineno": 5573
            },
            {
                "hunk": [
                    "+            Normally, None (the default) means to use :rc:`image.aspect`.  However, if",
                    "+            the image uses a transform that does not contain the axes data transform,",
                    "+            then None means to not modify the axes aspect at all (in that case, directly",
                    "+            call `.Axes.set_aspect` if desired).",
                    "+"
                ],
                "start_lineno": 5588,
                "end_lineno": 5588
            },
            {
                "hunk": [
                    "-        if aspect is None:",
                    "-            aspect = mpl.rcParams['image.aspect']",
                    "-        self.set_aspect(aspect)"
                ],
                "start_lineno": 5721,
                "end_lineno": 5723
            },
            {
                "hunk": [
                    "+        if aspect is None and not (",
                    "+                im.is_transform_set()",
                    "+                and not im.get_transform().contains_branch(self.transData)):",
                    "+            aspect = mpl.rcParams['image.aspect']",
                    "+        if aspect is not None:",
                    "+            self.set_aspect(aspect)",
                    "+"
                ],
                "start_lineno": 5731,
                "end_lineno": 5731
            }
        ]
    },
    "sympy__sympy-11897": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "+        if expr.is_Piecewise:",
                    "+            return True",
                    "         if any([expr.has(x) for x in (Mod,)]):",
                    "             return True",
                    "         if (not last and",
                    "-            any([expr.has(x) for x in (Integral, Piecewise, Product, Sum)])):",
                    "+            any([expr.has(x) for x in (Integral, Product, Sum)])):"
                ],
                "start_lineno": 238,
                "end_lineno": 241
            }
        ]
    },
    "sympy__sympy-18961": {
        "sympy/ntheory/digits.py": [
            {
                "hunk": [
                    "-def digits(n, b=10):",
                    "+def digits(n, b=10, digits=None):"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-    >>> digits(27, 2)",
                    "+",
                    "+    If the number is negative, the negative sign will be placed on the",
                    "+    base (which is the first element in the returned list):",
                    "+",
                    "+    >>> digits(-35)",
                    "+    [-10, 3, 5]",
                    "+",
                    "+    Bases other than 10 (and greater than 1) can be selected with ``b``:",
                    "+",
                    "+    >>> digits(27, b=2)",
                    "     [2, 1, 1, 0, 1, 1]",
                    "-    >>> digits(65536, 256)",
                    "-    [256, 1, 0, 0]",
                    "-    >>> digits(-3958, 27)",
                    "-    [-27, 5, 11, 16]",
                    "+",
                    "+    Use the ``digits`` keyword if a certain number of digits is desired:",
                    "+",
                    "+    >>> digits(35, digits=4)",
                    "+    [10, 0, 0, 3, 5]",
                    "+",
                    "+    Parameters",
                    "+    ==========",
                    "+",
                    "+    n: integer",
                    "+        The number whose digits are returned.",
                    "+",
                    "+    b: integer",
                    "+        The base in which digits are computed.",
                    "+",
                    "+    digits: integer (or None for all digits)",
                    "+        The number of digits to be returned (padded with zeros, if",
                    "+        necessary).",
                    "+",
                    "     \"\"\"",
                    " ",
                    "     b = as_int(b)",
                    "     n = as_int(n)",
                    "-    if b <= 1:",
                    "-        raise ValueError(\"b must be >= 2\")",
                    "+    if b < 2:",
                    "+        raise ValueError(\"b must be greater than 1\")"
                ],
                "start_lineno": 20,
                "end_lineno": 31
            },
            {
                "hunk": [
                    "+        ndig = len(y) - 1",
                    "+        if digits is not None:",
                    "+            if ndig > digits:",
                    "+                raise ValueError(",
                    "+                    \"For %s, at least %s digits are needed.\" % (n, ndig))",
                    "+            elif ndig < digits:",
                    "+                y[1:1] = [0]*(digits - ndig)"
                ],
                "start_lineno": 40,
                "end_lineno": 40
            }
        ]
    },
    "psf__requests-3738": {
        "requests/models.py": [
            {
                "hunk": [
                    "-        # `data`, `http+unix` etc to work around exceptions from `url_parse`,",
                    "-        # which handles RFC 3986 only.",
                    "-        if ':' in url and not url.lower().startswith(('http://', 'https://')):",
                    "+        # `data` etc to work around exceptions from `url_parse`, which",
                    "+        # handles RFC 3986 only.",
                    "+        if ':' in url and not url.lower().startswith('http'):"
                ],
                "start_lineno": 350,
                "end_lineno": 352
            }
        ]
    },
    "django__django-16491": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    empty_result_set_value = False"
                ],
                "start_lineno": 1549,
                "end_lineno": 1549
            }
        ]
    },
    "sphinx-doc__sphinx-9234": {
        "sphinx/builders/linkcheck.py": [
            {
                "hunk": [
                    "-            logger.info(color('redirect  ') + result.uri +",
                    "-                        color(' - ' + text + ' to ' + result.message))",
                    "+            if self.config.linkcheck_allowed_redirects:",
                    "+                logger.warning('redirect  ' + result.uri + ' - ' + text + ' to ' +",
                    "+                               result.message, location=(filename, result.lineno))",
                    "+            else:",
                    "+                logger.info(color('redirect  ') + result.uri +",
                    "+                            color(' - ' + text + ' to ' + result.message))"
                ],
                "start_lineno": 275,
                "end_lineno": 276
            },
            {
                "hunk": [
                    "-                # history contains any redirects, get last",
                    "-                if response.history:",
                    "+",
                    "+                if allowed_redirect(req_url, new_url):",
                    "+                    return 'working', '', 0",
                    "+                elif response.history:",
                    "+                    # history contains any redirects, get last",
                    "                     code = response.history[-1].status_code",
                    "                     return 'redirected', new_url, code",
                    "                 else:",
                    "                     return 'redirected', new_url, 0",
                    " ",
                    "+        def allowed_redirect(url: str, new_url: str) -> bool:",
                    "+            for from_url, to_url in self.config.linkcheck_allowed_redirects.items():",
                    "+                if from_url.match(url) and to_url.match(new_url):",
                    "+                    return True",
                    "+",
                    "+            return False",
                    "+"
                ],
                "start_lineno": 499,
                "end_lineno": 505
            },
            {
                "hunk": [
                    "+def compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -> None:",
                    "+    \"\"\"Compile patterns in linkcheck_allowed_redirects to the regexp objects.\"\"\"",
                    "+    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):",
                    "+        try:",
                    "+            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)",
                    "+        except re.error as exc:",
                    "+            logger.warning(__('Failed to compile regex in linkcheck_allowed_redirects: %r %s'),",
                    "+                           exc.pattern, exc.msg)",
                    "+        finally:",
                    "+            # Remove the original regexp-string",
                    "+            app.config.linkcheck_allowed_redirects.pop(url)",
                    "+",
                    "+",
                    " def setup(app: Sphinx) -> Dict[str, Any]:",
                    "     app.add_builder(CheckExternalLinksBuilder)",
                    "     app.add_post_transform(HyperlinkCollector)",
                    " ",
                    "     app.add_config_value('linkcheck_ignore', [], None)",
                    "+    app.add_config_value('linkcheck_allowed_redirects', {}, None)"
                ],
                "start_lineno": 670,
                "end_lineno": 674
            },
            {
                "hunk": [
                    "+",
                    "+    app.connect('config-inited', compile_linkcheck_allowed_redirects, priority=800)"
                ],
                "start_lineno": 687,
                "end_lineno": 687
            }
        ]
    },
    "django__django-11138": {
        "django/db/backends/mysql/operations.py": [
            {
                "hunk": [
                    "-        if settings.USE_TZ:",
                    "-            field_name = \"CONVERT_TZ(%s, 'UTC', '%s')\" % (field_name, tzname)",
                    "+        if settings.USE_TZ and self.connection.timezone_name != tzname:",
                    "+            field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (field_name, self.connection.timezone_name, tzname)"
                ],
                "start_lineno": 72,
                "end_lineno": 73
            }
        ],
        "django/db/backends/oracle/operations.py": [
            {
                "hunk": [
                    "-        # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE",
                    "-        # and cast it back to TIMESTAMP to strip the TIME ZONE details.",
                    "-        return \"CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)\" % (field_name, tzname)",
                    "+        # Convert from connection timezone to the local time, returning",
                    "+        # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the",
                    "+        # TIME ZONE details.",
                    "+        if self.connection.timezone_name != tzname:",
                    "+            return \"CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)\" % (",
                    "+                field_name,",
                    "+                self.connection.timezone_name,",
                    "+                tzname,",
                    "+            )",
                    "+        return field_name"
                ],
                "start_lineno": 102,
                "end_lineno": 104
            }
        ],
        "django/db/backends/sqlite3/base.py": [
            {
                "hunk": [
                    "-        conn.create_function(\"django_datetime_cast_date\", 2, _sqlite_datetime_cast_date)",
                    "-        conn.create_function(\"django_datetime_cast_time\", 2, _sqlite_datetime_cast_time)",
                    "-        conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)",
                    "-        conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)",
                    "+        conn.create_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)",
                    "+        conn.create_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)",
                    "+        conn.create_function('django_datetime_extract', 4, _sqlite_datetime_extract)",
                    "+        conn.create_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)"
                ],
                "start_lineno": 198,
                "end_lineno": 201
            },
            {
                "hunk": [
                    "-def _sqlite_datetime_parse(dt, tzname=None):",
                    "+def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):",
                    "     if dt is None:",
                    "         return None",
                    "     try:",
                    "         dt = backend_utils.typecast_timestamp(dt)",
                    "     except (TypeError, ValueError):",
                    "         return None",
                    "-    if tzname is not None:",
                    "+    if conn_tzname:",
                    "+        dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))",
                    "+    if tzname is not None and tzname != conn_tzname:"
                ],
                "start_lineno": 401,
                "end_lineno": 408
            },
            {
                "hunk": [
                    "-def _sqlite_datetime_cast_date(dt, tzname):",
                    "-    dt = _sqlite_datetime_parse(dt, tzname)",
                    "+def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):",
                    "+    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)",
                    "     if dt is None:",
                    "         return None",
                    "     return dt.date().isoformat()",
                    " ",
                    " ",
                    "-def _sqlite_datetime_cast_time(dt, tzname):",
                    "-    dt = _sqlite_datetime_parse(dt, tzname)",
                    "+def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):",
                    "+    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)",
                    "     if dt is None:",
                    "         return None",
                    "     return dt.time().isoformat()",
                    " ",
                    " ",
                    "-def _sqlite_datetime_extract(lookup_type, dt, tzname=None):",
                    "-    dt = _sqlite_datetime_parse(dt, tzname)",
                    "+def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):",
                    "+    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)"
                ],
                "start_lineno": 446,
                "end_lineno": 461
            },
            {
                "hunk": [
                    "-def _sqlite_datetime_trunc(lookup_type, dt, tzname):",
                    "-    dt = _sqlite_datetime_parse(dt, tzname)",
                    "+def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):",
                    "+    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)"
                ],
                "start_lineno": 476,
                "end_lineno": 477
            }
        ],
        "django/db/backends/sqlite3/operations.py": [
            {
                "hunk": [
                    "-    def _convert_tzname_to_sql(self, tzname):",
                    "-        return \"'%s'\" % tzname if settings.USE_TZ else 'NULL'",
                    "+    def _convert_tznames_to_sql(self, tzname):",
                    "+        if settings.USE_TZ:",
                    "+            return \"'%s'\" % tzname, \"'%s'\" % self.connection.timezone_name",
                    "+        return 'NULL', 'NULL'",
                    " ",
                    "     def datetime_cast_date_sql(self, field_name, tzname):",
                    "-        return \"django_datetime_cast_date(%s, %s)\" % (",
                    "-            field_name, self._convert_tzname_to_sql(tzname),",
                    "+        return 'django_datetime_cast_date(%s, %s, %s)' % (",
                    "+            field_name, *self._convert_tznames_to_sql(tzname),",
                    "         )",
                    " ",
                    "     def datetime_cast_time_sql(self, field_name, tzname):",
                    "-        return \"django_datetime_cast_time(%s, %s)\" % (",
                    "-            field_name, self._convert_tzname_to_sql(tzname),",
                    "+        return 'django_datetime_cast_time(%s, %s, %s)' % (",
                    "+            field_name, *self._convert_tznames_to_sql(tzname),",
                    "         )",
                    " ",
                    "     def datetime_extract_sql(self, lookup_type, field_name, tzname):",
                    "-        return \"django_datetime_extract('%s', %s, %s)\" % (",
                    "-            lookup_type.lower(), field_name, self._convert_tzname_to_sql(tzname),",
                    "+        return \"django_datetime_extract('%s', %s, %s, %s)\" % (",
                    "+            lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),",
                    "         )",
                    " ",
                    "     def datetime_trunc_sql(self, lookup_type, field_name, tzname):",
                    "-        return \"django_datetime_trunc('%s', %s, %s)\" % (",
                    "-            lookup_type.lower(), field_name, self._convert_tzname_to_sql(tzname),",
                    "+        return \"django_datetime_trunc('%s', %s, %s, %s)\" % (",
                    "+            lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),"
                ],
                "start_lineno": 87,
                "end_lineno": 107
            }
        ]
    },
    "matplotlib__matplotlib-25287": {
        "lib/matplotlib/axis.py": [
            {
                "hunk": [
                    "+        if mpl.rcParams['xtick.labelcolor'] == 'inherit':",
                    "+            tick_color = mpl.rcParams['xtick.color']",
                    "+        else:",
                    "+            tick_color = mpl.rcParams['xtick.labelcolor']",
                    "+",
                    "         self.offsetText.set(",
                    "             x=1, y=0,",
                    "             verticalalignment='top', horizontalalignment='right',",
                    "             transform=mtransforms.blended_transform_factory(",
                    "                 self.axes.transAxes, mtransforms.IdentityTransform()),",
                    "             fontsize=mpl.rcParams['xtick.labelsize'],",
                    "-            color=mpl.rcParams['xtick.color'],",
                    "+            color=tick_color"
                ],
                "start_lineno": 2256,
                "end_lineno": 2262
            },
            {
                "hunk": [
                    "+",
                    "+        if mpl.rcParams['ytick.labelcolor'] == 'inherit':",
                    "+            tick_color = mpl.rcParams['ytick.color']",
                    "+        else:",
                    "+            tick_color = mpl.rcParams['ytick.labelcolor']",
                    "+"
                ],
                "start_lineno": 2515,
                "end_lineno": 2515
            },
            {
                "hunk": [
                    "-            color=mpl.rcParams['ytick.color'],",
                    "+            color=tick_color"
                ],
                "start_lineno": 2522,
                "end_lineno": 2522
            }
        ]
    },
    "django__django-12734": {
        "django/db/backends/sqlite3/schema.py": [
            {
                "hunk": [
                    "-        # Rebuild tables with FKs pointing to this field if the PK type changed.",
                    "-        if old_field.primary_key and new_field.primary_key and old_type != new_type:",
                    "-            for rel in new_field.model._meta.related_objects:",
                    "-                if not rel.many_to_many:",
                    "-                    self._remake_table(rel.related_model)",
                    "+        # Rebuild tables with FKs pointing to this field.",
                    "+        if new_field.unique and old_type != new_type:",
                    "+            related_models = set()",
                    "+            opts = new_field.model._meta",
                    "+            for remote_field in opts.related_objects:",
                    "+                # Ignore self-relationship since the table was already rebuilt.",
                    "+                if remote_field.related_model == model:",
                    "+                    continue",
                    "+                if not remote_field.many_to_many:",
                    "+                    if remote_field.field_name == new_field.name:",
                    "+                        related_models.add(remote_field.related_model)",
                    "+                elif new_field.primary_key and remote_field.through._meta.auto_created:",
                    "+                    related_models.add(remote_field.through)",
                    "+            if new_field.primary_key:",
                    "+                for many_to_many in opts.many_to_many:",
                    "+                    # Ignore self-relationship since the table was already rebuilt.",
                    "+                    if many_to_many.related_model == model:",
                    "+                        continue",
                    "+                    if many_to_many.remote_field.through._meta.auto_created:",
                    "+                        related_models.add(many_to_many.remote_field.through)",
                    "+            for related_model in related_models:",
                    "+                self._remake_table(related_model)"
                ],
                "start_lineno": 361,
                "end_lineno": 365
            }
        ]
    },
    "django__django-15166": {
        "django/core/cache/backends/db.py": [
            {
                "hunk": [
                    "-                'SELECT %s FROM %s WHERE %s = %%s and expires > %%s' % (",
                    "+                'SELECT %s FROM %s WHERE %s = %%s and %s > %%s' % (",
                    "                     quote_name('cache_key'),",
                    "                     quote_name(self._table),",
                    "                     quote_name('cache_key'),",
                    "+                    quote_name('expires'),"
                ],
                "start_lineno": 231,
                "end_lineno": 234
            },
            {
                "hunk": [
                    "-            cursor.execute(\"DELETE FROM %s WHERE expires < %%s\" % table,",
                    "-                           [connection.ops.adapt_datetimefield_value(now)])",
                    "+            cursor.execute('DELETE FROM %s WHERE %s < %%s' % (",
                    "+                table,",
                    "+                connection.ops.quote_name('expires'),",
                    "+            ), [connection.ops.adapt_datetimefield_value(now)])"
                ],
                "start_lineno": 246,
                "end_lineno": 247
            },
            {
                "hunk": [
                    "-                        'DELETE FROM %s WHERE cache_key < %%s' % table,",
                    "+                        'DELETE FROM %s WHERE %s < %%s' % (",
                    "+                            table,",
                    "+                            connection.ops.quote_name('cache_key'),",
                    "+                        ),"
                ],
                "start_lineno": 258,
                "end_lineno": 258
            }
        ],
        "django/db/backends/base/operations.py": [
            {
                "hunk": [
                    "-        return \"SELECT cache_key FROM %s ORDER BY cache_key LIMIT 1 OFFSET %%s\"",
                    "+        cache_key = self.quote_name('cache_key')",
                    "+        return f'SELECT {cache_key} FROM %s ORDER BY {cache_key} LIMIT 1 OFFSET %%s'"
                ],
                "start_lineno": 91,
                "end_lineno": 91
            }
        ],
        "django/db/backends/oracle/operations.py": [
            {
                "hunk": [
                    "-        return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'",
                    "+        cache_key = self.quote_name('cache_key')",
                    "+        return (",
                    "+            f'SELECT {cache_key} '",
                    "+            f'FROM %s '",
                    "+            f'ORDER BY {cache_key} OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'",
                    "+        )"
                ],
                "start_lineno": 75,
                "end_lineno": 75
            }
        ]
    },
    "django__django-11790": {
        "django/contrib/auth/forms.py": [
            {
                "hunk": [
                    "-        self.fields['username'].max_length = self.username_field.max_length or 254",
                    "+        username_max_length = self.username_field.max_length or 254",
                    "+        self.fields['username'].max_length = username_max_length",
                    "+        self.fields['username'].widget.attrs['maxlength'] = username_max_length"
                ],
                "start_lineno": 194,
                "end_lineno": 194
            }
        ]
    },
    "django__django-12556": {
        "django/contrib/auth/hashers.py": [
            {
                "hunk": [
                    "-        return get_random_string()",
                    "+        # 12 returns a 71-bit value, log_2((26+26+10)^12) =~ 71 bits",
                    "+        return get_random_string(12)"
                ],
                "start_lineno": 188,
                "end_lineno": 188
            }
        ],
        "django/db/backends/oracle/creation.py": [
            {
                "hunk": [
                    "-            password = get_random_string(length=30)",
                    "+            password = get_random_string(30)"
                ],
                "start_lineno": 344,
                "end_lineno": 344
            }
        ],
        "django/utils/crypto.py": [
            {
                "hunk": [
                    "+import warnings",
                    " ",
                    " from django.conf import settings",
                    "+from django.utils.deprecation import RemovedInDjango40Warning"
                ],
                "start_lineno": 7,
                "end_lineno": 8
            },
            {
                "hunk": [
                    "-def get_random_string(length=12,",
                    "-                      allowed_chars='abcdefghijklmnopqrstuvwxyz'",
                    "-                                    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):",
                    "+NOT_PROVIDED = object()  # RemovedInDjango40Warning.",
                    "+",
                    "+",
                    "+# RemovedInDjango40Warning: when the deprecation ends, replace with:",
                    "+#   def get_random_string(self, length, allowed_chars='...'):",
                    "+def get_random_string(length=NOT_PROVIDED, allowed_chars=(",
                    "+    'abcdefghijklmnopqrstuvwxyz'",
                    "+    'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'",
                    "+)):",
                    "     \"\"\"",
                    "     Return a securely generated random string.",
                    " ",
                    "-    The default length of 12 with the a-z, A-Z, 0-9 character set returns",
                    "-    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits",
                    "+    The bit length of the returned value can be calculated with the formula:",
                    "+        log_2(len(allowed_chars)^length)",
                    "+",
                    "+    For example, with default `allowed_chars` (26+26+10), this gives:",
                    "+      * length: 12, bit length =~ 71 bits",
                    "+      * length: 22, bit length =~ 131 bits",
                    "     \"\"\"",
                    "+    if length is NOT_PROVIDED:",
                    "+        warnings.warn(",
                    "+            'Not providing a length argument is deprecated.',",
                    "+            RemovedInDjango40Warning,",
                    "+        )",
                    "+        length = 12"
                ],
                "start_lineno": 47,
                "end_lineno": 55
            }
        ]
    },
    "django__django-13112": {
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "-            kwargs['to'] = self.remote_field.model.lower()",
                    "+            if '.' in self.remote_field.model:",
                    "+                app_label, model_name = self.remote_field.model.split('.')",
                    "+                kwargs['to'] = '%s.%s' % (app_label, model_name.lower())",
                    "+            else:",
                    "+                kwargs['to'] = self.remote_field.model.lower()"
                ],
                "start_lineno": 585,
                "end_lineno": 585
            }
        ]
    },
    "sympy__sympy-21101": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-    re.compile(r'[{ ]*[-+0-9]'),  # match",
                    "+    re.compile(r'[0-9]'),  # match"
                ],
                "start_lineno": 118,
                "end_lineno": 118
            },
            {
                "hunk": [
                    "-                            _between_two_numbers_p[1].match(term_tex):",
                    "+                            _between_two_numbers_p[1].match(str(term)):"
                ],
                "start_lineno": 532,
                "end_lineno": 532
            }
        ]
    },
    "pylint-dev__pylint-8757": {
        "pylint/checkers/similar.py": [
            {
                "hunk": [
                    "+",
                    "+        Calls self.close() to actually calculate and report duplicate code.",
                    "         \"\"\"",
                    "         Similar.combine_mapreduce_data(self, linesets_collection=data)",
                    "+        self.close()"
                ],
                "start_lineno": 892,
                "end_lineno": 893
            }
        ],
        "pylint/lint/parallel.py": [
            {
                "hunk": [
                    "-    multiple files, as in the similarity-checker, then implement the map/reduce mixin functionality.",
                    "+    multiple files, as in the similarity-checker, then implement the map/reduce functionality."
                ],
                "start_lineno": 133,
                "end_lineno": 133
            }
        ]
    },
    "django__django-15062": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-class ExpressionWrapper(Expression):",
                    "+class ExpressionWrapper(SQLiteNumericMixin, Expression):"
                ],
                "start_lineno": 936,
                "end_lineno": 936
            },
            {
                "hunk": [
                    "-class Case(Expression):",
                    "+class Case(SQLiteNumericMixin, Expression):"
                ],
                "start_lineno": 1035,
                "end_lineno": 1035
            }
        ]
    },
    "django__django-12928": {
        "django/template/__init__.py": [
            {
                "hunk": [
                    "+# Import the .autoreload module to trigger the registrations of signals.",
                    "+from . import autoreload                                                # NOQA isort:skip",
                    "+"
                ],
                "start_lineno": 67,
                "end_lineno": 67
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+from django.dispatch import receiver",
                    "+from django.template import engines",
                    "+from django.template.backends.django import DjangoTemplates",
                    "+from django.utils.autoreload import (",
                    "+    autoreload_started, file_changed, is_django_path,",
                    "+)",
                    "+",
                    "+",
                    "+def get_template_directories():",
                    "+    # Iterate through each template backend and find",
                    "+    # any template_loader that has a 'get_dirs' method.",
                    "+    # Collect the directories, filtering out Django templates.",
                    "+    items = set()",
                    "+    for backend in engines.all():",
                    "+        if not isinstance(backend, DjangoTemplates):",
                    "+            continue",
                    "+",
                    "+        items.update(backend.engine.dirs)",
                    "+",
                    "+        for loader in backend.engine.template_loaders:",
                    "+            if not hasattr(loader, 'get_dirs'):",
                    "+                continue",
                    "+            items.update(",
                    "+                directory",
                    "+                for directory in loader.get_dirs()",
                    "+                if not is_django_path(directory)",
                    "+            )",
                    "+    return items",
                    "+",
                    "+",
                    "+def reset_loaders():",
                    "+    for backend in engines.all():",
                    "+        if not isinstance(backend, DjangoTemplates):",
                    "+            continue",
                    "+        for loader in backend.engine.template_loaders:",
                    "+            loader.reset()",
                    "+",
                    "+",
                    "+@receiver(autoreload_started, dispatch_uid='template_loaders_watch_changes')",
                    "+def watch_for_template_changes(sender, **kwargs):",
                    "+    for directory in get_template_directories():",
                    "+        sender.watch_dir(directory, '**/*')",
                    "+",
                    "+",
                    "+@receiver(file_changed, dispatch_uid='template_loaders_file_changed')",
                    "+def template_changed(sender, file_path, **kwargs):",
                    "+    for template_dir in get_template_directories():",
                    "+        if template_dir in file_path.parents:",
                    "+            reset_loaders()",
                    "+            return True"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ],
        "django/template/loaders/cached.py": [
            {
                "hunk": [
                    "+    def get_dirs(self):",
                    "+        for loader in self.loaders:",
                    "+            if hasattr(loader, \"get_dirs\"):",
                    "+                yield from loader.get_dirs()",
                    "+"
                ],
                "start_lineno": 21,
                "end_lineno": 21
            }
        ],
        "django/utils/autoreload.py": [
            {
                "hunk": [
                    "+import django"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "+def is_django_module(module):",
                    "+    \"\"\"Return True if the given module is nested under Django.\"\"\"",
                    "+    return module.__name__.startswith('django.')",
                    "+",
                    "+",
                    "+def is_django_path(path):",
                    "+    \"\"\"Return True if the given file path is nested under Django.\"\"\"",
                    "+    return Path(django.__file__).parent in Path(path).parents",
                    "+",
                    "+"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            },
            {
                "hunk": [
                    "+        # Only receive notifications of files changing, filtering out other types",
                    "+        # like special files: https://facebook.github.io/watchman/docs/type",
                    "+        only_files_expression = [",
                    "+            'allof',",
                    "+            ['anyof', ['type', 'f'], ['type', 'l']],",
                    "+            expression",
                    "+        ]",
                    "         query = {",
                    "-            'expression': expression,",
                    "+            'expression': only_files_expression,"
                ],
                "start_lineno": 434,
                "end_lineno": 435
            }
        ],
        "django/utils/translation/reloader.py": [
            {
                "hunk": [
                    "-",
                    "-",
                    "-def _is_django_module(module):",
                    "-    \"\"\"Return True if the given module is nested under Django.\"\"\"",
                    "-    return module.__name__.startswith('django.')",
                    "+from django.utils.autoreload import is_django_module"
                ],
                "start_lineno": 6,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "-            if not _is_django_module(config.module)",
                    "+            if not is_django_module(config.module)"
                ],
                "start_lineno": 22,
                "end_lineno": 22
            }
        ]
    },
    "astropy__astropy-12891": {
        "astropy/units/quantity.py": [
            {
                "hunk": [
                    "+from astropy.utils.compat import NUMPY_LT_1_20, NUMPY_LT_1_22"
                ],
                "start_lineno": 21,
                "end_lineno": 21
            },
            {
                "hunk": [
                    "-",
                    "-    def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "-        return self._wrap_function(np.var, axis, dtype,",
                    "-                                   out=out, ddof=ddof, keepdims=keepdims,",
                    "-                                   unit=self.unit**2)",
                    "-",
                    "-    def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "-        return self._wrap_function(np.std, axis, dtype, out=out, ddof=ddof,",
                    "-                                   keepdims=keepdims)",
                    "-",
                    "-    def mean(self, axis=None, dtype=None, out=None, keepdims=False):",
                    "-        return self._wrap_function(np.mean, axis, dtype, out=out,",
                    "-                                   keepdims=keepdims)",
                    "+    if NUMPY_LT_1_20:",
                    "+        def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "+            return self._wrap_function(np.var, axis, dtype,",
                    "+                                       out=out, ddof=ddof, keepdims=keepdims,",
                    "+                                       unit=self.unit**2)",
                    "+    else:",
                    "+        def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True):",
                    "+            return self._wrap_function(np.var, axis, dtype,",
                    "+                                       out=out, ddof=ddof, keepdims=keepdims, where=where,",
                    "+                                       unit=self.unit**2)",
                    "+",
                    "+    if NUMPY_LT_1_20:",
                    "+        def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "+            return self._wrap_function(np.std, axis, dtype, out=out, ddof=ddof,",
                    "+                                       keepdims=keepdims)",
                    "+    else:",
                    "+        def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True):",
                    "+            return self._wrap_function(np.std, axis, dtype, out=out, ddof=ddof,",
                    "+                                       keepdims=keepdims, where=where)",
                    "+",
                    "+    if NUMPY_LT_1_20:",
                    "+        def mean(self, axis=None, dtype=None, out=None, keepdims=False):",
                    "+            return self._wrap_function(np.mean, axis, dtype, out=out,",
                    "+                                       keepdims=keepdims)",
                    "+    else:",
                    "+        def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):",
                    "+            return self._wrap_function(np.mean, axis, dtype, out=out,",
                    "+                                       keepdims=keepdims, where=where)"
                ],
                "start_lineno": 1791,
                "end_lineno": 1803
            },
            {
                "hunk": [
                    "-    def nansum(self, axis=None, out=None, keepdims=False):",
                    "-        return self._wrap_function(np.nansum, axis,",
                    "-                                   out=out, keepdims=keepdims)",
                    "+    if NUMPY_LT_1_22:",
                    "+        def nansum(self, axis=None, out=None, keepdims=False):",
                    "+            return self._wrap_function(np.nansum, axis,",
                    "+                                       out=out, keepdims=keepdims)",
                    "+    else:",
                    "+        def nansum(self, axis=None, out=None, keepdims=False, *, initial=None, where=True):",
                    "+            return self._wrap_function(np.nansum, axis,",
                    "+                                       out=out, keepdims=keepdims, initial=initial, where=where)"
                ],
                "start_lineno": 1830,
                "end_lineno": 1832
            }
        ],
        "astropy/utils/masked/core.py": [
            {
                "hunk": [
                    "-    def mean(self, axis=None, dtype=None, out=None, keepdims=False):",
                    "+    def mean(self, axis=None, dtype=None, out=None, keepdims=False, *, where=True):"
                ],
                "start_lineno": 1046,
                "end_lineno": 1046
            },
            {
                "hunk": [
                    "+        where = ~self.mask & where",
                    "+",
                    "         result = self.sum(axis=axis, dtype=dtype, out=out,",
                    "-                          keepdims=keepdims, where=~self.mask)",
                    "-        n = np.add.reduce(~self.mask, axis=axis, keepdims=keepdims)",
                    "+                          keepdims=keepdims, where=where)",
                    "+        n = np.add.reduce(where, axis=axis, keepdims=keepdims)",
                    "         result /= n",
                    "         if is_float16_result:",
                    "             result = result.astype(self.dtype)",
                    "         return result",
                    " ",
                    "-    def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "+    def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True):",
                    "+        where_final = ~self.mask & where",
                    "+",
                    "         # Simplified implementation based on that in numpy/core/_methods.py",
                    "-        n = np.add.reduce(~self.mask, axis=axis, keepdims=keepdims)[...]",
                    "+        n = np.add.reduce(where_final, axis=axis, keepdims=keepdims)[...]",
                    " ",
                    "         # Cast bool, unsigned int, and int to float64 by default.",
                    "         if dtype is None and issubclass(self.dtype.type,",
                    "                                         (np.integer, np.bool_)):",
                    "             dtype = np.dtype('f8')",
                    "-        mean = self.mean(axis=axis, dtype=dtype, keepdims=True)",
                    "+        mean = self.mean(axis=axis, dtype=dtype, keepdims=True, where=where)",
                    " ",
                    "         x = self - mean",
                    "         x *= x.conjugate()  # Conjugate just returns x if not complex.",
                    " ",
                    "         result = x.sum(axis=axis, dtype=dtype, out=out,",
                    "-                       keepdims=keepdims, where=~x.mask)",
                    "+                       keepdims=keepdims, where=where_final)",
                    "         n -= ddof",
                    "         n = np.maximum(n, 0, out=n)",
                    "         result /= n",
                    "         result._mask |= (n == 0)",
                    "         return result",
                    " ",
                    "-    def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):",
                    "+    def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True):",
                    "         result = self.var(axis=axis, dtype=dtype, out=out, ddof=ddof,",
                    "-                          keepdims=keepdims)",
                    "+                          keepdims=keepdims, where=where)"
                ],
                "start_lineno": 1058,
                "end_lineno": 1089
            },
            {
                "hunk": [
                    "-    def any(self, axis=None, out=None, keepdims=False):",
                    "+    def any(self, axis=None, out=None, keepdims=False, *, where=True):",
                    "         return np.logical_or.reduce(self, axis=axis, out=out,",
                    "-                                    keepdims=keepdims, where=~self.mask)",
                    "+                                    keepdims=keepdims, where=~self.mask & where)",
                    " ",
                    "-    def all(self, axis=None, out=None, keepdims=False):",
                    "+    def all(self, axis=None, out=None, keepdims=False, *, where=True):",
                    "         return np.logical_and.reduce(self, axis=axis, out=out,",
                    "-                                     keepdims=keepdims, where=~self.mask)",
                    "+                                     keepdims=keepdims, where=~self.mask & where)"
                ],
                "start_lineno": 1097,
                "end_lineno": 1103
            }
        ]
    },
    "django__django-13620": {
        "django/core/management/__init__.py": [
            {
                "hunk": [
                    "-    parse_args = [str(a) for a in args]",
                    "+    parse_args = []",
                    "+    for arg in args:",
                    "+        if isinstance(arg, (list, tuple)):",
                    "+            parse_args += map(str, arg)",
                    "+        else:",
                    "+            parse_args.append(str(arg))"
                ],
                "start_lineno": 123,
                "end_lineno": 123
            },
            {
                "hunk": [
                    "-    parse_args += [",
                    "-        min(opt.option_strings)",
                    "-        if isinstance(opt, (_AppendConstAction, _CountAction, _StoreConstAction))",
                    "-        else '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])",
                    "-        for opt in parser_actions if (",
                    "+    for opt in parser_actions:",
                    "+        if (",
                    "             opt.dest in options and",
                    "             (opt.required or opt in mutually_exclusive_required_options)",
                    "-        )",
                    "-    ]",
                    "+        ):",
                    "+            parse_args.append(min(opt.option_strings))",
                    "+            if isinstance(opt, (_AppendConstAction, _CountAction, _StoreConstAction)):",
                    "+                continue",
                    "+            value = arg_options[opt.dest]",
                    "+            if isinstance(value, (list, tuple)):",
                    "+                parse_args += map(str, value)",
                    "+            else:",
                    "+                parse_args.append(str(value))"
                ],
                "start_lineno": 142,
                "end_lineno": 150
            }
        ]
    },
    "django__django-7475": {
        "django/core/management/commands/diffsettings.py": [
            {
                "hunk": [
                    "+        parser.add_argument(",
                    "+            '--default', dest='default', metavar='MODULE', default=None,",
                    "+            help=(",
                    "+                \"The settings module to compare the current settings against. Leave empty to \"",
                    "+                \"compare against Django's default settings.\"",
                    "+            ),",
                    "+        )",
                    " ",
                    "     def handle(self, **options):",
                    "         # Inspired by Postfix's \"postconf -n\".",
                    "-        from django.conf import settings, global_settings",
                    "+        from django.conf import settings, Settings, global_settings",
                    " ",
                    "         # Because settings are imported lazily, we need to explicitly load them.",
                    "         settings._setup()",
                    " ",
                    "         user_settings = module_to_dict(settings._wrapped)",
                    "-        default_settings = module_to_dict(global_settings)",
                    "+        default = options['default']",
                    "+        default_settings = module_to_dict(Settings(default) if default else global_settings)"
                ],
                "start_lineno": 21,
                "end_lineno": 30
            }
        ]
    },
    "scikit-learn__scikit-learn-15535": {
        "sklearn/metrics/cluster/_supervised.py": [
            {
                "hunk": [
                    "-        labels_true, ensure_2d=False, ensure_min_samples=0",
                    "+        labels_true, ensure_2d=False, ensure_min_samples=0, dtype=None,",
                    "     )",
                    "     labels_pred = check_array(",
                    "-        labels_pred, ensure_2d=False, ensure_min_samples=0",
                    "+        labels_pred, ensure_2d=False, ensure_min_samples=0, dtype=None,"
                ],
                "start_lineno": 46,
                "end_lineno": 49
            }
        ]
    },
    "pytest-dev__pytest-11178": {
        "src/_pytest/python_api.py": [
            {
                "hunk": [
                    "-                max_abs_diff = max(",
                    "-                    max_abs_diff, abs(approx_value.expected - other_value)",
                    "-                )",
                    "-                if approx_value.expected == 0.0:",
                    "-                    max_rel_diff = math.inf",
                    "-                else:",
                    "-                    max_rel_diff = max(",
                    "-                        max_rel_diff,",
                    "-                        abs(",
                    "-                            (approx_value.expected - other_value)",
                    "-                            / approx_value.expected",
                    "-                        ),",
                    "+                if approx_value.expected is not None and other_value is not None:",
                    "+                    max_abs_diff = max(",
                    "+                        max_abs_diff, abs(approx_value.expected - other_value)",
                    "                     )",
                    "+                    if approx_value.expected == 0.0:",
                    "+                        max_rel_diff = math.inf",
                    "+                    else:",
                    "+                        max_rel_diff = max(",
                    "+                            max_rel_diff,",
                    "+                            abs(",
                    "+                                (approx_value.expected - other_value)",
                    "+                                / approx_value.expected",
                    "+                            ),",
                    "+                        )"
                ],
                "start_lineno": 268,
                "end_lineno": 280
            }
        ]
    },
    "django__django-13925": {
        "django/db/models/base.py": [
            {
                "hunk": [
                    "+            # Inherited PKs are checked in parents models.",
                    "+            not (",
                    "+                isinstance(cls._meta.pk, OneToOneField) and",
                    "+                cls._meta.pk.remote_field.parent_link",
                    "+            ) and"
                ],
                "start_lineno": 1302,
                "end_lineno": 1302
            }
        ]
    },
    "django__django-13454": {
        "django/contrib/contenttypes/fields.py": [
            {
                "hunk": [
                    "+    empty_strings_allowed = False"
                ],
                "start_lineno": 280,
                "end_lineno": 280
            },
            {
                "hunk": [
                    "+        # Reverse relations are always nullable (Django can't enforce that a",
                    "+        # foreign key on the related model points to this model).",
                    "+        kwargs['null'] = True"
                ],
                "start_lineno": 298,
                "end_lineno": 298
            }
        ]
    },
    "scikit-learn__scikit-learn-14869": {
        "sklearn/ensemble/_hist_gradient_boosting/gradient_boosting.py": [
            {
                "hunk": [
                    "+        if (self.loss == 'categorical_crossentropy' and",
                    "+                self.n_trees_per_iteration_ == 1):",
                    "+            raise ValueError(\"'categorical_crossentropy' is not suitable for \"",
                    "+                             \"a binary classification problem. Please use \"",
                    "+                             \"'auto' or 'binary_crossentropy' instead.\")",
                    "+"
                ],
                "start_lineno": 1042,
                "end_lineno": 1042
            }
        ]
    },
    "django__django-12957": {
        "django/utils/formats.py": [
            {
                "hunk": [
                    "+        if use_l10n is False:",
                    "+            return str(value)"
                ],
                "start_lineno": 200,
                "end_lineno": 200
            }
        ]
    },
    "django__django-14124": {
        "django/contrib/admindocs/utils.py": [
            {
                "hunk": [
                    "+    if hasattr(view_func, 'view_class'):",
                    "+        klass = view_func.view_class",
                    "+        return f'{klass.__module__}.{klass.__qualname__}'"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            }
        ],
        "django/urls/resolvers.py": [
            {
                "hunk": [
                    "-        if not hasattr(callback, '__name__'):",
                    "+        if hasattr(callback, 'view_class'):",
                    "+            callback = callback.view_class",
                    "+        elif not hasattr(callback, '__name__'):"
                ],
                "start_lineno": 381,
                "end_lineno": 381
            }
        ],
        "django/views/debug.py": [
            {
                "hunk": [
                    "-        if hasattr(obj, '__name__'):",
                    "+        if hasattr(obj, 'view_class'):",
                    "+            caller = obj.view_class",
                    "+        elif hasattr(obj, '__name__'):"
                ],
                "start_lineno": 520,
                "end_lineno": 520
            }
        ],
        "django/views/generic/base.py": [
            {
                "hunk": [
                    "-from functools import update_wrapper"
                ],
                "start_lineno": 2,
                "end_lineno": 2
            },
            {
                "hunk": [
                    "-        # take name and docstring from class",
                    "-        update_wrapper(view, cls, updated=())",
                    "+        # __name__ and __qualname__ are intentionally left unchanged as",
                    "+        # view_class should be used to robustly determine the name of the view",
                    "+        # instead.",
                    "+        view.__doc__ = cls.__doc__",
                    "+        view.__module__ = cls.__module__",
                    "+        view.__annotations__ = cls.dispatch.__annotations__",
                    "+        # Copy possible attributes set by decorators, e.g. @csrf_exempt, from",
                    "+        # the dispatch method.",
                    "+        view.__dict__.update(cls.dispatch.__dict__)",
                    " ",
                    "-        # and possible attributes set by decorators",
                    "-        # like csrf_exempt from dispatch",
                    "-        update_wrapper(view, cls.dispatch, assigned=())"
                ],
                "start_lineno": 74,
                "end_lineno": 79
            }
        ]
    },
    "django__django-12091": {
        "django/http/request.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "+from django.utils.deprecation import RemovedInDjango40Warning"
                ],
                "start_lineno": 18,
                "end_lineno": 18
            },
            {
                "hunk": [
                    "+        warnings.warn(",
                    "+            'request.is_ajax() is deprecated. See Django 3.1 release notes '",
                    "+            'for more details about this deprecation.',",
                    "+            RemovedInDjango40Warning,",
                    "+        )"
                ],
                "start_lineno": 259,
                "end_lineno": 259
            }
        ],
        "django/views/debug.py": [
            {
                "hunk": [
                    "-    if request.is_ajax():",
                    "-        text = reporter.get_traceback_text()",
                    "-        return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')",
                    "-    else:",
                    "+    if request.accepts('text/html'):",
                    "         html = reporter.get_traceback_html()",
                    "         return HttpResponse(html, status=status_code, content_type='text/html')",
                    "+    else:",
                    "+        text = reporter.get_traceback_text()",
                    "+        return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')"
                ],
                "start_lineno": 51,
                "end_lineno": 56
            }
        ],
        "django/views/i18n.py": [
            {
                "hunk": [
                    "-        (next_url or not request.is_ajax()) and",
                    "+        (next_url or request.accepts('text/html')) and"
                ],
                "start_lineno": 36,
                "end_lineno": 36
            }
        ]
    },
    "pylint-dev__pylint-4604": {
        "pylint/checkers/variables.py": [
            {
                "hunk": [
                    "+        if isinstance(type_annotation, astroid.Attribute):",
                    "+            self._store_type_annotation_node(type_annotation.expr)",
                    "+            return",
                    "+"
                ],
                "start_lineno": 1829,
                "end_lineno": 1829
            }
        ],
        "pylint/constants.py": [
            {
                "hunk": [
                    "+import platform"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "+IS_PYPY = platform.python_implementation() == \"PyPy\""
                ],
                "start_lineno": 14,
                "end_lineno": 14
            }
        ]
    },
    "sphinx-doc__sphinx-10360": {
        "sphinx/domains/c.py": [
            {
                "hunk": [
                    "-from sphinx.util.cfamily import (ASTAttribute, ASTBaseBase, ASTBaseParenExprList, BaseParser,",
                    "-                                 DefinitionError, NoOldIdError, StringifyTransform,",
                    "+from sphinx.util.cfamily import (ASTAttributeList, ASTBaseBase, ASTBaseParenExprList,",
                    "+                                 BaseParser, DefinitionError, NoOldIdError, StringifyTransform,"
                ],
                "start_lineno": 24,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "-    def __init__(self, args: List[ASTFunctionParameter], attrs: List[ASTAttribute]) -> None:",
                    "+    def __init__(self, args: List[ASTFunctionParameter], attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 690,
                "end_lineno": 690
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "+        if len(self.attrs) != 0:",
                    "             res.append(' ')",
                    "-            res.append(transform(attr))",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 708,
                "end_lineno": 710
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "+        if len(self.attrs) != 0:",
                    "             signode += addnodes.desc_sig_space()",
                    "-            attr.describe_signature(signode)",
                    "+            self.attrs.describe_signature(signode)",
                    " ",
                    " ",
                    " class ASTDeclSpecsSimple(ASTBaseBase):",
                    "     def __init__(self, storage: str, threadLocal: str, inline: bool,",
                    "-                 restrict: bool, volatile: bool, const: bool, attrs: List[Any]) -> None:",
                    "+                 restrict: bool, volatile: bool, const: bool, attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 735,
                "end_lineno": 742
            },
            {
                "hunk": [
                    "-        res.extend(transform(attr) for attr in self.attrs)",
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 764,
                "end_lineno": 764
            },
            {
                "hunk": [
                    "-            if len(modifiers) > 0:",
                    "+            if len(modifiers) != 0:",
                    "                 modifiers.append(addnodes.desc_sig_space())",
                    "             modifiers.append(addnodes.desc_sig_keyword(text, text))",
                    " ",
                    "-        for attr in self.attrs:",
                    "-            if len(modifiers) > 0:",
                    "-                modifiers.append(addnodes.desc_sig_space())",
                    "-            modifiers.append(attr.describe_signature(modifiers))",
                    "+        if len(modifiers) != 0 and len(self.attrs) != 0:",
                    "+            modifiers.append(addnodes.desc_sig_space())",
                    "+        tempNode = nodes.TextElement()",
                    "+        self.attrs.describe_signature(tempNode)",
                    "+        modifiers.extend(tempNode.children)"
                ],
                "start_lineno": 781,
                "end_lineno": 788
            },
            {
                "hunk": [
                    "-                 attrs: Any) -> None:",
                    "+                 attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 1005,
                "end_lineno": 1005
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            res.append(transform(a))",
                    "-        if len(self.attrs) > 0 and (self.restrict or self.volatile or self.const):",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0 and (self.restrict or self.volatile or self.const):"
                ],
                "start_lineno": 1028,
                "end_lineno": 1030
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            a.describe_signature(signode)",
                    "-        if len(self.attrs) > 0 and (self.restrict or self.volatile or self.const):",
                    "+        self.attrs.describe_signature(signode)",
                    "+        if len(self.attrs) != 0 and (self.restrict or self.volatile or self.const):"
                ],
                "start_lineno": 1052,
                "end_lineno": 1054
            },
            {
                "hunk": [
                    "-    def __init__(self, name: ASTNestedName, init: ASTInitializer) -> None:",
                    "+    def __init__(self, name: ASTNestedName, init: Optional[ASTInitializer],",
                    "+                 attrs: ASTAttributeList) -> None:",
                    "         self.name = name",
                    "         self.init = init",
                    "+        self.attrs = attrs"
                ],
                "start_lineno": 1377,
                "end_lineno": 1379
            },
            {
                "hunk": [
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(' ')",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 1387,
                "end_lineno": 1387
            },
            {
                "hunk": [
                    "+        if len(self.attrs) != 0:",
                    "+            signode += addnodes.desc_sig_space()",
                    "+            self.attrs.describe_signature(signode)"
                ],
                "start_lineno": 1395,
                "end_lineno": 1395
            },
            {
                "hunk": [
                    "-        attrs = []",
                    "-        while True:",
                    "-            attr = self._parse_attribute()",
                    "-            if attr is None:",
                    "-                break",
                    "-            attrs.append(attr)",
                    "-",
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 2644,
                "end_lineno": 2650
            },
            {
                "hunk": [
                    "-                                  restrict, volatile, const, attrs)",
                    "+                                  restrict, volatile, const, ASTAttributeList(attrs))"
                ],
                "start_lineno": 2709,
                "end_lineno": 2709
            },
            {
                "hunk": [
                    "-                                    attrs=attrs)",
                    "+                                    attrs=ASTAttributeList(attrs))"
                ],
                "start_lineno": 2841,
                "end_lineno": 2841
            },
            {
                "hunk": [
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 3036,
                "end_lineno": 3036
            },
            {
                "hunk": [
                    "-        return ASTEnumerator(name, init)",
                    "+        return ASTEnumerator(name, init, attrs)"
                ],
                "start_lineno": 3046,
                "end_lineno": 3046
            }
        ],
        "sphinx/domains/cpp.py": [
            {
                "hunk": [
                    "-from sphinx.util.cfamily import (ASTAttribute, ASTBaseBase, ASTBaseParenExprList, BaseParser,",
                    "-                                 DefinitionError, NoOldIdError, StringifyTransform,",
                    "+from sphinx.util.cfamily import (ASTAttributeList, ASTBaseBase, ASTBaseParenExprList,",
                    "+                                 BaseParser, DefinitionError, NoOldIdError, StringifyTransform,"
                ],
                "start_lineno": 24,
                "end_lineno": 25
            },
            {
                "hunk": [
                    "-                 override: bool, final: bool, attrs: List[ASTAttribute],",
                    "+                 override: bool, final: bool, attrs: ASTAttributeList,"
                ],
                "start_lineno": 2051,
                "end_lineno": 2051
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "+        if len(self.attrs) != 0:",
                    "             res.append(' ')",
                    "-            res.append(transform(attr))",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 2121,
                "end_lineno": 2123
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "+        if len(self.attrs) != 0:",
                    "             signode += addnodes.desc_sig_space()",
                    "-            attr.describe_signature(signode)",
                    "+            self.attrs.describe_signature(signode)"
                ],
                "start_lineno": 2174,
                "end_lineno": 2176
            },
            {
                "hunk": [
                    "-                 attrs: List[ASTAttribute]) -> None:",
                    "+                 attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 2214,
                "end_lineno": 2214
            },
            {
                "hunk": [
                    "-        res.extend(transform(attr) for attr in self.attrs)",
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 2246,
                "end_lineno": 2246
            },
            {
                "hunk": [
                    "-        addSpace = False",
                    "-        for attr in self.attrs:",
                    "-            if addSpace:",
                    "-                signode += addnodes.desc_sig_space()",
                    "-            addSpace = True",
                    "-            attr.describe_signature(signode)",
                    "+        self.attrs.describe_signature(signode)",
                    "+        addSpace = len(self.attrs) != 0"
                ],
                "start_lineno": 2273,
                "end_lineno": 2278
            },
            {
                "hunk": [
                    "-                 attrs: List[ASTAttribute]) -> None:",
                    "+                 attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 2595,
                "end_lineno": 2595
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            res.append(transform(a))",
                    "-        if len(self.attrs) > 0 and (self.volatile or self.const):",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0 and (self.volatile or self.const):"
                ],
                "start_lineno": 2623,
                "end_lineno": 2625
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            a.describe_signature(signode)",
                    "-        if len(self.attrs) > 0 and (self.volatile or self.const):",
                    "+        self.attrs.describe_signature(signode)",
                    "+        if len(self.attrs) != 0 and (self.volatile or self.const):"
                ],
                "start_lineno": 2680,
                "end_lineno": 2682
            },
            {
                "hunk": [
                    "-    def __init__(self, next: ASTDeclarator, attrs: List[ASTAttribute]) -> None:",
                    "+    def __init__(self, next: ASTDeclarator, attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 2700,
                "end_lineno": 2700
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            res.append(transform(a))",
                    "-        if len(self.attrs) > 0 and self.next.require_space_after_declSpecs():",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0 and self.next.require_space_after_declSpecs():"
                ],
                "start_lineno": 2730,
                "end_lineno": 2732
            },
            {
                "hunk": [
                    "-        for a in self.attrs:",
                    "-            a.describe_signature(signode)",
                    "+        self.attrs.describe_signature(signode)"
                ],
                "start_lineno": 2761,
                "end_lineno": 2762
            },
            {
                "hunk": [
                    "-                 attrs: List[ASTAttribute]) -> None:",
                    "+                 attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 3352,
                "end_lineno": 3352
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "-            res.append(transform(attr) + ' ')",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(' ')"
                ],
                "start_lineno": 3363,
                "end_lineno": 3364
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "-            attr.describe_signature(signode)",
                    "+        self.attrs.describe_signature(signode)",
                    "+        if len(self.attrs) != 0:"
                ],
                "start_lineno": 3381,
                "end_lineno": 3382
            },
            {
                "hunk": [
                    "-    def __init__(self, name: ASTNestedName, attrs: List[ASTAttribute]) -> None:",
                    "+    def __init__(self, name: ASTNestedName, attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 3401,
                "end_lineno": 3401
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "-            res.append(transform(attr) + ' ')",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(' ')",
                    "         res.append(transform(self.name))",
                    "         return ''.join(res)",
                    " ",
                    "     def describe_signature(self, signode: TextElement, mode: str,",
                    "                            env: \"BuildEnvironment\", symbol: \"Symbol\") -> None:",
                    "         verify_description_mode(mode)",
                    "-        for attr in self.attrs:",
                    "-            attr.describe_signature(signode)",
                    "+        self.attrs.describe_signature(signode)",
                    "+        if len(self.attrs) != 0:",
                    "             signode += addnodes.desc_sig_space()",
                    "         self.name.describe_signature(signode, mode, env, symbol=symbol)",
                    " ",
                    " ",
                    " class ASTEnum(ASTBase):",
                    "     def __init__(self, name: ASTNestedName, scoped: str, underlyingType: ASTType,",
                    "-                 attrs: List[ASTAttribute]) -> None:",
                    "+                 attrs: ASTAttributeList) -> None:"
                ],
                "start_lineno": 3412,
                "end_lineno": 3428
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "-            res.append(transform(attr) + ' ')",
                    "+        res.append(transform(self.attrs))",
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(' ')"
                ],
                "start_lineno": 3444,
                "end_lineno": 3445
            },
            {
                "hunk": [
                    "-        for attr in self.attrs:",
                    "-            attr.describe_signature(signode)",
                    "+        self.attrs.describe_signature(signode)",
                    "+        if len(self.attrs) != 0:"
                ],
                "start_lineno": 3456,
                "end_lineno": 3457
            },
            {
                "hunk": [
                    "-    def __init__(self, name: ASTNestedName, init: ASTInitializer) -> None:",
                    "+    def __init__(self, name: ASTNestedName, init: Optional[ASTInitializer],",
                    "+                 attrs: ASTAttributeList) -> None:",
                    "         self.name = name",
                    "         self.init = init",
                    "+        self.attrs = attrs"
                ],
                "start_lineno": 3469,
                "end_lineno": 3471
            },
            {
                "hunk": [
                    "+        if len(self.attrs) != 0:",
                    "+            res.append(' ')",
                    "+            res.append(transform(self.attrs))"
                ],
                "start_lineno": 3481,
                "end_lineno": 3481
            },
            {
                "hunk": [
                    "+        if len(self.attrs) != 0:",
                    "+            signode += addnodes.desc_sig_space()",
                    "+            self.attrs.describe_signature(signode)"
                ],
                "start_lineno": 3489,
                "end_lineno": 3489
            },
            {
                "hunk": [
                    "-        attrs = []",
                    "-        while True:",
                    "-            attr = self._parse_attribute()",
                    "-            if attr is None:",
                    "-                break",
                    "-            attrs.append(attr)",
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 6121,
                "end_lineno": 6126
            },
            {
                "hunk": [
                    "-                                  volatile, const, friend, attrs)",
                    "+                                  volatile, const, friend, ASTAttributeList(attrs))"
                ],
                "start_lineno": 6238,
                "end_lineno": 6238
            },
            {
                "hunk": [
                    "-            attrs = []",
                    "+            attrList = []"
                ],
                "start_lineno": 6335,
                "end_lineno": 6335
            },
            {
                "hunk": [
                    "-                    attrs.append(attr)",
                    "+                    attrList.append(attr)",
                    "                     continue",
                    "                 break",
                    "             next = self._parse_declarator(named, paramMode, typed)",
                    "-            return ASTDeclaratorPtr(next=next, volatile=volatile, const=const, attrs=attrs)",
                    "+            return ASTDeclaratorPtr(next=next, volatile=volatile, const=const,",
                    "+                                    attrs=ASTAttributeList(attrList))",
                    "         # TODO: shouldn't we parse an R-value ref here first?",
                    "         if typed and self.skip_string(\"&\"):",
                    "-            attrs = []",
                    "-            while 1:",
                    "-                attr = self._parse_attribute()",
                    "-                if attr is None:",
                    "-                    break",
                    "-                attrs.append(attr)",
                    "+            attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 6347,
                "end_lineno": 6359
            },
            {
                "hunk": [
                    "-        attrs = []",
                    "-        while 1:",
                    "-            attr = self._parse_attribute()",
                    "-            if attr is None:",
                    "-                break",
                    "-            attrs.append(attr)",
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 6631,
                "end_lineno": 6636
            },
            {
                "hunk": [
                    "-        attrs = []",
                    "-        while 1:",
                    "-            attr = self._parse_attribute()",
                    "-            if attr is None:",
                    "-                break",
                    "-            attrs.append(attr)",
                    "+        attrs = self._parse_attribute_list()",
                    "         name = self._parse_nested_name()",
                    "         return ASTUnion(name, attrs)",
                    " ",
                    "     def _parse_enum(self) -> ASTEnum:",
                    "         scoped = None  # is set by CPPEnumObject",
                    "-        attrs = []",
                    "-        while 1:",
                    "-            attr = self._parse_attribute()",
                    "-            if attr is None:",
                    "-                break",
                    "-            attrs.append(attr)",
                    "-        self.skip_ws()",
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 6667,
                "end_lineno": 6684
            },
            {
                "hunk": [
                    "+        attrs = self._parse_attribute_list()"
                ],
                "start_lineno": 6694,
                "end_lineno": 6694
            },
            {
                "hunk": [
                    "-        return ASTEnumerator(name, init)",
                    "+        return ASTEnumerator(name, init, attrs)"
                ],
                "start_lineno": 6703,
                "end_lineno": 6703
            }
        ],
        "sphinx/util/cfamily.py": [
            {
                "hunk": [
                    "+class ASTAttributeList(ASTBaseBase):",
                    "+    def __init__(self, attrs: List[ASTAttribute]) -> None:",
                    "+        self.attrs = attrs",
                    "+",
                    "+    def __len__(self) -> int:",
                    "+        return len(self.attrs)",
                    "+",
                    "+    def __add__(self, other: \"ASTAttributeList\") -> \"ASTAttributeList\":",
                    "+        return ASTAttributeList(self.attrs + other.attrs)",
                    "+",
                    "+    def _stringify(self, transform: StringifyTransform) -> str:",
                    "+        return ' '.join(transform(attr) for attr in self.attrs)",
                    "+",
                    "+    def describe_signature(self, signode: TextElement) -> None:",
                    "+        if len(self.attrs) == 0:",
                    "+            return",
                    "+        self.attrs[0].describe_signature(signode)",
                    "+        if len(self.attrs) == 1:",
                    "+            return",
                    "+        for attr in self.attrs[1:]:",
                    "+            signode.append(addnodes.desc_sig_space())",
                    "+            attr.describe_signature(signode)",
                    "+",
                    "+"
                ],
                "start_lineno": 195,
                "end_lineno": 195
            },
            {
                "hunk": [
                    "+    def _parse_attribute_list(self) -> ASTAttributeList:",
                    "+        res = []",
                    "+        while True:",
                    "+            attr = self._parse_attribute()",
                    "+            if attr is None:",
                    "+                break",
                    "+            res.append(attr)",
                    "+        return ASTAttributeList(res)",
                    "+"
                ],
                "start_lineno": 426,
                "end_lineno": 426
            }
        ]
    },
    "astropy__astropy-13745": {
        "astropy/coordinates/angles.py": [
            {
                "hunk": [
                    "-            limit = 0.5 * np.pi",
                    "+            limit = self.dtype.type(0.5 * np.pi)"
                ],
                "start_lineno": 590,
                "end_lineno": 590
            }
        ]
    },
    "psf__requests-5414": {
        "requests/models.py": [
            {
                "hunk": [
                    "-        elif host.startswith(u'*'):",
                    "+        elif host.startswith((u'*', u'.')):"
                ],
                "start_lineno": 406,
                "end_lineno": 406
            }
        ]
    },
    "sphinx-doc__sphinx-8291": {
        "doc/usage/extensions/example_google.py": [
            {
                "hunk": [
                    "+",
                    "+class ExamplePEP526Class:",
                    "+    \"\"\"The summary line for a class docstring should fit on one line.",
                    "+",
                    "+    If the class has public attributes, they may be documented here",
                    "+    in an ``Attributes`` section and follow the same formatting as a",
                    "+    function's ``Args`` section. If ``napoleon_attr_annotations``",
                    "+    is True, types can be specified in the class body using ``PEP 526``",
                    "+    annotations.",
                    "+",
                    "+    Attributes:",
                    "+        attr1: Description of `attr1`.",
                    "+        attr2: Description of `attr2`.",
                    "+",
                    "+    \"\"\"",
                    "+",
                    "+    attr1: str",
                    "+    attr2: int"
                ],
                "start_lineno": 297,
                "end_lineno": 297
            }
        ],
        "sphinx/ext/napoleon/__init__.py": [
            {
                "hunk": [
                    "+        napoleon_attr_annotations = True"
                ],
                "start_lineno": 47,
                "end_lineno": 47
            },
            {
                "hunk": [
                    "+    napoleon_attr_annotations : :obj:`bool` (Defaults to True)",
                    "+        Use the type annotations of class attributes that are documented in the docstring",
                    "+        but do not have a type in the docstring."
                ],
                "start_lineno": 260,
                "end_lineno": 260
            },
            {
                "hunk": [
                    "-        'napoleon_custom_sections': (None, 'env')",
                    "+        'napoleon_custom_sections': (None, 'env'),",
                    "+        'napoleon_attr_annotations': (True, 'env'),"
                ],
                "start_lineno": 277,
                "end_lineno": 277
            }
        ],
        "sphinx/ext/napoleon/docstring.py": [
            {
                "hunk": [
                    "+from sphinx.util.inspect import stringify_annotation",
                    "+from sphinx.util.typing import get_type_hints"
                ],
                "start_lineno": 24,
                "end_lineno": 24
            },
            {
                "hunk": [
                    "+            if not _type:",
                    "+                _type = self._lookup_annotation(_name)"
                ],
                "start_lineno": 603,
                "end_lineno": 603
            },
            {
                "hunk": [
                    "+    def _lookup_annotation(self, _name: str) -> str:",
                    "+        if self._config.napoleon_attr_annotations:",
                    "+            if self._what in (\"module\", \"class\", \"exception\") and self._obj:",
                    "+                # cache the class annotations",
                    "+                if not hasattr(self, \"_annotations\"):",
                    "+                    localns = getattr(self._config, \"autodoc_type_aliases\", {})",
                    "+                    localns.update(getattr(",
                    "+                                   self._config, \"napoleon_type_aliases\", {}",
                    "+                                   ) or {})",
                    "+                    self._annotations = get_type_hints(self._obj, None, localns)",
                    "+                if _name in self._annotations:",
                    "+                    return stringify_annotation(self._annotations[_name])",
                    "+        # No annotation found",
                    "+        return \"\"",
                    "+"
                ],
                "start_lineno": 807,
                "end_lineno": 807
            },
            {
                "hunk": [
                    "+        if parse_type and not _type:",
                    "+            _type = self._lookup_annotation(_name)",
                    "+"
                ],
                "start_lineno": 1111,
                "end_lineno": 1111
            }
        ],
        "sphinx/util/typing.py": [
            {
                "hunk": [
                    "-        return typing.get_type_hints(obj, None, localns)",
                    "+        return typing.get_type_hints(obj, globalns, localns)"
                ],
                "start_lineno": 69,
                "end_lineno": 69
            }
        ]
    },
    "pylint-dev__pylint-6528": {
        "pylint/lint/expand_modules.py": [
            {
                "hunk": [
                    "+def _is_ignored_file(",
                    "+    element: str,",
                    "+    ignore_list: list[str],",
                    "+    ignore_list_re: list[Pattern[str]],",
                    "+    ignore_list_paths_re: list[Pattern[str]],",
                    "+) -> bool:",
                    "+    basename = os.path.basename(element)",
                    "+    return (",
                    "+        basename in ignore_list",
                    "+        or _is_in_ignore_list_re(basename, ignore_list_re)",
                    "+        or _is_in_ignore_list_re(element, ignore_list_paths_re)",
                    "+    )",
                    "+",
                    "+"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            },
            {
                "hunk": [
                    "-        if (",
                    "-            basename in ignore_list",
                    "-            or _is_in_ignore_list_re(os.path.basename(something), ignore_list_re)",
                    "-            or _is_in_ignore_list_re(something, ignore_list_paths_re)",
                    "+        if _is_ignored_file(",
                    "+            something, ignore_list, ignore_list_re, ignore_list_paths_re"
                ],
                "start_lineno": 64,
                "end_lineno": 67
            }
        ],
        "pylint/lint/pylinter.py": [
            {
                "hunk": [
                    "-from pylint.lint.expand_modules import expand_modules",
                    "+from pylint.lint.expand_modules import _is_ignored_file, expand_modules"
                ],
                "start_lineno": 34,
                "end_lineno": 34
            },
            {
                "hunk": [
                    "-    @staticmethod",
                    "-    def _discover_files(files_or_modules: Sequence[str]) -> Iterator[str]:",
                    "+    def _discover_files(self, files_or_modules: Sequence[str]) -> Iterator[str]:"
                ],
                "start_lineno": 567,
                "end_lineno": 568
            },
            {
                "hunk": [
                    "+",
                    "+                    if _is_ignored_file(",
                    "+                        root,",
                    "+                        self.config.ignore,",
                    "+                        self.config.ignore_patterns,",
                    "+                        self.config.ignore_paths,",
                    "+                    ):",
                    "+                        skip_subtrees.append(root)",
                    "+                        continue",
                    "+"
                ],
                "start_lineno": 582,
                "end_lineno": 582
            }
        ]
    },
    "django__django-9296": {
        "django/core/paginator.py": [
            {
                "hunk": [
                    "+    def __iter__(self):",
                    "+        for page_number in self.page_range:",
                    "+            yield self.page(page_number)",
                    "+"
                ],
                "start_lineno": 37,
                "end_lineno": 37
            }
        ]
    },
    "scikit-learn__scikit-learn-11281": {
        "sklearn/mixture/base.py": [
            {
                "hunk": [
                    "-        The method fit the model `n_init` times and set the parameters with",
                    "+        The method fits the model `n_init` times and set the parameters with"
                ],
                "start_lineno": 175,
                "end_lineno": 175
            },
            {
                "hunk": [
                    "+        self.fit_predict(X, y)",
                    "+        return self",
                    "+",
                    "+    def fit_predict(self, X, y=None):",
                    "+        \"\"\"Estimate model parameters using X and predict the labels for X.",
                    "+",
                    "+        The method fits the model n_init times and sets the parameters with",
                    "+        which the model has the largest likelihood or lower bound. Within each",
                    "+        trial, the method iterates between E-step and M-step for `max_iter`",
                    "+        times until the change of likelihood or lower bound is less than",
                    "+        `tol`, otherwise, a `ConvergenceWarning` is raised. After fitting, it",
                    "+        predicts the most probable label for the input data points.",
                    "+",
                    "+        .. versionadded:: 0.20",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        X : array-like, shape (n_samples, n_features)",
                    "+            List of n_features-dimensional data points. Each row",
                    "+            corresponds to a single data point.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        labels : array, shape (n_samples,)",
                    "+            Component labels.",
                    "+        \"\"\""
                ],
                "start_lineno": 191,
                "end_lineno": 191
            },
            {
                "hunk": [
                    "-        return self",
                    "+        return log_resp.argmax(axis=1)"
                ],
                "start_lineno": 243,
                "end_lineno": 243
            }
        ]
    },
    "django__django-13165": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        if getattr(expression, '_output_field_or_none', True) is None:",
                    "-            expression = expression.copy()",
                    "-            expression.output_field = output_field"
                ],
                "start_lineno": 861,
                "end_lineno": 863
            },
            {
                "hunk": [
                    "-        return self.expression.get_group_by_cols(alias=alias)",
                    "+        expression = self.expression.copy()",
                    "+        expression.output_field = self.output_field",
                    "+        return expression.get_group_by_cols(alias=alias)"
                ],
                "start_lineno": 873,
                "end_lineno": 873
            }
        ]
    },
    "sympy__sympy-18667": {
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"",
                    "+The Schur number S(k) is the largest integer n for which the interval [1,n]",
                    "+can be partitioned into k sum-free sets.(http://mathworld.wolfram.com/SchurNumber.html)",
                    "+\"\"\"",
                    "+import math",
                    "+from sympy.core import S",
                    "+from sympy.core.basic import Basic",
                    "+from sympy.core.function import Function",
                    "+from sympy.core.numbers import Integer",
                    "+",
                    "+",
                    "+class SchurNumber(Function):",
                    "+    \"\"\"",
                    "+    This function creates a SchurNumber object",
                    "+    which is evaluated for k <= 4 otherwise only",
                    "+    the lower bound information can be retrieved.",
                    "+",
                    "+    Examples",
                    "+    ========",
                    "+",
                    "+    >>> from sympy.combinatorics.schur_number import SchurNumber",
                    "+",
                    "+    Since S(3) = 13, hence the output is a number",
                    "+    >>> SchurNumber(3)",
                    "+    13",
                    "+",
                    "+    We don't know the schur number for values greater than 4, hence",
                    "+    only the object is returned",
                    "+    >>> SchurNumber(6)",
                    "+    SchurNumber(6)",
                    "+",
                    "+    Now, the lower bound information can be retrieved using lower_bound()",
                    "+    method",
                    "+    >>> SchurNumber(6).lower_bound()",
                    "+    364",
                    "+",
                    "+    \"\"\"",
                    "+",
                    "+    @classmethod",
                    "+    def eval(cls, k):",
                    "+        if k.is_Number:",
                    "+            if k is S.Infinity:",
                    "+                return S.Infinity",
                    "+            if k.is_zero:",
                    "+                return 0",
                    "+            if not k.is_integer or k.is_negative:",
                    "+                raise ValueError(\"k should be a positive integer\")",
                    "+            first_known_schur_numbers = {1: 1, 2: 4, 3: 13, 4: 44}",
                    "+            if k <= 4:",
                    "+                return Integer(first_known_schur_numbers[k])",
                    "+",
                    "+    def lower_bound(self):",
                    "+        f_ = self.args[0]",
                    "+        return (3**f_ - 1)/2",
                    "+",
                    "+",
                    "+def _schur_subsets_number(n):",
                    "+",
                    "+    if n is S.Infinity:",
                    "+        raise ValueError(\"Input must be finite\")",
                    "+    if n <= 0:",
                    "+        raise ValueError(\"n must be a non-zero positive integer.\")",
                    "+    elif n <= 3:",
                    "+        min_k = 1",
                    "+    else:",
                    "+        min_k = math.ceil(math.log(2*n + 1, 3))",
                    "+",
                    "+    return Integer(min_k)",
                    "+",
                    "+",
                    "+def schur_partition(n):",
                    "+    \"\"\"",
                    "+",
                    "+    This function returns the partition in the minimum number of sum-free subsets",
                    "+    according to the lower bound given by the Schur Number.",
                    "+",
                    "+    Parameters",
                    "+    ==========",
                    "+",
                    "+    n: a number",
                    "+        n is the upper limit of the range [1, n] for which we need to find and",
                    "+        return the minimum number of free subsets according to the lower bound",
                    "+        of schur number",
                    "+",
                    "+    Returns",
                    "+    =======",
                    "+",
                    "+    List of lists",
                    "+        List of the minimum number of sum-free subsets",
                    "+",
                    "+    Notes",
                    "+    =====",
                    "+",
                    "+    It is possible for some n to make the partition into less",
                    "+    subsets since the only known Schur numbers are:",
                    "+    S(1) = 1, S(2) = 4 , S(3) = 13, S(4) = 44.",
                    "+    e.g for n = 44 the lower bound from the function above is 5 subsets but it has been proven",
                    "+    that can be done with 4 subsets.",
                    "+",
                    "+    Examples",
                    "+    ========",
                    "+",
                    "+    For n = 1, 2, 3 the answer is the set itself",
                    "+",
                    "+    >>> from sympy.combinatorics.schur_number import schur_partition",
                    "+    >>> schur_partition(2)",
                    "+    [[1, 2]]",
                    "+",
                    "+    For n > 3, the answer is the minimum number of sum-free subsets:",
                    "+",
                    "+    >>> schur_partition(5)",
                    "+    [[3, 2], [5], [1, 4]]",
                    "+",
                    "+    >>> schur_partition(8)",
                    "+    [[3, 2], [6, 5, 8], [1, 4, 7]]",
                    "+    \"\"\"",
                    "+",
                    "+    if isinstance(n, Basic) and not n.is_Number:",
                    "+        raise ValueError(\"Input value must be a number\")",
                    "+",
                    "+    number_of_subsets = _schur_subsets_number(n)",
                    "+    if n == 1:",
                    "+        sum_free_subsets = [[1]]",
                    "+    elif n == 2:",
                    "+        sum_free_subsets = [[1, 2]]",
                    "+    elif n == 3:",
                    "+        sum_free_subsets = [[1, 2, 3]]",
                    "+    else:",
                    "+        sum_free_subsets = [[1, 4], [2, 3]]",
                    "+",
                    "+    while len(sum_free_subsets) < number_of_subsets:",
                    "+        sum_free_subsets = _generate_next_list(sum_free_subsets, n)",
                    "+        missed_elements = [3*k + 1 for k in range(len(sum_free_subsets), (n-1)//3 + 1)]",
                    "+        sum_free_subsets[-1] += missed_elements",
                    "+",
                    "+    return sum_free_subsets",
                    "+",
                    "+",
                    "+def _generate_next_list(current_list, n):",
                    "+    new_list = []",
                    "+",
                    "+    for item in current_list:",
                    "+        temp_1 = [number*3 for number in item if number*3 <= n]",
                    "+        temp_2 = [number*3 - 1 for number in item if number*3 - 1 <= n]",
                    "+        new_item = temp_1 + temp_2",
                    "+        new_list.append(new_item)",
                    "+",
                    "+    last_list = [3*k + 1 for k in range(0, len(current_list)+1) if 3*k + 1 <= n]",
                    "+    new_list.append(last_list)",
                    "+    current_list = new_list",
                    "+",
                    "+    return current_list"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ]
    },
    "sympy__sympy-15349": {
        "sympy/algebras/quaternion.py": [
            {
                "hunk": [
                    "-        m12 = 2*s*(q.c*q.d + q.b*q.a)",
                    "+        m12 = 2*s*(q.c*q.d - q.b*q.a)"
                ],
                "start_lineno": 532,
                "end_lineno": 532
            }
        ]
    },
    "sympy__sympy-21567": {
        "sympy/functions/elementary/hyperbolic.py": [
            {
                "hunk": [
                    "-",
                    "-"
                ],
                "start_lineno": 13,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "+    def _eval_expand_trig(self, **hints):",
                    "+        arg = self.args[0]",
                    "+        if arg.is_Add:",
                    "+            from sympy import symmetric_poly",
                    "+            CX = [coth(x, evaluate=False)._eval_expand_trig() for x in arg.args]",
                    "+            p = [[], []]",
                    "+            n = len(arg.args)",
                    "+            for i in range(n, -1, -1):",
                    "+                p[(n - i) % 2].append(symmetric_poly(i, CX))",
                    "+            return Add(*p[0])/Add(*p[1])",
                    "+        elif arg.is_Mul:",
                    "+            from sympy import binomial",
                    "+            coeff, x = arg.as_coeff_Mul(rational=True)",
                    "+            if coeff.is_Integer and coeff > 1:",
                    "+                c = coth(x, evaluate=False)",
                    "+                p = [[], []]",
                    "+                for i in range(coeff, -1, -1):",
                    "+                    p[(coeff - i) % 2].append(binomial(coeff, i)*c**i)",
                    "+                return Add(*p[0])/Add(*p[1])",
                    "+        return coth(arg)",
                    "+"
                ],
                "start_lineno": 880,
                "end_lineno": 880
            },
            {
                "hunk": [
                    "+    def _eval_expand_trig(self, **hints):",
                    "+        return self._calculate_reciprocal(\"_eval_expand_trig\", **hints)",
                    "+"
                ],
                "start_lineno": 942,
                "end_lineno": 942
            }
        ]
    },
    "django__django-15292": {
        "django/views/debug.py": [
            {
                "hunk": [
                    "-            caller = obj.view_class",
                    "-        elif hasattr(obj, '__name__'):",
                    "+            obj = obj.view_class",
                    "+",
                    "+        if hasattr(obj, '__name__'):"
                ],
                "start_lineno": 548,
                "end_lineno": 549
            }
        ]
    },
    "django__django-12009": {
        "django/bin/django-admin.py": [
            {
                "hunk": [
                    "+# When the django-admin.py deprecation ends, remove this script.",
                    "+import warnings",
                    "+",
                    " from django.core import management",
                    " ",
                    "+try:",
                    "+    from django.utils.deprecation import RemovedInDjango40Warning",
                    "+except ImportError:",
                    "+    raise ImportError(",
                    "+        'django-admin.py was deprecated in Django 3.1 and removed in Django '",
                    "+        '4.0. Please manually remove this script from your virtual environment '",
                    "+        'and use django-admin instead.'",
                    "+    )",
                    "+",
                    " if __name__ == \"__main__\":",
                    "+    warnings.warn(",
                    "+        'django-admin.py is deprecated in favor of django-admin.',",
                    "+        RemovedInDjango40Warning,",
                    "+    )"
                ],
                "start_lineno": 2,
                "end_lineno": 4
            }
        ]
    },
    "django__django-16502": {
        "django/core/servers/basehttp.py": [
            {
                "hunk": [
                    "+from collections import deque"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "+        if (",
                    "+            self.environ[\"REQUEST_METHOD\"] == \"HEAD\"",
                    "+            and \"Content-Length\" in self.headers",
                    "+        ):",
                    "+            del self.headers[\"Content-Length\"]",
                    "         # HTTP/1.1 requires support for persistent connections. Send 'close' if",
                    "         # the content length is unknown to prevent clients from reusing the",
                    "         # connection.",
                    "-        if \"Content-Length\" not in self.headers:",
                    "+        if (",
                    "+            self.environ[\"REQUEST_METHOD\"] != \"HEAD\"",
                    "+            and \"Content-Length\" not in self.headers",
                    "+        ):"
                ],
                "start_lineno": 133,
                "end_lineno": 136
            },
            {
                "hunk": [
                    "+    def finish_response(self):",
                    "+        if self.environ[\"REQUEST_METHOD\"] == \"HEAD\":",
                    "+            try:",
                    "+                deque(self.result, maxlen=0)  # Consume iterator.",
                    "+                # Don't call self.finish_content() as, if the headers have not",
                    "+                # been sent and Content-Length isn't set, it'll default to \"0\"",
                    "+                # which will prevent omission of the Content-Length header with",
                    "+                # HEAD requests as permitted by RFC 9110 Section 9.3.2.",
                    "+                # Instead, send the headers, if not sent yet.",
                    "+                if not self.headers_sent:",
                    "+                    self.send_headers()",
                    "+            finally:",
                    "+                self.close()",
                    "+        else:",
                    "+            super().finish_response()",
                    "+"
                ],
                "start_lineno": 150,
                "end_lineno": 150
            }
        ]
    },
    "matplotlib__matplotlib-25079": {
        "lib/matplotlib/colors.py": [
            {
                "hunk": [
                    "-        self.vmin = self.vmax = None",
                    "-        self.autoscale_None(A)",
                    "+        with self.callbacks.blocked():",
                    "+            # Pause callbacks while we are updating so we only get",
                    "+            # a single update signal at the end",
                    "+            self.vmin = self.vmax = None",
                    "+            self.autoscale_None(A)",
                    "+        self._changed()"
                ],
                "start_lineno": 1365,
                "end_lineno": 1366
            }
        ]
    },
    "astropy__astropy-14539": {
        "astropy/io/fits/diff.py": [
            {
                "hunk": [
                    "-            elif \"P\" in col.format:",
                    "+            elif \"P\" in col.format or \"Q\" in col.format:"
                ],
                "start_lineno": 1452,
                "end_lineno": 1452
            }
        ]
    },
    "sympy__sympy-12798": {
        "sympy/functions/combinatorial/factorials.py": [
            {
                "hunk": [
                    "-from sympy.polys.polytools import poly_from_expr",
                    "-from sympy.polys.polyerrors import PolificationFailed",
                    "-",
                    "+from sympy.polys.polytools import Poly"
                ],
                "start_lineno": 16,
                "end_lineno": 18
            },
            {
                "hunk": [
                    "-    \"\"\"Rising factorial (also called Pochhammer symbol) is a double valued",
                    "+    \"\"\"",
                    "+    Rising factorial (also called Pochhammer symbol) is a double valued"
                ],
                "start_lineno": 411,
                "end_lineno": 411
            },
            {
                "hunk": [
                    "-    When x is a polynomial f of a single variable y of order >= 1,",
                    "-    rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in",
                    "-    Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",",
                    "-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.",
                    "+    When x is a Poly instance of degree >= 1 with a single variable,",
                    "+    rf(x,k) = x(y) * x(y+1) * ... * x(y+k-1), where y is the variable of x.",
                    "+    This is as described in Peter Paule, \"Greatest Factorial Factorization and",
                    "+    Symbolic Summation\", Journal of Symbolic Computation, vol. 20, pp.",
                    "+    235-268, 1995.",
                    " ",
                    "     Examples",
                    "     ========",
                    " ",
                    "-    >>> from sympy import rf, symbols, factorial, ff, binomial",
                    "+    >>> from sympy import rf, symbols, factorial, ff, binomial, Poly"
                ],
                "start_lineno": 421,
                "end_lineno": 429
            },
            {
                "hunk": [
                    "-    >>> rf(x**3, 2)",
                    "+    >>> rf(Poly(x**3, x), 2)"
                ],
                "start_lineno": 438,
                "end_lineno": 438
            },
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 459,
                "end_lineno": 459
            },
            {
                "hunk": [
                    "-                        try:",
                    "-                            F, opt = poly_from_expr(x)",
                    "-                        except PolificationFailed:",
                    "-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)",
                    "-                        if len(opt.gens) > 1 or F.degree() <= 1:",
                    "-                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)",
                    "+                        if isinstance(x, Poly):",
                    "+                            gens = x.gens",
                    "+                            if len(gens)!= 1:",
                    "+                                raise ValueError(\"rf only defined for polynomials on one generator\")",
                    "+                            else:",
                    "+                                return reduce(lambda r, i:",
                    "+                                              r*(x.shift(i).expand()),",
                    "+                                              range(0, int(k)), 1)",
                    "                         else:",
                    "-                            v = opt.gens[0]",
                    "-                            return reduce(lambda r, i:",
                    "-                                          r*(F.subs(v, v + i).expand()),",
                    "-                                          range(0, int(k)), 1)",
                    "+                            return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)",
                    "+",
                    "                 else:",
                    "                     if x is S.Infinity:",
                    "                         return S.Infinity",
                    "                     elif x is S.NegativeInfinity:",
                    "                         return S.Infinity",
                    "                     else:",
                    "-                        try:",
                    "-                            F, opt = poly_from_expr(x)",
                    "-                        except PolificationFailed:",
                    "-                            return 1/reduce(lambda r, i:",
                    "-                                            r*(x - i),",
                    "-                                            range(1, abs(int(k)) + 1), 1)",
                    "-                        if len(opt.gens) > 1 or F.degree() <= 1:",
                    "-                            return 1/reduce(lambda r, i:",
                    "-                                            r*(x - i),",
                    "-                                            range(1, abs(int(k)) + 1), 1)",
                    "+                        if isinstance(x, Poly):",
                    "+                            gens = x.gens",
                    "+                            if len(gens)!= 1:",
                    "+                                raise ValueError(\"rf only defined for polynomials on one generator\")",
                    "+                            else:",
                    "+                                return 1/reduce(lambda r, i:",
                    "+                                                r*(x.shift(-i).expand()),",
                    "+                                                range(1, abs(int(k)) + 1), 1)",
                    "                         else:",
                    "-                            v = opt.gens[0]",
                    "                             return 1/reduce(lambda r, i:",
                    "-                                            r*(F.subs(v, v - i).expand()),",
                    "+                                            r*(x - i),"
                ],
                "start_lineno": 483,
                "end_lineno": 513
            },
            {
                "hunk": [
                    "-    \"\"\"Falling factorial (related to rising factorial) is a double valued",
                    "+    \"\"\"",
                    "+    Falling factorial (related to rising factorial) is a double valued"
                ],
                "start_lineno": 541,
                "end_lineno": 541
            },
            {
                "hunk": [
                    "-    When x is a polynomial f of a single variable y of order >= 1,",
                    "-    ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in",
                    "-    Peter Paule, \"Greatest Factorial Factorization and Symbolic Summation\",",
                    "-    Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.",
                    "+    When x is a Poly instance of degree >= 1 with single variable,",
                    "+    ff(x,k) = x(y) * x(y-1) * ... * x(y-k+1), where y is the variable of x.",
                    "+    This is as described in Peter Paule, \"Greatest Factorial Factorization and",
                    "+    Symbolic Summation\", Journal of Symbolic Computation, vol. 20, pp.",
                    "+    235-268, 1995.",
                    " ",
                    "-    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols",
                    "+    >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols, Poly"
                ],
                "start_lineno": 551,
                "end_lineno": 556
            },
            {
                "hunk": [
                    "-    >>> ff(x**2, 2)",
                    "+    >>> ff(Poly(x**2, x), 2)"
                ],
                "start_lineno": 565,
                "end_lineno": 565
            },
            {
                "hunk": [
                    "+"
                ],
                "start_lineno": 590,
                "end_lineno": 590
            },
            {
                "hunk": [
                    "-                        try:",
                    "-                            F, opt = poly_from_expr(x)",
                    "-                        except PolificationFailed:",
                    "-                            return reduce(lambda r, i: r*(x - i),",
                    "-                                          range(0, int(k)), 1)",
                    "-                        if len(opt.gens) > 1 or F.degree() <= 1:",
                    "-                            return reduce(lambda r, i: r*(x - i),",
                    "-                                          range(0, int(k)), 1)",
                    "+                        if isinstance(x, Poly):",
                    "+                            gens = x.gens",
                    "+                            if len(gens)!= 1:",
                    "+                                raise ValueError(\"ff only defined for polynomials on one generator\")",
                    "+                            else:",
                    "+                                return reduce(lambda r, i:",
                    "+                                              r*(x.shift(-i).expand()),",
                    "+                                              range(0, int(k)), 1)",
                    "                         else:",
                    "-                            v = opt.gens[0]",
                    "-                            return reduce(lambda r, i:",
                    "-                                          r*(F.subs(v, v - i).expand()),",
                    "+                            return reduce(lambda r, i: r*(x - i),"
                ],
                "start_lineno": 614,
                "end_lineno": 625
            },
            {
                "hunk": [
                    "-                        try:",
                    "-                            F, opt = poly_from_expr(x)",
                    "-                        except PolificationFailed:",
                    "-                            return 1/reduce(lambda r, i: r*(x + i),",
                    "-                                            range(1, abs(int(k)) + 1), 1)",
                    "-                        if len(opt.gens) > 1 or F.degree() <= 1:",
                    "-                            return 1/reduce(lambda r, i: r*(x + i),",
                    "-                                            range(1, abs(int(k)) + 1), 1)",
                    "+                        if isinstance(x, Poly):",
                    "+                            gens = x.gens",
                    "+                            if len(gens)!= 1:",
                    "+                                raise ValueError(\"rf only defined for polynomials on one generator\")",
                    "+                            else:",
                    "+                                return 1/reduce(lambda r, i:",
                    "+                                                r*(x.shift(i).expand()),",
                    "+                                                range(1, abs(int(k)) + 1), 1)",
                    "                         else:",
                    "-                            v = opt.gens[0]",
                    "-                            return 1/reduce(lambda r, i:",
                    "-                                            r*(F.subs(v, v + i).expand()),",
                    "+                            return 1/reduce(lambda r, i: r*(x + i),"
                ],
                "start_lineno": 633,
                "end_lineno": 644
            }
        ],
        "sympy/polys/polytools.py": [
            {
                "hunk": [
                    "+    Note that the input to ff() and rf() should be Poly instances to use the",
                    "+    definitions here.",
                    "+",
                    "     Examples",
                    "     ========",
                    " ",
                    "-    >>> from sympy import gff_list, ff",
                    "+    >>> from sympy import gff_list, ff, Poly",
                    "     >>> from sympy.abc import x",
                    " ",
                    "-    >>> f = x**5 + 2*x**4 - x**3 - 2*x**2",
                    "+    >>> f = Poly(x**5 + 2*x**4 - x**3 - 2*x**2, x)",
                    " ",
                    "     >>> gff_list(f)",
                    "-    [(x, 1), (x + 2, 4)]",
                    "+    [(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)]",
                    " ",
                    "-    >>> (ff(x, 1)*ff(x + 2, 4)).expand() == f",
                    "+    >>> (ff(Poly(x), 1)*ff(Poly(x + 2), 4)).expand() == f",
                    "     True",
                    " ",
                    "-    >>> f = x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \\",
                    "-        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x",
                    "+    >>> f = Poly(x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 - \\",
                    "+        1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x, x)",
                    " ",
                    "     >>> gff_list(f)",
                    "-    [(x**3 + 7, 2), (x**2 + 5*x, 3)]",
                    "+    [(Poly(x**3 + 7, x, domain='ZZ'), 2), (Poly(x**2 + 5*x, x, domain='ZZ'), 3)]",
                    " ",
                    "-    >>> ff(x**3 + 7, 2)*ff(x**2 + 5*x, 3) == f",
                    "+    >>> ff(Poly(x**3 + 7, x), 2)*ff(Poly(x**2 + 5*x, x), 3) == f"
                ],
                "start_lineno": 5607,
                "end_lineno": 5627
            }
        ]
    },
    "sympy__sympy-21171": {
        "sympy/printing/latex.py": [
            {
                "hunk": [
                    "-    def _print_SingularityFunction(self, expr):",
                    "+    def _print_SingularityFunction(self, expr, exp=None):",
                    "         shift = self._print(expr.args[0] - expr.args[1])",
                    "         power = self._print(expr.args[2])",
                    "         tex = r\"{\\left\\langle %s \\right\\rangle}^{%s}\" % (shift, power)",
                    "+        if exp is not None:",
                    "+            tex = r\"{\\left({\\langle %s \\rangle}^{%s}\\right)}^{%s}\" % (shift, power, exp)"
                ],
                "start_lineno": 1971,
                "end_lineno": 1974
            }
        ]
    },
    "psf__requests-1376": {
        "requests/models.py": [
            {
                "hunk": [
                    "-            raise InvalidURL(\"Invalid URL %t: No host supplied\" % url)",
                    "+            raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)"
                ],
                "start_lineno": 294,
                "end_lineno": 294
            }
        ]
    },
    "pylint-dev__pylint-6412": {
        "pylint/checkers/base_checker.py": [
            {
                "hunk": [
                    "+        if getattr(self, \"__implements__\", None):",
                    "+            warnings.warn(",
                    "+                \"Using the __implements__ inheritance pattern for BaseChecker is no \"",
                    "+                \"longer supported. Child classes should only inherit BaseChecker or any \"",
                    "+                \"of the other checker types from pylint.checkers.\",",
                    "+                DeprecationWarning,",
                    "+            )"
                ],
                "start_lineno": 44,
                "end_lineno": 44
            },
            {
                "hunk": [
                    "-            # TODO: Interfaces: Deprecate looking for implements here # pylint: disable=fixme",
                    "+            # TODO: 3.0: Remove deprecated if-statement # pylint: disable=fixme",
                    "             elif implements(self, (IRawChecker, ITokenChecker)):",
                    "-                default_scope = WarningScope.LINE",
                    "+                warnings.warn(  # pragma: no cover",
                    "+                    \"Checkers should subclass BaseTokenChecker or BaseRawFileChecker\"",
                    "+                    \"instead of using the __implements__ mechanism. Use of __implements__\"",
                    "+                    \"will no longer be supported in pylint 3.0\",",
                    "+                    DeprecationWarning,",
                    "+                )",
                    "+                default_scope = WarningScope.LINE  # pragma: no cover"
                ],
                "start_lineno": 169,
                "end_lineno": 171
            }
        ],
        "pylint/interfaces.py": [
            {
                "hunk": [
                    "+    def __init__(self) -> None:",
                    "+        warnings.warn(",
                    "+            \"Interface and all of its subclasses have been deprecated \"",
                    "+            \"and will be removed in pylint 3.0.\",",
                    "+            DeprecationWarning,",
                    "+        )",
                    "+"
                ],
                "start_lineno": 54,
                "end_lineno": 54
            }
        ],
        "pylint/lint/pylinter.py": [
            {
                "hunk": [
                    "-        with warnings.catch_warnings():",
                    "-            warnings.filterwarnings(\"ignore\", category=DeprecationWarning)",
                    "-            tokencheckers = [",
                    "-                c",
                    "-                for c in _checkers",
                    "+        tokencheckers = [",
                    "+            c",
                    "+            for c in _checkers",
                    "+            if isinstance(c, checkers.BaseTokenChecker) and c is not self",
                    "+        ]",
                    "+        # TODO: 3.0: Remove deprecated for-loop # pylint: disable=fixme",
                    "+        for c in _checkers:",
                    "+            with warnings.catch_warnings():",
                    "+                warnings.filterwarnings(\"ignore\", category=DeprecationWarning)",
                    "                 if (",
                    "                     interfaces.implements(c, interfaces.ITokenChecker)",
                    "-                    or isinstance(c, checkers.BaseTokenChecker)",
                    "-                )",
                    "-                and c is not self",
                    "-            ]",
                    "-        with warnings.catch_warnings():",
                    "-            warnings.filterwarnings(\"ignore\", category=DeprecationWarning)",
                    "-            rawcheckers = [",
                    "-                c",
                    "-                for c in _checkers",
                    "-                if interfaces.implements(c, interfaces.IRawChecker)",
                    "-                or isinstance(c, checkers.BaseRawFileChecker)",
                    "-            ]",
                    "+                    and c not in tokencheckers",
                    "+                    and c is not self",
                    "+                ):",
                    "+                    tokencheckers.append(c)  # pragma: no cover",
                    "+                    warnings.warn(  # pragma: no cover",
                    "+                        \"Checkers should subclass BaseTokenChecker \"",
                    "+                        \"instead of using the __implements__ mechanism. Use of __implements__ \"",
                    "+                        \"will no longer be supported in pylint 3.0\",",
                    "+                        DeprecationWarning,",
                    "+                    )",
                    "+        rawcheckers = [",
                    "+            c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)",
                    "+        ]",
                    "+        # TODO: 3.0: Remove deprecated if-statement # pylint: disable=fixme",
                    "+        for c in _checkers:",
                    "+            with warnings.catch_warnings():",
                    "+                warnings.filterwarnings(\"ignore\", category=DeprecationWarning)",
                    "+                if (",
                    "+                    interfaces.implements(c, interfaces.IRawChecker)",
                    "+                    and c not in rawcheckers",
                    "+                ):",
                    "+                    rawcheckers.append(c)  # pragma: no cover",
                    "+                    warnings.warn(  # pragma: no cover",
                    "+                        \"Checkers should subclass BaseRawFileChecker \"",
                    "+                        \"instead of using the __implements__ mechanism. Use of __implements__ \"",
                    "+                        \"will no longer be supported in pylint 3.0\",",
                    "+                        DeprecationWarning,",
                    "+                    )"
                ],
                "start_lineno": 877,
                "end_lineno": 895
            }
        ],
        "pylint/reporters/base_reporter.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+        if getattr(self, \"__implements__\", None):",
                    "+            warnings.warn(",
                    "+                \"Using the __implements__ inheritance pattern for BaseReporter is no \"",
                    "+                \"longer supported. Child classes should only inherit BaseReporter\",",
                    "+                DeprecationWarning,",
                    "+            )"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            }
        ]
    },
    "pydata__xarray-7233": {
        "xarray/core/rolling.py": [
            {
                "hunk": [
                    "-        should_be_coords = set(window_dim) & set(self.obj.coords)",
                    "+        # should handle window_dim being unindexed",
                    "+        should_be_coords = (set(window_dim) & set(self.obj.coords)) | set(",
                    "+            self.obj.coords",
                    "+        )"
                ],
                "start_lineno": 976,
                "end_lineno": 976
            }
        ]
    },
    "django__django-15629": {
        "django/db/backends/base/schema.py": [
            {
                "hunk": [
                    "+        old_collation = old_db_params.get(\"collation\")",
                    "+        new_collation = new_db_params.get(\"collation\")",
                    "         drop_foreign_keys = (",
                    "             self.connection.features.supports_foreign_keys",
                    "             and (",
                    "                 (old_field.primary_key and new_field.primary_key)",
                    "                 or (old_field.unique and new_field.unique)",
                    "             )",
                    "-            and old_type != new_type",
                    "+            and ((old_type != new_type) or (old_collation != new_collation))"
                ],
                "start_lineno": 826,
                "end_lineno": 832
            },
            {
                "hunk": [
                    "-        old_collation = old_db_params.get(\"collation\")",
                    "-        new_collation = new_db_params.get(\"collation\")"
                ],
                "start_lineno": 917,
                "end_lineno": 918
            },
            {
                "hunk": [
                    "-            fragment, other_actions = self._alter_column_type_sql(",
                    "-                new_rel.related_model, old_rel.field, new_rel.field, rel_type",
                    "-            )",
                    "+            rel_collation = rel_db_params.get(\"collation\")",
                    "+            old_rel_db_params = old_rel.field.db_parameters(connection=self.connection)",
                    "+            old_rel_collation = old_rel_db_params.get(\"collation\")",
                    "+            if old_rel_collation != rel_collation:",
                    "+                # Collation change handles also a type change.",
                    "+                fragment = self._alter_column_collation_sql(",
                    "+                    new_rel.related_model,",
                    "+                    new_rel.field,",
                    "+                    rel_type,",
                    "+                    rel_collation,",
                    "+                )",
                    "+                other_actions = []",
                    "+            else:",
                    "+                fragment, other_actions = self._alter_column_type_sql(",
                    "+                    new_rel.related_model, old_rel.field, new_rel.field, rel_type",
                    "+                )"
                ],
                "start_lineno": 1041,
                "end_lineno": 1043
            }
        ],
        "django/db/backends/oracle/features.py": [
            {
                "hunk": [
                    "+        \"Oracle doesn't support changing collations on indexed columns (#33671).\": {",
                    "+            \"migrations.test_operations.OperationTests.\"",
                    "+            \"test_alter_field_pk_fk_db_collation\",",
                    "+        },"
                ],
                "start_lineno": 107,
                "end_lineno": 107
            }
        ],
        "django/db/backends/sqlite3/schema.py": [
            {
                "hunk": [
                    "-        if new_field.unique and old_type != new_type:",
                    "+        old_collation = old_db_params.get(\"collation\")",
                    "+        new_collation = new_db_params.get(\"collation\")",
                    "+        if new_field.unique and (",
                    "+            old_type != new_type or old_collation != new_collation",
                    "+        ):"
                ],
                "start_lineno": 458,
                "end_lineno": 458
            }
        ],
        "django/db/models/fields/related.py": [
            {
                "hunk": [
                    "-        return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}",
                    "+        target_db_parameters = self.target_field.db_parameters(connection)",
                    "+        return {",
                    "+            \"type\": self.db_type(connection),",
                    "+            \"check\": self.db_check(connection),",
                    "+            \"collation\": target_db_parameters.get(\"collation\"),",
                    "+        }"
                ],
                "start_lineno": 1183,
                "end_lineno": 1183
            }
        ]
    },
    "pydata__xarray-3976": {
        "xarray/core/dataarray.py": [
            {
                "hunk": [
                    "-from .merge import PANDAS_TYPES, _extract_indexes_from_coords",
                    "+from .merge import PANDAS_TYPES, MergeError, _extract_indexes_from_coords"
                ],
                "start_lineno": 57,
                "end_lineno": 57
            },
            {
                "hunk": [
                    "-            with self.coords._merge_inplace(other_coords):",
                    "-                f(self.variable, other_variable)",
                    "+            try:",
                    "+                with self.coords._merge_inplace(other_coords):",
                    "+                    f(self.variable, other_variable)",
                    "+            except MergeError as exc:",
                    "+                raise MergeError(",
                    "+                    \"Automatic alignment is not supported for in-place operations.\\n\"",
                    "+                    \"Consider aligning the indices manually or using a not-in-place operation.\\n\"",
                    "+                    \"See https://github.com/pydata/xarray/issues/3910 for more explanations.\"",
                    "+                ) from exc"
                ],
                "start_lineno": 2666,
                "end_lineno": 2667
            }
        ]
    },
    "pylint-dev__pylint-6386": {
        "pylint/config/argument.py": [
            {
                "hunk": [
                    "+        metavar: str,"
                ],
                "start_lineno": 460,
                "end_lineno": 460
            },
            {
                "hunk": [
                    "+",
                    "+        self.metavar = metavar",
                    "+        \"\"\"The metavar of the argument.",
                    "+",
                    "+        See:",
                    "+        https://docs.python.org/3/library/argparse.html#metavar",
                    "+        \"\"\""
                ],
                "start_lineno": 470,
                "end_lineno": 470
            }
        ],
        "pylint/config/arguments_manager.py": [
            {
                "hunk": [
                    "+                metavar=argument.metavar,"
                ],
                "start_lineno": 221,
                "end_lineno": 221
            }
        ],
        "pylint/config/utils.py": [
            {
                "hunk": [
                    "+            metavar=optdict.get(\"metavar\", None),"
                ],
                "start_lineno": 74,
                "end_lineno": 74
            },
            {
                "hunk": [
                    "+    \"-v\": (False, _set_verbose_mode),"
                ],
                "start_lineno": 210,
                "end_lineno": 210
            },
            {
                "hunk": [
                    "-        if not argument.startswith(\"--\"):",
                    "+        if not argument.startswith(\"-\"):"
                ],
                "start_lineno": 221,
                "end_lineno": 221
            }
        ],
        "pylint/lint/base_options.py": [
            {
                "hunk": [
                    "+                \"metavar\": \"\","
                ],
                "start_lineno": 547,
                "end_lineno": 547
            },
            {
                "hunk": [
                    "+                \"metavar\": \"\","
                ],
                "start_lineno": 557,
                "end_lineno": 557
            }
        ]
    },
    "django__django-15863": {
        "django/template/defaultfilters.py": [
            {
                "hunk": [
                    "-        input_val = repr(text)",
                    "+        input_val = str(text)"
                ],
                "start_lineno": 152,
                "end_lineno": 152
            }
        ]
    },
    "astropy__astropy-13453": {
        "astropy/io/ascii/html.py": [
            {
                "hunk": [
                    "+        self.data.cols = cols",
                    " ",
                    "         if isinstance(self.data.fill_values, tuple):",
                    "             self.data.fill_values = [self.data.fill_values]",
                    " ",
                    "         self.data._set_fill_values(cols)",
                    "+        self.data._set_col_formats()"
                ],
                "start_lineno": 352,
                "end_lineno": 356
            }
        ]
    },
    "matplotlib__matplotlib-24971": {
        "lib/matplotlib/_tight_bbox.py": [
            {
                "hunk": [
                    "-    orig_layout = fig.get_layout_engine()",
                    "-    fig.set_layout_engine(None)"
                ],
                "start_lineno": 20,
                "end_lineno": 21
            },
            {
                "hunk": [
                    "-        fig.set_layout_engine(orig_layout)"
                ],
                "start_lineno": 49,
                "end_lineno": 49
            }
        ]
    },
    "pydata__xarray-5365": {
        "xarray/__init__.py": [
            {
                "hunk": [
                    "-from .core.computation import apply_ufunc, corr, cov, dot, polyval, unify_chunks, where",
                    "+from .core.computation import (",
                    "+    apply_ufunc,",
                    "+    corr,",
                    "+    cov,",
                    "+    cross,",
                    "+    dot,",
                    "+    polyval,",
                    "+    unify_chunks,",
                    "+    where,",
                    "+)"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "+    \"cross\","
                ],
                "start_lineno": 63,
                "end_lineno": 63
            }
        ],
        "xarray/core/computation.py": [
            {
                "hunk": [
                    "+    from .dataarray import DataArray"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            },
            {
                "hunk": [
                    "+def cross(",
                    "+    a: Union[DataArray, Variable], b: Union[DataArray, Variable], *, dim: Hashable",
                    "+) -> Union[DataArray, Variable]:",
                    "+    \"\"\"",
                    "+    Compute the cross product of two (arrays of) vectors.",
                    "+",
                    "+    The cross product of `a` and `b` in :math:`R^3` is a vector",
                    "+    perpendicular to both `a` and `b`. The vectors in `a` and `b` are",
                    "+    defined by the values along the dimension `dim` and can have sizes",
                    "+    1, 2 or 3. Where the size of either `a` or `b` is",
                    "+    1 or 2, the remaining components of the input vector is assumed to",
                    "+    be zero and the cross product calculated accordingly. In cases where",
                    "+    both input vectors have dimension 2, the z-component of the cross",
                    "+    product is returned.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    a, b : DataArray or Variable",
                    "+        Components of the first and second vector(s).",
                    "+    dim : hashable",
                    "+        The dimension along which the cross product will be computed.",
                    "+        Must be available in both vectors.",
                    "+",
                    "+    Examples",
                    "+    --------",
                    "+    Vector cross-product with 3 dimensions:",
                    "+",
                    "+    >>> a = xr.DataArray([1, 2, 3])",
                    "+    >>> b = xr.DataArray([4, 5, 6])",
                    "+    >>> xr.cross(a, b, dim=\"dim_0\")",
                    "+    <xarray.DataArray (dim_0: 3)>",
                    "+    array([-3,  6, -3])",
                    "+    Dimensions without coordinates: dim_0",
                    "+",
                    "+    Vector cross-product with 2 dimensions, returns in the perpendicular",
                    "+    direction:",
                    "+",
                    "+    >>> a = xr.DataArray([1, 2])",
                    "+    >>> b = xr.DataArray([4, 5])",
                    "+    >>> xr.cross(a, b, dim=\"dim_0\")",
                    "+    <xarray.DataArray ()>",
                    "+    array(-3)",
                    "+",
                    "+    Vector cross-product with 3 dimensions but zeros at the last axis",
                    "+    yields the same results as with 2 dimensions:",
                    "+",
                    "+    >>> a = xr.DataArray([1, 2, 0])",
                    "+    >>> b = xr.DataArray([4, 5, 0])",
                    "+    >>> xr.cross(a, b, dim=\"dim_0\")",
                    "+    <xarray.DataArray (dim_0: 3)>",
                    "+    array([ 0,  0, -3])",
                    "+    Dimensions without coordinates: dim_0",
                    "+",
                    "+    One vector with dimension 2:",
                    "+",
                    "+    >>> a = xr.DataArray(",
                    "+    ...     [1, 2],",
                    "+    ...     dims=[\"cartesian\"],",
                    "+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\"])),",
                    "+    ... )",
                    "+    >>> b = xr.DataArray(",
                    "+    ...     [4, 5, 6],",
                    "+    ...     dims=[\"cartesian\"],",
                    "+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),",
                    "+    ... )",
                    "+    >>> xr.cross(a, b, dim=\"cartesian\")",
                    "+    <xarray.DataArray (cartesian: 3)>",
                    "+    array([12, -6, -3])",
                    "+    Coordinates:",
                    "+      * cartesian  (cartesian) <U1 'x' 'y' 'z'",
                    "+",
                    "+    One vector with dimension 2 but coords in other positions:",
                    "+",
                    "+    >>> a = xr.DataArray(",
                    "+    ...     [1, 2],",
                    "+    ...     dims=[\"cartesian\"],",
                    "+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"z\"])),",
                    "+    ... )",
                    "+    >>> b = xr.DataArray(",
                    "+    ...     [4, 5, 6],",
                    "+    ...     dims=[\"cartesian\"],",
                    "+    ...     coords=dict(cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"])),",
                    "+    ... )",
                    "+    >>> xr.cross(a, b, dim=\"cartesian\")",
                    "+    <xarray.DataArray (cartesian: 3)>",
                    "+    array([-10,   2,   5])",
                    "+    Coordinates:",
                    "+      * cartesian  (cartesian) <U1 'x' 'y' 'z'",
                    "+",
                    "+    Multiple vector cross-products. Note that the direction of the",
                    "+    cross product vector is defined by the right-hand rule:",
                    "+",
                    "+    >>> a = xr.DataArray(",
                    "+    ...     [[1, 2, 3], [4, 5, 6]],",
                    "+    ...     dims=(\"time\", \"cartesian\"),",
                    "+    ...     coords=dict(",
                    "+    ...         time=([\"time\"], [0, 1]),",
                    "+    ...         cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),",
                    "+    ...     ),",
                    "+    ... )",
                    "+    >>> b = xr.DataArray(",
                    "+    ...     [[4, 5, 6], [1, 2, 3]],",
                    "+    ...     dims=(\"time\", \"cartesian\"),",
                    "+    ...     coords=dict(",
                    "+    ...         time=([\"time\"], [0, 1]),",
                    "+    ...         cartesian=([\"cartesian\"], [\"x\", \"y\", \"z\"]),",
                    "+    ...     ),",
                    "+    ... )",
                    "+    >>> xr.cross(a, b, dim=\"cartesian\")",
                    "+    <xarray.DataArray (time: 2, cartesian: 3)>",
                    "+    array([[-3,  6, -3],",
                    "+           [ 3, -6,  3]])",
                    "+    Coordinates:",
                    "+      * time       (time) int64 0 1",
                    "+      * cartesian  (cartesian) <U1 'x' 'y' 'z'",
                    "+",
                    "+    Cross can be called on Datasets by converting to DataArrays and later",
                    "+    back to a Dataset:",
                    "+",
                    "+    >>> ds_a = xr.Dataset(dict(x=(\"dim_0\", [1]), y=(\"dim_0\", [2]), z=(\"dim_0\", [3])))",
                    "+    >>> ds_b = xr.Dataset(dict(x=(\"dim_0\", [4]), y=(\"dim_0\", [5]), z=(\"dim_0\", [6])))",
                    "+    >>> c = xr.cross(",
                    "+    ...     ds_a.to_array(\"cartesian\"), ds_b.to_array(\"cartesian\"), dim=\"cartesian\"",
                    "+    ... )",
                    "+    >>> c.to_dataset(dim=\"cartesian\")",
                    "+    <xarray.Dataset>",
                    "+    Dimensions:  (dim_0: 1)",
                    "+    Dimensions without coordinates: dim_0",
                    "+    Data variables:",
                    "+        x        (dim_0) int64 -3",
                    "+        y        (dim_0) int64 6",
                    "+        z        (dim_0) int64 -3",
                    "+",
                    "+    See Also",
                    "+    --------",
                    "+    numpy.cross : Corresponding numpy function",
                    "+    \"\"\"",
                    "+",
                    "+    if dim not in a.dims:",
                    "+        raise ValueError(f\"Dimension {dim!r} not on a\")",
                    "+    elif dim not in b.dims:",
                    "+        raise ValueError(f\"Dimension {dim!r} not on b\")",
                    "+",
                    "+    if not 1 <= a.sizes[dim] <= 3:",
                    "+        raise ValueError(",
                    "+            f\"The size of {dim!r} on a must be 1, 2, or 3 to be \"",
                    "+            f\"compatible with a cross product but is {a.sizes[dim]}\"",
                    "+        )",
                    "+    elif not 1 <= b.sizes[dim] <= 3:",
                    "+        raise ValueError(",
                    "+            f\"The size of {dim!r} on b must be 1, 2, or 3 to be \"",
                    "+            f\"compatible with a cross product but is {b.sizes[dim]}\"",
                    "+        )",
                    "+",
                    "+    all_dims = list(dict.fromkeys(a.dims + b.dims))",
                    "+",
                    "+    if a.sizes[dim] != b.sizes[dim]:",
                    "+        # Arrays have different sizes. Append zeros where the smaller",
                    "+        # array is missing a value, zeros will not affect np.cross:",
                    "+",
                    "+        if (",
                    "+            not isinstance(a, Variable)  # Only used to make mypy happy.",
                    "+            and dim in getattr(a, \"coords\", {})",
                    "+            and not isinstance(b, Variable)  # Only used to make mypy happy.",
                    "+            and dim in getattr(b, \"coords\", {})",
                    "+        ):",
                    "+            # If the arrays have coords we know which indexes to fill",
                    "+            # with zeros:",
                    "+            a, b = align(",
                    "+                a,",
                    "+                b,",
                    "+                fill_value=0,",
                    "+                join=\"outer\",",
                    "+                exclude=set(all_dims) - {dim},",
                    "+            )",
                    "+        elif min(a.sizes[dim], b.sizes[dim]) == 2:",
                    "+            # If the array doesn't have coords we can only infer",
                    "+            # that it has composite values if the size is at least 2.",
                    "+            # Once padded, rechunk the padded array because apply_ufunc",
                    "+            # requires core dimensions not to be chunked:",
                    "+            if a.sizes[dim] < b.sizes[dim]:",
                    "+                a = a.pad({dim: (0, 1)}, constant_values=0)",
                    "+                # TODO: Should pad or apply_ufunc handle correct chunking?",
                    "+                a = a.chunk({dim: -1}) if is_duck_dask_array(a.data) else a",
                    "+            else:",
                    "+                b = b.pad({dim: (0, 1)}, constant_values=0)",
                    "+                # TODO: Should pad or apply_ufunc handle correct chunking?",
                    "+                b = b.chunk({dim: -1}) if is_duck_dask_array(b.data) else b",
                    "+        else:",
                    "+            raise ValueError(",
                    "+                f\"{dim!r} on {'a' if a.sizes[dim] == 1 else 'b'} is incompatible:\"",
                    "+                \" dimensions without coordinates must have have a length of 2 or 3\"",
                    "+            )",
                    "+",
                    "+    c = apply_ufunc(",
                    "+        np.cross,",
                    "+        a,",
                    "+        b,",
                    "+        input_core_dims=[[dim], [dim]],",
                    "+        output_core_dims=[[dim] if a.sizes[dim] == 3 else []],",
                    "+        dask=\"parallelized\",",
                    "+        output_dtypes=[np.result_type(a, b)],",
                    "+    )",
                    "+    c = c.transpose(*all_dims, missing_dims=\"ignore\")",
                    "+",
                    "+    return c",
                    "+",
                    "+"
                ],
                "start_lineno": 1376,
                "end_lineno": 1376
            }
        ]
    },
    "sympy__sympy-16840": {
        "sympy/core/numbers.py": [
            {
                "hunk": [
                    "+        from sympy.functions.elementary.complexes import sign",
                    " ",
                    "         try:",
                    "             other = Number(other)",
                    "+            if self.is_infinite or S.NaN in (self, other):",
                    "+                return (S.NaN, S.NaN)"
                ],
                "start_lineno": 548,
                "end_lineno": 550
            },
            {
                "hunk": [
                    "+        elif isinstance(other, Float):",
                    "+            rat = self/Rational(other)",
                    "         else:",
                    "             rat = self/other",
                    "-        w = int(rat) if rat > 0 else int(rat) - 1",
                    "-        r = self - other*w",
                    "+        if other.is_finite:",
                    "+            w = int(rat) if rat > 0 else int(rat) - 1",
                    "+            r = self - other*w",
                    "+        else:",
                    "+            w = 0 if not self or (sign(self) == sign(other)) else -1",
                    "+            r = other if w else self"
                ],
                "start_lineno": 558,
                "end_lineno": 561
            },
            {
                "hunk": [
                    "-        return Integer(self.p // Integer(other).p)",
                    "+        if isinstance(other, Integer):",
                    "+            return Integer(self.p // other)",
                    "+        return Integer(divmod(self, other)[0])"
                ],
                "start_lineno": 2307,
                "end_lineno": 2307
            }
        ]
    },
    "sympy__sympy-13768": {
        "sympy/matrices/matrices.py": [
            {
                "hunk": [
                    "+from sympy.utilities.exceptions import SymPyDeprecationWarning"
                ],
                "start_lineno": 28,
                "end_lineno": 28
            },
            {
                "hunk": [
                    "+    def _legacy_array_dot(self, b):",
                    "+        \"\"\"Compatibility function for deprecated behavior of ``matrix.dot(vector)``",
                    "+        \"\"\"",
                    "+        from .dense import Matrix",
                    "+",
                    "+        if not isinstance(b, MatrixBase):",
                    "+            if is_sequence(b):",
                    "+                if len(b) != self.cols and len(b) != self.rows:",
                    "+                    raise ShapeError(",
                    "+                        \"Dimensions incorrect for dot product: %s, %s\" % (",
                    "+                            self.shape, len(b)))",
                    "+                return self.dot(Matrix(b))",
                    "+            else:",
                    "+                raise TypeError(",
                    "+                    \"`b` must be an ordered iterable or Matrix, not %s.\" %",
                    "+                    type(b))",
                    "+",
                    "+        mat = self",
                    "+        if mat.cols == b.rows:",
                    "+            if b.cols != 1:",
                    "+                mat = mat.T",
                    "+                b = b.T",
                    "+            prod = flatten((mat * b).tolist())",
                    "+            return prod",
                    "+        if mat.cols == b.cols:",
                    "+            return mat.dot(b.T)",
                    "+        elif mat.rows == b.rows:",
                    "+            return mat.T.dot(b)",
                    "+        else:",
                    "+            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (",
                    "+                self.shape, b.shape))",
                    "+"
                ],
                "start_lineno": 1706,
                "end_lineno": 1706
            },
            {
                "hunk": [
                    "-        \"\"\"Return the dot product of Matrix self and b relaxing the condition",
                    "-        of compatible dimensions: if either the number of rows or columns are",
                    "-        the same as the length of b then the dot product is returned. If self",
                    "-        is a row or column vector, a scalar is returned. Otherwise, a list",
                    "-        of results is returned (and in that case the number of columns in self",
                    "-        must match the length of b).",
                    "+        \"\"\"Return the dot product of two vectors of equal length. ``self`` must",
                    "+        be a ``Matrix`` of size 1 x n or n x 1, and ``b`` must be either a",
                    "+        matrix of size 1 x n, n x 1, or a list/tuple of length n. A scalar is returned.",
                    " ",
                    "         Examples",
                    "         ========",
                    " ",
                    "         >>> from sympy import Matrix",
                    "         >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
                    "-        >>> v = [1, 1, 1]",
                    "+        >>> v = Matrix([1, 1, 1])",
                    "         >>> M.row(0).dot(v)",
                    "         6",
                    "         >>> M.col(0).dot(v)",
                    "         12",
                    "-        >>> M.dot(v)",
                    "-        [6, 15, 24]",
                    "+        >>> v = [3, 2, 1]",
                    "+        >>> M.row(0).dot(v)",
                    "+        10"
                ],
                "start_lineno": 2401,
                "end_lineno": 2419
            },
            {
                "hunk": [
                    "-        if mat.cols == b.rows:",
                    "-            if b.cols != 1:",
                    "-                mat = mat.T",
                    "-                b = b.T",
                    "-            prod = flatten((mat * b).tolist())",
                    "-            if len(prod) == 1:",
                    "-                return prod[0]",
                    "-            return prod",
                    "-        if mat.cols == b.cols:",
                    "-            return mat.dot(b.T)",
                    "-        elif mat.rows == b.rows:",
                    "-            return mat.T.dot(b)",
                    "-        else:",
                    "-            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (",
                    "-                self.shape, b.shape))",
                    "+        if (1 not in mat.shape) or (1 not in b.shape) :",
                    "+            SymPyDeprecationWarning(",
                    "+                feature=\"Dot product of non row/column vectors\",",
                    "+                issue=13815,",
                    "+                deprecated_since_version=\"1.2\").warn()",
                    "+            return mat._legacy_array_dot(b)",
                    "+        if len(mat) != len(b):",
                    "+            raise ShapeError(\"Dimensions incorrect for dot product: %s, %s\" % (self.shape, b.shape))",
                    "+        n = len(mat)",
                    "+        if mat.shape != (1, n):",
                    "+            mat = mat.reshape(1, n)",
                    "+        if b.shape != (n, 1):",
                    "+            b = b.reshape(n, 1)",
                    "+        # Now ``mat`` is a row vector and ``b`` is a column vector.",
                    "+        return (mat * b)[0]"
                ],
                "start_lineno": 2443,
                "end_lineno": 2457
            }
        ]
    },
    "django__django-16879": {
        "django/db/models/aggregates.py": [
            {
                "hunk": [
                    "-        if not summarize:",
                    "+        if summarize:",
                    "+            # Summarized aggregates cannot refer to summarized aggregates.",
                    "+            for ref in c.get_refs():",
                    "+                if query.annotations[ref].is_summary:",
                    "+                    raise FieldError(",
                    "+                        f\"Cannot compute {c.name}('{ref}'): '{ref}' is an aggregate\"",
                    "+                    )",
                    "+        elif not self.is_summary:"
                ],
                "start_lineno": 68,
                "end_lineno": 68
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+    subquery = True"
                ],
                "start_lineno": 1544,
                "end_lineno": 1544
            }
        ],
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "-        aggregates = {}",
                    "+        # Store annotation mask prior to temporarily adding aggregations for",
                    "+        # resolving purpose to facilitate their subsequent removal.",
                    "+        refs_subquery = False",
                    "+        replacements = {}",
                    "+        annotation_select_mask = self.annotation_select_mask"
                ],
                "start_lineno": 403,
                "end_lineno": 403
            },
            {
                "hunk": [
                    "-            aggregates[alias] = aggregate",
                    "+            # Temporarily add aggregate to annotations to allow remaining",
                    "+            # members of `aggregates` to resolve against each others.",
                    "+            self.append_annotation_mask([alias])",
                    "+            refs_subquery |= any(",
                    "+                getattr(self.annotations[ref], \"subquery\", False)",
                    "+                for ref in aggregate.get_refs()",
                    "+            )",
                    "+            aggregate = aggregate.replace_expressions(replacements)",
                    "+            self.annotations[alias] = aggregate",
                    "+            replacements[Ref(alias, aggregate)] = aggregate",
                    "+        # Stash resolved aggregates now that they have been allowed to resolve",
                    "+        # against each other.",
                    "+        aggregates = {alias: self.annotations.pop(alias) for alias in aggregate_exprs}",
                    "+        self.set_annotation_mask(annotation_select_mask)"
                ],
                "start_lineno": 411,
                "end_lineno": 411
            },
            {
                "hunk": [
                    "+            or refs_subquery"
                ],
                "start_lineno": 436,
                "end_lineno": 436
            }
        ]
    },
    "scikit-learn__scikit-learn-13554": {
        "sklearn/metrics/pairwise.py": [
            {
                "hunk": [
                    "+        May be ignored in some cases, see the note below."
                ],
                "start_lineno": 196,
                "end_lineno": 196
            },
            {
                "hunk": [
                    "+        May be ignored in some cases, see the note below.",
                    "+",
                    "+    Notes",
                    "+    -----",
                    "+    To achieve better accuracy, `X_norm_squared`\u00a0and `Y_norm_squared` may be",
                    "+    unused if they are passed as ``float32``.",
                    " ",
                    "     Returns",
                    "     -------",
                    "-    distances : {array, sparse matrix}, shape (n_samples_1, n_samples_2)",
                    "+    distances : array, shape (n_samples_1, n_samples_2)"
                ],
                "start_lineno": 203,
                "end_lineno": 206
            },
            {
                "hunk": [
                    "+    # If norms are passed as float32, they are unused. If arrays are passed as",
                    "+    # float32, norms needs to be recomputed on upcast chunks.",
                    "+    # TODO: use a float64 accumulator in row_norms to avoid the latter."
                ],
                "start_lineno": 227,
                "end_lineno": 227
            },
            {
                "hunk": [
                    "+        if XX.dtype == np.float32:",
                    "+            XX = None",
                    "+    elif X.dtype == np.float32:",
                    "+        XX = None",
                    "     else:",
                    "         XX = row_norms(X, squared=True)[:, np.newaxis]",
                    " ",
                    "-    if X is Y:  # shortcut in the common case euclidean_distances(X, X)",
                    "+    if X is Y and XX is not None:",
                    "+        # shortcut in the common case euclidean_distances(X, X)"
                ],
                "start_lineno": 234,
                "end_lineno": 237
            },
            {
                "hunk": [
                    "+        if YY.dtype == np.float32:",
                    "+            YY = None",
                    "+    elif Y.dtype == np.float32:",
                    "+        YY = None",
                    "     else:",
                    "         YY = row_norms(Y, squared=True)[np.newaxis, :]",
                    " ",
                    "-    distances = safe_sparse_dot(X, Y.T, dense_output=True)",
                    "-    distances *= -2",
                    "-    distances += XX",
                    "-    distances += YY",
                    "+    if X.dtype == np.float32:",
                    "+        # To minimize precision issues with float32, we compute the distance",
                    "+        # matrix on chunks of X and Y upcast to float64",
                    "+        distances = _euclidean_distances_upcast(X, XX, Y, YY)",
                    "+    else:",
                    "+        # if dtype is already float64, no need to chunk and upcast",
                    "+        distances = - 2 * safe_sparse_dot(X, Y.T, dense_output=True)",
                    "+        distances += XX",
                    "+        distances += YY",
                    "     np.maximum(distances, 0, out=distances)",
                    " ",
                    "+    # Ensure that distances between vectors and themselves are set to 0.0.",
                    "+    # This may not be the case due to floating point rounding errors.",
                    "     if X is Y:",
                    "-        # Ensure that distances between vectors and themselves are set to 0.0.",
                    "-        # This may not be the case due to floating point rounding errors.",
                    "-        distances.flat[::distances.shape[0] + 1] = 0.0",
                    "+        np.fill_diagonal(distances, 0)",
                    " ",
                    "     return distances if squared else np.sqrt(distances, out=distances)",
                    " ",
                    " ",
                    "+def _euclidean_distances_upcast(X, XX=None, Y=None, YY=None):",
                    "+    \"\"\"Euclidean distances between X and Y",
                    "+",
                    "+    Assumes X and Y have float32 dtype.",
                    "+    Assumes XX and YY have float64 dtype or are None.",
                    "+",
                    "+    X and Y are upcast to float64 by chunks, which size is chosen to limit",
                    "+    memory increase by approximately 10% (at least 10MiB).",
                    "+    \"\"\"",
                    "+    n_samples_X = X.shape[0]",
                    "+    n_samples_Y = Y.shape[0]",
                    "+    n_features = X.shape[1]",
                    "+",
                    "+    distances = np.empty((n_samples_X, n_samples_Y), dtype=np.float32)",
                    "+",
                    "+    x_density = X.nnz / np.prod(X.shape) if issparse(X) else 1",
                    "+    y_density = Y.nnz / np.prod(Y.shape) if issparse(Y) else 1",
                    "+",
                    "+    # Allow 10% more memory than X, Y and the distance matrix take (at least",
                    "+    # 10MiB)",
                    "+    maxmem = max(",
                    "+        ((x_density * n_samples_X + y_density * n_samples_Y) * n_features",
                    "+         + (x_density * n_samples_X * y_density * n_samples_Y)) / 10,",
                    "+        10 * 2**17)",
                    "+",
                    "+    # The increase amount of memory in 8-byte blocks is:",
                    "+    # - x_density * batch_size * n_features (copy of chunk of X)",
                    "+    # - y_density * batch_size * n_features (copy of chunk of Y)",
                    "+    # - batch_size * batch_size (chunk of distance matrix)",
                    "+    # Hence x\u00b2 + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem",
                    "+    #                                 xd=x_density and yd=y_density",
                    "+    tmp = (x_density + y_density) * n_features",
                    "+    batch_size = (-tmp + np.sqrt(tmp**2 + 4 * maxmem)) / 2",
                    "+    batch_size = max(int(batch_size), 1)",
                    "+",
                    "+    x_batches = gen_batches(X.shape[0], batch_size)",
                    "+    y_batches = gen_batches(Y.shape[0], batch_size)",
                    "+",
                    "+    for i, x_slice in enumerate(x_batches):",
                    "+        X_chunk = X[x_slice].astype(np.float64)",
                    "+        if XX is None:",
                    "+            XX_chunk = row_norms(X_chunk, squared=True)[:, np.newaxis]",
                    "+        else:",
                    "+            XX_chunk = XX[x_slice]",
                    "+",
                    "+        for j, y_slice in enumerate(y_batches):",
                    "+            if X is Y and j < i:",
                    "+                # when X is Y the distance matrix is symmetric so we only need",
                    "+                # to compute half of it.",
                    "+                d = distances[y_slice, x_slice].T",
                    "+",
                    "+            else:",
                    "+                Y_chunk = Y[y_slice].astype(np.float64)",
                    "+                if YY is None:",
                    "+                    YY_chunk = row_norms(Y_chunk, squared=True)[np.newaxis, :]",
                    "+                else:",
                    "+                    YY_chunk = YY[:, y_slice]",
                    "+",
                    "+                d = -2 * safe_sparse_dot(X_chunk, Y_chunk.T, dense_output=True)",
                    "+                d += XX_chunk",
                    "+                d += YY_chunk",
                    "+",
                    "+            distances[x_slice, y_slice] = d.astype(np.float32, copy=False)",
                    "+",
                    "+    return distances",
                    "+",
                    "+"
                ],
                "start_lineno": 245,
                "end_lineno": 261
            }
        ]
    },
    "matplotlib__matplotlib-24912": {
        "lib/matplotlib/contour.py": [
            {
                "hunk": [
                    "-",
                    "-        if not self.filled:",
                    "-            inside = (self.levels > self.zmin) & (self.levels < self.zmax)",
                    "-            levels_in = self.levels[inside]",
                    "-            if len(levels_in) == 0:",
                    "-                self.levels = [self.zmin]",
                    "-                _api.warn_external(",
                    "-                    \"No contour levels were found within the data range.\")",
                    "-",
                    "         if self.filled and len(self.levels) < 2:",
                    "             raise ValueError(\"Filled contours require at least 2 levels.\")",
                    "-"
                ],
                "start_lineno": 1140,
                "end_lineno": 1151
            }
        ]
    },
    "django__django-10853": {
        "django/db/backends/base/features.py": [
            {
                "hunk": [
                    "+    supports_frame_range_fixed_distance = False"
                ],
                "start_lineno": 242,
                "end_lineno": 242
            }
        ],
        "django/db/backends/oracle/features.py": [
            {
                "hunk": [
                    "+    supports_frame_range_fixed_distance = True"
                ],
                "start_lineno": 55,
                "end_lineno": 55
            }
        ],
        "django/db/backends/sqlite3/features.py": [
            {
                "hunk": [
                    "+    supports_over_clause = Database.sqlite_version_info >= (3, 25, 0)"
                ],
                "start_lineno": 43,
                "end_lineno": 43
            }
        ],
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "+from django.db.utils import NotSupportedError"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            },
            {
                "hunk": [
                    "+        if not connection.features.supports_over_clause:",
                    "+            raise NotSupportedError('This backend does not support window expressions.')"
                ],
                "start_lineno": 1240,
                "end_lineno": 1240
            }
        ]
    },
    "django__django-13315": {
        "django/forms/models.py": [
            {
                "hunk": [
                    "+    from django.db.models import Exists, OuterRef, Q",
                    "     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):",
                    "         limit_choices_to = formfield.get_limit_choices_to()",
                    "-        if limit_choices_to is not None:",
                    "-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)",
                    "+        if limit_choices_to:",
                    "+            complex_filter = limit_choices_to",
                    "+            if not isinstance(complex_filter, Q):",
                    "+                complex_filter = Q(**limit_choices_to)",
                    "+            complex_filter &= Q(pk=OuterRef('pk'))",
                    "+            # Use Exists() to avoid potential duplicates.",
                    "+            formfield.queryset = formfield.queryset.filter(",
                    "+                Exists(formfield.queryset.model._base_manager.filter(complex_filter)),",
                    "+            )"
                ],
                "start_lineno": 100,
                "end_lineno": 103
            }
        ]
    },
    "sympy__sympy-19601": {
        "sympy/simplify/radsimp.py": [
            {
                "hunk": [
                    "-            return {urep.get(k, k): v for k, v in rv.items()}",
                    "+            return {urep.get(k, k): v.xreplace(urep) for k, v in rv.items()}"
                ],
                "start_lineno": 181,
                "end_lineno": 181
            }
        ]
    },
    "django__django-11292": {
        "django/core/management/base.py": [
            {
                "hunk": [
                    "-        '--no-color', '--force-color',",
                    "+        '--no-color', '--force-color', '--skip-checks',"
                ],
                "start_lineno": 98,
                "end_lineno": 98
            },
            {
                "hunk": [
                    "-    base_stealth_options = ('skip_checks', 'stderr', 'stdout')",
                    "+    base_stealth_options = ('stderr', 'stdout')"
                ],
                "start_lineno": 226,
                "end_lineno": 226
            },
            {
                "hunk": [
                    "+        if self.requires_system_checks:",
                    "+            parser.add_argument(",
                    "+                '--skip-checks', action='store_true',",
                    "+                help='Skip system checks.',",
                    "+            )"
                ],
                "start_lineno": 289,
                "end_lineno": 289
            },
            {
                "hunk": [
                    "-        if self.requires_system_checks and not options.get('skip_checks'):",
                    "+        if self.requires_system_checks and not options['skip_checks']:"
                ],
                "start_lineno": 360,
                "end_lineno": 360
            }
        ]
    },
    "django__django-12155": {
        "django/contrib/admindocs/utils.py": [
            {
                "hunk": [
                    "+from inspect import cleandoc"
                ],
                "start_lineno": 6,
                "end_lineno": 6
            },
            {
                "hunk": [
                    "-def trim_docstring(docstring):",
                    "-    \"\"\"",
                    "-    Uniformly trim leading/trailing whitespace from docstrings.",
                    "-",
                    "-    Based on https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation",
                    "-    \"\"\"",
                    "-    if not docstring or not docstring.strip():",
                    "-        return ''",
                    "-    # Convert tabs to spaces and split into lines",
                    "-    lines = docstring.expandtabs().splitlines()",
                    "-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())",
                    "-    trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]",
                    "-    return \"\\n\".join(trimmed).strip()",
                    "-",
                    "-",
                    " def parse_docstring(docstring):",
                    "     \"\"\"",
                    "     Parse out the parts of a docstring.  Return (title, body, metadata).",
                    "     \"\"\"",
                    "-    docstring = trim_docstring(docstring)",
                    "+    if not docstring:",
                    "+        return '', '', {}",
                    "+    docstring = cleandoc(docstring)"
                ],
                "start_lineno": 27,
                "end_lineno": 46
            }
        ],
        "django/contrib/admindocs/views.py": [
            {
                "hunk": [
                    "+from inspect import cleandoc"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-                    utils.parse_rst(utils.trim_docstring(verbose), 'model', _('model:') + opts.model_name)",
                    "+                    utils.parse_rst(cleandoc(verbose), 'model', _('model:') + opts.model_name)"
                ],
                "start_lineno": 259,
                "end_lineno": 259
            }
        ]
    },
    "mwaskom__seaborn-3180": {
        "seaborn/relational.py": [
            {
                "hunk": [
                    "-    g.set(xlabel=variables.get(\"x\"), ylabel=variables.get(\"y\"))",
                    "+    # Pass \"\" when the variable name is None to overwrite internal variables",
                    "+    g.set_axis_labels(variables.get(\"x\") or \"\", variables.get(\"y\") or \"\")"
                ],
                "start_lineno": 958,
                "end_lineno": 958
            }
        ]
    },
    "psf__requests-2754": {
        "requests/sessions.py": [
            {
                "hunk": [
                    "-from .compat import cookielib, OrderedDict, urljoin, urlparse",
                    "+from .compat import cookielib, OrderedDict, urljoin, urlparse, is_py3, str"
                ],
                "start_lineno": 16,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "+            # On Python 3, the location header was decoded using Latin 1, but",
                    "+            # urlparse in requote_uri will encode it with UTF-8 before quoting.",
                    "+            # Because of this insanity, we need to fix it up ourselves by",
                    "+            # sending the URL back to bytes ourselves.",
                    "+            if is_py3 and isinstance(location_url, str):",
                    "+                location_url = location_url.encode('latin1')",
                    "+"
                ],
                "start_lineno": 135,
                "end_lineno": 135
            }
        ],
        "requests/utils.py": [
            {
                "hunk": [
                    "-                     basestring)",
                    "+                     basestring, is_py3)"
                ],
                "start_lineno": 29,
                "end_lineno": 29
            },
            {
                "hunk": [
                    "-    parts = uri.split('%')",
                    "+    # This convert function is used to optionally convert the output of `chr`.",
                    "+    # In Python 3, `chr` returns a unicode string, while in Python 2 it returns",
                    "+    # a bytestring. Here we deal with that by optionally converting.",
                    "+    def convert(is_bytes, c):",
                    "+        if is_py2 and not is_bytes:",
                    "+            return c.decode('ascii')",
                    "+        elif is_py3 and is_bytes:",
                    "+            return c.encode('ascii')",
                    "+        else:",
                    "+            return c",
                    "+",
                    "+    # Handle both bytestrings and unicode strings.",
                    "+    is_bytes = isinstance(uri, bytes)",
                    "+    splitchar = u'%'",
                    "+    base = u''",
                    "+    if is_bytes:",
                    "+        splitchar = splitchar.encode('ascii')",
                    "+        base = base.encode('ascii')",
                    "+",
                    "+    parts = uri.split(splitchar)"
                ],
                "start_lineno": 425,
                "end_lineno": 425
            },
            {
                "hunk": [
                    "-                parts[i] = c + parts[i][2:]",
                    "+                parts[i] = convert(is_bytes, c) + parts[i][2:]",
                    "             else:",
                    "-                parts[i] = '%' + parts[i]",
                    "+                parts[i] = splitchar + parts[i]",
                    "         else:",
                    "-            parts[i] = '%' + parts[i]",
                    "-    return ''.join(parts)",
                    "+            parts[i] = splitchar + parts[i]",
                    "+    return base.join(parts)"
                ],
                "start_lineno": 435,
                "end_lineno": 440
            }
        ]
    },
    "sympy__sympy-15320": {
        "sympy/polys/rootoftools.py": [
            {
                "hunk": [
                    "-    Can be imported as ``CRootOf``.",
                    "+    Can be imported as ``CRootOf``. To avoid confusion, the",
                    "+    generator must be a Symbol."
                ],
                "start_lineno": 179,
                "end_lineno": 179
            },
            {
                "hunk": [
                    "+    Notes",
                    "+    =====",
                    "+",
                    "+    Although a PurePoly can be constructed from a non-symbol generator",
                    "+    RootOf instances of non-symbols are disallowed to avoid confusion",
                    "+    over what root is being represented.",
                    "+",
                    "+    >>> from sympy import exp, PurePoly",
                    "+    >>> PurePoly(x) == PurePoly(exp(x))",
                    "+    True",
                    "+    >>> CRootOf(x - 1, 0)",
                    "+    1",
                    "+    >>> CRootOf(exp(x) - 1, 0)  # would correspond to x == 0",
                    "+    Traceback (most recent call last):",
                    "+    ...",
                    "+    sympy.polys.polyerrors.PolynomialError: generator must be a Symbol",
                    "+"
                ],
                "start_lineno": 273,
                "end_lineno": 273
            },
            {
                "hunk": [
                    "+        if not poly.gen.is_Symbol:",
                    "+            # PurePoly(sin(x) + 1) == PurePoly(x + 1) but the roots of",
                    "+            # x for each are not the same: issue 8617",
                    "+            raise PolynomialError(\"generator must be a Symbol\")",
                    "+"
                ],
                "start_lineno": 309,
                "end_lineno": 309
            }
        ]
    },
    "sympy__sympy-12270": {
        "sympy/core/expr.py": [
            {
                "hunk": [
                    "-"
                ],
                "start_lineno": 14,
                "end_lineno": 14
            },
            {
                "hunk": [
                    "+        from .function import _coeff_isneg",
                    "+"
                ],
                "start_lineno": 1943,
                "end_lineno": 1943
            },
            {
                "hunk": [
                    "+",
                    "         if c.is_Add:",
                    "             cc, pc = c.primitive()",
                    "             if cc is not S.One:",
                    "                 c = Mul(cc, pc, evaluate=False)",
                    "+",
                    "         if c.is_Mul:",
                    "             a, b = c.as_two_terms()",
                    "             x = self.extract_multiplicatively(a)",
                    "             if x is not None:",
                    "                 return x.extract_multiplicatively(b)",
                    "+"
                ],
                "start_lineno": 1950,
                "end_lineno": 1958
            },
            {
                "hunk": [
                    "-            if cs is not S.One:",
                    "-                return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)",
                    "+            # assert cs >= 1",
                    "+            if c.is_Number and c is not S.NegativeOne:",
                    "+                # assert c != 1 (handled at top)",
                    "+                if cs is not S.One:",
                    "+                    if c.is_negative:",
                    "+                        xc = -(cs.extract_multiplicatively(-c))",
                    "+                    else:",
                    "+                        xc = cs.extract_multiplicatively(c)",
                    "+                    if xc is not None:",
                    "+                        return xc*ps  # rely on 2-arg Mul to restore Add",
                    "+                return  # |c| != 1 can only be extracted from cs",
                    "+            if c == ps:",
                    "+                return cs",
                    "+            # check args of ps",
                    "             newargs = []",
                    "-            for arg in self.args:",
                    "+            for arg in ps.args:",
                    "                 newarg = arg.extract_multiplicatively(c)",
                    "-                if newarg is not None:",
                    "-                    newargs.append(newarg)",
                    "-                else:",
                    "-                    return None",
                    "-            return Add(*newargs)",
                    "+                if newarg is None:",
                    "+                    return  # all or nothing",
                    "+                newargs.append(newarg)",
                    "+            # args should be in same order so use unevaluated return",
                    "+            if cs is not S.One:",
                    "+                return Add._from_args([cs*t for t in newargs])",
                    "+            else:",
                    "+                return Add._from_args(newargs)"
                ],
                "start_lineno": 2001,
                "end_lineno": 2010
            }
        ]
    },
    "django__django-11276": {
        "django/utils/html.py": [
            {
                "hunk": [
                    "+import html"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-_html_escapes = {",
                    "-    ord('&'): '&amp;',",
                    "-    ord('<'): '&lt;',",
                    "-    ord('>'): '&gt;',",
                    "-    ord('\"'): '&quot;',",
                    "-    ord(\"'\"): '&#39;',",
                    "-}",
                    "-"
                ],
                "start_lineno": 27,
                "end_lineno": 34
            },
            {
                "hunk": [
                    "-    return mark_safe(str(text).translate(_html_escapes))",
                    "+    return mark_safe(html.escape(str(text)))"
                ],
                "start_lineno": 46,
                "end_lineno": 46
            },
            {
                "hunk": [
                    "-    def unescape(text):",
                    "-        \"\"\"",
                    "-        If input URL is HTML-escaped, unescape it so that it can be safely fed",
                    "-        to smart_urlquote. For example:",
                    "-        http://example.com?x=1&amp;y=&lt;2&gt; => http://example.com?x=1&y=<2>",
                    "-        \"\"\"",
                    "-        return text.replace('&amp;', '&').replace('&lt;', '<').replace(",
                    "-            '&gt;', '>').replace('&quot;', '\"').replace('&#39;', \"'\")",
                    "-"
                ],
                "start_lineno": 262,
                "end_lineno": 270
            },
            {
                "hunk": [
                    "-            middle_unescaped = unescape(middle)",
                    "+            middle_unescaped = html.unescape(middle)"
                ],
                "start_lineno": 295,
                "end_lineno": 295
            },
            {
                "hunk": [
                    "-                url = smart_urlquote(unescape(middle))",
                    "+                url = smart_urlquote(html.unescape(middle))",
                    "             elif simple_url_2_re.match(middle):",
                    "-                url = smart_urlquote('http://%s' % unescape(middle))",
                    "+                url = smart_urlquote('http://%s' % html.unescape(middle))"
                ],
                "start_lineno": 332,
                "end_lineno": 334
            }
        ]
    },
    "scikit-learn__scikit-learn-25363": {
        "benchmarks/bench_saga.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    "-from sklearn.utils.fixes import delayed",
                    "+from sklearn.utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 10,
                "end_lineno": 11
            }
        ],
        "sklearn/calibration.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-from .utils.fixes import delayed",
                    "+from .utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            }
        ],
        "sklearn/cluster/_mean_shift.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    " from numbers import Integral, Real",
                    " ",
                    " from collections import defaultdict",
                    " from ..utils._param_validation import Interval, validate_params",
                    " from ..utils.validation import check_is_fitted",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 19,
                "end_lineno": 25
            }
        ],
        "sklearn/compose/_column_transformer.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 29,
                "end_lineno": 29
            }
        ],
        "sklearn/covariance/_graph_lasso.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 16,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 26,
                "end_lineno": 26
            }
        ],
        "sklearn/decomposition/_dict_learning.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 16,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 24,
                "end_lineno": 24
            }
        ],
        "sklearn/decomposition/_lda.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs",
                    " ",
                    " from ..base import BaseEstimator, TransformerMixin, ClassNamePrefixFeaturesOutMixin",
                    " from ..utils import check_random_state, gen_batches, gen_even_slices",
                    " from ..utils.validation import check_non_negative",
                    " from ..utils.validation import check_is_fitted",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 18,
                "end_lineno": 24
            }
        ],
        "sklearn/ensemble/_bagging.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    "-"
                ],
                "start_lineno": 15,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 28,
                "end_lineno": 28
            }
        ],
        "sklearn/ensemble/_forest.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 51,
                "end_lineno": 51
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 69,
                "end_lineno": 69
            }
        ],
        "sklearn/ensemble/_stacking.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 11,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 36,
                "end_lineno": 36
            }
        ],
        "sklearn/ensemble/_voting.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    "-"
                ],
                "start_lineno": 21,
                "end_lineno": 22
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 39,
                "end_lineno": 39
            }
        ],
        "sklearn/feature_selection/_rfe.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 11,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            }
        ],
        "sklearn/inspection/_permutation_importance.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 4,
                "end_lineno": 4
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            }
        ],
        "sklearn/inspection/_plot/partial_dependence.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "-from ...utils.fixes import delayed",
                    "+from ...utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            }
        ],
        "sklearn/linear_model/_base.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 28,
                "end_lineno": 28
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 43,
                "end_lineno": 43
            }
        ],
        "sklearn/linear_model/_coordinate_descent.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            }
        ],
        "sklearn/linear_model/_least_angle.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 31,
                "end_lineno": 31
            }
        ],
        "sklearn/linear_model/_logistic.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 37,
                "end_lineno": 37
            }
        ],
        "sklearn/linear_model/_omp.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    " ",
                    " from ._base import LinearModel, _pre_fit, _deprecate_normalize",
                    " from ..base import RegressorMixin, MultiOutputMixin",
                    " from ..utils import as_float_array, check_array",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 15,
                "end_lineno": 20
            }
        ],
        "sklearn/linear_model/_stochastic_gradient.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    "-"
                ],
                "start_lineno": 15,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 29,
                "end_lineno": 29
            }
        ],
        "sklearn/linear_model/_theil_sen.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs",
                    " ",
                    " from ._base import LinearModel",
                    " from ..base import RegressorMixin",
                    " from ..utils import check_random_state",
                    " from ..utils._param_validation import Interval",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 18,
                "end_lineno": 24
            }
        ],
        "sklearn/manifold/_mds.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 11,
                "end_lineno": 11
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            }
        ],
        "sklearn/metrics/pairwise.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 18,
                "end_lineno": 18
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 30,
                "end_lineno": 30
            }
        ],
        "sklearn/model_selection/_search.py": [
            {
                "hunk": [
                    "-from joblib import Parallel",
                    " from ..utils import check_random_state",
                    " from ..utils.random import sample_without_replacement",
                    " from ..utils._param_validation import HasMethods, Interval, StrOptions",
                    " from ..utils._tags import _safe_tags",
                    " from ..utils.validation import indexable, check_is_fitted, _check_fit_params",
                    " from ..utils.metaestimators import available_if",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 36,
                "end_lineno": 43
            }
        ],
        "sklearn/model_selection/_validation.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, logger",
                    "+from joblib import logger",
                    " ",
                    " from ..base import is_classifier, clone",
                    " from ..utils import indexable, check_random_state, _safe_indexing",
                    " from ..utils.validation import _check_fit_params",
                    " from ..utils.validation import _num_samples",
                    "-from ..utils.fixes import delayed",
                    "+from ..utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 24,
                "end_lineno": 30
            }
        ],
        "sklearn/multiclass.py": [
            {
                "hunk": [
                    "-from .utils.fixes import delayed",
                    "-",
                    "-from joblib import Parallel",
                    "+from .utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 59,
                "end_lineno": 61
            }
        ],
        "sklearn/multioutput.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 20,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "-from .utils.fixes import delayed",
                    "+from .utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 34,
                "end_lineno": 34
            }
        ],
        "sklearn/neighbors/_base.py": [
            {
                "hunk": [
                    "-from joblib import Parallel, effective_n_jobs",
                    "+from joblib import effective_n_jobs"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "-from ..utils.fixes import delayed, sp_version",
                    "-from ..utils.fixes import parse_version",
                    "+from ..utils.parallel import delayed, Parallel",
                    "+from ..utils.fixes import parse_version, sp_version"
                ],
                "start_lineno": 40,
                "end_lineno": 41
            }
        ],
        "sklearn/pipeline.py": [
            {
                "hunk": [
                    "-from joblib import Parallel"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            },
            {
                "hunk": [
                    "-from .utils.fixes import delayed",
                    "+from .utils.parallel import delayed, Parallel"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            }
        ],
        "sklearn/utils/fixes.py": [
            {
                "hunk": [
                    "-from functools import update_wrapper",
                    " from importlib import resources",
                    "-import functools"
                ],
                "start_lineno": 13,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-from .._config import config_context, get_config",
                    "+",
                    "+from .deprecation import deprecated"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            },
            {
                "hunk": [
                    "-# remove when https://github.com/joblib/joblib/issues/1071 is fixed",
                    "-def delayed(function):",
                    "-    \"\"\"Decorator used to capture the arguments of a function.\"\"\"",
                    "-",
                    "-    @functools.wraps(function)",
                    "-    def delayed_function(*args, **kwargs):",
                    "-        return _FuncWrapper(function), args, kwargs",
                    "-",
                    "-    return delayed_function",
                    "-",
                    "-",
                    "-class _FuncWrapper:",
                    "-    \"\"\" \"Load the global configuration before calling the function.\"\"\"",
                    "-",
                    "-    def __init__(self, function):",
                    "-        self.function = function",
                    "-        self.config = get_config()",
                    "-        update_wrapper(self, self.function)",
                    "-",
                    "-    def __call__(self, *args, **kwargs):",
                    "-        with config_context(**self.config):",
                    "-            return self.function(*args, **kwargs)",
                    "-",
                    "-"
                ],
                "start_lineno": 109,
                "end_lineno": 132
            },
            {
                "hunk": [
                    "+@deprecated(",
                    "+    \"The function `delayed` has been moved from `sklearn.utils.fixes` to \"",
                    "+    \"`sklearn.utils.parallel`. This import path will be removed in 1.5.\"",
                    "+)",
                    "+def delayed(function):",
                    "+    from sklearn.utils.parallel import delayed",
                    "+",
                    "+    return delayed(function)",
                    "+",
                    "+"
                ],
                "start_lineno": 181,
                "end_lineno": 181
            }
        ],
        "dev/null": [
            {
                "hunk": [
                    "+\"\"\"Module that customize joblib tools for scikit-learn usage.\"\"\"",
                    "+",
                    "+import functools",
                    "+import warnings",
                    "+from functools import update_wrapper",
                    "+",
                    "+import joblib",
                    "+",
                    "+from .._config import config_context, get_config",
                    "+",
                    "+",
                    "+def _with_config(delayed_func, config):",
                    "+    \"\"\"Helper function that intends to attach a config to a delayed function.\"\"\"",
                    "+    if hasattr(delayed_func, \"with_config\"):",
                    "+        return delayed_func.with_config(config)",
                    "+    else:",
                    "+        warnings.warn(",
                    "+            \"`sklearn.utils.parallel.Parallel` needs to be used in \"",
                    "+            \"conjunction with `sklearn.utils.parallel.delayed` instead of \"",
                    "+            \"`joblib.delayed` to correctly propagate the scikit-learn \"",
                    "+            \"configuration to the joblib workers.\",",
                    "+            UserWarning,",
                    "+        )",
                    "+        return delayed_func",
                    "+",
                    "+",
                    "+class Parallel(joblib.Parallel):",
                    "+    \"\"\"Tweak of :class:`joblib.Parallel` that propagates the scikit-learn configuration.",
                    "+",
                    "+    This subclass of :class:`joblib.Parallel` ensures that the active configuration",
                    "+    (thread-local) of scikit-learn is propagated to the parallel workers for the",
                    "+    duration of the execution of the parallel tasks.",
                    "+",
                    "+    The API does not change and you can refer to :class:`joblib.Parallel`",
                    "+    documentation for more details.",
                    "+",
                    "+    .. versionadded:: 1.3",
                    "+    \"\"\"",
                    "+",
                    "+    def __call__(self, iterable):",
                    "+        \"\"\"Dispatch the tasks and return the results.",
                    "+",
                    "+        Parameters",
                    "+        ----------",
                    "+        iterable : iterable",
                    "+            Iterable containing tuples of (delayed_function, args, kwargs) that should",
                    "+            be consumed.",
                    "+",
                    "+        Returns",
                    "+        -------",
                    "+        results : list",
                    "+            List of results of the tasks.",
                    "+        \"\"\"",
                    "+        # Capture the thread-local scikit-learn configuration at the time",
                    "+        # Parallel.__call__ is issued since the tasks can be dispatched",
                    "+        # in a different thread depending on the backend and on the value of",
                    "+        # pre_dispatch and n_jobs.",
                    "+        config = get_config()",
                    "+        iterable_with_config = (",
                    "+            (_with_config(delayed_func, config), args, kwargs)",
                    "+            for delayed_func, args, kwargs in iterable",
                    "+        )",
                    "+        return super().__call__(iterable_with_config)",
                    "+",
                    "+",
                    "+# remove when https://github.com/joblib/joblib/issues/1071 is fixed",
                    "+def delayed(function):",
                    "+    \"\"\"Decorator used to capture the arguments of a function.",
                    "+",
                    "+    This alternative to `joblib.delayed` is meant to be used in conjunction",
                    "+    with `sklearn.utils.parallel.Parallel`. The latter captures the the scikit-",
                    "+    learn configuration by calling `sklearn.get_config()` in the current",
                    "+    thread, prior to dispatching the first task. The captured configuration is",
                    "+    then propagated and enabled for the duration of the execution of the",
                    "+    delayed function in the joblib workers.",
                    "+",
                    "+    .. versionchanged:: 1.3",
                    "+       `delayed` was moved from `sklearn.utils.fixes` to `sklearn.utils.parallel`",
                    "+       in scikit-learn 1.3.",
                    "+",
                    "+    Parameters",
                    "+    ----------",
                    "+    function : callable",
                    "+        The function to be delayed.",
                    "+",
                    "+    Returns",
                    "+    -------",
                    "+    output: tuple",
                    "+        Tuple containing the delayed function, the positional arguments, and the",
                    "+        keyword arguments.",
                    "+    \"\"\"",
                    "+",
                    "+    @functools.wraps(function)",
                    "+    def delayed_function(*args, **kwargs):",
                    "+        return _FuncWrapper(function), args, kwargs",
                    "+",
                    "+    return delayed_function",
                    "+",
                    "+",
                    "+class _FuncWrapper:",
                    "+    \"\"\"Load the global configuration before calling the function.\"\"\"",
                    "+",
                    "+    def __init__(self, function):",
                    "+        self.function = function",
                    "+        update_wrapper(self, self.function)",
                    "+",
                    "+    def with_config(self, config):",
                    "+        self.config = config",
                    "+        return self",
                    "+",
                    "+    def __call__(self, *args, **kwargs):",
                    "+        config = getattr(self, \"config\", None)",
                    "+        if config is None:",
                    "+            warnings.warn(",
                    "+                \"`sklearn.utils.parallel.delayed` should be used with \"",
                    "+                \"`sklearn.utils.parallel.Parallel` to make it possible to propagate \"",
                    "+                \"the scikit-learn configuration of the current thread to the \"",
                    "+                \"joblib workers.\",",
                    "+                UserWarning,",
                    "+            )",
                    "+            config = {}",
                    "+        with config_context(**config):",
                    "+            return self.function(*args, **kwargs)"
                ],
                "start_lineno": 0,
                "end_lineno": 0
            }
        ]
    },
    "django__django-12469": {
        "django/contrib/admin/templatetags/admin_list.py": [
            {
                "hunk": [
                    "-    display_for_field, display_for_value, label_for_field, lookup_field,",
                    "+    display_for_field, display_for_value, get_fields_from_path,",
                    "+    label_for_field, lookup_field,"
                ],
                "start_lineno": 5,
                "end_lineno": 5
            },
            {
                "hunk": [
                    "-from django.utils import formats",
                    "+from django.utils import formats, timezone"
                ],
                "start_lineno": 16,
                "end_lineno": 16
            },
            {
                "hunk": [
                    "+        field = get_fields_from_path(cl.model, field_name)[-1]",
                    "+        if isinstance(field, models.DateTimeField):",
                    "+            dates_or_datetimes = 'datetimes'",
                    "+            qs_kwargs = {'is_dst': True}",
                    "+        else:",
                    "+            dates_or_datetimes = 'dates'",
                    "+            qs_kwargs = {}"
                ],
                "start_lineno": 362,
                "end_lineno": 362
            },
            {
                "hunk": [
                    "+            if dates_or_datetimes == 'datetimes':",
                    "+                date_range = {",
                    "+                    k: timezone.localtime(v) if timezone.is_aware(v) else v",
                    "+                    for k, v in date_range.items()",
                    "+                }"
                ],
                "start_lineno": 377,
                "end_lineno": 377
            },
            {
                "hunk": [
                    "-            days = getattr(cl.queryset, 'dates')(field_name, 'day')",
                    "+            days = getattr(cl.queryset, dates_or_datetimes)(field_name, 'day', **qs_kwargs)"
                ],
                "start_lineno": 394,
                "end_lineno": 394
            },
            {
                "hunk": [
                    "-            months = getattr(cl.queryset, 'dates')(field_name, 'month')",
                    "+            months = getattr(cl.queryset, dates_or_datetimes)(field_name, 'month', **qs_kwargs)"
                ],
                "start_lineno": 407,
                "end_lineno": 407
            },
            {
                "hunk": [
                    "-            years = getattr(cl.queryset, 'dates')(field_name, 'year')",
                    "+            years = getattr(cl.queryset, dates_or_datetimes)(field_name, 'year', **qs_kwargs)"
                ],
                "start_lineno": 420,
                "end_lineno": 420
            }
        ]
    },
    "sphinx-doc__sphinx-7501": {
        "sphinx/domains/std.py": [
            {
                "hunk": [
                    "+        elif typ == 'term':",
                    "+            resolver = self._resolve_term_xref"
                ],
                "start_lineno": 792,
                "end_lineno": 792
            },
            {
                "hunk": [
                    "+    def _resolve_term_xref(self, env: \"BuildEnvironment\", fromdocname: str,",
                    "+                           builder: \"Builder\", typ: str, target: str,",
                    "+                           node: pending_xref, contnode: Element) -> Element:",
                    "+        result = self._resolve_obj_xref(env, fromdocname, builder, typ,",
                    "+                                        target, node, contnode)",
                    "+        if result:",
                    "+            return result",
                    "+        else:",
                    "+            for objtype, term in self.objects:",
                    "+                if objtype == 'term' and term.lower() == target.lower():",
                    "+                    docname, labelid = self.objects[objtype, term]",
                    "+                    logger.warning(__('term %s not found in case sensitive match.'",
                    "+                                      'made a reference to %s instead.'),",
                    "+                                   target, term, location=node, type='ref', subtype='term')",
                    "+                    break",
                    "+            else:",
                    "+                docname, labelid = '', ''",
                    "+            if not docname:",
                    "+                return None",
                    "+            return make_refnode(builder, fromdocname, docname,",
                    "+                                labelid, contnode)",
                    "+"
                ],
                "start_lineno": 926,
                "end_lineno": 926
            }
        ]
    },
    "matplotlib__matplotlib-22711": {
        "lib/matplotlib/widgets.py": [
            {
                "hunk": [
                    "-            self._active_handle.set_xdata([val])",
                    "+            if self.orientation == \"vertical\":",
                    "+                self._active_handle.set_ydata([val])",
                    "+            else:",
                    "+                self._active_handle.set_xdata([val])"
                ],
                "start_lineno": 816,
                "end_lineno": 816
            },
            {
                "hunk": [
                    "-        handle = self._handles[",
                    "-            np.argmin(",
                    "+        if self.orientation == \"vertical\":",
                    "+            handle_index = np.argmin(",
                    "+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])",
                    "+            )",
                    "+        else:",
                    "+            handle_index = np.argmin(",
                    "                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])",
                    "             )",
                    "-        ]",
                    "+        handle = self._handles[handle_index]",
                    "+"
                ],
                "start_lineno": 839,
                "end_lineno": 843
            },
            {
                "hunk": [
                    "+",
                    "+            self._handles[0].set_ydata([val[0]])",
                    "+            self._handles[1].set_ydata([val[1]])",
                    "         else:",
                    "             xy[0] = val[0], .25",
                    "             xy[1] = val[0], .75",
                    "             xy[2] = val[1], .75",
                    "             xy[3] = val[1], .25",
                    "             xy[4] = val[0], .25",
                    "+",
                    "+            self._handles[0].set_xdata([val[0]])",
                    "+            self._handles[1].set_xdata([val[1]])",
                    "+",
                    "         self.poly.xy = xy",
                    "         self.valtext.set_text(self._format(val))",
                    "+"
                ],
                "start_lineno": 907,
                "end_lineno": 914
            }
        ]
    },
    "django__django-13744": {
        "django/core/cache/__init__.py": [
            {
                "hunk": [
                    "-    # Some caches -- python-memcached in particular -- need to do a cleanup at the",
                    "-    # end of a request cycle. If not implemented in a particular backend",
                    "-    # cache.close is a no-op",
                    "+    # Some caches need to do a cleanup at the end of a request cycle. If not",
                    "+    # implemented in a particular backend cache.close() is a no-op."
                ],
                "start_lineno": 117,
                "end_lineno": 119
            }
        ],
        "django/core/cache/backends/memcached.py": [
            {
                "hunk": [
                    "+import warnings",
                    " ",
                    " from django.core.cache.backends.base import (",
                    "     DEFAULT_TIMEOUT, BaseCache, InvalidCacheKey, memcache_key_warnings,",
                    " )",
                    "+from django.utils.deprecation import RemovedInDjango41Warning"
                ],
                "start_lineno": 6,
                "end_lineno": 9
            },
            {
                "hunk": [
                    "+        warnings.warn(",
                    "+            'MemcachedCache is deprecated in favor of PyMemcacheCache and '",
                    "+            'PyLibMCCache.',",
                    "+            RemovedInDjango41Warning, stacklevel=2,",
                    "+        )"
                ],
                "start_lineno": 167,
                "end_lineno": 167
            }
        ]
    },
    "django__django-13617": {
        "django/db/models/sql/query.py": [
            {
                "hunk": [
                    "+            selected = frozenset(field_names + extra_names + annotation_names)",
                    "         else:",
                    "             field_names = [f.attname for f in self.model._meta.concrete_fields]",
                    "+            selected = frozenset(field_names)"
                ],
                "start_lineno": 2213,
                "end_lineno": 2214
            },
            {
                "hunk": [
                    "-                if isinstance(expr, Ref) and expr.refs not in field_names:",
                    "+                if isinstance(expr, Ref) and expr.refs not in selected:"
                ],
                "start_lineno": 2228,
                "end_lineno": 2228
            }
        ]
    },
    "django__django-12910": {
        "django/contrib/auth/management/commands/changepassword.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            }
        ],
        "django/contrib/gis/management/commands/ogrinspect.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 40,
                "end_lineno": 40
            }
        ],
        "django/contrib/staticfiles/management/commands/collectstatic.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = [Tags.staticfiles]"
                ],
                "start_lineno": 19,
                "end_lineno": 19
            },
            {
                "hunk": [
                    "-        parser.add_argument(",
                    "-            '--skip-checks', action='store_true',",
                    "-            help='Skip system checks.',",
                    "-        )"
                ],
                "start_lineno": 39,
                "end_lineno": 42
            },
            {
                "hunk": [
                    "-        if not options['skip_checks']:",
                    "-            self.check(tags=[Tags.staticfiles])",
                    "-"
                ],
                "start_lineno": 154,
                "end_lineno": 156
            }
        ],
        "django/core/management/base.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 7,
                "end_lineno": 7
            },
            {
                "hunk": [
                    "+from django.utils.deprecation import RemovedInDjango41Warning",
                    "+",
                    "+ALL_CHECKS = '__all__'"
                ],
                "start_lineno": 15,
                "end_lineno": 15
            },
            {
                "hunk": [
                    "-        A boolean; if ``True``, entire Django project will be checked for errors",
                    "-        prior to executing the command. Default value is ``True``.",
                    "+        A list or tuple of tags, e.g. [Tags.staticfiles, Tags.models]. System",
                    "+        checks registered in the chosen tags will be checked for errors prior",
                    "+        to executing the command. The value '__all__' can be used to specify",
                    "+        that all system checks should be performed. Default value is '__all__'.",
                    "+"
                ],
                "start_lineno": 206,
                "end_lineno": 207
            },
            {
                "hunk": [
                    "-    requires_system_checks = True",
                    "+    requires_system_checks = '__all__'"
                ],
                "start_lineno": 225,
                "end_lineno": 225
            },
            {
                "hunk": [
                    "+        if self.requires_system_checks in [False, True]:",
                    "+            warnings.warn(",
                    "+                \"Using a boolean value for requires_system_checks is \"",
                    "+                \"deprecated. Use '__all__' instead of True, and [] (an empty \"",
                    "+                \"list) instead of False.\",",
                    "+                RemovedInDjango41Warning,",
                    "+            )",
                    "+            self.requires_system_checks = ALL_CHECKS if self.requires_system_checks else []",
                    "+        if (",
                    "+            not isinstance(self.requires_system_checks, (list, tuple)) and",
                    "+            self.requires_system_checks != ALL_CHECKS",
                    "+        ):",
                    "+            raise TypeError('requires_system_checks must be a list or tuple.')"
                ],
                "start_lineno": 242,
                "end_lineno": 242
            },
            {
                "hunk": [
                    "-            self.check()",
                    "+            if self.requires_system_checks == ALL_CHECKS:",
                    "+                self.check()",
                    "+            else:",
                    "+                self.check(tags=self.requires_system_checks)"
                ],
                "start_lineno": 368,
                "end_lineno": 368
            }
        ],
        "django/core/management/commands/check.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 10,
                "end_lineno": 10
            }
        ],
        "django/core/management/commands/compilemessages.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 32,
                "end_lineno": 32
            }
        ],
        "django/core/management/commands/createcachetable.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            }
        ],
        "django/core/management/commands/dbshell.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            }
        ],
        "django/core/management/commands/diffsettings.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            }
        ],
        "django/core/management/commands/inspectdb.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 11,
                "end_lineno": 11
            }
        ],
        "django/core/management/commands/makemessages.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 209,
                "end_lineno": 209
            }
        ],
        "django/core/management/commands/migrate.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            }
        ],
        "django/core/management/commands/runserver.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 28,
                "end_lineno": 28
            }
        ],
        "django/core/management/commands/shell.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 17,
                "end_lineno": 17
            }
        ],
        "django/core/management/commands/testserver.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 9,
                "end_lineno": 9
            }
        ],
        "django/core/management/templates.py": [
            {
                "hunk": [
                    "-    requires_system_checks = False",
                    "+    requires_system_checks = []"
                ],
                "start_lineno": 31,
                "end_lineno": 31
            }
        ]
    },
    "scikit-learn__scikit-learn-25102": {
        "sklearn/base.py": [
            {
                "hunk": [
                    "+        cast_to_ndarray=True,"
                ],
                "start_lineno": 501,
                "end_lineno": 501
            },
            {
                "hunk": [
                    "+        cast_to_ndarray : bool, default=True",
                    "+            Cast `X` and `y` to ndarray with checks in `check_params`. If",
                    "+            `False`, `X` and `y` are unchanged and only `feature_names` and",
                    "+            `n_features_in_` are checked.",
                    "+"
                ],
                "start_lineno": 546,
                "end_lineno": 546
            },
            {
                "hunk": [
                    "-            X = check_array(X, input_name=\"X\", **check_params)",
                    "+            if cast_to_ndarray:",
                    "+                X = check_array(X, input_name=\"X\", **check_params)",
                    "             out = X",
                    "         elif no_val_X and not no_val_y:",
                    "-            y = _check_y(y, **check_params)",
                    "+            if cast_to_ndarray:",
                    "+                y = _check_y(y, **check_params) if cast_to_ndarray else y",
                    "             out = y",
                    "         else:",
                    "-            if validate_separately:",
                    "+            if validate_separately and cast_to_ndarray:"
                ],
                "start_lineno": 577,
                "end_lineno": 583
            }
        ],
        "sklearn/feature_selection/_base.py": [
            {
                "hunk": [
                    "-    safe_mask,",
                    "     safe_sqr,",
                    " )",
                    " from ..utils._tags import _safe_tags",
                    "+from ..utils import _safe_indexing",
                    "+from ..utils._set_output import _get_output_config"
                ],
                "start_lineno": 17,
                "end_lineno": 20
            },
            {
                "hunk": [
                    "+        # Preserve X when X is a dataframe and the output is configured to",
                    "+        # be pandas.",
                    "+        output_config_dense = _get_output_config(\"transform\", estimator=self)[\"dense\"]",
                    "+        preserve_X = hasattr(X, \"iloc\") and output_config_dense == \"pandas\"",
                    "+"
                ],
                "start_lineno": 81,
                "end_lineno": 81
            },
            {
                "hunk": [
                    "+            cast_to_ndarray=not preserve_X,"
                ],
                "start_lineno": 88,
                "end_lineno": 88
            },
            {
                "hunk": [
                    "+            if hasattr(X, \"iloc\"):",
                    "+                return X.iloc[:, :0]",
                    "             return np.empty(0, dtype=X.dtype).reshape((X.shape[0], 0))",
                    "-        if len(mask) != X.shape[1]:",
                    "-            raise ValueError(\"X has a different shape than during fitting.\")",
                    "-        return X[:, safe_mask(X, mask)]",
                    "+        return _safe_indexing(X, mask, axis=1)"
                ],
                "start_lineno": 101,
                "end_lineno": 104
            }
        ]
    },
    "matplotlib__matplotlib-26472": {
        "lib/matplotlib/backend_bases.py": [
            {
                "hunk": [
                    "-    _tight_bbox, transforms, widgets, get_backend, is_interactive, rcParams)",
                    "+    _tight_bbox, transforms, widgets, is_interactive, rcParams)"
                ],
                "start_lineno": 48,
                "end_lineno": 48
            },
            {
                "hunk": [
                    "-            f\"Matplotlib is currently using {get_backend()}, which is a \"",
                    "-            f\"non-GUI backend, so cannot show the figure.\")",
                    "+            f\"{type(self.canvas).__name__} is non-interactive, and thus cannot be \"",
                    "+            f\"shown\")"
                ],
                "start_lineno": 2739,
                "end_lineno": 2740
            }
        ],
        "lib/matplotlib/pyplot.py": [
            {
                "hunk": [
                    "+",
                    "     if not cbook._str_equal(old_backend, newbackend):",
                    "+        if get_fignums():",
                    "+            _api.warn_deprecated(\"3.8\", message=(",
                    "+                \"Auto-close()ing of figures upon backend switching is deprecated since \"",
                    "+                \"%(since)s and will be removed %(removal)s.  To suppress this warning, \"",
                    "+                \"explicitly call plt.close('all') first.\"))",
                    "         close(\"all\")",
                    " ",
                    "-    # make sure the repl display hook is installed in case we become",
                    "-    # interactive",
                    "+    # Make sure the repl display hook is installed in case we become interactive."
                ],
                "start_lineno": 423,
                "end_lineno": 427
            }
        ]
    },
    "sympy__sympy-17139": {
        "sympy/simplify/fu.py": [
            {
                "hunk": [
                    "+        if not rv.exp.is_real:",
                    "+            return rv"
                ],
                "start_lineno": 503,
                "end_lineno": 503
            }
        ]
    },
    "psf__requests-2153": {
        "requests/compat.py": [
            {
                "hunk": [
                    "-    from httplib import IncompleteRead"
                ],
                "start_lineno": 95,
                "end_lineno": 95
            },
            {
                "hunk": [
                    "-    from http.client import IncompleteRead"
                ],
                "start_lineno": 111,
                "end_lineno": 111
            }
        ],
        "requests/models.py": [
            {
                "hunk": [
                    "-import socket"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "-from .packages.urllib3.exceptions import DecodeError",
                    "+from .packages.urllib3.exceptions import (",
                    "+    DecodeError, ReadTimeoutError, ProtocolError)"
                ],
                "start_lineno": 23,
                "end_lineno": 23
            },
            {
                "hunk": [
                    "-    is_py2, chardet, json, builtin_str, basestring, IncompleteRead)",
                    "+    is_py2, chardet, json, builtin_str, basestring)"
                ],
                "start_lineno": 33,
                "end_lineno": 33
            },
            {
                "hunk": [
                    "-                except IncompleteRead as e:",
                    "+                except ProtocolError as e:",
                    "                     raise ChunkedEncodingError(e)",
                    "                 except DecodeError as e:",
                    "                     raise ContentDecodingError(e)",
                    "-                except socket.error as e:",
                    "+                except ReadTimeoutError as e:"
                ],
                "start_lineno": 640,
                "end_lineno": 644
            }
        ]
    },
    "django__django-14334": {
        "django/utils/translation/trans_real.py": [
            {
                "hunk": [
                    "-        # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.",
                    "+        # If 'zh-hant-tw' is not supported, try special fallback or subsequent",
                    "+        # language codes i.e. 'zh-hant' and 'zh'.",
                    "         possible_lang_codes = [lang_code]",
                    "         try:",
                    "             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])",
                    "         except KeyError:",
                    "             pass",
                    "-        generic_lang_code = lang_code.split('-')[0]",
                    "-        possible_lang_codes.append(generic_lang_code)",
                    "+        i = None",
                    "+        while (i := lang_code.rfind('-', 0, i)) > -1:",
                    "+            possible_lang_codes.append(lang_code[:i])",
                    "+        generic_lang_code = possible_lang_codes[-1]"
                ],
                "start_lineno": 477,
                "end_lineno": 484
            }
        ]
    },
    "astropy__astropy-14628": {
        "astropy/coordinates/earth.py": [
            {
                "hunk": [
                    "-    def get_itrs(self, obstime=None):",
                    "+    def get_itrs(self, obstime=None, location=None):",
                    "         \"\"\"",
                    "         Generates an `~astropy.coordinates.ITRS` object with the location of",
                    "-        this object at the requested ``obstime``.",
                    "+        this object at the requested ``obstime``, either geocentric, or",
                    "+        topocentric relative to a given ``location``.",
                    " ",
                    "         Parameters",
                    "         ----------",
                    "         obstime : `~astropy.time.Time` or None",
                    "             The ``obstime`` to apply to the new `~astropy.coordinates.ITRS`, or",
                    "             if None, the default ``obstime`` will be used.",
                    "+        location : `~astropy.coordinates.EarthLocation` or None",
                    "+            A possible observer's location, for a topocentric ITRS position.",
                    "+            If not given (default), a geocentric ITRS object will be created.",
                    " ",
                    "         Returns",
                    "         -------",
                    "         itrs : `~astropy.coordinates.ITRS`",
                    "-            The new object in the ITRS frame",
                    "+            The new object in the ITRS frame, either geocentric or topocentric",
                    "+            relative to the given ``location``."
                ],
                "start_lineno": 658,
                "end_lineno": 672
            },
            {
                "hunk": [
                    "-        return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)",
                    "+        if location is None:",
                    "+            # No location provided, return geocentric ITRS coordinates",
                    "+            return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)",
                    "+        else:",
                    "+            return ITRS(",
                    "+                self.x - location.x,",
                    "+                self.y - location.y,",
                    "+                self.z - location.z,",
                    "+                copy=False,",
                    "+                obstime=obstime,",
                    "+                location=location,",
                    "+            )"
                ],
                "start_lineno": 682,
                "end_lineno": 682
            }
        ]
    },
    "scikit-learn__scikit-learn-13174": {
        "sklearn/ensemble/weight_boosting.py": [
            {
                "hunk": [
                    "-from ..base import ClassifierMixin, RegressorMixin, is_regressor, is_classifier",
                    "+from ..base import ClassifierMixin, RegressorMixin, is_classifier, is_regressor",
                    " ",
                    "-from .forest import BaseForest",
                    " from ..tree import DecisionTreeClassifier, DecisionTreeRegressor",
                    "-from ..tree.tree import BaseDecisionTree",
                    "-from ..tree._tree import DTYPE",
                    "-from ..utils import check_array, check_X_y, check_random_state",
                    "+from ..utils import check_array, check_random_state, check_X_y, safe_indexing",
                    " from ..utils.extmath import stable_cumsum",
                    " from ..metrics import accuracy_score, r2_score",
                    "-from sklearn.utils.validation import has_fit_parameter, check_is_fitted",
                    "+from ..utils.validation import check_is_fitted",
                    "+from ..utils.validation import has_fit_parameter",
                    "+from ..utils.validation import _num_samples"
                ],
                "start_lineno": 33,
                "end_lineno": 42
            },
            {
                "hunk": [
                    "+    def _validate_data(self, X, y=None):",
                    "+",
                    "+        # Accept or convert to these sparse matrix formats so we can",
                    "+        # use safe_indexing",
                    "+        accept_sparse = ['csr', 'csc']",
                    "+        if y is None:",
                    "+            ret = check_array(X,",
                    "+                              accept_sparse=accept_sparse,",
                    "+                              ensure_2d=False,",
                    "+                              allow_nd=True,",
                    "+                              dtype=None)",
                    "+        else:",
                    "+            ret = check_X_y(X, y,",
                    "+                            accept_sparse=accept_sparse,",
                    "+                            ensure_2d=False,",
                    "+                            allow_nd=True,",
                    "+                            dtype=None,",
                    "+                            y_numeric=is_regressor(self))",
                    "+        return ret",
                    "+"
                ],
                "start_lineno": 73,
                "end_lineno": 73
            },
            {
                "hunk": [
                    "-            DOK, or LIL. COO, DOK, and LIL are converted to CSR. The dtype is",
                    "-            forced to DTYPE from tree._tree if the base classifier of this",
                    "-            ensemble weighted boosting classifier is a tree or forest.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 80,
                "end_lineno": 82
            },
            {
                "hunk": [
                    "-        if (self.base_estimator is None or",
                    "-                isinstance(self.base_estimator, (BaseDecisionTree,",
                    "-                                                 BaseForest))):",
                    "-            dtype = DTYPE",
                    "-            accept_sparse = 'csc'",
                    "-        else:",
                    "-            dtype = None",
                    "-            accept_sparse = ['csr', 'csc']",
                    "-",
                    "-        X, y = check_X_y(X, y, accept_sparse=accept_sparse, dtype=dtype,",
                    "-                         y_numeric=is_regressor(self))",
                    "+        X, y = self._validate_data(X, y)",
                    " ",
                    "         if sample_weight is None:",
                    "             # Initialize weights to 1 / n_samples",
                    "-            sample_weight = np.empty(X.shape[0], dtype=np.float64)",
                    "-            sample_weight[:] = 1. / X.shape[0]",
                    "+            sample_weight = np.empty(_num_samples(X), dtype=np.float64)",
                    "+            sample_weight[:] = 1. / _num_samples(X)"
                ],
                "start_lineno": 100,
                "end_lineno": 115
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 219,
                "end_lineno": 219
            },
            {
                "hunk": [
                    "+        X = self._validate_data(X)",
                    "+"
                ],
                "start_lineno": 231,
                "end_lineno": 231
            },
            {
                "hunk": [
                    "-    def _validate_X_predict(self, X):",
                    "-        \"\"\"Ensure that X is in the proper format\"\"\"",
                    "-        if (self.base_estimator is None or",
                    "-                isinstance(self.base_estimator,",
                    "-                           (BaseDecisionTree, BaseForest))):",
                    "-            X = check_array(X, accept_sparse='csr', dtype=DTYPE)",
                    "-",
                    "-        else:",
                    "-            X = check_array(X, accept_sparse=['csr', 'csc', 'coo'])",
                    "-",
                    "-        return X",
                    "-"
                ],
                "start_lineno": 262,
                "end_lineno": 273
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 394,
                "end_lineno": 394
            },
            {
                "hunk": [
                    "-            The training input samples. Sparse matrix can be CSC, CSR, COO,",
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            The training input samples."
                ],
                "start_lineno": 445,
                "end_lineno": 446
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR.",
                    " ",
                    "         Returns",
                    "         -------",
                    "         y : array of shape = [n_samples]",
                    "             The predicted classes.",
                    "         \"\"\"",
                    "+        X = self._validate_data(X)",
                    "+"
                ],
                "start_lineno": 594,
                "end_lineno": 600
            },
            {
                "hunk": [
                    "-            The input samples.",
                    "+            The input samples. Sparse matrix can be CSC, CSR, COO,",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR.",
                    " ",
                    "         Returns",
                    "         -------",
                    "         y : generator of array, shape = [n_samples]",
                    "             The predicted classes.",
                    "         \"\"\"",
                    "+        X = self._validate_data(X)",
                    "+"
                ],
                "start_lineno": 621,
                "end_lineno": 627
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 647,
                "end_lineno": 647
            },
            {
                "hunk": [
                    "-        X = self._validate_X_predict(X)",
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 660,
                "end_lineno": 660
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 690,
                "end_lineno": 690
            },
            {
                "hunk": [
                    "-        X = self._validate_X_predict(X)",
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 703,
                "end_lineno": 703
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 744,
                "end_lineno": 744
            },
            {
                "hunk": [
                    "+        X = self._validate_data(X)",
                    " ",
                    "         n_classes = self.n_classes_",
                    "-        X = self._validate_X_predict(X)",
                    " ",
                    "         if n_classes == 1:",
                    "-            return np.ones((X.shape[0], 1))",
                    "+            return np.ones((_num_samples(X), 1))"
                ],
                "start_lineno": 753,
                "end_lineno": 758
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 793,
                "end_lineno": 793
            },
            {
                "hunk": [
                    "-        X = self._validate_X_predict(X)",
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 801,
                "end_lineno": 801
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 840,
                "end_lineno": 840
            },
            {
                "hunk": [
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 848,
                "end_lineno": 848
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 940,
                "end_lineno": 940
            },
            {
                "hunk": [
                    "-            The training input samples. Sparse matrix can be CSC, CSR, COO,",
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            The training input samples."
                ],
                "start_lineno": 978,
                "end_lineno": 979
            },
            {
                "hunk": [
                    "-        uniform_samples = random_state.random_sample(X.shape[0])",
                    "+        uniform_samples = random_state.random_sample(_num_samples(X))",
                    "         bootstrap_idx = cdf.searchsorted(uniform_samples, side='right')",
                    "         # searchsorted returns a scalar",
                    "         bootstrap_idx = np.array(bootstrap_idx, copy=False)",
                    " ",
                    "         # Fit on the bootstrapped sample and obtain a prediction",
                    "         # for all samples in the training set",
                    "-        estimator.fit(X[bootstrap_idx], y[bootstrap_idx])",
                    "+        X_ = safe_indexing(X, bootstrap_idx)",
                    "+        y_ = safe_indexing(y, bootstrap_idx)",
                    "+        estimator.fit(X_, y_)"
                ],
                "start_lineno": 1011,
                "end_lineno": 1018
            },
            {
                "hunk": [
                    "-        median_estimators = sorted_idx[np.arange(X.shape[0]), median_idx]",
                    "+        median_estimators = sorted_idx[np.arange(_num_samples(X)), median_idx]",
                    " ",
                    "         # Return median predictions",
                    "-        return predictions[np.arange(X.shape[0]), median_estimators]",
                    "+        return predictions[np.arange(_num_samples(X)), median_estimators]"
                ],
                "start_lineno": 1070,
                "end_lineno": 1073
            },
            {
                "hunk": [
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            DOK, or LIL. COO, DOK, and LIL are converted to CSR."
                ],
                "start_lineno": 1085,
                "end_lineno": 1085
            },
            {
                "hunk": [
                    "-        X = self._validate_X_predict(X)",
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 1093,
                "end_lineno": 1093
            },
            {
                "hunk": [
                    "-            The training input samples. Sparse matrix can be CSC, CSR, COO,",
                    "-            DOK, or LIL. DOK and LIL are converted to CSR.",
                    "+            The training input samples."
                ],
                "start_lineno": 1110,
                "end_lineno": 1111
            },
            {
                "hunk": [
                    "-        X = self._validate_X_predict(X)",
                    "+        X = self._validate_data(X)"
                ],
                "start_lineno": 1119,
                "end_lineno": 1119
            }
        ]
    },
    "pydata__xarray-4356": {
        "xarray/core/nanops.py": [
            {
                "hunk": [
                    "-    if hasattr(axis, \"__len__\"):  # if tuple or list",
                    "-        raise ValueError(",
                    "-            \"min_count is not available for reduction with more than one dimensions.\"",
                    "-        )",
                    " ",
                    "     if axis is not None and getattr(result, \"ndim\", False):",
                    "-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0",
                    "+        null_mask = (np.take(mask.shape, axis).prod() - mask.sum(axis) - min_count) < 0"
                ],
                "start_lineno": 29,
                "end_lineno": 35
            }
        ]
    },
    "sympy__sympy-12307": {
        "sympy/printing/fcode.py": [
            {
                "hunk": [
                    "+#issue 12267",
                    "+    def _print_sign(self,func):",
                    "+        if func.args[0].is_integer:",
                    "+            return \"merge(0, isign(1, {0}), {0} == 0)\".format(self._print(func.args[0]))",
                    "+        elif func.args[0].is_complex:",
                    "+            return \"merge(cmplx(0d0, 0d0), {0}/abs({0}), abs({0}) == 0d0)\".format(self._print(func.args[0]))",
                    "+        else:",
                    "+            return \"merge(0d0, dsign(1d0, {0}), {0} == 0d0)\".format(self._print(func.args[0]))"
                ],
                "start_lineno": 109,
                "end_lineno": 109
            }
        ]
    },
    "django__django-11905": {
        "django/db/models/lookups.py": [
            {
                "hunk": [
                    "+import warnings"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "+from django.utils.deprecation import RemovedInDjango40Warning"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "+        if not isinstance(self.rhs, bool):",
                    "+            # When the deprecation ends, replace with:",
                    "+            # raise ValueError(",
                    "+            #     'The QuerySet value for an isnull lookup must be True or '",
                    "+            #     'False.'",
                    "+            # )",
                    "+            warnings.warn(",
                    "+                'Using a non-boolean value for an isnull lookup is '",
                    "+                'deprecated, use True or False instead.',",
                    "+                RemovedInDjango40Warning,",
                    "+            )"
                ],
                "start_lineno": 466,
                "end_lineno": 466
            }
        ]
    },
    "sympy__sympy-13615": {
        "sympy/sets/sets.py": [
            {
                "hunk": [
                    "-            return FiniteSet(*[el for el in other if self.contains(el) != True])",
                    "+            from sympy.utilities.iterables import sift",
                    "+",
                    "+            def ternary_sift(el):",
                    "+                contains = self.contains(el)",
                    "+                return contains if contains in [True, False] else None",
                    "+",
                    "+            sifted = sift(other, ternary_sift)",
                    "+            # ignore those that are contained in self",
                    "+            return Union(FiniteSet(*(sifted[False])),",
                    "+                Complement(FiniteSet(*(sifted[None])), self, evaluate=False)",
                    "+                if sifted[None] else S.EmptySet)"
                ],
                "start_lineno": 220,
                "end_lineno": 220
            }
        ]
    },
    "matplotlib__matplotlib-26020": {
        "lib/mpl_toolkits/axes_grid1/axes_grid.py": [
            {
                "hunk": [
                    "+from types import MethodType"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-from .mpl_axes import Axes",
                    "+from .mpl_axes import Axes, SimpleAxisArtist",
                    " ",
                    " ",
                    " def _tick_only(ax, bottom_on, left_on):",
                    "     bottom_off = not bottom_on",
                    "     left_off = not left_on",
                    "-    ax.axis[\"bottom\"].toggle(ticklabels=bottom_off, label=bottom_off)",
                    "-    ax.axis[\"left\"].toggle(ticklabels=left_off, label=left_off)",
                    "+    if isinstance(ax.axis, MethodType):",
                    "+        bottom = SimpleAxisArtist(ax.xaxis, 1, ax.spines[\"bottom\"])",
                    "+        left = SimpleAxisArtist(ax.yaxis, 1, ax.spines[\"left\"])",
                    "+    else:",
                    "+        bottom = ax.axis[\"bottom\"]",
                    "+        left = ax.axis[\"left\"]",
                    "+    bottom.toggle(ticklabels=bottom_off, label=bottom_off)",
                    "+    left.toggle(ticklabels=left_off, label=left_off)"
                ],
                "start_lineno": 10,
                "end_lineno": 17
            }
        ]
    },
    "django__django-16067": {
        "django/core/validators.py": [
            {
                "hunk": [
                    "-            # A positive exponent adds that many trailing zeros.",
                    "-            digits = len(digit_tuple) + exponent",
                    "+            digits = len(digit_tuple)",
                    "+            if digit_tuple != (0,):",
                    "+                # A positive exponent adds that many trailing zeros.",
                    "+                digits += exponent"
                ],
                "start_lineno": 489,
                "end_lineno": 490
            }
        ]
    },
    "matplotlib__matplotlib-25960": {
        "lib/matplotlib/figure.py": [
            {
                "hunk": [
                    "-            If not given, the values will be inferred from a figure or",
                    "-            rcParams when necessary.",
                    "+            If not given, the values will be inferred from rcParams if using",
                    "+            constrained layout (see `~.ConstrainedLayoutEngine`), or zero if",
                    "+            not using a layout engine."
                ],
                "start_lineno": 1567,
                "end_lineno": 1568
            },
            {
                "hunk": [
                    "-                      height_ratios=height_ratios)",
                    "+                      height_ratios=height_ratios,",
                    "+                      left=0, right=1, bottom=0, top=1)",
                    " ",
                    "         sfarr = np.empty((nrows, ncols), dtype=object)",
                    "         for i in range(ncols):",
                    "             for j in range(nrows):",
                    "                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)",
                    " ",
                    "+        if self.get_layout_engine() is None and (wspace is not None or",
                    "+                                                 hspace is not None):",
                    "+            # Gridspec wspace and hspace is ignored on subfigure instantiation,",
                    "+            # and no space is left.  So need to account for it here if required.",
                    "+            bottoms, tops, lefts, rights = gs.get_grid_positions(self)",
                    "+            for sfrow, bottom, top in zip(sfarr, bottoms, tops):",
                    "+                for sf, left, right in zip(sfrow, lefts, rights):",
                    "+                    bbox = Bbox.from_extents(left, bottom, right, top)",
                    "+                    sf._redo_transform_rel_fig(bbox=bbox)",
                    "+"
                ],
                "start_lineno": 1583,
                "end_lineno": 1589
            }
        ]
    },
    "sympy__sympy-17022": {
        "sympy/printing/pycode.py": [
            {
                "hunk": [
                    "+    def _print_Identity(self, expr):",
                    "+        shape = expr.shape",
                    "+        if all([dim.is_Integer for dim in shape]):",
                    "+            return \"%s(%s)\" % (self._module_format('numpy.eye'), self._print(expr.shape[0]))",
                    "+        else:",
                    "+            raise NotImplementedError(\"Symbolic matrix dimensions are not yet supported for identity matrices\")",
                    "+"
                ],
                "start_lineno": 611,
                "end_lineno": 611
            }
        ]
    },
    "sympy__sympy-12171": {
        "sympy/printing/mathematica.py": [
            {
                "hunk": [
                    "+    def _print_Derivative(self, expr):",
                    "+        return \"Hold[D[\" + ', '.join(self.doprint(a) for a in expr.args) + \"]]\"",
                    "+"
                ],
                "start_lineno": 112,
                "end_lineno": 112
            }
        ]
    },
    "django__django-12517": {
        "django/utils/log.py": [
            {
                "hunk": [
                    "+    default_time_format = '%d/%b/%Y %H:%M:%S'",
                    "+"
                ],
                "start_lineno": 163,
                "end_lineno": 163
            }
        ]
    },
    "django__django-13512": {
        "django/contrib/admin/utils.py": [
            {
                "hunk": [
                    "+import json"
                ],
                "start_lineno": 3,
                "end_lineno": 3
            },
            {
                "hunk": [
                    "-            return field.get_prep_value(value)",
                    "+            return json.dumps(value, ensure_ascii=False, cls=field.encoder)"
                ],
                "start_lineno": 403,
                "end_lineno": 403
            }
        ],
        "django/forms/fields.py": [
            {
                "hunk": [
                    "-        return json.dumps(value, cls=self.encoder)",
                    "+        return json.dumps(value, ensure_ascii=False, cls=self.encoder)"
                ],
                "start_lineno": 1261,
                "end_lineno": 1261
            }
        ]
    },
    "django__django-13886": {
        "django/db/models/base.py": [
            {
                "hunk": [
                    "+        references = set()"
                ],
                "start_lineno": 1627,
                "end_lineno": 1627
            },
            {
                "hunk": [
                    "+            if index.contains_expressions:",
                    "+                for expression in index.expressions:",
                    "+                    references.update(",
                    "+                        ref[0] for ref in cls._get_expr_references(expression)",
                    "+                    )"
                ],
                "start_lineno": 1648,
                "end_lineno": 1648
            },
            {
                "hunk": [
                    "+        fields += references"
                ],
                "start_lineno": 1702,
                "end_lineno": 1702
            }
        ]
    },
    "scikit-learn__scikit-learn-26242": {
        "sklearn/ensemble/_base.py": [
            {
                "hunk": [
                    "-        elif self.base_estimator not in [None, \"deprecated\"]:",
                    "+        elif self.base_estimator != \"deprecated\":"
                ],
                "start_lineno": 160,
                "end_lineno": 160
            },
            {
                "hunk": [
                    "-            self.estimator_ = self.base_estimator",
                    "+            if self.base_estimator is not None:",
                    "+                self.estimator_ = self.base_estimator",
                    "+            else:",
                    "+                self.estimator_ = default"
                ],
                "start_lineno": 168,
                "end_lineno": 168
            }
        ],
        "sklearn/ensemble/_weight_boosting.py": [
            {
                "hunk": [
                    "-        \"base_estimator\": [HasMethods([\"fit\", \"predict\"]), StrOptions({\"deprecated\"})],",
                    "+        \"base_estimator\": [",
                    "+            HasMethods([\"fit\", \"predict\"]),",
                    "+            StrOptions({\"deprecated\"}),",
                    "+            None,",
                    "+        ],"
                ],
                "start_lineno": 67,
                "end_lineno": 67
            }
        ]
    },
    "matplotlib__matplotlib-22734": {
        "lib/matplotlib/tri/tripcolor.py": [
            {
                "hunk": [
                    "+    _api.check_isinstance((Normalize, None), norm=norm)",
                    "     if shading == 'gouraud':",
                    "         if facecolors is not None:",
                    "             raise ValueError(",
                    "                 \"shading='gouraud' can only be used when the colors \"",
                    "                 \"are specified at the points, not at the faces.\")",
                    "-        collection = TriMesh(tri, **kwargs)",
                    "-        colors = point_colors",
                    "+        collection = TriMesh(tri, alpha=alpha, array=point_colors,",
                    "+                             cmap=cmap, norm=norm, **kwargs)"
                ],
                "start_lineno": 118,
                "end_lineno": 124
            },
            {
                "hunk": [
                    "+        collection = PolyCollection(verts, alpha=alpha, array=colors,",
                    "+                                    cmap=cmap, norm=norm, **kwargs)",
                    " ",
                    "-        collection = PolyCollection(verts, **kwargs)",
                    "-",
                    "-    collection.set_alpha(alpha)",
                    "-    collection.set_array(colors)",
                    "-    _api.check_isinstance((Normalize, None), norm=norm)",
                    "-    collection.set_cmap(cmap)",
                    "-    collection.set_norm(norm)"
                ],
                "start_lineno": 139,
                "end_lineno": 146
            }
        ]
    },
    "sympy__sympy-24066": {
        "sympy/physics/units/unitsystem.py": [
            {
                "hunk": [
                    "-            fds = [self._collect_factor_and_dimension(",
                    "-                arg) for arg in expr.args]",
                    "-            return (expr.func(*(f[0] for f in fds)),",
                    "-                    *(d[1] for d in fds))",
                    "+            fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]",
                    "+            dims = [Dimension(1) if self.get_dimension_system().is_dimensionless(d[1]) else d[1] for d in fds]",
                    "+            return (expr.func(*(f[0] for f in fds)), *dims)"
                ],
                "start_lineno": 193,
                "end_lineno": 196
            }
        ]
    },
    "sphinx-doc__sphinx-10435": {
        "sphinx/writers/latex.py": [
            {
                "hunk": [
                    "-                                r'\\sphinxcode{\\sphinxupquote{')",
                    "+                                r'\\sphinxcode{\\sphinxupquote{%')",
                    "         # get consistent trailer",
                    "-        hlcode = hlcode.rstrip()[:-14]  # strip \\end{Verbatim}",
                    "+        hlcode = hlcode.rstrip()[:-15]  # strip \\n\\end{Verbatim}",
                    "         self.body.append(hlcode)",
                    "-        self.body.append('}}')",
                    "+        self.body.append('%' + CR + '}}')"
                ],
                "start_lineno": 1713,
                "end_lineno": 1717
            }
        ]
    },
    "django__django-16883": {
        "django/core/management/commands/inspectdb.py": [
            {
                "hunk": [
                    "-        def table2model(table_name):",
                    "-            return re.sub(r\"[^a-zA-Z0-9]\", \"\", table_name.title())",
                    "-"
                ],
                "start_lineno": 59,
                "end_lineno": 61
            },
            {
                "hunk": [
                    "-                model_name = table2model(table_name)",
                    "+                model_name = self.normalize_table_name(table_name)"
                ],
                "start_lineno": 128,
                "end_lineno": 128
            },
            {
                "hunk": [
                    "-                            else table2model(ref_db_table)",
                    "+                            else self.normalize_table_name(ref_db_table)"
                ],
                "start_lineno": 183,
                "end_lineno": 183
            },
            {
                "hunk": [
                    "+    def normalize_table_name(self, table_name):",
                    "+        \"\"\"Translate the table name to a Python-compatible model name.\"\"\"",
                    "+        return re.sub(r\"[^a-zA-Z0-9]\", \"\", table_name.title())",
                    "+"
                ],
                "start_lineno": 325,
                "end_lineno": 325
            }
        ]
    },
    "sympy__sympy-16221": {
        "sympy/printing/mathematica.py": [
            {
                "hunk": [
                    "+    def _print_ImmutableDenseNDimArray(self, expr):",
                    "+        return self.doprint(expr.tolist())",
                    "+",
                    "+    def _print_ImmutableSparseNDimArray(self, expr):",
                    "+        def print_string_list(string_list):",
                    "+            return '{' + ', '.join(a for a in string_list) + '}'",
                    "+",
                    "+        def to_mathematica_index(*args):",
                    "+            \"\"\"Helper function to change Python style indexing to",
                    "+            Pathematica indexing.",
                    "+",
                    "+            Python indexing (0, 1 ... n-1)",
                    "+            -> Mathematica indexing (1, 2 ... n)",
                    "+            \"\"\"",
                    "+            return tuple(i + 1 for i in args)",
                    "+",
                    "+        def print_rule(pos, val):",
                    "+            \"\"\"Helper function to print a rule of Mathematica\"\"\"",
                    "+            return '{} -> {}'.format(self.doprint(pos), self.doprint(val))",
                    "+",
                    "+        def print_data():",
                    "+            \"\"\"Helper function to print data part of Mathematica",
                    "+            sparse array.",
                    "+",
                    "+            It uses the fourth notation ``SparseArray[data,{d1,d2,\u2026}]``",
                    "+            from",
                    "+            https://reference.wolfram.com/language/ref/SparseArray.html",
                    "+",
                    "+            ``data`` must be formatted with rule.",
                    "+            \"\"\"",
                    "+            return print_string_list(",
                    "+                [print_rule(",
                    "+                    to_mathematica_index(*(expr._get_tuple_index(key))),",
                    "+                    value)",
                    "+                for key, value in sorted(expr._sparse_array.items())]",
                    "+            )",
                    "+",
                    "+        def print_dims():",
                    "+            \"\"\"Helper function to print dimensions part of Mathematica",
                    "+            sparse array.",
                    "+",
                    "+            It uses the fourth notation ``SparseArray[data,{d1,d2,\u2026}]``",
                    "+            from",
                    "+            https://reference.wolfram.com/language/ref/SparseArray.html",
                    "+            \"\"\"",
                    "+            return self.doprint(expr.shape)",
                    "+",
                    "+        return 'SparseArray[{}, {}]'.format(print_data(), print_dims())",
                    "+"
                ],
                "start_lineno": 163,
                "end_lineno": 163
            }
        ]
    },
    "scikit-learn__scikit-learn-13497": {
        "sklearn/feature_selection/mutual_info_.py": [
            {
                "hunk": [
                    "-from ..utils.validation import check_X_y",
                    "+from ..utils.validation import check_array, check_X_y"
                ],
                "start_lineno": 13,
                "end_lineno": 13
            },
            {
                "hunk": [
                    "-    if discrete_features == 'auto':",
                    "-        discrete_features = issparse(X)",
                    "-",
                    "-    if isinstance(discrete_features, bool):",
                    "+    if isinstance(discrete_features, (str, bool)):",
                    "+        if isinstance(discrete_features, str):",
                    "+            if discrete_features == 'auto':",
                    "+                discrete_features = issparse(X)",
                    "+            else:",
                    "+                raise ValueError(\"Invalid string value for discrete_features.\")",
                    "         discrete_mask = np.empty(n_features, dtype=bool)",
                    "         discrete_mask.fill(discrete_features)",
                    "     else:",
                    "-        discrete_features = np.asarray(discrete_features)",
                    "+        discrete_features = check_array(discrete_features, ensure_2d=False)"
                ],
                "start_lineno": 250,
                "end_lineno": 257
            }
        ]
    },
    "sphinx-doc__sphinx-7961": {
        "sphinx/ext/mathjax.py": [
            {
                "hunk": [
                    "-                         'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?'",
                    "-                         'config=TeX-AMS-MML_HTMLorMML', 'html')",
                    "+                         'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js',",
                    "+                         'html')"
                ],
                "start_lineno": 99,
                "end_lineno": 100
            }
        ]
    },
    "pylint-dev__pylint-6506": {
        "pylint/config/config_initialization.py": [
            {
                "hunk": [
                    "-        linter.add_message(\"unrecognized-option\", line=0, args=msg)",
                    "-        raise _UnrecognizedOptionError(options=unrecognized_options)",
                    "+        linter._arg_parser.error(f\"Unrecognized option found: {msg}\")"
                ],
                "start_lineno": 84,
                "end_lineno": 85
            }
        ]
    },
    "sympy__sympy-23534": {
        "sympy/core/symbol.py": [
            {
                "hunk": [
                    "-            result.append(symbols(name, **args))",
                    "+            result.append(symbols(name, cls=cls, **args))"
                ],
                "start_lineno": 794,
                "end_lineno": 794
            }
        ]
    },
    "django__django-14805": {
        "django/core/management/commands/makemigrations.py": [
            {
                "hunk": [
                    "-            questioner = NonInteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)",
                    "+            questioner = NonInteractiveMigrationQuestioner(",
                    "+                specified_apps=app_labels,",
                    "+                dry_run=self.dry_run,",
                    "+                verbosity=self.verbosity,",
                    "+                log=self.log,",
                    "+            )"
                ],
                "start_lineno": 149,
                "end_lineno": 149
            }
        ],
        "django/db/migrations/questioner.py": [
            {
                "hunk": [
                    "+    def __init__(",
                    "+        self, defaults=None, specified_apps=None, dry_run=None, verbosity=1,",
                    "+        log=None,",
                    "+    ):",
                    "+        self.verbosity = verbosity",
                    "+        self.log = log",
                    "+        super().__init__(",
                    "+            defaults=defaults, specified_apps=specified_apps, dry_run=dry_run,",
                    "+        )",
                    "+",
                    "+    def log_lack_of_migration(self, field_name, model_name, reason):",
                    "+        if self.verbosity > 0:",
                    "+            self.log(",
                    "+                f\"Field '{field_name}' on model '{model_name}' not migrated: \"",
                    "+                f\"{reason}.\"",
                    "+            )",
                    " ",
                    "     def ask_not_null_addition(self, field_name, model_name):",
                    "         # We can't ask the user, so act like the user aborted.",
                    "+        self.log_lack_of_migration(",
                    "+            field_name,",
                    "+            model_name,",
                    "+            'it is impossible to add a non-nullable field without specifying '",
                    "+            'a default',",
                    "+        )",
                    "         sys.exit(3)",
                    " ",
                    "     def ask_not_null_alteration(self, field_name, model_name):",
                    "         # We can't ask the user, so set as not provided.",
                    "+        self.log(",
                    "+            f\"Field '{field_name}' on model '{model_name}' given a default of \"",
                    "+            f\"NOT PROVIDED and must be corrected.\"",
                    "+        )",
                    "         return NOT_PROVIDED",
                    " ",
                    "     def ask_auto_now_add_addition(self, field_name, model_name):",
                    "         # We can't ask the user, so act like the user aborted.",
                    "+        self.log_lack_of_migration(",
                    "+            field_name,",
                    "+            model_name,",
                    "+            \"it is impossible to add a field with 'auto_now_add=True' without \"",
                    "+            \"specifying a default\",",
                    "+        )"
                ],
                "start_lineno": 261,
                "end_lineno": 271
            }
        ]
    },
    "django__django-13689": {
        "django/db/models/expressions.py": [
            {
                "hunk": [
                    "-        expression = self.expression.copy()",
                    "-        expression.output_field = self.output_field",
                    "-        return expression.get_group_by_cols(alias=alias)",
                    "+        if isinstance(self.expression, Expression):",
                    "+            expression = self.expression.copy()",
                    "+            expression.output_field = self.output_field",
                    "+            return expression.get_group_by_cols(alias=alias)",
                    "+        # For non-expressions e.g. an SQL WHERE clause, the entire",
                    "+        # `expression` must be included in the GROUP BY clause.",
                    "+        return super().get_group_by_cols()"
                ],
                "start_lineno": 918,
                "end_lineno": 920
            }
        ]
    },
    "scikit-learn__scikit-learn-15096": {
        "sklearn/model_selection/_search.py": [
            {
                "hunk": [
                    "-            self.best_estimator_ = clone(base_estimator).set_params(",
                    "-                **self.best_params_)",
                    "+            # we clone again after setting params in case some",
                    "+            # of the params are estimators as well.",
                    "+            self.best_estimator_ = clone(clone(base_estimator).set_params(",
                    "+                **self.best_params_))"
                ],
                "start_lineno": 733,
                "end_lineno": 734
            }
        ],
        "sklearn/model_selection/_validation.py": [
            {
                "hunk": [
                    "-        estimator.set_params(**parameters)",
                    "+        # clone after setting parameters in case any parameters",
                    "+        # are estimators (like pipeline steps)",
                    "+        # because pipeline doesn't clone steps in fit",
                    "+        cloned_parameters = {}",
                    "+        for k, v in parameters.items():",
                    "+            cloned_parameters[k] = clone(v, safe=False)",
                    "+",
                    "+        estimator = estimator.set_params(**cloned_parameters)"
                ],
                "start_lineno": 491,
                "end_lineno": 491
            }
        ]
    },
    "matplotlib__matplotlib-25667": {
        "lib/matplotlib/axes/_axes.py": [
            {
                "hunk": [
                    "+            Note that if *bottom* has units (e.g. datetime), *height* should be in",
                    "+            units that are a difference from the value of *bottom* (e.g. timedelta).",
                    "+",
                    "         width : float or array-like, default: 0.8",
                    "             The width(s) of the bars.",
                    " ",
                    "+            Note that if *x* has units (e.g. datetime), then *width* should be in",
                    "+            units that are a difference (e.g. timedelta) around the *x* values.",
                    "+",
                    "         bottom : float or array-like, default: 0",
                    "             The y coordinate(s) of the bottom side(s) of the bars.",
                    " ",
                    "+            Note that if *bottom* has units, then the y-axis will get a Locator and",
                    "+            Formatter appropriate for the units (e.g. dates, or categorical).",
                    "+"
                ],
                "start_lineno": 2288,
                "end_lineno": 2293
            },
            {
                "hunk": [
                    "+            # It is possible for y (bottom) to contain unit information.",
                    "+            # However, it is also possible for y=0 for the default and height",
                    "+            # to contain unit information.  This will prioritize the units of y.",
                    "             self._process_unit_info(",
                    "-                [(\"x\", x), (\"y\", height)], kwargs, convert=False)",
                    "+                [(\"x\", x), (\"y\", y), (\"y\", height)], kwargs, convert=False)",
                    "             if log:",
                    "                 self.set_yscale('log', nonpositive='clip')",
                    "         else:  # horizontal",
                    "+            # It is possible for x (left) to contain unit information.",
                    "+            # However, it is also possible for x=0 for the default and width",
                    "+            # to contain unit information.  This will prioritize the units of x.",
                    "             self._process_unit_info(",
                    "-                [(\"x\", width), (\"y\", y)], kwargs, convert=False)",
                    "+                [(\"x\", x), (\"x\", width), (\"y\", y)], kwargs, convert=False)"
                ],
                "start_lineno": 2419,
                "end_lineno": 2425
            },
            {
                "hunk": [
                    "+            Note that if *left* has units (e.g. datetime), *width* should be in",
                    "+            units that are a difference from the value of *left* (e.g. timedelta).",
                    "+",
                    "         height : float or array-like, default: 0.8",
                    "             The heights of the bars.",
                    " ",
                    "+            Note that if *y* has units (e.g. datetime), then *height* should be in",
                    "+            units that are a difference (e.g. timedelta) around the *y* values.",
                    "+",
                    "         left : float or array-like, default: 0",
                    "             The x coordinates of the left side(s) of the bars.",
                    " ",
                    "+            Note that if *left* has units, then the x-axis will get a Locator and",
                    "+            Formatter appropriate for the units (e.g. dates, or categorical).",
                    "+"
                ],
                "start_lineno": 2585,
                "end_lineno": 2590
            }
        ]
    },
    "sympy__sympy-13264": {
        "sympy/simplify/simplify.py": [
            {
                "hunk": [
                    "-from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg",
                    "+from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat"
                ],
                "start_lineno": 12,
                "end_lineno": 12
            },
            {
                "hunk": [
                    "-def simplify(expr, ratio=1.7, measure=count_ops, fu=False):",
                    "+def simplify(expr, ratio=1.7, measure=count_ops, rational=False):"
                ],
                "start_lineno": 385,
                "end_lineno": 385
            },
            {
                "hunk": [
                    "+",
                    "+    If rational=True, Floats will be recast as Rationals before simplification.",
                    "+    If rational=None, Floats will be recast as Rationals but the result will",
                    "+    be recast as Floats. If rational=False(default) then nothing will be done",
                    "+    to the Floats."
                ],
                "start_lineno": 507,
                "end_lineno": 507
            },
            {
                "hunk": [
                    "-                                measure=measure, fu=fu)",
                    "-        return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu)",
                    "+                                measure=measure, rational=rational)",
                    "+        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)"
                ],
                "start_lineno": 529,
                "end_lineno": 530
            },
            {
                "hunk": [
                    "+    # rationalize Floats",
                    "+    floats = False",
                    "+    if rational is not False and expr.has(Float):",
                    "+        floats = True",
                    "+        expr = nsimplify(expr, rational=True)",
                    "+"
                ],
                "start_lineno": 544,
                "end_lineno": 544
            },
            {
                "hunk": [
                    "-    if expr.has(TrigonometricFunction) and not fu or expr.has(",
                    "-            HyperbolicFunction):",
                    "+    if expr.has(TrigonometricFunction, HyperbolicFunction):"
                ],
                "start_lineno": 567,
                "end_lineno": 568
            },
            {
                "hunk": [
                    "+    short = shorter(short, cancel(short))"
                ],
                "start_lineno": 584,
                "end_lineno": 584
            },
            {
                "hunk": [
                    "+    # restore floats",
                    "+    if floats and rational is None:",
                    "+        expr = nfloat(expr, exponent=False)",
                    "+"
                ],
                "start_lineno": 613,
                "end_lineno": 613
            }
        ]
    },
    "django__django-16858": {
        "django/db/models/fields/json.py": [
            {
                "hunk": [
                    "+        if not prepared:",
                    "+            value = self.get_prep_value(value)"
                ],
                "start_lineno": 102,
                "end_lineno": 102
            }
        ]
    },
    "scikit-learn__scikit-learn-11235": {
        "sklearn/preprocessing/data.py": [
            {
                "hunk": [
                    "+                if not hasattr(self, 'n_samples_seen_'):",
                    "+                    self.n_samples_seen_ = X.shape[0]",
                    "+                else:",
                    "+                    self.n_samples_seen_ += X.shape[0]"
                ],
                "start_lineno": 655,
                "end_lineno": 655
            },
            {
                "hunk": [
                    "-            self.mean_, self.var_, self.n_samples_seen_ = \\",
                    "-                _incremental_mean_and_var(X, self.mean_, self.var_,",
                    "-                                          self.n_samples_seen_)",
                    "+            if not self.with_mean and not self.with_std:",
                    "+                self.mean_ = None",
                    "+                self.var_ = None",
                    "+                self.n_samples_seen_ += X.shape[0]",
                    "+            else:",
                    "+                self.mean_, self.var_, self.n_samples_seen_ = \\",
                    "+                    _incremental_mean_and_var(X, self.mean_, self.var_,",
                    "+                                              self.n_samples_seen_)"
                ],
                "start_lineno": 665,
                "end_lineno": 667
            }
        ]
    }
}