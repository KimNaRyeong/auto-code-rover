[
    {
        "rel_file_path": "django/views/debug.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/views/debug.py",
        "start": 1,
        "end": 583,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 import sys\n4 import types\n5 import warnings\n6 from pathlib import Path\n7 \n8 from django.conf import settings\n9 from django.http import Http404, HttpResponse, HttpResponseNotFound\n10 from django.template import Context, Engine, TemplateDoesNotExist\n11 from django.template.defaultfilters import pprint\n12 from django.urls import resolve\n13 from django.utils import timezone\n14 from django.utils.datastructures import MultiValueDict\n15 from django.utils.encoding import force_str\n16 from django.utils.module_loading import import_string\n17 from django.utils.regex_helper import _lazy_re_compile\n18 from django.utils.version import get_docs_version\n19 \n20 # Minimal Django templates engine to render the error templates\n21 # regardless of the project's TEMPLATES setting. Templates are\n22 # read directly from the filesystem so that the error handler\n23 # works even if the template loader is broken.\n24 DEBUG_ENGINE = Engine(\n25     debug=True,\n26     libraries={'i18n': 'django.templatetags.i18n'},\n27 )\n28 \n29 \n30 def builtin_template_path(name):\n31     \"\"\"\n32     Return a path to a builtin template.\n33 \n34     Avoid calling this function at the module level or in a class-definition\n35     because __file__ may not exist, e.g. in frozen environments.\n36     \"\"\"\n37     return Path(__file__).parent / 'templates' / name\n38 \n39 \n40 class ExceptionCycleWarning(UserWarning):\n41     pass\n42 \n43 \n44 class CallableSettingWrapper:\n45     \"\"\"\n46     Object to wrap callable appearing in settings.\n47     * Not to call in the debug page (#21345).\n48     * Not to break the debug page if the callable forbidding to set attributes\n49       (#23070).\n50     \"\"\"\n51     def __init__(self, callable_setting):\n52         self._wrapped = callable_setting\n53 \n54     def __repr__(self):\n55         return repr(self._wrapped)\n56 \n57 \n58 def technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n59     \"\"\"\n60     Create a technical server error response. The last three arguments are\n61     the values returned from sys.exc_info() and friends.\n62     \"\"\"\n63     reporter = get_exception_reporter_class(request)(request, exc_type, exc_value, tb)\n64     if request.accepts('text/html'):\n65         html = reporter.get_traceback_html()\n66         return HttpResponse(html, status=status_code, content_type='text/html')\n67     else:\n68         text = reporter.get_traceback_text()\n69         return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')\n70 \n71 \n72 @functools.lru_cache\n73 def get_default_exception_reporter_filter():\n74     # Instantiate the default filter for the first time and cache it.\n75     return import_string(settings.DEFAULT_EXCEPTION_REPORTER_FILTER)()\n76 \n77 \n78 def get_exception_reporter_filter(request):\n79     default_filter = get_default_exception_reporter_filter()\n80     return getattr(request, 'exception_reporter_filter', default_filter)\n81 \n82 \n83 def get_exception_reporter_class(request):\n84     default_exception_reporter_class = import_string(settings.DEFAULT_EXCEPTION_REPORTER)\n85     return getattr(request, 'exception_reporter_class', default_exception_reporter_class)\n86 \n87 \n88 class SafeExceptionReporterFilter:\n89     \"\"\"\n90     Use annotations made by the sensitive_post_parameters and\n91     sensitive_variables decorators to filter out sensitive information.\n92     \"\"\"\n93     cleansed_substitute = '********************'\n94     hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)\n95 \n96     def cleanse_setting(self, key, value):\n97         \"\"\"\n98         Cleanse an individual setting key/value of sensitive content. If the\n99         value is a dictionary, recursively cleanse the keys in that dictionary.\n100         \"\"\"\n101         try:\n102             is_sensitive = self.hidden_settings.search(key)\n103         except TypeError:\n104             is_sensitive = False\n105 \n106         if is_sensitive:\n107             cleansed = self.cleansed_substitute\n108         elif isinstance(value, dict):\n109             cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n110         elif isinstance(value, list):\n111             cleansed = [self.cleanse_setting('', v) for v in value]\n112         elif isinstance(value, tuple):\n113             cleansed = tuple([self.cleanse_setting('', v) for v in value])\n114         else:\n115             cleansed = value\n116 \n117         if callable(cleansed):\n118             cleansed = CallableSettingWrapper(cleansed)\n119 \n120         return cleansed\n121 \n122     def get_safe_settings(self):\n123         \"\"\"\n124         Return a dictionary of the settings module with values of sensitive\n125         settings replaced with stars (*********).\n126         \"\"\"\n127         settings_dict = {}\n128         for k in dir(settings):\n129             if k.isupper():\n130                 settings_dict[k] = self.cleanse_setting(k, getattr(settings, k))\n131         return settings_dict\n132 \n133     def get_safe_request_meta(self, request):\n134         \"\"\"\n135         Return a dictionary of request.META with sensitive values redacted.\n136         \"\"\"\n137         if not hasattr(request, 'META'):\n138             return {}\n139         return {k: self.cleanse_setting(k, v) for k, v in request.META.items()}\n140 \n141     def is_active(self, request):\n142         \"\"\"\n143         This filter is to add safety in production environments (i.e. DEBUG\n144         is False). If DEBUG is True then your site is not safe anyway.\n145         This hook is provided as a convenience to easily activate or\n146         deactivate the filter on a per request basis.\n147         \"\"\"\n148         return settings.DEBUG is False\n149 \n150     def get_cleansed_multivaluedict(self, request, multivaluedict):\n151         \"\"\"\n152         Replace the keys in a MultiValueDict marked as sensitive with stars.\n153         This mitigates leaking sensitive POST parameters if something like\n154         request.POST['nonexistent_key'] throws an exception (#21098).\n155         \"\"\"\n156         sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])\n157         if self.is_active(request) and sensitive_post_parameters:\n158             multivaluedict = multivaluedict.copy()\n159             for param in sensitive_post_parameters:\n160                 if param in multivaluedict:\n161                     multivaluedict[param] = self.cleansed_substitute\n162         return multivaluedict\n163 \n164     def get_post_parameters(self, request):\n165         \"\"\"\n166         Replace the values of POST parameters marked as sensitive with\n167         stars (*********).\n168         \"\"\"\n169         if request is None:\n170             return {}\n171         else:\n172             sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])\n173             if self.is_active(request) and sensitive_post_parameters:\n174                 cleansed = request.POST.copy()\n175                 if sensitive_post_parameters == '__ALL__':\n176                     # Cleanse all parameters.\n177                     for k in cleansed:\n178                         cleansed[k] = self.cleansed_substitute\n179                     return cleansed\n180                 else:\n181                     # Cleanse only the specified parameters.\n182                     for param in sensitive_post_parameters:\n183                         if param in cleansed:\n184                             cleansed[param] = self.cleansed_substitute\n185                     return cleansed\n186             else:\n187                 return request.POST\n188 \n189     def cleanse_special_types(self, request, value):\n190         try:\n191             # If value is lazy or a complex object of another kind, this check\n192             # might raise an exception. isinstance checks that lazy\n193             # MultiValueDicts will have a return value.\n194             is_multivalue_dict = isinstance(value, MultiValueDict)\n195         except Exception as e:\n196             return '{!r} while evaluating {!r}'.format(e, value)\n197 \n198         if is_multivalue_dict:\n199             # Cleanse MultiValueDicts (request.POST is the one we usually care about)\n200             value = self.get_cleansed_multivaluedict(request, value)\n201         return value\n202 \n203     def get_traceback_frame_variables(self, request, tb_frame):\n204         \"\"\"\n205         Replace the values of variables marked as sensitive with\n206         stars (*********).\n207         \"\"\"\n208         # Loop through the frame's callers to see if the sensitive_variables\n209         # decorator was used.\n210         current_frame = tb_frame.f_back\n211         sensitive_variables = None\n212         while current_frame is not None:\n213             if (current_frame.f_code.co_name == 'sensitive_variables_wrapper' and\n214                     'sensitive_variables_wrapper' in current_frame.f_locals):\n215                 # The sensitive_variables decorator was used, so we take note\n216                 # of the sensitive variables' names.\n217                 wrapper = current_frame.f_locals['sensitive_variables_wrapper']\n218                 sensitive_variables = getattr(wrapper, 'sensitive_variables', None)\n219                 break\n220             current_frame = current_frame.f_back\n221 \n222         cleansed = {}\n223         if self.is_active(request) and sensitive_variables:\n224             if sensitive_variables == '__ALL__':\n225                 # Cleanse all variables\n226                 for name in tb_frame.f_locals:\n227                     cleansed[name] = self.cleansed_substitute\n228             else:\n229                 # Cleanse specified variables\n230                 for name, value in tb_frame.f_locals.items():\n231                     if name in sensitive_variables:\n232                         value = self.cleansed_substitute\n233                     else:\n234                         value = self.cleanse_special_types(request, value)\n235                     cleansed[name] = value\n236         else:\n237             # Potentially cleanse the request and any MultiValueDicts if they\n238             # are one of the frame variables.\n239             for name, value in tb_frame.f_locals.items():\n240                 cleansed[name] = self.cleanse_special_types(request, value)\n241 \n242         if (tb_frame.f_code.co_name == 'sensitive_variables_wrapper' and\n243                 'sensitive_variables_wrapper' in tb_frame.f_locals):\n244             # For good measure, obfuscate the decorated function's arguments in\n245             # the sensitive_variables decorator's frame, in case the variables\n246             # associated with those arguments were meant to be obfuscated from\n247             # the decorated function's frame.\n248             cleansed['func_args'] = self.cleansed_substitute\n249             cleansed['func_kwargs'] = self.cleansed_substitute\n250 \n251         return cleansed.items()\n252 \n253 \n254 class ExceptionReporter:\n255     \"\"\"Organize and coordinate reporting on exceptions.\"\"\"\n256 \n257     @property\n258     def html_template_path(self):\n259         return builtin_template_path('technical_500.html')\n260 \n261     @property\n262     def text_template_path(self):\n263         return builtin_template_path('technical_500.txt')\n264 \n265     def __init__(self, request, exc_type, exc_value, tb, is_email=False):\n266         self.request = request\n267         self.filter = get_exception_reporter_filter(self.request)\n268         self.exc_type = exc_type\n269         self.exc_value = exc_value\n270         self.tb = tb\n271         self.is_email = is_email\n272 \n273         self.template_info = getattr(self.exc_value, 'template_debug', None)\n274         self.template_does_not_exist = False\n275         self.postmortem = None\n276 \n277     def _get_raw_insecure_uri(self):\n278         \"\"\"\n279         Return an absolute URI from variables available in this request. Skip\n280         allowed hosts protection, so may return insecure URI.\n281         \"\"\"\n282         return '{scheme}://{host}{path}'.format(\n283             scheme=self.request.scheme,\n284             host=self.request._get_raw_host(),\n285             path=self.request.get_full_path(),\n286         )\n287 \n288     def get_traceback_data(self):\n289         \"\"\"Return a dictionary containing traceback information.\"\"\"\n290         if self.exc_type and issubclass(self.exc_type, TemplateDoesNotExist):\n291             self.template_does_not_exist = True\n292             self.postmortem = self.exc_value.chain or [self.exc_value]\n293 \n294         frames = self.get_traceback_frames()\n295         for i, frame in enumerate(frames):\n296             if 'vars' in frame:\n297                 frame_vars = []\n298                 for k, v in frame['vars']:\n299                     v = pprint(v)\n300                     # Trim large blobs of data\n301                     if len(v) > 4096:\n302                         v = '%s\u2026 <trimmed %d bytes string>' % (v[0:4096], len(v))\n303                     frame_vars.append((k, v))\n304                 frame['vars'] = frame_vars\n305             frames[i] = frame\n306 \n307         unicode_hint = ''\n308         if self.exc_type and issubclass(self.exc_type, UnicodeError):\n309             start = getattr(self.exc_value, 'start', None)\n310             end = getattr(self.exc_value, 'end', None)\n311             if start is not None and end is not None:\n312                 unicode_str = self.exc_value.args[1]\n313                 unicode_hint = force_str(\n314                     unicode_str[max(start - 5, 0):min(end + 5, len(unicode_str))],\n315                     'ascii', errors='replace'\n316                 )\n317         from django import get_version\n318 \n319         if self.request is None:\n320             user_str = None\n321         else:\n322             try:\n323                 user_str = str(self.request.user)\n324             except Exception:\n325                 # request.user may raise OperationalError if the database is\n326                 # unavailable, for example.\n327                 user_str = '[unable to retrieve the current user]'\n328 \n329         c = {\n330             'is_email': self.is_email,\n331             'unicode_hint': unicode_hint,\n332             'frames': frames,\n333             'request': self.request,\n334             'request_meta': self.filter.get_safe_request_meta(self.request),\n335             'user_str': user_str,\n336             'filtered_POST_items': list(self.filter.get_post_parameters(self.request).items()),\n337             'settings': self.filter.get_safe_settings(),\n338             'sys_executable': sys.executable,\n339             'sys_version_info': '%d.%d.%d' % sys.version_info[0:3],\n340             'server_time': timezone.now(),\n341             'django_version_info': get_version(),\n342             'sys_path': sys.path,\n343             'template_info': self.template_info,\n344             'template_does_not_exist': self.template_does_not_exist,\n345             'postmortem': self.postmortem,\n346         }\n347         if self.request is not None:\n348             c['request_GET_items'] = self.request.GET.items()\n349             c['request_FILES_items'] = self.request.FILES.items()\n350             c['request_COOKIES_items'] = self.request.COOKIES.items()\n351             c['request_insecure_uri'] = self._get_raw_insecure_uri()\n352 \n353         # Check whether exception info is available\n354         if self.exc_type:\n355             c['exception_type'] = self.exc_type.__name__\n356         if self.exc_value:\n357             c['exception_value'] = str(self.exc_value)\n358         if frames:\n359             c['lastframe'] = frames[-1]\n360         return c\n361 \n362     def get_traceback_html(self):\n363         \"\"\"Return HTML version of debug 500 HTTP error page.\"\"\"\n364         with self.html_template_path.open(encoding='utf-8') as fh:\n365             t = DEBUG_ENGINE.from_string(fh.read())\n366         c = Context(self.get_traceback_data(), use_l10n=False)\n367         return t.render(c)\n368 \n369     def get_traceback_text(self):\n370         \"\"\"Return plain text version of debug 500 HTTP error page.\"\"\"\n371         with self.text_template_path.open(encoding='utf-8') as fh:\n372             t = DEBUG_ENGINE.from_string(fh.read())\n373         c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)\n374         return t.render(c)\n375 \n376     def _get_source(self, filename, loader, module_name):\n377         source = None\n378         if hasattr(loader, 'get_source'):\n379             try:\n380                 source = loader.get_source(module_name)\n381             except ImportError:\n382                 pass\n383             if source is not None:\n384                 source = source.splitlines()\n385         if source is None:\n386             try:\n387                 with open(filename, 'rb') as fp:\n388                     source = fp.read().splitlines()\n389             except OSError:\n390                 pass\n391         return source\n392 \n393     def _get_lines_from_file(self, filename, lineno, context_lines, loader=None, module_name=None):\n394         \"\"\"\n395         Return context_lines before and after lineno from file.\n396         Return (pre_context_lineno, pre_context, context_line, post_context).\n397         \"\"\"\n398         source = self._get_source(filename, loader, module_name)\n399         if source is None:\n400             return None, [], None, []\n401 \n402         # If we just read the source from a file, or if the loader did not\n403         # apply tokenize.detect_encoding to decode the source into a\n404         # string, then we should do that ourselves.\n405         if isinstance(source[0], bytes):\n406             encoding = 'ascii'\n407             for line in source[:2]:\n408                 # File coding may be specified. Match pattern from PEP-263\n409                 # (https://www.python.org/dev/peps/pep-0263/)\n410                 match = re.search(br'coding[:=]\\s*([-\\w.]+)', line)\n411                 if match:\n412                     encoding = match[1].decode('ascii')\n413                     break\n414             source = [str(sline, encoding, 'replace') for sline in source]\n415 \n416         lower_bound = max(0, lineno - context_lines)\n417         upper_bound = lineno + context_lines\n418 \n419         try:\n420             pre_context = source[lower_bound:lineno]\n421             context_line = source[lineno]\n422             post_context = source[lineno + 1:upper_bound]\n423         except IndexError:\n424             return None, [], None, []\n425         return lower_bound, pre_context, context_line, post_context\n426 \n427     def _get_explicit_or_implicit_cause(self, exc_value):\n428         explicit = getattr(exc_value, '__cause__', None)\n429         suppress_context = getattr(exc_value, '__suppress_context__', None)\n430         implicit = getattr(exc_value, '__context__', None)\n431         return explicit or (None if suppress_context else implicit)\n432 \n433     def get_traceback_frames(self):\n434         # Get the exception and all its causes\n435         exceptions = []\n436         exc_value = self.exc_value\n437         while exc_value:\n438             exceptions.append(exc_value)\n439             exc_value = self._get_explicit_or_implicit_cause(exc_value)\n440             if exc_value in exceptions:\n441                 warnings.warn(\n442                     \"Cycle in the exception chain detected: exception '%s' \"\n443                     \"encountered again.\" % exc_value,\n444                     ExceptionCycleWarning,\n445                 )\n446                 # Avoid infinite loop if there's a cyclic reference (#29393).\n447                 break\n448 \n449         frames = []\n450         # No exceptions were supplied to ExceptionReporter\n451         if not exceptions:\n452             return frames\n453 \n454         # In case there's just one exception, take the traceback from self.tb\n455         exc_value = exceptions.pop()\n456         tb = self.tb if not exceptions else exc_value.__traceback__\n457         while True:\n458             frames.extend(self.get_exception_traceback_frames(exc_value, tb))\n459             try:\n460                 exc_value = exceptions.pop()\n461             except IndexError:\n462                 break\n463             tb = exc_value.__traceback__\n464         return frames\n465 \n466     def get_exception_traceback_frames(self, exc_value, tb):\n467         exc_cause = self._get_explicit_or_implicit_cause(exc_value)\n468         exc_cause_explicit = getattr(exc_value, '__cause__', True)\n469         if tb is None:\n470             yield {\n471                 'exc_cause': exc_cause,\n472                 'exc_cause_explicit': exc_cause_explicit,\n473                 'tb': None,\n474                 'type': 'user',\n475             }\n476         while tb is not None:\n477             # Support for __traceback_hide__ which is used by a few libraries\n478             # to hide internal frames.\n479             if tb.tb_frame.f_locals.get('__traceback_hide__'):\n480                 tb = tb.tb_next\n481                 continue\n482             filename = tb.tb_frame.f_code.co_filename\n483             function = tb.tb_frame.f_code.co_name\n484             lineno = tb.tb_lineno - 1\n485             loader = tb.tb_frame.f_globals.get('__loader__')\n486             module_name = tb.tb_frame.f_globals.get('__name__') or ''\n487             pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(\n488                 filename, lineno, 7, loader, module_name,\n489             )\n490             if pre_context_lineno is None:\n491                 pre_context_lineno = lineno\n492                 pre_context = []\n493                 context_line = '<source code not available>'\n494                 post_context = []\n495             yield {\n496                 'exc_cause': exc_cause,\n497                 'exc_cause_explicit': exc_cause_explicit,\n498                 'tb': tb,\n499                 'type': 'django' if module_name.startswith('django.') else 'user',\n500                 'filename': filename,\n501                 'function': function,\n502                 'lineno': lineno + 1,\n503                 'vars': self.filter.get_traceback_frame_variables(self.request, tb.tb_frame),\n504                 'id': id(tb),\n505                 'pre_context': pre_context,\n506                 'context_line': context_line,\n507                 'post_context': post_context,\n508                 'pre_context_lineno': pre_context_lineno + 1,\n509             }\n510             tb = tb.tb_next\n511 \n512 \n513 def technical_404_response(request, exception):\n514     \"\"\"Create a technical 404 error response. `exception` is the Http404.\"\"\"\n515     try:\n516         error_url = exception.args[0]['path']\n517     except (IndexError, TypeError, KeyError):\n518         error_url = request.path_info[1:]  # Trim leading slash\n519 \n520     try:\n521         tried = exception.args[0]['tried']\n522     except (IndexError, TypeError, KeyError):\n523         resolved = True\n524         tried = request.resolver_match.tried if request.resolver_match else None\n525     else:\n526         resolved = False\n527         if (not tried or (                  # empty URLconf\n528             request.path == '/' and\n529             len(tried) == 1 and             # default URLconf\n530             len(tried[0]) == 1 and\n531             getattr(tried[0][0], 'app_name', '') == getattr(tried[0][0], 'namespace', '') == 'admin'\n532         )):\n533             return default_urlconf(request)\n534 \n535     urlconf = getattr(request, 'urlconf', settings.ROOT_URLCONF)\n536     if isinstance(urlconf, types.ModuleType):\n537         urlconf = urlconf.__name__\n538 \n539     caller = ''\n540     try:\n541         resolver_match = resolve(request.path)\n542     except Http404:\n543         pass\n544     else:\n545         obj = resolver_match.func\n546 \n547         if hasattr(obj, 'view_class'):\n548             caller = obj.view_class\n549         elif hasattr(obj, '__name__'):\n550             caller = obj.__name__\n551         elif hasattr(obj, '__class__') and hasattr(obj.__class__, '__name__'):\n552             caller = obj.__class__.__name__\n553 \n554         if hasattr(obj, '__module__'):\n555             module = obj.__module__\n556             caller = '%s.%s' % (module, caller)\n557 \n558     with builtin_template_path('technical_404.html').open(encoding='utf-8') as fh:\n559         t = DEBUG_ENGINE.from_string(fh.read())\n560     reporter_filter = get_default_exception_reporter_filter()\n561     c = Context({\n562         'urlconf': urlconf,\n563         'root_urlconf': settings.ROOT_URLCONF,\n564         'request_path': error_url,\n565         'urlpatterns': tried,\n566         'resolved': resolved,\n567         'reason': str(exception),\n568         'request': request,\n569         'settings': reporter_filter.get_safe_settings(),\n570         'raising_view_name': caller,\n571     })\n572     return HttpResponseNotFound(t.render(c), content_type='text/html')\n573 \n574 \n575 def default_urlconf(request):\n576     \"\"\"Create an empty URLconf 404 error response.\"\"\"\n577     with builtin_template_path('default_urlconf.html').open(encoding='utf-8') as fh:\n578         t = DEBUG_ENGINE.from_string(fh.read())\n579     c = Context({\n580         'version': get_docs_version(),\n581     })\n582 \n583     return HttpResponse(t.render(c), content_type='text/html')\n",
        "intended_behavior": "This file likely contains functionality for rendering technical debug information, including the 'Raised by' section of 404 pages. The intended behavior here is to ensure that when class-based views (CBVs) are reported in the 'Raised by' section, they are displayed using their proper Python path ('app.views.ViewName') instead of the '<class 'app.views.ViewName'>' format. This might involve adjusting how the view class is converted to a string in the context of error reporting, ensuring that it checks if the object is a class and uses its '__module__.__name__' attributes instead of a direct 'str()' conversion or similar mechanism that leads to the class representation issue."
    },
    {
        "rel_file_path": "django/core/handlers/exception.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/handlers/exception.py",
        "start": 1,
        "end": 149,
        "class_name": null,
        "method_name": null,
        "code": "1 import asyncio\n2 import logging\n3 import sys\n4 from functools import wraps\n5 \n6 from asgiref.sync import sync_to_async\n7 \n8 from django.conf import settings\n9 from django.core import signals\n10 from django.core.exceptions import (\n11     BadRequest, PermissionDenied, RequestDataTooBig, SuspiciousOperation,\n12     TooManyFieldsSent,\n13 )\n14 from django.http import Http404\n15 from django.http.multipartparser import MultiPartParserError\n16 from django.urls import get_resolver, get_urlconf\n17 from django.utils.log import log_response\n18 from django.views import debug\n19 \n20 \n21 def convert_exception_to_response(get_response):\n22     \"\"\"\n23     Wrap the given get_response callable in exception-to-response conversion.\n24 \n25     All exceptions will be converted. All known 4xx exceptions (Http404,\n26     PermissionDenied, MultiPartParserError, SuspiciousOperation) will be\n27     converted to the appropriate response, and all other exceptions will be\n28     converted to 500 responses.\n29 \n30     This decorator is automatically applied to all middleware to ensure that\n31     no middleware leaks an exception and that the next middleware in the stack\n32     can rely on getting a response instead of an exception.\n33     \"\"\"\n34     if asyncio.iscoroutinefunction(get_response):\n35         @wraps(get_response)\n36         async def inner(request):\n37             try:\n38                 response = await get_response(request)\n39             except Exception as exc:\n40                 response = await sync_to_async(response_for_exception, thread_sensitive=False)(request, exc)\n41             return response\n42         return inner\n43     else:\n44         @wraps(get_response)\n45         def inner(request):\n46             try:\n47                 response = get_response(request)\n48             except Exception as exc:\n49                 response = response_for_exception(request, exc)\n50             return response\n51         return inner\n52 \n53 \n54 def response_for_exception(request, exc):\n55     if isinstance(exc, Http404):\n56         if settings.DEBUG:\n57             response = debug.technical_404_response(request, exc)\n58         else:\n59             response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)\n60 \n61     elif isinstance(exc, PermissionDenied):\n62         response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)\n63         log_response(\n64             'Forbidden (Permission denied): %s', request.path,\n65             response=response,\n66             request=request,\n67             exc_info=sys.exc_info(),\n68         )\n69 \n70     elif isinstance(exc, MultiPartParserError):\n71         response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n72         log_response(\n73             'Bad request (Unable to parse request body): %s', request.path,\n74             response=response,\n75             request=request,\n76             exc_info=sys.exc_info(),\n77         )\n78 \n79     elif isinstance(exc, BadRequest):\n80         if settings.DEBUG:\n81             response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n82         else:\n83             response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n84         log_response(\n85             '%s: %s', str(exc), request.path,\n86             response=response,\n87             request=request,\n88             exc_info=sys.exc_info(),\n89         )\n90     elif isinstance(exc, SuspiciousOperation):\n91         if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):\n92             # POST data can't be accessed again, otherwise the original\n93             # exception would be raised.\n94             request._mark_post_parse_error()\n95 \n96         # The request logger receives events for any problematic request\n97         # The security logger receives events for all SuspiciousOperations\n98         security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)\n99         security_logger.error(\n100             str(exc),\n101             extra={'status_code': 400, 'request': request},\n102         )\n103         if settings.DEBUG:\n104             response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)\n105         else:\n106             response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)\n107 \n108     else:\n109         signals.got_request_exception.send(sender=None, request=request)\n110         response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())\n111         log_response(\n112             '%s: %s', response.reason_phrase, request.path,\n113             response=response,\n114             request=request,\n115             exc_info=sys.exc_info(),\n116         )\n117 \n118     # Force a TemplateResponse to be rendered.\n119     if not getattr(response, 'is_rendered', True) and callable(getattr(response, 'render', None)):\n120         response = response.render()\n121 \n122     return response\n123 \n124 \n125 def get_exception_response(request, resolver, status_code, exception):\n126     try:\n127         callback = resolver.resolve_error_handler(status_code)\n128         response = callback(request, exception=exception)\n129     except Exception:\n130         signals.got_request_exception.send(sender=None, request=request)\n131         response = handle_uncaught_exception(request, resolver, sys.exc_info())\n132 \n133     return response\n134 \n135 \n136 def handle_uncaught_exception(request, resolver, exc_info):\n137     \"\"\"\n138     Processing for any otherwise uncaught exceptions (those that will\n139     generate HTTP 500 responses).\n140     \"\"\"\n141     if settings.DEBUG_PROPAGATE_EXCEPTIONS:\n142         raise\n143 \n144     if settings.DEBUG:\n145         return debug.technical_500_response(request, *exc_info)\n146 \n147     # Return an HttpResponse that displays a friendly error message.\n148     callback = resolver.resolve_error_handler(500)\n149     return callback(request)\n",
        "intended_behavior": "This file is responsible for handling exceptions and generating error pages. The code here should ensure that when an exception involves a CBV, the view's name is accurately formatted in the error report. The adjustment needed could be similar to the one in 'debug.py', focusing on proper identification and representation of class-based views within exceptions. The goal is to preserve the functionality of detailed error reporting while correcting the display of CBV names in error contexts, adhering to a more readable and consistent format."
    }
]