[
    {
        "rel_file_path": "sympy/core/mul.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/core/mul.py",
        "start": 1,
        "end": 1764,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 from functools import cmp_to_key\n5 import operator\n6 \n7 from .sympify import sympify\n8 from .basic import Basic\n9 from .singleton import S\n10 from .operations import AssocOp\n11 from .cache import cacheit\n12 from .logic import fuzzy_not, _fuzzy_group\n13 from .compatibility import reduce, range\n14 from .expr import Expr\n15 \n16 # internal marker to indicate:\n17 #   \"there are still non-commutative objects -- don't forget to process them\"\n18 \n19 \n20 class NC_Marker:\n21     is_Order = False\n22     is_Mul = False\n23     is_Number = False\n24     is_Poly = False\n25 \n26     is_commutative = False\n27 \n28 \n29 # Key for sorting commutative args in canonical order\n30 _args_sortkey = cmp_to_key(Basic.compare)\n31 def _mulsort(args):\n32     # in-place sorting of args\n33     args.sort(key=_args_sortkey)\n34 \n35 \n36 def _unevaluated_Mul(*args):\n37     \"\"\"Return a well-formed unevaluated Mul: Numbers are collected and\n38     put in slot 0, any arguments that are Muls will be flattened, and args\n39     are sorted. Use this when args have changed but you still want to return\n40     an unevaluated Mul.\n41 \n42     Examples\n43     ========\n44 \n45     >>> from sympy.core.mul import _unevaluated_Mul as uMul\n46     >>> from sympy import S, sqrt, Mul\n47     >>> from sympy.abc import x\n48     >>> a = uMul(*[S(3.0), x, S(2)])\n49     >>> a.args[0]\n50     6.00000000000000\n51     >>> a.args[1]\n52     x\n53 \n54     Two unevaluated Muls with the same arguments will\n55     always compare as equal during testing:\n56 \n57     >>> m = uMul(sqrt(2), sqrt(3))\n58     >>> m == uMul(sqrt(3), sqrt(2))\n59     True\n60     >>> u = Mul(sqrt(3), sqrt(2), evaluate=False)\n61     >>> m == uMul(u)\n62     True\n63     >>> m == Mul(*m.args)\n64     False\n65 \n66     \"\"\"\n67     args = list(args)\n68     newargs = []\n69     ncargs = []\n70     co = S.One\n71     while args:\n72         a = args.pop()\n73         if a.is_Mul:\n74             c, nc = a.args_cnc()\n75             args.extend(c)\n76             if nc:\n77                 ncargs.append(Mul._from_args(nc))\n78         elif a.is_Number:\n79             co *= a\n80         else:\n81             newargs.append(a)\n82     _mulsort(newargs)\n83     if co is not S.One:\n84         newargs.insert(0, co)\n85     if ncargs:\n86         newargs.append(Mul._from_args(ncargs))\n87     return Mul._from_args(newargs)\n88 \n89 \n90 class Mul(Expr, AssocOp):\n91 \n92     __slots__ = []\n93 \n94     is_Mul = True\n95 \n96     @classmethod\n97     def flatten(cls, seq):\n98         \"\"\"Return commutative, noncommutative and order arguments by\n99         combining related terms.\n100 \n101         Notes\n102         =====\n103             * In an expression like ``a*b*c``, python process this through sympy\n104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.\n105 \n106               -  Sometimes terms are not combined as one would like:\n107                  {c.f. https://github.com/sympy/sympy/issues/4596}\n108 \n109                 >>> from sympy import Mul, sqrt\n110                 >>> from sympy.abc import x, y, z\n111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior\n112                 2*x + 2\n113                 >>> y*(x + 1)*2\n114                 2*y*(x + 1)\n115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first\n116                 y*(2*x + 2)\n117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n118                 2*y*(x + 1)\n119                 >>> 2*((x + 1)*y) # parentheses can control this behavior\n120                 2*y*(x + 1)\n121 \n122                 Powers with compound bases may not find a single base to\n123                 combine with unless all arguments are processed at once.\n124                 Post-processing may be necessary in such cases.\n125                 {c.f. https://github.com/sympy/sympy/issues/5728}\n126 \n127                 >>> a = sqrt(x*sqrt(y))\n128                 >>> a**3\n129                 (x*sqrt(y))**(3/2)\n130                 >>> Mul(a,a,a)\n131                 (x*sqrt(y))**(3/2)\n132                 >>> a*a*a\n133                 x*sqrt(y)*sqrt(x*sqrt(y))\n134                 >>> _.subs(a.base, z).subs(z, a.base)\n135                 (x*sqrt(y))**(3/2)\n136 \n137               -  If more than two terms are being multiplied then all the\n138                  previous terms will be re-processed for each new argument.\n139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`\n140                  expression, then ``a*b*c`` (or building up the product\n141                  with ``*=``) will process all the arguments of ``a`` and\n142                  ``b`` twice: once when ``a*b`` is computed and again when\n143                  ``c`` is multiplied.\n144 \n145                  Using ``Mul(a, b, c)`` will process all arguments once.\n146 \n147             * The results of Mul are cached according to arguments, so flatten\n148               will only be called once for ``Mul(a, b, c)``. If you can\n149               structure a calculation so the arguments are most likely to be\n150               repeats then this can save time in computing the answer. For\n151               example, say you had a Mul, M, that you wished to divide by ``d[i]``\n152               and multiply by ``n[i]`` and you suspect there are many repeats\n153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather\n154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the\n155               product, ``M*n[i]`` will be returned without flattening -- the\n156               cached value will be returned. If you divide by the ``d[i]``\n157               first (and those are more unique than the ``n[i]``) then that will\n158               create a new Mul, ``M/d[i]`` the args of which will be traversed\n159               again when it is multiplied by ``n[i]``.\n160 \n161               {c.f. https://github.com/sympy/sympy/issues/5706}\n162 \n163               This consideration is moot if the cache is turned off.\n164 \n165             NB\n166             --\n167               The validity of the above notes depends on the implementation\n168               details of Mul and flatten which may change at any time. Therefore,\n169               you should only consider them when your code is highly performance\n170               sensitive.\n171 \n172               Removal of 1 from the sequence is already handled by AssocOp.__new__.\n173         \"\"\"\n174 \n175         from sympy.calculus.util import AccumBounds\n176         rv = None\n177         if len(seq) == 2:\n178             a, b = seq\n179             if b.is_Rational:\n180                 a, b = b, a\n181             assert not a is S.One\n182             if not a.is_zero and a.is_Rational:\n183                 r, b = b.as_coeff_Mul()\n184                 if b.is_Add:\n185                     if r is not S.One:  # 2-arg hack\n186                         # leave the Mul as a Mul\n187                         rv = [cls(a*r, b, evaluate=False)], [], None\n188                     elif b.is_commutative:\n189                         if a is S.One:\n190                             rv = [b], [], None\n191                         else:\n192                             r, b = b.as_coeff_Add()\n193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n194                             _addsort(bargs)\n195                             ar = a*r\n196                             if ar:\n197                                 bargs.insert(0, ar)\n198                             bargs = [Add._from_args(bargs)]\n199                             rv = bargs, [], None\n200             if rv:\n201                 return rv\n202 \n203         # apply associativity, separate commutative part of seq\n204         c_part = []         # out: commutative factors\n205         nc_part = []        # out: non-commutative factors\n206 \n207         nc_seq = []\n208 \n209         coeff = S.One       # standalone term\n210                             # e.g. 3 * ...\n211 \n212         c_powers = []       # (base,exp)      n\n213                             # e.g. (x,n) for x\n214 \n215         num_exp = []        # (num-base, exp)           y\n216                             # e.g.  (3, y)  for  ... * 3  * ...\n217 \n218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I\n219 \n220         pnum_rat = {}       # (num-base, Rat-exp)          1/2\n221                             # e.g.  (3, 1/2)  for  ... * 3     * ...\n222 \n223         order_symbols = None\n224 \n225         # --- PART 1 ---\n226         #\n227         # \"collect powers and coeff\":\n228         #\n229         # o coeff\n230         # o c_powers\n231         # o num_exp\n232         # o neg1e\n233         # o pnum_rat\n234         #\n235         # NOTE: this is optimized for all-objects-are-commutative case\n236         for o in seq:\n237             # O(x)\n238             if o.is_Order:\n239                 o, order_symbols = o.as_expr_variables(order_symbols)\n240 \n241             # Mul([...])\n242             if o.is_Mul:\n243                 if o.is_commutative:\n244                     seq.extend(o.args)    # XXX zerocopy?\n245 \n246                 else:\n247                     # NCMul can have commutative parts as well\n248                     for q in o.args:\n249                         if q.is_commutative:\n250                             seq.append(q)\n251                         else:\n252                             nc_seq.append(q)\n253 \n254                     # append non-commutative marker, so we don't forget to\n255                     # process scheduled non-commutative objects\n256                     seq.append(NC_Marker)\n257 \n258                 continue\n259 \n260             # 3\n261             elif o.is_Number:\n262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:\n263                     # we know for sure the result will be nan\n264                     return [S.NaN], [], None\n265                 elif coeff.is_Number:  # it could be zoo\n266                     coeff *= o\n267                     if coeff is S.NaN:\n268                         # we know for sure the result will be nan\n269                         return [S.NaN], [], None\n270                 continue\n271 \n272             elif isinstance(o, AccumBounds):\n273                 coeff = o.__mul__(coeff)\n274                 continue\n275 \n276             elif o is S.ComplexInfinity:\n277                 if not coeff:\n278                     # 0 * zoo = NaN\n279                     return [S.NaN], [], None\n280                 if coeff is S.ComplexInfinity:\n281                     # zoo * zoo = zoo\n282                     return [S.ComplexInfinity], [], None\n283                 coeff = S.ComplexInfinity\n284                 continue\n285 \n286             elif o is S.ImaginaryUnit:\n287                 neg1e += S.Half\n288                 continue\n289 \n290             elif o.is_commutative:\n291                 #      e\n292                 # o = b\n293                 b, e = o.as_base_exp()\n294 \n295                 #  y\n296                 # 3\n297                 if o.is_Pow:\n298                     if b.is_Number:\n299 \n300                         # get all the factors with numeric base so they can be\n301                         # combined below, but don't combine negatives unless\n302                         # the exponent is an integer\n303                         if e.is_Rational:\n304                             if e.is_Integer:\n305                                 coeff *= Pow(b, e)  # it is an unevaluated power\n306                                 continue\n307                             elif e.is_negative:    # also a sign of an unevaluated power\n308                                 seq.append(Pow(b, e))\n309                                 continue\n310                             elif b.is_negative:\n311                                 neg1e += e\n312                                 b = -b\n313                             if b is not S.One:\n314                                 pnum_rat.setdefault(b, []).append(e)\n315                             continue\n316                         elif b.is_positive or e.is_integer:\n317                             num_exp.append((b, e))\n318                             continue\n319 \n320                     elif b is S.ImaginaryUnit and e.is_Rational:\n321                         neg1e += e/2\n322                         continue\n323 \n324                 c_powers.append((b, e))\n325 \n326             # NON-COMMUTATIVE\n327             # TODO: Make non-commutative exponents not combine automatically\n328             else:\n329                 if o is not NC_Marker:\n330                     nc_seq.append(o)\n331 \n332                 # process nc_seq (if any)\n333                 while nc_seq:\n334                     o = nc_seq.pop(0)\n335                     if not nc_part:\n336                         nc_part.append(o)\n337                         continue\n338 \n339                     #                             b    c       b+c\n340                     # try to combine last terms: a  * a   ->  a\n341                     o1 = nc_part.pop()\n342                     b1, e1 = o1.as_base_exp()\n343                     b2, e2 = o.as_base_exp()\n344                     new_exp = e1 + e2\n345                     # Only allow powers to combine if the new exponent is\n346                     # not an Add. This allow things like a**2*b**3 == a**5\n347                     # if a.is_commutative == False, but prohibits\n348                     # a**x*a**y and x**a*x**b from combining (x,y commute).\n349                     if b1 == b2 and (not new_exp.is_Add):\n350                         o12 = b1 ** new_exp\n351 \n352                         # now o12 could be a commutative object\n353                         if o12.is_commutative:\n354                             seq.append(o12)\n355                             continue\n356                         else:\n357                             nc_seq.insert(0, o12)\n358 \n359                     else:\n360                         nc_part.append(o1)\n361                         nc_part.append(o)\n362 \n363         # We do want a combined exponent if it would not be an Add, such as\n364         #  y    2y     3y\n365         # x  * x   -> x\n366         # We determine if two exponents have the same term by using\n367         # as_coeff_Mul.\n368         #\n369         # Unfortunately, this isn't smart enough to consider combining into\n370         # exponents that might already be adds, so things like:\n371         #  z - y    y\n372         # x      * x  will be left alone.  This is because checking every possible\n373         # combination can slow things down.\n374 \n375         # gather exponents of common bases...\n376         def _gather(c_powers):\n377             common_b = {}  # b:e\n378             for b, e in c_powers:\n379                 co = e.as_coeff_Mul()\n380                 common_b.setdefault(b, {}).setdefault(\n381                     co[1], []).append(co[0])\n382             for b, d in common_b.items():\n383                 for di, li in d.items():\n384                     d[di] = Add(*li)\n385             new_c_powers = []\n386             for b, e in common_b.items():\n387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])\n388             return new_c_powers\n389 \n390         # in c_powers\n391         c_powers = _gather(c_powers)\n392 \n393         # and in num_exp\n394         num_exp = _gather(num_exp)\n395 \n396         # --- PART 2 ---\n397         #\n398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)\n399         # o combine collected powers  (2**x * 3**x -> 6**x)\n400         #   with numeric base\n401 \n402         # ................................\n403         # now we have:\n404         # - coeff:\n405         # - c_powers:    (b, e)\n406         # - num_exp:     (2, e)\n407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}\n408 \n409         #  0             1\n410         # x  -> 1       x  -> x\n411 \n412         # this should only need to run twice; if it fails because\n413         # it needs to be run more times, perhaps this should be\n414         # changed to a \"while True\" loop -- the only reason it\n415         # isn't such now is to allow a less-than-perfect result to\n416         # be obtained rather than raising an error or entering an\n417         # infinite loop\n418         for i in range(2):\n419             new_c_powers = []\n420             changed = False\n421             for b, e in c_powers:\n422                 if e.is_zero:\n423                     continue\n424                 if e is S.One:\n425                     if b.is_Number:\n426                         coeff *= b\n427                         continue\n428                     p = b\n429                 if e is not S.One:\n430                     p = Pow(b, e)\n431                     # check to make sure that the base doesn't change\n432                     # after exponentiation; to allow for unevaluated\n433                     # Pow, we only do so if b is not already a Pow\n434                     if p.is_Pow and not b.is_Pow:\n435                         bi = b\n436                         b, e = p.as_base_exp()\n437                         if b != bi:\n438                             changed = True\n439                 c_part.append(p)\n440                 new_c_powers.append((b, e))\n441             # there might have been a change, but unless the base\n442             # matches some other base, there is nothing to do\n443             if changed and len(set(\n444                     b for b, e in new_c_powers)) != len(new_c_powers):\n445                 # start over again\n446                 c_part = []\n447                 c_powers = _gather(new_c_powers)\n448             else:\n449                 break\n450 \n451         #  x    x     x\n452         # 2  * 3  -> 6\n453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x\n454                             # e.g.  x:6  for  ... * 2  * 3  * ...\n455         for b, e in num_exp:\n456             inv_exp_dict.setdefault(e, []).append(b)\n457         for e, b in inv_exp_dict.items():\n458             inv_exp_dict[e] = cls(*b)\n459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n460 \n461         # b, e -> e' = sum(e), b\n462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}\n463         comb_e = {}\n464         for b, e in pnum_rat.items():\n465             comb_e.setdefault(Add(*e), []).append(b)\n466         del pnum_rat\n467         # process them, reducing exponents to values less than 1\n468         # and updating coeff if necessary else adding them to\n469         # num_rat for further processing\n470         num_rat = []\n471         for e, b in comb_e.items():\n472             b = cls(*b)\n473             if e.q == 1:\n474                 coeff *= Pow(b, e)\n475                 continue\n476             if e.p > e.q:\n477                 e_i, ep = divmod(e.p, e.q)\n478                 coeff *= Pow(b, e_i)\n479                 e = Rational(ep, e.q)\n480             num_rat.append((b, e))\n481         del comb_e\n482 \n483         # extract gcd of bases in num_rat\n484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)\n485         pnew = defaultdict(list)\n486         i = 0  # steps through num_rat which may grow\n487         while i < len(num_rat):\n488             bi, ei = num_rat[i]\n489             grow = []\n490             for j in range(i + 1, len(num_rat)):\n491                 bj, ej = num_rat[j]\n492                 g = bi.gcd(bj)\n493                 if g is not S.One:\n494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2\n495                     # this might have a gcd with something else\n496                     e = ei + ej\n497                     if e.q == 1:\n498                         coeff *= Pow(g, e)\n499                     else:\n500                         if e.p > e.q:\n501                             e_i, ep = divmod(e.p, e.q)  # change e in place\n502                             coeff *= Pow(g, e_i)\n503                             e = Rational(ep, e.q)\n504                         grow.append((g, e))\n505                     # update the jth item\n506                     num_rat[j] = (bj/g, ej)\n507                     # update bi that we are checking with\n508                     bi = bi/g\n509                     if bi is S.One:\n510                         break\n511             if bi is not S.One:\n512                 obj = Pow(bi, ei)\n513                 if obj.is_Number:\n514                     coeff *= obj\n515                 else:\n516                     # changes like sqrt(12) -> 2*sqrt(3)\n517                     for obj in Mul.make_args(obj):\n518                         if obj.is_Number:\n519                             coeff *= obj\n520                         else:\n521                             assert obj.is_Pow\n522                             bi, ei = obj.args\n523                             pnew[ei].append(bi)\n524 \n525             num_rat.extend(grow)\n526             i += 1\n527 \n528         # combine bases of the new powers\n529         for e, b in pnew.items():\n530             pnew[e] = cls(*b)\n531 \n532         # handle -1 and I\n533         if neg1e:\n534             # treat I as (-1)**(1/2) and compute -1's total exponent\n535             p, q =  neg1e.as_numer_denom()\n536             # if the integer part is odd, extract -1\n537             n, p = divmod(p, q)\n538             if n % 2:\n539                 coeff = -coeff\n540             # if it's a multiple of 1/2 extract I\n541             if q == 2:\n542                 c_part.append(S.ImaginaryUnit)\n543             elif p:\n544                 # see if there is any positive base this power of\n545                 # -1 can join\n546                 neg1e = Rational(p, q)\n547                 for e, b in pnew.items():\n548                     if e == neg1e and b.is_positive:\n549                         pnew[e] = -b\n550                         break\n551                 else:\n552                     # keep it separate; we've already evaluated it as\n553                     # much as possible so evaluate=False\n554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n555 \n556         # add all the pnew powers\n557         c_part.extend([Pow(b, e) for e, b in pnew.items()])\n558 \n559         # oo, -oo\n560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):\n561             def _handle_for_oo(c_part, coeff_sign):\n562                 new_c_part = []\n563                 for t in c_part:\n564                     if t.is_positive:\n565                         continue\n566                     if t.is_negative:\n567                         coeff_sign *= -1\n568                         continue\n569                     new_c_part.append(t)\n570                 return new_c_part, coeff_sign\n571             c_part, coeff_sign = _handle_for_oo(c_part, 1)\n572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n573             coeff *= coeff_sign\n574 \n575         # zoo\n576         if coeff is S.ComplexInfinity:\n577             # zoo might be\n578             #   infinite_real + bounded_im\n579             #   bounded_real + infinite_im\n580             #   infinite_real + infinite_im\n581             # and non-zero real or imaginary will not change that status.\n582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and\n583                                                 c.is_real is not None)]\n584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and\n585                                                   c.is_real is not None)]\n586 \n587         # 0\n588         elif coeff is S.Zero:\n589             # we know for sure the result will be 0 except the multiplicand\n590             # is infinity\n591             if any(c.is_finite == False for c in c_part):\n592                 return [S.NaN], [], order_symbols\n593             return [coeff], [], order_symbols\n594 \n595         # check for straggling Numbers that were produced\n596         _new = []\n597         for i in c_part:\n598             if i.is_Number:\n599                 coeff *= i\n600             else:\n601                 _new.append(i)\n602         c_part = _new\n603 \n604         # order commutative part canonically\n605         _mulsort(c_part)\n606 \n607         # current code expects coeff to be always in slot-0\n608         if coeff is not S.One:\n609             c_part.insert(0, coeff)\n610 \n611         # we are done\n612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and\n613                 c_part[1].is_Add):\n614             # 2*(1+a) -> 2 + 2 * a\n615             coeff = c_part[0]\n616             c_part = [Add(*[coeff*f for f in c_part[1].args])]\n617 \n618         return c_part, nc_part, order_symbols\n619 \n620     def _eval_power(b, e):\n621 \n622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B\n623         cargs, nc = b.args_cnc(split_1=False)\n624 \n625         if e.is_Integer:\n626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \\\n627                 Pow(Mul._from_args(nc), e, evaluate=False)\n628 \n629         p = Pow(b, e, evaluate=False)\n630 \n631         if e.is_Rational or e.is_Float:\n632             return p._eval_expand_power_base()\n633 \n634         return p\n635 \n636     @classmethod\n637     def class_key(cls):\n638         return 3, 0, cls.__name__\n639 \n640     def _eval_evalf(self, prec):\n641         c, m = self.as_coeff_Mul()\n642         if c is S.NegativeOne:\n643             if m.is_Mul:\n644                 rv = -AssocOp._eval_evalf(m, prec)\n645             else:\n646                 mnew = m._eval_evalf(prec)\n647                 if mnew is not None:\n648                     m = mnew\n649                 rv = -m\n650         else:\n651             rv = AssocOp._eval_evalf(self, prec)\n652         if rv.is_number:\n653             return rv.expand()\n654         return rv\n655 \n656     @property\n657     def _mpc_(self):\n658         \"\"\"\n659         Convert self to an mpmath mpc if possible\n660         \"\"\"\n661         from sympy.core.numbers import I, Float\n662         im_part, imag_unit = self.as_coeff_Mul()\n663         if not imag_unit == I:\n664             # ValueError may seem more reasonable but since it's a @property,\n665             # we need to use AttributeError to keep from confusing things like\n666             # hasattr.\n667             raise AttributeError(\"Cannot convert Mul to mpc. Must be of the form Number*I\")\n668 \n669         return (Float(0)._mpf_, Float(im_part)._mpf_)\n670 \n671     @cacheit\n672     def as_two_terms(self):\n673         \"\"\"Return head and tail of self.\n674 \n675         This is the most efficient way to get the head and tail of an\n676         expression.\n677 \n678         - if you want only the head, use self.args[0];\n679         - if you want to process the arguments of the tail then use\n680           self.as_coef_mul() which gives the head and a tuple containing\n681           the arguments of the tail when treated as a Mul.\n682         - if you want the coefficient when self is treated as an Add\n683           then use self.as_coeff_add()[0]\n684 \n685         >>> from sympy.abc import x, y\n686         >>> (3*x*y).as_two_terms()\n687         (3, x*y)\n688         \"\"\"\n689         args = self.args\n690 \n691         if len(args) == 1:\n692             return S.One, self\n693         elif len(args) == 2:\n694             return args\n695 \n696         else:\n697             return args[0], self._new_rawargs(*args[1:])\n698 \n699     @cacheit\n700     def as_coefficients_dict(self):\n701         \"\"\"Return a dictionary mapping terms to their coefficient.\n702         Since the dictionary is a defaultdict, inquiries about terms which\n703         were not present will return a coefficient of 0. The dictionary\n704         is considered to have a single term.\n705 \n706         Examples\n707         ========\n708 \n709         >>> from sympy.abc import a, x\n710         >>> (3*a*x).as_coefficients_dict()\n711         {a*x: 3}\n712         >>> _[a]\n713         0\n714         \"\"\"\n715 \n716         d = defaultdict(int)\n717         args = self.args\n718 \n719         if len(args) == 1 or not args[0].is_Number:\n720             d[self] = S.One\n721         else:\n722             d[self._new_rawargs(*args[1:])] = args[0]\n723 \n724         return d\n725 \n726     @cacheit\n727     def as_coeff_mul(self, *deps, **kwargs):\n728         rational = kwargs.pop('rational', True)\n729         if deps:\n730             l1 = []\n731             l2 = []\n732             for f in self.args:\n733                 if f.has(*deps):\n734                     l2.append(f)\n735                 else:\n736                     l1.append(f)\n737             return self._new_rawargs(*l1), tuple(l2)\n738         args = self.args\n739         if args[0].is_Number:\n740             if not rational or args[0].is_Rational:\n741                 return args[0], args[1:]\n742             elif args[0].is_negative:\n743                 return S.NegativeOne, (-args[0],) + args[1:]\n744         return S.One, args\n745 \n746     def as_coeff_Mul(self, rational=False):\n747         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n748         coeff, args = self.args[0], self.args[1:]\n749 \n750         if coeff.is_Number:\n751             if not rational or coeff.is_Rational:\n752                 if len(args) == 1:\n753                     return coeff, args[0]\n754                 else:\n755                     return coeff, self._new_rawargs(*args)\n756             elif coeff.is_negative:\n757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n758         return S.One, self\n759 \n760     def as_real_imag(self, deep=True, **hints):\n761         from sympy import Abs, expand_mul, im, re\n762         other = []\n763         coeffr = []\n764         coeffi = []\n765         addterms = S.One\n766         for a in self.args:\n767             if a.is_real:\n768                 coeffr.append(a)\n769             elif a.is_imaginary:\n770                 coeffi.append(a)\n771             elif a.is_commutative:\n772                 # search for complex conjugate pairs:\n773                 for i, x in enumerate(other):\n774                     if x == a.conjugate():\n775                         coeffr.append(Abs(x)**2)\n776                         del other[i]\n777                         break\n778                 else:\n779                     if a.is_Add:\n780                         addterms *= a\n781                     else:\n782                         other.append(a)\n783             else:\n784                 other.append(a)\n785         m = self.func(*other)\n786         if hints.get('ignore') == m:\n787             return\n788         if len(coeffi) % 2:\n789             imco = im(coeffi.pop(0))\n790             # all other pairs make a real factor; they will be\n791             # put into reco below\n792         else:\n793             imco = S.Zero\n794         reco = self.func(*(coeffr + coeffi))\n795         r, i = (reco*re(m), reco*im(m))\n796         if addterms == 1:\n797             if m == 1:\n798                 if imco is S.Zero:\n799                     return (reco, S.Zero)\n800                 else:\n801                     return (S.Zero, reco*imco)\n802             if imco is S.Zero:\n803                 return (r, i)\n804             return (-imco*i, imco*r)\n805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n806         if imco is S.Zero:\n807             return (r*addre - i*addim, i*addre + r*addim)\n808         else:\n809             r, i = -imco*i, imco*r\n810             return (r*addre - i*addim, r*addim + i*addre)\n811 \n812     @staticmethod\n813     def _expandsums(sums):\n814         \"\"\"\n815         Helper function for _eval_expand_mul.\n816 \n817         sums must be a list of instances of Basic.\n818         \"\"\"\n819 \n820         L = len(sums)\n821         if L == 1:\n822             return sums[0].args\n823         terms = []\n824         left = Mul._expandsums(sums[:L//2])\n825         right = Mul._expandsums(sums[L//2:])\n826 \n827         terms = [Mul(a, b) for a in left for b in right]\n828         added = Add(*terms)\n829         return Add.make_args(added)  # it may have collapsed down to one term\n830 \n831     def _eval_expand_mul(self, **hints):\n832         from sympy import fraction\n833 \n834         # Handle things like 1/(x*(x + 1)), which are automatically converted\n835         # to 1/x*1/(x + 1)\n836         expr = self\n837         n, d = fraction(expr)\n838         if d.is_Mul:\n839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i\n840                 for i in (n, d)]\n841             expr = n/d\n842             if not expr.is_Mul:\n843                 return expr\n844 \n845         plain, sums, rewrite = [], [], False\n846         for factor in expr.args:\n847             if factor.is_Add:\n848                 sums.append(factor)\n849                 rewrite = True\n850             else:\n851                 if factor.is_commutative:\n852                     plain.append(factor)\n853                 else:\n854                     sums.append(Basic(factor))  # Wrapper\n855 \n856         if not rewrite:\n857             return expr\n858         else:\n859             plain = self.func(*plain)\n860             if sums:\n861                 terms = self.func._expandsums(sums)\n862                 args = []\n863                 for term in terms:\n864                     t = self.func(plain, term)\n865                     if t.is_Mul and any(a.is_Add for a in t.args):\n866                         t = t._eval_expand_mul()\n867                     args.append(t)\n868                 return Add(*args)\n869             else:\n870                 return plain\n871 \n872     @cacheit\n873     def _eval_derivative(self, s):\n874         args = list(self.args)\n875         terms = []\n876         for i in range(len(args)):\n877             d = args[i].diff(s)\n878             if d:\n879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))\n880         return Add(*terms)\n881 \n882     def _eval_difference_delta(self, n, step):\n883         from sympy.series.limitseq import difference_delta as dd\n884         arg0 = self.args[0]\n885         rest = Mul(*self.args[1:])\n886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *\n887                 rest)\n888 \n889     def _matches_simple(self, expr, repl_dict):\n890         # handle (w*3).matches('x*5') -> {w: x*5/3}\n891         coeff, terms = self.as_coeff_Mul()\n892         terms = Mul.make_args(terms)\n893         if len(terms) == 1:\n894             newexpr = self.__class__._combine_inverse(expr, coeff)\n895             return terms[0].matches(newexpr, repl_dict)\n896         return\n897 \n898     def matches(self, expr, repl_dict={}, old=False):\n899         expr = sympify(expr)\n900         if self.is_commutative and expr.is_commutative:\n901             return AssocOp._matches_commutative(self, expr, repl_dict, old)\n902         elif self.is_commutative is not expr.is_commutative:\n903             return None\n904         c1, nc1 = self.args_cnc()\n905         c2, nc2 = expr.args_cnc()\n906         repl_dict = repl_dict.copy()\n907         if c1:\n908             if not c2:\n909                 c2 = [1]\n910             a = self.func(*c1)\n911             if isinstance(a, AssocOp):\n912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)\n913             else:\n914                 repl_dict = a.matches(self.func(*c2), repl_dict)\n915         if repl_dict:\n916             a = self.func(*nc1)\n917             if isinstance(a, self.func):\n918                 repl_dict = a._matches(self.func(*nc2), repl_dict)\n919             else:\n920                 repl_dict = a.matches(self.func(*nc2), repl_dict)\n921         return repl_dict or None\n922 \n923     def _matches(self, expr, repl_dict={}):\n924         # weed out negative one prefixes#\n925         from sympy import Wild\n926         sign = 1\n927         a, b = self.as_two_terms()\n928         if a is S.NegativeOne:\n929             if b.is_Mul:\n930                 sign = -sign\n931             else:\n932                 # the remainder, b, is not a Mul anymore\n933                 return b.matches(-expr, repl_dict)\n934         expr = sympify(expr)\n935         if expr.is_Mul and expr.args[0] is S.NegativeOne:\n936             expr = -expr\n937             sign = -sign\n938 \n939         if not expr.is_Mul:\n940             # expr can only match if it matches b and a matches +/- 1\n941             if len(self.args) == 2:\n942                 # quickly test for equality\n943                 if b == expr:\n944                     return a.matches(Rational(sign), repl_dict)\n945                 # do more expensive match\n946                 dd = b.matches(expr, repl_dict)\n947                 if dd is None:\n948                     return None\n949                 dd = a.matches(Rational(sign), dd)\n950                 return dd\n951             return None\n952 \n953         d = repl_dict.copy()\n954 \n955         # weed out identical terms\n956         pp = list(self.args)\n957         ee = list(expr.args)\n958         for p in self.args:\n959             if p in expr.args:\n960                 ee.remove(p)\n961                 pp.remove(p)\n962 \n963         # only one symbol left in pattern -> match the remaining expression\n964         if len(pp) == 1 and isinstance(pp[0], Wild):\n965             if len(ee) == 1:\n966                 d[pp[0]] = sign * ee[0]\n967             else:\n968                 d[pp[0]] = sign * expr.func(*ee)\n969             return d\n970 \n971         if len(ee) != len(pp):\n972             return None\n973 \n974         for p, e in zip(pp, ee):\n975             d = p.xreplace(d).matches(e, d)\n976             if d is None:\n977                 return None\n978         return d\n979 \n980     @staticmethod\n981     def _combine_inverse(lhs, rhs):\n982         \"\"\"\n983         Returns lhs/rhs, but treats arguments like symbols, so things like\n984         oo/oo return 1, instead of a nan.\n985         \"\"\"\n986         if lhs == rhs:\n987             return S.One\n988 \n989         def check(l, r):\n990             if l.is_Float and r.is_comparable:\n991                 # if both objects are added to 0 they will share the same \"normalization\"\n992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow\n993                 # the 0 to pass, we use __add__ directly.\n994                 return l.__add__(0) == r.evalf().__add__(0)\n995             return False\n996         if check(lhs, rhs) or check(rhs, lhs):\n997             return S.One\n998         if lhs.is_Mul and rhs.is_Mul:\n999             a = list(lhs.args)\n1000             b = [1]\n1001             for x in rhs.args:\n1002                 if x in a:\n1003                     a.remove(x)\n1004                 elif -x in a:\n1005                     a.remove(-x)\n1006                     b.append(-1)\n1007                 else:\n1008                     b.append(x)\n1009             return lhs.func(*a)/rhs.func(*b)\n1010         return lhs/rhs\n1011 \n1012     def as_powers_dict(self):\n1013         d = defaultdict(int)\n1014         for term in self.args:\n1015             b, e = term.as_base_exp()\n1016             d[b] += e\n1017         return d\n1018 \n1019     def as_numer_denom(self):\n1020         # don't use _from_args to rebuild the numerators and denominators\n1021         # as the order is not guaranteed to be the same once they have\n1022         # been separated from each other\n1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n1024         return self.func(*numers), self.func(*denoms)\n1025 \n1026     def as_base_exp(self):\n1027         e1 = None\n1028         bases = []\n1029         nc = 0\n1030         for m in self.args:\n1031             b, e = m.as_base_exp()\n1032             if not b.is_commutative:\n1033                 nc += 1\n1034             if e1 is None:\n1035                 e1 = e\n1036             elif e != e1 or nc > 1:\n1037                 return self, S.One\n1038             bases.append(b)\n1039         return self.func(*bases), e1\n1040 \n1041     def _eval_is_polynomial(self, syms):\n1042         return all(term._eval_is_polynomial(syms) for term in self.args)\n1043 \n1044     def _eval_is_rational_function(self, syms):\n1045         return all(term._eval_is_rational_function(syms) for term in self.args)\n1046 \n1047     def _eval_is_algebraic_expr(self, syms):\n1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)\n1049 \n1050     _eval_is_finite = lambda self: _fuzzy_group(\n1051         a.is_finite for a in self.args)\n1052     _eval_is_commutative = lambda self: _fuzzy_group(\n1053         a.is_commutative for a in self.args)\n1054     _eval_is_complex = lambda self: _fuzzy_group(\n1055         (a.is_complex for a in self.args), quick_exit=True)\n1056 \n1057     def _eval_is_infinite(self):\n1058         if any(a.is_infinite for a in self.args):\n1059             if any(a.is_zero for a in self.args):\n1060                 return S.NaN.is_infinite\n1061             if any(a.is_zero is None for a in self.args):\n1062                 return None\n1063             return True\n1064 \n1065     def _eval_is_rational(self):\n1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n1067         if r:\n1068             return r\n1069         elif r is False:\n1070             return self.is_zero\n1071 \n1072     def _eval_is_algebraic(self):\n1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n1074         if r:\n1075             return r\n1076         elif r is False:\n1077             return self.is_zero\n1078 \n1079     def _eval_is_zero(self):\n1080         zero = infinite = False\n1081         for a in self.args:\n1082             z = a.is_zero\n1083             if z:\n1084                 if infinite:\n1085                     return  # 0*oo is nan and nan.is_zero is None\n1086                 zero = True\n1087             else:\n1088                 if not a.is_finite:\n1089                     if zero:\n1090                         return  # 0*oo is nan and nan.is_zero is None\n1091                     infinite = True\n1092                 if zero is False and z is None:  # trap None\n1093                     zero = None\n1094         return zero\n1095 \n1096     def _eval_is_integer(self):\n1097         is_rational = self.is_rational\n1098 \n1099         if is_rational:\n1100             n, d = self.as_numer_denom()\n1101             if d is S.One:\n1102                 return True\n1103             elif d is S(2):\n1104                 return n.is_even\n1105         elif is_rational is False:\n1106             return False\n1107 \n1108     def _eval_is_polar(self):\n1109         has_polar = any(arg.is_polar for arg in self.args)\n1110         return has_polar and \\\n1111             all(arg.is_polar or arg.is_positive for arg in self.args)\n1112 \n1113     def _eval_is_real(self):\n1114         return self._eval_real_imag(True)\n1115 \n1116     def _eval_real_imag(self, real):\n1117         zero = one_neither = False\n1118 \n1119         for t in self.args:\n1120             if not t.is_complex:\n1121                 return t.is_complex\n1122             elif t.is_imaginary:\n1123                 real = not real\n1124             elif t.is_real:\n1125                 if not zero:\n1126                     z = t.is_zero\n1127                     if not z and zero is False:\n1128                         zero = z\n1129                     elif z:\n1130                         if all(a.is_finite for a in self.args):\n1131                             return True\n1132                         return\n1133             elif t.is_real is False:\n1134                 if one_neither:\n1135                     return  # complex terms might cancel\n1136                 one_neither = True\n1137             else:\n1138                 return\n1139 \n1140         if one_neither:  # self is a+I*b or I*b\n1141             if real:\n1142                 return zero  # real*self is like self: neither is real\n1143         elif zero is False:\n1144             return real  # can't be trumped by 0\n1145         elif real:\n1146             return real  # doesn't matter what zero is\n1147 \n1148     def _eval_is_imaginary(self):\n1149         z = self.is_zero\n1150         if z:\n1151             return False\n1152         elif z is False:\n1153             return self._eval_real_imag(False)\n1154 \n1155     def _eval_is_hermitian(self):\n1156         return self._eval_herm_antiherm(True)\n1157 \n1158     def _eval_herm_antiherm(self, real):\n1159         one_nc = zero = one_neither = False\n1160 \n1161         for t in self.args:\n1162             if not t.is_commutative:\n1163                 if one_nc:\n1164                     return\n1165                 one_nc = True\n1166 \n1167             if t.is_antihermitian:\n1168                 real = not real\n1169             elif t.is_hermitian:\n1170                 if not zero:\n1171                     z = t.is_zero\n1172                     if not z and zero is False:\n1173                         zero = z\n1174                     elif z:\n1175                         if all(a.is_finite for a in self.args):\n1176                             return True\n1177                         return\n1178             elif t.is_hermitian is False:\n1179                 if one_neither:\n1180                     return\n1181                 one_neither = True\n1182             else:\n1183                 return\n1184 \n1185         if one_neither:\n1186             if real:\n1187                 return zero\n1188         elif zero is False or real:\n1189             return real\n1190 \n1191     def _eval_is_antihermitian(self):\n1192         z = self.is_zero\n1193         if z:\n1194             return False\n1195         elif z is False:\n1196             return self._eval_herm_antiherm(False)\n1197 \n1198     def _eval_is_irrational(self):\n1199         for t in self.args:\n1200             a = t.is_irrational\n1201             if a:\n1202                 others = list(self.args)\n1203                 others.remove(t)\n1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):\n1205                     return True\n1206                 return\n1207             if a is None:\n1208                 return\n1209         return False\n1210 \n1211     def _eval_is_positive(self):\n1212         \"\"\"Return True if self is positive, False if not, and None if it\n1213         cannot be determined.\n1214 \n1215         This algorithm is non-recursive and works by keeping track of the\n1216         sign which changes when a negative or nonpositive is encountered.\n1217         Whether a nonpositive or nonnegative is seen is also tracked since\n1218         the presence of these makes it impossible to return True, but\n1219         possible to return False if the end result is nonpositive. e.g.\n1220 \n1221             pos * neg * nonpositive -> pos or zero -> None is returned\n1222             pos * neg * nonnegative -> neg or zero -> False is returned\n1223         \"\"\"\n1224         return self._eval_pos_neg(1)\n1225 \n1226     def _eval_pos_neg(self, sign):\n1227         saw_NON = saw_NOT = False\n1228         for t in self.args:\n1229             if t.is_positive:\n1230                 continue\n1231             elif t.is_negative:\n1232                 sign = -sign\n1233             elif t.is_zero:\n1234                 if all(a.is_finite for a in self.args):\n1235                     return False\n1236                 return\n1237             elif t.is_nonpositive:\n1238                 sign = -sign\n1239                 saw_NON = True\n1240             elif t.is_nonnegative:\n1241                 saw_NON = True\n1242             elif t.is_positive is False:\n1243                 sign = -sign\n1244                 if saw_NOT:\n1245                     return\n1246                 saw_NOT = True\n1247             elif t.is_negative is False:\n1248                 if saw_NOT:\n1249                     return\n1250                 saw_NOT = True\n1251             else:\n1252                 return\n1253         if sign == 1 and saw_NON is False and saw_NOT is False:\n1254             return True\n1255         if sign < 0:\n1256             return False\n1257 \n1258     def _eval_is_negative(self):\n1259         if self.args[0] == -1:\n1260             return (-self).is_positive  # remove -1\n1261         return self._eval_pos_neg(-1)\n1262 \n1263     def _eval_is_odd(self):\n1264         is_integer = self.is_integer\n1265 \n1266         if is_integer:\n1267             r, acc = True, 1\n1268             for t in self.args:\n1269                 if not t.is_integer:\n1270                     return None\n1271                 elif t.is_even:\n1272                     r = False\n1273                 elif t.is_integer:\n1274                     if r is False:\n1275                         pass\n1276                     elif acc != 1 and (acc + t).is_odd:\n1277                         r = False\n1278                     elif t.is_odd is None:\n1279                         r = None\n1280                 acc = t\n1281             return r\n1282 \n1283         # !integer -> !odd\n1284         elif is_integer is False:\n1285             return False\n1286 \n1287     def _eval_is_even(self):\n1288         is_integer = self.is_integer\n1289 \n1290         if is_integer:\n1291             return fuzzy_not(self.is_odd)\n1292 \n1293         elif is_integer is False:\n1294             return False\n1295 \n1296     def _eval_is_prime(self):\n1297         \"\"\"\n1298         If product is a positive integer, multiplication\n1299         will never result in a prime number.\n1300         \"\"\"\n1301         if self.is_number:\n1302             \"\"\"\n1303             If input is a number that is not completely simplified.\n1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)\n1305             So we manually evaluate it and return whether that is prime or not.\n1306             \"\"\"\n1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)\n1308             r = S.One\n1309             for arg in self.args:\n1310                 r *= arg\n1311             return r.is_prime\n1312 \n1313         if self.is_integer and self.is_positive:\n1314             \"\"\"\n1315             Here we count the number of arguments that have a minimum value\n1316             greater than two.\n1317             If there are more than one of such a symbol then the result is not prime.\n1318             Else, the result cannot be determined.\n1319             \"\"\"\n1320             number_of_args = 0 # count of symbols with minimum value greater than one\n1321             for arg in self.args:\n1322                 if (arg-1).is_positive:\n1323                     number_of_args += 1\n1324 \n1325             if number_of_args > 1:\n1326                 return False\n1327 \n1328     def _eval_subs(self, old, new):\n1329         from sympy.functions.elementary.complexes import sign\n1330         from sympy.ntheory.factor_ import multiplicity\n1331         from sympy.simplify.powsimp import powdenest\n1332         from sympy.simplify.radsimp import fraction\n1333 \n1334         if not old.is_Mul:\n1335             return None\n1336 \n1337         # try keep replacement literal so -2*x doesn't replace 4*x\n1338         if old.args[0].is_Number and old.args[0] < 0:\n1339             if self.args[0].is_Number:\n1340                 if self.args[0] < 0:\n1341                     return self._subs(-old, -new)\n1342                 return None\n1343 \n1344         def base_exp(a):\n1345             # if I and -1 are in a Mul, they get both end up with\n1346             # a -1 base (see issue 6421); all we want here are the\n1347             # true Pow or exp separated into base and exponent\n1348             from sympy import exp\n1349             if a.is_Pow or a.func is exp:\n1350                 return a.as_base_exp()\n1351             return a, S.One\n1352 \n1353         def breakup(eq):\n1354             \"\"\"break up powers of eq when treated as a Mul:\n1355                    b**(Rational*e) -> b**e, Rational\n1356                 commutatives come back as a dictionary {b**e: Rational}\n1357                 noncommutatives come back as a list [(b**e, Rational)]\n1358             \"\"\"\n1359 \n1360             (c, nc) = (defaultdict(int), list())\n1361             for a in Mul.make_args(eq):\n1362                 a = powdenest(a)\n1363                 (b, e) = base_exp(a)\n1364                 if e is not S.One:\n1365                     (co, _) = e.as_coeff_mul()\n1366                     b = Pow(b, e/co)\n1367                     e = co\n1368                 if a.is_commutative:\n1369                     c[b] += e\n1370                 else:\n1371                     nc.append([b, e])\n1372             return (c, nc)\n1373 \n1374         def rejoin(b, co):\n1375             \"\"\"\n1376             Put rational back with exponent; in general this is not ok, but\n1377             since we took it from the exponent for analysis, it's ok to put\n1378             it back.\n1379             \"\"\"\n1380 \n1381             (b, e) = base_exp(b)\n1382             return Pow(b, e*co)\n1383 \n1384         def ndiv(a, b):\n1385             \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n1386             but not vice versa, and 2/5 does not divide 1/3) then return\n1387             the integer number of times it divides, else return 0.\n1388             \"\"\"\n1389             if not b.q % a.q or not a.q % b.q:\n1390                 return int(a/b)\n1391             return 0\n1392 \n1393         # give Muls in the denominator a chance to be changed (see issue 5651)\n1394         # rv will be the default return value\n1395         rv = None\n1396         n, d = fraction(self)\n1397         self2 = self\n1398         if d is not S.One:\n1399             self2 = n._subs(old, new)/d._subs(old, new)\n1400             if not self2.is_Mul:\n1401                 return self2._subs(old, new)\n1402             if self2 != self:\n1403                 rv = self2\n1404 \n1405         # Now continue with regular substitution.\n1406 \n1407         # handle the leading coefficient and use it to decide if anything\n1408         # should even be started; we always know where to find the Rational\n1409         # so it's a quick test\n1410 \n1411         co_self = self2.args[0]\n1412         co_old = old.args[0]\n1413         co_xmul = None\n1414         if co_old.is_Rational and co_self.is_Rational:\n1415             # if coeffs are the same there will be no updating to do\n1416             # below after breakup() step; so skip (and keep co_xmul=None)\n1417             if co_old != co_self:\n1418                 co_xmul = co_self.extract_multiplicatively(co_old)\n1419         elif co_old.is_Rational:\n1420             return rv\n1421 \n1422         # break self and old into factors\n1423 \n1424         (c, nc) = breakup(self2)\n1425         (old_c, old_nc) = breakup(old)\n1426 \n1427         # update the coefficients if we had an extraction\n1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5\n1429         # then co_self in c is replaced by (3/5)**2 and co_residual\n1430         # is 2*(1/7)**2\n1431 \n1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:\n1433             mult = S(multiplicity(abs(co_old), co_self))\n1434             c.pop(co_self)\n1435             if co_old in c:\n1436                 c[co_old] += mult\n1437             else:\n1438                 c[co_old] = mult\n1439             co_residual = co_self/co_old**mult\n1440         else:\n1441             co_residual = 1\n1442 \n1443         # do quick tests to see if we can't succeed\n1444 \n1445         ok = True\n1446         if len(old_nc) > len(nc):\n1447             # more non-commutative terms\n1448             ok = False\n1449         elif len(old_c) > len(c):\n1450             # more commutative terms\n1451             ok = False\n1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):\n1453             # unmatched non-commutative bases\n1454             ok = False\n1455         elif set(old_c).difference(set(c)):\n1456             # unmatched commutative terms\n1457             ok = False\n1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n1459             # differences in sign\n1460             ok = False\n1461         if not ok:\n1462             return rv\n1463 \n1464         if not old_c:\n1465             cdid = None\n1466         else:\n1467             rat = []\n1468             for (b, old_e) in old_c.items():\n1469                 c_e = c[b]\n1470                 rat.append(ndiv(c_e, old_e))\n1471                 if not rat[-1]:\n1472                     return rv\n1473             cdid = min(rat)\n1474 \n1475         if not old_nc:\n1476             ncdid = None\n1477             for i in range(len(nc)):\n1478                 nc[i] = rejoin(*nc[i])\n1479         else:\n1480             ncdid = 0  # number of nc replacements we did\n1481             take = len(old_nc)  # how much to look at each time\n1482             limit = cdid or S.Infinity  # max number that we can take\n1483             failed = []  # failed terms will need subs if other terms pass\n1484             i = 0\n1485             while limit and i + take <= len(nc):\n1486                 hit = False\n1487 \n1488                 # the bases must be equivalent in succession, and\n1489                 # the powers must be extractively compatible on the\n1490                 # first and last factor but equal inbetween.\n1491 \n1492                 rat = []\n1493                 for j in range(take):\n1494                     if nc[i + j][0] != old_nc[j][0]:\n1495                         break\n1496                     elif j == 0:\n1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n1498                     elif j == take - 1:\n1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n1500                     elif nc[i + j][1] != old_nc[j][1]:\n1501                         break\n1502                     else:\n1503                         rat.append(1)\n1504                     j += 1\n1505                 else:\n1506                     ndo = min(rat)\n1507                     if ndo:\n1508                         if take == 1:\n1509                             if cdid:\n1510                                 ndo = min(cdid, ndo)\n1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],\n1512                                     nc[i][1] - ndo*old_nc[0][1])\n1513                         else:\n1514                             ndo = 1\n1515 \n1516                             # the left residual\n1517 \n1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*\n1519                                     old_nc[0][1])\n1520 \n1521                             # eliminate all middle terms\n1522 \n1523                             mid = new\n1524 \n1525                             # the right residual (which may be the same as the middle if take == 2)\n1526 \n1527                             ir = i + take - 1\n1528                             r = (nc[ir][0], nc[ir][1] - ndo*\n1529                                  old_nc[-1][1])\n1530                             if r[1]:\n1531                                 if i + take < len(nc):\n1532                                     nc[i:i + take] = [l*mid, r]\n1533                                 else:\n1534                                     r = rejoin(*r)\n1535                                     nc[i:i + take] = [l*mid*r]\n1536                             else:\n1537 \n1538                                 # there was nothing left on the right\n1539 \n1540                                 nc[i:i + take] = [l*mid]\n1541 \n1542                         limit -= ndo\n1543                         ncdid += ndo\n1544                         hit = True\n1545                 if not hit:\n1546 \n1547                     # do the subs on this failing factor\n1548 \n1549                     failed.append(i)\n1550                 i += 1\n1551             else:\n1552 \n1553                 if not ncdid:\n1554                     return rv\n1555 \n1556                 # although we didn't fail, certain nc terms may have\n1557                 # failed so we rebuild them after attempting a partial\n1558                 # subs on them\n1559 \n1560                 failed.extend(range(i, len(nc)))\n1561                 for i in failed:\n1562                     nc[i] = rejoin(*nc[i]).subs(old, new)\n1563 \n1564         # rebuild the expression\n1565 \n1566         if cdid is None:\n1567             do = ncdid\n1568         elif ncdid is None:\n1569             do = cdid\n1570         else:\n1571             do = min(ncdid, cdid)\n1572 \n1573         margs = []\n1574         for b in c:\n1575             if b in old_c:\n1576 \n1577                 # calculate the new exponent\n1578 \n1579                 e = c[b] - old_c[b]*do\n1580                 margs.append(rejoin(b, e))\n1581             else:\n1582                 margs.append(rejoin(b.subs(old, new), c[b]))\n1583         if cdid and not ncdid:\n1584 \n1585             # in case we are replacing commutative with non-commutative,\n1586             # we want the new term to come at the front just like the\n1587             # rest of this routine\n1588 \n1589             margs = [Pow(new, cdid)] + margs\n1590         return co_residual*self2.func(*margs)*self2.func(*nc)\n1591 \n1592     def _eval_nseries(self, x, n, logx):\n1593         from sympy import Order, powsimp\n1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]\n1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)\n1596         if res.has(Order):\n1597             res += Order(x**n, x)\n1598         return res\n1599 \n1600     def _eval_as_leading_term(self, x):\n1601         return self.func(*[t.as_leading_term(x) for t in self.args])\n1602 \n1603     def _eval_conjugate(self):\n1604         return self.func(*[t.conjugate() for t in self.args])\n1605 \n1606     def _eval_transpose(self):\n1607         return self.func(*[t.transpose() for t in self.args[::-1]])\n1608 \n1609     def _eval_adjoint(self):\n1610         return self.func(*[t.adjoint() for t in self.args[::-1]])\n1611 \n1612     def _sage_(self):\n1613         s = 1\n1614         for x in self.args:\n1615             s *= x._sage_()\n1616         return s\n1617 \n1618     def as_content_primitive(self, radical=False, clear=True):\n1619         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n1620         extracted from self.\n1621 \n1622         Examples\n1623         ========\n1624 \n1625         >>> from sympy import sqrt\n1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n1627         (6, -sqrt(2)*(-sqrt(2) + 1))\n1628 \n1629         See docstring of Expr.as_content_primitive for more examples.\n1630         \"\"\"\n1631 \n1632         coef = S.One\n1633         args = []\n1634         for i, a in enumerate(self.args):\n1635             c, p = a.as_content_primitive(radical=radical, clear=clear)\n1636             coef *= c\n1637             if p is not S.One:\n1638                 args.append(p)\n1639         # don't use self._from_args here to reconstruct args\n1640         # since there may be identical args now that should be combined\n1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n1642         return coef, self.func(*args)\n1643 \n1644     def as_ordered_factors(self, order=None):\n1645         \"\"\"Transform an expression into an ordered list of factors.\n1646 \n1647         Examples\n1648         ========\n1649 \n1650         >>> from sympy import sin, cos\n1651         >>> from sympy.abc import x, y\n1652 \n1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n1654         [2, x, y, sin(x), cos(x)]\n1655 \n1656         \"\"\"\n1657         cpart, ncpart = self.args_cnc()\n1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))\n1659         return cpart + ncpart\n1660 \n1661     @property\n1662     def _sorted_args(self):\n1663         return tuple(self.as_ordered_factors())\n1664 \n1665 \n1666 def prod(a, start=1):\n1667     \"\"\"Return product of elements of a. Start with int 1 so if only\n1668        ints are included then an int result is returned.\n1669 \n1670     Examples\n1671     ========\n1672 \n1673     >>> from sympy import prod, S\n1674     >>> prod(range(3))\n1675     0\n1676     >>> type(_) is int\n1677     True\n1678     >>> prod([S(2), 3])\n1679     6\n1680     >>> _.is_Integer\n1681     True\n1682 \n1683     You can start the product at something other than 1:\n1684 \n1685     >>> prod([1, 2], 3)\n1686     6\n1687 \n1688     \"\"\"\n1689     return reduce(operator.mul, a, start)\n1690 \n1691 \n1692 def _keep_coeff(coeff, factors, clear=True, sign=False):\n1693     \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n1694 \n1695     If ``clear`` is False, do not keep the coefficient as a factor\n1696     if it can be distributed on a single factor such that one or\n1697     more terms will still have integer coefficients.\n1698 \n1699     If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n1700 \n1701     Examples\n1702     ========\n1703 \n1704     >>> from sympy.core.mul import _keep_coeff\n1705     >>> from sympy.abc import x, y\n1706     >>> from sympy import S\n1707 \n1708     >>> _keep_coeff(S.Half, x + 2)\n1709     (x + 2)/2\n1710     >>> _keep_coeff(S.Half, x + 2, clear=False)\n1711     x/2 + 1\n1712     >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n1713     y*(x + 2)/2\n1714     >>> _keep_coeff(S(-1), x + y)\n1715     -x - y\n1716     >>> _keep_coeff(S(-1), x + y, sign=True)\n1717     -(x + y)\n1718     \"\"\"\n1719 \n1720     if not coeff.is_Number:\n1721         if factors.is_Number:\n1722             factors, coeff = coeff, factors\n1723         else:\n1724             return coeff*factors\n1725     if coeff is S.One:\n1726         return factors\n1727     elif coeff is S.NegativeOne and not sign:\n1728         return -factors\n1729     elif factors.is_Add:\n1730         if not clear and coeff.is_Rational and coeff.q != 1:\n1731             q = S(coeff.q)\n1732             for i in factors.args:\n1733                 c, t = i.as_coeff_Mul()\n1734                 r = c/q\n1735                 if r == int(r):\n1736                     return coeff*factors\n1737         return Mul._from_args((coeff, factors))\n1738     elif factors.is_Mul:\n1739         margs = list(factors.args)\n1740         if margs[0].is_Number:\n1741             margs[0] *= coeff\n1742             if margs[0] == 1:\n1743                 margs.pop(0)\n1744         else:\n1745             margs.insert(0, coeff)\n1746         return Mul._from_args(margs)\n1747     else:\n1748         return coeff*factors\n1749 \n1750 \n1751 def expand_2arg(e):\n1752     from sympy.simplify.simplify import bottom_up\n1753     def do(e):\n1754         if e.is_Mul:\n1755             c, r = e.as_coeff_Mul()\n1756             if c.is_Number and r.is_Add:\n1757                 return _unevaluated_Add(*[c*ri for ri in r.args])\n1758         return e\n1759     return bottom_up(e, do)\n1760 \n1761 \n1762 from .numbers import Rational\n1763 from .power import Pow\n1764 from .add import Add, _addsort, _unevaluated_Add\n",
        "intended_behavior": "Ensure that `is_Mul` accurately identifies only true multiplication expressions without mistakenly flagging other expression types due to simplification, evaluation, or manipulation errors."
    },
    {
        "rel_file_path": "sympy/simplify/simplify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/simplify/simplify.py",
        "start": 1,
        "end": 1374,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 \n5 from sympy.core import (Basic, S, Add, Mul, Pow,\n6     Symbol, sympify, expand_mul, expand_func,\n7     Function, Dummy, Expr, factor_terms,\n8     symbols, expand_power_exp)\n9 from sympy.core.compatibility import (iterable,\n10     ordered, range, as_int)\n11 from sympy.core.numbers import Float, I, pi, Rational, Integer\n12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg\n13 from sympy.core.rules import Transform\n14 from sympy.core.evaluate import global_evaluate\n15 from sympy.functions import (\n16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)\n17 from sympy.functions.elementary.exponential import ExpBase\n18 from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n19 from sympy.functions.elementary.integers import ceiling\n20 from sympy.functions.elementary.complexes import unpolarify\n21 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n22 from sympy.functions.combinatorial.factorials import CombinatorialFunction\n23 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\n24 \n25 from sympy.utilities.iterables import has_variety\n26 \n27 from sympy.simplify.radsimp import radsimp, fraction\n28 from sympy.simplify.trigsimp import trigsimp, exptrigsimp\n29 from sympy.simplify.powsimp import powsimp\n30 from sympy.simplify.cse_opts import sub_pre, sub_post\n31 from sympy.simplify.sqrtdenest import sqrtdenest\n32 from sympy.simplify.combsimp import combsimp\n33 \n34 from sympy.polys import (together, cancel, factor)\n35 \n36 \n37 import mpmath\n38 \n39 \n40 \n41 def separatevars(expr, symbols=[], dict=False, force=False):\n42     \"\"\"\n43     Separates variables in an expression, if possible.  By\n44     default, it separates with respect to all symbols in an\n45     expression and collects constant coefficients that are\n46     independent of symbols.\n47 \n48     If dict=True then the separated terms will be returned\n49     in a dictionary keyed to their corresponding symbols.\n50     By default, all symbols in the expression will appear as\n51     keys; if symbols are provided, then all those symbols will\n52     be used as keys, and any terms in the expression containing\n53     other symbols or non-symbols will be returned keyed to the\n54     string 'coeff'. (Passing None for symbols will return the\n55     expression in a dictionary keyed to 'coeff'.)\n56 \n57     If force=True, then bases of powers will be separated regardless\n58     of assumptions on the symbols involved.\n59 \n60     Notes\n61     =====\n62     The order of the factors is determined by Mul, so that the\n63     separated expressions may not necessarily be grouped together.\n64 \n65     Although factoring is necessary to separate variables in some\n66     expressions, it is not necessary in all cases, so one should not\n67     count on the returned factors being factored.\n68 \n69     Examples\n70     ========\n71 \n72     >>> from sympy.abc import x, y, z, alpha\n73     >>> from sympy import separatevars, sin\n74     >>> separatevars((x*y)**y)\n75     (x*y)**y\n76     >>> separatevars((x*y)**y, force=True)\n77     x**y*y**y\n78 \n79     >>> e = 2*x**2*z*sin(y)+2*z*x**2\n80     >>> separatevars(e)\n81     2*x**2*z*(sin(y) + 1)\n82     >>> separatevars(e, symbols=(x, y), dict=True)\n83     {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n84     >>> separatevars(e, [x, y, alpha], dict=True)\n85     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n86 \n87     If the expression is not really separable, or is only partially\n88     separable, separatevars will do the best it can to separate it\n89     by using factoring.\n90 \n91     >>> separatevars(x + x*y - 3*x**2)\n92     -x*(3*x - y - 1)\n93 \n94     If the expression is not separable then expr is returned unchanged\n95     or (if dict=True) then None is returned.\n96 \n97     >>> eq = 2*x + y*sin(x)\n98     >>> separatevars(eq) == eq\n99     True\n100     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None\n101     True\n102 \n103     \"\"\"\n104     expr = sympify(expr)\n105     if dict:\n106         return _separatevars_dict(_separatevars(expr, force), symbols)\n107     else:\n108         return _separatevars(expr, force)\n109 \n110 \n111 def _separatevars(expr, force):\n112     if len(expr.free_symbols) == 1:\n113         return expr\n114     # don't destroy a Mul since much of the work may already be done\n115     if expr.is_Mul:\n116         args = list(expr.args)\n117         changed = False\n118         for i, a in enumerate(args):\n119             args[i] = separatevars(a, force)\n120             changed = changed or args[i] != a\n121         if changed:\n122             expr = expr.func(*args)\n123         return expr\n124 \n125     # get a Pow ready for expansion\n126     if expr.is_Pow:\n127         expr = Pow(separatevars(expr.base, force=force), expr.exp)\n128 \n129     # First try other expansion methods\n130     expr = expr.expand(mul=False, multinomial=False, force=force)\n131 \n132     _expr, reps = posify(expr) if force else (expr, {})\n133     expr = factor(_expr).subs(reps)\n134 \n135     if not expr.is_Add:\n136         return expr\n137 \n138     # Find any common coefficients to pull out\n139     args = list(expr.args)\n140     commonc = args[0].args_cnc(cset=True, warn=False)[0]\n141     for i in args[1:]:\n142         commonc &= i.args_cnc(cset=True, warn=False)[0]\n143     commonc = Mul(*commonc)\n144     commonc = commonc.as_coeff_Mul()[1]  # ignore constants\n145     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]\n146 \n147     # remove them\n148     for i, a in enumerate(args):\n149         c, nc = a.args_cnc(cset=True, warn=False)\n150         c = c - commonc_set\n151         args[i] = Mul(*c)*Mul(*nc)\n152     nonsepar = Add(*args)\n153 \n154     if len(nonsepar.free_symbols) > 1:\n155         _expr = nonsepar\n156         _expr, reps = posify(_expr) if force else (_expr, {})\n157         _expr = (factor(_expr)).subs(reps)\n158 \n159         if not _expr.is_Add:\n160             nonsepar = _expr\n161 \n162     return commonc*nonsepar\n163 \n164 \n165 def _separatevars_dict(expr, symbols):\n166     if symbols:\n167         if not all((t.is_Atom for t in symbols)):\n168             raise ValueError(\"symbols must be Atoms.\")\n169         symbols = list(symbols)\n170     elif symbols is None:\n171         return {'coeff': expr}\n172     else:\n173         symbols = list(expr.free_symbols)\n174         if not symbols:\n175             return None\n176 \n177     ret = dict(((i, []) for i in symbols + ['coeff']))\n178 \n179     for i in Mul.make_args(expr):\n180         expsym = i.free_symbols\n181         intersection = set(symbols).intersection(expsym)\n182         if len(intersection) > 1:\n183             return None\n184         if len(intersection) == 0:\n185             # There are no symbols, so it is part of the coefficient\n186             ret['coeff'].append(i)\n187         else:\n188             ret[intersection.pop()].append(i)\n189 \n190     # rebuild\n191     for k, v in ret.items():\n192         ret[k] = Mul(*v)\n193 \n194     return ret\n195 \n196 \n197 def _is_sum_surds(p):\n198     args = p.args if p.is_Add else [p]\n199     for y in args:\n200         if not ((y**2).is_Rational and y.is_real):\n201             return False\n202     return True\n203 \n204 \n205 def posify(eq):\n206     \"\"\"Return eq (with generic symbols made positive) and a\n207     dictionary containing the mapping between the old and new\n208     symbols.\n209 \n210     Any symbol that has positive=None will be replaced with a positive dummy\n211     symbol having the same name. This replacement will allow more symbolic\n212     processing of expressions, especially those involving powers and\n213     logarithms.\n214 \n215     A dictionary that can be sent to subs to restore eq to its original\n216     symbols is also returned.\n217 \n218     >>> from sympy import posify, Symbol, log, solve\n219     >>> from sympy.abc import x\n220     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n221     (_x + n + p, {_x: x})\n222 \n223     >>> eq = 1/x\n224     >>> log(eq).expand()\n225     log(1/x)\n226     >>> log(posify(eq)[0]).expand()\n227     -log(_x)\n228     >>> p, rep = posify(eq)\n229     >>> log(p).expand().subs(rep)\n230     -log(x)\n231 \n232     It is possible to apply the same transformations to an iterable\n233     of expressions:\n234 \n235     >>> eq = x**2 - 4\n236     >>> solve(eq, x)\n237     [-2, 2]\n238     >>> eq_x, reps = posify([eq, x]); eq_x\n239     [_x**2 - 4, _x]\n240     >>> solve(*eq_x)\n241     [2]\n242     \"\"\"\n243     eq = sympify(eq)\n244     if iterable(eq):\n245         f = type(eq)\n246         eq = list(eq)\n247         syms = set()\n248         for e in eq:\n249             syms = syms.union(e.atoms(Symbol))\n250         reps = {}\n251         for s in syms:\n252             reps.update(dict((v, k) for k, v in posify(s)[1].items()))\n253         for i, e in enumerate(eq):\n254             eq[i] = e.subs(reps)\n255         return f(eq), {r: s for s, r in reps.items()}\n256 \n257     reps = dict([(s, Dummy(s.name, positive=True))\n258                  for s in eq.free_symbols if s.is_positive is None])\n259     eq = eq.subs(reps)\n260     return eq, {r: s for s, r in reps.items()}\n261 \n262 \n263 def hypersimp(f, k):\n264     \"\"\"Given combinatorial term f(k) simplify its consecutive term ratio\n265        i.e. f(k+1)/f(k).  The input term can be composed of functions and\n266        integer sequences which have equivalent representation in terms\n267        of gamma special function.\n268 \n269        The algorithm performs three basic steps:\n270 \n271        1. Rewrite all functions in terms of gamma, if possible.\n272 \n273        2. Rewrite all occurrences of gamma in terms of products\n274           of gamma and rising factorial with integer,  absolute\n275           constant exponent.\n276 \n277        3. Perform simplification of nested fractions, powers\n278           and if the resulting expression is a quotient of\n279           polynomials, reduce their total degree.\n280 \n281        If f(k) is hypergeometric then as result we arrive with a\n282        quotient of polynomials of minimal degree. Otherwise None\n283        is returned.\n284 \n285        For more information on the implemented algorithm refer to:\n286 \n287        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,\n288           Journal of Symbolic Computation (1995) 20, 399-417\n289     \"\"\"\n290     f = sympify(f)\n291 \n292     g = f.subs(k, k + 1) / f\n293 \n294     g = g.rewrite(gamma)\n295     g = expand_func(g)\n296     g = powsimp(g, deep=True, combine='exp')\n297 \n298     if g.is_rational_function(k):\n299         return simplify(g, ratio=S.Infinity)\n300     else:\n301         return None\n302 \n303 \n304 def hypersimilar(f, g, k):\n305     \"\"\"Returns True if 'f' and 'g' are hyper-similar.\n306 \n307        Similarity in hypergeometric sense means that a quotient of\n308        f(k) and g(k) is a rational function in k.  This procedure\n309        is useful in solving recurrence relations.\n310 \n311        For more information see hypersimp().\n312 \n313     \"\"\"\n314     f, g = list(map(sympify, (f, g)))\n315 \n316     h = (f/g).rewrite(gamma)\n317     h = h.expand(func=True, basic=False)\n318 \n319     return h.is_rational_function(k)\n320 \n321 \n322 def signsimp(expr, evaluate=None):\n323     \"\"\"Make all Add sub-expressions canonical wrt sign.\n324 \n325     If an Add subexpression, ``a``, can have a sign extracted,\n326     as determined by could_extract_minus_sign, it is replaced\n327     with Mul(-1, a, evaluate=False). This allows signs to be\n328     extracted from powers and products.\n329 \n330     Examples\n331     ========\n332 \n333     >>> from sympy import signsimp, exp, symbols\n334     >>> from sympy.abc import x, y\n335     >>> i = symbols('i', odd=True)\n336     >>> n = -1 + 1/x\n337     >>> n/x/(-n)**2 - 1/n/x\n338     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n339     >>> signsimp(_)\n340     0\n341     >>> x*n + x*-n\n342     x*(-1 + 1/x) + x*(1 - 1/x)\n343     >>> signsimp(_)\n344     0\n345 \n346     Since powers automatically handle leading signs\n347 \n348     >>> (-2)**i\n349     -2**i\n350 \n351     signsimp can be used to put the base of a power with an integer\n352     exponent into canonical form:\n353 \n354     >>> n**i\n355     (-1 + 1/x)**i\n356 \n357     By default, signsimp doesn't leave behind any hollow simplification:\n358     if making an Add canonical wrt sign didn't change the expression, the\n359     original Add is restored. If this is not desired then the keyword\n360     ``evaluate`` can be set to False:\n361 \n362     >>> e = exp(y - x)\n363     >>> signsimp(e) == e\n364     True\n365     >>> signsimp(e, evaluate=False)\n366     exp(-(x - y))\n367 \n368     \"\"\"\n369     if evaluate is None:\n370         evaluate = global_evaluate[0]\n371     expr = sympify(expr)\n372     if not isinstance(expr, Expr) or expr.is_Atom:\n373         return expr\n374     e = sub_post(sub_pre(expr))\n375     if not isinstance(e, Expr) or e.is_Atom:\n376         return e\n377     if e.is_Add:\n378         return e.func(*[signsimp(a) for a in e.args])\n379     if evaluate:\n380         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n381     return e\n382 \n383 \n384 def simplify(expr, ratio=1.7, measure=count_ops, fu=False):\n385     \"\"\"\n386     Simplifies the given expression.\n387 \n388     Simplification is not a well defined term and the exact strategies\n389     this function tries can change in the future versions of SymPy. If\n390     your algorithm relies on \"simplification\" (whatever it is), try to\n391     determine what you need exactly  -  is it powsimp()?, radsimp()?,\n392     together()?, logcombine()?, or something else? And use this particular\n393     function directly, because those are well defined and thus your algorithm\n394     will be robust.\n395 \n396     Nonetheless, especially for interactive use, or when you don't know\n397     anything about the structure of the expression, simplify() tries to apply\n398     intelligent heuristics to make the input expression \"simpler\".  For\n399     example:\n400 \n401     >>> from sympy import simplify, cos, sin\n402     >>> from sympy.abc import x, y\n403     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n404     >>> a\n405     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n406     >>> simplify(a)\n407     x + 1\n408 \n409     Note that we could have obtained the same result by using specific\n410     simplification functions:\n411 \n412     >>> from sympy import trigsimp, cancel\n413     >>> trigsimp(a)\n414     (x**2 + x)/x\n415     >>> cancel(_)\n416     x + 1\n417 \n418     In some cases, applying :func:`simplify` may actually result in some more\n419     complicated expression. The default ``ratio=1.7`` prevents more extreme\n420     cases: if (result length)/(input length) > ratio, then input is returned\n421     unmodified.  The ``measure`` parameter lets you specify the function used\n422     to determine how complex an expression is.  The function should take a\n423     single argument as an expression and return a number such that if\n424     expression ``a`` is more complex than expression ``b``, then\n425     ``measure(a) > measure(b)``.  The default measure function is\n426     :func:`count_ops`, which returns the total number of operations in the\n427     expression.\n428 \n429     For example, if ``ratio=1``, ``simplify`` output can't be longer\n430     than input.\n431 \n432     ::\n433 \n434         >>> from sympy import sqrt, simplify, count_ops, oo\n435         >>> root = 1/(sqrt(2)+3)\n436 \n437     Since ``simplify(root)`` would result in a slightly longer expression,\n438     root is returned unchanged instead::\n439 \n440        >>> simplify(root, ratio=1) == root\n441        True\n442 \n443     If ``ratio=oo``, simplify will be applied anyway::\n444 \n445         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n446         True\n447 \n448     Note that the shortest expression is not necessary the simplest, so\n449     setting ``ratio`` to 1 may not be a good idea.\n450     Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n451     choice.\n452 \n453     You can easily define your own measure function based on what you feel\n454     should represent the \"size\" or \"complexity\" of the input expression.  Note\n455     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n456     good metrics, but have other problems (in this case, the measure function\n457     may slow down simplify too much for very large expressions).  If you don't\n458     know what a good metric would be, the default, ``count_ops``, is a good\n459     one.\n460 \n461     For example:\n462 \n463     >>> from sympy import symbols, log\n464     >>> a, b = symbols('a b', positive=True)\n465     >>> g = log(a) + log(b) + log(a)*log(1/b)\n466     >>> h = simplify(g)\n467     >>> h\n468     log(a*b**(-log(a) + 1))\n469     >>> count_ops(g)\n470     8\n471     >>> count_ops(h)\n472     5\n473 \n474     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n475     However, we may not like how ``simplify`` (in this case, using\n476     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n477     to reduce this would be to give more weight to powers as operations in\n478     ``count_ops``.  We can do this by using the ``visual=True`` option:\n479 \n480     >>> print(count_ops(g, visual=True))\n481     2*ADD + DIV + 4*LOG + MUL\n482     >>> print(count_ops(h, visual=True))\n483     2*LOG + MUL + POW + SUB\n484 \n485     >>> from sympy import Symbol, S\n486     >>> def my_measure(expr):\n487     ...     POW = Symbol('POW')\n488     ...     # Discourage powers by giving POW a weight of 10\n489     ...     count = count_ops(expr, visual=True).subs(POW, 10)\n490     ...     # Every other operation gets a weight of 1 (the default)\n491     ...     count = count.replace(Symbol, type(S.One))\n492     ...     return count\n493     >>> my_measure(g)\n494     8\n495     >>> my_measure(h)\n496     14\n497     >>> 15./8 > 1.7 # 1.7 is the default ratio\n498     True\n499     >>> simplify(g, measure=my_measure)\n500     -log(a)*log(b) + log(a) + log(b)\n501 \n502     Note that because ``simplify()`` internally tries many different\n503     simplification strategies and then compares them using the measure\n504     function, we get a completely different result that is still different\n505     from the input expression by doing this.\n506     \"\"\"\n507     expr = sympify(expr)\n508 \n509     try:\n510         return expr._eval_simplify(ratio=ratio, measure=measure)\n511     except AttributeError:\n512         pass\n513 \n514     original_expr = expr = signsimp(expr)\n515 \n516     from sympy.simplify.hyperexpand import hyperexpand\n517     from sympy.functions.special.bessel import BesselBase\n518     from sympy import Sum, Product\n519 \n520     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n521         return expr\n522 \n523     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n524         if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n525             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n526                isinstance(expr.args[0], expr.inverse(argindex=1)):\n527                 return simplify(expr.args[0].args[0], ratio=ratio,\n528                                 measure=measure, fu=fu)\n529         return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu)\n530                          for x in expr.args])\n531 \n532     # TODO: Apply different strategies, considering expression pattern:\n533     # is it a purely rational function? Is there any trigonometric function?...\n534     # See also https://github.com/sympy/sympy/pull/185.\n535 \n536     def shorter(*choices):\n537         '''Return the choice that has the fewest ops. In case of a tie,\n538         the expression listed first is selected.'''\n539         if not has_variety(choices):\n540             return choices[0]\n541         return min(choices, key=measure)\n542 \n543     expr = bottom_up(expr, lambda w: w.normal())\n544     expr = Mul(*powsimp(expr).as_content_primitive())\n545     _e = cancel(expr)\n546     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n547     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n548 \n549     if ratio is S.Infinity:\n550         expr = expr2\n551     else:\n552         expr = shorter(expr2, expr1, expr)\n553     if not isinstance(expr, Basic):  # XXX: temporary hack\n554         return expr\n555 \n556     expr = factor_terms(expr, sign=False)\n557 \n558     # hyperexpand automatically only works on hypergeometric terms\n559     expr = hyperexpand(expr)\n560 \n561     expr = piecewise_fold(expr)\n562 \n563     if expr.has(BesselBase):\n564         expr = besselsimp(expr)\n565 \n566     if expr.has(TrigonometricFunction) and not fu or expr.has(\n567             HyperbolicFunction):\n568         expr = trigsimp(expr, deep=True)\n569 \n570     if expr.has(log):\n571         expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n572 \n573     if expr.has(CombinatorialFunction, gamma):\n574         expr = combsimp(expr)\n575 \n576     if expr.has(Sum):\n577         expr = sum_simplify(expr)\n578 \n579     if expr.has(Product):\n580         expr = product_simplify(expr)\n581 \n582     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n583     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n584     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n585         short = exptrigsimp(short, simplify=False)\n586 \n587     # get rid of hollow 2-arg Mul factorization\n588     hollow_mul = Transform(\n589         lambda x: Mul(*x.args),\n590         lambda x:\n591         x.is_Mul and\n592         len(x.args) == 2 and\n593         x.args[0].is_Number and\n594         x.args[1].is_Add and\n595         x.is_commutative)\n596     expr = short.xreplace(hollow_mul)\n597 \n598     numer, denom = expr.as_numer_denom()\n599     if denom.is_Add:\n600         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n601         if n is not S.One:\n602             expr = (numer*n).expand()/d\n603 \n604     if expr.could_extract_minus_sign():\n605         n, d = fraction(expr)\n606         if d != 0:\n607             expr = signsimp(-n/(-d))\n608 \n609     if measure(expr) > ratio*measure(original_expr):\n610         expr = original_expr\n611 \n612     return expr\n613 \n614 \n615 def sum_simplify(s):\n616     \"\"\"Main function for Sum simplification\"\"\"\n617     from sympy.concrete.summations import Sum\n618     from sympy.core.function import expand\n619 \n620     terms = Add.make_args(expand(s))\n621     s_t = [] # Sum Terms\n622     o_t = [] # Other Terms\n623 \n624     for term in terms:\n625         if isinstance(term, Mul):\n626             other = 1\n627             sum_terms = []\n628 \n629             if not term.has(Sum):\n630                 o_t.append(term)\n631                 continue\n632 \n633             mul_terms = Mul.make_args(term)\n634             for mul_term in mul_terms:\n635                 if isinstance(mul_term, Sum):\n636                     r = mul_term._eval_simplify()\n637                     sum_terms.extend(Add.make_args(r))\n638                 else:\n639                     other = other * mul_term\n640             if len(sum_terms):\n641                 #some simplification may have happened\n642                 #use if so\n643                 s_t.append(Mul(*sum_terms) * other)\n644             else:\n645                 o_t.append(other)\n646         elif isinstance(term, Sum):\n647             #as above, we need to turn this into an add list\n648             r = term._eval_simplify()\n649             s_t.extend(Add.make_args(r))\n650         else:\n651             o_t.append(term)\n652 \n653 \n654     result = Add(sum_combine(s_t), *o_t)\n655 \n656     return result\n657 \n658 def sum_combine(s_t):\n659     \"\"\"Helper function for Sum simplification\n660 \n661        Attempts to simplify a list of sums, by combining limits / sum function's\n662        returns the simplified sum\n663     \"\"\"\n664     from sympy.concrete.summations import Sum\n665 \n666 \n667     used = [False] * len(s_t)\n668 \n669     for method in range(2):\n670         for i, s_term1 in enumerate(s_t):\n671             if not used[i]:\n672                 for j, s_term2 in enumerate(s_t):\n673                     if not used[j] and i != j:\n674                         temp = sum_add(s_term1, s_term2, method)\n675                         if isinstance(temp, Sum) or isinstance(temp, Mul):\n676                             s_t[i] = temp\n677                             s_term1 = s_t[i]\n678                             used[j] = True\n679 \n680     result = S.Zero\n681     for i, s_term in enumerate(s_t):\n682         if not used[i]:\n683             result = Add(result, s_term)\n684 \n685     return result\n686 \n687 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):\n688     \"\"\"Helper function for Sum simplification\n689 \n690        if limits is specified, \"self\" is the inner part of a sum\n691 \n692        Returns the sum with constant factors brought outside\n693     \"\"\"\n694     from sympy.core.exprtools import factor_terms\n695     from sympy.concrete.summations import Sum\n696 \n697     result = self.function if limits is None else self\n698     limits = self.limits if limits is None else limits\n699     #avoid any confusion w/ as_independent\n700     if result == 0:\n701         return S.Zero\n702 \n703     #get the summation variables\n704     sum_vars = set([limit.args[0] for limit in limits])\n705 \n706     #finally we try to factor out any common terms\n707     #and remove the from the sum if independent\n708     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)\n709     #avoid doing anything bad\n710     if not result.is_commutative:\n711         return Sum(result, *limits)\n712 \n713     i, d = retv.as_independent(*sum_vars)\n714     if isinstance(retv, Add):\n715         return i * Sum(1, *limits) + Sum(d, *limits)\n716     else:\n717         return i * Sum(d, *limits)\n718 \n719 def sum_add(self, other, method=0):\n720     \"\"\"Helper function for Sum simplification\"\"\"\n721     from sympy.concrete.summations import Sum\n722     from sympy import Mul\n723 \n724     #we know this is something in terms of a constant * a sum\n725     #so we temporarily put the constants inside for simplification\n726     #then simplify the result\n727     def __refactor(val):\n728         args = Mul.make_args(val)\n729         sumv = next(x for x in args if isinstance(x, Sum))\n730         constant = Mul(*[x for x in args if x != sumv])\n731         return Sum(constant * sumv.function, *sumv.limits)\n732 \n733     if isinstance(self, Mul):\n734         rself = __refactor(self)\n735     else:\n736         rself = self\n737 \n738     if isinstance(other, Mul):\n739         rother = __refactor(other)\n740     else:\n741         rother = other\n742 \n743     if type(rself) == type(rother):\n744         if method == 0:\n745             if rself.limits == rother.limits:\n746                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))\n747         elif method == 1:\n748             if simplify(rself.function - rother.function) == 0:\n749                 if len(rself.limits) == len(rother.limits) == 1:\n750                     i = rself.limits[0][0]\n751                     x1 = rself.limits[0][1]\n752                     y1 = rself.limits[0][2]\n753                     j = rother.limits[0][0]\n754                     x2 = rother.limits[0][1]\n755                     y2 = rother.limits[0][2]\n756 \n757                     if i == j:\n758                         if x2 == y1 + 1:\n759                             return factor_sum(Sum(rself.function, (i, x1, y2)))\n760                         elif x1 == y2 + 1:\n761                             return factor_sum(Sum(rself.function, (i, x2, y1)))\n762 \n763     return Add(self, other)\n764 \n765 \n766 def product_simplify(s):\n767     \"\"\"Main function for Product simplification\"\"\"\n768     from sympy.concrete.products import Product\n769 \n770     terms = Mul.make_args(s)\n771     p_t = [] # Product Terms\n772     o_t = [] # Other Terms\n773 \n774     for term in terms:\n775         if isinstance(term, Product):\n776             p_t.append(term)\n777         else:\n778             o_t.append(term)\n779 \n780     used = [False] * len(p_t)\n781 \n782     for method in range(2):\n783         for i, p_term1 in enumerate(p_t):\n784             if not used[i]:\n785                 for j, p_term2 in enumerate(p_t):\n786                     if not used[j] and i != j:\n787                         if isinstance(product_mul(p_term1, p_term2, method), Product):\n788                             p_t[i] = product_mul(p_term1, p_term2, method)\n789                             used[j] = True\n790 \n791     result = Mul(*o_t)\n792 \n793     for i, p_term in enumerate(p_t):\n794         if not used[i]:\n795             result = Mul(result, p_term)\n796 \n797     return result\n798 \n799 \n800 def product_mul(self, other, method=0):\n801     \"\"\"Helper function for Product simplification\"\"\"\n802     from sympy.concrete.products import Product\n803 \n804     if type(self) == type(other):\n805         if method == 0:\n806             if self.limits == other.limits:\n807                 return Product(self.function * other.function, *self.limits)\n808         elif method == 1:\n809             if simplify(self.function - other.function) == 0:\n810                 if len(self.limits) == len(other.limits) == 1:\n811                     i = self.limits[0][0]\n812                     x1 = self.limits[0][1]\n813                     y1 = self.limits[0][2]\n814                     j = other.limits[0][0]\n815                     x2 = other.limits[0][1]\n816                     y2 = other.limits[0][2]\n817 \n818                     if i == j:\n819                         if x2 == y1 + 1:\n820                             return Product(self.function, (i, x1, y2))\n821                         elif x1 == y2 + 1:\n822                             return Product(self.function, (i, x2, y1))\n823 \n824     return Mul(self, other)\n825 \n826 \n827 def _nthroot_solve(p, n, prec):\n828     \"\"\"\n829      helper function for ``nthroot``\n830      It denests ``p**Rational(1, n)`` using its minimal polynomial\n831     \"\"\"\n832     from sympy.polys.numberfields import _minimal_polynomial_sq\n833     from sympy.solvers import solve\n834     while n % 2 == 0:\n835         p = sqrtdenest(sqrt(p))\n836         n = n // 2\n837     if n == 1:\n838         return p\n839     pn = p**Rational(1, n)\n840     x = Symbol('x')\n841     f = _minimal_polynomial_sq(p, n, x)\n842     if f is None:\n843         return None\n844     sols = solve(f, x)\n845     for sol in sols:\n846         if abs(sol - pn).n() < 1./10**prec:\n847             sol = sqrtdenest(sol)\n848             if _mexpand(sol**n) == p:\n849                 return sol\n850 \n851 \n852 def logcombine(expr, force=False):\n853     \"\"\"\n854     Takes logarithms and combines them using the following rules:\n855 \n856     - log(x) + log(y) == log(x*y) if both are not negative\n857     - a*log(x) == log(x**a) if x is positive and a is real\n858 \n859     If ``force`` is True then the assumptions above will be assumed to hold if\n860     there is no assumption already in place on a quantity. For example, if\n861     ``a`` is imaginary or the argument negative, force will not perform a\n862     combination but if ``a`` is a symbol with no assumptions the change will\n863     take place.\n864 \n865     Examples\n866     ========\n867 \n868     >>> from sympy import Symbol, symbols, log, logcombine, I\n869     >>> from sympy.abc import a, x, y, z\n870     >>> logcombine(a*log(x) + log(y) - log(z))\n871     a*log(x) + log(y) - log(z)\n872     >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n873     log(x**a*y/z)\n874     >>> x,y,z = symbols('x,y,z', positive=True)\n875     >>> a = Symbol('a', real=True)\n876     >>> logcombine(a*log(x) + log(y) - log(z))\n877     log(x**a*y/z)\n878 \n879     The transformation is limited to factors and/or terms that\n880     contain logs, so the result depends on the initial state of\n881     expansion:\n882 \n883     >>> eq = (2 + 3*I)*log(x)\n884     >>> logcombine(eq, force=True) == eq\n885     True\n886     >>> logcombine(eq.expand(), force=True)\n887     log(x**2) + I*log(x**3)\n888 \n889     See Also\n890     ========\n891     posify: replace all symbols with symbols having positive assumptions\n892 \n893     \"\"\"\n894 \n895     def f(rv):\n896         if not (rv.is_Add or rv.is_Mul):\n897             return rv\n898 \n899         def gooda(a):\n900             # bool to tell whether the leading ``a`` in ``a*log(x)``\n901             # could appear as log(x**a)\n902             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow\n903                 (a.is_real or force and a.is_real is not False))\n904 \n905         def goodlog(l):\n906             # bool to tell whether log ``l``'s argument can combine with others\n907             a = l.args[0]\n908             return a.is_positive or force and a.is_nonpositive is not False\n909 \n910         other = []\n911         logs = []\n912         log1 = defaultdict(list)\n913         for a in Add.make_args(rv):\n914             if a.func is log and goodlog(a):\n915                 log1[()].append(([], a))\n916             elif not a.is_Mul:\n917                 other.append(a)\n918             else:\n919                 ot = []\n920                 co = []\n921                 lo = []\n922                 for ai in a.args:\n923                     if ai.is_Rational and ai < 0:\n924                         ot.append(S.NegativeOne)\n925                         co.append(-ai)\n926                     elif ai.func is log and goodlog(ai):\n927                         lo.append(ai)\n928                     elif gooda(ai):\n929                         co.append(ai)\n930                     else:\n931                         ot.append(ai)\n932                 if len(lo) > 1:\n933                     logs.append((ot, co, lo))\n934                 elif lo:\n935                     log1[tuple(ot)].append((co, lo[0]))\n936                 else:\n937                     other.append(a)\n938 \n939         # if there is only one log at each coefficient and none have\n940         # an exponent to place inside the log then there is nothing to do\n941         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):\n942             return rv\n943 \n944         # collapse multi-logs as far as possible in a canonical way\n945         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?\n946         # -- in this case, it's unambiguous, but if it were were a log(c) in\n947         # each term then it's arbitrary whether they are grouped by log(a) or\n948         # by log(c). So for now, just leave this alone; it's probably better to\n949         # let the user decide\n950         for o, e, l in logs:\n951             l = list(ordered(l))\n952             e = log(l.pop(0).args[0]**Mul(*e))\n953             while l:\n954                 li = l.pop(0)\n955                 e = log(li.args[0]**e)\n956             c, l = Mul(*o), e\n957             if l.func is log:  # it should be, but check to be sure\n958                 log1[(c,)].append(([], l))\n959             else:\n960                 other.append(c*l)\n961 \n962         # logs that have the same coefficient can multiply\n963         for k in list(log1.keys()):\n964             log1[Mul(*k)] = log(logcombine(Mul(*[\n965                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),\n966                 force=force))\n967 \n968         # logs that have oppositely signed coefficients can divide\n969         for k in ordered(list(log1.keys())):\n970             if not k in log1:  # already popped as -k\n971                 continue\n972             if -k in log1:\n973                 # figure out which has the minus sign; the one with\n974                 # more op counts should be the one\n975                 num, den = k, -k\n976                 if num.count_ops() > den.count_ops():\n977                     num, den = den, num\n978                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))\n979             else:\n980                 other.append(k*log1.pop(k))\n981 \n982         return Add(*other)\n983 \n984     return bottom_up(expr, f)\n985 \n986 \n987 def bottom_up(rv, F, atoms=False, nonbasic=False):\n988     \"\"\"Apply ``F`` to all expressions in an expression tree from the\n989     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n990     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n991     \"\"\"\n992     try:\n993         if rv.args:\n994             args = tuple([bottom_up(a, F, atoms, nonbasic)\n995                 for a in rv.args])\n996             if args != rv.args:\n997                 rv = rv.func(*args)\n998             rv = F(rv)\n999         elif atoms:\n1000             rv = F(rv)\n1001     except AttributeError:\n1002         if nonbasic:\n1003             try:\n1004                 rv = F(rv)\n1005             except TypeError:\n1006                 pass\n1007 \n1008     return rv\n1009 \n1010 \n1011 def besselsimp(expr):\n1012     \"\"\"\n1013     Simplify bessel-type functions.\n1014 \n1015     This routine tries to simplify bessel-type functions. Currently it only\n1016     works on the Bessel J and I functions, however. It works by looking at all\n1017     such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n1018     their polar equivalents) in front of the argument. Then, functions of\n1019     half-integer order are rewritten using strigonometric functions and\n1020     functions of integer order (> 1) are rewritten using functions\n1021     of low order.  Finally, if the expression was changed, compute\n1022     factorization of the result with factor().\n1023 \n1024     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n1025     >>> from sympy.abc import z, nu\n1026     >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n1027     exp(I*pi*nu)*besselj(nu, z)\n1028     >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n1029     exp(-I*pi*nu/2)*besselj(nu, z)\n1030     >>> besselsimp(besseli(S(-1)/2, z))\n1031     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n1032     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n1033     3*z*besseli(0, z)/2\n1034     \"\"\"\n1035     # TODO\n1036     # - better algorithm?\n1037     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...\n1038     # - use contiguity relations?\n1039 \n1040     def replacer(fro, to, factors):\n1041         factors = set(factors)\n1042 \n1043         def repl(nu, z):\n1044             if factors.intersection(Mul.make_args(z)):\n1045                 return to(nu, z)\n1046             return fro(nu, z)\n1047         return repl\n1048 \n1049     def torewrite(fro, to):\n1050         def tofunc(nu, z):\n1051             return fro(nu, z).rewrite(to)\n1052         return tofunc\n1053 \n1054     def tominus(fro):\n1055         def tofunc(nu, z):\n1056             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)\n1057         return tofunc\n1058 \n1059     orig_expr = expr\n1060 \n1061     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]\n1062     expr = expr.replace(\n1063         besselj, replacer(besselj,\n1064         torewrite(besselj, besseli), ifactors))\n1065     expr = expr.replace(\n1066         besseli, replacer(besseli,\n1067         torewrite(besseli, besselj), ifactors))\n1068 \n1069     minusfactors = [-1, exp_polar(I*pi)]\n1070     expr = expr.replace(\n1071         besselj, replacer(besselj, tominus(besselj), minusfactors))\n1072     expr = expr.replace(\n1073         besseli, replacer(besseli, tominus(besseli), minusfactors))\n1074 \n1075     z0 = Dummy('z')\n1076 \n1077     def expander(fro):\n1078         def repl(nu, z):\n1079             if (nu % 1) == S(1)/2:\n1080                 return exptrigsimp(trigsimp(unpolarify(\n1081                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(\n1082                             func=True)).subs(z0, z)))\n1083             elif nu.is_Integer and nu > 1:\n1084                 return fro(nu, z).expand(func=True)\n1085             return fro(nu, z)\n1086         return repl\n1087 \n1088     expr = expr.replace(besselj, expander(besselj))\n1089     expr = expr.replace(bessely, expander(bessely))\n1090     expr = expr.replace(besseli, expander(besseli))\n1091     expr = expr.replace(besselk, expander(besselk))\n1092 \n1093     if expr != orig_expr:\n1094         expr = expr.factor()\n1095 \n1096     return expr\n1097 \n1098 \n1099 def nthroot(expr, n, max_len=4, prec=15):\n1100     \"\"\"\n1101     compute a real nth-root of a sum of surds\n1102 \n1103     Parameters\n1104     ==========\n1105 \n1106     expr : sum of surds\n1107     n : integer\n1108     max_len : maximum number of surds passed as constants to ``nsimplify``\n1109 \n1110     Algorithm\n1111     =========\n1112 \n1113     First ``nsimplify`` is used to get a candidate root; if it is not a\n1114     root the minimal polynomial is computed; the answer is one of its\n1115     roots.\n1116 \n1117     Examples\n1118     ========\n1119 \n1120     >>> from sympy.simplify.simplify import nthroot\n1121     >>> from sympy import Rational, sqrt\n1122     >>> nthroot(90 + 34*sqrt(7), 3)\n1123     sqrt(7) + 3\n1124 \n1125     \"\"\"\n1126     expr = sympify(expr)\n1127     n = sympify(n)\n1128     p = expr**Rational(1, n)\n1129     if not n.is_integer:\n1130         return p\n1131     if not _is_sum_surds(expr):\n1132         return p\n1133     surds = []\n1134     coeff_muls = [x.as_coeff_Mul() for x in expr.args]\n1135     for x, y in coeff_muls:\n1136         if not x.is_rational:\n1137             return p\n1138         if y is S.One:\n1139             continue\n1140         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):\n1141             return p\n1142         surds.append(y)\n1143     surds.sort()\n1144     surds = surds[:max_len]\n1145     if expr < 0 and n % 2 == 1:\n1146         p = (-expr)**Rational(1, n)\n1147         a = nsimplify(p, constants=surds)\n1148         res = a if _mexpand(a**n) == _mexpand(-expr) else p\n1149         return -res\n1150     a = nsimplify(p, constants=surds)\n1151     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):\n1152         return _mexpand(a)\n1153     expr = _nthroot_solve(expr, n, prec)\n1154     if expr is None:\n1155         return p\n1156     return expr\n1157 \n1158 \n1159 def nsimplify(expr, constants=[], tolerance=None, full=False, rational=None):\n1160     \"\"\"\n1161     Find a simple representation for a number or, if there are free symbols or\n1162     if rational=True, then replace Floats with their Rational equivalents. If\n1163     no change is made and rational is not False then Floats will at least be\n1164     converted to Rationals.\n1165 \n1166     For numerical expressions, a simple formula that numerically matches the\n1167     given numerical expression is sought (and the input should be possible\n1168     to evalf to a precision of at least 30 digits).\n1169 \n1170     Optionally, a list of (rationally independent) constants to\n1171     include in the formula may be given.\n1172 \n1173     A lower tolerance may be set to find less exact matches. If no tolerance\n1174     is given then the least precise value will set the tolerance (e.g. Floats\n1175     default to 15 digits of precision, so would be tolerance=10**-15).\n1176 \n1177     With full=True, a more extensive search is performed\n1178     (this is useful to find simpler numbers when the tolerance\n1179     is set low).\n1180 \n1181     Examples\n1182     ========\n1183 \n1184     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi\n1185     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n1186     -2 + 2*GoldenRatio\n1187     >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n1188     1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n1189     >>> nsimplify(I**I, [pi])\n1190     exp(-pi/2)\n1191     >>> nsimplify(pi, tolerance=0.01)\n1192     22/7\n1193 \n1194     See Also\n1195     ========\n1196     sympy.core.function.nfloat\n1197 \n1198     \"\"\"\n1199     try:\n1200         return sympify(as_int(expr))\n1201     except (TypeError, ValueError):\n1202         pass\n1203     expr = sympify(expr).xreplace({\n1204         Float('inf'): S.Infinity,\n1205         Float('-inf'): S.NegativeInfinity,\n1206         })\n1207     if expr is S.Infinity or expr is S.NegativeInfinity:\n1208         return expr\n1209     if rational or expr.free_symbols:\n1210         return _real_to_rational(expr, tolerance)\n1211 \n1212     # SymPy's default tolerance for Rationals is 15; other numbers may have\n1213     # lower tolerances set, so use them to pick the largest tolerance if None\n1214     # was given\n1215     if tolerance is None:\n1216         tolerance = 10**-min([15] +\n1217              [mpmath.libmp.libmpf.prec_to_dps(n._prec)\n1218              for n in expr.atoms(Float)])\n1219     # XXX should prec be set independent of tolerance or should it be computed\n1220     # from tolerance?\n1221     prec = 30\n1222     bprec = int(prec*3.33)\n1223 \n1224     constants_dict = {}\n1225     for constant in constants:\n1226         constant = sympify(constant)\n1227         v = constant.evalf(prec)\n1228         if not v.is_Float:\n1229             raise ValueError(\"constants must be real-valued\")\n1230         constants_dict[str(constant)] = v._to_mpmath(bprec)\n1231 \n1232     exprval = expr.evalf(prec, chop=True)\n1233     re, im = exprval.as_real_imag()\n1234 \n1235     # safety check to make sure that this evaluated to a number\n1236     if not (re.is_Number and im.is_Number):\n1237         return expr\n1238 \n1239     def nsimplify_real(x):\n1240         orig = mpmath.mp.dps\n1241         xv = x._to_mpmath(bprec)\n1242         try:\n1243             # We'll be happy with low precision if a simple fraction\n1244             if not (tolerance or full):\n1245                 mpmath.mp.dps = 15\n1246                 rat = mpmath.pslq([xv, 1])\n1247                 if rat is not None:\n1248                     return Rational(-int(rat[1]), int(rat[0]))\n1249             mpmath.mp.dps = prec\n1250             newexpr = mpmath.identify(xv, constants=constants_dict,\n1251                 tol=tolerance, full=full)\n1252             if not newexpr:\n1253                 raise ValueError\n1254             if full:\n1255                 newexpr = newexpr[0]\n1256             expr = sympify(newexpr)\n1257             if x and not expr:  # don't let x become 0\n1258                 raise ValueError\n1259             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:\n1260                 raise ValueError\n1261             return expr\n1262         finally:\n1263             # even though there are returns above, this is executed\n1264             # before leaving\n1265             mpmath.mp.dps = orig\n1266     try:\n1267         if re:\n1268             re = nsimplify_real(re)\n1269         if im:\n1270             im = nsimplify_real(im)\n1271     except ValueError:\n1272         if rational is None:\n1273             return _real_to_rational(expr)\n1274         return expr\n1275 \n1276     rv = re + im*S.ImaginaryUnit\n1277     # if there was a change or rational is explicitly not wanted\n1278     # return the value, else return the Rational representation\n1279     if rv != expr or rational is False:\n1280         return rv\n1281     return _real_to_rational(expr)\n1282 \n1283 \n1284 def _real_to_rational(expr, tolerance=None):\n1285     \"\"\"\n1286     Replace all reals in expr with rationals.\n1287 \n1288     >>> from sympy import nsimplify\n1289     >>> from sympy.abc import x\n1290 \n1291     >>> nsimplify(.76 + .1*x**.5, rational=True)\n1292     sqrt(x)/10 + 19/25\n1293 \n1294     \"\"\"\n1295     inf = Float('inf')\n1296     p = expr\n1297     reps = {}\n1298     reduce_num = None\n1299     if tolerance is not None and tolerance < 1:\n1300         reduce_num = ceiling(1/tolerance)\n1301     for float in p.atoms(Float):\n1302         key = float\n1303         if reduce_num is not None:\n1304             r = Rational(float).limit_denominator(reduce_num)\n1305         elif (tolerance is not None and tolerance >= 1 and\n1306                 float.is_Integer is False):\n1307             r = Rational(tolerance*round(float/tolerance)\n1308                 ).limit_denominator(int(tolerance))\n1309         else:\n1310             r = nsimplify(float, rational=False)\n1311             # e.g. log(3).n() -> log(3) instead of a Rational\n1312             if float and not r:\n1313                 r = Rational(float)\n1314             elif not r.is_Rational:\n1315                 if float == inf or float == -inf:\n1316                     r = S.ComplexInfinity\n1317                 elif float < 0:\n1318                     float = -float\n1319                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))\n1320                     r = -Rational(str(float/d))*d\n1321                 elif float > 0:\n1322                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))\n1323                     r = Rational(str(float/d))*d\n1324                 else:\n1325                     r = Integer(0)\n1326         reps[key] = r\n1327     return p.subs(reps, simultaneous=True)\n1328 \n1329 \n1330 def clear_coefficients(expr, rhs=S.Zero):\n1331     \"\"\"Return `p, r` where `p` is the expression obtained when Rational\n1332     additive and multiplicative coefficients of `expr` have been stripped\n1333     away in a naive fashion (i.e. without simplification). The operations\n1334     needed to remove the coefficients will be applied to `rhs` and returned\n1335     as `r`.\n1336 \n1337     Examples\n1338     ========\n1339 \n1340     >>> from sympy.simplify.simplify import clear_coefficients\n1341     >>> from sympy.abc import x, y\n1342     >>> from sympy import Dummy\n1343     >>> expr = 4*y*(6*x + 3)\n1344     >>> clear_coefficients(expr - 2)\n1345     (y*(2*x + 1), 1/6)\n1346 \n1347     When solving 2 or more expressions like `expr = a`,\n1348     `expr = b`, etc..., it is advantageous to provide a Dummy symbol\n1349     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.\n1350 \n1351     >>> rhs = Dummy('rhs')\n1352     >>> clear_coefficients(expr, rhs)\n1353     (y*(2*x + 1), _rhs/12)\n1354     >>> _[1].subs(rhs, 2)\n1355     1/6\n1356     \"\"\"\n1357     was = None\n1358     free = expr.free_symbols\n1359     if expr.is_Rational:\n1360         return (S.Zero, rhs - expr)\n1361     while expr and was != expr:\n1362         was = expr\n1363         m, expr = (\n1364             expr.as_content_primitive()\n1365             if free else\n1366             factor_terms(expr).as_coeff_Mul(rational=True))\n1367         rhs /= m\n1368         c, expr = expr.as_coeff_Add(rational=True)\n1369         rhs -= c\n1370     expr = signsimp(expr, evaluate = False)\n1371     if _coeff_isneg(expr):\n1372         expr = -expr\n1373         rhs = -rhs\n1374     return expr, rhs\n",
        "intended_behavior": "Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself."
    },
    {
        "rel_file_path": "sympy/simplify/combsimp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/simplify/combsimp.py",
        "start": 1,
        "end": 513,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core import Function, S, Mul, Pow, Add\n4 from sympy.core.compatibility import ordered, default_sort_key\n5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial\n6 from sympy.functions import gamma, sqrt, sin\n7 from sympy.polys import factor, cancel\n8 \n9 from sympy.utilities.timeutils import timethis\n10 from sympy.utilities.iterables import sift\n11 from sympy.utilities.iterables import uniq\n12 \n13 \n14 \n15 @timethis('combsimp')\n16 def combsimp(expr):\n17     r\"\"\"\n18     Simplify combinatorial expressions.\n19 \n20     This function takes as input an expression containing factorials,\n21     binomials, Pochhammer symbol and other \"combinatorial\" functions,\n22     and tries to minimize the number of those functions and reduce\n23     the size of their arguments.\n24 \n25     The algorithm works by rewriting all combinatorial functions as\n26     expressions involving rising factorials (Pochhammer symbols) and\n27     applies recurrence relations and other transformations applicable\n28     to rising factorials, to reduce their arguments, possibly letting\n29     the resulting rising factorial to cancel. Rising factorials with\n30     the second argument being an integer are expanded into polynomial\n31     forms and finally all other rising factorial are rewritten in terms\n32     of more familiar functions. If the initial expression consisted of\n33     gamma functions alone, the result is expressed in terms of gamma\n34     functions. If the initial expression consists of gamma function\n35     with some other combinatorial, the result is expressed in terms of\n36     gamma functions.\n37 \n38     If the result is expressed using gamma functions, the following three\n39     additional steps are performed:\n40 \n41     1. Reduce the number of gammas by applying the reflection theorem\n42        gamma(x)*gamma(1-x) == pi/sin(pi*x).\n43     2. Reduce the number of gammas by applying the multiplication theorem\n44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\n45     3. Reduce the number of prefactors by absorbing them into gammas, where\n46        possible.\n47 \n48     All transformation rules can be found (or was derived from) here:\n49 \n50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\n51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\n52 \n53     Examples\n54     ========\n55 \n56     >>> from sympy.simplify import combsimp\n57     >>> from sympy import factorial, binomial\n58     >>> from sympy.abc import n, k\n59 \n60     >>> combsimp(factorial(n)/factorial(n - 3))\n61     n*(n - 2)*(n - 1)\n62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n63     (n + 1)/(k + 1)\n64 \n65     \"\"\"\n66 \n67     # as a rule of thumb, if the expression contained gammas initially, it\n68     # probably makes sense to retain them\n69     as_gamma = expr.has(gamma)\n70     as_factorial = expr.has(factorial)\n71     as_binomial = expr.has(binomial)\n72 \n73 \n74     expr = expr.replace(binomial,\n75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))\n76     expr = expr.replace(factorial,\n77         lambda n: _rf(1, n.expand()))\n78     expr = expr.rewrite(gamma)\n79     expr = expr.replace(gamma,\n80         lambda n: _rf(1, (n - 1).expand()))\n81 \n82     if as_gamma:\n83         expr = expr.replace(_rf,\n84             lambda a, b: gamma(a + b)/gamma(a))\n85     else:\n86         expr = expr.replace(_rf,\n87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))\n88 \n89     def rule(n, k):\n90         coeff, rewrite = S.One, False\n91 \n92         cn, _n = n.as_coeff_Add()\n93 \n94         if _n and cn.is_Integer and cn:\n95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)\n96             rewrite = True\n97             n = _n\n98 \n99         # this sort of binomial has already been removed by\n100         # rising factorials but is left here in case the order\n101         # of rule application is changed\n102         if k.is_Add:\n103             ck, _k = k.as_coeff_Add()\n104             if _k and ck.is_Integer and ck:\n105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)\n106                 rewrite = True\n107                 k = _k\n108 \n109         if rewrite:\n110             return coeff*binomial(n, k)\n111 \n112     expr = expr.replace(binomial, rule)\n113 \n114     def rule_gamma(expr, level=0):\n115         \"\"\" Simplify products of gamma functions further. \"\"\"\n116 \n117         if expr.is_Atom:\n118             return expr\n119 \n120         def gamma_rat(x):\n121             # helper to simplify ratios of gammas\n122             was = x.count(gamma)\n123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()\n124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))\n125             if xx.count(gamma) < was:\n126                 x = xx\n127             return x\n128 \n129         def gamma_factor(x):\n130             # return True if there is a gamma factor in shallow args\n131             if x.func is gamma:\n132                 return True\n133             if x.is_Add or x.is_Mul:\n134                 return any(gamma_factor(xi) for xi in x.args)\n135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n136                 return gamma_factor(x.base)\n137             return False\n138 \n139         # recursion step\n140         if level == 0:\n141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n142             level += 1\n143 \n144         if not expr.is_Mul:\n145             return expr\n146 \n147         # non-commutative step\n148         if level == 1:\n149             args, nc = expr.args_cnc()\n150             if not args:\n151                 return expr\n152             if nc:\n153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)\n154             level += 1\n155 \n156         # pure gamma handling, not factor absorbtion\n157         if level == 2:\n158             sifted = sift(expr.args, gamma_factor)\n159             gamma_ind = Mul(*sifted.pop(False, []))\n160             d = Mul(*sifted.pop(True, []))\n161             assert not sifted\n162 \n163             nd, dd = d.as_numer_denom()\n164             for ipass in range(2):\n165                 args = list(ordered(Mul.make_args(nd)))\n166                 for i, ni in enumerate(args):\n167                     if ni.is_Add:\n168                         ni, dd = Add(*[\n169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]\n170                             ).as_numer_denom()\n171                         args[i] = ni\n172                         if not dd.has(gamma):\n173                             break\n174                 nd = Mul(*args)\n175                 if ipass ==  0 and not gamma_factor(nd):\n176                     break\n177                 nd, dd = dd, nd  # now process in reversed order\n178             expr = gamma_ind*nd/dd\n179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n180                 return expr\n181             level += 1\n182 \n183         # iteration until constant\n184         if level == 3:\n185             while True:\n186                 was = expr\n187                 expr = rule_gamma(expr, 4)\n188                 if expr == was:\n189                     return expr\n190 \n191         numer_gammas = []\n192         denom_gammas = []\n193         numer_others = []\n194         denom_others = []\n195         def explicate(p):\n196             if p is S.One:\n197                 return None, []\n198             b, e = p.as_base_exp()\n199             if e.is_Integer:\n200                 if b.func is gamma:\n201                     return True, [b.args[0]]*e\n202                 else:\n203                     return False, [b]*e\n204             else:\n205                 return False, [p]\n206 \n207         newargs = list(ordered(expr.args))\n208         while newargs:\n209             n, d = newargs.pop().as_numer_denom()\n210             isg, l = explicate(n)\n211             if isg:\n212                 numer_gammas.extend(l)\n213             elif isg is False:\n214                 numer_others.extend(l)\n215             isg, l = explicate(d)\n216             if isg:\n217                 denom_gammas.extend(l)\n218             elif isg is False:\n219                 denom_others.extend(l)\n220 \n221         # =========== level 2 work: pure gamma manipulation =========\n222 \n223         # Try to reduce the number of gamma factors by applying the\n224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)\n225         for gammas, numer, denom in [(\n226             numer_gammas, numer_others, denom_others),\n227                 (denom_gammas, denom_others, numer_others)]:\n228             new = []\n229             while gammas:\n230                 g1 = gammas.pop()\n231                 if g1.is_integer:\n232                     new.append(g1)\n233                     continue\n234                 for i, g2 in enumerate(gammas):\n235                     n = g1 + g2 - 1\n236                     if not n.is_Integer:\n237                         continue\n238                     numer.append(S.Pi)\n239                     denom.append(sin(S.Pi*g1))\n240                     gammas.pop(i)\n241                     if n > 0:\n242                         for k in range(n):\n243                             numer.append(1 - g1 + k)\n244                     elif n < 0:\n245                         for k in range(-n):\n246                             denom.append(-g1 - k)\n247                     break\n248                 else:\n249                     new.append(g1)\n250             # /!\\ updating IN PLACE\n251             gammas[:] = new\n252 \n253         # Try to reduce the number of gammas by using the duplication\n254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =\n255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could\n256         # be done with higher argument ratios like gamma(3*x)/gamma(x),\n257         # this would not reduce the number of gammas as in this case.\n258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,\n259                                 denom_others),\n260                                (denom_gammas, numer_gammas, denom_others,\n261                                 numer_others)]:\n262 \n263             while True:\n264                 for x in ng:\n265                     for y in dg:\n266                         n = x - 2*y\n267                         if n.is_Integer:\n268                             break\n269                     else:\n270                         continue\n271                     break\n272                 else:\n273                     break\n274                 ng.remove(x)\n275                 dg.remove(y)\n276                 if n > 0:\n277                     for k in range(n):\n278                         no.append(2*y + k)\n279                 elif n < 0:\n280                     for k in range(-n):\n281                         do.append(2*y - 1 - k)\n282                 ng.append(y + S(1)/2)\n283                 no.append(2**(2*y - 1))\n284                 do.append(sqrt(S.Pi))\n285 \n286         # Try to reduce the number of gamma factors by applying the\n287         # multiplication theorem (used when n gammas with args differing\n288         # by 1/n mod 1 are encountered).\n289         #\n290         # run of 2 with args differing by 1/2\n291         #\n292         # >>> combsimp(gamma(x)*gamma(x+S.Half))\n293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)\n294         #\n295         # run of 3 args differing by 1/3 (mod 1)\n296         #\n297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))\n298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)\n299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))\n300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)\n301         #\n302         def _run(coeffs):\n303             # find runs in coeffs such that the difference in terms (mod 1)\n304             # of t1, t2, ..., tn is 1/n\n305             u = list(uniq(coeffs))\n306             for i in range(len(u)):\n307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])\n308                 for one, j in dj:\n309                     if one.p == 1 and one.q != 1:\n310                         n = one.q\n311                         got = [i]\n312                         get = list(range(1, n))\n313                         for d, j in dj:\n314                             m = n*d\n315                             if m.is_Integer and m in get:\n316                                 get.remove(m)\n317                                 got.append(j)\n318                                 if not get:\n319                                     break\n320                         else:\n321                             continue\n322                         for i, j in enumerate(got):\n323                             c = u[j]\n324                             coeffs.remove(c)\n325                             got[i] = c\n326                         return one.q, got[0], got[1:]\n327 \n328         def _mult_thm(gammas, numer, denom):\n329             # pull off and analyze the leading coefficient from each gamma arg\n330             # looking for runs in those Rationals\n331 \n332             # expr -> coeff + resid -> rats[resid] = coeff\n333             rats = {}\n334             for g in gammas:\n335                 c, resid = g.as_coeff_Add()\n336                 rats.setdefault(resid, []).append(c)\n337 \n338             # look for runs in Rationals for each resid\n339             keys = sorted(rats, key=default_sort_key)\n340             for resid in keys:\n341                 coeffs = list(sorted(rats[resid]))\n342                 new = []\n343                 while True:\n344                     run = _run(coeffs)\n345                     if run is None:\n346                         break\n347 \n348                     # process the sequence that was found:\n349                     # 1) convert all the gamma functions to have the right\n350                     #    argument (could be off by an integer)\n351                     # 2) append the factors corresponding to the theorem\n352                     # 3) append the new gamma function\n353 \n354                     n, ui, other = run\n355 \n356                     # (1)\n357                     for u in other:\n358                         con = resid + u - 1\n359                         for k in range(int(u - ui)):\n360                             numer.append(con - k)\n361 \n362                     con = n*(resid + ui)  # for (2) and (3)\n363 \n364                     # (2)\n365                     numer.append((2*S.Pi)**(S(n - 1)/2)*\n366                                  n**(S(1)/2 - con))\n367                     # (3)\n368                     new.append(con)\n369 \n370                 # restore resid to coeffs\n371                 rats[resid] = [resid + c for c in coeffs] + new\n372 \n373             # rebuild the gamma arguments\n374             g = []\n375             for resid in keys:\n376                 g += rats[resid]\n377             # /!\\ updating IN PLACE\n378             gammas[:] = g\n379 \n380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),\n381                                 (denom_gammas, denom_others, numer_others)]:\n382             _mult_thm(l, numer, denom)\n383 \n384         # =========== level >= 2 work: factor absorbtion =========\n385 \n386         if level >= 2:\n387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)\n388             # and gamma(x)/(x - 1) -> gamma(x - 1)\n389             # This code (in particular repeated calls to find_fuzzy) can be very\n390             # slow.\n391             def find_fuzzy(l, x):\n392                 if not l:\n393                     return\n394                 S1, T1 = compute_ST(x)\n395                 for y in l:\n396                     S2, T2 = inv[y]\n397                     if T1 != T2 or (not S1.intersection(S2) and\n398                                     (S1 != set() or S2 != set())):\n399                         continue\n400                     # XXX we want some simplification (e.g. cancel or\n401                     # simplify) but no matter what it's slow.\n402                     a = len(cancel(x/y).free_symbols)\n403                     b = len(x.free_symbols)\n404                     c = len(y.free_symbols)\n405                     # TODO is there a better heuristic?\n406                     if a == 0 and (b > 0 or c > 0):\n407                         return y\n408 \n409             # We thus try to avoid expensive calls by building the following\n410             # \"invariants\": For every factor or gamma function argument\n411             #   - the set of free symbols S\n412             #   - the set of functional components T\n413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset\n414             # or S1 == S2 == emptyset)\n415             inv = {}\n416 \n417             def compute_ST(expr):\n418                 if expr in inv:\n419                     return inv[expr]\n420                 return (expr.free_symbols, expr.atoms(Function).union(\n421                         set(e.exp for e in expr.atoms(Pow))))\n422 \n423             def update_ST(expr):\n424                 inv[expr] = compute_ST(expr)\n425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n426                 update_ST(expr)\n427 \n428             for gammas, numer, denom in [(\n429                 numer_gammas, numer_others, denom_others),\n430                     (denom_gammas, denom_others, numer_others)]:\n431                 new = []\n432                 while gammas:\n433                     g = gammas.pop()\n434                     cont = True\n435                     while cont:\n436                         cont = False\n437                         y = find_fuzzy(numer, g)\n438                         if y is not None:\n439                             numer.remove(y)\n440                             if y != g:\n441                                 numer.append(y/g)\n442                                 update_ST(y/g)\n443                             g += 1\n444                             cont = True\n445                         y = find_fuzzy(denom, g - 1)\n446                         if y is not None:\n447                             denom.remove(y)\n448                             if y != g - 1:\n449                                 numer.append((g - 1)/y)\n450                                 update_ST((g - 1)/y)\n451                             g -= 1\n452                             cont = True\n453                     new.append(g)\n454                 # /!\\ updating IN PLACE\n455                 gammas[:] = new\n456 \n457         # =========== rebuild expr ==================================\n458 \n459         return Mul(*[gamma(g) for g in numer_gammas]) \\\n460             / Mul(*[gamma(g) for g in denom_gammas]) \\\n461             * Mul(*numer_others) / Mul(*denom_others)\n462 \n463     # (for some reason we cannot use Basic.replace in this case)\n464     was = factor(expr)\n465     expr = rule_gamma(was)\n466     if expr != was:\n467         expr = factor(expr)\n468 \n469     if not as_gamma:\n470         if as_factorial:\n471             expr = expr.rewrite(factorial)\n472         elif as_binomial:\n473             expr = expr.rewrite(binomial)\n474 \n475     return expr\n476 \n477 class _rf(Function):\n478     @classmethod\n479     def eval(cls, a, b):\n480         if b.is_Integer:\n481             if not b:\n482                 return S.One\n483 \n484             n, result = int(b), S.One\n485 \n486             if n > 0:\n487                 for i in range(n):\n488                     result *= a + i\n489 \n490                 return result\n491             elif n < 0:\n492                 for i in range(1, -n + 1):\n493                     result *= a - i\n494 \n495                 return 1/result\n496         else:\n497             if b.is_Add:\n498                 c, _b = b.as_coeff_Add()\n499 \n500                 if c.is_Integer:\n501                     if c > 0:\n502                         return _rf(a, _b)*_rf(a + _b, c)\n503                     elif c < 0:\n504                         return _rf(a, _b)/_rf(a + _b + c, -c)\n505 \n506             if a.is_Add:\n507                 c, _a = a.as_coeff_Add()\n508 \n509                 if c.is_Integer:\n510                     if c > 0:\n511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)\n512                     elif c < 0:\n513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)\n",
        "intended_behavior": "Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself."
    }
]