2025-10-16 01:42:37.672 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 01:42:42.376 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=304, output_tokens=13, cost=0.003430
2025-10-16 01:42:48.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=484, output_tokens=217, cost=0.011350
2025-10-16 01:44:48.713 | INFO     | registered non reproducing test 0
2025-10-16 01:44:59.342 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=974, output_tokens=481, cost=0.024170
2025-10-16 01:45:00.592 | INFO     | registered non reproducing test 1
2025-10-16 01:45:14.686 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1428, output_tokens=614, cost=0.032700
2025-10-16 01:45:15.875 | INFO     | registered non reproducing test 2
2025-10-16 01:45:15.875 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 01:45:15.882 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:45:21.373 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=200, cost=0.012110
2025-10-16 01:45:21.375 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:45:23.882 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=554, output_tokens=52, cost=0.007100
2025-10-16 01:45:23.883 | DEBUG    | Extracted a valid json.
2025-10-16 01:45:23.883 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"test_issue_11230\", \"sympy/simplify/tests/test_cse.py\")",
        "search_method(\"is_Mul\")"
    ],
    "bug_locations": []
}
2025-10-16 01:45:23.886 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:45:23.886 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:45:32.912 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=988, output_tokens=359, cost=0.020650
2025-10-16 01:45:32.917 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:45:36.709 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1563, output_tokens=120, cost=0.019230
2025-10-16 01:45:36.711 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:45:38.955 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=14, cost=0.005160
2025-10-16 01:45:38.956 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:45:38.962 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:45:40.077 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=14, cost=0.005160
2025-10-16 01:45:40.078 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:45:40.078 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:45:42.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=14, cost=0.005160
2025-10-16 01:45:42.663 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:45:42.663 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:45:44.717 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=46, cost=0.006120
2025-10-16 01:45:44.717 | DEBUG    | the API call 'search_code_in_file('test_cse.py')' has wrong number of arguments. Will retry.
2025-10-16 01:45:44.717 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:45:46.367 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=34, cost=0.005760
2025-10-16 01:45:46.369 | DEBUG    | Extracted a valid json.
2025-10-16 01:45:46.369 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"is_Mul\", \"test_cse.py\")"
    ],
    "bug_locations": []
}
2025-10-16 01:45:46.372 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:45:46.373 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:45:55.547 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1825, output_tokens=411, cost=0.030580
2025-10-16 01:45:55.552 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:45:59.104 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2452, output_tokens=134, cost=0.028540
2025-10-16 01:45:59.106 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:46:02.118 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-16 01:46:02.119 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:02.120 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:46:03.309 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-16 01:46:03.310 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:03.310 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:46:05.016 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-16 01:46:05.017 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:05.017 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:46:06.001 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-16 01:46:06.002 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:06.002 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:46:08.378 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=14, cost=0.005300
2025-10-16 01:46:08.379 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:08.379 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:46:08.379 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:46:08.380 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:46:08.380 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:46:13.818 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2613, output_tokens=230, cost=0.033030
2025-10-16 01:46:13.825 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:46:17.003 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=14, cost=0.006260
2025-10-16 01:46:17.004 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:17.004 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:46:18.207 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=14, cost=0.006260
2025-10-16 01:46:18.208 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:18.208 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:46:20.136 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=14, cost=0.006260
2025-10-16 01:46:20.136 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:20.136 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:46:23.537 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=14, cost=0.006260
2025-10-16 01:46:23.537 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:23.538 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:46:25.751 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=584, output_tokens=14, cost=0.006260
2025-10-16 01:46:25.752 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:25.752 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:46:25.752 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:46:25.753 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:46:25.753 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:46:31.950 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2870, output_tokens=192, cost=0.034460
2025-10-16 01:46:31.954 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:46:34.372 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=14, cost=0.005880
2025-10-16 01:46:34.373 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:34.373 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:46:35.483 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=14, cost=0.005880
2025-10-16 01:46:35.483 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:35.483 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:46:36.611 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=14, cost=0.005880
2025-10-16 01:46:36.612 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:36.612 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:46:39.785 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=14, cost=0.005880
2025-10-16 01:46:39.786 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:39.793 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:46:40.974 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=14, cost=0.005880
2025-10-16 01:46:40.974 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:46:40.974 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:46:40.975 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:46:40.975 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:46:40.975 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:46:44.947 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3089, output_tokens=121, cost=0.034520
2025-10-16 01:46:44.954 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:46:47.367 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=475, output_tokens=33, cost=0.005740
2025-10-16 01:46:47.368 | DEBUG    | Extracted a valid json.
2025-10-16 01:46:47.368 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"test_issue_11230\")", "search_code(\"is_Mul\")"],
    "bug_locations": []
}
2025-10-16 01:46:47.710 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:46:47.710 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:46:59.978 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4419, output_tokens=562, cost=0.061050
2025-10-16 01:46:59.983 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:47:11.177 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5197, output_tokens=469, cost=0.066040
2025-10-16 01:47:11.181 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:47:15.460 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=161, cost=0.013060
2025-10-16 01:47:15.461 | DEBUG    | Extracted a valid json.
2025-10-16 01:47:15.461 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "test_cse.py", "class": "", "method": "test_issue_11230", "intended_behavior": "The `is_Mul` property/method accurately reflects the presence of a multiplication operation within an expression. Any simplification, manipulation, or evaluation process (possibly involving the `cse` method in this context) should maintain the integrity of the mathematical expressions, such that `is_Mul` only returns `true` for genuine multiplication operations. The test case `test_issue_11230` should validate that the common subexpression elimination (CSE) or related simplification processes do not introduce incorrect multiplication structures (`is_Mul` being true) unless it is a valid result of the operation."}]
}
2025-10-16 01:47:15.463 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-16 01:47:15.464 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:47:15.464 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:47:25.289 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5700, output_tokens=385, cost=0.068550
2025-10-16 01:47:25.292 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:47:27.186 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=14, cost=0.007810
2025-10-16 01:47:27.187 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:47:27.188 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:47:28.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=14, cost=0.007810
2025-10-16 01:47:28.307 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:47:28.307 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:47:29.959 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=14, cost=0.007810
2025-10-16 01:47:29.960 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:47:29.960 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:47:30.989 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=14, cost=0.007810
2025-10-16 01:47:30.990 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:47:30.990 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:47:33.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=14, cost=0.007810
2025-10-16 01:47:33.045 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:47:33.051 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:47:33.051 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:47:33.052 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:47:33.052 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:47:47.974 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6112, output_tokens=577, cost=0.078430
2025-10-16 01:47:47.983 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:47:50.436 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=76, cost=0.011590
2025-10-16 01:47:50.437 | DEBUG    | Extracted a valid json.
2025-10-16 01:47:50.437 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"test_issue_11230\", \"test_cse.py\")",
        "search_method_in_file(\"is_Mul\", \"test_cse.py\")",
        "search_code(\"test_issue_11230\")",
        "search_code(\"is_Mul\")"
    ],
    "bug_locations": []
}
2025-10-16 01:47:50.750 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:47:50.751 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:48:05.796 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7962, output_tokens=648, cost=0.099060
2025-10-16 01:48:05.802 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:48:19.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8826, output_tokens=442, cost=0.101520
2025-10-16 01:48:19.851 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:48:26.830 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=796, output_tokens=248, cost=0.015400
2025-10-16 01:48:26.831 | DEBUG    | Extracted a valid json.
2025-10-16 01:48:26.831 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/mul.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that `is_Mul` accurately identifies only true multiplication expressions without mistakenly flagging other expression types due to simplification, evaluation, or manipulation errors."
        },
        {
            "file": "sympy/simplify/simplify.py",
            "class": "",
            "method": "",
            "intended_behavior": "Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself."
        },
        {
            "file": "sympy/simplify/combsimp.py",
            "class": "",
            "method": "",
            "intended_behavior": "Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself."
        }
    ]
}
2025-10-16 01:48:26.836 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/mul.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 from functools import cmp_to_key
5 import operator
6 
7 from .sympify import sympify
8 from .basic import Basic
9 from .singleton import S
10 from .operations import AssocOp
11 from .cache import cacheit
12 from .logic import fuzzy_not, _fuzzy_group
13 from .compatibility import reduce, range
14 from .expr import Expr
15 
16 # internal marker to indicate:
17 #   "there are still non-commutative objects -- don't forget to process them"
18 
19 
20 class NC_Marker:
21     is_Order = False
22     is_Mul = False
23     is_Number = False
24     is_Poly = False
25 
26     is_commutative = False
27 
28 
29 # Key for sorting commutative args in canonical order
30 _args_sortkey = cmp_to_key(Basic.compare)
31 def _mulsort(args):
32     # in-place sorting of args
33     args.sort(key=_args_sortkey)
34 
35 
36 def _unevaluated_Mul(*args):
37     """Return a well-formed unevaluated Mul: Numbers are collected and
38     put in slot 0, any arguments that are Muls will be flattened, and args
39     are sorted. Use this when args have changed but you still want to return
40     an unevaluated Mul.
41 
42     Examples
43     ========
44 
45     >>> from sympy.core.mul import _unevaluated_Mul as uMul
46     >>> from sympy import S, sqrt, Mul
47     >>> from sympy.abc import x
48     >>> a = uMul(*[S(3.0), x, S(2)])
49     >>> a.args[0]
50     6.00000000000000
51     >>> a.args[1]
52     x
53 
54     Two unevaluated Muls with the same arguments will
55     always compare as equal during testing:
56 
57     >>> m = uMul(sqrt(2), sqrt(3))
58     >>> m == uMul(sqrt(3), sqrt(2))
59     True
60     >>> u = Mul(sqrt(3), sqrt(2), evaluate=False)
61     >>> m == uMul(u)
62     True
63     >>> m == Mul(*m.args)
64     False
65 
66     """
67     args = list(args)
68     newargs = []
69     ncargs = []
70     co = S.One
71     while args:
72         a = args.pop()
73         if a.is_Mul:
74             c, nc = a.args_cnc()
75             args.extend(c)
76             if nc:
77                 ncargs.append(Mul._from_args(nc))
78         elif a.is_Number:
79             co *= a
80         else:
81             newargs.append(a)
82     _mulsort(newargs)
83     if co is not S.One:
84         newargs.insert(0, co)
85     if ncargs:
86         newargs.append(Mul._from_args(ncargs))
87     return Mul._from_args(newargs)
88 
89 
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())
1664 
1665 
1666 def prod(a, start=1):
1667     """Return product of elements of a. Start with int 1 so if only
1668        ints are included then an int result is returned.
1669 
1670     Examples
1671     ========
1672 
1673     >>> from sympy import prod, S
1674     >>> prod(range(3))
1675     0
1676     >>> type(_) is int
1677     True
1678     >>> prod([S(2), 3])
1679     6
1680     >>> _.is_Integer
1681     True
1682 
1683     You can start the product at something other than 1:
1684 
1685     >>> prod([1, 2], 3)
1686     6
1687 
1688     """
1689     return reduce(operator.mul, a, start)
1690 
1691 
1692 def _keep_coeff(coeff, factors, clear=True, sign=False):
1693     """Return ``coeff*factors`` unevaluated if necessary.
1694 
1695     If ``clear`` is False, do not keep the coefficient as a factor
1696     if it can be distributed on a single factor such that one or
1697     more terms will still have integer coefficients.
1698 
1699     If ``sign`` is True, allow a coefficient of -1 to remain factored out.
1700 
1701     Examples
1702     ========
1703 
1704     >>> from sympy.core.mul import _keep_coeff
1705     >>> from sympy.abc import x, y
1706     >>> from sympy import S
1707 
1708     >>> _keep_coeff(S.Half, x + 2)
1709     (x + 2)/2
1710     >>> _keep_coeff(S.Half, x + 2, clear=False)
1711     x/2 + 1
1712     >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)
1713     y*(x + 2)/2
1714     >>> _keep_coeff(S(-1), x + y)
1715     -x - y
1716     >>> _keep_coeff(S(-1), x + y, sign=True)
1717     -(x + y)
1718     """
1719 
1720     if not coeff.is_Number:
1721         if factors.is_Number:
1722             factors, coeff = coeff, factors
1723         else:
1724             return coeff*factors
1725     if coeff is S.One:
1726         return factors
1727     elif coeff is S.NegativeOne and not sign:
1728         return -factors
1729     elif factors.is_Add:
1730         if not clear and coeff.is_Rational and coeff.q != 1:
1731             q = S(coeff.q)
1732             for i in factors.args:
1733                 c, t = i.as_coeff_Mul()
1734                 r = c/q
1735                 if r == int(r):
1736                     return coeff*factors
1737         return Mul._from_args((coeff, factors))
1738     elif factors.is_Mul:
1739         margs = list(factors.args)
1740         if margs[0].is_Number:
1741             margs[0] *= coeff
1742             if margs[0] == 1:
1743                 margs.pop(0)
1744         else:
1745             margs.insert(0, coeff)
1746         return Mul._from_args(margs)
1747     else:
1748         return coeff*factors
1749 
1750 
1751 def expand_2arg(e):
1752     from sympy.simplify.simplify import bottom_up
1753     def do(e):
1754         if e.is_Mul:
1755             c, r = e.as_coeff_Mul()
1756             if c.is_Number and r.is_Add:
1757                 return _unevaluated_Add(*[c*ri for ri in r.args])
1758         return e
1759     return bottom_up(e, do)
1760 
1761 
1762 from .numbers import Rational
1763 from .power import Pow
1764 from .add import Add, _addsort, _unevaluated_Add

</code><intended_behavior>Ensure that `is_Mul` accurately identifies only true multiplication expressions without mistakenly flagging other expression types due to simplification, evaluation, or manipulation errors.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow,
6     Symbol, sympify, expand_mul, expand_func,
7     Function, Dummy, Expr, factor_terms,
8     symbols, expand_power_exp)
9 from sympy.core.compatibility import (iterable,
10     ordered, range, as_int)
11 from sympy.core.numbers import Float, I, pi, Rational, Integer
12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg
13 from sympy.core.rules import Transform
14 from sympy.core.evaluate import global_evaluate
15 from sympy.functions import (
16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)
17 from sympy.functions.elementary.exponential import ExpBase
18 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
19 from sympy.functions.elementary.integers import ceiling
20 from sympy.functions.elementary.complexes import unpolarify
21 from sympy.functions.elementary.trigonometric import TrigonometricFunction
22 from sympy.functions.combinatorial.factorials import CombinatorialFunction
23 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
24 
25 from sympy.utilities.iterables import has_variety
26 
27 from sympy.simplify.radsimp import radsimp, fraction
28 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
29 from sympy.simplify.powsimp import powsimp
30 from sympy.simplify.cse_opts import sub_pre, sub_post
31 from sympy.simplify.sqrtdenest import sqrtdenest
32 from sympy.simplify.combsimp import combsimp
33 
34 from sympy.polys import (together, cancel, factor)
35 
36 
37 import mpmath
38 
39 
40 
41 def separatevars(expr, symbols=[], dict=False, force=False):
42     """
43     Separates variables in an expression, if possible.  By
44     default, it separates with respect to all symbols in an
45     expression and collects constant coefficients that are
46     independent of symbols.
47 
48     If dict=True then the separated terms will be returned
49     in a dictionary keyed to their corresponding symbols.
50     By default, all symbols in the expression will appear as
51     keys; if symbols are provided, then all those symbols will
52     be used as keys, and any terms in the expression containing
53     other symbols or non-symbols will be returned keyed to the
54     string 'coeff'. (Passing None for symbols will return the
55     expression in a dictionary keyed to 'coeff'.)
56 
57     If force=True, then bases of powers will be separated regardless
58     of assumptions on the symbols involved.
59 
60     Notes
61     =====
62     The order of the factors is determined by Mul, so that the
63     separated expressions may not necessarily be grouped together.
64 
65     Although factoring is necessary to separate variables in some
66     expressions, it is not necessary in all cases, so one should not
67     count on the returned factors being factored.
68 
69     Examples
70     ========
71 
72     >>> from sympy.abc import x, y, z, alpha
73     >>> from sympy import separatevars, sin
74     >>> separatevars((x*y)**y)
75     (x*y)**y
76     >>> separatevars((x*y)**y, force=True)
77     x**y*y**y
78 
79     >>> e = 2*x**2*z*sin(y)+2*z*x**2
80     >>> separatevars(e)
81     2*x**2*z*(sin(y) + 1)
82     >>> separatevars(e, symbols=(x, y), dict=True)
83     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
84     >>> separatevars(e, [x, y, alpha], dict=True)
85     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
86 
87     If the expression is not really separable, or is only partially
88     separable, separatevars will do the best it can to separate it
89     by using factoring.
90 
91     >>> separatevars(x + x*y - 3*x**2)
92     -x*(3*x - y - 1)
93 
94     If the expression is not separable then expr is returned unchanged
95     or (if dict=True) then None is returned.
96 
97     >>> eq = 2*x + y*sin(x)
98     >>> separatevars(eq) == eq
99     True
100     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None
101     True
102 
103     """
104     expr = sympify(expr)
105     if dict:
106         return _separatevars_dict(_separatevars(expr, force), symbols)
107     else:
108         return _separatevars(expr, force)
109 
110 
111 def _separatevars(expr, force):
112     if len(expr.free_symbols) == 1:
113         return expr
114     # don't destroy a Mul since much of the work may already be done
115     if expr.is_Mul:
116         args = list(expr.args)
117         changed = False
118         for i, a in enumerate(args):
119             args[i] = separatevars(a, force)
120             changed = changed or args[i] != a
121         if changed:
122             expr = expr.func(*args)
123         return expr
124 
125     # get a Pow ready for expansion
126     if expr.is_Pow:
127         expr = Pow(separatevars(expr.base, force=force), expr.exp)
128 
129     # First try other expansion methods
130     expr = expr.expand(mul=False, multinomial=False, force=force)
131 
132     _expr, reps = posify(expr) if force else (expr, {})
133     expr = factor(_expr).subs(reps)
134 
135     if not expr.is_Add:
136         return expr
137 
138     # Find any common coefficients to pull out
139     args = list(expr.args)
140     commonc = args[0].args_cnc(cset=True, warn=False)[0]
141     for i in args[1:]:
142         commonc &= i.args_cnc(cset=True, warn=False)[0]
143     commonc = Mul(*commonc)
144     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
145     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
146 
147     # remove them
148     for i, a in enumerate(args):
149         c, nc = a.args_cnc(cset=True, warn=False)
150         c = c - commonc_set
151         args[i] = Mul(*c)*Mul(*nc)
152     nonsepar = Add(*args)
153 
154     if len(nonsepar.free_symbols) > 1:
155         _expr = nonsepar
156         _expr, reps = posify(_expr) if force else (_expr, {})
157         _expr = (factor(_expr)).subs(reps)
158 
159         if not _expr.is_Add:
160             nonsepar = _expr
161 
162     return commonc*nonsepar
163 
164 
165 def _separatevars_dict(expr, symbols):
166     if symbols:
167         if not all((t.is_Atom for t in symbols)):
168             raise ValueError("symbols must be Atoms.")
169         symbols = list(symbols)
170     elif symbols is None:
171         return {'coeff': expr}
172     else:
173         symbols = list(expr.free_symbols)
174         if not symbols:
175             return None
176 
177     ret = dict(((i, []) for i in symbols + ['coeff']))
178 
179     for i in Mul.make_args(expr):
180         expsym = i.free_symbols
181         intersection = set(symbols).intersection(expsym)
182         if len(intersection) > 1:
183             return None
184         if len(intersection) == 0:
185             # There are no symbols, so it is part of the coefficient
186             ret['coeff'].append(i)
187         else:
188             ret[intersection.pop()].append(i)
189 
190     # rebuild
191     for k, v in ret.items():
192         ret[k] = Mul(*v)
193 
194     return ret
195 
196 
197 def _is_sum_surds(p):
198     args = p.args if p.is_Add else [p]
199     for y in args:
200         if not ((y**2).is_Rational and y.is_real):
201             return False
202     return True
203 
204 
205 def posify(eq):
206     """Return eq (with generic symbols made positive) and a
207     dictionary containing the mapping between the old and new
208     symbols.
209 
210     Any symbol that has positive=None will be replaced with a positive dummy
211     symbol having the same name. This replacement will allow more symbolic
212     processing of expressions, especially those involving powers and
213     logarithms.
214 
215     A dictionary that can be sent to subs to restore eq to its original
216     symbols is also returned.
217 
218     >>> from sympy import posify, Symbol, log, solve
219     >>> from sympy.abc import x
220     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
221     (_x + n + p, {_x: x})
222 
223     >>> eq = 1/x
224     >>> log(eq).expand()
225     log(1/x)
226     >>> log(posify(eq)[0]).expand()
227     -log(_x)
228     >>> p, rep = posify(eq)
229     >>> log(p).expand().subs(rep)
230     -log(x)
231 
232     It is possible to apply the same transformations to an iterable
233     of expressions:
234 
235     >>> eq = x**2 - 4
236     >>> solve(eq, x)
237     [-2, 2]
238     >>> eq_x, reps = posify([eq, x]); eq_x
239     [_x**2 - 4, _x]
240     >>> solve(*eq_x)
241     [2]
242     """
243     eq = sympify(eq)
244     if iterable(eq):
245         f = type(eq)
246         eq = list(eq)
247         syms = set()
248         for e in eq:
249             syms = syms.union(e.atoms(Symbol))
250         reps = {}
251         for s in syms:
252             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
253         for i, e in enumerate(eq):
254             eq[i] = e.subs(reps)
255         return f(eq), {r: s for s, r in reps.items()}
256 
257     reps = dict([(s, Dummy(s.name, positive=True))
258                  for s in eq.free_symbols if s.is_positive is None])
259     eq = eq.subs(reps)
260     return eq, {r: s for s, r in reps.items()}
261 
262 
263 def hypersimp(f, k):
264     """Given combinatorial term f(k) simplify its consecutive term ratio
265        i.e. f(k+1)/f(k).  The input term can be composed of functions and
266        integer sequences which have equivalent representation in terms
267        of gamma special function.
268 
269        The algorithm performs three basic steps:
270 
271        1. Rewrite all functions in terms of gamma, if possible.
272 
273        2. Rewrite all occurrences of gamma in terms of products
274           of gamma and rising factorial with integer,  absolute
275           constant exponent.
276 
277        3. Perform simplification of nested fractions, powers
278           and if the resulting expression is a quotient of
279           polynomials, reduce their total degree.
280 
281        If f(k) is hypergeometric then as result we arrive with a
282        quotient of polynomials of minimal degree. Otherwise None
283        is returned.
284 
285        For more information on the implemented algorithm refer to:
286 
287        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
288           Journal of Symbolic Computation (1995) 20, 399-417
289     """
290     f = sympify(f)
291 
292     g = f.subs(k, k + 1) / f
293 
294     g = g.rewrite(gamma)
295     g = expand_func(g)
296     g = powsimp(g, deep=True, combine='exp')
297 
298     if g.is_rational_function(k):
299         return simplify(g, ratio=S.Infinity)
300     else:
301         return None
302 
303 
304 def hypersimilar(f, g, k):
305     """Returns True if 'f' and 'g' are hyper-similar.
306 
307        Similarity in hypergeometric sense means that a quotient of
308        f(k) and g(k) is a rational function in k.  This procedure
309        is useful in solving recurrence relations.
310 
311        For more information see hypersimp().
312 
313     """
314     f, g = list(map(sympify, (f, g)))
315 
316     h = (f/g).rewrite(gamma)
317     h = h.expand(func=True, basic=False)
318 
319     return h.is_rational_function(k)
320 
321 
322 def signsimp(expr, evaluate=None):
323     """Make all Add sub-expressions canonical wrt sign.
324 
325     If an Add subexpression, ``a``, can have a sign extracted,
326     as determined by could_extract_minus_sign, it is replaced
327     with Mul(-1, a, evaluate=False). This allows signs to be
328     extracted from powers and products.
329 
330     Examples
331     ========
332 
333     >>> from sympy import signsimp, exp, symbols
334     >>> from sympy.abc import x, y
335     >>> i = symbols('i', odd=True)
336     >>> n = -1 + 1/x
337     >>> n/x/(-n)**2 - 1/n/x
338     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
339     >>> signsimp(_)
340     0
341     >>> x*n + x*-n
342     x*(-1 + 1/x) + x*(1 - 1/x)
343     >>> signsimp(_)
344     0
345 
346     Since powers automatically handle leading signs
347 
348     >>> (-2)**i
349     -2**i
350 
351     signsimp can be used to put the base of a power with an integer
352     exponent into canonical form:
353 
354     >>> n**i
355     (-1 + 1/x)**i
356 
357     By default, signsimp doesn't leave behind any hollow simplification:
358     if making an Add canonical wrt sign didn't change the expression, the
359     original Add is restored. If this is not desired then the keyword
360     ``evaluate`` can be set to False:
361 
362     >>> e = exp(y - x)
363     >>> signsimp(e) == e
364     True
365     >>> signsimp(e, evaluate=False)
366     exp(-(x - y))
367 
368     """
369     if evaluate is None:
370         evaluate = global_evaluate[0]
371     expr = sympify(expr)
372     if not isinstance(expr, Expr) or expr.is_Atom:
373         return expr
374     e = sub_post(sub_pre(expr))
375     if not isinstance(e, Expr) or e.is_Atom:
376         return e
377     if e.is_Add:
378         return e.func(*[signsimp(a) for a in e.args])
379     if evaluate:
380         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
381     return e
382 
383 
384 def simplify(expr, ratio=1.7, measure=count_ops, fu=False):
385     """
386     Simplifies the given expression.
387 
388     Simplification is not a well defined term and the exact strategies
389     this function tries can change in the future versions of SymPy. If
390     your algorithm relies on "simplification" (whatever it is), try to
391     determine what you need exactly  -  is it powsimp()?, radsimp()?,
392     together()?, logcombine()?, or something else? And use this particular
393     function directly, because those are well defined and thus your algorithm
394     will be robust.
395 
396     Nonetheless, especially for interactive use, or when you don't know
397     anything about the structure of the expression, simplify() tries to apply
398     intelligent heuristics to make the input expression "simpler".  For
399     example:
400 
401     >>> from sympy import simplify, cos, sin
402     >>> from sympy.abc import x, y
403     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
404     >>> a
405     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
406     >>> simplify(a)
407     x + 1
408 
409     Note that we could have obtained the same result by using specific
410     simplification functions:
411 
412     >>> from sympy import trigsimp, cancel
413     >>> trigsimp(a)
414     (x**2 + x)/x
415     >>> cancel(_)
416     x + 1
417 
418     In some cases, applying :func:`simplify` may actually result in some more
419     complicated expression. The default ``ratio=1.7`` prevents more extreme
420     cases: if (result length)/(input length) > ratio, then input is returned
421     unmodified.  The ``measure`` parameter lets you specify the function used
422     to determine how complex an expression is.  The function should take a
423     single argument as an expression and return a number such that if
424     expression ``a`` is more complex than expression ``b``, then
425     ``measure(a) > measure(b)``.  The default measure function is
426     :func:`count_ops`, which returns the total number of operations in the
427     expression.
428 
429     For example, if ``ratio=1``, ``simplify`` output can't be longer
430     than input.
431 
432     ::
433 
434         >>> from sympy import sqrt, simplify, count_ops, oo
435         >>> root = 1/(sqrt(2)+3)
436 
437     Since ``simplify(root)`` would result in a slightly longer expression,
438     root is returned unchanged instead::
439 
440        >>> simplify(root, ratio=1) == root
441        True
442 
443     If ``ratio=oo``, simplify will be applied anyway::
444 
445         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
446         True
447 
448     Note that the shortest expression is not necessary the simplest, so
449     setting ``ratio`` to 1 may not be a good idea.
450     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
451     choice.
452 
453     You can easily define your own measure function based on what you feel
454     should represent the "size" or "complexity" of the input expression.  Note
455     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
456     good metrics, but have other problems (in this case, the measure function
457     may slow down simplify too much for very large expressions).  If you don't
458     know what a good metric would be, the default, ``count_ops``, is a good
459     one.
460 
461     For example:
462 
463     >>> from sympy import symbols, log
464     >>> a, b = symbols('a b', positive=True)
465     >>> g = log(a) + log(b) + log(a)*log(1/b)
466     >>> h = simplify(g)
467     >>> h
468     log(a*b**(-log(a) + 1))
469     >>> count_ops(g)
470     8
471     >>> count_ops(h)
472     5
473 
474     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
475     However, we may not like how ``simplify`` (in this case, using
476     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
477     to reduce this would be to give more weight to powers as operations in
478     ``count_ops``.  We can do this by using the ``visual=True`` option:
479 
480     >>> print(count_ops(g, visual=True))
481     2*ADD + DIV + 4*LOG + MUL
482     >>> print(count_ops(h, visual=True))
483     2*LOG + MUL + POW + SUB
484 
485     >>> from sympy import Symbol, S
486     >>> def my_measure(expr):
487     ...     POW = Symbol('POW')
488     ...     # Discourage powers by giving POW a weight of 10
489     ...     count = count_ops(expr, visual=True).subs(POW, 10)
490     ...     # Every other operation gets a weight of 1 (the default)
491     ...     count = count.replace(Symbol, type(S.One))
492     ...     return count
493     >>> my_measure(g)
494     8
495     >>> my_measure(h)
496     14
497     >>> 15./8 > 1.7 # 1.7 is the default ratio
498     True
499     >>> simplify(g, measure=my_measure)
500     -log(a)*log(b) + log(a) + log(b)
501 
502     Note that because ``simplify()`` internally tries many different
503     simplification strategies and then compares them using the measure
504     function, we get a completely different result that is still different
505     from the input expression by doing this.
506     """
507     expr = sympify(expr)
508 
509     try:
510         return expr._eval_simplify(ratio=ratio, measure=measure)
511     except AttributeError:
512         pass
513 
514     original_expr = expr = signsimp(expr)
515 
516     from sympy.simplify.hyperexpand import hyperexpand
517     from sympy.functions.special.bessel import BesselBase
518     from sympy import Sum, Product
519 
520     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
521         return expr
522 
523     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
524         if isinstance(expr, Function) and hasattr(expr, "inverse"):
525             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \
526                isinstance(expr.args[0], expr.inverse(argindex=1)):
527                 return simplify(expr.args[0].args[0], ratio=ratio,
528                                 measure=measure, fu=fu)
529         return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu)
530                          for x in expr.args])
531 
532     # TODO: Apply different strategies, considering expression pattern:
533     # is it a purely rational function? Is there any trigonometric function?...
534     # See also https://github.com/sympy/sympy/pull/185.
535 
536     def shorter(*choices):
537         '''Return the choice that has the fewest ops. In case of a tie,
538         the expression listed first is selected.'''
539         if not has_variety(choices):
540             return choices[0]
541         return min(choices, key=measure)
542 
543     expr = bottom_up(expr, lambda w: w.normal())
544     expr = Mul(*powsimp(expr).as_content_primitive())
545     _e = cancel(expr)
546     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
547     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
548 
549     if ratio is S.Infinity:
550         expr = expr2
551     else:
552         expr = shorter(expr2, expr1, expr)
553     if not isinstance(expr, Basic):  # XXX: temporary hack
554         return expr
555 
556     expr = factor_terms(expr, sign=False)
557 
558     # hyperexpand automatically only works on hypergeometric terms
559     expr = hyperexpand(expr)
560 
561     expr = piecewise_fold(expr)
562 
563     if expr.has(BesselBase):
564         expr = besselsimp(expr)
565 
566     if expr.has(TrigonometricFunction) and not fu or expr.has(
567             HyperbolicFunction):
568         expr = trigsimp(expr, deep=True)
569 
570     if expr.has(log):
571         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
572 
573     if expr.has(CombinatorialFunction, gamma):
574         expr = combsimp(expr)
575 
576     if expr.has(Sum):
577         expr = sum_simplify(expr)
578 
579     if expr.has(Product):
580         expr = product_simplify(expr)
581 
582     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
583     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
584     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
585         short = exptrigsimp(short, simplify=False)
586 
587     # get rid of hollow 2-arg Mul factorization
588     hollow_mul = Transform(
589         lambda x: Mul(*x.args),
590         lambda x:
591         x.is_Mul and
592         len(x.args) == 2 and
593         x.args[0].is_Number and
594         x.args[1].is_Add and
595         x.is_commutative)
596     expr = short.xreplace(hollow_mul)
597 
598     numer, denom = expr.as_numer_denom()
599     if denom.is_Add:
600         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
601         if n is not S.One:
602             expr = (numer*n).expand()/d
603 
604     if expr.could_extract_minus_sign():
605         n, d = fraction(expr)
606         if d != 0:
607             expr = signsimp(-n/(-d))
608 
609     if measure(expr) > ratio*measure(original_expr):
610         expr = original_expr
611 
612     return expr
613 
614 
615 def sum_simplify(s):
616     """Main function for Sum simplification"""
617     from sympy.concrete.summations import Sum
618     from sympy.core.function import expand
619 
620     terms = Add.make_args(expand(s))
621     s_t = [] # Sum Terms
622     o_t = [] # Other Terms
623 
624     for term in terms:
625         if isinstance(term, Mul):
626             other = 1
627             sum_terms = []
628 
629             if not term.has(Sum):
630                 o_t.append(term)
631                 continue
632 
633             mul_terms = Mul.make_args(term)
634             for mul_term in mul_terms:
635                 if isinstance(mul_term, Sum):
636                     r = mul_term._eval_simplify()
637                     sum_terms.extend(Add.make_args(r))
638                 else:
639                     other = other * mul_term
640             if len(sum_terms):
641                 #some simplification may have happened
642                 #use if so
643                 s_t.append(Mul(*sum_terms) * other)
644             else:
645                 o_t.append(other)
646         elif isinstance(term, Sum):
647             #as above, we need to turn this into an add list
648             r = term._eval_simplify()
649             s_t.extend(Add.make_args(r))
650         else:
651             o_t.append(term)
652 
653 
654     result = Add(sum_combine(s_t), *o_t)
655 
656     return result
657 
658 def sum_combine(s_t):
659     """Helper function for Sum simplification
660 
661        Attempts to simplify a list of sums, by combining limits / sum function's
662        returns the simplified sum
663     """
664     from sympy.concrete.summations import Sum
665 
666 
667     used = [False] * len(s_t)
668 
669     for method in range(2):
670         for i, s_term1 in enumerate(s_t):
671             if not used[i]:
672                 for j, s_term2 in enumerate(s_t):
673                     if not used[j] and i != j:
674                         temp = sum_add(s_term1, s_term2, method)
675                         if isinstance(temp, Sum) or isinstance(temp, Mul):
676                             s_t[i] = temp
677                             s_term1 = s_t[i]
678                             used[j] = True
679 
680     result = S.Zero
681     for i, s_term in enumerate(s_t):
682         if not used[i]:
683             result = Add(result, s_term)
684 
685     return result
686 
687 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
688     """Helper function for Sum simplification
689 
690        if limits is specified, "self" is the inner part of a sum
691 
692        Returns the sum with constant factors brought outside
693     """
694     from sympy.core.exprtools import factor_terms
695     from sympy.concrete.summations import Sum
696 
697     result = self.function if limits is None else self
698     limits = self.limits if limits is None else limits
699     #avoid any confusion w/ as_independent
700     if result == 0:
701         return S.Zero
702 
703     #get the summation variables
704     sum_vars = set([limit.args[0] for limit in limits])
705 
706     #finally we try to factor out any common terms
707     #and remove the from the sum if independent
708     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)
709     #avoid doing anything bad
710     if not result.is_commutative:
711         return Sum(result, *limits)
712 
713     i, d = retv.as_independent(*sum_vars)
714     if isinstance(retv, Add):
715         return i * Sum(1, *limits) + Sum(d, *limits)
716     else:
717         return i * Sum(d, *limits)
718 
719 def sum_add(self, other, method=0):
720     """Helper function for Sum simplification"""
721     from sympy.concrete.summations import Sum
722     from sympy import Mul
723 
724     #we know this is something in terms of a constant * a sum
725     #so we temporarily put the constants inside for simplification
726     #then simplify the result
727     def __refactor(val):
728         args = Mul.make_args(val)
729         sumv = next(x for x in args if isinstance(x, Sum))
730         constant = Mul(*[x for x in args if x != sumv])
731         return Sum(constant * sumv.function, *sumv.limits)
732 
733     if isinstance(self, Mul):
734         rself = __refactor(self)
735     else:
736         rself = self
737 
738     if isinstance(other, Mul):
739         rother = __refactor(other)
740     else:
741         rother = other
742 
743     if type(rself) == type(rother):
744         if method == 0:
745             if rself.limits == rother.limits:
746                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
747         elif method == 1:
748             if simplify(rself.function - rother.function) == 0:
749                 if len(rself.limits) == len(rother.limits) == 1:
750                     i = rself.limits[0][0]
751                     x1 = rself.limits[0][1]
752                     y1 = rself.limits[0][2]
753                     j = rother.limits[0][0]
754                     x2 = rother.limits[0][1]
755                     y2 = rother.limits[0][2]
756 
757                     if i == j:
758                         if x2 == y1 + 1:
759                             return factor_sum(Sum(rself.function, (i, x1, y2)))
760                         elif x1 == y2 + 1:
761                             return factor_sum(Sum(rself.function, (i, x2, y1)))
762 
763     return Add(self, other)
764 
765 
766 def product_simplify(s):
767     """Main function for Product simplification"""
768     from sympy.concrete.products import Product
769 
770     terms = Mul.make_args(s)
771     p_t = [] # Product Terms
772     o_t = [] # Other Terms
773 
774     for term in terms:
775         if isinstance(term, Product):
776             p_t.append(term)
777         else:
778             o_t.append(term)
779 
780     used = [False] * len(p_t)
781 
782     for method in range(2):
783         for i, p_term1 in enumerate(p_t):
784             if not used[i]:
785                 for j, p_term2 in enumerate(p_t):
786                     if not used[j] and i != j:
787                         if isinstance(product_mul(p_term1, p_term2, method), Product):
788                             p_t[i] = product_mul(p_term1, p_term2, method)
789                             used[j] = True
790 
791     result = Mul(*o_t)
792 
793     for i, p_term in enumerate(p_t):
794         if not used[i]:
795             result = Mul(result, p_term)
796 
797     return result
798 
799 
800 def product_mul(self, other, method=0):
801     """Helper function for Product simplification"""
802     from sympy.concrete.products import Product
803 
804     if type(self) == type(other):
805         if method == 0:
806             if self.limits == other.limits:
807                 return Product(self.function * other.function, *self.limits)
808         elif method == 1:
809             if simplify(self.function - other.function) == 0:
810                 if len(self.limits) == len(other.limits) == 1:
811                     i = self.limits[0][0]
812                     x1 = self.limits[0][1]
813                     y1 = self.limits[0][2]
814                     j = other.limits[0][0]
815                     x2 = other.limits[0][1]
816                     y2 = other.limits[0][2]
817 
818                     if i == j:
819                         if x2 == y1 + 1:
820                             return Product(self.function, (i, x1, y2))
821                         elif x1 == y2 + 1:
822                             return Product(self.function, (i, x2, y1))
823 
824     return Mul(self, other)
825 
826 
827 def _nthroot_solve(p, n, prec):
828     """
829      helper function for ``nthroot``
830      It denests ``p**Rational(1, n)`` using its minimal polynomial
831     """
832     from sympy.polys.numberfields import _minimal_polynomial_sq
833     from sympy.solvers import solve
834     while n % 2 == 0:
835         p = sqrtdenest(sqrt(p))
836         n = n // 2
837     if n == 1:
838         return p
839     pn = p**Rational(1, n)
840     x = Symbol('x')
841     f = _minimal_polynomial_sq(p, n, x)
842     if f is None:
843         return None
844     sols = solve(f, x)
845     for sol in sols:
846         if abs(sol - pn).n() < 1./10**prec:
847             sol = sqrtdenest(sol)
848             if _mexpand(sol**n) == p:
849                 return sol
850 
851 
852 def logcombine(expr, force=False):
853     """
854     Takes logarithms and combines them using the following rules:
855 
856     - log(x) + log(y) == log(x*y) if both are not negative
857     - a*log(x) == log(x**a) if x is positive and a is real
858 
859     If ``force`` is True then the assumptions above will be assumed to hold if
860     there is no assumption already in place on a quantity. For example, if
861     ``a`` is imaginary or the argument negative, force will not perform a
862     combination but if ``a`` is a symbol with no assumptions the change will
863     take place.
864 
865     Examples
866     ========
867 
868     >>> from sympy import Symbol, symbols, log, logcombine, I
869     >>> from sympy.abc import a, x, y, z
870     >>> logcombine(a*log(x) + log(y) - log(z))
871     a*log(x) + log(y) - log(z)
872     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
873     log(x**a*y/z)
874     >>> x,y,z = symbols('x,y,z', positive=True)
875     >>> a = Symbol('a', real=True)
876     >>> logcombine(a*log(x) + log(y) - log(z))
877     log(x**a*y/z)
878 
879     The transformation is limited to factors and/or terms that
880     contain logs, so the result depends on the initial state of
881     expansion:
882 
883     >>> eq = (2 + 3*I)*log(x)
884     >>> logcombine(eq, force=True) == eq
885     True
886     >>> logcombine(eq.expand(), force=True)
887     log(x**2) + I*log(x**3)
888 
889     See Also
890     ========
891     posify: replace all symbols with symbols having positive assumptions
892 
893     """
894 
895     def f(rv):
896         if not (rv.is_Add or rv.is_Mul):
897             return rv
898 
899         def gooda(a):
900             # bool to tell whether the leading ``a`` in ``a*log(x)``
901             # could appear as log(x**a)
902             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
903                 (a.is_real or force and a.is_real is not False))
904 
905         def goodlog(l):
906             # bool to tell whether log ``l``'s argument can combine with others
907             a = l.args[0]
908             return a.is_positive or force and a.is_nonpositive is not False
909 
910         other = []
911         logs = []
912         log1 = defaultdict(list)
913         for a in Add.make_args(rv):
914             if a.func is log and goodlog(a):
915                 log1[()].append(([], a))
916             elif not a.is_Mul:
917                 other.append(a)
918             else:
919                 ot = []
920                 co = []
921                 lo = []
922                 for ai in a.args:
923                     if ai.is_Rational and ai < 0:
924                         ot.append(S.NegativeOne)
925                         co.append(-ai)
926                     elif ai.func is log and goodlog(ai):
927                         lo.append(ai)
928                     elif gooda(ai):
929                         co.append(ai)
930                     else:
931                         ot.append(ai)
932                 if len(lo) > 1:
933                     logs.append((ot, co, lo))
934                 elif lo:
935                     log1[tuple(ot)].append((co, lo[0]))
936                 else:
937                     other.append(a)
938 
939         # if there is only one log at each coefficient and none have
940         # an exponent to place inside the log then there is nothing to do
941         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
942             return rv
943 
944         # collapse multi-logs as far as possible in a canonical way
945         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
946         # -- in this case, it's unambiguous, but if it were were a log(c) in
947         # each term then it's arbitrary whether they are grouped by log(a) or
948         # by log(c). So for now, just leave this alone; it's probably better to
949         # let the user decide
950         for o, e, l in logs:
951             l = list(ordered(l))
952             e = log(l.pop(0).args[0]**Mul(*e))
953             while l:
954                 li = l.pop(0)
955                 e = log(li.args[0]**e)
956             c, l = Mul(*o), e
957             if l.func is log:  # it should be, but check to be sure
958                 log1[(c,)].append(([], l))
959             else:
960                 other.append(c*l)
961 
962         # logs that have the same coefficient can multiply
963         for k in list(log1.keys()):
964             log1[Mul(*k)] = log(logcombine(Mul(*[
965                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
966                 force=force))
967 
968         # logs that have oppositely signed coefficients can divide
969         for k in ordered(list(log1.keys())):
970             if not k in log1:  # already popped as -k
971                 continue
972             if -k in log1:
973                 # figure out which has the minus sign; the one with
974                 # more op counts should be the one
975                 num, den = k, -k
976                 if num.count_ops() > den.count_ops():
977                     num, den = den, num
978                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))
979             else:
980                 other.append(k*log1.pop(k))
981 
982         return Add(*other)
983 
984     return bottom_up(expr, f)
985 
986 
987 def bottom_up(rv, F, atoms=False, nonbasic=False):
988     """Apply ``F`` to all expressions in an expression tree from the
989     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
990     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
991     """
992     try:
993         if rv.args:
994             args = tuple([bottom_up(a, F, atoms, nonbasic)
995                 for a in rv.args])
996             if args != rv.args:
997                 rv = rv.func(*args)
998             rv = F(rv)
999         elif atoms:
1000             rv = F(rv)
1001     except AttributeError:
1002         if nonbasic:
1003             try:
1004                 rv = F(rv)
1005             except TypeError:
1006                 pass
1007 
1008     return rv
1009 
1010 
1011 def besselsimp(expr):
1012     """
1013     Simplify bessel-type functions.
1014 
1015     This routine tries to simplify bessel-type functions. Currently it only
1016     works on the Bessel J and I functions, however. It works by looking at all
1017     such functions in turn, and eliminating factors of "I" and "-1" (actually
1018     their polar equivalents) in front of the argument. Then, functions of
1019     half-integer order are rewritten using strigonometric functions and
1020     functions of integer order (> 1) are rewritten using functions
1021     of low order.  Finally, if the expression was changed, compute
1022     factorization of the result with factor().
1023 
1024     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1025     >>> from sympy.abc import z, nu
1026     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1027     exp(I*pi*nu)*besselj(nu, z)
1028     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1029     exp(-I*pi*nu/2)*besselj(nu, z)
1030     >>> besselsimp(besseli(S(-1)/2, z))
1031     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1032     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1033     3*z*besseli(0, z)/2
1034     """
1035     # TODO
1036     # - better algorithm?
1037     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1038     # - use contiguity relations?
1039 
1040     def replacer(fro, to, factors):
1041         factors = set(factors)
1042 
1043         def repl(nu, z):
1044             if factors.intersection(Mul.make_args(z)):
1045                 return to(nu, z)
1046             return fro(nu, z)
1047         return repl
1048 
1049     def torewrite(fro, to):
1050         def tofunc(nu, z):
1051             return fro(nu, z).rewrite(to)
1052         return tofunc
1053 
1054     def tominus(fro):
1055         def tofunc(nu, z):
1056             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1057         return tofunc
1058 
1059     orig_expr = expr
1060 
1061     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1062     expr = expr.replace(
1063         besselj, replacer(besselj,
1064         torewrite(besselj, besseli), ifactors))
1065     expr = expr.replace(
1066         besseli, replacer(besseli,
1067         torewrite(besseli, besselj), ifactors))
1068 
1069     minusfactors = [-1, exp_polar(I*pi)]
1070     expr = expr.replace(
1071         besselj, replacer(besselj, tominus(besselj), minusfactors))
1072     expr = expr.replace(
1073         besseli, replacer(besseli, tominus(besseli), minusfactors))
1074 
1075     z0 = Dummy('z')
1076 
1077     def expander(fro):
1078         def repl(nu, z):
1079             if (nu % 1) == S(1)/2:
1080                 return exptrigsimp(trigsimp(unpolarify(
1081                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1082                             func=True)).subs(z0, z)))
1083             elif nu.is_Integer and nu > 1:
1084                 return fro(nu, z).expand(func=True)
1085             return fro(nu, z)
1086         return repl
1087 
1088     expr = expr.replace(besselj, expander(besselj))
1089     expr = expr.replace(bessely, expander(bessely))
1090     expr = expr.replace(besseli, expander(besseli))
1091     expr = expr.replace(besselk, expander(besselk))
1092 
1093     if expr != orig_expr:
1094         expr = expr.factor()
1095 
1096     return expr
1097 
1098 
1099 def nthroot(expr, n, max_len=4, prec=15):
1100     """
1101     compute a real nth-root of a sum of surds
1102 
1103     Parameters
1104     ==========
1105 
1106     expr : sum of surds
1107     n : integer
1108     max_len : maximum number of surds passed as constants to ``nsimplify``
1109 
1110     Algorithm
1111     =========
1112 
1113     First ``nsimplify`` is used to get a candidate root; if it is not a
1114     root the minimal polynomial is computed; the answer is one of its
1115     roots.
1116 
1117     Examples
1118     ========
1119 
1120     >>> from sympy.simplify.simplify import nthroot
1121     >>> from sympy import Rational, sqrt
1122     >>> nthroot(90 + 34*sqrt(7), 3)
1123     sqrt(7) + 3
1124 
1125     """
1126     expr = sympify(expr)
1127     n = sympify(n)
1128     p = expr**Rational(1, n)
1129     if not n.is_integer:
1130         return p
1131     if not _is_sum_surds(expr):
1132         return p
1133     surds = []
1134     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1135     for x, y in coeff_muls:
1136         if not x.is_rational:
1137             return p
1138         if y is S.One:
1139             continue
1140         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1141             return p
1142         surds.append(y)
1143     surds.sort()
1144     surds = surds[:max_len]
1145     if expr < 0 and n % 2 == 1:
1146         p = (-expr)**Rational(1, n)
1147         a = nsimplify(p, constants=surds)
1148         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1149         return -res
1150     a = nsimplify(p, constants=surds)
1151     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1152         return _mexpand(a)
1153     expr = _nthroot_solve(expr, n, prec)
1154     if expr is None:
1155         return p
1156     return expr
1157 
1158 
1159 def nsimplify(expr, constants=[], tolerance=None, full=False, rational=None):
1160     """
1161     Find a simple representation for a number or, if there are free symbols or
1162     if rational=True, then replace Floats with their Rational equivalents. If
1163     no change is made and rational is not False then Floats will at least be
1164     converted to Rationals.
1165 
1166     For numerical expressions, a simple formula that numerically matches the
1167     given numerical expression is sought (and the input should be possible
1168     to evalf to a precision of at least 30 digits).
1169 
1170     Optionally, a list of (rationally independent) constants to
1171     include in the formula may be given.
1172 
1173     A lower tolerance may be set to find less exact matches. If no tolerance
1174     is given then the least precise value will set the tolerance (e.g. Floats
1175     default to 15 digits of precision, so would be tolerance=10**-15).
1176 
1177     With full=True, a more extensive search is performed
1178     (this is useful to find simpler numbers when the tolerance
1179     is set low).
1180 
1181     Examples
1182     ========
1183 
1184     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi
1185     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1186     -2 + 2*GoldenRatio
1187     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1188     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1189     >>> nsimplify(I**I, [pi])
1190     exp(-pi/2)
1191     >>> nsimplify(pi, tolerance=0.01)
1192     22/7
1193 
1194     See Also
1195     ========
1196     sympy.core.function.nfloat
1197 
1198     """
1199     try:
1200         return sympify(as_int(expr))
1201     except (TypeError, ValueError):
1202         pass
1203     expr = sympify(expr).xreplace({
1204         Float('inf'): S.Infinity,
1205         Float('-inf'): S.NegativeInfinity,
1206         })
1207     if expr is S.Infinity or expr is S.NegativeInfinity:
1208         return expr
1209     if rational or expr.free_symbols:
1210         return _real_to_rational(expr, tolerance)
1211 
1212     # SymPy's default tolerance for Rationals is 15; other numbers may have
1213     # lower tolerances set, so use them to pick the largest tolerance if None
1214     # was given
1215     if tolerance is None:
1216         tolerance = 10**-min([15] +
1217              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1218              for n in expr.atoms(Float)])
1219     # XXX should prec be set independent of tolerance or should it be computed
1220     # from tolerance?
1221     prec = 30
1222     bprec = int(prec*3.33)
1223 
1224     constants_dict = {}
1225     for constant in constants:
1226         constant = sympify(constant)
1227         v = constant.evalf(prec)
1228         if not v.is_Float:
1229             raise ValueError("constants must be real-valued")
1230         constants_dict[str(constant)] = v._to_mpmath(bprec)
1231 
1232     exprval = expr.evalf(prec, chop=True)
1233     re, im = exprval.as_real_imag()
1234 
1235     # safety check to make sure that this evaluated to a number
1236     if not (re.is_Number and im.is_Number):
1237         return expr
1238 
1239     def nsimplify_real(x):
1240         orig = mpmath.mp.dps
1241         xv = x._to_mpmath(bprec)
1242         try:
1243             # We'll be happy with low precision if a simple fraction
1244             if not (tolerance or full):
1245                 mpmath.mp.dps = 15
1246                 rat = mpmath.pslq([xv, 1])
1247                 if rat is not None:
1248                     return Rational(-int(rat[1]), int(rat[0]))
1249             mpmath.mp.dps = prec
1250             newexpr = mpmath.identify(xv, constants=constants_dict,
1251                 tol=tolerance, full=full)
1252             if not newexpr:
1253                 raise ValueError
1254             if full:
1255                 newexpr = newexpr[0]
1256             expr = sympify(newexpr)
1257             if x and not expr:  # don't let x become 0
1258                 raise ValueError
1259             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1260                 raise ValueError
1261             return expr
1262         finally:
1263             # even though there are returns above, this is executed
1264             # before leaving
1265             mpmath.mp.dps = orig
1266     try:
1267         if re:
1268             re = nsimplify_real(re)
1269         if im:
1270             im = nsimplify_real(im)
1271     except ValueError:
1272         if rational is None:
1273             return _real_to_rational(expr)
1274         return expr
1275 
1276     rv = re + im*S.ImaginaryUnit
1277     # if there was a change or rational is explicitly not wanted
1278     # return the value, else return the Rational representation
1279     if rv != expr or rational is False:
1280         return rv
1281     return _real_to_rational(expr)
1282 
1283 
1284 def _real_to_rational(expr, tolerance=None):
1285     """
1286     Replace all reals in expr with rationals.
1287 
1288     >>> from sympy import nsimplify
1289     >>> from sympy.abc import x
1290 
1291     >>> nsimplify(.76 + .1*x**.5, rational=True)
1292     sqrt(x)/10 + 19/25
1293 
1294     """
1295     inf = Float('inf')
1296     p = expr
1297     reps = {}
1298     reduce_num = None
1299     if tolerance is not None and tolerance < 1:
1300         reduce_num = ceiling(1/tolerance)
1301     for float in p.atoms(Float):
1302         key = float
1303         if reduce_num is not None:
1304             r = Rational(float).limit_denominator(reduce_num)
1305         elif (tolerance is not None and tolerance >= 1 and
1306                 float.is_Integer is False):
1307             r = Rational(tolerance*round(float/tolerance)
1308                 ).limit_denominator(int(tolerance))
1309         else:
1310             r = nsimplify(float, rational=False)
1311             # e.g. log(3).n() -> log(3) instead of a Rational
1312             if float and not r:
1313                 r = Rational(float)
1314             elif not r.is_Rational:
1315                 if float == inf or float == -inf:
1316                     r = S.ComplexInfinity
1317                 elif float < 0:
1318                     float = -float
1319                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))
1320                     r = -Rational(str(float/d))*d
1321                 elif float > 0:
1322                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))
1323                     r = Rational(str(float/d))*d
1324                 else:
1325                     r = Integer(0)
1326         reps[key] = r
1327     return p.subs(reps, simultaneous=True)
1328 
1329 
1330 def clear_coefficients(expr, rhs=S.Zero):
1331     """Return `p, r` where `p` is the expression obtained when Rational
1332     additive and multiplicative coefficients of `expr` have been stripped
1333     away in a naive fashion (i.e. without simplification). The operations
1334     needed to remove the coefficients will be applied to `rhs` and returned
1335     as `r`.
1336 
1337     Examples
1338     ========
1339 
1340     >>> from sympy.simplify.simplify import clear_coefficients
1341     >>> from sympy.abc import x, y
1342     >>> from sympy import Dummy
1343     >>> expr = 4*y*(6*x + 3)
1344     >>> clear_coefficients(expr - 2)
1345     (y*(2*x + 1), 1/6)
1346 
1347     When solving 2 or more expressions like `expr = a`,
1348     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1349     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1350 
1351     >>> rhs = Dummy('rhs')
1352     >>> clear_coefficients(expr, rhs)
1353     (y*(2*x + 1), _rhs/12)
1354     >>> _[1].subs(rhs, 2)
1355     1/6
1356     """
1357     was = None
1358     free = expr.free_symbols
1359     if expr.is_Rational:
1360         return (S.Zero, rhs - expr)
1361     while expr and was != expr:
1362         was = expr
1363         m, expr = (
1364             expr.as_content_primitive()
1365             if free else
1366             factor_terms(expr).as_coeff_Mul(rational=True))
1367         rhs /= m
1368         c, expr = expr.as_coeff_Add(rational=True)
1369         rhs -= c
1370     expr = signsimp(expr, evaluate = False)
1371     if _coeff_isneg(expr):
1372         expr = -expr
1373         rhs = -rhs
1374     return expr, rhs

</code><intended_behavior>Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself.</intended_behavior>, <file>sympy/simplify/combsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import Function, S, Mul, Pow, Add
4 from sympy.core.compatibility import ordered, default_sort_key
5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial
6 from sympy.functions import gamma, sqrt, sin
7 from sympy.polys import factor, cancel
8 
9 from sympy.utilities.timeutils import timethis
10 from sympy.utilities.iterables import sift
11 from sympy.utilities.iterables import uniq
12 
13 
14 
15 @timethis('combsimp')
16 def combsimp(expr):
17     r"""
18     Simplify combinatorial expressions.
19 
20     This function takes as input an expression containing factorials,
21     binomials, Pochhammer symbol and other "combinatorial" functions,
22     and tries to minimize the number of those functions and reduce
23     the size of their arguments.
24 
25     The algorithm works by rewriting all combinatorial functions as
26     expressions involving rising factorials (Pochhammer symbols) and
27     applies recurrence relations and other transformations applicable
28     to rising factorials, to reduce their arguments, possibly letting
29     the resulting rising factorial to cancel. Rising factorials with
30     the second argument being an integer are expanded into polynomial
31     forms and finally all other rising factorial are rewritten in terms
32     of more familiar functions. If the initial expression consisted of
33     gamma functions alone, the result is expressed in terms of gamma
34     functions. If the initial expression consists of gamma function
35     with some other combinatorial, the result is expressed in terms of
36     gamma functions.
37 
38     If the result is expressed using gamma functions, the following three
39     additional steps are performed:
40 
41     1. Reduce the number of gammas by applying the reflection theorem
42        gamma(x)*gamma(1-x) == pi/sin(pi*x).
43     2. Reduce the number of gammas by applying the multiplication theorem
44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).
45     3. Reduce the number of prefactors by absorbing them into gammas, where
46        possible.
47 
48     All transformation rules can be found (or was derived from) here:
49 
50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/
51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/
52 
53     Examples
54     ========
55 
56     >>> from sympy.simplify import combsimp
57     >>> from sympy import factorial, binomial
58     >>> from sympy.abc import n, k
59 
60     >>> combsimp(factorial(n)/factorial(n - 3))
61     n*(n - 2)*(n - 1)
62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))
63     (n + 1)/(k + 1)
64 
65     """
66 
67     # as a rule of thumb, if the expression contained gammas initially, it
68     # probably makes sense to retain them
69     as_gamma = expr.has(gamma)
70     as_factorial = expr.has(factorial)
71     as_binomial = expr.has(binomial)
72 
73 
74     expr = expr.replace(binomial,
75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))
76     expr = expr.replace(factorial,
77         lambda n: _rf(1, n.expand()))
78     expr = expr.rewrite(gamma)
79     expr = expr.replace(gamma,
80         lambda n: _rf(1, (n - 1).expand()))
81 
82     if as_gamma:
83         expr = expr.replace(_rf,
84             lambda a, b: gamma(a + b)/gamma(a))
85     else:
86         expr = expr.replace(_rf,
87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))
88 
89     def rule(n, k):
90         coeff, rewrite = S.One, False
91 
92         cn, _n = n.as_coeff_Add()
93 
94         if _n and cn.is_Integer and cn:
95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)
96             rewrite = True
97             n = _n
98 
99         # this sort of binomial has already been removed by
100         # rising factorials but is left here in case the order
101         # of rule application is changed
102         if k.is_Add:
103             ck, _k = k.as_coeff_Add()
104             if _k and ck.is_Integer and ck:
105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)
106                 rewrite = True
107                 k = _k
108 
109         if rewrite:
110             return coeff*binomial(n, k)
111 
112     expr = expr.replace(binomial, rule)
113 
114     def rule_gamma(expr, level=0):
115         """ Simplify products of gamma functions further. """
116 
117         if expr.is_Atom:
118             return expr
119 
120         def gamma_rat(x):
121             # helper to simplify ratios of gammas
122             was = x.count(gamma)
123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()
124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))
125             if xx.count(gamma) < was:
126                 x = xx
127             return x
128 
129         def gamma_factor(x):
130             # return True if there is a gamma factor in shallow args
131             if x.func is gamma:
132                 return True
133             if x.is_Add or x.is_Mul:
134                 return any(gamma_factor(xi) for xi in x.args)
135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):
136                 return gamma_factor(x.base)
137             return False
138 
139         # recursion step
140         if level == 0:
141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])
142             level += 1
143 
144         if not expr.is_Mul:
145             return expr
146 
147         # non-commutative step
148         if level == 1:
149             args, nc = expr.args_cnc()
150             if not args:
151                 return expr
152             if nc:
153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)
154             level += 1
155 
156         # pure gamma handling, not factor absorbtion
157         if level == 2:
158             sifted = sift(expr.args, gamma_factor)
159             gamma_ind = Mul(*sifted.pop(False, []))
160             d = Mul(*sifted.pop(True, []))
161             assert not sifted
162 
163             nd, dd = d.as_numer_denom()
164             for ipass in range(2):
165                 args = list(ordered(Mul.make_args(nd)))
166                 for i, ni in enumerate(args):
167                     if ni.is_Add:
168                         ni, dd = Add(*[
169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]
170                             ).as_numer_denom()
171                         args[i] = ni
172                         if not dd.has(gamma):
173                             break
174                 nd = Mul(*args)
175                 if ipass ==  0 and not gamma_factor(nd):
176                     break
177                 nd, dd = dd, nd  # now process in reversed order
178             expr = gamma_ind*nd/dd
179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):
180                 return expr
181             level += 1
182 
183         # iteration until constant
184         if level == 3:
185             while True:
186                 was = expr
187                 expr = rule_gamma(expr, 4)
188                 if expr == was:
189                     return expr
190 
191         numer_gammas = []
192         denom_gammas = []
193         numer_others = []
194         denom_others = []
195         def explicate(p):
196             if p is S.One:
197                 return None, []
198             b, e = p.as_base_exp()
199             if e.is_Integer:
200                 if b.func is gamma:
201                     return True, [b.args[0]]*e
202                 else:
203                     return False, [b]*e
204             else:
205                 return False, [p]
206 
207         newargs = list(ordered(expr.args))
208         while newargs:
209             n, d = newargs.pop().as_numer_denom()
210             isg, l = explicate(n)
211             if isg:
212                 numer_gammas.extend(l)
213             elif isg is False:
214                 numer_others.extend(l)
215             isg, l = explicate(d)
216             if isg:
217                 denom_gammas.extend(l)
218             elif isg is False:
219                 denom_others.extend(l)
220 
221         # =========== level 2 work: pure gamma manipulation =========
222 
223         # Try to reduce the number of gamma factors by applying the
224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)
225         for gammas, numer, denom in [(
226             numer_gammas, numer_others, denom_others),
227                 (denom_gammas, denom_others, numer_others)]:
228             new = []
229             while gammas:
230                 g1 = gammas.pop()
231                 if g1.is_integer:
232                     new.append(g1)
233                     continue
234                 for i, g2 in enumerate(gammas):
235                     n = g1 + g2 - 1
236                     if not n.is_Integer:
237                         continue
238                     numer.append(S.Pi)
239                     denom.append(sin(S.Pi*g1))
240                     gammas.pop(i)
241                     if n > 0:
242                         for k in range(n):
243                             numer.append(1 - g1 + k)
244                     elif n < 0:
245                         for k in range(-n):
246                             denom.append(-g1 - k)
247                     break
248                 else:
249                     new.append(g1)
250             # /!\ updating IN PLACE
251             gammas[:] = new
252 
253         # Try to reduce the number of gammas by using the duplication
254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =
255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could
256         # be done with higher argument ratios like gamma(3*x)/gamma(x),
257         # this would not reduce the number of gammas as in this case.
258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,
259                                 denom_others),
260                                (denom_gammas, numer_gammas, denom_others,
261                                 numer_others)]:
262 
263             while True:
264                 for x in ng:
265                     for y in dg:
266                         n = x - 2*y
267                         if n.is_Integer:
268                             break
269                     else:
270                         continue
271                     break
272                 else:
273                     break
274                 ng.remove(x)
275                 dg.remove(y)
276                 if n > 0:
277                     for k in range(n):
278                         no.append(2*y + k)
279                 elif n < 0:
280                     for k in range(-n):
281                         do.append(2*y - 1 - k)
282                 ng.append(y + S(1)/2)
283                 no.append(2**(2*y - 1))
284                 do.append(sqrt(S.Pi))
285 
286         # Try to reduce the number of gamma factors by applying the
287         # multiplication theorem (used when n gammas with args differing
288         # by 1/n mod 1 are encountered).
289         #
290         # run of 2 with args differing by 1/2
291         #
292         # >>> combsimp(gamma(x)*gamma(x+S.Half))
293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)
294         #
295         # run of 3 args differing by 1/3 (mod 1)
296         #
297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))
298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)
299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))
300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)
301         #
302         def _run(coeffs):
303             # find runs in coeffs such that the difference in terms (mod 1)
304             # of t1, t2, ..., tn is 1/n
305             u = list(uniq(coeffs))
306             for i in range(len(u)):
307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])
308                 for one, j in dj:
309                     if one.p == 1 and one.q != 1:
310                         n = one.q
311                         got = [i]
312                         get = list(range(1, n))
313                         for d, j in dj:
314                             m = n*d
315                             if m.is_Integer and m in get:
316                                 get.remove(m)
317                                 got.append(j)
318                                 if not get:
319                                     break
320                         else:
321                             continue
322                         for i, j in enumerate(got):
323                             c = u[j]
324                             coeffs.remove(c)
325                             got[i] = c
326                         return one.q, got[0], got[1:]
327 
328         def _mult_thm(gammas, numer, denom):
329             # pull off and analyze the leading coefficient from each gamma arg
330             # looking for runs in those Rationals
331 
332             # expr -> coeff + resid -> rats[resid] = coeff
333             rats = {}
334             for g in gammas:
335                 c, resid = g.as_coeff_Add()
336                 rats.setdefault(resid, []).append(c)
337 
338             # look for runs in Rationals for each resid
339             keys = sorted(rats, key=default_sort_key)
340             for resid in keys:
341                 coeffs = list(sorted(rats[resid]))
342                 new = []
343                 while True:
344                     run = _run(coeffs)
345                     if run is None:
346                         break
347 
348                     # process the sequence that was found:
349                     # 1) convert all the gamma functions to have the right
350                     #    argument (could be off by an integer)
351                     # 2) append the factors corresponding to the theorem
352                     # 3) append the new gamma function
353 
354                     n, ui, other = run
355 
356                     # (1)
357                     for u in other:
358                         con = resid + u - 1
359                         for k in range(int(u - ui)):
360                             numer.append(con - k)
361 
362                     con = n*(resid + ui)  # for (2) and (3)
363 
364                     # (2)
365                     numer.append((2*S.Pi)**(S(n - 1)/2)*
366                                  n**(S(1)/2 - con))
367                     # (3)
368                     new.append(con)
369 
370                 # restore resid to coeffs
371                 rats[resid] = [resid + c for c in coeffs] + new
372 
373             # rebuild the gamma arguments
374             g = []
375             for resid in keys:
376                 g += rats[resid]
377             # /!\ updating IN PLACE
378             gammas[:] = g
379 
380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),
381                                 (denom_gammas, denom_others, numer_others)]:
382             _mult_thm(l, numer, denom)
383 
384         # =========== level >= 2 work: factor absorbtion =========
385 
386         if level >= 2:
387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)
388             # and gamma(x)/(x - 1) -> gamma(x - 1)
389             # This code (in particular repeated calls to find_fuzzy) can be very
390             # slow.
391             def find_fuzzy(l, x):
392                 if not l:
393                     return
394                 S1, T1 = compute_ST(x)
395                 for y in l:
396                     S2, T2 = inv[y]
397                     if T1 != T2 or (not S1.intersection(S2) and
398                                     (S1 != set() or S2 != set())):
399                         continue
400                     # XXX we want some simplification (e.g. cancel or
401                     # simplify) but no matter what it's slow.
402                     a = len(cancel(x/y).free_symbols)
403                     b = len(x.free_symbols)
404                     c = len(y.free_symbols)
405                     # TODO is there a better heuristic?
406                     if a == 0 and (b > 0 or c > 0):
407                         return y
408 
409             # We thus try to avoid expensive calls by building the following
410             # "invariants": For every factor or gamma function argument
411             #   - the set of free symbols S
412             #   - the set of functional components T
413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset
414             # or S1 == S2 == emptyset)
415             inv = {}
416 
417             def compute_ST(expr):
418                 if expr in inv:
419                     return inv[expr]
420                 return (expr.free_symbols, expr.atoms(Function).union(
421                         set(e.exp for e in expr.atoms(Pow))))
422 
423             def update_ST(expr):
424                 inv[expr] = compute_ST(expr)
425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:
426                 update_ST(expr)
427 
428             for gammas, numer, denom in [(
429                 numer_gammas, numer_others, denom_others),
430                     (denom_gammas, denom_others, numer_others)]:
431                 new = []
432                 while gammas:
433                     g = gammas.pop()
434                     cont = True
435                     while cont:
436                         cont = False
437                         y = find_fuzzy(numer, g)
438                         if y is not None:
439                             numer.remove(y)
440                             if y != g:
441                                 numer.append(y/g)
442                                 update_ST(y/g)
443                             g += 1
444                             cont = True
445                         y = find_fuzzy(denom, g - 1)
446                         if y is not None:
447                             denom.remove(y)
448                             if y != g - 1:
449                                 numer.append((g - 1)/y)
450                                 update_ST((g - 1)/y)
451                             g -= 1
452                             cont = True
453                     new.append(g)
454                 # /!\ updating IN PLACE
455                 gammas[:] = new
456 
457         # =========== rebuild expr ==================================
458 
459         return Mul(*[gamma(g) for g in numer_gammas]) \
460             / Mul(*[gamma(g) for g in denom_gammas]) \
461             * Mul(*numer_others) / Mul(*denom_others)
462 
463     # (for some reason we cannot use Basic.replace in this case)
464     was = factor(expr)
465     expr = rule_gamma(was)
466     if expr != was:
467         expr = factor(expr)
468 
469     if not as_gamma:
470         if as_factorial:
471             expr = expr.rewrite(factorial)
472         elif as_binomial:
473             expr = expr.rewrite(binomial)
474 
475     return expr
476 
477 class _rf(Function):
478     @classmethod
479     def eval(cls, a, b):
480         if b.is_Integer:
481             if not b:
482                 return S.One
483 
484             n, result = int(b), S.One
485 
486             if n > 0:
487                 for i in range(n):
488                     result *= a + i
489 
490                 return result
491             elif n < 0:
492                 for i in range(1, -n + 1):
493                     result *= a - i
494 
495                 return 1/result
496         else:
497             if b.is_Add:
498                 c, _b = b.as_coeff_Add()
499 
500                 if c.is_Integer:
501                     if c > 0:
502                         return _rf(a, _b)*_rf(a + _b, c)
503                     elif c < 0:
504                         return _rf(a, _b)/_rf(a + _b + c, -c)
505 
506             if a.is_Add:
507                 c, _a = a.as_coeff_Add()
508 
509                 if c.is_Integer:
510                     if c > 0:
511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)
512                     elif c < 0:
513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)

</code><intended_behavior>Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself.</intended_behavior>]
2025-10-16 01:48:26.836 | INFO     | Search completed. Bug locations: [<file>sympy/core/mul.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 from functools import cmp_to_key
5 import operator
6 
7 from .sympify import sympify
8 from .basic import Basic
9 from .singleton import S
10 from .operations import AssocOp
11 from .cache import cacheit
12 from .logic import fuzzy_not, _fuzzy_group
13 from .compatibility import reduce, range
14 from .expr import Expr
15 
16 # internal marker to indicate:
17 #   "there are still non-commutative objects -- don't forget to process them"
18 
19 
20 class NC_Marker:
21     is_Order = False
22     is_Mul = False
23     is_Number = False
24     is_Poly = False
25 
26     is_commutative = False
27 
28 
29 # Key for sorting commutative args in canonical order
30 _args_sortkey = cmp_to_key(Basic.compare)
31 def _mulsort(args):
32     # in-place sorting of args
33     args.sort(key=_args_sortkey)
34 
35 
36 def _unevaluated_Mul(*args):
37     """Return a well-formed unevaluated Mul: Numbers are collected and
38     put in slot 0, any arguments that are Muls will be flattened, and args
39     are sorted. Use this when args have changed but you still want to return
40     an unevaluated Mul.
41 
42     Examples
43     ========
44 
45     >>> from sympy.core.mul import _unevaluated_Mul as uMul
46     >>> from sympy import S, sqrt, Mul
47     >>> from sympy.abc import x
48     >>> a = uMul(*[S(3.0), x, S(2)])
49     >>> a.args[0]
50     6.00000000000000
51     >>> a.args[1]
52     x
53 
54     Two unevaluated Muls with the same arguments will
55     always compare as equal during testing:
56 
57     >>> m = uMul(sqrt(2), sqrt(3))
58     >>> m == uMul(sqrt(3), sqrt(2))
59     True
60     >>> u = Mul(sqrt(3), sqrt(2), evaluate=False)
61     >>> m == uMul(u)
62     True
63     >>> m == Mul(*m.args)
64     False
65 
66     """
67     args = list(args)
68     newargs = []
69     ncargs = []
70     co = S.One
71     while args:
72         a = args.pop()
73         if a.is_Mul:
74             c, nc = a.args_cnc()
75             args.extend(c)
76             if nc:
77                 ncargs.append(Mul._from_args(nc))
78         elif a.is_Number:
79             co *= a
80         else:
81             newargs.append(a)
82     _mulsort(newargs)
83     if co is not S.One:
84         newargs.insert(0, co)
85     if ncargs:
86         newargs.append(Mul._from_args(ncargs))
87     return Mul._from_args(newargs)
88 
89 
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())
1664 
1665 
1666 def prod(a, start=1):
1667     """Return product of elements of a. Start with int 1 so if only
1668        ints are included then an int result is returned.
1669 
1670     Examples
1671     ========
1672 
1673     >>> from sympy import prod, S
1674     >>> prod(range(3))
1675     0
1676     >>> type(_) is int
1677     True
1678     >>> prod([S(2), 3])
1679     6
1680     >>> _.is_Integer
1681     True
1682 
1683     You can start the product at something other than 1:
1684 
1685     >>> prod([1, 2], 3)
1686     6
1687 
1688     """
1689     return reduce(operator.mul, a, start)
1690 
1691 
1692 def _keep_coeff(coeff, factors, clear=True, sign=False):
1693     """Return ``coeff*factors`` unevaluated if necessary.
1694 
1695     If ``clear`` is False, do not keep the coefficient as a factor
1696     if it can be distributed on a single factor such that one or
1697     more terms will still have integer coefficients.
1698 
1699     If ``sign`` is True, allow a coefficient of -1 to remain factored out.
1700 
1701     Examples
1702     ========
1703 
1704     >>> from sympy.core.mul import _keep_coeff
1705     >>> from sympy.abc import x, y
1706     >>> from sympy import S
1707 
1708     >>> _keep_coeff(S.Half, x + 2)
1709     (x + 2)/2
1710     >>> _keep_coeff(S.Half, x + 2, clear=False)
1711     x/2 + 1
1712     >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)
1713     y*(x + 2)/2
1714     >>> _keep_coeff(S(-1), x + y)
1715     -x - y
1716     >>> _keep_coeff(S(-1), x + y, sign=True)
1717     -(x + y)
1718     """
1719 
1720     if not coeff.is_Number:
1721         if factors.is_Number:
1722             factors, coeff = coeff, factors
1723         else:
1724             return coeff*factors
1725     if coeff is S.One:
1726         return factors
1727     elif coeff is S.NegativeOne and not sign:
1728         return -factors
1729     elif factors.is_Add:
1730         if not clear and coeff.is_Rational and coeff.q != 1:
1731             q = S(coeff.q)
1732             for i in factors.args:
1733                 c, t = i.as_coeff_Mul()
1734                 r = c/q
1735                 if r == int(r):
1736                     return coeff*factors
1737         return Mul._from_args((coeff, factors))
1738     elif factors.is_Mul:
1739         margs = list(factors.args)
1740         if margs[0].is_Number:
1741             margs[0] *= coeff
1742             if margs[0] == 1:
1743                 margs.pop(0)
1744         else:
1745             margs.insert(0, coeff)
1746         return Mul._from_args(margs)
1747     else:
1748         return coeff*factors
1749 
1750 
1751 def expand_2arg(e):
1752     from sympy.simplify.simplify import bottom_up
1753     def do(e):
1754         if e.is_Mul:
1755             c, r = e.as_coeff_Mul()
1756             if c.is_Number and r.is_Add:
1757                 return _unevaluated_Add(*[c*ri for ri in r.args])
1758         return e
1759     return bottom_up(e, do)
1760 
1761 
1762 from .numbers import Rational
1763 from .power import Pow
1764 from .add import Add, _addsort, _unevaluated_Add

</code><intended_behavior>Ensure that `is_Mul` accurately identifies only true multiplication expressions without mistakenly flagging other expression types due to simplification, evaluation, or manipulation errors.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow,
6     Symbol, sympify, expand_mul, expand_func,
7     Function, Dummy, Expr, factor_terms,
8     symbols, expand_power_exp)
9 from sympy.core.compatibility import (iterable,
10     ordered, range, as_int)
11 from sympy.core.numbers import Float, I, pi, Rational, Integer
12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg
13 from sympy.core.rules import Transform
14 from sympy.core.evaluate import global_evaluate
15 from sympy.functions import (
16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)
17 from sympy.functions.elementary.exponential import ExpBase
18 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
19 from sympy.functions.elementary.integers import ceiling
20 from sympy.functions.elementary.complexes import unpolarify
21 from sympy.functions.elementary.trigonometric import TrigonometricFunction
22 from sympy.functions.combinatorial.factorials import CombinatorialFunction
23 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
24 
25 from sympy.utilities.iterables import has_variety
26 
27 from sympy.simplify.radsimp import radsimp, fraction
28 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
29 from sympy.simplify.powsimp import powsimp
30 from sympy.simplify.cse_opts import sub_pre, sub_post
31 from sympy.simplify.sqrtdenest import sqrtdenest
32 from sympy.simplify.combsimp import combsimp
33 
34 from sympy.polys import (together, cancel, factor)
35 
36 
37 import mpmath
38 
39 
40 
41 def separatevars(expr, symbols=[], dict=False, force=False):
42     """
43     Separates variables in an expression, if possible.  By
44     default, it separates with respect to all symbols in an
45     expression and collects constant coefficients that are
46     independent of symbols.
47 
48     If dict=True then the separated terms will be returned
49     in a dictionary keyed to their corresponding symbols.
50     By default, all symbols in the expression will appear as
51     keys; if symbols are provided, then all those symbols will
52     be used as keys, and any terms in the expression containing
53     other symbols or non-symbols will be returned keyed to the
54     string 'coeff'. (Passing None for symbols will return the
55     expression in a dictionary keyed to 'coeff'.)
56 
57     If force=True, then bases of powers will be separated regardless
58     of assumptions on the symbols involved.
59 
60     Notes
61     =====
62     The order of the factors is determined by Mul, so that the
63     separated expressions may not necessarily be grouped together.
64 
65     Although factoring is necessary to separate variables in some
66     expressions, it is not necessary in all cases, so one should not
67     count on the returned factors being factored.
68 
69     Examples
70     ========
71 
72     >>> from sympy.abc import x, y, z, alpha
73     >>> from sympy import separatevars, sin
74     >>> separatevars((x*y)**y)
75     (x*y)**y
76     >>> separatevars((x*y)**y, force=True)
77     x**y*y**y
78 
79     >>> e = 2*x**2*z*sin(y)+2*z*x**2
80     >>> separatevars(e)
81     2*x**2*z*(sin(y) + 1)
82     >>> separatevars(e, symbols=(x, y), dict=True)
83     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
84     >>> separatevars(e, [x, y, alpha], dict=True)
85     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
86 
87     If the expression is not really separable, or is only partially
88     separable, separatevars will do the best it can to separate it
89     by using factoring.
90 
91     >>> separatevars(x + x*y - 3*x**2)
92     -x*(3*x - y - 1)
93 
94     If the expression is not separable then expr is returned unchanged
95     or (if dict=True) then None is returned.
96 
97     >>> eq = 2*x + y*sin(x)
98     >>> separatevars(eq) == eq
99     True
100     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None
101     True
102 
103     """
104     expr = sympify(expr)
105     if dict:
106         return _separatevars_dict(_separatevars(expr, force), symbols)
107     else:
108         return _separatevars(expr, force)
109 
110 
111 def _separatevars(expr, force):
112     if len(expr.free_symbols) == 1:
113         return expr
114     # don't destroy a Mul since much of the work may already be done
115     if expr.is_Mul:
116         args = list(expr.args)
117         changed = False
118         for i, a in enumerate(args):
119             args[i] = separatevars(a, force)
120             changed = changed or args[i] != a
121         if changed:
122             expr = expr.func(*args)
123         return expr
124 
125     # get a Pow ready for expansion
126     if expr.is_Pow:
127         expr = Pow(separatevars(expr.base, force=force), expr.exp)
128 
129     # First try other expansion methods
130     expr = expr.expand(mul=False, multinomial=False, force=force)
131 
132     _expr, reps = posify(expr) if force else (expr, {})
133     expr = factor(_expr).subs(reps)
134 
135     if not expr.is_Add:
136         return expr
137 
138     # Find any common coefficients to pull out
139     args = list(expr.args)
140     commonc = args[0].args_cnc(cset=True, warn=False)[0]
141     for i in args[1:]:
142         commonc &= i.args_cnc(cset=True, warn=False)[0]
143     commonc = Mul(*commonc)
144     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
145     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
146 
147     # remove them
148     for i, a in enumerate(args):
149         c, nc = a.args_cnc(cset=True, warn=False)
150         c = c - commonc_set
151         args[i] = Mul(*c)*Mul(*nc)
152     nonsepar = Add(*args)
153 
154     if len(nonsepar.free_symbols) > 1:
155         _expr = nonsepar
156         _expr, reps = posify(_expr) if force else (_expr, {})
157         _expr = (factor(_expr)).subs(reps)
158 
159         if not _expr.is_Add:
160             nonsepar = _expr
161 
162     return commonc*nonsepar
163 
164 
165 def _separatevars_dict(expr, symbols):
166     if symbols:
167         if not all((t.is_Atom for t in symbols)):
168             raise ValueError("symbols must be Atoms.")
169         symbols = list(symbols)
170     elif symbols is None:
171         return {'coeff': expr}
172     else:
173         symbols = list(expr.free_symbols)
174         if not symbols:
175             return None
176 
177     ret = dict(((i, []) for i in symbols + ['coeff']))
178 
179     for i in Mul.make_args(expr):
180         expsym = i.free_symbols
181         intersection = set(symbols).intersection(expsym)
182         if len(intersection) > 1:
183             return None
184         if len(intersection) == 0:
185             # There are no symbols, so it is part of the coefficient
186             ret['coeff'].append(i)
187         else:
188             ret[intersection.pop()].append(i)
189 
190     # rebuild
191     for k, v in ret.items():
192         ret[k] = Mul(*v)
193 
194     return ret
195 
196 
197 def _is_sum_surds(p):
198     args = p.args if p.is_Add else [p]
199     for y in args:
200         if not ((y**2).is_Rational and y.is_real):
201             return False
202     return True
203 
204 
205 def posify(eq):
206     """Return eq (with generic symbols made positive) and a
207     dictionary containing the mapping between the old and new
208     symbols.
209 
210     Any symbol that has positive=None will be replaced with a positive dummy
211     symbol having the same name. This replacement will allow more symbolic
212     processing of expressions, especially those involving powers and
213     logarithms.
214 
215     A dictionary that can be sent to subs to restore eq to its original
216     symbols is also returned.
217 
218     >>> from sympy import posify, Symbol, log, solve
219     >>> from sympy.abc import x
220     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
221     (_x + n + p, {_x: x})
222 
223     >>> eq = 1/x
224     >>> log(eq).expand()
225     log(1/x)
226     >>> log(posify(eq)[0]).expand()
227     -log(_x)
228     >>> p, rep = posify(eq)
229     >>> log(p).expand().subs(rep)
230     -log(x)
231 
232     It is possible to apply the same transformations to an iterable
233     of expressions:
234 
235     >>> eq = x**2 - 4
236     >>> solve(eq, x)
237     [-2, 2]
238     >>> eq_x, reps = posify([eq, x]); eq_x
239     [_x**2 - 4, _x]
240     >>> solve(*eq_x)
241     [2]
242     """
243     eq = sympify(eq)
244     if iterable(eq):
245         f = type(eq)
246         eq = list(eq)
247         syms = set()
248         for e in eq:
249             syms = syms.union(e.atoms(Symbol))
250         reps = {}
251         for s in syms:
252             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
253         for i, e in enumerate(eq):
254             eq[i] = e.subs(reps)
255         return f(eq), {r: s for s, r in reps.items()}
256 
257     reps = dict([(s, Dummy(s.name, positive=True))
258                  for s in eq.free_symbols if s.is_positive is None])
259     eq = eq.subs(reps)
260     return eq, {r: s for s, r in reps.items()}
261 
262 
263 def hypersimp(f, k):
264     """Given combinatorial term f(k) simplify its consecutive term ratio
265        i.e. f(k+1)/f(k).  The input term can be composed of functions and
266        integer sequences which have equivalent representation in terms
267        of gamma special function.
268 
269        The algorithm performs three basic steps:
270 
271        1. Rewrite all functions in terms of gamma, if possible.
272 
273        2. Rewrite all occurrences of gamma in terms of products
274           of gamma and rising factorial with integer,  absolute
275           constant exponent.
276 
277        3. Perform simplification of nested fractions, powers
278           and if the resulting expression is a quotient of
279           polynomials, reduce their total degree.
280 
281        If f(k) is hypergeometric then as result we arrive with a
282        quotient of polynomials of minimal degree. Otherwise None
283        is returned.
284 
285        For more information on the implemented algorithm refer to:
286 
287        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
288           Journal of Symbolic Computation (1995) 20, 399-417
289     """
290     f = sympify(f)
291 
292     g = f.subs(k, k + 1) / f
293 
294     g = g.rewrite(gamma)
295     g = expand_func(g)
296     g = powsimp(g, deep=True, combine='exp')
297 
298     if g.is_rational_function(k):
299         return simplify(g, ratio=S.Infinity)
300     else:
301         return None
302 
303 
304 def hypersimilar(f, g, k):
305     """Returns True if 'f' and 'g' are hyper-similar.
306 
307        Similarity in hypergeometric sense means that a quotient of
308        f(k) and g(k) is a rational function in k.  This procedure
309        is useful in solving recurrence relations.
310 
311        For more information see hypersimp().
312 
313     """
314     f, g = list(map(sympify, (f, g)))
315 
316     h = (f/g).rewrite(gamma)
317     h = h.expand(func=True, basic=False)
318 
319     return h.is_rational_function(k)
320 
321 
322 def signsimp(expr, evaluate=None):
323     """Make all Add sub-expressions canonical wrt sign.
324 
325     If an Add subexpression, ``a``, can have a sign extracted,
326     as determined by could_extract_minus_sign, it is replaced
327     with Mul(-1, a, evaluate=False). This allows signs to be
328     extracted from powers and products.
329 
330     Examples
331     ========
332 
333     >>> from sympy import signsimp, exp, symbols
334     >>> from sympy.abc import x, y
335     >>> i = symbols('i', odd=True)
336     >>> n = -1 + 1/x
337     >>> n/x/(-n)**2 - 1/n/x
338     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
339     >>> signsimp(_)
340     0
341     >>> x*n + x*-n
342     x*(-1 + 1/x) + x*(1 - 1/x)
343     >>> signsimp(_)
344     0
345 
346     Since powers automatically handle leading signs
347 
348     >>> (-2)**i
349     -2**i
350 
351     signsimp can be used to put the base of a power with an integer
352     exponent into canonical form:
353 
354     >>> n**i
355     (-1 + 1/x)**i
356 
357     By default, signsimp doesn't leave behind any hollow simplification:
358     if making an Add canonical wrt sign didn't change the expression, the
359     original Add is restored. If this is not desired then the keyword
360     ``evaluate`` can be set to False:
361 
362     >>> e = exp(y - x)
363     >>> signsimp(e) == e
364     True
365     >>> signsimp(e, evaluate=False)
366     exp(-(x - y))
367 
368     """
369     if evaluate is None:
370         evaluate = global_evaluate[0]
371     expr = sympify(expr)
372     if not isinstance(expr, Expr) or expr.is_Atom:
373         return expr
374     e = sub_post(sub_pre(expr))
375     if not isinstance(e, Expr) or e.is_Atom:
376         return e
377     if e.is_Add:
378         return e.func(*[signsimp(a) for a in e.args])
379     if evaluate:
380         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
381     return e
382 
383 
384 def simplify(expr, ratio=1.7, measure=count_ops, fu=False):
385     """
386     Simplifies the given expression.
387 
388     Simplification is not a well defined term and the exact strategies
389     this function tries can change in the future versions of SymPy. If
390     your algorithm relies on "simplification" (whatever it is), try to
391     determine what you need exactly  -  is it powsimp()?, radsimp()?,
392     together()?, logcombine()?, or something else? And use this particular
393     function directly, because those are well defined and thus your algorithm
394     will be robust.
395 
396     Nonetheless, especially for interactive use, or when you don't know
397     anything about the structure of the expression, simplify() tries to apply
398     intelligent heuristics to make the input expression "simpler".  For
399     example:
400 
401     >>> from sympy import simplify, cos, sin
402     >>> from sympy.abc import x, y
403     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
404     >>> a
405     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
406     >>> simplify(a)
407     x + 1
408 
409     Note that we could have obtained the same result by using specific
410     simplification functions:
411 
412     >>> from sympy import trigsimp, cancel
413     >>> trigsimp(a)
414     (x**2 + x)/x
415     >>> cancel(_)
416     x + 1
417 
418     In some cases, applying :func:`simplify` may actually result in some more
419     complicated expression. The default ``ratio=1.7`` prevents more extreme
420     cases: if (result length)/(input length) > ratio, then input is returned
421     unmodified.  The ``measure`` parameter lets you specify the function used
422     to determine how complex an expression is.  The function should take a
423     single argument as an expression and return a number such that if
424     expression ``a`` is more complex than expression ``b``, then
425     ``measure(a) > measure(b)``.  The default measure function is
426     :func:`count_ops`, which returns the total number of operations in the
427     expression.
428 
429     For example, if ``ratio=1``, ``simplify`` output can't be longer
430     than input.
431 
432     ::
433 
434         >>> from sympy import sqrt, simplify, count_ops, oo
435         >>> root = 1/(sqrt(2)+3)
436 
437     Since ``simplify(root)`` would result in a slightly longer expression,
438     root is returned unchanged instead::
439 
440        >>> simplify(root, ratio=1) == root
441        True
442 
443     If ``ratio=oo``, simplify will be applied anyway::
444 
445         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
446         True
447 
448     Note that the shortest expression is not necessary the simplest, so
449     setting ``ratio`` to 1 may not be a good idea.
450     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
451     choice.
452 
453     You can easily define your own measure function based on what you feel
454     should represent the "size" or "complexity" of the input expression.  Note
455     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
456     good metrics, but have other problems (in this case, the measure function
457     may slow down simplify too much for very large expressions).  If you don't
458     know what a good metric would be, the default, ``count_ops``, is a good
459     one.
460 
461     For example:
462 
463     >>> from sympy import symbols, log
464     >>> a, b = symbols('a b', positive=True)
465     >>> g = log(a) + log(b) + log(a)*log(1/b)
466     >>> h = simplify(g)
467     >>> h
468     log(a*b**(-log(a) + 1))
469     >>> count_ops(g)
470     8
471     >>> count_ops(h)
472     5
473 
474     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
475     However, we may not like how ``simplify`` (in this case, using
476     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
477     to reduce this would be to give more weight to powers as operations in
478     ``count_ops``.  We can do this by using the ``visual=True`` option:
479 
480     >>> print(count_ops(g, visual=True))
481     2*ADD + DIV + 4*LOG + MUL
482     >>> print(count_ops(h, visual=True))
483     2*LOG + MUL + POW + SUB
484 
485     >>> from sympy import Symbol, S
486     >>> def my_measure(expr):
487     ...     POW = Symbol('POW')
488     ...     # Discourage powers by giving POW a weight of 10
489     ...     count = count_ops(expr, visual=True).subs(POW, 10)
490     ...     # Every other operation gets a weight of 1 (the default)
491     ...     count = count.replace(Symbol, type(S.One))
492     ...     return count
493     >>> my_measure(g)
494     8
495     >>> my_measure(h)
496     14
497     >>> 15./8 > 1.7 # 1.7 is the default ratio
498     True
499     >>> simplify(g, measure=my_measure)
500     -log(a)*log(b) + log(a) + log(b)
501 
502     Note that because ``simplify()`` internally tries many different
503     simplification strategies and then compares them using the measure
504     function, we get a completely different result that is still different
505     from the input expression by doing this.
506     """
507     expr = sympify(expr)
508 
509     try:
510         return expr._eval_simplify(ratio=ratio, measure=measure)
511     except AttributeError:
512         pass
513 
514     original_expr = expr = signsimp(expr)
515 
516     from sympy.simplify.hyperexpand import hyperexpand
517     from sympy.functions.special.bessel import BesselBase
518     from sympy import Sum, Product
519 
520     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
521         return expr
522 
523     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):
524         if isinstance(expr, Function) and hasattr(expr, "inverse"):
525             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \
526                isinstance(expr.args[0], expr.inverse(argindex=1)):
527                 return simplify(expr.args[0].args[0], ratio=ratio,
528                                 measure=measure, fu=fu)
529         return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu)
530                          for x in expr.args])
531 
532     # TODO: Apply different strategies, considering expression pattern:
533     # is it a purely rational function? Is there any trigonometric function?...
534     # See also https://github.com/sympy/sympy/pull/185.
535 
536     def shorter(*choices):
537         '''Return the choice that has the fewest ops. In case of a tie,
538         the expression listed first is selected.'''
539         if not has_variety(choices):
540             return choices[0]
541         return min(choices, key=measure)
542 
543     expr = bottom_up(expr, lambda w: w.normal())
544     expr = Mul(*powsimp(expr).as_content_primitive())
545     _e = cancel(expr)
546     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
547     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
548 
549     if ratio is S.Infinity:
550         expr = expr2
551     else:
552         expr = shorter(expr2, expr1, expr)
553     if not isinstance(expr, Basic):  # XXX: temporary hack
554         return expr
555 
556     expr = factor_terms(expr, sign=False)
557 
558     # hyperexpand automatically only works on hypergeometric terms
559     expr = hyperexpand(expr)
560 
561     expr = piecewise_fold(expr)
562 
563     if expr.has(BesselBase):
564         expr = besselsimp(expr)
565 
566     if expr.has(TrigonometricFunction) and not fu or expr.has(
567             HyperbolicFunction):
568         expr = trigsimp(expr, deep=True)
569 
570     if expr.has(log):
571         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
572 
573     if expr.has(CombinatorialFunction, gamma):
574         expr = combsimp(expr)
575 
576     if expr.has(Sum):
577         expr = sum_simplify(expr)
578 
579     if expr.has(Product):
580         expr = product_simplify(expr)
581 
582     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
583     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
584     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
585         short = exptrigsimp(short, simplify=False)
586 
587     # get rid of hollow 2-arg Mul factorization
588     hollow_mul = Transform(
589         lambda x: Mul(*x.args),
590         lambda x:
591         x.is_Mul and
592         len(x.args) == 2 and
593         x.args[0].is_Number and
594         x.args[1].is_Add and
595         x.is_commutative)
596     expr = short.xreplace(hollow_mul)
597 
598     numer, denom = expr.as_numer_denom()
599     if denom.is_Add:
600         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
601         if n is not S.One:
602             expr = (numer*n).expand()/d
603 
604     if expr.could_extract_minus_sign():
605         n, d = fraction(expr)
606         if d != 0:
607             expr = signsimp(-n/(-d))
608 
609     if measure(expr) > ratio*measure(original_expr):
610         expr = original_expr
611 
612     return expr
613 
614 
615 def sum_simplify(s):
616     """Main function for Sum simplification"""
617     from sympy.concrete.summations import Sum
618     from sympy.core.function import expand
619 
620     terms = Add.make_args(expand(s))
621     s_t = [] # Sum Terms
622     o_t = [] # Other Terms
623 
624     for term in terms:
625         if isinstance(term, Mul):
626             other = 1
627             sum_terms = []
628 
629             if not term.has(Sum):
630                 o_t.append(term)
631                 continue
632 
633             mul_terms = Mul.make_args(term)
634             for mul_term in mul_terms:
635                 if isinstance(mul_term, Sum):
636                     r = mul_term._eval_simplify()
637                     sum_terms.extend(Add.make_args(r))
638                 else:
639                     other = other * mul_term
640             if len(sum_terms):
641                 #some simplification may have happened
642                 #use if so
643                 s_t.append(Mul(*sum_terms) * other)
644             else:
645                 o_t.append(other)
646         elif isinstance(term, Sum):
647             #as above, we need to turn this into an add list
648             r = term._eval_simplify()
649             s_t.extend(Add.make_args(r))
650         else:
651             o_t.append(term)
652 
653 
654     result = Add(sum_combine(s_t), *o_t)
655 
656     return result
657 
658 def sum_combine(s_t):
659     """Helper function for Sum simplification
660 
661        Attempts to simplify a list of sums, by combining limits / sum function's
662        returns the simplified sum
663     """
664     from sympy.concrete.summations import Sum
665 
666 
667     used = [False] * len(s_t)
668 
669     for method in range(2):
670         for i, s_term1 in enumerate(s_t):
671             if not used[i]:
672                 for j, s_term2 in enumerate(s_t):
673                     if not used[j] and i != j:
674                         temp = sum_add(s_term1, s_term2, method)
675                         if isinstance(temp, Sum) or isinstance(temp, Mul):
676                             s_t[i] = temp
677                             s_term1 = s_t[i]
678                             used[j] = True
679 
680     result = S.Zero
681     for i, s_term in enumerate(s_t):
682         if not used[i]:
683             result = Add(result, s_term)
684 
685     return result
686 
687 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
688     """Helper function for Sum simplification
689 
690        if limits is specified, "self" is the inner part of a sum
691 
692        Returns the sum with constant factors brought outside
693     """
694     from sympy.core.exprtools import factor_terms
695     from sympy.concrete.summations import Sum
696 
697     result = self.function if limits is None else self
698     limits = self.limits if limits is None else limits
699     #avoid any confusion w/ as_independent
700     if result == 0:
701         return S.Zero
702 
703     #get the summation variables
704     sum_vars = set([limit.args[0] for limit in limits])
705 
706     #finally we try to factor out any common terms
707     #and remove the from the sum if independent
708     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)
709     #avoid doing anything bad
710     if not result.is_commutative:
711         return Sum(result, *limits)
712 
713     i, d = retv.as_independent(*sum_vars)
714     if isinstance(retv, Add):
715         return i * Sum(1, *limits) + Sum(d, *limits)
716     else:
717         return i * Sum(d, *limits)
718 
719 def sum_add(self, other, method=0):
720     """Helper function for Sum simplification"""
721     from sympy.concrete.summations import Sum
722     from sympy import Mul
723 
724     #we know this is something in terms of a constant * a sum
725     #so we temporarily put the constants inside for simplification
726     #then simplify the result
727     def __refactor(val):
728         args = Mul.make_args(val)
729         sumv = next(x for x in args if isinstance(x, Sum))
730         constant = Mul(*[x for x in args if x != sumv])
731         return Sum(constant * sumv.function, *sumv.limits)
732 
733     if isinstance(self, Mul):
734         rself = __refactor(self)
735     else:
736         rself = self
737 
738     if isinstance(other, Mul):
739         rother = __refactor(other)
740     else:
741         rother = other
742 
743     if type(rself) == type(rother):
744         if method == 0:
745             if rself.limits == rother.limits:
746                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
747         elif method == 1:
748             if simplify(rself.function - rother.function) == 0:
749                 if len(rself.limits) == len(rother.limits) == 1:
750                     i = rself.limits[0][0]
751                     x1 = rself.limits[0][1]
752                     y1 = rself.limits[0][2]
753                     j = rother.limits[0][0]
754                     x2 = rother.limits[0][1]
755                     y2 = rother.limits[0][2]
756 
757                     if i == j:
758                         if x2 == y1 + 1:
759                             return factor_sum(Sum(rself.function, (i, x1, y2)))
760                         elif x1 == y2 + 1:
761                             return factor_sum(Sum(rself.function, (i, x2, y1)))
762 
763     return Add(self, other)
764 
765 
766 def product_simplify(s):
767     """Main function for Product simplification"""
768     from sympy.concrete.products import Product
769 
770     terms = Mul.make_args(s)
771     p_t = [] # Product Terms
772     o_t = [] # Other Terms
773 
774     for term in terms:
775         if isinstance(term, Product):
776             p_t.append(term)
777         else:
778             o_t.append(term)
779 
780     used = [False] * len(p_t)
781 
782     for method in range(2):
783         for i, p_term1 in enumerate(p_t):
784             if not used[i]:
785                 for j, p_term2 in enumerate(p_t):
786                     if not used[j] and i != j:
787                         if isinstance(product_mul(p_term1, p_term2, method), Product):
788                             p_t[i] = product_mul(p_term1, p_term2, method)
789                             used[j] = True
790 
791     result = Mul(*o_t)
792 
793     for i, p_term in enumerate(p_t):
794         if not used[i]:
795             result = Mul(result, p_term)
796 
797     return result
798 
799 
800 def product_mul(self, other, method=0):
801     """Helper function for Product simplification"""
802     from sympy.concrete.products import Product
803 
804     if type(self) == type(other):
805         if method == 0:
806             if self.limits == other.limits:
807                 return Product(self.function * other.function, *self.limits)
808         elif method == 1:
809             if simplify(self.function - other.function) == 0:
810                 if len(self.limits) == len(other.limits) == 1:
811                     i = self.limits[0][0]
812                     x1 = self.limits[0][1]
813                     y1 = self.limits[0][2]
814                     j = other.limits[0][0]
815                     x2 = other.limits[0][1]
816                     y2 = other.limits[0][2]
817 
818                     if i == j:
819                         if x2 == y1 + 1:
820                             return Product(self.function, (i, x1, y2))
821                         elif x1 == y2 + 1:
822                             return Product(self.function, (i, x2, y1))
823 
824     return Mul(self, other)
825 
826 
827 def _nthroot_solve(p, n, prec):
828     """
829      helper function for ``nthroot``
830      It denests ``p**Rational(1, n)`` using its minimal polynomial
831     """
832     from sympy.polys.numberfields import _minimal_polynomial_sq
833     from sympy.solvers import solve
834     while n % 2 == 0:
835         p = sqrtdenest(sqrt(p))
836         n = n // 2
837     if n == 1:
838         return p
839     pn = p**Rational(1, n)
840     x = Symbol('x')
841     f = _minimal_polynomial_sq(p, n, x)
842     if f is None:
843         return None
844     sols = solve(f, x)
845     for sol in sols:
846         if abs(sol - pn).n() < 1./10**prec:
847             sol = sqrtdenest(sol)
848             if _mexpand(sol**n) == p:
849                 return sol
850 
851 
852 def logcombine(expr, force=False):
853     """
854     Takes logarithms and combines them using the following rules:
855 
856     - log(x) + log(y) == log(x*y) if both are not negative
857     - a*log(x) == log(x**a) if x is positive and a is real
858 
859     If ``force`` is True then the assumptions above will be assumed to hold if
860     there is no assumption already in place on a quantity. For example, if
861     ``a`` is imaginary or the argument negative, force will not perform a
862     combination but if ``a`` is a symbol with no assumptions the change will
863     take place.
864 
865     Examples
866     ========
867 
868     >>> from sympy import Symbol, symbols, log, logcombine, I
869     >>> from sympy.abc import a, x, y, z
870     >>> logcombine(a*log(x) + log(y) - log(z))
871     a*log(x) + log(y) - log(z)
872     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
873     log(x**a*y/z)
874     >>> x,y,z = symbols('x,y,z', positive=True)
875     >>> a = Symbol('a', real=True)
876     >>> logcombine(a*log(x) + log(y) - log(z))
877     log(x**a*y/z)
878 
879     The transformation is limited to factors and/or terms that
880     contain logs, so the result depends on the initial state of
881     expansion:
882 
883     >>> eq = (2 + 3*I)*log(x)
884     >>> logcombine(eq, force=True) == eq
885     True
886     >>> logcombine(eq.expand(), force=True)
887     log(x**2) + I*log(x**3)
888 
889     See Also
890     ========
891     posify: replace all symbols with symbols having positive assumptions
892 
893     """
894 
895     def f(rv):
896         if not (rv.is_Add or rv.is_Mul):
897             return rv
898 
899         def gooda(a):
900             # bool to tell whether the leading ``a`` in ``a*log(x)``
901             # could appear as log(x**a)
902             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
903                 (a.is_real or force and a.is_real is not False))
904 
905         def goodlog(l):
906             # bool to tell whether log ``l``'s argument can combine with others
907             a = l.args[0]
908             return a.is_positive or force and a.is_nonpositive is not False
909 
910         other = []
911         logs = []
912         log1 = defaultdict(list)
913         for a in Add.make_args(rv):
914             if a.func is log and goodlog(a):
915                 log1[()].append(([], a))
916             elif not a.is_Mul:
917                 other.append(a)
918             else:
919                 ot = []
920                 co = []
921                 lo = []
922                 for ai in a.args:
923                     if ai.is_Rational and ai < 0:
924                         ot.append(S.NegativeOne)
925                         co.append(-ai)
926                     elif ai.func is log and goodlog(ai):
927                         lo.append(ai)
928                     elif gooda(ai):
929                         co.append(ai)
930                     else:
931                         ot.append(ai)
932                 if len(lo) > 1:
933                     logs.append((ot, co, lo))
934                 elif lo:
935                     log1[tuple(ot)].append((co, lo[0]))
936                 else:
937                     other.append(a)
938 
939         # if there is only one log at each coefficient and none have
940         # an exponent to place inside the log then there is nothing to do
941         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
942             return rv
943 
944         # collapse multi-logs as far as possible in a canonical way
945         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
946         # -- in this case, it's unambiguous, but if it were were a log(c) in
947         # each term then it's arbitrary whether they are grouped by log(a) or
948         # by log(c). So for now, just leave this alone; it's probably better to
949         # let the user decide
950         for o, e, l in logs:
951             l = list(ordered(l))
952             e = log(l.pop(0).args[0]**Mul(*e))
953             while l:
954                 li = l.pop(0)
955                 e = log(li.args[0]**e)
956             c, l = Mul(*o), e
957             if l.func is log:  # it should be, but check to be sure
958                 log1[(c,)].append(([], l))
959             else:
960                 other.append(c*l)
961 
962         # logs that have the same coefficient can multiply
963         for k in list(log1.keys()):
964             log1[Mul(*k)] = log(logcombine(Mul(*[
965                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
966                 force=force))
967 
968         # logs that have oppositely signed coefficients can divide
969         for k in ordered(list(log1.keys())):
970             if not k in log1:  # already popped as -k
971                 continue
972             if -k in log1:
973                 # figure out which has the minus sign; the one with
974                 # more op counts should be the one
975                 num, den = k, -k
976                 if num.count_ops() > den.count_ops():
977                     num, den = den, num
978                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))
979             else:
980                 other.append(k*log1.pop(k))
981 
982         return Add(*other)
983 
984     return bottom_up(expr, f)
985 
986 
987 def bottom_up(rv, F, atoms=False, nonbasic=False):
988     """Apply ``F`` to all expressions in an expression tree from the
989     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
990     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
991     """
992     try:
993         if rv.args:
994             args = tuple([bottom_up(a, F, atoms, nonbasic)
995                 for a in rv.args])
996             if args != rv.args:
997                 rv = rv.func(*args)
998             rv = F(rv)
999         elif atoms:
1000             rv = F(rv)
1001     except AttributeError:
1002         if nonbasic:
1003             try:
1004                 rv = F(rv)
1005             except TypeError:
1006                 pass
1007 
1008     return rv
1009 
1010 
1011 def besselsimp(expr):
1012     """
1013     Simplify bessel-type functions.
1014 
1015     This routine tries to simplify bessel-type functions. Currently it only
1016     works on the Bessel J and I functions, however. It works by looking at all
1017     such functions in turn, and eliminating factors of "I" and "-1" (actually
1018     their polar equivalents) in front of the argument. Then, functions of
1019     half-integer order are rewritten using strigonometric functions and
1020     functions of integer order (> 1) are rewritten using functions
1021     of low order.  Finally, if the expression was changed, compute
1022     factorization of the result with factor().
1023 
1024     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1025     >>> from sympy.abc import z, nu
1026     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1027     exp(I*pi*nu)*besselj(nu, z)
1028     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1029     exp(-I*pi*nu/2)*besselj(nu, z)
1030     >>> besselsimp(besseli(S(-1)/2, z))
1031     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1032     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1033     3*z*besseli(0, z)/2
1034     """
1035     # TODO
1036     # - better algorithm?
1037     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1038     # - use contiguity relations?
1039 
1040     def replacer(fro, to, factors):
1041         factors = set(factors)
1042 
1043         def repl(nu, z):
1044             if factors.intersection(Mul.make_args(z)):
1045                 return to(nu, z)
1046             return fro(nu, z)
1047         return repl
1048 
1049     def torewrite(fro, to):
1050         def tofunc(nu, z):
1051             return fro(nu, z).rewrite(to)
1052         return tofunc
1053 
1054     def tominus(fro):
1055         def tofunc(nu, z):
1056             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1057         return tofunc
1058 
1059     orig_expr = expr
1060 
1061     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1062     expr = expr.replace(
1063         besselj, replacer(besselj,
1064         torewrite(besselj, besseli), ifactors))
1065     expr = expr.replace(
1066         besseli, replacer(besseli,
1067         torewrite(besseli, besselj), ifactors))
1068 
1069     minusfactors = [-1, exp_polar(I*pi)]
1070     expr = expr.replace(
1071         besselj, replacer(besselj, tominus(besselj), minusfactors))
1072     expr = expr.replace(
1073         besseli, replacer(besseli, tominus(besseli), minusfactors))
1074 
1075     z0 = Dummy('z')
1076 
1077     def expander(fro):
1078         def repl(nu, z):
1079             if (nu % 1) == S(1)/2:
1080                 return exptrigsimp(trigsimp(unpolarify(
1081                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1082                             func=True)).subs(z0, z)))
1083             elif nu.is_Integer and nu > 1:
1084                 return fro(nu, z).expand(func=True)
1085             return fro(nu, z)
1086         return repl
1087 
1088     expr = expr.replace(besselj, expander(besselj))
1089     expr = expr.replace(bessely, expander(bessely))
1090     expr = expr.replace(besseli, expander(besseli))
1091     expr = expr.replace(besselk, expander(besselk))
1092 
1093     if expr != orig_expr:
1094         expr = expr.factor()
1095 
1096     return expr
1097 
1098 
1099 def nthroot(expr, n, max_len=4, prec=15):
1100     """
1101     compute a real nth-root of a sum of surds
1102 
1103     Parameters
1104     ==========
1105 
1106     expr : sum of surds
1107     n : integer
1108     max_len : maximum number of surds passed as constants to ``nsimplify``
1109 
1110     Algorithm
1111     =========
1112 
1113     First ``nsimplify`` is used to get a candidate root; if it is not a
1114     root the minimal polynomial is computed; the answer is one of its
1115     roots.
1116 
1117     Examples
1118     ========
1119 
1120     >>> from sympy.simplify.simplify import nthroot
1121     >>> from sympy import Rational, sqrt
1122     >>> nthroot(90 + 34*sqrt(7), 3)
1123     sqrt(7) + 3
1124 
1125     """
1126     expr = sympify(expr)
1127     n = sympify(n)
1128     p = expr**Rational(1, n)
1129     if not n.is_integer:
1130         return p
1131     if not _is_sum_surds(expr):
1132         return p
1133     surds = []
1134     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1135     for x, y in coeff_muls:
1136         if not x.is_rational:
1137             return p
1138         if y is S.One:
1139             continue
1140         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1141             return p
1142         surds.append(y)
1143     surds.sort()
1144     surds = surds[:max_len]
1145     if expr < 0 and n % 2 == 1:
1146         p = (-expr)**Rational(1, n)
1147         a = nsimplify(p, constants=surds)
1148         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1149         return -res
1150     a = nsimplify(p, constants=surds)
1151     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1152         return _mexpand(a)
1153     expr = _nthroot_solve(expr, n, prec)
1154     if expr is None:
1155         return p
1156     return expr
1157 
1158 
1159 def nsimplify(expr, constants=[], tolerance=None, full=False, rational=None):
1160     """
1161     Find a simple representation for a number or, if there are free symbols or
1162     if rational=True, then replace Floats with their Rational equivalents. If
1163     no change is made and rational is not False then Floats will at least be
1164     converted to Rationals.
1165 
1166     For numerical expressions, a simple formula that numerically matches the
1167     given numerical expression is sought (and the input should be possible
1168     to evalf to a precision of at least 30 digits).
1169 
1170     Optionally, a list of (rationally independent) constants to
1171     include in the formula may be given.
1172 
1173     A lower tolerance may be set to find less exact matches. If no tolerance
1174     is given then the least precise value will set the tolerance (e.g. Floats
1175     default to 15 digits of precision, so would be tolerance=10**-15).
1176 
1177     With full=True, a more extensive search is performed
1178     (this is useful to find simpler numbers when the tolerance
1179     is set low).
1180 
1181     Examples
1182     ========
1183 
1184     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi
1185     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1186     -2 + 2*GoldenRatio
1187     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1188     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1189     >>> nsimplify(I**I, [pi])
1190     exp(-pi/2)
1191     >>> nsimplify(pi, tolerance=0.01)
1192     22/7
1193 
1194     See Also
1195     ========
1196     sympy.core.function.nfloat
1197 
1198     """
1199     try:
1200         return sympify(as_int(expr))
1201     except (TypeError, ValueError):
1202         pass
1203     expr = sympify(expr).xreplace({
1204         Float('inf'): S.Infinity,
1205         Float('-inf'): S.NegativeInfinity,
1206         })
1207     if expr is S.Infinity or expr is S.NegativeInfinity:
1208         return expr
1209     if rational or expr.free_symbols:
1210         return _real_to_rational(expr, tolerance)
1211 
1212     # SymPy's default tolerance for Rationals is 15; other numbers may have
1213     # lower tolerances set, so use them to pick the largest tolerance if None
1214     # was given
1215     if tolerance is None:
1216         tolerance = 10**-min([15] +
1217              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1218              for n in expr.atoms(Float)])
1219     # XXX should prec be set independent of tolerance or should it be computed
1220     # from tolerance?
1221     prec = 30
1222     bprec = int(prec*3.33)
1223 
1224     constants_dict = {}
1225     for constant in constants:
1226         constant = sympify(constant)
1227         v = constant.evalf(prec)
1228         if not v.is_Float:
1229             raise ValueError("constants must be real-valued")
1230         constants_dict[str(constant)] = v._to_mpmath(bprec)
1231 
1232     exprval = expr.evalf(prec, chop=True)
1233     re, im = exprval.as_real_imag()
1234 
1235     # safety check to make sure that this evaluated to a number
1236     if not (re.is_Number and im.is_Number):
1237         return expr
1238 
1239     def nsimplify_real(x):
1240         orig = mpmath.mp.dps
1241         xv = x._to_mpmath(bprec)
1242         try:
1243             # We'll be happy with low precision if a simple fraction
1244             if not (tolerance or full):
1245                 mpmath.mp.dps = 15
1246                 rat = mpmath.pslq([xv, 1])
1247                 if rat is not None:
1248                     return Rational(-int(rat[1]), int(rat[0]))
1249             mpmath.mp.dps = prec
1250             newexpr = mpmath.identify(xv, constants=constants_dict,
1251                 tol=tolerance, full=full)
1252             if not newexpr:
1253                 raise ValueError
1254             if full:
1255                 newexpr = newexpr[0]
1256             expr = sympify(newexpr)
1257             if x and not expr:  # don't let x become 0
1258                 raise ValueError
1259             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1260                 raise ValueError
1261             return expr
1262         finally:
1263             # even though there are returns above, this is executed
1264             # before leaving
1265             mpmath.mp.dps = orig
1266     try:
1267         if re:
1268             re = nsimplify_real(re)
1269         if im:
1270             im = nsimplify_real(im)
1271     except ValueError:
1272         if rational is None:
1273             return _real_to_rational(expr)
1274         return expr
1275 
1276     rv = re + im*S.ImaginaryUnit
1277     # if there was a change or rational is explicitly not wanted
1278     # return the value, else return the Rational representation
1279     if rv != expr or rational is False:
1280         return rv
1281     return _real_to_rational(expr)
1282 
1283 
1284 def _real_to_rational(expr, tolerance=None):
1285     """
1286     Replace all reals in expr with rationals.
1287 
1288     >>> from sympy import nsimplify
1289     >>> from sympy.abc import x
1290 
1291     >>> nsimplify(.76 + .1*x**.5, rational=True)
1292     sqrt(x)/10 + 19/25
1293 
1294     """
1295     inf = Float('inf')
1296     p = expr
1297     reps = {}
1298     reduce_num = None
1299     if tolerance is not None and tolerance < 1:
1300         reduce_num = ceiling(1/tolerance)
1301     for float in p.atoms(Float):
1302         key = float
1303         if reduce_num is not None:
1304             r = Rational(float).limit_denominator(reduce_num)
1305         elif (tolerance is not None and tolerance >= 1 and
1306                 float.is_Integer is False):
1307             r = Rational(tolerance*round(float/tolerance)
1308                 ).limit_denominator(int(tolerance))
1309         else:
1310             r = nsimplify(float, rational=False)
1311             # e.g. log(3).n() -> log(3) instead of a Rational
1312             if float and not r:
1313                 r = Rational(float)
1314             elif not r.is_Rational:
1315                 if float == inf or float == -inf:
1316                     r = S.ComplexInfinity
1317                 elif float < 0:
1318                     float = -float
1319                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))
1320                     r = -Rational(str(float/d))*d
1321                 elif float > 0:
1322                     d = Pow(10, int((mpmath.log(float)/mpmath.log(10))))
1323                     r = Rational(str(float/d))*d
1324                 else:
1325                     r = Integer(0)
1326         reps[key] = r
1327     return p.subs(reps, simultaneous=True)
1328 
1329 
1330 def clear_coefficients(expr, rhs=S.Zero):
1331     """Return `p, r` where `p` is the expression obtained when Rational
1332     additive and multiplicative coefficients of `expr` have been stripped
1333     away in a naive fashion (i.e. without simplification). The operations
1334     needed to remove the coefficients will be applied to `rhs` and returned
1335     as `r`.
1336 
1337     Examples
1338     ========
1339 
1340     >>> from sympy.simplify.simplify import clear_coefficients
1341     >>> from sympy.abc import x, y
1342     >>> from sympy import Dummy
1343     >>> expr = 4*y*(6*x + 3)
1344     >>> clear_coefficients(expr - 2)
1345     (y*(2*x + 1), 1/6)
1346 
1347     When solving 2 or more expressions like `expr = a`,
1348     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1349     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1350 
1351     >>> rhs = Dummy('rhs')
1352     >>> clear_coefficients(expr, rhs)
1353     (y*(2*x + 1), _rhs/12)
1354     >>> _[1].subs(rhs, 2)
1355     1/6
1356     """
1357     was = None
1358     free = expr.free_symbols
1359     if expr.is_Rational:
1360         return (S.Zero, rhs - expr)
1361     while expr and was != expr:
1362         was = expr
1363         m, expr = (
1364             expr.as_content_primitive()
1365             if free else
1366             factor_terms(expr).as_coeff_Mul(rational=True))
1367         rhs /= m
1368         c, expr = expr.as_coeff_Add(rational=True)
1369         rhs -= c
1370     expr = signsimp(expr, evaluate = False)
1371     if _coeff_isneg(expr):
1372         expr = -expr
1373         rhs = -rhs
1374     return expr, rhs

</code><intended_behavior>Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself.</intended_behavior>, <file>sympy/simplify/combsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import Function, S, Mul, Pow, Add
4 from sympy.core.compatibility import ordered, default_sort_key
5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial
6 from sympy.functions import gamma, sqrt, sin
7 from sympy.polys import factor, cancel
8 
9 from sympy.utilities.timeutils import timethis
10 from sympy.utilities.iterables import sift
11 from sympy.utilities.iterables import uniq
12 
13 
14 
15 @timethis('combsimp')
16 def combsimp(expr):
17     r"""
18     Simplify combinatorial expressions.
19 
20     This function takes as input an expression containing factorials,
21     binomials, Pochhammer symbol and other "combinatorial" functions,
22     and tries to minimize the number of those functions and reduce
23     the size of their arguments.
24 
25     The algorithm works by rewriting all combinatorial functions as
26     expressions involving rising factorials (Pochhammer symbols) and
27     applies recurrence relations and other transformations applicable
28     to rising factorials, to reduce their arguments, possibly letting
29     the resulting rising factorial to cancel. Rising factorials with
30     the second argument being an integer are expanded into polynomial
31     forms and finally all other rising factorial are rewritten in terms
32     of more familiar functions. If the initial expression consisted of
33     gamma functions alone, the result is expressed in terms of gamma
34     functions. If the initial expression consists of gamma function
35     with some other combinatorial, the result is expressed in terms of
36     gamma functions.
37 
38     If the result is expressed using gamma functions, the following three
39     additional steps are performed:
40 
41     1. Reduce the number of gammas by applying the reflection theorem
42        gamma(x)*gamma(1-x) == pi/sin(pi*x).
43     2. Reduce the number of gammas by applying the multiplication theorem
44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).
45     3. Reduce the number of prefactors by absorbing them into gammas, where
46        possible.
47 
48     All transformation rules can be found (or was derived from) here:
49 
50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/
51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/
52 
53     Examples
54     ========
55 
56     >>> from sympy.simplify import combsimp
57     >>> from sympy import factorial, binomial
58     >>> from sympy.abc import n, k
59 
60     >>> combsimp(factorial(n)/factorial(n - 3))
61     n*(n - 2)*(n - 1)
62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))
63     (n + 1)/(k + 1)
64 
65     """
66 
67     # as a rule of thumb, if the expression contained gammas initially, it
68     # probably makes sense to retain them
69     as_gamma = expr.has(gamma)
70     as_factorial = expr.has(factorial)
71     as_binomial = expr.has(binomial)
72 
73 
74     expr = expr.replace(binomial,
75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))
76     expr = expr.replace(factorial,
77         lambda n: _rf(1, n.expand()))
78     expr = expr.rewrite(gamma)
79     expr = expr.replace(gamma,
80         lambda n: _rf(1, (n - 1).expand()))
81 
82     if as_gamma:
83         expr = expr.replace(_rf,
84             lambda a, b: gamma(a + b)/gamma(a))
85     else:
86         expr = expr.replace(_rf,
87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))
88 
89     def rule(n, k):
90         coeff, rewrite = S.One, False
91 
92         cn, _n = n.as_coeff_Add()
93 
94         if _n and cn.is_Integer and cn:
95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)
96             rewrite = True
97             n = _n
98 
99         # this sort of binomial has already been removed by
100         # rising factorials but is left here in case the order
101         # of rule application is changed
102         if k.is_Add:
103             ck, _k = k.as_coeff_Add()
104             if _k and ck.is_Integer and ck:
105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)
106                 rewrite = True
107                 k = _k
108 
109         if rewrite:
110             return coeff*binomial(n, k)
111 
112     expr = expr.replace(binomial, rule)
113 
114     def rule_gamma(expr, level=0):
115         """ Simplify products of gamma functions further. """
116 
117         if expr.is_Atom:
118             return expr
119 
120         def gamma_rat(x):
121             # helper to simplify ratios of gammas
122             was = x.count(gamma)
123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()
124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))
125             if xx.count(gamma) < was:
126                 x = xx
127             return x
128 
129         def gamma_factor(x):
130             # return True if there is a gamma factor in shallow args
131             if x.func is gamma:
132                 return True
133             if x.is_Add or x.is_Mul:
134                 return any(gamma_factor(xi) for xi in x.args)
135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):
136                 return gamma_factor(x.base)
137             return False
138 
139         # recursion step
140         if level == 0:
141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])
142             level += 1
143 
144         if not expr.is_Mul:
145             return expr
146 
147         # non-commutative step
148         if level == 1:
149             args, nc = expr.args_cnc()
150             if not args:
151                 return expr
152             if nc:
153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)
154             level += 1
155 
156         # pure gamma handling, not factor absorbtion
157         if level == 2:
158             sifted = sift(expr.args, gamma_factor)
159             gamma_ind = Mul(*sifted.pop(False, []))
160             d = Mul(*sifted.pop(True, []))
161             assert not sifted
162 
163             nd, dd = d.as_numer_denom()
164             for ipass in range(2):
165                 args = list(ordered(Mul.make_args(nd)))
166                 for i, ni in enumerate(args):
167                     if ni.is_Add:
168                         ni, dd = Add(*[
169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]
170                             ).as_numer_denom()
171                         args[i] = ni
172                         if not dd.has(gamma):
173                             break
174                 nd = Mul(*args)
175                 if ipass ==  0 and not gamma_factor(nd):
176                     break
177                 nd, dd = dd, nd  # now process in reversed order
178             expr = gamma_ind*nd/dd
179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):
180                 return expr
181             level += 1
182 
183         # iteration until constant
184         if level == 3:
185             while True:
186                 was = expr
187                 expr = rule_gamma(expr, 4)
188                 if expr == was:
189                     return expr
190 
191         numer_gammas = []
192         denom_gammas = []
193         numer_others = []
194         denom_others = []
195         def explicate(p):
196             if p is S.One:
197                 return None, []
198             b, e = p.as_base_exp()
199             if e.is_Integer:
200                 if b.func is gamma:
201                     return True, [b.args[0]]*e
202                 else:
203                     return False, [b]*e
204             else:
205                 return False, [p]
206 
207         newargs = list(ordered(expr.args))
208         while newargs:
209             n, d = newargs.pop().as_numer_denom()
210             isg, l = explicate(n)
211             if isg:
212                 numer_gammas.extend(l)
213             elif isg is False:
214                 numer_others.extend(l)
215             isg, l = explicate(d)
216             if isg:
217                 denom_gammas.extend(l)
218             elif isg is False:
219                 denom_others.extend(l)
220 
221         # =========== level 2 work: pure gamma manipulation =========
222 
223         # Try to reduce the number of gamma factors by applying the
224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)
225         for gammas, numer, denom in [(
226             numer_gammas, numer_others, denom_others),
227                 (denom_gammas, denom_others, numer_others)]:
228             new = []
229             while gammas:
230                 g1 = gammas.pop()
231                 if g1.is_integer:
232                     new.append(g1)
233                     continue
234                 for i, g2 in enumerate(gammas):
235                     n = g1 + g2 - 1
236                     if not n.is_Integer:
237                         continue
238                     numer.append(S.Pi)
239                     denom.append(sin(S.Pi*g1))
240                     gammas.pop(i)
241                     if n > 0:
242                         for k in range(n):
243                             numer.append(1 - g1 + k)
244                     elif n < 0:
245                         for k in range(-n):
246                             denom.append(-g1 - k)
247                     break
248                 else:
249                     new.append(g1)
250             # /!\ updating IN PLACE
251             gammas[:] = new
252 
253         # Try to reduce the number of gammas by using the duplication
254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =
255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could
256         # be done with higher argument ratios like gamma(3*x)/gamma(x),
257         # this would not reduce the number of gammas as in this case.
258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,
259                                 denom_others),
260                                (denom_gammas, numer_gammas, denom_others,
261                                 numer_others)]:
262 
263             while True:
264                 for x in ng:
265                     for y in dg:
266                         n = x - 2*y
267                         if n.is_Integer:
268                             break
269                     else:
270                         continue
271                     break
272                 else:
273                     break
274                 ng.remove(x)
275                 dg.remove(y)
276                 if n > 0:
277                     for k in range(n):
278                         no.append(2*y + k)
279                 elif n < 0:
280                     for k in range(-n):
281                         do.append(2*y - 1 - k)
282                 ng.append(y + S(1)/2)
283                 no.append(2**(2*y - 1))
284                 do.append(sqrt(S.Pi))
285 
286         # Try to reduce the number of gamma factors by applying the
287         # multiplication theorem (used when n gammas with args differing
288         # by 1/n mod 1 are encountered).
289         #
290         # run of 2 with args differing by 1/2
291         #
292         # >>> combsimp(gamma(x)*gamma(x+S.Half))
293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)
294         #
295         # run of 3 args differing by 1/3 (mod 1)
296         #
297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))
298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)
299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))
300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)
301         #
302         def _run(coeffs):
303             # find runs in coeffs such that the difference in terms (mod 1)
304             # of t1, t2, ..., tn is 1/n
305             u = list(uniq(coeffs))
306             for i in range(len(u)):
307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])
308                 for one, j in dj:
309                     if one.p == 1 and one.q != 1:
310                         n = one.q
311                         got = [i]
312                         get = list(range(1, n))
313                         for d, j in dj:
314                             m = n*d
315                             if m.is_Integer and m in get:
316                                 get.remove(m)
317                                 got.append(j)
318                                 if not get:
319                                     break
320                         else:
321                             continue
322                         for i, j in enumerate(got):
323                             c = u[j]
324                             coeffs.remove(c)
325                             got[i] = c
326                         return one.q, got[0], got[1:]
327 
328         def _mult_thm(gammas, numer, denom):
329             # pull off and analyze the leading coefficient from each gamma arg
330             # looking for runs in those Rationals
331 
332             # expr -> coeff + resid -> rats[resid] = coeff
333             rats = {}
334             for g in gammas:
335                 c, resid = g.as_coeff_Add()
336                 rats.setdefault(resid, []).append(c)
337 
338             # look for runs in Rationals for each resid
339             keys = sorted(rats, key=default_sort_key)
340             for resid in keys:
341                 coeffs = list(sorted(rats[resid]))
342                 new = []
343                 while True:
344                     run = _run(coeffs)
345                     if run is None:
346                         break
347 
348                     # process the sequence that was found:
349                     # 1) convert all the gamma functions to have the right
350                     #    argument (could be off by an integer)
351                     # 2) append the factors corresponding to the theorem
352                     # 3) append the new gamma function
353 
354                     n, ui, other = run
355 
356                     # (1)
357                     for u in other:
358                         con = resid + u - 1
359                         for k in range(int(u - ui)):
360                             numer.append(con - k)
361 
362                     con = n*(resid + ui)  # for (2) and (3)
363 
364                     # (2)
365                     numer.append((2*S.Pi)**(S(n - 1)/2)*
366                                  n**(S(1)/2 - con))
367                     # (3)
368                     new.append(con)
369 
370                 # restore resid to coeffs
371                 rats[resid] = [resid + c for c in coeffs] + new
372 
373             # rebuild the gamma arguments
374             g = []
375             for resid in keys:
376                 g += rats[resid]
377             # /!\ updating IN PLACE
378             gammas[:] = g
379 
380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),
381                                 (denom_gammas, denom_others, numer_others)]:
382             _mult_thm(l, numer, denom)
383 
384         # =========== level >= 2 work: factor absorbtion =========
385 
386         if level >= 2:
387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)
388             # and gamma(x)/(x - 1) -> gamma(x - 1)
389             # This code (in particular repeated calls to find_fuzzy) can be very
390             # slow.
391             def find_fuzzy(l, x):
392                 if not l:
393                     return
394                 S1, T1 = compute_ST(x)
395                 for y in l:
396                     S2, T2 = inv[y]
397                     if T1 != T2 or (not S1.intersection(S2) and
398                                     (S1 != set() or S2 != set())):
399                         continue
400                     # XXX we want some simplification (e.g. cancel or
401                     # simplify) but no matter what it's slow.
402                     a = len(cancel(x/y).free_symbols)
403                     b = len(x.free_symbols)
404                     c = len(y.free_symbols)
405                     # TODO is there a better heuristic?
406                     if a == 0 and (b > 0 or c > 0):
407                         return y
408 
409             # We thus try to avoid expensive calls by building the following
410             # "invariants": For every factor or gamma function argument
411             #   - the set of free symbols S
412             #   - the set of functional components T
413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset
414             # or S1 == S2 == emptyset)
415             inv = {}
416 
417             def compute_ST(expr):
418                 if expr in inv:
419                     return inv[expr]
420                 return (expr.free_symbols, expr.atoms(Function).union(
421                         set(e.exp for e in expr.atoms(Pow))))
422 
423             def update_ST(expr):
424                 inv[expr] = compute_ST(expr)
425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:
426                 update_ST(expr)
427 
428             for gammas, numer, denom in [(
429                 numer_gammas, numer_others, denom_others),
430                     (denom_gammas, denom_others, numer_others)]:
431                 new = []
432                 while gammas:
433                     g = gammas.pop()
434                     cont = True
435                     while cont:
436                         cont = False
437                         y = find_fuzzy(numer, g)
438                         if y is not None:
439                             numer.remove(y)
440                             if y != g:
441                                 numer.append(y/g)
442                                 update_ST(y/g)
443                             g += 1
444                             cont = True
445                         y = find_fuzzy(denom, g - 1)
446                         if y is not None:
447                             denom.remove(y)
448                             if y != g - 1:
449                                 numer.append((g - 1)/y)
450                                 update_ST((g - 1)/y)
451                             g -= 1
452                             cont = True
453                     new.append(g)
454                 # /!\ updating IN PLACE
455                 gammas[:] = new
456 
457         # =========== rebuild expr ==================================
458 
459         return Mul(*[gamma(g) for g in numer_gammas]) \
460             / Mul(*[gamma(g) for g in denom_gammas]) \
461             * Mul(*numer_others) / Mul(*denom_others)
462 
463     # (for some reason we cannot use Basic.replace in this case)
464     was = factor(expr)
465     expr = rule_gamma(was)
466     if expr != was:
467         expr = factor(expr)
468 
469     if not as_gamma:
470         if as_factorial:
471             expr = expr.rewrite(factorial)
472         elif as_binomial:
473             expr = expr.rewrite(binomial)
474 
475     return expr
476 
477 class _rf(Function):
478     @classmethod
479     def eval(cls, a, b):
480         if b.is_Integer:
481             if not b:
482                 return S.One
483 
484             n, result = int(b), S.One
485 
486             if n > 0:
487                 for i in range(n):
488                     result *= a + i
489 
490                 return result
491             elif n < 0:
492                 for i in range(1, -n + 1):
493                     result *= a - i
494 
495                 return 1/result
496         else:
497             if b.is_Add:
498                 c, _b = b.as_coeff_Add()
499 
500                 if c.is_Integer:
501                     if c > 0:
502                         return _rf(a, _b)*_rf(a + _b, c)
503                     elif c < 0:
504                         return _rf(a, _b)/_rf(a + _b + c, -c)
505 
506             if a.is_Add:
507                 c, _a = a.as_coeff_Add()
508 
509                 if c.is_Integer:
510                     if c > 0:
511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)
512                     elif c < 0:
513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)

</code><intended_behavior>Simplification methods should maintain the semantic integrity of expressions, ensuring that `is_Mul` flags are only applied when an actual multiplication operation is present in the simplified form, and not due to an artifact of the simplification process itself.</intended_behavior>]
2025-10-16 01:48:26.837 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 01:48:26.837 | INFO     | Search-only: skipping patch selection
2025-10-16 01:48:26.912 | INFO     | Task sympy__sympy-12301 completed successfully.
2025-10-16 01:48:26.913 | INFO     | No patch generated. You can try running ACR again.
