[
    {
        "rel_file_path": "sklearn/metrics/cluster/_supervised.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.22/sklearn/metrics/cluster/_supervised.py",
        "start": 565,
        "end": 648,
        "class_name": null,
        "method_name": "mutual_info_score",
        "code": "565 def mutual_info_score(labels_true, labels_pred, contingency=None):\n566     \"\"\"Mutual Information between two clusterings.\n567 \n568     The Mutual Information is a measure of the similarity between two labels of\n569     the same data. Where :math:`|U_i|` is the number of the samples\n570     in cluster :math:`U_i` and :math:`|V_j|` is the number of the\n571     samples in cluster :math:`V_j`, the Mutual Information\n572     between clusterings :math:`U` and :math:`V` is given as:\n573 \n574     .. math::\n575 \n576         MI(U,V)=\\\\sum_{i=1}^{|U|} \\\\sum_{j=1}^{|V|} \\\\frac{|U_i\\\\cap V_j|}{N}\n577         \\\\log\\\\frac{N|U_i \\\\cap V_j|}{|U_i||V_j|}\n578 \n579     This metric is independent of the absolute values of the labels:\n580     a permutation of the class or cluster label values won't change the\n581     score value in any way.\n582 \n583     This metric is furthermore symmetric: switching ``label_true`` with\n584     ``label_pred`` will return the same score value. This can be useful to\n585     measure the agreement of two independent label assignments strategies\n586     on the same dataset when the real ground truth is not known.\n587 \n588     Read more in the :ref:`User Guide <mutual_info_score>`.\n589 \n590     Parameters\n591     ----------\n592     labels_true : int array, shape = [n_samples]\n593         A clustering of the data into disjoint subsets.\n594 \n595     labels_pred : int array-like of shape (n_samples,)\n596         A clustering of the data into disjoint subsets.\n597 \n598     contingency : {None, array, sparse matrix}, \\\n599                   shape = [n_classes_true, n_classes_pred]\n600         A contingency matrix given by the :func:`contingency_matrix` function.\n601         If value is ``None``, it will be computed, otherwise the given value is\n602         used, with ``labels_true`` and ``labels_pred`` ignored.\n603 \n604     Returns\n605     -------\n606     mi : float\n607        Mutual information, a non-negative value\n608 \n609     Notes\n610     -----\n611     The logarithm used is the natural logarithm (base-e).\n612 \n613     See also\n614     --------\n615     adjusted_mutual_info_score: Adjusted against chance Mutual Information\n616     normalized_mutual_info_score: Normalized Mutual Information\n617     \"\"\"\n618     if contingency is None:\n619         labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n620         contingency = contingency_matrix(labels_true, labels_pred, sparse=True)\n621     else:\n622         contingency = check_array(contingency,\n623                                   accept_sparse=['csr', 'csc', 'coo'],\n624                                   dtype=[int, np.int32, np.int64])\n625 \n626     if isinstance(contingency, np.ndarray):\n627         # For an array\n628         nzx, nzy = np.nonzero(contingency)\n629         nz_val = contingency[nzx, nzy]\n630     elif sp.issparse(contingency):\n631         # For a sparse matrix\n632         nzx, nzy, nz_val = sp.find(contingency)\n633     else:\n634         raise ValueError(\"Unsupported type for 'contingency': %s\" %\n635                          type(contingency))\n636 \n637     contingency_sum = contingency.sum()\n638     pi = np.ravel(contingency.sum(axis=1))\n639     pj = np.ravel(contingency.sum(axis=0))\n640     log_contingency_nm = np.log(nz_val)\n641     contingency_nm = nz_val / contingency_sum\n642     # Don't need to calculate the full outer product, just for non-zeroes\n643     outer = (pi.take(nzx).astype(np.int64, copy=False)\n644              * pj.take(nzy).astype(np.int64, copy=False))\n645     log_outer = -np.log(outer) + log(pi.sum()) + log(pj.sum())\n646     mi = (contingency_nm * (log_contingency_nm - log(contingency_sum)) +\n647           contingency_nm * log_outer)\n648     return mi.sum()\n",
        "intended_behavior": "This method should handle inputs (labels) of any type, especially object arrays containing strings, for the computation of mutual information score without raising type conversion errors. The method or a related utility within its call path should include a preprocessing step to properly encode categorical data represented as strings into a numerical format suitable for the mutual information calculation or enhance the method to directly handle categorical data without inappropriate type conversion attempts."
    },
    {
        "rel_file_path": "sklearn/metrics/cluster/_supervised.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.22/sklearn/metrics/cluster/_supervised.py",
        "start": 79,
        "end": 133,
        "class_name": null,
        "method_name": "contingency_matrix",
        "code": "79 def contingency_matrix(labels_true, labels_pred, eps=None, sparse=False):\n80     \"\"\"Build a contingency matrix describing the relationship between labels.\n81 \n82     Parameters\n83     ----------\n84     labels_true : int array, shape = [n_samples]\n85         Ground truth class labels to be used as a reference\n86 \n87     labels_pred : array-like of shape (n_samples,)\n88         Cluster labels to evaluate\n89 \n90     eps : None or float, optional.\n91         If a float, that value is added to all values in the contingency\n92         matrix. This helps to stop NaN propagation.\n93         If ``None``, nothing is adjusted.\n94 \n95     sparse : boolean, optional.\n96         If True, return a sparse CSR continency matrix. If ``eps is not None``,\n97         and ``sparse is True``, will throw ValueError.\n98 \n99         .. versionadded:: 0.18\n100 \n101     Returns\n102     -------\n103     contingency : {array-like, sparse}, shape=[n_classes_true, n_classes_pred]\n104         Matrix :math:`C` such that :math:`C_{i, j}` is the number of samples in\n105         true class :math:`i` and in predicted class :math:`j`. If\n106         ``eps is None``, the dtype of this array will be integer. If ``eps`` is\n107         given, the dtype will be float.\n108         Will be a ``scipy.sparse.csr_matrix`` if ``sparse=True``.\n109     \"\"\"\n110 \n111     if eps is not None and sparse:\n112         raise ValueError(\"Cannot set 'eps' when sparse=True\")\n113 \n114     classes, class_idx = np.unique(labels_true, return_inverse=True)\n115     clusters, cluster_idx = np.unique(labels_pred, return_inverse=True)\n116     n_classes = classes.shape[0]\n117     n_clusters = clusters.shape[0]\n118     # Using coo_matrix to accelerate simple histogram calculation,\n119     # i.e. bins are consecutive integers\n120     # Currently, coo_matrix is faster than histogram2d for simple cases\n121     contingency = sp.coo_matrix((np.ones(class_idx.shape[0]),\n122                                  (class_idx, cluster_idx)),\n123                                 shape=(n_classes, n_clusters),\n124                                 dtype=np.int)\n125     if sparse:\n126         contingency = contingency.tocsr()\n127         contingency.sum_duplicates()\n128     else:\n129         contingency = contingency.toarray()\n130         if eps is not None:\n131             # don't use += as contingency is integer\n132             contingency = contingency + eps\n133     return contingency\n",
        "intended_behavior": "The function should be able to construct a contingency matrix from labels of any data type, including arrays of strings (object type). If necessary, it should include explicit handling or encoding of string-type labels to ensure that the matrix accurately reflects the relationships between true and predicted labels without data type conversion errors. This could involve incorporating a check or conversion for non-numeric label types to ensure compatibility with the matrix operations that follow."
    }
]