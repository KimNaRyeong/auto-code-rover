[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 1933,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import importlib\n14 import re\n15 import warnings\n16 from inspect import Parameter, Signature\n17 from types import ModuleType\n18 from typing import (\n19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union\n20 )\n21 \n22 from docutils.statemachine import StringList\n23 \n24 import sphinx\n25 from sphinx.application import Sphinx\n26 from sphinx.config import Config, ENUM\n27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n28 from sphinx.environment import BuildEnvironment\n29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members\n30 from sphinx.ext.autodoc.mock import mock\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect\n34 from sphinx.util import logging\n35 from sphinx.util import split_full_qualified_name\n36 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43     from sphinx.ext.autodoc.directive import DocumenterBridge\n44 \n45 \n46 logger = logging.getLogger(__name__)\n47 \n48 \n49 # This type isn't exposed directly in any modules, but can be found\n50 # here in most Python versions\n51 MethodDescriptorType = type(type.__subclasses__)\n52 \n53 \n54 #: extended signature RE: with explicit module name separated by ::\n55 py_ext_sig_re = re.compile(\n56     r'''^ ([\\w.]+::)?            # explicit module name\n57           ([\\w.]+\\.)?            # module and/or class name(s)\n58           (\\w+)  \\s*             # thing name\n59           (?: \\((.*)\\)           # optional: arguments\n60            (?:\\s* -> \\s* (.*))?  #           return annotation\n61           )? $                   # and nothing more\n62           ''', re.VERBOSE)\n63 \n64 \n65 def identity(x: Any) -> Any:\n66     return x\n67 \n68 \n69 ALL = object()\n70 UNINITIALIZED_ATTR = object()\n71 INSTANCEATTR = object()\n72 SLOTSATTR = object()\n73 \n74 \n75 def members_option(arg: Any) -> Union[object, List[str]]:\n76     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n77     if arg is None or arg is True:\n78         return ALL\n79     return [x.strip() for x in arg.split(',') if x.strip()]\n80 \n81 \n82 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n83     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n84     if arg is None:\n85         return ALL\n86     return {x.strip() for x in arg.split(',') if x.strip()}\n87 \n88 \n89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n90     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n91     if arg is None:\n92         return 'object'\n93     else:\n94         return arg\n95 \n96 \n97 def member_order_option(arg: Any) -> Optional[str]:\n98     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n99     if arg is None:\n100         return None\n101     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n102         return arg\n103     else:\n104         raise ValueError(__('invalid value for member-order option: %s') % arg)\n105 \n106 \n107 SUPPRESS = object()\n108 \n109 \n110 def annotation_option(arg: Any) -> Any:\n111     if arg is None:\n112         # suppress showing the representation of the object\n113         return SUPPRESS\n114     else:\n115         return arg\n116 \n117 \n118 def bool_option(arg: Any) -> bool:\n119     \"\"\"Used to convert flag options to auto directives.  (Instead of\n120     directives.flag(), which returns None).\n121     \"\"\"\n122     return True\n123 \n124 \n125 def merge_special_members_option(options: Dict) -> None:\n126     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n127     if 'special-members' in options and options['special-members'] is not ALL:\n128         if options.get('members') is ALL:\n129             pass\n130         elif options.get('members'):\n131             for member in options['special-members']:\n132                 if member not in options['members']:\n133                     options['members'].append(member)\n134         else:\n135             options['members'] = options['special-members']\n136 \n137 \n138 # Some useful event listener factories for autodoc-process-docstring.\n139 \n140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n141     \"\"\"Return a listener that removes the first *pre* and last *post*\n142     lines of every docstring.  If *what* is a sequence of strings,\n143     only docstrings of a type in *what* will be processed.\n144 \n145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n146 \n147        from sphinx.ext.autodoc import cut_lines\n148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n149 \n150     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n151     \"\"\"\n152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n153                 ) -> None:\n154         if what and what_ not in what:\n155             return\n156         del lines[:pre]\n157         if post:\n158             # remove one trailing blank line.\n159             if lines and not lines[-1]:\n160                 lines.pop(-1)\n161             del lines[-post:]\n162         # make sure there is a blank line at the end\n163         if lines and lines[-1]:\n164             lines.append('')\n165     return process\n166 \n167 \n168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n169             exclude: bool = False) -> Callable:\n170     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n171     lines between lines that match the *marker* regular expression.  If no line\n172     matches, the resulting docstring would be empty, so no change will be made\n173     unless *keepempty* is true.\n174 \n175     If *what* is a sequence of strings, only docstrings of a type in *what* will\n176     be processed.\n177     \"\"\"\n178     marker_re = re.compile(marker)\n179 \n180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n181                 ) -> None:\n182         if what and what_ not in what:\n183             return\n184         deleted = 0\n185         delete = not exclude\n186         orig_lines = lines[:]\n187         for i, line in enumerate(orig_lines):\n188             if delete:\n189                 lines.pop(i - deleted)\n190                 deleted += 1\n191             if marker_re.match(line):\n192                 delete = not delete\n193                 if delete:\n194                     lines.pop(i - deleted)\n195                     deleted += 1\n196         if not lines and not keepempty:\n197             lines[:] = orig_lines\n198         # make sure there is a blank line at the end\n199         if lines and lines[-1]:\n200             lines.append('')\n201     return process\n202 \n203 \n204 # This class is used only in ``sphinx.ext.autodoc.directive``,\n205 # But we define this class here to keep compatibility (see #4538)\n206 class Options(dict):\n207     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n208     def __getattr__(self, name: str) -> Any:\n209         try:\n210             return self[name.replace('_', '-')]\n211         except KeyError:\n212             return None\n213 \n214 \n215 class Documenter:\n216     \"\"\"\n217     A Documenter knows how to autodocument a single object type.  When\n218     registered with the AutoDirective, it will be used to document objects\n219     of that type when needed by autodoc.\n220 \n221     Its *objtype* attribute selects what auto directive it is assigned to\n222     (the directive name is 'auto' + objtype), and what directive it generates\n223     by default, though that can be overridden by an attribute called\n224     *directivetype*.\n225 \n226     A Documenter has an *option_spec* that works like a docutils directive's;\n227     in fact, it will be used to parse an auto directive's options that matches\n228     the documenter.\n229     \"\"\"\n230     #: name by which the directive is called (auto...) and the default\n231     #: generated directive name\n232     objtype = 'object'\n233     #: indentation by which to indent the directive content\n234     content_indent = '   '\n235     #: priority if multiple documenters return True from can_document_member\n236     priority = 0\n237     #: order if autodoc_member_order is set to 'groupwise'\n238     member_order = 0\n239     #: true if the generated content may contain titles\n240     titles_allowed = False\n241 \n242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n243 \n244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n245         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n247 \n248     @classmethod\n249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n250                             ) -> bool:\n251         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n252         raise NotImplementedError('must be implemented in subclasses')\n253 \n254     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n255         self.directive = directive\n256         self.env = directive.env    # type: BuildEnvironment\n257         self.options = directive.genopt\n258         self.name = name\n259         self.indent = indent\n260         # the module and object path within the module, and the fully\n261         # qualified name (all set after resolve_name succeeds)\n262         self.modname = None         # type: str\n263         self.module = None          # type: ModuleType\n264         self.objpath = None         # type: List[str]\n265         self.fullname = None        # type: str\n266         # extra signature items (arguments and return annotation,\n267         # also set after resolve_name succeeds)\n268         self.args = None            # type: str\n269         self.retann = None          # type: str\n270         # the object to document (set after import_object succeeds)\n271         self.object = None          # type: Any\n272         self.object_name = None     # type: str\n273         # the parent/owner of the object to document\n274         self.parent = None          # type: Any\n275         # the module analyzer to get at attribute docs, or None\n276         self.analyzer = None        # type: ModuleAnalyzer\n277 \n278     @property\n279     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n280         \"\"\"Returns registered Documenter classes\"\"\"\n281         return self.env.app.registry.documenters\n282 \n283     def add_line(self, line: str, source: str, *lineno: int) -> None:\n284         \"\"\"Append one line of generated reST to the output.\"\"\"\n285         if line.strip():  # not a blank line\n286             self.directive.result.append(self.indent + line, source, *lineno)\n287         else:\n288             self.directive.result.append('', source, *lineno)\n289 \n290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n291                      ) -> Tuple[str, List[str]]:\n292         \"\"\"Resolve the module and name of the object to document given by the\n293         arguments and the current module/class.\n294 \n295         Must return a pair of the module name and a chain of attributes; for\n296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n297         ``zipfile.ZipFile.open`` method.\n298         \"\"\"\n299         raise NotImplementedError('must be implemented in subclasses')\n300 \n301     def parse_name(self) -> bool:\n302         \"\"\"Determine what module to import and what attribute to document.\n303 \n304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n305         *self.args* and *self.retann* if parsing and resolving was successful.\n306         \"\"\"\n307         # first, parse the definition -- auto directives for classes and\n308         # functions can contain a signature which is then used instead of\n309         # an autogenerated one\n310         try:\n311             explicit_modname, path, base, args, retann = \\\n312                 py_ext_sig_re.match(self.name).groups()\n313         except AttributeError:\n314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n315                            type='autodoc')\n316             return False\n317 \n318         # support explicit module and class name separation via ::\n319         if explicit_modname is not None:\n320             modname = explicit_modname[:-2]\n321             parents = path.rstrip('.').split('.') if path else []\n322         else:\n323             modname = None\n324             parents = []\n325 \n326         with mock(self.env.config.autodoc_mock_imports):\n327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n328 \n329         if not self.modname:\n330             return False\n331 \n332         self.args = args\n333         self.retann = retann\n334         self.fullname = (self.modname or '') + \\\n335                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n336         return True\n337 \n338     def import_object(self) -> bool:\n339         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n340         it as *self.object*.\n341 \n342         Returns True if successful, False if an error occurred.\n343         \"\"\"\n344         with mock(self.env.config.autodoc_mock_imports):\n345             try:\n346                 ret = import_object(self.modname, self.objpath, self.objtype,\n347                                     attrgetter=self.get_attr,\n348                                     warningiserror=self.env.config.autodoc_warningiserror)\n349                 self.module, self.parent, self.object_name, self.object = ret\n350                 return True\n351             except ImportError as exc:\n352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n353                 self.env.note_reread()\n354                 return False\n355 \n356     def get_real_modname(self) -> str:\n357         \"\"\"Get the real module name of an object to document.\n358 \n359         It can differ from the name of the module through which the object was\n360         imported.\n361         \"\"\"\n362         return self.get_attr(self.object, '__module__', None) or self.modname\n363 \n364     def check_module(self) -> bool:\n365         \"\"\"Check if *self.object* is really defined in the module given by\n366         *self.modname*.\n367         \"\"\"\n368         if self.options.imported_members:\n369             return True\n370 \n371         subject = inspect.unpartial(self.object)\n372         modname = self.get_attr(subject, '__module__', None)\n373         if modname and modname != self.modname:\n374             return False\n375         return True\n376 \n377     def format_args(self, **kwargs: Any) -> str:\n378         \"\"\"Format the argument signature of *self.object*.\n379 \n380         Should return None if the object does not have a signature.\n381         \"\"\"\n382         return None\n383 \n384     def format_name(self) -> str:\n385         \"\"\"Format the name of *self.object*.\n386 \n387         This normally should be something that can be parsed by the generated\n388         directive, but doesn't need to be (Sphinx will display it unparsed\n389         then).\n390         \"\"\"\n391         # normally the name doesn't contain the module (except for module\n392         # directives of course)\n393         return '.'.join(self.objpath) or self.modname\n394 \n395     def _call_format_args(self, **kwargs: Any) -> str:\n396         if kwargs:\n397             try:\n398                 return self.format_args(**kwargs)\n399             except TypeError:\n400                 # avoid chaining exceptions, by putting nothing here\n401                 pass\n402 \n403         # retry without arguments for old documenters\n404         return self.format_args()\n405 \n406     def format_signature(self, **kwargs: Any) -> str:\n407         \"\"\"Format the signature (arguments and return annotation) of the object.\n408 \n409         Let the user process it via the ``autodoc-process-signature`` event.\n410         \"\"\"\n411         if self.args is not None:\n412             # signature given explicitly\n413             args = \"(%s)\" % self.args\n414             retann = self.retann\n415         else:\n416             # try to introspect the signature\n417             try:\n418                 retann = None\n419                 args = self._call_format_args(**kwargs)\n420                 if args:\n421                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n422                     if matched:\n423                         args = matched.group(1)\n424                         retann = matched.group(2)\n425             except Exception:\n426                 logger.warning(__('error while formatting arguments for %s:') %\n427                                self.fullname, type='autodoc', exc_info=True)\n428                 args = None\n429 \n430         result = self.env.events.emit_firstresult('autodoc-process-signature',\n431                                                   self.objtype, self.fullname,\n432                                                   self.object, self.options, args, retann)\n433         if result:\n434             args, retann = result\n435 \n436         if args is not None:\n437             return args + ((' -> %s' % retann) if retann else '')\n438         else:\n439             return ''\n440 \n441     def add_directive_header(self, sig: str) -> None:\n442         \"\"\"Add the directive header and options to the generated content.\"\"\"\n443         domain = getattr(self, 'domain', 'py')\n444         directive = getattr(self, 'directivetype', self.objtype)\n445         name = self.format_name()\n446         sourcename = self.get_sourcename()\n447 \n448         # one signature per line, indented by column\n449         prefix = '.. %s:%s:: ' % (domain, directive)\n450         for i, sig_line in enumerate(sig.split(\"\\n\")):\n451             self.add_line('%s%s%s' % (prefix, name, sig_line),\n452                           sourcename)\n453             if i == 0:\n454                 prefix = \" \" * len(prefix)\n455 \n456         if self.options.noindex:\n457             self.add_line('   :noindex:', sourcename)\n458         if self.objpath:\n459             # Be explicit about the module, this is necessary since .. class::\n460             # etc. don't support a prepended module name\n461             self.add_line('   :module: %s' % self.modname, sourcename)\n462 \n463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n464         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n465         if encoding is not None:\n466             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n467                           % self.__class__.__name__,\n468                           RemovedInSphinx40Warning, stacklevel=2)\n469         if ignore is not None:\n470             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n471                           % self.__class__.__name__,\n472                           RemovedInSphinx50Warning, stacklevel=2)\n473         docstring = getdoc(self.object, self.get_attr,\n474                            self.env.config.autodoc_inherit_docstrings,\n475                            self.parent, self.object_name)\n476         if docstring:\n477             tab_width = self.directive.state.document.settings.tab_width\n478             return [prepare_docstring(docstring, ignore, tab_width)]\n479         return []\n480 \n481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n482         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n483         for docstringlines in docstrings:\n484             if self.env.app:\n485                 # let extensions preprocess docstrings\n486                 self.env.app.emit('autodoc-process-docstring',\n487                                   self.objtype, self.fullname, self.object,\n488                                   self.options, docstringlines)\n489             yield from docstringlines\n490 \n491     def get_sourcename(self) -> str:\n492         if self.analyzer:\n493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n494         return 'docstring of %s' % self.fullname\n495 \n496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n497         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n498         # set sourcename and add content from attribute documentation\n499         sourcename = self.get_sourcename()\n500         if self.analyzer:\n501             attr_docs = self.analyzer.find_attr_docs()\n502             if self.objpath:\n503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n504                 if key in attr_docs:\n505                     no_docstring = True\n506                     # make a copy of docstring for attributes to avoid cache\n507                     # the change of autodoc-process-docstring event.\n508                     docstrings = [list(attr_docs[key])]\n509 \n510                     for i, line in enumerate(self.process_doc(docstrings)):\n511                         self.add_line(line, sourcename, i)\n512 \n513         # add content from docstrings\n514         if not no_docstring:\n515             docstrings = self.get_doc()\n516             if not docstrings:\n517                 # append at least a dummy docstring, so that the event\n518                 # autodoc-process-docstring is fired and can add some\n519                 # content if desired\n520                 docstrings.append([])\n521             for i, line in enumerate(self.process_doc(docstrings)):\n522                 self.add_line(line, sourcename, i)\n523 \n524         # add additional content (e.g. from document), if present\n525         if more_content:\n526             for line, src in zip(more_content.data, more_content.items):\n527                 self.add_line(line, src[0], src[1])\n528 \n529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n530         \"\"\"Return `(members_check_module, members)` where `members` is a\n531         list of `(membername, member)` pairs of the members of *self.object*.\n532 \n533         If *want_all* is True, return all members.  Else, only return those\n534         members given by *self.options.members* (which may also be none).\n535         \"\"\"\n536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n537         if not want_all:\n538             if not self.options.members:\n539                 return False, []\n540             # specific members given\n541             selected = []\n542             for name in self.options.members:\n543                 if name in members:\n544                     selected.append((name, members[name].value))\n545                 else:\n546                     logger.warning(__('missing attribute %s in object %s') %\n547                                    (name, self.fullname), type='autodoc')\n548             return False, selected\n549         elif self.options.inherited_members:\n550             return False, [(m.name, m.value) for m in members.values()]\n551         else:\n552             return False, [(m.name, m.value) for m in members.values()\n553                            if m.directly_defined]\n554 \n555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n556                        ) -> List[Tuple[str, Any, bool]]:\n557         \"\"\"Filter the given member list.\n558 \n559         Members are skipped if\n560 \n561         - they are private (except if given explicitly or the private-members\n562           option is set)\n563         - they are special methods (except if given explicitly or the\n564           special-members option is set)\n565         - they are undocumented (except if the undoc-members option is set)\n566 \n567         The user can override the skipping decision by connecting to the\n568         ``autodoc-skip-member`` event.\n569         \"\"\"\n570         def is_filtered_inherited_member(name: str) -> bool:\n571             if inspect.isclass(self.object):\n572                 for cls in self.object.__mro__:\n573                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n574                         # given member is a member of specified *super class*\n575                         return True\n576                     elif name in cls.__dict__:\n577                         return False\n578 \n579             return False\n580 \n581         ret = []\n582 \n583         # search for members in source code too\n584         namespace = '.'.join(self.objpath)  # will be empty for modules\n585 \n586         if self.analyzer:\n587             attr_docs = self.analyzer.find_attr_docs()\n588         else:\n589             attr_docs = {}\n590 \n591         # process members and determine which to skip\n592         for (membername, member) in members:\n593             # if isattr is True, the member is documented as an attribute\n594             if member is INSTANCEATTR:\n595                 isattr = True\n596             else:\n597                 isattr = False\n598 \n599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n600                          self.parent, self.object_name)\n601             if not isinstance(doc, str):\n602                 # Ignore non-string __doc__\n603                 doc = None\n604 \n605             # if the member __doc__ is the same as self's __doc__, it's just\n606             # inherited and therefore not the member's doc\n607             cls = self.get_attr(member, '__class__', None)\n608             if cls:\n609                 cls_doc = self.get_attr(cls, '__doc__', None)\n610                 if cls_doc == doc:\n611                     doc = None\n612             has_doc = bool(doc)\n613 \n614             metadata = extract_metadata(doc)\n615             if 'private' in metadata:\n616                 # consider a member private if docstring has \"private\" metadata\n617                 isprivate = True\n618             elif 'public' in metadata:\n619                 # consider a member public if docstring has \"public\" metadata\n620                 isprivate = False\n621             else:\n622                 isprivate = membername.startswith('_')\n623 \n624             keep = False\n625             if safe_getattr(member, '__sphinx_mock__', False):\n626                 # mocked module or object\n627                 pass\n628             elif want_all and membername.startswith('__') and \\\n629                     membername.endswith('__') and len(membername) > 4:\n630                 # special __methods__\n631                 if self.options.special_members is ALL:\n632                     if membername == '__doc__':\n633                         keep = False\n634                     elif is_filtered_inherited_member(membername):\n635                         keep = False\n636                     else:\n637                         keep = has_doc or self.options.undoc_members\n638                 elif self.options.special_members:\n639                     if membername in self.options.special_members:\n640                         keep = has_doc or self.options.undoc_members\n641             elif (namespace, membername) in attr_docs:\n642                 if want_all and isprivate:\n643                     # ignore members whose name starts with _ by default\n644                     keep = self.options.private_members\n645                 else:\n646                     # keep documented attributes\n647                     keep = True\n648                 isattr = True\n649             elif want_all and isprivate:\n650                 # ignore members whose name starts with _ by default\n651                 keep = self.options.private_members and \\\n652                     (has_doc or self.options.undoc_members)\n653             else:\n654                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n655                     keep = False\n656                 else:\n657                     # ignore undocumented members if :undoc-members: is not given\n658                     keep = has_doc or self.options.undoc_members\n659 \n660             # give the user a chance to decide whether this member\n661             # should be skipped\n662             if self.env.app:\n663                 # let extensions preprocess docstrings\n664                 try:\n665                     skip_user = self.env.app.emit_firstresult(\n666                         'autodoc-skip-member', self.objtype, membername, member,\n667                         not keep, self.options)\n668                     if skip_user is not None:\n669                         keep = not skip_user\n670                 except Exception as exc:\n671                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n672                                       'the following exception was raised:\\n%s'),\n673                                    member, exc, type='autodoc')\n674                     keep = False\n675 \n676             if keep:\n677                 ret.append((membername, member, isattr))\n678 \n679         return ret\n680 \n681     def document_members(self, all_members: bool = False) -> None:\n682         \"\"\"Generate reST for member documentation.\n683 \n684         If *all_members* is True, do all members, else those given by\n685         *self.options.members*.\n686         \"\"\"\n687         # set current namespace for finding members\n688         self.env.temp_data['autodoc:module'] = self.modname\n689         if self.objpath:\n690             self.env.temp_data['autodoc:class'] = self.objpath[0]\n691 \n692         want_all = all_members or self.options.inherited_members or \\\n693             self.options.members is ALL\n694         # find out which members are documentable\n695         members_check_module, members = self.get_object_members(want_all)\n696 \n697         # remove members given by exclude-members\n698         if self.options.exclude_members:\n699             members = [\n700                 (membername, member) for (membername, member) in members\n701                 if (\n702                     self.options.exclude_members is ALL or\n703                     membername not in self.options.exclude_members\n704                 )\n705             ]\n706 \n707         # document non-skipped members\n708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n709         for (mname, member, isattr) in self.filter_members(members, want_all):\n710             classes = [cls for cls in self.documenters.values()\n711                        if cls.can_document_member(member, mname, isattr, self)]\n712             if not classes:\n713                 # don't know how to document this member\n714                 continue\n715             # prefer the documenter with the highest priority\n716             classes.sort(key=lambda cls: cls.priority)\n717             # give explicitly separated module name, so that members\n718             # of inner classes can be documented\n719             full_mname = self.modname + '::' + \\\n720                 '.'.join(self.objpath + [mname])\n721             documenter = classes[-1](self.directive, full_mname, self.indent)\n722             memberdocumenters.append((documenter, isattr))\n723 \n724         member_order = self.options.member_order or self.env.config.autodoc_member_order\n725         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n726 \n727         for documenter, isattr in memberdocumenters:\n728             documenter.generate(\n729                 all_members=True, real_modname=self.real_modname,\n730                 check_module=members_check_module and not isattr)\n731 \n732         # reset current objects\n733         self.env.temp_data['autodoc:module'] = None\n734         self.env.temp_data['autodoc:class'] = None\n735 \n736     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n737                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n738         \"\"\"Sort the given member list.\"\"\"\n739         if order == 'groupwise':\n740             # sort by group; alphabetically within groups\n741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n742         elif order == 'bysource':\n743             if self.analyzer:\n744                 # sort by source order, by virtue of the module analyzer\n745                 tagorder = self.analyzer.tagorder\n746 \n747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n748                     fullname = entry[0].name.split('::')[1]\n749                     return tagorder.get(fullname, len(tagorder))\n750                 documenters.sort(key=keyfunc)\n751             else:\n752                 # Assume that member discovery order matches source order.\n753                 # This is a reasonable assumption in Python 3.6 and up, where\n754                 # module.__dict__ is insertion-ordered.\n755                 pass\n756         else:  # alphabetical\n757             documenters.sort(key=lambda e: e[0].name)\n758 \n759         return documenters\n760 \n761     def generate(self, more_content: Any = None, real_modname: str = None,\n762                  check_module: bool = False, all_members: bool = False) -> None:\n763         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n764         its members.\n765 \n766         If *more_content* is given, include that content. If *real_modname* is\n767         given, use that module name to find attribute docs. If *check_module* is\n768         True, only generate if the object is defined in the module name it is\n769         imported from. If *all_members* is True, document all members.\n770         \"\"\"\n771         if not self.parse_name():\n772             # need a module to import\n773             logger.warning(\n774                 __('don\\'t know which module to import for autodocumenting '\n775                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n776                    'in the document, or giving an explicit module name)') %\n777                 self.name, type='autodoc')\n778             return\n779 \n780         # now, import the module and get object to document\n781         if not self.import_object():\n782             return\n783 \n784         # If there is no real module defined, figure out which to use.\n785         # The real module is used in the module analyzer to look up the module\n786         # where the attribute documentation would actually be found in.\n787         # This is used for situations where you have a module that collects the\n788         # functions and classes of internal submodules.\n789         guess_modname = self.get_real_modname()\n790         self.real_modname = real_modname or guess_modname\n791 \n792         # try to also get a source code analyzer for attribute docs\n793         try:\n794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n795             # parse right now, to get PycodeErrors on parsing (results will\n796             # be cached anyway)\n797             self.analyzer.find_attr_docs()\n798         except PycodeError:\n799             logger.debug('[autodoc] module analyzer failed:', exc_info=True)\n800             # no source file -- e.g. for builtin and C modules\n801             self.analyzer = None\n802             # at least add the module.__file__ as a dependency\n803             if hasattr(self.module, '__file__') and self.module.__file__:\n804                 self.directive.filename_set.add(self.module.__file__)\n805         else:\n806             self.directive.filename_set.add(self.analyzer.srcname)\n807 \n808         if self.real_modname != guess_modname:\n809             # Add module to dependency list if target object is defined in other module.\n810             try:\n811                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n812                 self.directive.filename_set.add(analyzer.srcname)\n813             except PycodeError:\n814                 pass\n815 \n816         # check __module__ of object (for members not given explicitly)\n817         if check_module:\n818             if not self.check_module():\n819                 return\n820 \n821         sourcename = self.get_sourcename()\n822 \n823         # make sure that the result starts with an empty line.  This is\n824         # necessary for some situations where another directive preprocesses\n825         # reST and no starting newline is present\n826         self.add_line('', sourcename)\n827 \n828         # format the object's signature, if any\n829         sig = self.format_signature()\n830 \n831         # generate the directive header and options, if applicable\n832         self.add_directive_header(sig)\n833         self.add_line('', sourcename)\n834 \n835         # e.g. the module directive doesn't have content\n836         self.indent += self.content_indent\n837 \n838         # add all content (from docstrings, attribute docs etc.)\n839         self.add_content(more_content)\n840 \n841         # document members, if possible\n842         self.document_members(all_members)\n843 \n844 \n845 class ModuleDocumenter(Documenter):\n846     \"\"\"\n847     Specialized Documenter subclass for modules.\n848     \"\"\"\n849     objtype = 'module'\n850     content_indent = ''\n851     titles_allowed = True\n852 \n853     option_spec = {\n854         'members': members_option, 'undoc-members': bool_option,\n855         'noindex': bool_option, 'inherited-members': inherited_members_option,\n856         'show-inheritance': bool_option, 'synopsis': identity,\n857         'platform': identity, 'deprecated': bool_option,\n858         'member-order': member_order_option, 'exclude-members': members_set_option,\n859         'private-members': bool_option, 'special-members': members_option,\n860         'imported-members': bool_option, 'ignore-module-all': bool_option\n861     }  # type: Dict[str, Callable]\n862 \n863     def __init__(self, *args: Any) -> None:\n864         super().__init__(*args)\n865         merge_special_members_option(self.options)\n866         self.__all__ = None\n867 \n868     @classmethod\n869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n870                             ) -> bool:\n871         # don't document submodules automatically\n872         return False\n873 \n874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n875                      ) -> Tuple[str, List[str]]:\n876         if modname is not None:\n877             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n878                            type='autodoc')\n879         return (path or '') + base, []\n880 \n881     def parse_name(self) -> bool:\n882         ret = super().parse_name()\n883         if self.args or self.retann:\n884             logger.warning(__('signature arguments or return annotation '\n885                               'given for automodule %s') % self.fullname,\n886                            type='autodoc')\n887         return ret\n888 \n889     def import_object(self) -> Any:\n890         def is_valid_module_all(__all__: Any) -> bool:\n891             \"\"\"Check the given *__all__* is valid for a module.\"\"\"\n892             if (isinstance(__all__, (list, tuple)) and\n893                     all(isinstance(e, str) for e in __all__)):\n894                 return True\n895             else:\n896                 return False\n897 \n898         ret = super().import_object()\n899 \n900         if not self.options.ignore_module_all:\n901             __all__ = getattr(self.object, '__all__', None)\n902             if is_valid_module_all(__all__):\n903                 # valid __all__ found. copy it to self.__all__\n904                 self.__all__ = __all__\n905             elif __all__:\n906                 # invalid __all__ found.\n907                 logger.warning(__('__all__ should be a list of strings, not %r '\n908                                   '(in module %s) -- ignoring __all__') %\n909                                (__all__, self.fullname), type='autodoc')\n910 \n911         return ret\n912 \n913     def add_directive_header(self, sig: str) -> None:\n914         Documenter.add_directive_header(self, sig)\n915 \n916         sourcename = self.get_sourcename()\n917 \n918         # add some module-specific options\n919         if self.options.synopsis:\n920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n921         if self.options.platform:\n922             self.add_line('   :platform: ' + self.options.platform, sourcename)\n923         if self.options.deprecated:\n924             self.add_line('   :deprecated:', sourcename)\n925 \n926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n927         if want_all:\n928             if self.__all__:\n929                 memberlist = self.__all__\n930             else:\n931                 # for implicit module members, check __module__ to avoid\n932                 # documenting imported objects\n933                 return True, get_module_members(self.object)\n934         else:\n935             memberlist = self.options.members or []\n936         ret = []\n937         for mname in memberlist:\n938             try:\n939                 ret.append((mname, safe_getattr(self.object, mname)))\n940             except AttributeError:\n941                 logger.warning(\n942                     __('missing attribute mentioned in :members: or __all__: '\n943                        'module %s, attribute %s') %\n944                     (safe_getattr(self.object, '__name__', '???'), mname),\n945                     type='autodoc'\n946                 )\n947         return False, ret\n948 \n949     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n950                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n951         if order == 'bysource' and self.__all__:\n952             # Sort alphabetically first (for members not listed on the __all__)\n953             documenters.sort(key=lambda e: e[0].name)\n954 \n955             # Sort by __all__\n956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n957                 name = entry[0].name.split('::')[1]\n958                 if name in self.__all__:\n959                     return self.__all__.index(name)\n960                 else:\n961                     return len(self.__all__)\n962             documenters.sort(key=keyfunc)\n963 \n964             return documenters\n965         else:\n966             return super().sort_members(documenters, order)\n967 \n968 \n969 class ModuleLevelDocumenter(Documenter):\n970     \"\"\"\n971     Specialized Documenter subclass for objects on module level (functions,\n972     classes, data/constants).\n973     \"\"\"\n974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n975                      ) -> Tuple[str, List[str]]:\n976         if modname is None:\n977             if path:\n978                 stripped = path.rstrip('.')\n979                 modname, qualname = split_full_qualified_name(stripped)\n980                 if qualname:\n981                     parents = qualname.split(\".\")\n982                 else:\n983                     parents = []\n984 \n985             if modname is None:\n986                 # if documenting a toplevel object without explicit module,\n987                 # it can be contained in another auto directive ...\n988                 modname = self.env.temp_data.get('autodoc:module')\n989                 # ... or in the scope of a module directive\n990                 if not modname:\n991                     modname = self.env.ref_context.get('py:module')\n992                 # ... else, it stays None, which means invalid\n993         return modname, parents + [base]\n994 \n995 \n996 class ClassLevelDocumenter(Documenter):\n997     \"\"\"\n998     Specialized Documenter subclass for objects on class level (methods,\n999     attributes).\n1000     \"\"\"\n1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1002                      ) -> Tuple[str, List[str]]:\n1003         if modname is None:\n1004             if path:\n1005                 mod_cls = path.rstrip('.')\n1006             else:\n1007                 mod_cls = None\n1008                 # if documenting a class-level object without path,\n1009                 # there must be a current class, either from a parent\n1010                 # auto directive ...\n1011                 mod_cls = self.env.temp_data.get('autodoc:class')\n1012                 # ... or from a class directive\n1013                 if mod_cls is None:\n1014                     mod_cls = self.env.ref_context.get('py:class')\n1015                 # ... if still None, there's no way to know\n1016                 if mod_cls is None:\n1017                     return None, []\n1018 \n1019             try:\n1020                 modname, qualname = split_full_qualified_name(mod_cls)\n1021                 parents = qualname.split(\".\") if qualname else []\n1022             except ImportError:\n1023                 parents = mod_cls.split(\".\")\n1024 \n1025             # if the module name is still missing, get it like above\n1026             if not modname:\n1027                 modname = self.env.temp_data.get('autodoc:module')\n1028             if not modname:\n1029                 modname = self.env.ref_context.get('py:module')\n1030             # ... else, it stays None, which means invalid\n1031         return modname, parents + [base]\n1032 \n1033 \n1034 class DocstringSignatureMixin:\n1035     \"\"\"\n1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1037     feature of reading the signature from the docstring.\n1038     \"\"\"\n1039 \n1040     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1041         if encoding is not None:\n1042             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1043                           \"deprecated.\" % self.__class__.__name__,\n1044                           RemovedInSphinx40Warning, stacklevel=2)\n1045         docstrings = self.get_doc()\n1046         self._new_docstrings = docstrings[:]\n1047         result = None\n1048         for i, doclines in enumerate(docstrings):\n1049             # no lines in docstring, no match\n1050             if not doclines:\n1051                 continue\n1052             # match first line of docstring against signature RE\n1053             match = py_ext_sig_re.match(doclines[0])\n1054             if not match:\n1055                 continue\n1056             exmod, path, base, args, retann = match.groups()\n1057             # the base name must match ours\n1058             valid_names = [self.objpath[-1]]  # type: ignore\n1059             if isinstance(self, ClassDocumenter):\n1060                 valid_names.append('__init__')\n1061                 if hasattr(self.object, '__mro__'):\n1062                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1063             if base not in valid_names:\n1064                 continue\n1065             # re-prepare docstring to ignore more leading indentation\n1066             tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1067             self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n1068                                                         tabsize=tab_width)\n1069             result = args, retann\n1070             # don't look any further\n1071             break\n1072         return result\n1073 \n1074     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1075         if encoding is not None:\n1076             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1077                           % self.__class__.__name__,\n1078                           RemovedInSphinx40Warning, stacklevel=2)\n1079         lines = getattr(self, '_new_docstrings', None)\n1080         if lines is not None:\n1081             return lines\n1082         return super().get_doc(None, ignore)  # type: ignore\n1083 \n1084     def format_signature(self, **kwargs: Any) -> str:\n1085         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1086             # only act if a signature is not explicitly given already, and if\n1087             # the feature is enabled\n1088             result = self._find_signature()\n1089             if result is not None:\n1090                 self.args, self.retann = result\n1091         return super().format_signature(**kwargs)  # type: ignore\n1092 \n1093 \n1094 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1095     \"\"\"\n1096     Mixin for AttributeDocumenter to provide the\n1097     feature of stripping any function signature from the docstring.\n1098     \"\"\"\n1099     def format_signature(self, **kwargs: Any) -> str:\n1100         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1101             # only act if a signature is not explicitly given already, and if\n1102             # the feature is enabled\n1103             result = self._find_signature()\n1104             if result is not None:\n1105                 # Discarding _args is a only difference with\n1106                 # DocstringSignatureMixin.format_signature.\n1107                 # Documenter.format_signature use self.args value to format.\n1108                 _args, self.retann = result\n1109         return super().format_signature(**kwargs)\n1110 \n1111 \n1112 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1113     \"\"\"\n1114     Specialized Documenter subclass for functions.\n1115     \"\"\"\n1116     objtype = 'function'\n1117     member_order = 30\n1118 \n1119     @classmethod\n1120     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1121                             ) -> bool:\n1122         # supports functions, builtins and bound methods exported at the module level\n1123         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1124                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1125 \n1126     def format_args(self, **kwargs: Any) -> str:\n1127         if self.env.config.autodoc_typehints in ('none', 'description'):\n1128             kwargs.setdefault('show_annotation', False)\n1129 \n1130         try:\n1131             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1132             if inspect.is_singledispatch_function(self.object):\n1133                 sig = inspect.signature(self.object, follow_wrapped=True)\n1134             else:\n1135                 sig = inspect.signature(self.object)\n1136             args = stringify_signature(sig, **kwargs)\n1137         except TypeError as exc:\n1138             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1139                            self.fullname, exc)\n1140             return None\n1141         except ValueError:\n1142             args = ''\n1143 \n1144         if self.env.config.strip_signature_backslash:\n1145             # escape backslashes for reST\n1146             args = args.replace('\\\\', '\\\\\\\\')\n1147         return args\n1148 \n1149     def document_members(self, all_members: bool = False) -> None:\n1150         pass\n1151 \n1152     def add_directive_header(self, sig: str) -> None:\n1153         sourcename = self.get_sourcename()\n1154         super().add_directive_header(sig)\n1155 \n1156         if inspect.iscoroutinefunction(self.object):\n1157             self.add_line('   :async:', sourcename)\n1158 \n1159     def format_signature(self, **kwargs: Any) -> str:\n1160         sig = super().format_signature(**kwargs)\n1161         sigs = [sig]\n1162 \n1163         if inspect.is_singledispatch_function(self.object):\n1164             # append signature of singledispatch'ed functions\n1165             for typ, func in self.object.registry.items():\n1166                 if typ is object:\n1167                     pass  # default implementation. skipped.\n1168                 else:\n1169                     self.annotate_to_first_argument(func, typ)\n1170 \n1171                     documenter = FunctionDocumenter(self.directive, '')\n1172                     documenter.object = func\n1173                     sigs.append(documenter.format_signature())\n1174 \n1175         return \"\\n\".join(sigs)\n1176 \n1177     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1178         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1179         sig = inspect.signature(func)\n1180         if len(sig.parameters) == 0:\n1181             return\n1182 \n1183         params = list(sig.parameters.values())\n1184         if params[0].annotation is Parameter.empty:\n1185             params[0] = params[0].replace(annotation=typ)\n1186             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1187 \n1188 \n1189 class SingledispatchFunctionDocumenter(FunctionDocumenter):\n1190     \"\"\"\n1191     Used to be a specialized Documenter subclass for singledispatch'ed functions.\n1192 \n1193     Retained for backwards compatibility, now does the same as the FunctionDocumenter\n1194     \"\"\"\n1195 \n1196 \n1197 class DecoratorDocumenter(FunctionDocumenter):\n1198     \"\"\"\n1199     Specialized Documenter subclass for decorator functions.\n1200     \"\"\"\n1201     objtype = 'decorator'\n1202 \n1203     # must be lower than FunctionDocumenter\n1204     priority = -1\n1205 \n1206     def format_args(self, **kwargs: Any) -> Any:\n1207         args = super().format_args(**kwargs)\n1208         if ',' in args:\n1209             return args\n1210         else:\n1211             return None\n1212 \n1213 \n1214 # Types which have confusing metaclass signatures it would be best not to show.\n1215 # These are listed by name, rather than storing the objects themselves, to avoid\n1216 # needing to import the modules.\n1217 _METACLASS_CALL_BLACKLIST = [\n1218     'enum.EnumMeta.__call__',\n1219 ]\n1220 \n1221 \n1222 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1223     \"\"\"\n1224     Specialized Documenter subclass for classes.\n1225     \"\"\"\n1226     objtype = 'class'\n1227     member_order = 20\n1228     option_spec = {\n1229         'members': members_option, 'undoc-members': bool_option,\n1230         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1231         'show-inheritance': bool_option, 'member-order': member_order_option,\n1232         'exclude-members': members_set_option,\n1233         'private-members': bool_option, 'special-members': members_option,\n1234     }  # type: Dict[str, Callable]\n1235 \n1236     def __init__(self, *args: Any) -> None:\n1237         super().__init__(*args)\n1238         merge_special_members_option(self.options)\n1239 \n1240     @classmethod\n1241     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1242                             ) -> bool:\n1243         return isinstance(member, type)\n1244 \n1245     def import_object(self) -> Any:\n1246         ret = super().import_object()\n1247         # if the class is documented under another name, document it\n1248         # as data/attribute\n1249         if ret:\n1250             if hasattr(self.object, '__name__'):\n1251                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1252             else:\n1253                 self.doc_as_attr = True\n1254         return ret\n1255 \n1256     def _get_signature(self) -> Optional[Signature]:\n1257         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1258             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1259             if inspect.is_builtin_class_method(obj, attr):\n1260                 return None\n1261             attr = self.get_attr(obj, attr, None)\n1262             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1263                 return None\n1264             return attr\n1265 \n1266         # This sequence is copied from inspect._signature_from_callable.\n1267         # ValueError means that no signature could be found, so we keep going.\n1268 \n1269         # First, let's see if it has an overloaded __call__ defined\n1270         # in its metaclass\n1271         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1272 \n1273         if call is not None:\n1274             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1275                 call = None\n1276 \n1277         if call is not None:\n1278             self.env.app.emit('autodoc-before-process-signature', call, True)\n1279             try:\n1280                 return inspect.signature(call, bound_method=True)\n1281             except ValueError:\n1282                 pass\n1283 \n1284         # Now we check if the 'obj' class has a '__new__' method\n1285         new = get_user_defined_function_or_method(self.object, '__new__')\n1286         if new is not None:\n1287             self.env.app.emit('autodoc-before-process-signature', new, True)\n1288             try:\n1289                 return inspect.signature(new, bound_method=True)\n1290             except ValueError:\n1291                 pass\n1292 \n1293         # Finally, we should have at least __init__ implemented\n1294         init = get_user_defined_function_or_method(self.object, '__init__')\n1295         if init is not None:\n1296             self.env.app.emit('autodoc-before-process-signature', init, True)\n1297             try:\n1298                 return inspect.signature(init, bound_method=True)\n1299             except ValueError:\n1300                 pass\n1301 \n1302         # None of the attributes are user-defined, so fall back to let inspect\n1303         # handle it.\n1304         # We don't know the exact method that inspect.signature will read\n1305         # the signature from, so just pass the object itself to our hook.\n1306         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1307         try:\n1308             return inspect.signature(self.object, bound_method=False)\n1309         except ValueError:\n1310             pass\n1311 \n1312         # Still no signature: happens e.g. for old-style classes\n1313         # with __init__ in C and no `__text_signature__`.\n1314         return None\n1315 \n1316     def format_args(self, **kwargs: Any) -> str:\n1317         if self.env.config.autodoc_typehints in ('none', 'description'):\n1318             kwargs.setdefault('show_annotation', False)\n1319 \n1320         try:\n1321             sig = self._get_signature()\n1322         except TypeError as exc:\n1323             # __signature__ attribute contained junk\n1324             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1325                            self.fullname, exc)\n1326             return None\n1327 \n1328         if sig is None:\n1329             return None\n1330 \n1331         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1332 \n1333     def format_signature(self, **kwargs: Any) -> str:\n1334         if self.doc_as_attr:\n1335             return ''\n1336 \n1337         return super().format_signature(**kwargs)\n1338 \n1339     def add_directive_header(self, sig: str) -> None:\n1340         sourcename = self.get_sourcename()\n1341 \n1342         if self.doc_as_attr:\n1343             self.directivetype = 'attribute'\n1344         super().add_directive_header(sig)\n1345 \n1346         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1347             self.add_line('   :final:', sourcename)\n1348 \n1349         # add inheritance info, if wanted\n1350         if not self.doc_as_attr and self.options.show_inheritance:\n1351             sourcename = self.get_sourcename()\n1352             self.add_line('', sourcename)\n1353             if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1354                 bases = [':class:`%s`' % b.__name__\n1355                          if b.__module__ in ('__builtin__', 'builtins')\n1356                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)\n1357                          for b in self.object.__bases__]\n1358                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),\n1359                               sourcename)\n1360 \n1361     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1362         if encoding is not None:\n1363             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1364                           % self.__class__.__name__,\n1365                           RemovedInSphinx40Warning, stacklevel=2)\n1366         lines = getattr(self, '_new_docstrings', None)\n1367         if lines is not None:\n1368             return lines\n1369 \n1370         content = self.env.config.autoclass_content\n1371 \n1372         docstrings = []\n1373         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1374         if attrdocstring:\n1375             docstrings.append(attrdocstring)\n1376 \n1377         # for classes, what the \"docstring\" is can be controlled via a\n1378         # config value; the default is only the class docstring\n1379         if content in ('both', 'init'):\n1380             __init__ = self.get_attr(self.object, '__init__', None)\n1381             initdocstring = getdoc(__init__, self.get_attr,\n1382                                    self.env.config.autodoc_inherit_docstrings,\n1383                                    self.parent, self.object_name)\n1384             # for new-style classes, no __init__ means default __init__\n1385             if (initdocstring is not None and\n1386                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1387                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1388                 initdocstring = None\n1389             if not initdocstring:\n1390                 # try __new__\n1391                 __new__ = self.get_attr(self.object, '__new__', None)\n1392                 initdocstring = getdoc(__new__, self.get_attr,\n1393                                        self.env.config.autodoc_inherit_docstrings,\n1394                                        self.parent, self.object_name)\n1395                 # for new-style classes, no __new__ means default __new__\n1396                 if (initdocstring is not None and\n1397                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1398                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1399                     initdocstring = None\n1400             if initdocstring:\n1401                 if content == 'init':\n1402                     docstrings = [initdocstring]\n1403                 else:\n1404                     docstrings.append(initdocstring)\n1405 \n1406         tab_width = self.directive.state.document.settings.tab_width\n1407         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1408 \n1409     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1410         if self.doc_as_attr:\n1411             classname = safe_getattr(self.object, '__qualname__', None)\n1412             if not classname:\n1413                 classname = safe_getattr(self.object, '__name__', None)\n1414             if classname:\n1415                 module = safe_getattr(self.object, '__module__', None)\n1416                 parentmodule = safe_getattr(self.parent, '__module__', None)\n1417                 if module and module != parentmodule:\n1418                     classname = str(module) + '.' + str(classname)\n1419                 content = StringList([_('alias of :class:`%s`') % classname], source='')\n1420                 super().add_content(content, no_docstring=True)\n1421         else:\n1422             super().add_content(more_content)\n1423 \n1424     def document_members(self, all_members: bool = False) -> None:\n1425         if self.doc_as_attr:\n1426             return\n1427         super().document_members(all_members)\n1428 \n1429     def generate(self, more_content: Any = None, real_modname: str = None,\n1430                  check_module: bool = False, all_members: bool = False) -> None:\n1431         # Do not pass real_modname and use the name from the __module__\n1432         # attribute of the class.\n1433         # If a class gets imported into the module real_modname\n1434         # the analyzer won't find the source of the class, if\n1435         # it looks in real_modname.\n1436         return super().generate(more_content=more_content,\n1437                                 check_module=check_module,\n1438                                 all_members=all_members)\n1439 \n1440 \n1441 class ExceptionDocumenter(ClassDocumenter):\n1442     \"\"\"\n1443     Specialized ClassDocumenter subclass for exceptions.\n1444     \"\"\"\n1445     objtype = 'exception'\n1446     member_order = 10\n1447 \n1448     # needs a higher priority than ClassDocumenter\n1449     priority = 10\n1450 \n1451     @classmethod\n1452     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1453                             ) -> bool:\n1454         return isinstance(member, type) and issubclass(member, BaseException)\n1455 \n1456 \n1457 class DataDocumenter(ModuleLevelDocumenter):\n1458     \"\"\"\n1459     Specialized Documenter subclass for data items.\n1460     \"\"\"\n1461     objtype = 'data'\n1462     member_order = 40\n1463     priority = -10\n1464     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1465     option_spec[\"annotation\"] = annotation_option\n1466 \n1467     @classmethod\n1468     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1469                             ) -> bool:\n1470         return isinstance(parent, ModuleDocumenter) and isattr\n1471 \n1472     def add_directive_header(self, sig: str) -> None:\n1473         super().add_directive_header(sig)\n1474         sourcename = self.get_sourcename()\n1475         if not self.options.annotation:\n1476             # obtain annotation for this data\n1477             annotations = getattr(self.parent, '__annotations__', {})\n1478             if annotations and self.objpath[-1] in annotations:\n1479                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1480                 self.add_line('   :type: ' + objrepr, sourcename)\n1481             else:\n1482                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1483                 if self.analyzer and key in self.analyzer.annotations:\n1484                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1485                                   sourcename)\n1486 \n1487             try:\n1488                 if self.object is UNINITIALIZED_ATTR:\n1489                     pass\n1490                 else:\n1491                     objrepr = object_description(self.object)\n1492                     self.add_line('   :value: ' + objrepr, sourcename)\n1493             except ValueError:\n1494                 pass\n1495         elif self.options.annotation is SUPPRESS:\n1496             pass\n1497         else:\n1498             self.add_line('   :annotation: %s' % self.options.annotation,\n1499                           sourcename)\n1500 \n1501     def document_members(self, all_members: bool = False) -> None:\n1502         pass\n1503 \n1504     def get_real_modname(self) -> str:\n1505         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1506             or self.modname\n1507 \n1508 \n1509 class DataDeclarationDocumenter(DataDocumenter):\n1510     \"\"\"\n1511     Specialized Documenter subclass for data that cannot be imported\n1512     because they are declared without initial value (refs: PEP-526).\n1513     \"\"\"\n1514     objtype = 'datadecl'\n1515     directivetype = 'data'\n1516     member_order = 60\n1517 \n1518     # must be higher than AttributeDocumenter\n1519     priority = 11\n1520 \n1521     @classmethod\n1522     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1523                             ) -> bool:\n1524         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1525         return (isinstance(parent, ModuleDocumenter) and\n1526                 isattr and\n1527                 member is INSTANCEATTR)\n1528 \n1529     def import_object(self) -> bool:\n1530         \"\"\"Never import anything.\"\"\"\n1531         # disguise as a data\n1532         self.objtype = 'data'\n1533         self.object = UNINITIALIZED_ATTR\n1534         try:\n1535             # import module to obtain type annotation\n1536             self.parent = importlib.import_module(self.modname)\n1537         except ImportError:\n1538             pass\n1539 \n1540         return True\n1541 \n1542     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1543         \"\"\"Never try to get a docstring from the object.\"\"\"\n1544         super().add_content(more_content, no_docstring=True)\n1545 \n1546 \n1547 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1548     \"\"\"\n1549     Specialized Documenter subclass for methods (normal, static and class).\n1550     \"\"\"\n1551     objtype = 'method'\n1552     directivetype = 'method'\n1553     member_order = 50\n1554     priority = 1  # must be more than FunctionDocumenter\n1555 \n1556     @classmethod\n1557     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1558                             ) -> bool:\n1559         return inspect.isroutine(member) and \\\n1560             not isinstance(parent, ModuleDocumenter)\n1561 \n1562     def import_object(self) -> Any:\n1563         ret = super().import_object()\n1564         if not ret:\n1565             return ret\n1566 \n1567         # to distinguish classmethod/staticmethod\n1568         obj = self.parent.__dict__.get(self.object_name)\n1569         if obj is None:\n1570             obj = self.object\n1571 \n1572         if (inspect.isclassmethod(obj) or\n1573                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n1574             # document class and static members before ordinary ones\n1575             self.member_order = self.member_order - 1\n1576 \n1577         return ret\n1578 \n1579     def format_args(self, **kwargs: Any) -> str:\n1580         if self.env.config.autodoc_typehints in ('none', 'description'):\n1581             kwargs.setdefault('show_annotation', False)\n1582 \n1583         try:\n1584             if self.object == object.__init__ and self.parent != object:\n1585                 # Classes not having own __init__() method are shown as no arguments.\n1586                 #\n1587                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n1588                 #       But it makes users confused.\n1589                 args = '()'\n1590             else:\n1591                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n1592                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1593                     sig = inspect.signature(self.object, bound_method=False)\n1594                 else:\n1595                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n1596 \n1597                     meth = self.parent.__dict__.get(self.objpath[-1], None)\n1598                     if meth and inspect.is_singledispatch_method(meth):\n1599                         sig = inspect.signature(self.object, bound_method=True,\n1600                                                 follow_wrapped=True)\n1601                     else:\n1602                         sig = inspect.signature(self.object, bound_method=True)\n1603                 args = stringify_signature(sig, **kwargs)\n1604         except TypeError as exc:\n1605             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1606                            self.fullname, exc)\n1607             return None\n1608         except ValueError:\n1609             args = ''\n1610 \n1611         if self.env.config.strip_signature_backslash:\n1612             # escape backslashes for reST\n1613             args = args.replace('\\\\', '\\\\\\\\')\n1614         return args\n1615 \n1616     def add_directive_header(self, sig: str) -> None:\n1617         super().add_directive_header(sig)\n1618 \n1619         sourcename = self.get_sourcename()\n1620         obj = self.parent.__dict__.get(self.object_name, self.object)\n1621         if inspect.isabstractmethod(obj):\n1622             self.add_line('   :abstractmethod:', sourcename)\n1623         if inspect.iscoroutinefunction(obj):\n1624             self.add_line('   :async:', sourcename)\n1625         if inspect.isclassmethod(obj):\n1626             self.add_line('   :classmethod:', sourcename)\n1627         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n1628             self.add_line('   :staticmethod:', sourcename)\n1629         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1630             self.add_line('   :final:', sourcename)\n1631 \n1632     def document_members(self, all_members: bool = False) -> None:\n1633         pass\n1634 \n1635     def format_signature(self, **kwargs: Any) -> str:\n1636         sig = super().format_signature(**kwargs)\n1637         sigs = [sig]\n1638 \n1639         meth = self.parent.__dict__.get(self.objpath[-1])\n1640         if inspect.is_singledispatch_method(meth):\n1641             # append signature of singledispatch'ed functions\n1642             for typ, func in meth.dispatcher.registry.items():\n1643                 if typ is object:\n1644                     pass  # default implementation. skipped.\n1645                 else:\n1646                     self.annotate_to_first_argument(func, typ)\n1647 \n1648                     documenter = MethodDocumenter(self.directive, '')\n1649                     documenter.parent = self.parent\n1650                     documenter.object = func\n1651                     documenter.objpath = [None]\n1652                     sigs.append(documenter.format_signature())\n1653 \n1654         return \"\\n\".join(sigs)\n1655 \n1656     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1657         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1658         sig = inspect.signature(func)\n1659         if len(sig.parameters) == 1:\n1660             return\n1661 \n1662         params = list(sig.parameters.values())\n1663         if params[1].annotation is Parameter.empty:\n1664             params[1] = params[1].replace(annotation=typ)\n1665             func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1666 \n1667 \n1668 class SingledispatchMethodDocumenter(MethodDocumenter):\n1669     \"\"\"\n1670     Used to be a specialized Documenter subclass for singledispatch'ed methods.\n1671 \n1672     Retained for backwards compatibility, now does the same as the MethodDocumenter\n1673     \"\"\"\n1674 \n1675 \n1676 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1677     \"\"\"\n1678     Specialized Documenter subclass for attributes.\n1679     \"\"\"\n1680     objtype = 'attribute'\n1681     member_order = 60\n1682     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1683     option_spec[\"annotation\"] = annotation_option\n1684 \n1685     # must be higher than the MethodDocumenter, else it will recognize\n1686     # some non-data descriptors as methods\n1687     priority = 10\n1688 \n1689     @staticmethod\n1690     def is_function_or_method(obj: Any) -> bool:\n1691         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n1692 \n1693     @classmethod\n1694     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1695                             ) -> bool:\n1696         if inspect.isattributedescriptor(member):\n1697             return True\n1698         elif (not isinstance(parent, ModuleDocumenter) and\n1699               not inspect.isroutine(member) and\n1700               not isinstance(member, type)):\n1701             return True\n1702         else:\n1703             return False\n1704 \n1705     def document_members(self, all_members: bool = False) -> None:\n1706         pass\n1707 \n1708     def import_object(self) -> Any:\n1709         ret = super().import_object()\n1710         if inspect.isenumattribute(self.object):\n1711             self.object = self.object.value\n1712         if inspect.isattributedescriptor(self.object):\n1713             self._datadescriptor = True\n1714         else:\n1715             # if it's not a data descriptor\n1716             self._datadescriptor = False\n1717         return ret\n1718 \n1719     def get_real_modname(self) -> str:\n1720         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1721             or self.modname\n1722 \n1723     def add_directive_header(self, sig: str) -> None:\n1724         super().add_directive_header(sig)\n1725         sourcename = self.get_sourcename()\n1726         if not self.options.annotation:\n1727             # obtain type annotation for this attribute\n1728             annotations = getattr(self.parent, '__annotations__', {})\n1729             if annotations and self.objpath[-1] in annotations:\n1730                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1731                 self.add_line('   :type: ' + objrepr, sourcename)\n1732             else:\n1733                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1734                 if self.analyzer and key in self.analyzer.annotations:\n1735                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1736                                   sourcename)\n1737 \n1738             # data descriptors do not have useful values\n1739             if not self._datadescriptor:\n1740                 try:\n1741                     if self.object is INSTANCEATTR:\n1742                         pass\n1743                     else:\n1744                         objrepr = object_description(self.object)\n1745                         self.add_line('   :value: ' + objrepr, sourcename)\n1746                 except ValueError:\n1747                     pass\n1748         elif self.options.annotation is SUPPRESS:\n1749             pass\n1750         else:\n1751             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n1752 \n1753     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1754         if not self._datadescriptor:\n1755             # if it's not a data descriptor, its docstring is very probably the\n1756             # wrong thing to display\n1757             no_docstring = True\n1758         super().add_content(more_content, no_docstring)\n1759 \n1760 \n1761 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1762     \"\"\"\n1763     Specialized Documenter subclass for properties.\n1764     \"\"\"\n1765     objtype = 'property'\n1766     directivetype = 'method'\n1767     member_order = 60\n1768 \n1769     # before AttributeDocumenter\n1770     priority = AttributeDocumenter.priority + 1\n1771 \n1772     @classmethod\n1773     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1774                             ) -> bool:\n1775         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n1776 \n1777     def document_members(self, all_members: bool = False) -> None:\n1778         pass\n1779 \n1780     def get_real_modname(self) -> str:\n1781         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1782             or self.modname\n1783 \n1784     def add_directive_header(self, sig: str) -> None:\n1785         super().add_directive_header(sig)\n1786         sourcename = self.get_sourcename()\n1787         if inspect.isabstractmethod(self.object):\n1788             self.add_line('   :abstractmethod:', sourcename)\n1789         self.add_line('   :property:', sourcename)\n1790 \n1791 \n1792 class InstanceAttributeDocumenter(AttributeDocumenter):\n1793     \"\"\"\n1794     Specialized Documenter subclass for attributes that cannot be imported\n1795     because they are instance attributes (e.g. assigned in __init__).\n1796     \"\"\"\n1797     objtype = 'instanceattribute'\n1798     directivetype = 'attribute'\n1799     member_order = 60\n1800 \n1801     # must be higher than AttributeDocumenter\n1802     priority = 11\n1803 \n1804     @classmethod\n1805     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1806                             ) -> bool:\n1807         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1808         return (not isinstance(parent, ModuleDocumenter) and\n1809                 isattr and\n1810                 member is INSTANCEATTR)\n1811 \n1812     def import_object(self) -> bool:\n1813         \"\"\"Never import anything.\"\"\"\n1814         # disguise as an attribute\n1815         self.objtype = 'attribute'\n1816         self.object = INSTANCEATTR\n1817         self._datadescriptor = False\n1818         return True\n1819 \n1820     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1821         \"\"\"Never try to get a docstring from the object.\"\"\"\n1822         super().add_content(more_content, no_docstring=True)\n1823 \n1824 \n1825 class SlotsAttributeDocumenter(AttributeDocumenter):\n1826     \"\"\"\n1827     Specialized Documenter subclass for attributes that cannot be imported\n1828     because they are attributes in __slots__.\n1829     \"\"\"\n1830     objtype = 'slotsattribute'\n1831     directivetype = 'attribute'\n1832     member_order = 60\n1833 \n1834     # must be higher than AttributeDocumenter\n1835     priority = 11\n1836 \n1837     @classmethod\n1838     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1839                             ) -> bool:\n1840         \"\"\"This documents only SLOTSATTR members.\"\"\"\n1841         return member is SLOTSATTR\n1842 \n1843     def import_object(self) -> Any:\n1844         \"\"\"Never import anything.\"\"\"\n1845         # disguise as an attribute\n1846         self.objtype = 'attribute'\n1847         self._datadescriptor = True\n1848 \n1849         with mock(self.env.config.autodoc_mock_imports):\n1850             try:\n1851                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n1852                                     attrgetter=self.get_attr,\n1853                                     warningiserror=self.env.config.autodoc_warningiserror)\n1854                 self.module, _, _, self.parent = ret\n1855                 return True\n1856             except ImportError as exc:\n1857                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1858                 self.env.note_reread()\n1859                 return False\n1860 \n1861     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1862         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n1863         if ignore is not None:\n1864             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1865                           % self.__class__.__name__,\n1866                           RemovedInSphinx50Warning, stacklevel=2)\n1867         name = self.objpath[-1]\n1868         __slots__ = safe_getattr(self.parent, '__slots__', [])\n1869         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):\n1870             docstring = prepare_docstring(__slots__[name])\n1871             return [docstring]\n1872         else:\n1873             return []\n1874 \n1875 \n1876 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n1877     \"\"\"Returns registered Documenter classes\"\"\"\n1878     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n1879     return app.registry.documenters\n1880 \n1881 \n1882 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n1883     \"\"\"Alternative getattr() for types\"\"\"\n1884     for typ, func in app.registry.autodoc_attrgettrs.items():\n1885         if isinstance(obj, typ):\n1886             return func(obj, name, *defargs)\n1887 \n1888     return safe_getattr(obj, name, *defargs)\n1889 \n1890 \n1891 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n1892     if config.autodoc_member_order == 'alphabetic':\n1893         # RemovedInSphinx50Warning\n1894         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n1895                           'instead of \"alphabetic\". Please update your setting.'))\n1896         config.autodoc_member_order = 'alphabetical'  # type: ignore\n1897 \n1898 \n1899 def setup(app: Sphinx) -> Dict[str, Any]:\n1900     app.add_autodocumenter(ModuleDocumenter)\n1901     app.add_autodocumenter(ClassDocumenter)\n1902     app.add_autodocumenter(ExceptionDocumenter)\n1903     app.add_autodocumenter(DataDocumenter)\n1904     app.add_autodocumenter(DataDeclarationDocumenter)\n1905     app.add_autodocumenter(FunctionDocumenter)\n1906     app.add_autodocumenter(DecoratorDocumenter)\n1907     app.add_autodocumenter(MethodDocumenter)\n1908     app.add_autodocumenter(AttributeDocumenter)\n1909     app.add_autodocumenter(PropertyDocumenter)\n1910     app.add_autodocumenter(InstanceAttributeDocumenter)\n1911     app.add_autodocumenter(SlotsAttributeDocumenter)\n1912 \n1913     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n1914     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n1915                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n1916     app.add_config_value('autodoc_default_options', {}, True)\n1917     app.add_config_value('autodoc_docstring_signature', True, True)\n1918     app.add_config_value('autodoc_mock_imports', [], True)\n1919     app.add_config_value('autodoc_typehints', \"signature\", True,\n1920                          ENUM(\"signature\", \"description\", \"none\"))\n1921     app.add_config_value('autodoc_warningiserror', True, True)\n1922     app.add_config_value('autodoc_inherit_docstrings', True, True)\n1923     app.add_event('autodoc-before-process-signature')\n1924     app.add_event('autodoc-process-docstring')\n1925     app.add_event('autodoc-process-signature')\n1926     app.add_event('autodoc-skip-member')\n1927 \n1928     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n1929 \n1930     app.setup_extension('sphinx.ext.autodoc.type_comment')\n1931     app.setup_extension('sphinx.ext.autodoc.typehints')\n1932 \n1933     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "Modify the logic that parses method signatures from docstrings to iteratively capture all signatures present for overloaded methods. The modified code should ensure that each overloaded method signature is identified, parsed, and included in the generated documentation, rather than only recognizing the first signature. This enhancement should preserve the existing functionality of handling single-method docstrings while extending support for overloaded method signatures."
    },
    {
        "rel_file_path": "sphinx/ext/napoleon/docstring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/ext/napoleon/docstring.py",
        "start": 1,
        "end": 1039,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon.docstring\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5 \n6     Classes for docstring parsing and formatting.\n7 \n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import inspect\n14 import re\n15 from functools import partial\n16 from typing import Any, Callable, Dict, List, Tuple, Union\n17 \n18 from sphinx.application import Sphinx\n19 from sphinx.config import Config as SphinxConfig\n20 from sphinx.ext.napoleon.iterators import modify_iter\n21 from sphinx.locale import _\n22 \n23 if False:\n24     # For type annotation\n25     from typing import Type  # for python3.5.1\n26 \n27 \n28 _directive_regex = re.compile(r'\\.\\. \\S+::')\n29 _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n30 _google_typed_arg_regex = re.compile(r'\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)')\n31 _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n33 _xref_or_code_regex = re.compile(\n34     r'((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'\n35     r'(?:``.+``))')\n36 _bullet_list_regex = re.compile(r'^(\\*|\\+|\\-)(\\s+\\S|\\s*$)')\n37 _enumerated_list_regex = re.compile(\n38     r'^(?P<paren>\\()?'\n39     r'(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'\n40     r'(?(paren)\\)|\\.)(\\s+\\S|\\s*$)')\n41 \n42 \n43 class GoogleDocstring:\n44     \"\"\"Convert Google style docstrings to reStructuredText.\n45 \n46     Parameters\n47     ----------\n48     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n49         The docstring to parse, given either as a string or split into\n50         individual lines.\n51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n52         The configuration settings to use. If not given, defaults to the\n53         config object on `app`; or if `app` is not given defaults to the\n54         a new :class:`sphinx.ext.napoleon.Config` object.\n55 \n56 \n57     Other Parameters\n58     ----------------\n59     app : :class:`sphinx.application.Sphinx`, optional\n60         Application object representing the Sphinx process.\n61     what : :obj:`str`, optional\n62         A string specifying the type of the object to which the docstring\n63         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n64         \"method\", \"attribute\".\n65     name : :obj:`str`, optional\n66         The fully qualified name of the object.\n67     obj : module, class, exception, function, method, or attribute\n68         The object to which the docstring belongs.\n69     options : :class:`sphinx.ext.autodoc.Options`, optional\n70         The options given to the directive: an object with attributes\n71         inherited_members, undoc_members, show_inheritance and noindex that\n72         are True if the flag option of same name was given to the auto\n73         directive.\n74 \n75 \n76     Example\n77     -------\n78     >>> from sphinx.ext.napoleon import Config\n79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n80     >>> docstring = '''One line summary.\n81     ...\n82     ... Extended description.\n83     ...\n84     ... Args:\n85     ...   arg1(int): Description of `arg1`\n86     ...   arg2(str): Description of `arg2`\n87     ... Returns:\n88     ...   str: Description of return value.\n89     ... '''\n90     >>> print(GoogleDocstring(docstring, config))\n91     One line summary.\n92     <BLANKLINE>\n93     Extended description.\n94     <BLANKLINE>\n95     :param arg1: Description of `arg1`\n96     :type arg1: int\n97     :param arg2: Description of `arg2`\n98     :type arg2: str\n99     <BLANKLINE>\n100     :returns: Description of return value.\n101     :rtype: str\n102     <BLANKLINE>\n103 \n104     \"\"\"\n105 \n106     _name_rgx = re.compile(r\"^\\s*((?::(?P<role>\\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|\"\n107                            r\" (?P<name2>~?[a-zA-Z0-9_.-]+))\\s*\", re.X)\n108 \n109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n110                  app: Sphinx = None, what: str = '', name: str = '',\n111                  obj: Any = None, options: Any = None) -> None:\n112         self._config = config\n113         self._app = app\n114 \n115         if not self._config:\n116             from sphinx.ext.napoleon import Config\n117             self._config = self._app.config if self._app else Config()  # type: ignore\n118 \n119         if not what:\n120             if inspect.isclass(obj):\n121                 what = 'class'\n122             elif inspect.ismodule(obj):\n123                 what = 'module'\n124             elif callable(obj):\n125                 what = 'function'\n126             else:\n127                 what = 'object'\n128 \n129         self._what = what\n130         self._name = name\n131         self._obj = obj\n132         self._opt = options\n133         if isinstance(docstring, str):\n134             lines = docstring.splitlines()\n135         else:\n136             lines = docstring\n137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())\n138         self._parsed_lines = []  # type: List[str]\n139         self._is_in_section = False\n140         self._section_indent = 0\n141         if not hasattr(self, '_directive_sections'):\n142             self._directive_sections = []  # type: List[str]\n143         if not hasattr(self, '_sections'):\n144             self._sections = {\n145                 'args': self._parse_parameters_section,\n146                 'arguments': self._parse_parameters_section,\n147                 'attention': partial(self._parse_admonition, 'attention'),\n148                 'attributes': self._parse_attributes_section,\n149                 'caution': partial(self._parse_admonition, 'caution'),\n150                 'danger': partial(self._parse_admonition, 'danger'),\n151                 'error': partial(self._parse_admonition, 'error'),\n152                 'example': self._parse_examples_section,\n153                 'examples': self._parse_examples_section,\n154                 'hint': partial(self._parse_admonition, 'hint'),\n155                 'important': partial(self._parse_admonition, 'important'),\n156                 'keyword args': self._parse_keyword_arguments_section,\n157                 'keyword arguments': self._parse_keyword_arguments_section,\n158                 'methods': self._parse_methods_section,\n159                 'note': partial(self._parse_admonition, 'note'),\n160                 'notes': self._parse_notes_section,\n161                 'other parameters': self._parse_other_parameters_section,\n162                 'parameters': self._parse_parameters_section,\n163                 'return': self._parse_returns_section,\n164                 'returns': self._parse_returns_section,\n165                 'raises': self._parse_raises_section,\n166                 'references': self._parse_references_section,\n167                 'see also': self._parse_see_also_section,\n168                 'tip': partial(self._parse_admonition, 'tip'),\n169                 'todo': partial(self._parse_admonition, 'todo'),\n170                 'warning': partial(self._parse_admonition, 'warning'),\n171                 'warnings': partial(self._parse_admonition, 'warning'),\n172                 'warns': self._parse_warns_section,\n173                 'yield': self._parse_yields_section,\n174                 'yields': self._parse_yields_section,\n175             }  # type: Dict[str, Callable]\n176 \n177         self._load_custom_sections()\n178 \n179         self._parse()\n180 \n181     def __str__(self) -> str:\n182         \"\"\"Return the parsed docstring in reStructuredText format.\n183 \n184         Returns\n185         -------\n186         unicode\n187             Unicode version of the docstring.\n188 \n189         \"\"\"\n190         return '\\n'.join(self.lines())\n191 \n192     def lines(self) -> List[str]:\n193         \"\"\"Return the parsed lines of the docstring in reStructuredText format.\n194 \n195         Returns\n196         -------\n197         list(str)\n198             The lines of the docstring in a list.\n199 \n200         \"\"\"\n201         return self._parsed_lines\n202 \n203     def _consume_indented_block(self, indent: int = 1) -> List[str]:\n204         lines = []\n205         line = self._line_iter.peek()\n206         while(not self._is_section_break() and\n207               (not line or self._is_indented(line, indent))):\n208             lines.append(next(self._line_iter))\n209             line = self._line_iter.peek()\n210         return lines\n211 \n212     def _consume_contiguous(self) -> List[str]:\n213         lines = []\n214         while (self._line_iter.has_next() and\n215                self._line_iter.peek() and\n216                not self._is_section_header()):\n217             lines.append(next(self._line_iter))\n218         return lines\n219 \n220     def _consume_empty(self) -> List[str]:\n221         lines = []\n222         line = self._line_iter.peek()\n223         while self._line_iter.has_next() and not line:\n224             lines.append(next(self._line_iter))\n225             line = self._line_iter.peek()\n226         return lines\n227 \n228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n229                        ) -> Tuple[str, str, List[str]]:\n230         line = next(self._line_iter)\n231 \n232         before, colon, after = self._partition_field_on_colon(line)\n233         _name, _type, _desc = before, '', after\n234 \n235         if parse_type:\n236             match = _google_typed_arg_regex.match(before)\n237             if match:\n238                 _name = match.group(1)\n239                 _type = match.group(2)\n240 \n241         _name = self._escape_args_and_kwargs(_name)\n242 \n243         if prefer_type and not _type:\n244             _type, _name = _name, _type\n245         indent = self._get_indent(line) + 1\n246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))\n247         _descs = self.__class__(_descs, self._config).lines()\n248         return _name, _type, _descs\n249 \n250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False\n251                         ) -> List[Tuple[str, str, List[str]]]:\n252         self._consume_empty()\n253         fields = []\n254         while not self._is_section_break():\n255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n256             if _name or _type or _desc:\n257                 fields.append((_name, _type, _desc,))\n258         return fields\n259 \n260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:\n261         line = next(self._line_iter)\n262         _type, colon, _desc = self._partition_field_on_colon(line)\n263         if not colon or not _desc:\n264             _type, _desc = _desc, _type\n265             _desc += colon\n266         _descs = [_desc] + self._dedent(self._consume_to_end())\n267         _descs = self.__class__(_descs, self._config).lines()\n268         return _type, _descs\n269 \n270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n271         lines = self._dedent(self._consume_to_next_section())\n272         if lines:\n273             before, colon, after = self._partition_field_on_colon(lines[0])\n274             _name, _type, _desc = '', '', lines\n275 \n276             if colon:\n277                 if after:\n278                     _desc = [after] + lines[1:]\n279                 else:\n280                     _desc = lines[1:]\n281 \n282                 _type = before\n283 \n284             _desc = self.__class__(_desc, self._config).lines()\n285             return [(_name, _type, _desc,)]\n286         else:\n287             return []\n288 \n289     def _consume_usage_section(self) -> List[str]:\n290         lines = self._dedent(self._consume_to_next_section())\n291         return lines\n292 \n293     def _consume_section_header(self) -> str:\n294         section = next(self._line_iter)\n295         stripped_section = section.strip(':')\n296         if stripped_section.lower() in self._sections:\n297             section = stripped_section\n298         return section\n299 \n300     def _consume_to_end(self) -> List[str]:\n301         lines = []\n302         while self._line_iter.has_next():\n303             lines.append(next(self._line_iter))\n304         return lines\n305 \n306     def _consume_to_next_section(self) -> List[str]:\n307         self._consume_empty()\n308         lines = []\n309         while not self._is_section_break():\n310             lines.append(next(self._line_iter))\n311         return lines + self._consume_empty()\n312 \n313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:\n314         if full:\n315             return [line.lstrip() for line in lines]\n316         else:\n317             min_indent = self._get_min_indent(lines)\n318             return [line[min_indent:] for line in lines]\n319 \n320     def _escape_args_and_kwargs(self, name: str) -> str:\n321         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):\n322             name = name[:-1] + r'\\_'\n323 \n324         if name[:2] == '**':\n325             return r'\\*\\*' + name[2:]\n326         elif name[:1] == '*':\n327             return r'\\*' + name[1:]\n328         else:\n329             return name\n330 \n331     def _fix_field_desc(self, desc: List[str]) -> List[str]:\n332         if self._is_list(desc):\n333             desc = [''] + desc\n334         elif desc[0].endswith('::'):\n335             desc_block = desc[1:]\n336             indent = self._get_indent(desc[0])\n337             block_indent = self._get_initial_indent(desc_block)\n338             if block_indent > indent:\n339                 desc = [''] + desc\n340             else:\n341                 desc = ['', desc[0]] + self._indent(desc_block, 4)\n342         return desc\n343 \n344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:\n345         lines = self._strip_empty(lines)\n346         if len(lines) == 1:\n347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']\n348         elif lines:\n349             lines = self._indent(self._dedent(lines), 3)\n350             return ['.. %s::' % admonition, ''] + lines + ['']\n351         else:\n352             return ['.. %s::' % admonition, '']\n353 \n354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:\n355         if lines:\n356             if padding is None:\n357                 padding = ' ' * len(prefix)\n358             result_lines = []\n359             for i, line in enumerate(lines):\n360                 if i == 0:\n361                     result_lines.append((prefix + line).rstrip())\n362                 elif line:\n363                     result_lines.append(padding + line)\n364                 else:\n365                     result_lines.append('')\n366             return result_lines\n367         else:\n368             return [prefix]\n369 \n370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],\n371                                 field_role: str = 'param', type_role: str = 'type'\n372                                 ) -> List[str]:\n373         lines = []\n374         for _name, _type, _desc in fields:\n375             _desc = self._strip_empty(_desc)\n376             if any(_desc):\n377                 _desc = self._fix_field_desc(_desc)\n378                 field = ':%s %s: ' % (field_role, _name)\n379                 lines.extend(self._format_block(field, _desc))\n380             else:\n381                 lines.append(':%s %s:' % (field_role, _name))\n382 \n383             if _type:\n384                 lines.append(':%s %s: %s' % (type_role, _name, _type))\n385         return lines + ['']\n386 \n387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n388         _desc = self._strip_empty(_desc)\n389         has_desc = any(_desc)\n390         separator = ' -- ' if has_desc else ''\n391         if _name:\n392             if _type:\n393                 if '`' in _type:\n394                     field = '**%s** (%s)%s' % (_name, _type, separator)\n395                 else:\n396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)\n397             else:\n398                 field = '**%s**%s' % (_name, separator)\n399         elif _type:\n400             if '`' in _type:\n401                 field = '%s%s' % (_type, separator)\n402             else:\n403                 field = '*%s*%s' % (_type, separator)\n404         else:\n405             field = ''\n406 \n407         if has_desc:\n408             _desc = self._fix_field_desc(_desc)\n409             if _desc[0]:\n410                 return [field + _desc[0]] + _desc[1:]\n411             else:\n412                 return [field] + _desc\n413         else:\n414             return [field]\n415 \n416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n417                        ) -> List[str]:\n418         field_type = ':%s:' % field_type.strip()\n419         padding = ' ' * len(field_type)\n420         multi = len(fields) > 1\n421         lines = []  # type: List[str]\n422         for _name, _type, _desc in fields:\n423             field = self._format_field(_name, _type, _desc)\n424             if multi:\n425                 if lines:\n426                     lines.extend(self._format_block(padding + ' * ', field))\n427                 else:\n428                     lines.extend(self._format_block(field_type + ' * ', field))\n429             else:\n430                 lines.extend(self._format_block(field_type + ' ', field))\n431         if lines and lines[-1]:\n432             lines.append('')\n433         return lines\n434 \n435     def _get_current_indent(self, peek_ahead: int = 0) -> int:\n436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n437         while line != self._line_iter.sentinel:\n438             if line:\n439                 return self._get_indent(line)\n440             peek_ahead += 1\n441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n442         return 0\n443 \n444     def _get_indent(self, line: str) -> int:\n445         for i, s in enumerate(line):\n446             if not s.isspace():\n447                 return i\n448         return len(line)\n449 \n450     def _get_initial_indent(self, lines: List[str]) -> int:\n451         for line in lines:\n452             if line:\n453                 return self._get_indent(line)\n454         return 0\n455 \n456     def _get_min_indent(self, lines: List[str]) -> int:\n457         min_indent = None\n458         for line in lines:\n459             if line:\n460                 indent = self._get_indent(line)\n461                 if min_indent is None:\n462                     min_indent = indent\n463                 elif indent < min_indent:\n464                     min_indent = indent\n465         return min_indent or 0\n466 \n467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:\n468         return [(' ' * n) + line for line in lines]\n469 \n470     def _is_indented(self, line: str, indent: int = 1) -> bool:\n471         for i, s in enumerate(line):\n472             if i >= indent:\n473                 return True\n474             elif not s.isspace():\n475                 return False\n476         return False\n477 \n478     def _is_list(self, lines: List[str]) -> bool:\n479         if not lines:\n480             return False\n481         if _bullet_list_regex.match(lines[0]):\n482             return True\n483         if _enumerated_list_regex.match(lines[0]):\n484             return True\n485         if len(lines) < 2 or lines[0].endswith('::'):\n486             return False\n487         indent = self._get_indent(lines[0])\n488         next_indent = indent\n489         for line in lines[1:]:\n490             if line:\n491                 next_indent = self._get_indent(line)\n492                 break\n493         return next_indent > indent\n494 \n495     def _is_section_header(self) -> bool:\n496         section = self._line_iter.peek().lower()\n497         match = _google_section_regex.match(section)\n498         if match and section.strip(':') in self._sections:\n499             header_indent = self._get_indent(section)\n500             section_indent = self._get_current_indent(peek_ahead=1)\n501             return section_indent > header_indent\n502         elif self._directive_sections:\n503             if _directive_regex.match(section):\n504                 for directive_section in self._directive_sections:\n505                     if section.startswith(directive_section):\n506                         return True\n507         return False\n508 \n509     def _is_section_break(self) -> bool:\n510         line = self._line_iter.peek()\n511         return (not self._line_iter.has_next() or\n512                 self._is_section_header() or\n513                 (self._is_in_section and\n514                     line and\n515                     not self._is_indented(line, self._section_indent)))\n516 \n517     def _load_custom_sections(self) -> None:\n518         if self._config.napoleon_custom_sections is not None:\n519             for entry in self._config.napoleon_custom_sections:\n520                 if isinstance(entry, str):\n521                     # if entry is just a label, add to sections list,\n522                     # using generic section logic.\n523                     self._sections[entry.lower()] = self._parse_custom_generic_section\n524                 else:\n525                     # otherwise, assume entry is container;\n526                     # [0] is new section, [1] is the section to alias.\n527                     # in the case of key mismatch, just handle as generic section.\n528                     self._sections[entry[0].lower()] = \\\n529                         self._sections.get(entry[1].lower(),\n530                                            self._parse_custom_generic_section)\n531 \n532     def _parse(self) -> None:\n533         self._parsed_lines = self._consume_empty()\n534 \n535         if self._name and self._what in ('attribute', 'data', 'property'):\n536             # Implicit stop using StopIteration no longer allowed in\n537             # Python 3.7; see PEP 479\n538             res = []  # type: List[str]\n539             try:\n540                 res = self._parse_attribute_docstring()\n541             except StopIteration:\n542                 pass\n543             self._parsed_lines.extend(res)\n544             return\n545 \n546         while self._line_iter.has_next():\n547             if self._is_section_header():\n548                 try:\n549                     section = self._consume_section_header()\n550                     self._is_in_section = True\n551                     self._section_indent = self._get_current_indent()\n552                     if _directive_regex.match(section):\n553                         lines = [section] + self._consume_to_next_section()\n554                     else:\n555                         lines = self._sections[section.lower()](section)\n556                 finally:\n557                     self._is_in_section = False\n558                     self._section_indent = 0\n559             else:\n560                 if not self._parsed_lines:\n561                     lines = self._consume_contiguous() + self._consume_empty()\n562                 else:\n563                     lines = self._consume_to_next_section()\n564             self._parsed_lines.extend(lines)\n565 \n566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:\n567         # type (str, str) -> List[str]\n568         lines = self._consume_to_next_section()\n569         return self._format_admonition(admonition, lines)\n570 \n571     def _parse_attribute_docstring(self) -> List[str]:\n572         _type, _desc = self._consume_inline_attribute()\n573         lines = self._format_field('', '', _desc)\n574         if _type:\n575             lines.extend(['', ':type: %s' % _type])\n576         return lines\n577 \n578     def _parse_attributes_section(self, section: str) -> List[str]:\n579         lines = []\n580         for _name, _type, _desc in self._consume_fields():\n581             if self._config.napoleon_use_ivar:\n582                 _name = self._qualify_name(_name, self._obj)\n583                 field = ':ivar %s: ' % _name\n584                 lines.extend(self._format_block(field, _desc))\n585                 if _type:\n586                     lines.append(':vartype %s: %s' % (_name, _type))\n587             else:\n588                 lines.append('.. attribute:: ' + _name)\n589                 if self._opt and 'noindex' in self._opt:\n590                     lines.append('   :noindex:')\n591                 if _type:\n592                     lines.extend(self._indent([':type: %s' % _type], 3))\n593                 lines.append('')\n594 \n595                 fields = self._format_field('', '', _desc)\n596                 lines.extend(self._indent(fields, 3))\n597                 lines.append('')\n598         if self._config.napoleon_use_ivar:\n599             lines.append('')\n600         return lines\n601 \n602     def _parse_examples_section(self, section: str) -> List[str]:\n603         labels = {\n604             'example': _('Example'),\n605             'examples': _('Examples'),\n606         }\n607         use_admonition = self._config.napoleon_use_admonition_for_examples\n608         label = labels.get(section.lower(), section)\n609         return self._parse_generic_section(label, use_admonition)\n610 \n611     def _parse_custom_generic_section(self, section: str) -> List[str]:\n612         # for now, no admonition for simple custom sections\n613         return self._parse_generic_section(section, False)\n614 \n615     def _parse_usage_section(self, section: str) -> List[str]:\n616         header = ['.. rubric:: Usage:', '']\n617         block = ['.. code-block:: python', '']\n618         lines = self._consume_usage_section()\n619         lines = self._indent(lines, 3)\n620         return header + block + lines + ['']\n621 \n622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:\n623         lines = self._strip_empty(self._consume_to_next_section())\n624         lines = self._dedent(lines)\n625         if use_admonition:\n626             header = '.. admonition:: %s' % section\n627             lines = self._indent(lines, 3)\n628         else:\n629             header = '.. rubric:: %s' % section\n630         if lines:\n631             return [header, ''] + lines + ['']\n632         else:\n633             return [header, '']\n634 \n635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:\n636         fields = self._consume_fields()\n637         if self._config.napoleon_use_keyword:\n638             return self._format_docutils_params(\n639                 fields,\n640                 field_role=\"keyword\",\n641                 type_role=\"kwtype\")\n642         else:\n643             return self._format_fields(_('Keyword Arguments'), fields)\n644 \n645     def _parse_methods_section(self, section: str) -> List[str]:\n646         lines = []  # type: List[str]\n647         for _name, _type, _desc in self._consume_fields(parse_type=False):\n648             lines.append('.. method:: %s' % _name)\n649             if self._opt and 'noindex' in self._opt:\n650                 lines.append('   :noindex:')\n651             if _desc:\n652                 lines.extend([''] + self._indent(_desc, 3))\n653             lines.append('')\n654         return lines\n655 \n656     def _parse_notes_section(self, section: str) -> List[str]:\n657         use_admonition = self._config.napoleon_use_admonition_for_notes\n658         return self._parse_generic_section(_('Notes'), use_admonition)\n659 \n660     def _parse_other_parameters_section(self, section: str) -> List[str]:\n661         return self._format_fields(_('Other Parameters'), self._consume_fields())\n662 \n663     def _parse_parameters_section(self, section: str) -> List[str]:\n664         fields = self._consume_fields()\n665         if self._config.napoleon_use_param:\n666             return self._format_docutils_params(fields)\n667         else:\n668             return self._format_fields(_('Parameters'), fields)\n669 \n670     def _parse_raises_section(self, section: str) -> List[str]:\n671         fields = self._consume_fields(parse_type=False, prefer_type=True)\n672         lines = []  # type: List[str]\n673         for _name, _type, _desc in fields:\n674             m = self._name_rgx.match(_type)\n675             if m and m.group('name'):\n676                 _type = m.group('name')\n677             _type = ' ' + _type if _type else ''\n678             _desc = self._strip_empty(_desc)\n679             _descs = ' ' + '\\n    '.join(_desc) if any(_desc) else ''\n680             lines.append(':raises%s:%s' % (_type, _descs))\n681         if lines:\n682             lines.append('')\n683         return lines\n684 \n685     def _parse_references_section(self, section: str) -> List[str]:\n686         use_admonition = self._config.napoleon_use_admonition_for_references\n687         return self._parse_generic_section(_('References'), use_admonition)\n688 \n689     def _parse_returns_section(self, section: str) -> List[str]:\n690         fields = self._consume_returns_section()\n691         multi = len(fields) > 1\n692         if multi:\n693             use_rtype = False\n694         else:\n695             use_rtype = self._config.napoleon_use_rtype\n696 \n697         lines = []  # type: List[str]\n698         for _name, _type, _desc in fields:\n699             if use_rtype:\n700                 field = self._format_field(_name, '', _desc)\n701             else:\n702                 field = self._format_field(_name, _type, _desc)\n703 \n704             if multi:\n705                 if lines:\n706                     lines.extend(self._format_block('          * ', field))\n707                 else:\n708                     lines.extend(self._format_block(':returns: * ', field))\n709             else:\n710                 lines.extend(self._format_block(':returns: ', field))\n711                 if _type and use_rtype:\n712                     lines.extend([':rtype: %s' % _type, ''])\n713         if lines and lines[-1]:\n714             lines.append('')\n715         return lines\n716 \n717     def _parse_see_also_section(self, section: str) -> List[str]:\n718         return self._parse_admonition('seealso', section)\n719 \n720     def _parse_warns_section(self, section: str) -> List[str]:\n721         return self._format_fields(_('Warns'), self._consume_fields())\n722 \n723     def _parse_yields_section(self, section: str) -> List[str]:\n724         fields = self._consume_returns_section()\n725         return self._format_fields(_('Yields'), fields)\n726 \n727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:\n728         before_colon = []\n729         after_colon = []\n730         colon = ''\n731         found_colon = False\n732         for i, source in enumerate(_xref_or_code_regex.split(line)):\n733             if found_colon:\n734                 after_colon.append(source)\n735             else:\n736                 m = _single_colon_regex.search(source)\n737                 if (i % 2) == 0 and m:\n738                     found_colon = True\n739                     colon = source[m.start(): m.end()]\n740                     before_colon.append(source[:m.start()])\n741                     after_colon.append(source[m.end():])\n742                 else:\n743                     before_colon.append(source)\n744 \n745         return (\"\".join(before_colon).strip(),\n746                 colon,\n747                 \"\".join(after_colon).strip())\n748 \n749     def _qualify_name(self, attr_name: str, klass: \"Type\") -> str:\n750         if klass and '.' not in attr_name:\n751             if attr_name.startswith('~'):\n752                 attr_name = attr_name[1:]\n753             try:\n754                 q = klass.__qualname__\n755             except AttributeError:\n756                 q = klass.__name__\n757             return '~%s.%s' % (q, attr_name)\n758         return attr_name\n759 \n760     def _strip_empty(self, lines: List[str]) -> List[str]:\n761         if lines:\n762             start = -1\n763             for i, line in enumerate(lines):\n764                 if line:\n765                     start = i\n766                     break\n767             if start == -1:\n768                 lines = []\n769             end = -1\n770             for i in reversed(range(len(lines))):\n771                 line = lines[i]\n772                 if line:\n773                     end = i\n774                     break\n775             if start > 0 or end + 1 < len(lines):\n776                 lines = lines[start:end + 1]\n777         return lines\n778 \n779 \n780 class NumpyDocstring(GoogleDocstring):\n781     \"\"\"Convert NumPy style docstrings to reStructuredText.\n782 \n783     Parameters\n784     ----------\n785     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n786         The docstring to parse, given either as a string or split into\n787         individual lines.\n788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n789         The configuration settings to use. If not given, defaults to the\n790         config object on `app`; or if `app` is not given defaults to the\n791         a new :class:`sphinx.ext.napoleon.Config` object.\n792 \n793 \n794     Other Parameters\n795     ----------------\n796     app : :class:`sphinx.application.Sphinx`, optional\n797         Application object representing the Sphinx process.\n798     what : :obj:`str`, optional\n799         A string specifying the type of the object to which the docstring\n800         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n801         \"method\", \"attribute\".\n802     name : :obj:`str`, optional\n803         The fully qualified name of the object.\n804     obj : module, class, exception, function, method, or attribute\n805         The object to which the docstring belongs.\n806     options : :class:`sphinx.ext.autodoc.Options`, optional\n807         The options given to the directive: an object with attributes\n808         inherited_members, undoc_members, show_inheritance and noindex that\n809         are True if the flag option of same name was given to the auto\n810         directive.\n811 \n812 \n813     Example\n814     -------\n815     >>> from sphinx.ext.napoleon import Config\n816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n817     >>> docstring = '''One line summary.\n818     ...\n819     ... Extended description.\n820     ...\n821     ... Parameters\n822     ... ----------\n823     ... arg1 : int\n824     ...     Description of `arg1`\n825     ... arg2 : str\n826     ...     Description of `arg2`\n827     ... Returns\n828     ... -------\n829     ... str\n830     ...     Description of return value.\n831     ... '''\n832     >>> print(NumpyDocstring(docstring, config))\n833     One line summary.\n834     <BLANKLINE>\n835     Extended description.\n836     <BLANKLINE>\n837     :param arg1: Description of `arg1`\n838     :type arg1: int\n839     :param arg2: Description of `arg2`\n840     :type arg2: str\n841     <BLANKLINE>\n842     :returns: Description of return value.\n843     :rtype: str\n844     <BLANKLINE>\n845 \n846     Methods\n847     -------\n848     __str__()\n849         Return the parsed docstring in reStructuredText format.\n850 \n851         Returns\n852         -------\n853         str\n854             UTF-8 encoded version of the docstring.\n855 \n856     __unicode__()\n857         Return the parsed docstring in reStructuredText format.\n858 \n859         Returns\n860         -------\n861         unicode\n862             Unicode version of the docstring.\n863 \n864     lines()\n865         Return the parsed lines of the docstring in reStructuredText format.\n866 \n867         Returns\n868         -------\n869         list(str)\n870             The lines of the docstring in a list.\n871 \n872     \"\"\"\n873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n874                  app: Sphinx = None, what: str = '', name: str = '',\n875                  obj: Any = None, options: Any = None) -> None:\n876         self._directive_sections = ['.. index::']\n877         super().__init__(docstring, config, app, what, name, obj, options)\n878 \n879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n880                        ) -> Tuple[str, str, List[str]]:\n881         line = next(self._line_iter)\n882         if parse_type:\n883             _name, _, _type = self._partition_field_on_colon(line)\n884         else:\n885             _name, _type = line, ''\n886         _name, _type = _name.strip(), _type.strip()\n887         _name = self._escape_args_and_kwargs(_name)\n888 \n889         if prefer_type and not _type:\n890             _type, _name = _name, _type\n891         indent = self._get_indent(line) + 1\n892         _desc = self._dedent(self._consume_indented_block(indent))\n893         _desc = self.__class__(_desc, self._config).lines()\n894         return _name, _type, _desc\n895 \n896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n897         return self._consume_fields(prefer_type=True)\n898 \n899     def _consume_section_header(self) -> str:\n900         section = next(self._line_iter)\n901         if not _directive_regex.match(section):\n902             # Consume the header underline\n903             next(self._line_iter)\n904         return section\n905 \n906     def _is_section_break(self) -> bool:\n907         line1, line2 = self._line_iter.peek(2)\n908         return (not self._line_iter.has_next() or\n909                 self._is_section_header() or\n910                 ['', ''] == [line1, line2] or\n911                 (self._is_in_section and\n912                     line1 and\n913                     not self._is_indented(line1, self._section_indent)))\n914 \n915     def _is_section_header(self) -> bool:\n916         section, underline = self._line_iter.peek(2)\n917         section = section.lower()\n918         if section in self._sections and isinstance(underline, str):\n919             return bool(_numpy_section_regex.match(underline))\n920         elif self._directive_sections:\n921             if _directive_regex.match(section):\n922                 for directive_section in self._directive_sections:\n923                     if section.startswith(directive_section):\n924                         return True\n925         return False\n926 \n927     def _parse_see_also_section(self, section: str) -> List[str]:\n928         lines = self._consume_to_next_section()\n929         try:\n930             return self._parse_numpydoc_see_also_section(lines)\n931         except ValueError:\n932             return self._format_admonition('seealso', lines)\n933 \n934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:\n935         \"\"\"\n936         Derived from the NumpyDoc implementation of _parse_see_also.\n937 \n938         See Also\n939         --------\n940         func_name : Descriptive text\n941             continued text\n942         another_func_name : Descriptive text\n943         func_name1, func_name2, :meth:`func_name`, func_name3\n944 \n945         \"\"\"\n946         items = []\n947 \n948         def parse_item_name(text: str) -> Tuple[str, str]:\n949             \"\"\"Match ':role:`name`' or 'name'\"\"\"\n950             m = self._name_rgx.match(text)\n951             if m:\n952                 g = m.groups()\n953                 if g[1] is None:\n954                     return g[3], None\n955                 else:\n956                     return g[2], g[1]\n957             raise ValueError(\"%s is not a item name\" % text)\n958 \n959         def push_item(name: str, rest: List[str]) -> None:\n960             if not name:\n961                 return\n962             name, role = parse_item_name(name)\n963             items.append((name, list(rest), role))\n964             del rest[:]\n965 \n966         current_func = None\n967         rest = []  # type: List[str]\n968 \n969         for line in content:\n970             if not line.strip():\n971                 continue\n972 \n973             m = self._name_rgx.match(line)\n974             if m and line[m.end():].strip().startswith(':'):\n975                 push_item(current_func, rest)\n976                 current_func, line = line[:m.end()], line[m.end():]\n977                 rest = [line.split(':', 1)[1].strip()]\n978                 if not rest[0]:\n979                     rest = []\n980             elif not line.startswith(' '):\n981                 push_item(current_func, rest)\n982                 current_func = None\n983                 if ',' in line:\n984                     for func in line.split(','):\n985                         if func.strip():\n986                             push_item(func, [])\n987                 elif line.strip():\n988                     current_func = line\n989             elif current_func is not None:\n990                 rest.append(line.strip())\n991         push_item(current_func, rest)\n992 \n993         if not items:\n994             return []\n995 \n996         roles = {\n997             'method': 'meth',\n998             'meth': 'meth',\n999             'function': 'func',\n1000             'func': 'func',\n1001             'class': 'class',\n1002             'exception': 'exc',\n1003             'exc': 'exc',\n1004             'object': 'obj',\n1005             'obj': 'obj',\n1006             'module': 'mod',\n1007             'mod': 'mod',\n1008             'data': 'data',\n1009             'constant': 'const',\n1010             'const': 'const',\n1011             'attribute': 'attr',\n1012             'attr': 'attr'\n1013         }\n1014         if self._what is None:\n1015             func_role = 'obj'\n1016         else:\n1017             func_role = roles.get(self._what, '')\n1018         lines = []  # type: List[str]\n1019         last_had_desc = True\n1020         for func, desc, role in items:\n1021             if role:\n1022                 link = ':%s:`%s`' % (role, func)\n1023             elif func_role:\n1024                 link = ':%s:`%s`' % (func_role, func)\n1025             else:\n1026                 link = \"`%s`_\" % func\n1027             if desc or last_had_desc:\n1028                 lines += ['']\n1029                 lines += [link]\n1030             else:\n1031                 lines[-1] += \", %s\" % link\n1032             if desc:\n1033                 lines += self._indent([' '.join(desc)])\n1034                 last_had_desc = True\n1035             else:\n1036                 last_had_desc = False\n1037         lines += ['']\n1038 \n1039         return self._format_admonition('seealso', lines)\n",
        "intended_behavior": "If this file contributes to the handling of specific docstring styles (e.g., Google or NumPy), the parsing logic here may require adjustments to similarly accommodate and correctly interpret multiple overloaded method signatures within a single docstring. The adjustment would ensure that the Napoleon extension does not overlook additional signatures after the first, aligning with the enhanced behavior in `sphinx/ext/autodoc/__init__.py` to support a comprehensive documentation process for overloaded methods."
    }
]