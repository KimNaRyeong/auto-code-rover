2025-10-16 00:44:45.243 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:44:47.375 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=171, output_tokens=12, cost=0.002070
2025-10-16 00:44:47.376 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 00:44:47.380 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:44:53.362 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=480, output_tokens=205, cost=0.010950
2025-10-16 00:44:53.367 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:44:55.873 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=559, output_tokens=39, cost=0.006760
2025-10-16 00:44:55.875 | DEBUG    | Extracted a valid json.
2025-10-16 00:44:55.875 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"autodoc_docstring_signature\")",
        "search_code(\"overloaded methods\")"
    ],
    "bug_locations": []
}
2025-10-16 00:44:55.890 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:44:55.891 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:45:06.026 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=845, output_tokens=421, cost=0.021080
2025-10-16 00:45:06.036 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:45:07.555 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1482, output_tokens=31, cost=0.015750
2025-10-16 00:45:07.558 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:45:10.139 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=385, output_tokens=44, cost=0.005170
2025-10-16 00:45:10.140 | DEBUG    | Extracted a valid json.
2025-10-16 00:45:10.140 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"autodoc\")",
        "search_code(\"SWIG\")",
        "search_code(\"docstring\")"
    ],
    "bug_locations": []
}
2025-10-16 00:45:10.451 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:45:10.452 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:45:25.035 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2364, output_tokens=612, cost=0.042000
2025-10-16 00:45:25.041 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:45:31.592 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3192, output_tokens=233, cost=0.038910
2025-10-16 00:45:31.598 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:45:39.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=587, output_tokens=253, cost=0.013460
2025-10-16 00:45:39.235 | DEBUG    | Extracted a valid json.
2025-10-16 00:45:39.235 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the logic that parses method signatures from docstrings to iteratively capture all signatures present for overloaded methods. The modified code should ensure that each overloaded method signature is identified, parsed, and included in the generated documentation, rather than only recognizing the first signature. This enhancement should preserve the existing functionality of handling single-method docstrings while extending support for overloaded method signatures."
        },
        {
            "file": "sphinx/ext/napoleon/docstring.py",
            "class": "",
            "method": "",
            "intended_behavior": "If this file contributes to the handling of specific docstring styles (e.g., Google or NumPy), the parsing logic here may require adjustments to similarly accommodate and correctly interpret multiple overloaded method signatures within a single docstring. The adjustment would ensure that the Napoleon extension does not overlook additional signatures after the first, aligning with the enhanced behavior in `sphinx/ext/autodoc/__init__.py` to support a comprehensive documentation process for overloaded methods."
        }
    ]
}
2025-10-16 00:45:39.245 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def _call_format_args(self, **kwargs: Any) -> str:
396         if kwargs:
397             try:
398                 return self.format_args(**kwargs)
399             except TypeError:
400                 # avoid chaining exceptions, by putting nothing here
401                 pass
402 
403         # retry without arguments for old documenters
404         return self.format_args()
405 
406     def format_signature(self, **kwargs: Any) -> str:
407         """Format the signature (arguments and return annotation) of the object.
408 
409         Let the user process it via the ``autodoc-process-signature`` event.
410         """
411         if self.args is not None:
412             # signature given explicitly
413             args = "(%s)" % self.args
414             retann = self.retann
415         else:
416             # try to introspect the signature
417             try:
418                 retann = None
419                 args = self._call_format_args(**kwargs)
420                 if args:
421                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
422                     if matched:
423                         args = matched.group(1)
424                         retann = matched.group(2)
425             except Exception:
426                 logger.warning(__('error while formatting arguments for %s:') %
427                                self.fullname, type='autodoc', exc_info=True)
428                 args = None
429 
430         result = self.env.events.emit_firstresult('autodoc-process-signature',
431                                                   self.objtype, self.fullname,
432                                                   self.object, self.options, args, retann)
433         if result:
434             args, retann = result
435 
436         if args is not None:
437             return args + ((' -> %s' % retann) if retann else '')
438         else:
439             return ''
440 
441     def add_directive_header(self, sig: str) -> None:
442         """Add the directive header and options to the generated content."""
443         domain = getattr(self, 'domain', 'py')
444         directive = getattr(self, 'directivetype', self.objtype)
445         name = self.format_name()
446         sourcename = self.get_sourcename()
447 
448         # one signature per line, indented by column
449         prefix = '.. %s:%s:: ' % (domain, directive)
450         for i, sig_line in enumerate(sig.split("\n")):
451             self.add_line('%s%s%s' % (prefix, name, sig_line),
452                           sourcename)
453             if i == 0:
454                 prefix = " " * len(prefix)
455 
456         if self.options.noindex:
457             self.add_line('   :noindex:', sourcename)
458         if self.objpath:
459             # Be explicit about the module, this is necessary since .. class::
460             # etc. don't support a prepended module name
461             self.add_line('   :module: %s' % self.modname, sourcename)
462 
463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
464         """Decode and return lines of the docstring(s) for the object."""
465         if encoding is not None:
466             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
467                           % self.__class__.__name__,
468                           RemovedInSphinx40Warning, stacklevel=2)
469         if ignore is not None:
470             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
471                           % self.__class__.__name__,
472                           RemovedInSphinx50Warning, stacklevel=2)
473         docstring = getdoc(self.object, self.get_attr,
474                            self.env.config.autodoc_inherit_docstrings,
475                            self.parent, self.object_name)
476         if docstring:
477             tab_width = self.directive.state.document.settings.tab_width
478             return [prepare_docstring(docstring, ignore, tab_width)]
479         return []
480 
481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
482         """Let the user process the docstrings before adding them."""
483         for docstringlines in docstrings:
484             if self.env.app:
485                 # let extensions preprocess docstrings
486                 self.env.app.emit('autodoc-process-docstring',
487                                   self.objtype, self.fullname, self.object,
488                                   self.options, docstringlines)
489             yield from docstringlines
490 
491     def get_sourcename(self) -> str:
492         if self.analyzer:
493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
494         return 'docstring of %s' % self.fullname
495 
496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
497         """Add content from docstrings, attribute documentation and user."""
498         # set sourcename and add content from attribute documentation
499         sourcename = self.get_sourcename()
500         if self.analyzer:
501             attr_docs = self.analyzer.find_attr_docs()
502             if self.objpath:
503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
504                 if key in attr_docs:
505                     no_docstring = True
506                     # make a copy of docstring for attributes to avoid cache
507                     # the change of autodoc-process-docstring event.
508                     docstrings = [list(attr_docs[key])]
509 
510                     for i, line in enumerate(self.process_doc(docstrings)):
511                         self.add_line(line, sourcename, i)
512 
513         # add content from docstrings
514         if not no_docstring:
515             docstrings = self.get_doc()
516             if not docstrings:
517                 # append at least a dummy docstring, so that the event
518                 # autodoc-process-docstring is fired and can add some
519                 # content if desired
520                 docstrings.append([])
521             for i, line in enumerate(self.process_doc(docstrings)):
522                 self.add_line(line, sourcename, i)
523 
524         # add additional content (e.g. from document), if present
525         if more_content:
526             for line, src in zip(more_content.data, more_content.items):
527                 self.add_line(line, src[0], src[1])
528 
529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
530         """Return `(members_check_module, members)` where `members` is a
531         list of `(membername, member)` pairs of the members of *self.object*.
532 
533         If *want_all* is True, return all members.  Else, only return those
534         members given by *self.options.members* (which may also be none).
535         """
536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
537         if not want_all:
538             if not self.options.members:
539                 return False, []
540             # specific members given
541             selected = []
542             for name in self.options.members:
543                 if name in members:
544                     selected.append((name, members[name].value))
545                 else:
546                     logger.warning(__('missing attribute %s in object %s') %
547                                    (name, self.fullname), type='autodoc')
548             return False, selected
549         elif self.options.inherited_members:
550             return False, [(m.name, m.value) for m in members.values()]
551         else:
552             return False, [(m.name, m.value) for m in members.values()
553                            if m.directly_defined]
554 
555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
556                        ) -> List[Tuple[str, Any, bool]]:
557         """Filter the given member list.
558 
559         Members are skipped if
560 
561         - they are private (except if given explicitly or the private-members
562           option is set)
563         - they are special methods (except if given explicitly or the
564           special-members option is set)
565         - they are undocumented (except if the undoc-members option is set)
566 
567         The user can override the skipping decision by connecting to the
568         ``autodoc-skip-member`` event.
569         """
570         def is_filtered_inherited_member(name: str) -> bool:
571             if inspect.isclass(self.object):
572                 for cls in self.object.__mro__:
573                     if cls.__name__ == self.options.inherited_members and cls != self.object:
574                         # given member is a member of specified *super class*
575                         return True
576                     elif name in cls.__dict__:
577                         return False
578 
579             return False
580 
581         ret = []
582 
583         # search for members in source code too
584         namespace = '.'.join(self.objpath)  # will be empty for modules
585 
586         if self.analyzer:
587             attr_docs = self.analyzer.find_attr_docs()
588         else:
589             attr_docs = {}
590 
591         # process members and determine which to skip
592         for (membername, member) in members:
593             # if isattr is True, the member is documented as an attribute
594             if member is INSTANCEATTR:
595                 isattr = True
596             else:
597                 isattr = False
598 
599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
600                          self.parent, self.object_name)
601             if not isinstance(doc, str):
602                 # Ignore non-string __doc__
603                 doc = None
604 
605             # if the member __doc__ is the same as self's __doc__, it's just
606             # inherited and therefore not the member's doc
607             cls = self.get_attr(member, '__class__', None)
608             if cls:
609                 cls_doc = self.get_attr(cls, '__doc__', None)
610                 if cls_doc == doc:
611                     doc = None
612             has_doc = bool(doc)
613 
614             metadata = extract_metadata(doc)
615             if 'private' in metadata:
616                 # consider a member private if docstring has "private" metadata
617                 isprivate = True
618             elif 'public' in metadata:
619                 # consider a member public if docstring has "public" metadata
620                 isprivate = False
621             else:
622                 isprivate = membername.startswith('_')
623 
624             keep = False
625             if safe_getattr(member, '__sphinx_mock__', False):
626                 # mocked module or object
627                 pass
628             elif want_all and membername.startswith('__') and \
629                     membername.endswith('__') and len(membername) > 4:
630                 # special __methods__
631                 if self.options.special_members is ALL:
632                     if membername == '__doc__':
633                         keep = False
634                     elif is_filtered_inherited_member(membername):
635                         keep = False
636                     else:
637                         keep = has_doc or self.options.undoc_members
638                 elif self.options.special_members:
639                     if membername in self.options.special_members:
640                         keep = has_doc or self.options.undoc_members
641             elif (namespace, membername) in attr_docs:
642                 if want_all and isprivate:
643                     # ignore members whose name starts with _ by default
644                     keep = self.options.private_members
645                 else:
646                     # keep documented attributes
647                     keep = True
648                 isattr = True
649             elif want_all and isprivate:
650                 # ignore members whose name starts with _ by default
651                 keep = self.options.private_members and \
652                     (has_doc or self.options.undoc_members)
653             else:
654                 if self.options.members is ALL and is_filtered_inherited_member(membername):
655                     keep = False
656                 else:
657                     # ignore undocumented members if :undoc-members: is not given
658                     keep = has_doc or self.options.undoc_members
659 
660             # give the user a chance to decide whether this member
661             # should be skipped
662             if self.env.app:
663                 # let extensions preprocess docstrings
664                 try:
665                     skip_user = self.env.app.emit_firstresult(
666                         'autodoc-skip-member', self.objtype, membername, member,
667                         not keep, self.options)
668                     if skip_user is not None:
669                         keep = not skip_user
670                 except Exception as exc:
671                     logger.warning(__('autodoc: failed to determine %r to be documented, '
672                                       'the following exception was raised:\n%s'),
673                                    member, exc, type='autodoc')
674                     keep = False
675 
676             if keep:
677                 ret.append((membername, member, isattr))
678 
679         return ret
680 
681     def document_members(self, all_members: bool = False) -> None:
682         """Generate reST for member documentation.
683 
684         If *all_members* is True, do all members, else those given by
685         *self.options.members*.
686         """
687         # set current namespace for finding members
688         self.env.temp_data['autodoc:module'] = self.modname
689         if self.objpath:
690             self.env.temp_data['autodoc:class'] = self.objpath[0]
691 
692         want_all = all_members or self.options.inherited_members or \
693             self.options.members is ALL
694         # find out which members are documentable
695         members_check_module, members = self.get_object_members(want_all)
696 
697         # remove members given by exclude-members
698         if self.options.exclude_members:
699             members = [
700                 (membername, member) for (membername, member) in members
701                 if (
702                     self.options.exclude_members is ALL or
703                     membername not in self.options.exclude_members
704                 )
705             ]
706 
707         # document non-skipped members
708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
709         for (mname, member, isattr) in self.filter_members(members, want_all):
710             classes = [cls for cls in self.documenters.values()
711                        if cls.can_document_member(member, mname, isattr, self)]
712             if not classes:
713                 # don't know how to document this member
714                 continue
715             # prefer the documenter with the highest priority
716             classes.sort(key=lambda cls: cls.priority)
717             # give explicitly separated module name, so that members
718             # of inner classes can be documented
719             full_mname = self.modname + '::' + \
720                 '.'.join(self.objpath + [mname])
721             documenter = classes[-1](self.directive, full_mname, self.indent)
722             memberdocumenters.append((documenter, isattr))
723 
724         member_order = self.options.member_order or self.env.config.autodoc_member_order
725         memberdocumenters = self.sort_members(memberdocumenters, member_order)
726 
727         for documenter, isattr in memberdocumenters:
728             documenter.generate(
729                 all_members=True, real_modname=self.real_modname,
730                 check_module=members_check_module and not isattr)
731 
732         # reset current objects
733         self.env.temp_data['autodoc:module'] = None
734         self.env.temp_data['autodoc:class'] = None
735 
736     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
737                      order: str) -> List[Tuple["Documenter", bool]]:
738         """Sort the given member list."""
739         if order == 'groupwise':
740             # sort by group; alphabetically within groups
741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
742         elif order == 'bysource':
743             if self.analyzer:
744                 # sort by source order, by virtue of the module analyzer
745                 tagorder = self.analyzer.tagorder
746 
747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
748                     fullname = entry[0].name.split('::')[1]
749                     return tagorder.get(fullname, len(tagorder))
750                 documenters.sort(key=keyfunc)
751             else:
752                 # Assume that member discovery order matches source order.
753                 # This is a reasonable assumption in Python 3.6 and up, where
754                 # module.__dict__ is insertion-ordered.
755                 pass
756         else:  # alphabetical
757             documenters.sort(key=lambda e: e[0].name)
758 
759         return documenters
760 
761     def generate(self, more_content: Any = None, real_modname: str = None,
762                  check_module: bool = False, all_members: bool = False) -> None:
763         """Generate reST for the object given by *self.name*, and possibly for
764         its members.
765 
766         If *more_content* is given, include that content. If *real_modname* is
767         given, use that module name to find attribute docs. If *check_module* is
768         True, only generate if the object is defined in the module name it is
769         imported from. If *all_members* is True, document all members.
770         """
771         if not self.parse_name():
772             # need a module to import
773             logger.warning(
774                 __('don\'t know which module to import for autodocumenting '
775                    '%r (try placing a "module" or "currentmodule" directive '
776                    'in the document, or giving an explicit module name)') %
777                 self.name, type='autodoc')
778             return
779 
780         # now, import the module and get object to document
781         if not self.import_object():
782             return
783 
784         # If there is no real module defined, figure out which to use.
785         # The real module is used in the module analyzer to look up the module
786         # where the attribute documentation would actually be found in.
787         # This is used for situations where you have a module that collects the
788         # functions and classes of internal submodules.
789         guess_modname = self.get_real_modname()
790         self.real_modname = real_modname or guess_modname
791 
792         # try to also get a source code analyzer for attribute docs
793         try:
794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
795             # parse right now, to get PycodeErrors on parsing (results will
796             # be cached anyway)
797             self.analyzer.find_attr_docs()
798         except PycodeError:
799             logger.debug('[autodoc] module analyzer failed:', exc_info=True)
800             # no source file -- e.g. for builtin and C modules
801             self.analyzer = None
802             # at least add the module.__file__ as a dependency
803             if hasattr(self.module, '__file__') and self.module.__file__:
804                 self.directive.filename_set.add(self.module.__file__)
805         else:
806             self.directive.filename_set.add(self.analyzer.srcname)
807 
808         if self.real_modname != guess_modname:
809             # Add module to dependency list if target object is defined in other module.
810             try:
811                 analyzer = ModuleAnalyzer.for_module(guess_modname)
812                 self.directive.filename_set.add(analyzer.srcname)
813             except PycodeError:
814                 pass
815 
816         # check __module__ of object (for members not given explicitly)
817         if check_module:
818             if not self.check_module():
819                 return
820 
821         sourcename = self.get_sourcename()
822 
823         # make sure that the result starts with an empty line.  This is
824         # necessary for some situations where another directive preprocesses
825         # reST and no starting newline is present
826         self.add_line('', sourcename)
827 
828         # format the object's signature, if any
829         sig = self.format_signature()
830 
831         # generate the directive header and options, if applicable
832         self.add_directive_header(sig)
833         self.add_line('', sourcename)
834 
835         # e.g. the module directive doesn't have content
836         self.indent += self.content_indent
837 
838         # add all content (from docstrings, attribute docs etc.)
839         self.add_content(more_content)
840 
841         # document members, if possible
842         self.document_members(all_members)
843 
844 
845 class ModuleDocumenter(Documenter):
846     """
847     Specialized Documenter subclass for modules.
848     """
849     objtype = 'module'
850     content_indent = ''
851     titles_allowed = True
852 
853     option_spec = {
854         'members': members_option, 'undoc-members': bool_option,
855         'noindex': bool_option, 'inherited-members': inherited_members_option,
856         'show-inheritance': bool_option, 'synopsis': identity,
857         'platform': identity, 'deprecated': bool_option,
858         'member-order': member_order_option, 'exclude-members': members_set_option,
859         'private-members': bool_option, 'special-members': members_option,
860         'imported-members': bool_option, 'ignore-module-all': bool_option
861     }  # type: Dict[str, Callable]
862 
863     def __init__(self, *args: Any) -> None:
864         super().__init__(*args)
865         merge_special_members_option(self.options)
866         self.__all__ = None
867 
868     @classmethod
869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
870                             ) -> bool:
871         # don't document submodules automatically
872         return False
873 
874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
875                      ) -> Tuple[str, List[str]]:
876         if modname is not None:
877             logger.warning(__('"::" in automodule name doesn\'t make sense'),
878                            type='autodoc')
879         return (path or '') + base, []
880 
881     def parse_name(self) -> bool:
882         ret = super().parse_name()
883         if self.args or self.retann:
884             logger.warning(__('signature arguments or return annotation '
885                               'given for automodule %s') % self.fullname,
886                            type='autodoc')
887         return ret
888 
889     def import_object(self) -> Any:
890         def is_valid_module_all(__all__: Any) -> bool:
891             """Check the given *__all__* is valid for a module."""
892             if (isinstance(__all__, (list, tuple)) and
893                     all(isinstance(e, str) for e in __all__)):
894                 return True
895             else:
896                 return False
897 
898         ret = super().import_object()
899 
900         if not self.options.ignore_module_all:
901             __all__ = getattr(self.object, '__all__', None)
902             if is_valid_module_all(__all__):
903                 # valid __all__ found. copy it to self.__all__
904                 self.__all__ = __all__
905             elif __all__:
906                 # invalid __all__ found.
907                 logger.warning(__('__all__ should be a list of strings, not %r '
908                                   '(in module %s) -- ignoring __all__') %
909                                (__all__, self.fullname), type='autodoc')
910 
911         return ret
912 
913     def add_directive_header(self, sig: str) -> None:
914         Documenter.add_directive_header(self, sig)
915 
916         sourcename = self.get_sourcename()
917 
918         # add some module-specific options
919         if self.options.synopsis:
920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
921         if self.options.platform:
922             self.add_line('   :platform: ' + self.options.platform, sourcename)
923         if self.options.deprecated:
924             self.add_line('   :deprecated:', sourcename)
925 
926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
927         if want_all:
928             if self.__all__:
929                 memberlist = self.__all__
930             else:
931                 # for implicit module members, check __module__ to avoid
932                 # documenting imported objects
933                 return True, get_module_members(self.object)
934         else:
935             memberlist = self.options.members or []
936         ret = []
937         for mname in memberlist:
938             try:
939                 ret.append((mname, safe_getattr(self.object, mname)))
940             except AttributeError:
941                 logger.warning(
942                     __('missing attribute mentioned in :members: or __all__: '
943                        'module %s, attribute %s') %
944                     (safe_getattr(self.object, '__name__', '???'), mname),
945                     type='autodoc'
946                 )
947         return False, ret
948 
949     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
950                      order: str) -> List[Tuple["Documenter", bool]]:
951         if order == 'bysource' and self.__all__:
952             # Sort alphabetically first (for members not listed on the __all__)
953             documenters.sort(key=lambda e: e[0].name)
954 
955             # Sort by __all__
956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
957                 name = entry[0].name.split('::')[1]
958                 if name in self.__all__:
959                     return self.__all__.index(name)
960                 else:
961                     return len(self.__all__)
962             documenters.sort(key=keyfunc)
963 
964             return documenters
965         else:
966             return super().sort_members(documenters, order)
967 
968 
969 class ModuleLevelDocumenter(Documenter):
970     """
971     Specialized Documenter subclass for objects on module level (functions,
972     classes, data/constants).
973     """
974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
975                      ) -> Tuple[str, List[str]]:
976         if modname is None:
977             if path:
978                 stripped = path.rstrip('.')
979                 modname, qualname = split_full_qualified_name(stripped)
980                 if qualname:
981                     parents = qualname.split(".")
982                 else:
983                     parents = []
984 
985             if modname is None:
986                 # if documenting a toplevel object without explicit module,
987                 # it can be contained in another auto directive ...
988                 modname = self.env.temp_data.get('autodoc:module')
989                 # ... or in the scope of a module directive
990                 if not modname:
991                     modname = self.env.ref_context.get('py:module')
992                 # ... else, it stays None, which means invalid
993         return modname, parents + [base]
994 
995 
996 class ClassLevelDocumenter(Documenter):
997     """
998     Specialized Documenter subclass for objects on class level (methods,
999     attributes).
1000     """
1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1002                      ) -> Tuple[str, List[str]]:
1003         if modname is None:
1004             if path:
1005                 mod_cls = path.rstrip('.')
1006             else:
1007                 mod_cls = None
1008                 # if documenting a class-level object without path,
1009                 # there must be a current class, either from a parent
1010                 # auto directive ...
1011                 mod_cls = self.env.temp_data.get('autodoc:class')
1012                 # ... or from a class directive
1013                 if mod_cls is None:
1014                     mod_cls = self.env.ref_context.get('py:class')
1015                 # ... if still None, there's no way to know
1016                 if mod_cls is None:
1017                     return None, []
1018 
1019             try:
1020                 modname, qualname = split_full_qualified_name(mod_cls)
1021                 parents = qualname.split(".") if qualname else []
1022             except ImportError:
1023                 parents = mod_cls.split(".")
1024 
1025             # if the module name is still missing, get it like above
1026             if not modname:
1027                 modname = self.env.temp_data.get('autodoc:module')
1028             if not modname:
1029                 modname = self.env.ref_context.get('py:module')
1030             # ... else, it stays None, which means invalid
1031         return modname, parents + [base]
1032 
1033 
1034 class DocstringSignatureMixin:
1035     """
1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1037     feature of reading the signature from the docstring.
1038     """
1039 
1040     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1041         if encoding is not None:
1042             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1043                           "deprecated." % self.__class__.__name__,
1044                           RemovedInSphinx40Warning, stacklevel=2)
1045         docstrings = self.get_doc()
1046         self._new_docstrings = docstrings[:]
1047         result = None
1048         for i, doclines in enumerate(docstrings):
1049             # no lines in docstring, no match
1050             if not doclines:
1051                 continue
1052             # match first line of docstring against signature RE
1053             match = py_ext_sig_re.match(doclines[0])
1054             if not match:
1055                 continue
1056             exmod, path, base, args, retann = match.groups()
1057             # the base name must match ours
1058             valid_names = [self.objpath[-1]]  # type: ignore
1059             if isinstance(self, ClassDocumenter):
1060                 valid_names.append('__init__')
1061                 if hasattr(self.object, '__mro__'):
1062                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1063             if base not in valid_names:
1064                 continue
1065             # re-prepare docstring to ignore more leading indentation
1066             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1067             self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
1068                                                         tabsize=tab_width)
1069             result = args, retann
1070             # don't look any further
1071             break
1072         return result
1073 
1074     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1075         if encoding is not None:
1076             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1077                           % self.__class__.__name__,
1078                           RemovedInSphinx40Warning, stacklevel=2)
1079         lines = getattr(self, '_new_docstrings', None)
1080         if lines is not None:
1081             return lines
1082         return super().get_doc(None, ignore)  # type: ignore
1083 
1084     def format_signature(self, **kwargs: Any) -> str:
1085         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1086             # only act if a signature is not explicitly given already, and if
1087             # the feature is enabled
1088             result = self._find_signature()
1089             if result is not None:
1090                 self.args, self.retann = result
1091         return super().format_signature(**kwargs)  # type: ignore
1092 
1093 
1094 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1095     """
1096     Mixin for AttributeDocumenter to provide the
1097     feature of stripping any function signature from the docstring.
1098     """
1099     def format_signature(self, **kwargs: Any) -> str:
1100         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1101             # only act if a signature is not explicitly given already, and if
1102             # the feature is enabled
1103             result = self._find_signature()
1104             if result is not None:
1105                 # Discarding _args is a only difference with
1106                 # DocstringSignatureMixin.format_signature.
1107                 # Documenter.format_signature use self.args value to format.
1108                 _args, self.retann = result
1109         return super().format_signature(**kwargs)
1110 
1111 
1112 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1113     """
1114     Specialized Documenter subclass for functions.
1115     """
1116     objtype = 'function'
1117     member_order = 30
1118 
1119     @classmethod
1120     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1121                             ) -> bool:
1122         # supports functions, builtins and bound methods exported at the module level
1123         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1124                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1125 
1126     def format_args(self, **kwargs: Any) -> str:
1127         if self.env.config.autodoc_typehints in ('none', 'description'):
1128             kwargs.setdefault('show_annotation', False)
1129 
1130         try:
1131             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1132             if inspect.is_singledispatch_function(self.object):
1133                 sig = inspect.signature(self.object, follow_wrapped=True)
1134             else:
1135                 sig = inspect.signature(self.object)
1136             args = stringify_signature(sig, **kwargs)
1137         except TypeError as exc:
1138             logger.warning(__("Failed to get a function signature for %s: %s"),
1139                            self.fullname, exc)
1140             return None
1141         except ValueError:
1142             args = ''
1143 
1144         if self.env.config.strip_signature_backslash:
1145             # escape backslashes for reST
1146             args = args.replace('\\', '\\\\')
1147         return args
1148 
1149     def document_members(self, all_members: bool = False) -> None:
1150         pass
1151 
1152     def add_directive_header(self, sig: str) -> None:
1153         sourcename = self.get_sourcename()
1154         super().add_directive_header(sig)
1155 
1156         if inspect.iscoroutinefunction(self.object):
1157             self.add_line('   :async:', sourcename)
1158 
1159     def format_signature(self, **kwargs: Any) -> str:
1160         sig = super().format_signature(**kwargs)
1161         sigs = [sig]
1162 
1163         if inspect.is_singledispatch_function(self.object):
1164             # append signature of singledispatch'ed functions
1165             for typ, func in self.object.registry.items():
1166                 if typ is object:
1167                     pass  # default implementation. skipped.
1168                 else:
1169                     self.annotate_to_first_argument(func, typ)
1170 
1171                     documenter = FunctionDocumenter(self.directive, '')
1172                     documenter.object = func
1173                     sigs.append(documenter.format_signature())
1174 
1175         return "\n".join(sigs)
1176 
1177     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1178         """Annotate type hint to the first argument of function if needed."""
1179         sig = inspect.signature(func)
1180         if len(sig.parameters) == 0:
1181             return
1182 
1183         params = list(sig.parameters.values())
1184         if params[0].annotation is Parameter.empty:
1185             params[0] = params[0].replace(annotation=typ)
1186             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1187 
1188 
1189 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1190     """
1191     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1192 
1193     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1194     """
1195 
1196 
1197 class DecoratorDocumenter(FunctionDocumenter):
1198     """
1199     Specialized Documenter subclass for decorator functions.
1200     """
1201     objtype = 'decorator'
1202 
1203     # must be lower than FunctionDocumenter
1204     priority = -1
1205 
1206     def format_args(self, **kwargs: Any) -> Any:
1207         args = super().format_args(**kwargs)
1208         if ',' in args:
1209             return args
1210         else:
1211             return None
1212 
1213 
1214 # Types which have confusing metaclass signatures it would be best not to show.
1215 # These are listed by name, rather than storing the objects themselves, to avoid
1216 # needing to import the modules.
1217 _METACLASS_CALL_BLACKLIST = [
1218     'enum.EnumMeta.__call__',
1219 ]
1220 
1221 
1222 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1223     """
1224     Specialized Documenter subclass for classes.
1225     """
1226     objtype = 'class'
1227     member_order = 20
1228     option_spec = {
1229         'members': members_option, 'undoc-members': bool_option,
1230         'noindex': bool_option, 'inherited-members': inherited_members_option,
1231         'show-inheritance': bool_option, 'member-order': member_order_option,
1232         'exclude-members': members_set_option,
1233         'private-members': bool_option, 'special-members': members_option,
1234     }  # type: Dict[str, Callable]
1235 
1236     def __init__(self, *args: Any) -> None:
1237         super().__init__(*args)
1238         merge_special_members_option(self.options)
1239 
1240     @classmethod
1241     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1242                             ) -> bool:
1243         return isinstance(member, type)
1244 
1245     def import_object(self) -> Any:
1246         ret = super().import_object()
1247         # if the class is documented under another name, document it
1248         # as data/attribute
1249         if ret:
1250             if hasattr(self.object, '__name__'):
1251                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1252             else:
1253                 self.doc_as_attr = True
1254         return ret
1255 
1256     def _get_signature(self) -> Optional[Signature]:
1257         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1258             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1259             if inspect.is_builtin_class_method(obj, attr):
1260                 return None
1261             attr = self.get_attr(obj, attr, None)
1262             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1263                 return None
1264             return attr
1265 
1266         # This sequence is copied from inspect._signature_from_callable.
1267         # ValueError means that no signature could be found, so we keep going.
1268 
1269         # First, let's see if it has an overloaded __call__ defined
1270         # in its metaclass
1271         call = get_user_defined_function_or_method(type(self.object), '__call__')
1272 
1273         if call is not None:
1274             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1275                 call = None
1276 
1277         if call is not None:
1278             self.env.app.emit('autodoc-before-process-signature', call, True)
1279             try:
1280                 return inspect.signature(call, bound_method=True)
1281             except ValueError:
1282                 pass
1283 
1284         # Now we check if the 'obj' class has a '__new__' method
1285         new = get_user_defined_function_or_method(self.object, '__new__')
1286         if new is not None:
1287             self.env.app.emit('autodoc-before-process-signature', new, True)
1288             try:
1289                 return inspect.signature(new, bound_method=True)
1290             except ValueError:
1291                 pass
1292 
1293         # Finally, we should have at least __init__ implemented
1294         init = get_user_defined_function_or_method(self.object, '__init__')
1295         if init is not None:
1296             self.env.app.emit('autodoc-before-process-signature', init, True)
1297             try:
1298                 return inspect.signature(init, bound_method=True)
1299             except ValueError:
1300                 pass
1301 
1302         # None of the attributes are user-defined, so fall back to let inspect
1303         # handle it.
1304         # We don't know the exact method that inspect.signature will read
1305         # the signature from, so just pass the object itself to our hook.
1306         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1307         try:
1308             return inspect.signature(self.object, bound_method=False)
1309         except ValueError:
1310             pass
1311 
1312         # Still no signature: happens e.g. for old-style classes
1313         # with __init__ in C and no `__text_signature__`.
1314         return None
1315 
1316     def format_args(self, **kwargs: Any) -> str:
1317         if self.env.config.autodoc_typehints in ('none', 'description'):
1318             kwargs.setdefault('show_annotation', False)
1319 
1320         try:
1321             sig = self._get_signature()
1322         except TypeError as exc:
1323             # __signature__ attribute contained junk
1324             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1325                            self.fullname, exc)
1326             return None
1327 
1328         if sig is None:
1329             return None
1330 
1331         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1332 
1333     def format_signature(self, **kwargs: Any) -> str:
1334         if self.doc_as_attr:
1335             return ''
1336 
1337         return super().format_signature(**kwargs)
1338 
1339     def add_directive_header(self, sig: str) -> None:
1340         sourcename = self.get_sourcename()
1341 
1342         if self.doc_as_attr:
1343             self.directivetype = 'attribute'
1344         super().add_directive_header(sig)
1345 
1346         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1347             self.add_line('   :final:', sourcename)
1348 
1349         # add inheritance info, if wanted
1350         if not self.doc_as_attr and self.options.show_inheritance:
1351             sourcename = self.get_sourcename()
1352             self.add_line('', sourcename)
1353             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1354                 bases = [':class:`%s`' % b.__name__
1355                          if b.__module__ in ('__builtin__', 'builtins')
1356                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1357                          for b in self.object.__bases__]
1358                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1359                               sourcename)
1360 
1361     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1362         if encoding is not None:
1363             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1364                           % self.__class__.__name__,
1365                           RemovedInSphinx40Warning, stacklevel=2)
1366         lines = getattr(self, '_new_docstrings', None)
1367         if lines is not None:
1368             return lines
1369 
1370         content = self.env.config.autoclass_content
1371 
1372         docstrings = []
1373         attrdocstring = self.get_attr(self.object, '__doc__', None)
1374         if attrdocstring:
1375             docstrings.append(attrdocstring)
1376 
1377         # for classes, what the "docstring" is can be controlled via a
1378         # config value; the default is only the class docstring
1379         if content in ('both', 'init'):
1380             __init__ = self.get_attr(self.object, '__init__', None)
1381             initdocstring = getdoc(__init__, self.get_attr,
1382                                    self.env.config.autodoc_inherit_docstrings,
1383                                    self.parent, self.object_name)
1384             # for new-style classes, no __init__ means default __init__
1385             if (initdocstring is not None and
1386                 (initdocstring == object.__init__.__doc__ or  # for pypy
1387                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1388                 initdocstring = None
1389             if not initdocstring:
1390                 # try __new__
1391                 __new__ = self.get_attr(self.object, '__new__', None)
1392                 initdocstring = getdoc(__new__, self.get_attr,
1393                                        self.env.config.autodoc_inherit_docstrings,
1394                                        self.parent, self.object_name)
1395                 # for new-style classes, no __new__ means default __new__
1396                 if (initdocstring is not None and
1397                     (initdocstring == object.__new__.__doc__ or  # for pypy
1398                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1399                     initdocstring = None
1400             if initdocstring:
1401                 if content == 'init':
1402                     docstrings = [initdocstring]
1403                 else:
1404                     docstrings.append(initdocstring)
1405 
1406         tab_width = self.directive.state.document.settings.tab_width
1407         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1408 
1409     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1410         if self.doc_as_attr:
1411             classname = safe_getattr(self.object, '__qualname__', None)
1412             if not classname:
1413                 classname = safe_getattr(self.object, '__name__', None)
1414             if classname:
1415                 module = safe_getattr(self.object, '__module__', None)
1416                 parentmodule = safe_getattr(self.parent, '__module__', None)
1417                 if module and module != parentmodule:
1418                     classname = str(module) + '.' + str(classname)
1419                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1420                 super().add_content(content, no_docstring=True)
1421         else:
1422             super().add_content(more_content)
1423 
1424     def document_members(self, all_members: bool = False) -> None:
1425         if self.doc_as_attr:
1426             return
1427         super().document_members(all_members)
1428 
1429     def generate(self, more_content: Any = None, real_modname: str = None,
1430                  check_module: bool = False, all_members: bool = False) -> None:
1431         # Do not pass real_modname and use the name from the __module__
1432         # attribute of the class.
1433         # If a class gets imported into the module real_modname
1434         # the analyzer won't find the source of the class, if
1435         # it looks in real_modname.
1436         return super().generate(more_content=more_content,
1437                                 check_module=check_module,
1438                                 all_members=all_members)
1439 
1440 
1441 class ExceptionDocumenter(ClassDocumenter):
1442     """
1443     Specialized ClassDocumenter subclass for exceptions.
1444     """
1445     objtype = 'exception'
1446     member_order = 10
1447 
1448     # needs a higher priority than ClassDocumenter
1449     priority = 10
1450 
1451     @classmethod
1452     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1453                             ) -> bool:
1454         return isinstance(member, type) and issubclass(member, BaseException)
1455 
1456 
1457 class DataDocumenter(ModuleLevelDocumenter):
1458     """
1459     Specialized Documenter subclass for data items.
1460     """
1461     objtype = 'data'
1462     member_order = 40
1463     priority = -10
1464     option_spec = dict(ModuleLevelDocumenter.option_spec)
1465     option_spec["annotation"] = annotation_option
1466 
1467     @classmethod
1468     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1469                             ) -> bool:
1470         return isinstance(parent, ModuleDocumenter) and isattr
1471 
1472     def add_directive_header(self, sig: str) -> None:
1473         super().add_directive_header(sig)
1474         sourcename = self.get_sourcename()
1475         if not self.options.annotation:
1476             # obtain annotation for this data
1477             annotations = getattr(self.parent, '__annotations__', {})
1478             if annotations and self.objpath[-1] in annotations:
1479                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1480                 self.add_line('   :type: ' + objrepr, sourcename)
1481             else:
1482                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1483                 if self.analyzer and key in self.analyzer.annotations:
1484                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1485                                   sourcename)
1486 
1487             try:
1488                 if self.object is UNINITIALIZED_ATTR:
1489                     pass
1490                 else:
1491                     objrepr = object_description(self.object)
1492                     self.add_line('   :value: ' + objrepr, sourcename)
1493             except ValueError:
1494                 pass
1495         elif self.options.annotation is SUPPRESS:
1496             pass
1497         else:
1498             self.add_line('   :annotation: %s' % self.options.annotation,
1499                           sourcename)
1500 
1501     def document_members(self, all_members: bool = False) -> None:
1502         pass
1503 
1504     def get_real_modname(self) -> str:
1505         return self.get_attr(self.parent or self.object, '__module__', None) \
1506             or self.modname
1507 
1508 
1509 class DataDeclarationDocumenter(DataDocumenter):
1510     """
1511     Specialized Documenter subclass for data that cannot be imported
1512     because they are declared without initial value (refs: PEP-526).
1513     """
1514     objtype = 'datadecl'
1515     directivetype = 'data'
1516     member_order = 60
1517 
1518     # must be higher than AttributeDocumenter
1519     priority = 11
1520 
1521     @classmethod
1522     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1523                             ) -> bool:
1524         """This documents only INSTANCEATTR members."""
1525         return (isinstance(parent, ModuleDocumenter) and
1526                 isattr and
1527                 member is INSTANCEATTR)
1528 
1529     def import_object(self) -> bool:
1530         """Never import anything."""
1531         # disguise as a data
1532         self.objtype = 'data'
1533         self.object = UNINITIALIZED_ATTR
1534         try:
1535             # import module to obtain type annotation
1536             self.parent = importlib.import_module(self.modname)
1537         except ImportError:
1538             pass
1539 
1540         return True
1541 
1542     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1543         """Never try to get a docstring from the object."""
1544         super().add_content(more_content, no_docstring=True)
1545 
1546 
1547 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1548     """
1549     Specialized Documenter subclass for methods (normal, static and class).
1550     """
1551     objtype = 'method'
1552     directivetype = 'method'
1553     member_order = 50
1554     priority = 1  # must be more than FunctionDocumenter
1555 
1556     @classmethod
1557     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1558                             ) -> bool:
1559         return inspect.isroutine(member) and \
1560             not isinstance(parent, ModuleDocumenter)
1561 
1562     def import_object(self) -> Any:
1563         ret = super().import_object()
1564         if not ret:
1565             return ret
1566 
1567         # to distinguish classmethod/staticmethod
1568         obj = self.parent.__dict__.get(self.object_name)
1569         if obj is None:
1570             obj = self.object
1571 
1572         if (inspect.isclassmethod(obj) or
1573                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1574             # document class and static members before ordinary ones
1575             self.member_order = self.member_order - 1
1576 
1577         return ret
1578 
1579     def format_args(self, **kwargs: Any) -> str:
1580         if self.env.config.autodoc_typehints in ('none', 'description'):
1581             kwargs.setdefault('show_annotation', False)
1582 
1583         try:
1584             if self.object == object.__init__ and self.parent != object:
1585                 # Classes not having own __init__() method are shown as no arguments.
1586                 #
1587                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1588                 #       But it makes users confused.
1589                 args = '()'
1590             else:
1591                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1592                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1593                     sig = inspect.signature(self.object, bound_method=False)
1594                 else:
1595                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1596 
1597                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1598                     if meth and inspect.is_singledispatch_method(meth):
1599                         sig = inspect.signature(self.object, bound_method=True,
1600                                                 follow_wrapped=True)
1601                     else:
1602                         sig = inspect.signature(self.object, bound_method=True)
1603                 args = stringify_signature(sig, **kwargs)
1604         except TypeError as exc:
1605             logger.warning(__("Failed to get a method signature for %s: %s"),
1606                            self.fullname, exc)
1607             return None
1608         except ValueError:
1609             args = ''
1610 
1611         if self.env.config.strip_signature_backslash:
1612             # escape backslashes for reST
1613             args = args.replace('\\', '\\\\')
1614         return args
1615 
1616     def add_directive_header(self, sig: str) -> None:
1617         super().add_directive_header(sig)
1618 
1619         sourcename = self.get_sourcename()
1620         obj = self.parent.__dict__.get(self.object_name, self.object)
1621         if inspect.isabstractmethod(obj):
1622             self.add_line('   :abstractmethod:', sourcename)
1623         if inspect.iscoroutinefunction(obj):
1624             self.add_line('   :async:', sourcename)
1625         if inspect.isclassmethod(obj):
1626             self.add_line('   :classmethod:', sourcename)
1627         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1628             self.add_line('   :staticmethod:', sourcename)
1629         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1630             self.add_line('   :final:', sourcename)
1631 
1632     def document_members(self, all_members: bool = False) -> None:
1633         pass
1634 
1635     def format_signature(self, **kwargs: Any) -> str:
1636         sig = super().format_signature(**kwargs)
1637         sigs = [sig]
1638 
1639         meth = self.parent.__dict__.get(self.objpath[-1])
1640         if inspect.is_singledispatch_method(meth):
1641             # append signature of singledispatch'ed functions
1642             for typ, func in meth.dispatcher.registry.items():
1643                 if typ is object:
1644                     pass  # default implementation. skipped.
1645                 else:
1646                     self.annotate_to_first_argument(func, typ)
1647 
1648                     documenter = MethodDocumenter(self.directive, '')
1649                     documenter.parent = self.parent
1650                     documenter.object = func
1651                     documenter.objpath = [None]
1652                     sigs.append(documenter.format_signature())
1653 
1654         return "\n".join(sigs)
1655 
1656     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1657         """Annotate type hint to the first argument of function if needed."""
1658         sig = inspect.signature(func)
1659         if len(sig.parameters) == 1:
1660             return
1661 
1662         params = list(sig.parameters.values())
1663         if params[1].annotation is Parameter.empty:
1664             params[1] = params[1].replace(annotation=typ)
1665             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1666 
1667 
1668 class SingledispatchMethodDocumenter(MethodDocumenter):
1669     """
1670     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1671 
1672     Retained for backwards compatibility, now does the same as the MethodDocumenter
1673     """
1674 
1675 
1676 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1677     """
1678     Specialized Documenter subclass for attributes.
1679     """
1680     objtype = 'attribute'
1681     member_order = 60
1682     option_spec = dict(ModuleLevelDocumenter.option_spec)
1683     option_spec["annotation"] = annotation_option
1684 
1685     # must be higher than the MethodDocumenter, else it will recognize
1686     # some non-data descriptors as methods
1687     priority = 10
1688 
1689     @staticmethod
1690     def is_function_or_method(obj: Any) -> bool:
1691         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1692 
1693     @classmethod
1694     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1695                             ) -> bool:
1696         if inspect.isattributedescriptor(member):
1697             return True
1698         elif (not isinstance(parent, ModuleDocumenter) and
1699               not inspect.isroutine(member) and
1700               not isinstance(member, type)):
1701             return True
1702         else:
1703             return False
1704 
1705     def document_members(self, all_members: bool = False) -> None:
1706         pass
1707 
1708     def import_object(self) -> Any:
1709         ret = super().import_object()
1710         if inspect.isenumattribute(self.object):
1711             self.object = self.object.value
1712         if inspect.isattributedescriptor(self.object):
1713             self._datadescriptor = True
1714         else:
1715             # if it's not a data descriptor
1716             self._datadescriptor = False
1717         return ret
1718 
1719     def get_real_modname(self) -> str:
1720         return self.get_attr(self.parent or self.object, '__module__', None) \
1721             or self.modname
1722 
1723     def add_directive_header(self, sig: str) -> None:
1724         super().add_directive_header(sig)
1725         sourcename = self.get_sourcename()
1726         if not self.options.annotation:
1727             # obtain type annotation for this attribute
1728             annotations = getattr(self.parent, '__annotations__', {})
1729             if annotations and self.objpath[-1] in annotations:
1730                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1731                 self.add_line('   :type: ' + objrepr, sourcename)
1732             else:
1733                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1734                 if self.analyzer and key in self.analyzer.annotations:
1735                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1736                                   sourcename)
1737 
1738             # data descriptors do not have useful values
1739             if not self._datadescriptor:
1740                 try:
1741                     if self.object is INSTANCEATTR:
1742                         pass
1743                     else:
1744                         objrepr = object_description(self.object)
1745                         self.add_line('   :value: ' + objrepr, sourcename)
1746                 except ValueError:
1747                     pass
1748         elif self.options.annotation is SUPPRESS:
1749             pass
1750         else:
1751             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1752 
1753     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1754         if not self._datadescriptor:
1755             # if it's not a data descriptor, its docstring is very probably the
1756             # wrong thing to display
1757             no_docstring = True
1758         super().add_content(more_content, no_docstring)
1759 
1760 
1761 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1762     """
1763     Specialized Documenter subclass for properties.
1764     """
1765     objtype = 'property'
1766     directivetype = 'method'
1767     member_order = 60
1768 
1769     # before AttributeDocumenter
1770     priority = AttributeDocumenter.priority + 1
1771 
1772     @classmethod
1773     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1774                             ) -> bool:
1775         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1776 
1777     def document_members(self, all_members: bool = False) -> None:
1778         pass
1779 
1780     def get_real_modname(self) -> str:
1781         return self.get_attr(self.parent or self.object, '__module__', None) \
1782             or self.modname
1783 
1784     def add_directive_header(self, sig: str) -> None:
1785         super().add_directive_header(sig)
1786         sourcename = self.get_sourcename()
1787         if inspect.isabstractmethod(self.object):
1788             self.add_line('   :abstractmethod:', sourcename)
1789         self.add_line('   :property:', sourcename)
1790 
1791 
1792 class InstanceAttributeDocumenter(AttributeDocumenter):
1793     """
1794     Specialized Documenter subclass for attributes that cannot be imported
1795     because they are instance attributes (e.g. assigned in __init__).
1796     """
1797     objtype = 'instanceattribute'
1798     directivetype = 'attribute'
1799     member_order = 60
1800 
1801     # must be higher than AttributeDocumenter
1802     priority = 11
1803 
1804     @classmethod
1805     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1806                             ) -> bool:
1807         """This documents only INSTANCEATTR members."""
1808         return (not isinstance(parent, ModuleDocumenter) and
1809                 isattr and
1810                 member is INSTANCEATTR)
1811 
1812     def import_object(self) -> bool:
1813         """Never import anything."""
1814         # disguise as an attribute
1815         self.objtype = 'attribute'
1816         self.object = INSTANCEATTR
1817         self._datadescriptor = False
1818         return True
1819 
1820     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1821         """Never try to get a docstring from the object."""
1822         super().add_content(more_content, no_docstring=True)
1823 
1824 
1825 class SlotsAttributeDocumenter(AttributeDocumenter):
1826     """
1827     Specialized Documenter subclass for attributes that cannot be imported
1828     because they are attributes in __slots__.
1829     """
1830     objtype = 'slotsattribute'
1831     directivetype = 'attribute'
1832     member_order = 60
1833 
1834     # must be higher than AttributeDocumenter
1835     priority = 11
1836 
1837     @classmethod
1838     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1839                             ) -> bool:
1840         """This documents only SLOTSATTR members."""
1841         return member is SLOTSATTR
1842 
1843     def import_object(self) -> Any:
1844         """Never import anything."""
1845         # disguise as an attribute
1846         self.objtype = 'attribute'
1847         self._datadescriptor = True
1848 
1849         with mock(self.env.config.autodoc_mock_imports):
1850             try:
1851                 ret = import_object(self.modname, self.objpath[:-1], 'class',
1852                                     attrgetter=self.get_attr,
1853                                     warningiserror=self.env.config.autodoc_warningiserror)
1854                 self.module, _, _, self.parent = ret
1855                 return True
1856             except ImportError as exc:
1857                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1858                 self.env.note_reread()
1859                 return False
1860 
1861     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1862         """Decode and return lines of the docstring(s) for the object."""
1863         if ignore is not None:
1864             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1865                           % self.__class__.__name__,
1866                           RemovedInSphinx50Warning, stacklevel=2)
1867         name = self.objpath[-1]
1868         __slots__ = safe_getattr(self.parent, '__slots__', [])
1869         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
1870             docstring = prepare_docstring(__slots__[name])
1871             return [docstring]
1872         else:
1873             return []
1874 
1875 
1876 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
1877     """Returns registered Documenter classes"""
1878     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
1879     return app.registry.documenters
1880 
1881 
1882 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
1883     """Alternative getattr() for types"""
1884     for typ, func in app.registry.autodoc_attrgettrs.items():
1885         if isinstance(obj, typ):
1886             return func(obj, name, *defargs)
1887 
1888     return safe_getattr(obj, name, *defargs)
1889 
1890 
1891 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
1892     if config.autodoc_member_order == 'alphabetic':
1893         # RemovedInSphinx50Warning
1894         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
1895                           'instead of "alphabetic". Please update your setting.'))
1896         config.autodoc_member_order = 'alphabetical'  # type: ignore
1897 
1898 
1899 def setup(app: Sphinx) -> Dict[str, Any]:
1900     app.add_autodocumenter(ModuleDocumenter)
1901     app.add_autodocumenter(ClassDocumenter)
1902     app.add_autodocumenter(ExceptionDocumenter)
1903     app.add_autodocumenter(DataDocumenter)
1904     app.add_autodocumenter(DataDeclarationDocumenter)
1905     app.add_autodocumenter(FunctionDocumenter)
1906     app.add_autodocumenter(DecoratorDocumenter)
1907     app.add_autodocumenter(MethodDocumenter)
1908     app.add_autodocumenter(AttributeDocumenter)
1909     app.add_autodocumenter(PropertyDocumenter)
1910     app.add_autodocumenter(InstanceAttributeDocumenter)
1911     app.add_autodocumenter(SlotsAttributeDocumenter)
1912 
1913     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
1914     app.add_config_value('autodoc_member_order', 'alphabetical', True,
1915                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
1916     app.add_config_value('autodoc_default_options', {}, True)
1917     app.add_config_value('autodoc_docstring_signature', True, True)
1918     app.add_config_value('autodoc_mock_imports', [], True)
1919     app.add_config_value('autodoc_typehints', "signature", True,
1920                          ENUM("signature", "description", "none"))
1921     app.add_config_value('autodoc_warningiserror', True, True)
1922     app.add_config_value('autodoc_inherit_docstrings', True, True)
1923     app.add_event('autodoc-before-process-signature')
1924     app.add_event('autodoc-process-docstring')
1925     app.add_event('autodoc-process-signature')
1926     app.add_event('autodoc-skip-member')
1927 
1928     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
1929 
1930     app.setup_extension('sphinx.ext.autodoc.type_comment')
1931     app.setup_extension('sphinx.ext.autodoc.typehints')
1932 
1933     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>Modify the logic that parses method signatures from docstrings to iteratively capture all signatures present for overloaded methods. The modified code should ensure that each overloaded method signature is identified, parsed, and included in the generated documentation, rather than only recognizing the first signature. This enhancement should preserve the existing functionality of handling single-method docstrings while extending support for overloaded method signatures.</intended_behavior>, <file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import inspect
14 import re
15 from functools import partial
16 from typing import Any, Callable, Dict, List, Tuple, Union
17 
18 from sphinx.application import Sphinx
19 from sphinx.config import Config as SphinxConfig
20 from sphinx.ext.napoleon.iterators import modify_iter
21 from sphinx.locale import _
22 
23 if False:
24     # For type annotation
25     from typing import Type  # for python3.5.1
26 
27 
28 _directive_regex = re.compile(r'\.\. \S+::')
29 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
30 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
31 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
33 _xref_or_code_regex = re.compile(
34     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
35     r'(?:``.+``))')
36 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
37 _enumerated_list_regex = re.compile(
38     r'^(?P<paren>\()?'
39     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
40     r'(?(paren)\)|\.)(\s+\S|\s*$)')
41 
42 
43 class GoogleDocstring:
44     """Convert Google style docstrings to reStructuredText.
45 
46     Parameters
47     ----------
48     docstring : :obj:`str` or :obj:`list` of :obj:`str`
49         The docstring to parse, given either as a string or split into
50         individual lines.
51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
52         The configuration settings to use. If not given, defaults to the
53         config object on `app`; or if `app` is not given defaults to the
54         a new :class:`sphinx.ext.napoleon.Config` object.
55 
56 
57     Other Parameters
58     ----------------
59     app : :class:`sphinx.application.Sphinx`, optional
60         Application object representing the Sphinx process.
61     what : :obj:`str`, optional
62         A string specifying the type of the object to which the docstring
63         belongs. Valid values: "module", "class", "exception", "function",
64         "method", "attribute".
65     name : :obj:`str`, optional
66         The fully qualified name of the object.
67     obj : module, class, exception, function, method, or attribute
68         The object to which the docstring belongs.
69     options : :class:`sphinx.ext.autodoc.Options`, optional
70         The options given to the directive: an object with attributes
71         inherited_members, undoc_members, show_inheritance and noindex that
72         are True if the flag option of same name was given to the auto
73         directive.
74 
75 
76     Example
77     -------
78     >>> from sphinx.ext.napoleon import Config
79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
80     >>> docstring = '''One line summary.
81     ...
82     ... Extended description.
83     ...
84     ... Args:
85     ...   arg1(int): Description of `arg1`
86     ...   arg2(str): Description of `arg2`
87     ... Returns:
88     ...   str: Description of return value.
89     ... '''
90     >>> print(GoogleDocstring(docstring, config))
91     One line summary.
92     <BLANKLINE>
93     Extended description.
94     <BLANKLINE>
95     :param arg1: Description of `arg1`
96     :type arg1: int
97     :param arg2: Description of `arg2`
98     :type arg2: str
99     <BLANKLINE>
100     :returns: Description of return value.
101     :rtype: str
102     <BLANKLINE>
103 
104     """
105 
106     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
107                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
108 
109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
110                  app: Sphinx = None, what: str = '', name: str = '',
111                  obj: Any = None, options: Any = None) -> None:
112         self._config = config
113         self._app = app
114 
115         if not self._config:
116             from sphinx.ext.napoleon import Config
117             self._config = self._app.config if self._app else Config()  # type: ignore
118 
119         if not what:
120             if inspect.isclass(obj):
121                 what = 'class'
122             elif inspect.ismodule(obj):
123                 what = 'module'
124             elif callable(obj):
125                 what = 'function'
126             else:
127                 what = 'object'
128 
129         self._what = what
130         self._name = name
131         self._obj = obj
132         self._opt = options
133         if isinstance(docstring, str):
134             lines = docstring.splitlines()
135         else:
136             lines = docstring
137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
138         self._parsed_lines = []  # type: List[str]
139         self._is_in_section = False
140         self._section_indent = 0
141         if not hasattr(self, '_directive_sections'):
142             self._directive_sections = []  # type: List[str]
143         if not hasattr(self, '_sections'):
144             self._sections = {
145                 'args': self._parse_parameters_section,
146                 'arguments': self._parse_parameters_section,
147                 'attention': partial(self._parse_admonition, 'attention'),
148                 'attributes': self._parse_attributes_section,
149                 'caution': partial(self._parse_admonition, 'caution'),
150                 'danger': partial(self._parse_admonition, 'danger'),
151                 'error': partial(self._parse_admonition, 'error'),
152                 'example': self._parse_examples_section,
153                 'examples': self._parse_examples_section,
154                 'hint': partial(self._parse_admonition, 'hint'),
155                 'important': partial(self._parse_admonition, 'important'),
156                 'keyword args': self._parse_keyword_arguments_section,
157                 'keyword arguments': self._parse_keyword_arguments_section,
158                 'methods': self._parse_methods_section,
159                 'note': partial(self._parse_admonition, 'note'),
160                 'notes': self._parse_notes_section,
161                 'other parameters': self._parse_other_parameters_section,
162                 'parameters': self._parse_parameters_section,
163                 'return': self._parse_returns_section,
164                 'returns': self._parse_returns_section,
165                 'raises': self._parse_raises_section,
166                 'references': self._parse_references_section,
167                 'see also': self._parse_see_also_section,
168                 'tip': partial(self._parse_admonition, 'tip'),
169                 'todo': partial(self._parse_admonition, 'todo'),
170                 'warning': partial(self._parse_admonition, 'warning'),
171                 'warnings': partial(self._parse_admonition, 'warning'),
172                 'warns': self._parse_warns_section,
173                 'yield': self._parse_yields_section,
174                 'yields': self._parse_yields_section,
175             }  # type: Dict[str, Callable]
176 
177         self._load_custom_sections()
178 
179         self._parse()
180 
181     def __str__(self) -> str:
182         """Return the parsed docstring in reStructuredText format.
183 
184         Returns
185         -------
186         unicode
187             Unicode version of the docstring.
188 
189         """
190         return '\n'.join(self.lines())
191 
192     def lines(self) -> List[str]:
193         """Return the parsed lines of the docstring in reStructuredText format.
194 
195         Returns
196         -------
197         list(str)
198             The lines of the docstring in a list.
199 
200         """
201         return self._parsed_lines
202 
203     def _consume_indented_block(self, indent: int = 1) -> List[str]:
204         lines = []
205         line = self._line_iter.peek()
206         while(not self._is_section_break() and
207               (not line or self._is_indented(line, indent))):
208             lines.append(next(self._line_iter))
209             line = self._line_iter.peek()
210         return lines
211 
212     def _consume_contiguous(self) -> List[str]:
213         lines = []
214         while (self._line_iter.has_next() and
215                self._line_iter.peek() and
216                not self._is_section_header()):
217             lines.append(next(self._line_iter))
218         return lines
219 
220     def _consume_empty(self) -> List[str]:
221         lines = []
222         line = self._line_iter.peek()
223         while self._line_iter.has_next() and not line:
224             lines.append(next(self._line_iter))
225             line = self._line_iter.peek()
226         return lines
227 
228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
229                        ) -> Tuple[str, str, List[str]]:
230         line = next(self._line_iter)
231 
232         before, colon, after = self._partition_field_on_colon(line)
233         _name, _type, _desc = before, '', after
234 
235         if parse_type:
236             match = _google_typed_arg_regex.match(before)
237             if match:
238                 _name = match.group(1)
239                 _type = match.group(2)
240 
241         _name = self._escape_args_and_kwargs(_name)
242 
243         if prefer_type and not _type:
244             _type, _name = _name, _type
245         indent = self._get_indent(line) + 1
246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
247         _descs = self.__class__(_descs, self._config).lines()
248         return _name, _type, _descs
249 
250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False
251                         ) -> List[Tuple[str, str, List[str]]]:
252         self._consume_empty()
253         fields = []
254         while not self._is_section_break():
255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
256             if _name or _type or _desc:
257                 fields.append((_name, _type, _desc,))
258         return fields
259 
260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
261         line = next(self._line_iter)
262         _type, colon, _desc = self._partition_field_on_colon(line)
263         if not colon or not _desc:
264             _type, _desc = _desc, _type
265             _desc += colon
266         _descs = [_desc] + self._dedent(self._consume_to_end())
267         _descs = self.__class__(_descs, self._config).lines()
268         return _type, _descs
269 
270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
271         lines = self._dedent(self._consume_to_next_section())
272         if lines:
273             before, colon, after = self._partition_field_on_colon(lines[0])
274             _name, _type, _desc = '', '', lines
275 
276             if colon:
277                 if after:
278                     _desc = [after] + lines[1:]
279                 else:
280                     _desc = lines[1:]
281 
282                 _type = before
283 
284             _desc = self.__class__(_desc, self._config).lines()
285             return [(_name, _type, _desc,)]
286         else:
287             return []
288 
289     def _consume_usage_section(self) -> List[str]:
290         lines = self._dedent(self._consume_to_next_section())
291         return lines
292 
293     def _consume_section_header(self) -> str:
294         section = next(self._line_iter)
295         stripped_section = section.strip(':')
296         if stripped_section.lower() in self._sections:
297             section = stripped_section
298         return section
299 
300     def _consume_to_end(self) -> List[str]:
301         lines = []
302         while self._line_iter.has_next():
303             lines.append(next(self._line_iter))
304         return lines
305 
306     def _consume_to_next_section(self) -> List[str]:
307         self._consume_empty()
308         lines = []
309         while not self._is_section_break():
310             lines.append(next(self._line_iter))
311         return lines + self._consume_empty()
312 
313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
314         if full:
315             return [line.lstrip() for line in lines]
316         else:
317             min_indent = self._get_min_indent(lines)
318             return [line[min_indent:] for line in lines]
319 
320     def _escape_args_and_kwargs(self, name: str) -> str:
321         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):
322             name = name[:-1] + r'\_'
323 
324         if name[:2] == '**':
325             return r'\*\*' + name[2:]
326         elif name[:1] == '*':
327             return r'\*' + name[1:]
328         else:
329             return name
330 
331     def _fix_field_desc(self, desc: List[str]) -> List[str]:
332         if self._is_list(desc):
333             desc = [''] + desc
334         elif desc[0].endswith('::'):
335             desc_block = desc[1:]
336             indent = self._get_indent(desc[0])
337             block_indent = self._get_initial_indent(desc_block)
338             if block_indent > indent:
339                 desc = [''] + desc
340             else:
341                 desc = ['', desc[0]] + self._indent(desc_block, 4)
342         return desc
343 
344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
345         lines = self._strip_empty(lines)
346         if len(lines) == 1:
347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
348         elif lines:
349             lines = self._indent(self._dedent(lines), 3)
350             return ['.. %s::' % admonition, ''] + lines + ['']
351         else:
352             return ['.. %s::' % admonition, '']
353 
354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
355         if lines:
356             if padding is None:
357                 padding = ' ' * len(prefix)
358             result_lines = []
359             for i, line in enumerate(lines):
360                 if i == 0:
361                     result_lines.append((prefix + line).rstrip())
362                 elif line:
363                     result_lines.append(padding + line)
364                 else:
365                     result_lines.append('')
366             return result_lines
367         else:
368             return [prefix]
369 
370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
371                                 field_role: str = 'param', type_role: str = 'type'
372                                 ) -> List[str]:
373         lines = []
374         for _name, _type, _desc in fields:
375             _desc = self._strip_empty(_desc)
376             if any(_desc):
377                 _desc = self._fix_field_desc(_desc)
378                 field = ':%s %s: ' % (field_role, _name)
379                 lines.extend(self._format_block(field, _desc))
380             else:
381                 lines.append(':%s %s:' % (field_role, _name))
382 
383             if _type:
384                 lines.append(':%s %s: %s' % (type_role, _name, _type))
385         return lines + ['']
386 
387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
388         _desc = self._strip_empty(_desc)
389         has_desc = any(_desc)
390         separator = ' -- ' if has_desc else ''
391         if _name:
392             if _type:
393                 if '`' in _type:
394                     field = '**%s** (%s)%s' % (_name, _type, separator)
395                 else:
396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
397             else:
398                 field = '**%s**%s' % (_name, separator)
399         elif _type:
400             if '`' in _type:
401                 field = '%s%s' % (_type, separator)
402             else:
403                 field = '*%s*%s' % (_type, separator)
404         else:
405             field = ''
406 
407         if has_desc:
408             _desc = self._fix_field_desc(_desc)
409             if _desc[0]:
410                 return [field + _desc[0]] + _desc[1:]
411             else:
412                 return [field] + _desc
413         else:
414             return [field]
415 
416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
417                        ) -> List[str]:
418         field_type = ':%s:' % field_type.strip()
419         padding = ' ' * len(field_type)
420         multi = len(fields) > 1
421         lines = []  # type: List[str]
422         for _name, _type, _desc in fields:
423             field = self._format_field(_name, _type, _desc)
424             if multi:
425                 if lines:
426                     lines.extend(self._format_block(padding + ' * ', field))
427                 else:
428                     lines.extend(self._format_block(field_type + ' * ', field))
429             else:
430                 lines.extend(self._format_block(field_type + ' ', field))
431         if lines and lines[-1]:
432             lines.append('')
433         return lines
434 
435     def _get_current_indent(self, peek_ahead: int = 0) -> int:
436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
437         while line != self._line_iter.sentinel:
438             if line:
439                 return self._get_indent(line)
440             peek_ahead += 1
441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
442         return 0
443 
444     def _get_indent(self, line: str) -> int:
445         for i, s in enumerate(line):
446             if not s.isspace():
447                 return i
448         return len(line)
449 
450     def _get_initial_indent(self, lines: List[str]) -> int:
451         for line in lines:
452             if line:
453                 return self._get_indent(line)
454         return 0
455 
456     def _get_min_indent(self, lines: List[str]) -> int:
457         min_indent = None
458         for line in lines:
459             if line:
460                 indent = self._get_indent(line)
461                 if min_indent is None:
462                     min_indent = indent
463                 elif indent < min_indent:
464                     min_indent = indent
465         return min_indent or 0
466 
467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
468         return [(' ' * n) + line for line in lines]
469 
470     def _is_indented(self, line: str, indent: int = 1) -> bool:
471         for i, s in enumerate(line):
472             if i >= indent:
473                 return True
474             elif not s.isspace():
475                 return False
476         return False
477 
478     def _is_list(self, lines: List[str]) -> bool:
479         if not lines:
480             return False
481         if _bullet_list_regex.match(lines[0]):
482             return True
483         if _enumerated_list_regex.match(lines[0]):
484             return True
485         if len(lines) < 2 or lines[0].endswith('::'):
486             return False
487         indent = self._get_indent(lines[0])
488         next_indent = indent
489         for line in lines[1:]:
490             if line:
491                 next_indent = self._get_indent(line)
492                 break
493         return next_indent > indent
494 
495     def _is_section_header(self) -> bool:
496         section = self._line_iter.peek().lower()
497         match = _google_section_regex.match(section)
498         if match and section.strip(':') in self._sections:
499             header_indent = self._get_indent(section)
500             section_indent = self._get_current_indent(peek_ahead=1)
501             return section_indent > header_indent
502         elif self._directive_sections:
503             if _directive_regex.match(section):
504                 for directive_section in self._directive_sections:
505                     if section.startswith(directive_section):
506                         return True
507         return False
508 
509     def _is_section_break(self) -> bool:
510         line = self._line_iter.peek()
511         return (not self._line_iter.has_next() or
512                 self._is_section_header() or
513                 (self._is_in_section and
514                     line and
515                     not self._is_indented(line, self._section_indent)))
516 
517     def _load_custom_sections(self) -> None:
518         if self._config.napoleon_custom_sections is not None:
519             for entry in self._config.napoleon_custom_sections:
520                 if isinstance(entry, str):
521                     # if entry is just a label, add to sections list,
522                     # using generic section logic.
523                     self._sections[entry.lower()] = self._parse_custom_generic_section
524                 else:
525                     # otherwise, assume entry is container;
526                     # [0] is new section, [1] is the section to alias.
527                     # in the case of key mismatch, just handle as generic section.
528                     self._sections[entry[0].lower()] = \
529                         self._sections.get(entry[1].lower(),
530                                            self._parse_custom_generic_section)
531 
532     def _parse(self) -> None:
533         self._parsed_lines = self._consume_empty()
534 
535         if self._name and self._what in ('attribute', 'data', 'property'):
536             # Implicit stop using StopIteration no longer allowed in
537             # Python 3.7; see PEP 479
538             res = []  # type: List[str]
539             try:
540                 res = self._parse_attribute_docstring()
541             except StopIteration:
542                 pass
543             self._parsed_lines.extend(res)
544             return
545 
546         while self._line_iter.has_next():
547             if self._is_section_header():
548                 try:
549                     section = self._consume_section_header()
550                     self._is_in_section = True
551                     self._section_indent = self._get_current_indent()
552                     if _directive_regex.match(section):
553                         lines = [section] + self._consume_to_next_section()
554                     else:
555                         lines = self._sections[section.lower()](section)
556                 finally:
557                     self._is_in_section = False
558                     self._section_indent = 0
559             else:
560                 if not self._parsed_lines:
561                     lines = self._consume_contiguous() + self._consume_empty()
562                 else:
563                     lines = self._consume_to_next_section()
564             self._parsed_lines.extend(lines)
565 
566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
567         # type (str, str) -> List[str]
568         lines = self._consume_to_next_section()
569         return self._format_admonition(admonition, lines)
570 
571     def _parse_attribute_docstring(self) -> List[str]:
572         _type, _desc = self._consume_inline_attribute()
573         lines = self._format_field('', '', _desc)
574         if _type:
575             lines.extend(['', ':type: %s' % _type])
576         return lines
577 
578     def _parse_attributes_section(self, section: str) -> List[str]:
579         lines = []
580         for _name, _type, _desc in self._consume_fields():
581             if self._config.napoleon_use_ivar:
582                 _name = self._qualify_name(_name, self._obj)
583                 field = ':ivar %s: ' % _name
584                 lines.extend(self._format_block(field, _desc))
585                 if _type:
586                     lines.append(':vartype %s: %s' % (_name, _type))
587             else:
588                 lines.append('.. attribute:: ' + _name)
589                 if self._opt and 'noindex' in self._opt:
590                     lines.append('   :noindex:')
591                 if _type:
592                     lines.extend(self._indent([':type: %s' % _type], 3))
593                 lines.append('')
594 
595                 fields = self._format_field('', '', _desc)
596                 lines.extend(self._indent(fields, 3))
597                 lines.append('')
598         if self._config.napoleon_use_ivar:
599             lines.append('')
600         return lines
601 
602     def _parse_examples_section(self, section: str) -> List[str]:
603         labels = {
604             'example': _('Example'),
605             'examples': _('Examples'),
606         }
607         use_admonition = self._config.napoleon_use_admonition_for_examples
608         label = labels.get(section.lower(), section)
609         return self._parse_generic_section(label, use_admonition)
610 
611     def _parse_custom_generic_section(self, section: str) -> List[str]:
612         # for now, no admonition for simple custom sections
613         return self._parse_generic_section(section, False)
614 
615     def _parse_usage_section(self, section: str) -> List[str]:
616         header = ['.. rubric:: Usage:', '']
617         block = ['.. code-block:: python', '']
618         lines = self._consume_usage_section()
619         lines = self._indent(lines, 3)
620         return header + block + lines + ['']
621 
622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
623         lines = self._strip_empty(self._consume_to_next_section())
624         lines = self._dedent(lines)
625         if use_admonition:
626             header = '.. admonition:: %s' % section
627             lines = self._indent(lines, 3)
628         else:
629             header = '.. rubric:: %s' % section
630         if lines:
631             return [header, ''] + lines + ['']
632         else:
633             return [header, '']
634 
635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
636         fields = self._consume_fields()
637         if self._config.napoleon_use_keyword:
638             return self._format_docutils_params(
639                 fields,
640                 field_role="keyword",
641                 type_role="kwtype")
642         else:
643             return self._format_fields(_('Keyword Arguments'), fields)
644 
645     def _parse_methods_section(self, section: str) -> List[str]:
646         lines = []  # type: List[str]
647         for _name, _type, _desc in self._consume_fields(parse_type=False):
648             lines.append('.. method:: %s' % _name)
649             if self._opt and 'noindex' in self._opt:
650                 lines.append('   :noindex:')
651             if _desc:
652                 lines.extend([''] + self._indent(_desc, 3))
653             lines.append('')
654         return lines
655 
656     def _parse_notes_section(self, section: str) -> List[str]:
657         use_admonition = self._config.napoleon_use_admonition_for_notes
658         return self._parse_generic_section(_('Notes'), use_admonition)
659 
660     def _parse_other_parameters_section(self, section: str) -> List[str]:
661         return self._format_fields(_('Other Parameters'), self._consume_fields())
662 
663     def _parse_parameters_section(self, section: str) -> List[str]:
664         fields = self._consume_fields()
665         if self._config.napoleon_use_param:
666             return self._format_docutils_params(fields)
667         else:
668             return self._format_fields(_('Parameters'), fields)
669 
670     def _parse_raises_section(self, section: str) -> List[str]:
671         fields = self._consume_fields(parse_type=False, prefer_type=True)
672         lines = []  # type: List[str]
673         for _name, _type, _desc in fields:
674             m = self._name_rgx.match(_type)
675             if m and m.group('name'):
676                 _type = m.group('name')
677             _type = ' ' + _type if _type else ''
678             _desc = self._strip_empty(_desc)
679             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
680             lines.append(':raises%s:%s' % (_type, _descs))
681         if lines:
682             lines.append('')
683         return lines
684 
685     def _parse_references_section(self, section: str) -> List[str]:
686         use_admonition = self._config.napoleon_use_admonition_for_references
687         return self._parse_generic_section(_('References'), use_admonition)
688 
689     def _parse_returns_section(self, section: str) -> List[str]:
690         fields = self._consume_returns_section()
691         multi = len(fields) > 1
692         if multi:
693             use_rtype = False
694         else:
695             use_rtype = self._config.napoleon_use_rtype
696 
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             if use_rtype:
700                 field = self._format_field(_name, '', _desc)
701             else:
702                 field = self._format_field(_name, _type, _desc)
703 
704             if multi:
705                 if lines:
706                     lines.extend(self._format_block('          * ', field))
707                 else:
708                     lines.extend(self._format_block(':returns: * ', field))
709             else:
710                 lines.extend(self._format_block(':returns: ', field))
711                 if _type and use_rtype:
712                     lines.extend([':rtype: %s' % _type, ''])
713         if lines and lines[-1]:
714             lines.append('')
715         return lines
716 
717     def _parse_see_also_section(self, section: str) -> List[str]:
718         return self._parse_admonition('seealso', section)
719 
720     def _parse_warns_section(self, section: str) -> List[str]:
721         return self._format_fields(_('Warns'), self._consume_fields())
722 
723     def _parse_yields_section(self, section: str) -> List[str]:
724         fields = self._consume_returns_section()
725         return self._format_fields(_('Yields'), fields)
726 
727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
728         before_colon = []
729         after_colon = []
730         colon = ''
731         found_colon = False
732         for i, source in enumerate(_xref_or_code_regex.split(line)):
733             if found_colon:
734                 after_colon.append(source)
735             else:
736                 m = _single_colon_regex.search(source)
737                 if (i % 2) == 0 and m:
738                     found_colon = True
739                     colon = source[m.start(): m.end()]
740                     before_colon.append(source[:m.start()])
741                     after_colon.append(source[m.end():])
742                 else:
743                     before_colon.append(source)
744 
745         return ("".join(before_colon).strip(),
746                 colon,
747                 "".join(after_colon).strip())
748 
749     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
750         if klass and '.' not in attr_name:
751             if attr_name.startswith('~'):
752                 attr_name = attr_name[1:]
753             try:
754                 q = klass.__qualname__
755             except AttributeError:
756                 q = klass.__name__
757             return '~%s.%s' % (q, attr_name)
758         return attr_name
759 
760     def _strip_empty(self, lines: List[str]) -> List[str]:
761         if lines:
762             start = -1
763             for i, line in enumerate(lines):
764                 if line:
765                     start = i
766                     break
767             if start == -1:
768                 lines = []
769             end = -1
770             for i in reversed(range(len(lines))):
771                 line = lines[i]
772                 if line:
773                     end = i
774                     break
775             if start > 0 or end + 1 < len(lines):
776                 lines = lines[start:end + 1]
777         return lines
778 
779 
780 class NumpyDocstring(GoogleDocstring):
781     """Convert NumPy style docstrings to reStructuredText.
782 
783     Parameters
784     ----------
785     docstring : :obj:`str` or :obj:`list` of :obj:`str`
786         The docstring to parse, given either as a string or split into
787         individual lines.
788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
789         The configuration settings to use. If not given, defaults to the
790         config object on `app`; or if `app` is not given defaults to the
791         a new :class:`sphinx.ext.napoleon.Config` object.
792 
793 
794     Other Parameters
795     ----------------
796     app : :class:`sphinx.application.Sphinx`, optional
797         Application object representing the Sphinx process.
798     what : :obj:`str`, optional
799         A string specifying the type of the object to which the docstring
800         belongs. Valid values: "module", "class", "exception", "function",
801         "method", "attribute".
802     name : :obj:`str`, optional
803         The fully qualified name of the object.
804     obj : module, class, exception, function, method, or attribute
805         The object to which the docstring belongs.
806     options : :class:`sphinx.ext.autodoc.Options`, optional
807         The options given to the directive: an object with attributes
808         inherited_members, undoc_members, show_inheritance and noindex that
809         are True if the flag option of same name was given to the auto
810         directive.
811 
812 
813     Example
814     -------
815     >>> from sphinx.ext.napoleon import Config
816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
817     >>> docstring = '''One line summary.
818     ...
819     ... Extended description.
820     ...
821     ... Parameters
822     ... ----------
823     ... arg1 : int
824     ...     Description of `arg1`
825     ... arg2 : str
826     ...     Description of `arg2`
827     ... Returns
828     ... -------
829     ... str
830     ...     Description of return value.
831     ... '''
832     >>> print(NumpyDocstring(docstring, config))
833     One line summary.
834     <BLANKLINE>
835     Extended description.
836     <BLANKLINE>
837     :param arg1: Description of `arg1`
838     :type arg1: int
839     :param arg2: Description of `arg2`
840     :type arg2: str
841     <BLANKLINE>
842     :returns: Description of return value.
843     :rtype: str
844     <BLANKLINE>
845 
846     Methods
847     -------
848     __str__()
849         Return the parsed docstring in reStructuredText format.
850 
851         Returns
852         -------
853         str
854             UTF-8 encoded version of the docstring.
855 
856     __unicode__()
857         Return the parsed docstring in reStructuredText format.
858 
859         Returns
860         -------
861         unicode
862             Unicode version of the docstring.
863 
864     lines()
865         Return the parsed lines of the docstring in reStructuredText format.
866 
867         Returns
868         -------
869         list(str)
870             The lines of the docstring in a list.
871 
872     """
873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
874                  app: Sphinx = None, what: str = '', name: str = '',
875                  obj: Any = None, options: Any = None) -> None:
876         self._directive_sections = ['.. index::']
877         super().__init__(docstring, config, app, what, name, obj, options)
878 
879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
880                        ) -> Tuple[str, str, List[str]]:
881         line = next(self._line_iter)
882         if parse_type:
883             _name, _, _type = self._partition_field_on_colon(line)
884         else:
885             _name, _type = line, ''
886         _name, _type = _name.strip(), _type.strip()
887         _name = self._escape_args_and_kwargs(_name)
888 
889         if prefer_type and not _type:
890             _type, _name = _name, _type
891         indent = self._get_indent(line) + 1
892         _desc = self._dedent(self._consume_indented_block(indent))
893         _desc = self.__class__(_desc, self._config).lines()
894         return _name, _type, _desc
895 
896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
897         return self._consume_fields(prefer_type=True)
898 
899     def _consume_section_header(self) -> str:
900         section = next(self._line_iter)
901         if not _directive_regex.match(section):
902             # Consume the header underline
903             next(self._line_iter)
904         return section
905 
906     def _is_section_break(self) -> bool:
907         line1, line2 = self._line_iter.peek(2)
908         return (not self._line_iter.has_next() or
909                 self._is_section_header() or
910                 ['', ''] == [line1, line2] or
911                 (self._is_in_section and
912                     line1 and
913                     not self._is_indented(line1, self._section_indent)))
914 
915     def _is_section_header(self) -> bool:
916         section, underline = self._line_iter.peek(2)
917         section = section.lower()
918         if section in self._sections and isinstance(underline, str):
919             return bool(_numpy_section_regex.match(underline))
920         elif self._directive_sections:
921             if _directive_regex.match(section):
922                 for directive_section in self._directive_sections:
923                     if section.startswith(directive_section):
924                         return True
925         return False
926 
927     def _parse_see_also_section(self, section: str) -> List[str]:
928         lines = self._consume_to_next_section()
929         try:
930             return self._parse_numpydoc_see_also_section(lines)
931         except ValueError:
932             return self._format_admonition('seealso', lines)
933 
934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
935         """
936         Derived from the NumpyDoc implementation of _parse_see_also.
937 
938         See Also
939         --------
940         func_name : Descriptive text
941             continued text
942         another_func_name : Descriptive text
943         func_name1, func_name2, :meth:`func_name`, func_name3
944 
945         """
946         items = []
947 
948         def parse_item_name(text: str) -> Tuple[str, str]:
949             """Match ':role:`name`' or 'name'"""
950             m = self._name_rgx.match(text)
951             if m:
952                 g = m.groups()
953                 if g[1] is None:
954                     return g[3], None
955                 else:
956                     return g[2], g[1]
957             raise ValueError("%s is not a item name" % text)
958 
959         def push_item(name: str, rest: List[str]) -> None:
960             if not name:
961                 return
962             name, role = parse_item_name(name)
963             items.append((name, list(rest), role))
964             del rest[:]
965 
966         current_func = None
967         rest = []  # type: List[str]
968 
969         for line in content:
970             if not line.strip():
971                 continue
972 
973             m = self._name_rgx.match(line)
974             if m and line[m.end():].strip().startswith(':'):
975                 push_item(current_func, rest)
976                 current_func, line = line[:m.end()], line[m.end():]
977                 rest = [line.split(':', 1)[1].strip()]
978                 if not rest[0]:
979                     rest = []
980             elif not line.startswith(' '):
981                 push_item(current_func, rest)
982                 current_func = None
983                 if ',' in line:
984                     for func in line.split(','):
985                         if func.strip():
986                             push_item(func, [])
987                 elif line.strip():
988                     current_func = line
989             elif current_func is not None:
990                 rest.append(line.strip())
991         push_item(current_func, rest)
992 
993         if not items:
994             return []
995 
996         roles = {
997             'method': 'meth',
998             'meth': 'meth',
999             'function': 'func',
1000             'func': 'func',
1001             'class': 'class',
1002             'exception': 'exc',
1003             'exc': 'exc',
1004             'object': 'obj',
1005             'obj': 'obj',
1006             'module': 'mod',
1007             'mod': 'mod',
1008             'data': 'data',
1009             'constant': 'const',
1010             'const': 'const',
1011             'attribute': 'attr',
1012             'attr': 'attr'
1013         }
1014         if self._what is None:
1015             func_role = 'obj'
1016         else:
1017             func_role = roles.get(self._what, '')
1018         lines = []  # type: List[str]
1019         last_had_desc = True
1020         for func, desc, role in items:
1021             if role:
1022                 link = ':%s:`%s`' % (role, func)
1023             elif func_role:
1024                 link = ':%s:`%s`' % (func_role, func)
1025             else:
1026                 link = "`%s`_" % func
1027             if desc or last_had_desc:
1028                 lines += ['']
1029                 lines += [link]
1030             else:
1031                 lines[-1] += ", %s" % link
1032             if desc:
1033                 lines += self._indent([' '.join(desc)])
1034                 last_had_desc = True
1035             else:
1036                 last_had_desc = False
1037         lines += ['']
1038 
1039         return self._format_admonition('seealso', lines)

</code><intended_behavior>If this file contributes to the handling of specific docstring styles (e.g., Google or NumPy), the parsing logic here may require adjustments to similarly accommodate and correctly interpret multiple overloaded method signatures within a single docstring. The adjustment would ensure that the Napoleon extension does not overlook additional signatures after the first, aligning with the enhanced behavior in `sphinx/ext/autodoc/__init__.py` to support a comprehensive documentation process for overloaded methods.</intended_behavior>]
2025-10-16 00:45:39.246 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union
20 )
21 
22 from docutils.statemachine import StringList
23 
24 import sphinx
25 from sphinx.application import Sphinx
26 from sphinx.config import Config, ENUM
27 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
28 from sphinx.environment import BuildEnvironment
29 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
30 from sphinx.ext.autodoc.mock import mock
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect
34 from sphinx.util import logging
35 from sphinx.util import split_full_qualified_name
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import getdoc, object_description, safe_getattr, stringify_signature
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43     from sphinx.ext.autodoc.directive import DocumenterBridge
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 
49 # This type isn't exposed directly in any modules, but can be found
50 # here in most Python versions
51 MethodDescriptorType = type(type.__subclasses__)
52 
53 
54 #: extended signature RE: with explicit module name separated by ::
55 py_ext_sig_re = re.compile(
56     r'''^ ([\w.]+::)?            # explicit module name
57           ([\w.]+\.)?            # module and/or class name(s)
58           (\w+)  \s*             # thing name
59           (?: \((.*)\)           # optional: arguments
60            (?:\s* -> \s* (.*))?  #           return annotation
61           )? $                   # and nothing more
62           ''', re.VERBOSE)
63 
64 
65 def identity(x: Any) -> Any:
66     return x
67 
68 
69 ALL = object()
70 UNINITIALIZED_ATTR = object()
71 INSTANCEATTR = object()
72 SLOTSATTR = object()
73 
74 
75 def members_option(arg: Any) -> Union[object, List[str]]:
76     """Used to convert the :members: option to auto directives."""
77     if arg is None or arg is True:
78         return ALL
79     return [x.strip() for x in arg.split(',') if x.strip()]
80 
81 
82 def members_set_option(arg: Any) -> Union[object, Set[str]]:
83     """Used to convert the :members: option to auto directives."""
84     if arg is None:
85         return ALL
86     return {x.strip() for x in arg.split(',') if x.strip()}
87 
88 
89 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
90     """Used to convert the :members: option to auto directives."""
91     if arg is None:
92         return 'object'
93     else:
94         return arg
95 
96 
97 def member_order_option(arg: Any) -> Optional[str]:
98     """Used to convert the :members: option to auto directives."""
99     if arg is None:
100         return None
101     elif arg in ('alphabetical', 'bysource', 'groupwise'):
102         return arg
103     else:
104         raise ValueError(__('invalid value for member-order option: %s') % arg)
105 
106 
107 SUPPRESS = object()
108 
109 
110 def annotation_option(arg: Any) -> Any:
111     if arg is None:
112         # suppress showing the representation of the object
113         return SUPPRESS
114     else:
115         return arg
116 
117 
118 def bool_option(arg: Any) -> bool:
119     """Used to convert flag options to auto directives.  (Instead of
120     directives.flag(), which returns None).
121     """
122     return True
123 
124 
125 def merge_special_members_option(options: Dict) -> None:
126     """Merge :special-members: option to :members: option."""
127     if 'special-members' in options and options['special-members'] is not ALL:
128         if options.get('members') is ALL:
129             pass
130         elif options.get('members'):
131             for member in options['special-members']:
132                 if member not in options['members']:
133                     options['members'].append(member)
134         else:
135             options['members'] = options['special-members']
136 
137 
138 # Some useful event listener factories for autodoc-process-docstring.
139 
140 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
141     """Return a listener that removes the first *pre* and last *post*
142     lines of every docstring.  If *what* is a sequence of strings,
143     only docstrings of a type in *what* will be processed.
144 
145     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
146 
147        from sphinx.ext.autodoc import cut_lines
148        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
149 
150     This can (and should) be used in place of :confval:`automodule_skip_lines`.
151     """
152     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
153                 ) -> None:
154         if what and what_ not in what:
155             return
156         del lines[:pre]
157         if post:
158             # remove one trailing blank line.
159             if lines and not lines[-1]:
160                 lines.pop(-1)
161             del lines[-post:]
162         # make sure there is a blank line at the end
163         if lines and lines[-1]:
164             lines.append('')
165     return process
166 
167 
168 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
169             exclude: bool = False) -> Callable:
170     """Return a listener that either keeps, or if *exclude* is True excludes,
171     lines between lines that match the *marker* regular expression.  If no line
172     matches, the resulting docstring would be empty, so no change will be made
173     unless *keepempty* is true.
174 
175     If *what* is a sequence of strings, only docstrings of a type in *what* will
176     be processed.
177     """
178     marker_re = re.compile(marker)
179 
180     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
181                 ) -> None:
182         if what and what_ not in what:
183             return
184         deleted = 0
185         delete = not exclude
186         orig_lines = lines[:]
187         for i, line in enumerate(orig_lines):
188             if delete:
189                 lines.pop(i - deleted)
190                 deleted += 1
191             if marker_re.match(line):
192                 delete = not delete
193                 if delete:
194                     lines.pop(i - deleted)
195                     deleted += 1
196         if not lines and not keepempty:
197             lines[:] = orig_lines
198         # make sure there is a blank line at the end
199         if lines and lines[-1]:
200             lines.append('')
201     return process
202 
203 
204 # This class is used only in ``sphinx.ext.autodoc.directive``,
205 # But we define this class here to keep compatibility (see #4538)
206 class Options(dict):
207     """A dict/attribute hybrid that returns None on nonexisting keys."""
208     def __getattr__(self, name: str) -> Any:
209         try:
210             return self[name.replace('_', '-')]
211         except KeyError:
212             return None
213 
214 
215 class Documenter:
216     """
217     A Documenter knows how to autodocument a single object type.  When
218     registered with the AutoDirective, it will be used to document objects
219     of that type when needed by autodoc.
220 
221     Its *objtype* attribute selects what auto directive it is assigned to
222     (the directive name is 'auto' + objtype), and what directive it generates
223     by default, though that can be overridden by an attribute called
224     *directivetype*.
225 
226     A Documenter has an *option_spec* that works like a docutils directive's;
227     in fact, it will be used to parse an auto directive's options that matches
228     the documenter.
229     """
230     #: name by which the directive is called (auto...) and the default
231     #: generated directive name
232     objtype = 'object'
233     #: indentation by which to indent the directive content
234     content_indent = '   '
235     #: priority if multiple documenters return True from can_document_member
236     priority = 0
237     #: order if autodoc_member_order is set to 'groupwise'
238     member_order = 0
239     #: true if the generated content may contain titles
240     titles_allowed = False
241 
242     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
243 
244     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
245         """getattr() override for types such as Zope interfaces."""
246         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
247 
248     @classmethod
249     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
250                             ) -> bool:
251         """Called to see if a member can be documented by this documenter."""
252         raise NotImplementedError('must be implemented in subclasses')
253 
254     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
255         self.directive = directive
256         self.env = directive.env    # type: BuildEnvironment
257         self.options = directive.genopt
258         self.name = name
259         self.indent = indent
260         # the module and object path within the module, and the fully
261         # qualified name (all set after resolve_name succeeds)
262         self.modname = None         # type: str
263         self.module = None          # type: ModuleType
264         self.objpath = None         # type: List[str]
265         self.fullname = None        # type: str
266         # extra signature items (arguments and return annotation,
267         # also set after resolve_name succeeds)
268         self.args = None            # type: str
269         self.retann = None          # type: str
270         # the object to document (set after import_object succeeds)
271         self.object = None          # type: Any
272         self.object_name = None     # type: str
273         # the parent/owner of the object to document
274         self.parent = None          # type: Any
275         # the module analyzer to get at attribute docs, or None
276         self.analyzer = None        # type: ModuleAnalyzer
277 
278     @property
279     def documenters(self) -> Dict[str, "Type[Documenter]"]:
280         """Returns registered Documenter classes"""
281         return self.env.app.registry.documenters
282 
283     def add_line(self, line: str, source: str, *lineno: int) -> None:
284         """Append one line of generated reST to the output."""
285         if line.strip():  # not a blank line
286             self.directive.result.append(self.indent + line, source, *lineno)
287         else:
288             self.directive.result.append('', source, *lineno)
289 
290     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
291                      ) -> Tuple[str, List[str]]:
292         """Resolve the module and name of the object to document given by the
293         arguments and the current module/class.
294 
295         Must return a pair of the module name and a chain of attributes; for
296         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
297         ``zipfile.ZipFile.open`` method.
298         """
299         raise NotImplementedError('must be implemented in subclasses')
300 
301     def parse_name(self) -> bool:
302         """Determine what module to import and what attribute to document.
303 
304         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
305         *self.args* and *self.retann* if parsing and resolving was successful.
306         """
307         # first, parse the definition -- auto directives for classes and
308         # functions can contain a signature which is then used instead of
309         # an autogenerated one
310         try:
311             explicit_modname, path, base, args, retann = \
312                 py_ext_sig_re.match(self.name).groups()
313         except AttributeError:
314             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
315                            type='autodoc')
316             return False
317 
318         # support explicit module and class name separation via ::
319         if explicit_modname is not None:
320             modname = explicit_modname[:-2]
321             parents = path.rstrip('.').split('.') if path else []
322         else:
323             modname = None
324             parents = []
325 
326         with mock(self.env.config.autodoc_mock_imports):
327             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
328 
329         if not self.modname:
330             return False
331 
332         self.args = args
333         self.retann = retann
334         self.fullname = (self.modname or '') + \
335                         ('.' + '.'.join(self.objpath) if self.objpath else '')
336         return True
337 
338     def import_object(self) -> bool:
339         """Import the object given by *self.modname* and *self.objpath* and set
340         it as *self.object*.
341 
342         Returns True if successful, False if an error occurred.
343         """
344         with mock(self.env.config.autodoc_mock_imports):
345             try:
346                 ret = import_object(self.modname, self.objpath, self.objtype,
347                                     attrgetter=self.get_attr,
348                                     warningiserror=self.env.config.autodoc_warningiserror)
349                 self.module, self.parent, self.object_name, self.object = ret
350                 return True
351             except ImportError as exc:
352                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
353                 self.env.note_reread()
354                 return False
355 
356     def get_real_modname(self) -> str:
357         """Get the real module name of an object to document.
358 
359         It can differ from the name of the module through which the object was
360         imported.
361         """
362         return self.get_attr(self.object, '__module__', None) or self.modname
363 
364     def check_module(self) -> bool:
365         """Check if *self.object* is really defined in the module given by
366         *self.modname*.
367         """
368         if self.options.imported_members:
369             return True
370 
371         subject = inspect.unpartial(self.object)
372         modname = self.get_attr(subject, '__module__', None)
373         if modname and modname != self.modname:
374             return False
375         return True
376 
377     def format_args(self, **kwargs: Any) -> str:
378         """Format the argument signature of *self.object*.
379 
380         Should return None if the object does not have a signature.
381         """
382         return None
383 
384     def format_name(self) -> str:
385         """Format the name of *self.object*.
386 
387         This normally should be something that can be parsed by the generated
388         directive, but doesn't need to be (Sphinx will display it unparsed
389         then).
390         """
391         # normally the name doesn't contain the module (except for module
392         # directives of course)
393         return '.'.join(self.objpath) or self.modname
394 
395     def _call_format_args(self, **kwargs: Any) -> str:
396         if kwargs:
397             try:
398                 return self.format_args(**kwargs)
399             except TypeError:
400                 # avoid chaining exceptions, by putting nothing here
401                 pass
402 
403         # retry without arguments for old documenters
404         return self.format_args()
405 
406     def format_signature(self, **kwargs: Any) -> str:
407         """Format the signature (arguments and return annotation) of the object.
408 
409         Let the user process it via the ``autodoc-process-signature`` event.
410         """
411         if self.args is not None:
412             # signature given explicitly
413             args = "(%s)" % self.args
414             retann = self.retann
415         else:
416             # try to introspect the signature
417             try:
418                 retann = None
419                 args = self._call_format_args(**kwargs)
420                 if args:
421                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
422                     if matched:
423                         args = matched.group(1)
424                         retann = matched.group(2)
425             except Exception:
426                 logger.warning(__('error while formatting arguments for %s:') %
427                                self.fullname, type='autodoc', exc_info=True)
428                 args = None
429 
430         result = self.env.events.emit_firstresult('autodoc-process-signature',
431                                                   self.objtype, self.fullname,
432                                                   self.object, self.options, args, retann)
433         if result:
434             args, retann = result
435 
436         if args is not None:
437             return args + ((' -> %s' % retann) if retann else '')
438         else:
439             return ''
440 
441     def add_directive_header(self, sig: str) -> None:
442         """Add the directive header and options to the generated content."""
443         domain = getattr(self, 'domain', 'py')
444         directive = getattr(self, 'directivetype', self.objtype)
445         name = self.format_name()
446         sourcename = self.get_sourcename()
447 
448         # one signature per line, indented by column
449         prefix = '.. %s:%s:: ' % (domain, directive)
450         for i, sig_line in enumerate(sig.split("\n")):
451             self.add_line('%s%s%s' % (prefix, name, sig_line),
452                           sourcename)
453             if i == 0:
454                 prefix = " " * len(prefix)
455 
456         if self.options.noindex:
457             self.add_line('   :noindex:', sourcename)
458         if self.objpath:
459             # Be explicit about the module, this is necessary since .. class::
460             # etc. don't support a prepended module name
461             self.add_line('   :module: %s' % self.modname, sourcename)
462 
463     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
464         """Decode and return lines of the docstring(s) for the object."""
465         if encoding is not None:
466             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
467                           % self.__class__.__name__,
468                           RemovedInSphinx40Warning, stacklevel=2)
469         if ignore is not None:
470             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
471                           % self.__class__.__name__,
472                           RemovedInSphinx50Warning, stacklevel=2)
473         docstring = getdoc(self.object, self.get_attr,
474                            self.env.config.autodoc_inherit_docstrings,
475                            self.parent, self.object_name)
476         if docstring:
477             tab_width = self.directive.state.document.settings.tab_width
478             return [prepare_docstring(docstring, ignore, tab_width)]
479         return []
480 
481     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
482         """Let the user process the docstrings before adding them."""
483         for docstringlines in docstrings:
484             if self.env.app:
485                 # let extensions preprocess docstrings
486                 self.env.app.emit('autodoc-process-docstring',
487                                   self.objtype, self.fullname, self.object,
488                                   self.options, docstringlines)
489             yield from docstringlines
490 
491     def get_sourcename(self) -> str:
492         if self.analyzer:
493             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
494         return 'docstring of %s' % self.fullname
495 
496     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
497         """Add content from docstrings, attribute documentation and user."""
498         # set sourcename and add content from attribute documentation
499         sourcename = self.get_sourcename()
500         if self.analyzer:
501             attr_docs = self.analyzer.find_attr_docs()
502             if self.objpath:
503                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
504                 if key in attr_docs:
505                     no_docstring = True
506                     # make a copy of docstring for attributes to avoid cache
507                     # the change of autodoc-process-docstring event.
508                     docstrings = [list(attr_docs[key])]
509 
510                     for i, line in enumerate(self.process_doc(docstrings)):
511                         self.add_line(line, sourcename, i)
512 
513         # add content from docstrings
514         if not no_docstring:
515             docstrings = self.get_doc()
516             if not docstrings:
517                 # append at least a dummy docstring, so that the event
518                 # autodoc-process-docstring is fired and can add some
519                 # content if desired
520                 docstrings.append([])
521             for i, line in enumerate(self.process_doc(docstrings)):
522                 self.add_line(line, sourcename, i)
523 
524         # add additional content (e.g. from document), if present
525         if more_content:
526             for line, src in zip(more_content.data, more_content.items):
527                 self.add_line(line, src[0], src[1])
528 
529     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
530         """Return `(members_check_module, members)` where `members` is a
531         list of `(membername, member)` pairs of the members of *self.object*.
532 
533         If *want_all* is True, return all members.  Else, only return those
534         members given by *self.options.members* (which may also be none).
535         """
536         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
537         if not want_all:
538             if not self.options.members:
539                 return False, []
540             # specific members given
541             selected = []
542             for name in self.options.members:
543                 if name in members:
544                     selected.append((name, members[name].value))
545                 else:
546                     logger.warning(__('missing attribute %s in object %s') %
547                                    (name, self.fullname), type='autodoc')
548             return False, selected
549         elif self.options.inherited_members:
550             return False, [(m.name, m.value) for m in members.values()]
551         else:
552             return False, [(m.name, m.value) for m in members.values()
553                            if m.directly_defined]
554 
555     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
556                        ) -> List[Tuple[str, Any, bool]]:
557         """Filter the given member list.
558 
559         Members are skipped if
560 
561         - they are private (except if given explicitly or the private-members
562           option is set)
563         - they are special methods (except if given explicitly or the
564           special-members option is set)
565         - they are undocumented (except if the undoc-members option is set)
566 
567         The user can override the skipping decision by connecting to the
568         ``autodoc-skip-member`` event.
569         """
570         def is_filtered_inherited_member(name: str) -> bool:
571             if inspect.isclass(self.object):
572                 for cls in self.object.__mro__:
573                     if cls.__name__ == self.options.inherited_members and cls != self.object:
574                         # given member is a member of specified *super class*
575                         return True
576                     elif name in cls.__dict__:
577                         return False
578 
579             return False
580 
581         ret = []
582 
583         # search for members in source code too
584         namespace = '.'.join(self.objpath)  # will be empty for modules
585 
586         if self.analyzer:
587             attr_docs = self.analyzer.find_attr_docs()
588         else:
589             attr_docs = {}
590 
591         # process members and determine which to skip
592         for (membername, member) in members:
593             # if isattr is True, the member is documented as an attribute
594             if member is INSTANCEATTR:
595                 isattr = True
596             else:
597                 isattr = False
598 
599             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
600                          self.parent, self.object_name)
601             if not isinstance(doc, str):
602                 # Ignore non-string __doc__
603                 doc = None
604 
605             # if the member __doc__ is the same as self's __doc__, it's just
606             # inherited and therefore not the member's doc
607             cls = self.get_attr(member, '__class__', None)
608             if cls:
609                 cls_doc = self.get_attr(cls, '__doc__', None)
610                 if cls_doc == doc:
611                     doc = None
612             has_doc = bool(doc)
613 
614             metadata = extract_metadata(doc)
615             if 'private' in metadata:
616                 # consider a member private if docstring has "private" metadata
617                 isprivate = True
618             elif 'public' in metadata:
619                 # consider a member public if docstring has "public" metadata
620                 isprivate = False
621             else:
622                 isprivate = membername.startswith('_')
623 
624             keep = False
625             if safe_getattr(member, '__sphinx_mock__', False):
626                 # mocked module or object
627                 pass
628             elif want_all and membername.startswith('__') and \
629                     membername.endswith('__') and len(membername) > 4:
630                 # special __methods__
631                 if self.options.special_members is ALL:
632                     if membername == '__doc__':
633                         keep = False
634                     elif is_filtered_inherited_member(membername):
635                         keep = False
636                     else:
637                         keep = has_doc or self.options.undoc_members
638                 elif self.options.special_members:
639                     if membername in self.options.special_members:
640                         keep = has_doc or self.options.undoc_members
641             elif (namespace, membername) in attr_docs:
642                 if want_all and isprivate:
643                     # ignore members whose name starts with _ by default
644                     keep = self.options.private_members
645                 else:
646                     # keep documented attributes
647                     keep = True
648                 isattr = True
649             elif want_all and isprivate:
650                 # ignore members whose name starts with _ by default
651                 keep = self.options.private_members and \
652                     (has_doc or self.options.undoc_members)
653             else:
654                 if self.options.members is ALL and is_filtered_inherited_member(membername):
655                     keep = False
656                 else:
657                     # ignore undocumented members if :undoc-members: is not given
658                     keep = has_doc or self.options.undoc_members
659 
660             # give the user a chance to decide whether this member
661             # should be skipped
662             if self.env.app:
663                 # let extensions preprocess docstrings
664                 try:
665                     skip_user = self.env.app.emit_firstresult(
666                         'autodoc-skip-member', self.objtype, membername, member,
667                         not keep, self.options)
668                     if skip_user is not None:
669                         keep = not skip_user
670                 except Exception as exc:
671                     logger.warning(__('autodoc: failed to determine %r to be documented, '
672                                       'the following exception was raised:\n%s'),
673                                    member, exc, type='autodoc')
674                     keep = False
675 
676             if keep:
677                 ret.append((membername, member, isattr))
678 
679         return ret
680 
681     def document_members(self, all_members: bool = False) -> None:
682         """Generate reST for member documentation.
683 
684         If *all_members* is True, do all members, else those given by
685         *self.options.members*.
686         """
687         # set current namespace for finding members
688         self.env.temp_data['autodoc:module'] = self.modname
689         if self.objpath:
690             self.env.temp_data['autodoc:class'] = self.objpath[0]
691 
692         want_all = all_members or self.options.inherited_members or \
693             self.options.members is ALL
694         # find out which members are documentable
695         members_check_module, members = self.get_object_members(want_all)
696 
697         # remove members given by exclude-members
698         if self.options.exclude_members:
699             members = [
700                 (membername, member) for (membername, member) in members
701                 if (
702                     self.options.exclude_members is ALL or
703                     membername not in self.options.exclude_members
704                 )
705             ]
706 
707         # document non-skipped members
708         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
709         for (mname, member, isattr) in self.filter_members(members, want_all):
710             classes = [cls for cls in self.documenters.values()
711                        if cls.can_document_member(member, mname, isattr, self)]
712             if not classes:
713                 # don't know how to document this member
714                 continue
715             # prefer the documenter with the highest priority
716             classes.sort(key=lambda cls: cls.priority)
717             # give explicitly separated module name, so that members
718             # of inner classes can be documented
719             full_mname = self.modname + '::' + \
720                 '.'.join(self.objpath + [mname])
721             documenter = classes[-1](self.directive, full_mname, self.indent)
722             memberdocumenters.append((documenter, isattr))
723 
724         member_order = self.options.member_order or self.env.config.autodoc_member_order
725         memberdocumenters = self.sort_members(memberdocumenters, member_order)
726 
727         for documenter, isattr in memberdocumenters:
728             documenter.generate(
729                 all_members=True, real_modname=self.real_modname,
730                 check_module=members_check_module and not isattr)
731 
732         # reset current objects
733         self.env.temp_data['autodoc:module'] = None
734         self.env.temp_data['autodoc:class'] = None
735 
736     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
737                      order: str) -> List[Tuple["Documenter", bool]]:
738         """Sort the given member list."""
739         if order == 'groupwise':
740             # sort by group; alphabetically within groups
741             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
742         elif order == 'bysource':
743             if self.analyzer:
744                 # sort by source order, by virtue of the module analyzer
745                 tagorder = self.analyzer.tagorder
746 
747                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
748                     fullname = entry[0].name.split('::')[1]
749                     return tagorder.get(fullname, len(tagorder))
750                 documenters.sort(key=keyfunc)
751             else:
752                 # Assume that member discovery order matches source order.
753                 # This is a reasonable assumption in Python 3.6 and up, where
754                 # module.__dict__ is insertion-ordered.
755                 pass
756         else:  # alphabetical
757             documenters.sort(key=lambda e: e[0].name)
758 
759         return documenters
760 
761     def generate(self, more_content: Any = None, real_modname: str = None,
762                  check_module: bool = False, all_members: bool = False) -> None:
763         """Generate reST for the object given by *self.name*, and possibly for
764         its members.
765 
766         If *more_content* is given, include that content. If *real_modname* is
767         given, use that module name to find attribute docs. If *check_module* is
768         True, only generate if the object is defined in the module name it is
769         imported from. If *all_members* is True, document all members.
770         """
771         if not self.parse_name():
772             # need a module to import
773             logger.warning(
774                 __('don\'t know which module to import for autodocumenting '
775                    '%r (try placing a "module" or "currentmodule" directive '
776                    'in the document, or giving an explicit module name)') %
777                 self.name, type='autodoc')
778             return
779 
780         # now, import the module and get object to document
781         if not self.import_object():
782             return
783 
784         # If there is no real module defined, figure out which to use.
785         # The real module is used in the module analyzer to look up the module
786         # where the attribute documentation would actually be found in.
787         # This is used for situations where you have a module that collects the
788         # functions and classes of internal submodules.
789         guess_modname = self.get_real_modname()
790         self.real_modname = real_modname or guess_modname
791 
792         # try to also get a source code analyzer for attribute docs
793         try:
794             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
795             # parse right now, to get PycodeErrors on parsing (results will
796             # be cached anyway)
797             self.analyzer.find_attr_docs()
798         except PycodeError:
799             logger.debug('[autodoc] module analyzer failed:', exc_info=True)
800             # no source file -- e.g. for builtin and C modules
801             self.analyzer = None
802             # at least add the module.__file__ as a dependency
803             if hasattr(self.module, '__file__') and self.module.__file__:
804                 self.directive.filename_set.add(self.module.__file__)
805         else:
806             self.directive.filename_set.add(self.analyzer.srcname)
807 
808         if self.real_modname != guess_modname:
809             # Add module to dependency list if target object is defined in other module.
810             try:
811                 analyzer = ModuleAnalyzer.for_module(guess_modname)
812                 self.directive.filename_set.add(analyzer.srcname)
813             except PycodeError:
814                 pass
815 
816         # check __module__ of object (for members not given explicitly)
817         if check_module:
818             if not self.check_module():
819                 return
820 
821         sourcename = self.get_sourcename()
822 
823         # make sure that the result starts with an empty line.  This is
824         # necessary for some situations where another directive preprocesses
825         # reST and no starting newline is present
826         self.add_line('', sourcename)
827 
828         # format the object's signature, if any
829         sig = self.format_signature()
830 
831         # generate the directive header and options, if applicable
832         self.add_directive_header(sig)
833         self.add_line('', sourcename)
834 
835         # e.g. the module directive doesn't have content
836         self.indent += self.content_indent
837 
838         # add all content (from docstrings, attribute docs etc.)
839         self.add_content(more_content)
840 
841         # document members, if possible
842         self.document_members(all_members)
843 
844 
845 class ModuleDocumenter(Documenter):
846     """
847     Specialized Documenter subclass for modules.
848     """
849     objtype = 'module'
850     content_indent = ''
851     titles_allowed = True
852 
853     option_spec = {
854         'members': members_option, 'undoc-members': bool_option,
855         'noindex': bool_option, 'inherited-members': inherited_members_option,
856         'show-inheritance': bool_option, 'synopsis': identity,
857         'platform': identity, 'deprecated': bool_option,
858         'member-order': member_order_option, 'exclude-members': members_set_option,
859         'private-members': bool_option, 'special-members': members_option,
860         'imported-members': bool_option, 'ignore-module-all': bool_option
861     }  # type: Dict[str, Callable]
862 
863     def __init__(self, *args: Any) -> None:
864         super().__init__(*args)
865         merge_special_members_option(self.options)
866         self.__all__ = None
867 
868     @classmethod
869     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
870                             ) -> bool:
871         # don't document submodules automatically
872         return False
873 
874     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
875                      ) -> Tuple[str, List[str]]:
876         if modname is not None:
877             logger.warning(__('"::" in automodule name doesn\'t make sense'),
878                            type='autodoc')
879         return (path or '') + base, []
880 
881     def parse_name(self) -> bool:
882         ret = super().parse_name()
883         if self.args or self.retann:
884             logger.warning(__('signature arguments or return annotation '
885                               'given for automodule %s') % self.fullname,
886                            type='autodoc')
887         return ret
888 
889     def import_object(self) -> Any:
890         def is_valid_module_all(__all__: Any) -> bool:
891             """Check the given *__all__* is valid for a module."""
892             if (isinstance(__all__, (list, tuple)) and
893                     all(isinstance(e, str) for e in __all__)):
894                 return True
895             else:
896                 return False
897 
898         ret = super().import_object()
899 
900         if not self.options.ignore_module_all:
901             __all__ = getattr(self.object, '__all__', None)
902             if is_valid_module_all(__all__):
903                 # valid __all__ found. copy it to self.__all__
904                 self.__all__ = __all__
905             elif __all__:
906                 # invalid __all__ found.
907                 logger.warning(__('__all__ should be a list of strings, not %r '
908                                   '(in module %s) -- ignoring __all__') %
909                                (__all__, self.fullname), type='autodoc')
910 
911         return ret
912 
913     def add_directive_header(self, sig: str) -> None:
914         Documenter.add_directive_header(self, sig)
915 
916         sourcename = self.get_sourcename()
917 
918         # add some module-specific options
919         if self.options.synopsis:
920             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
921         if self.options.platform:
922             self.add_line('   :platform: ' + self.options.platform, sourcename)
923         if self.options.deprecated:
924             self.add_line('   :deprecated:', sourcename)
925 
926     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
927         if want_all:
928             if self.__all__:
929                 memberlist = self.__all__
930             else:
931                 # for implicit module members, check __module__ to avoid
932                 # documenting imported objects
933                 return True, get_module_members(self.object)
934         else:
935             memberlist = self.options.members or []
936         ret = []
937         for mname in memberlist:
938             try:
939                 ret.append((mname, safe_getattr(self.object, mname)))
940             except AttributeError:
941                 logger.warning(
942                     __('missing attribute mentioned in :members: or __all__: '
943                        'module %s, attribute %s') %
944                     (safe_getattr(self.object, '__name__', '???'), mname),
945                     type='autodoc'
946                 )
947         return False, ret
948 
949     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
950                      order: str) -> List[Tuple["Documenter", bool]]:
951         if order == 'bysource' and self.__all__:
952             # Sort alphabetically first (for members not listed on the __all__)
953             documenters.sort(key=lambda e: e[0].name)
954 
955             # Sort by __all__
956             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
957                 name = entry[0].name.split('::')[1]
958                 if name in self.__all__:
959                     return self.__all__.index(name)
960                 else:
961                     return len(self.__all__)
962             documenters.sort(key=keyfunc)
963 
964             return documenters
965         else:
966             return super().sort_members(documenters, order)
967 
968 
969 class ModuleLevelDocumenter(Documenter):
970     """
971     Specialized Documenter subclass for objects on module level (functions,
972     classes, data/constants).
973     """
974     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
975                      ) -> Tuple[str, List[str]]:
976         if modname is None:
977             if path:
978                 stripped = path.rstrip('.')
979                 modname, qualname = split_full_qualified_name(stripped)
980                 if qualname:
981                     parents = qualname.split(".")
982                 else:
983                     parents = []
984 
985             if modname is None:
986                 # if documenting a toplevel object without explicit module,
987                 # it can be contained in another auto directive ...
988                 modname = self.env.temp_data.get('autodoc:module')
989                 # ... or in the scope of a module directive
990                 if not modname:
991                     modname = self.env.ref_context.get('py:module')
992                 # ... else, it stays None, which means invalid
993         return modname, parents + [base]
994 
995 
996 class ClassLevelDocumenter(Documenter):
997     """
998     Specialized Documenter subclass for objects on class level (methods,
999     attributes).
1000     """
1001     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1002                      ) -> Tuple[str, List[str]]:
1003         if modname is None:
1004             if path:
1005                 mod_cls = path.rstrip('.')
1006             else:
1007                 mod_cls = None
1008                 # if documenting a class-level object without path,
1009                 # there must be a current class, either from a parent
1010                 # auto directive ...
1011                 mod_cls = self.env.temp_data.get('autodoc:class')
1012                 # ... or from a class directive
1013                 if mod_cls is None:
1014                     mod_cls = self.env.ref_context.get('py:class')
1015                 # ... if still None, there's no way to know
1016                 if mod_cls is None:
1017                     return None, []
1018 
1019             try:
1020                 modname, qualname = split_full_qualified_name(mod_cls)
1021                 parents = qualname.split(".") if qualname else []
1022             except ImportError:
1023                 parents = mod_cls.split(".")
1024 
1025             # if the module name is still missing, get it like above
1026             if not modname:
1027                 modname = self.env.temp_data.get('autodoc:module')
1028             if not modname:
1029                 modname = self.env.ref_context.get('py:module')
1030             # ... else, it stays None, which means invalid
1031         return modname, parents + [base]
1032 
1033 
1034 class DocstringSignatureMixin:
1035     """
1036     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1037     feature of reading the signature from the docstring.
1038     """
1039 
1040     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1041         if encoding is not None:
1042             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1043                           "deprecated." % self.__class__.__name__,
1044                           RemovedInSphinx40Warning, stacklevel=2)
1045         docstrings = self.get_doc()
1046         self._new_docstrings = docstrings[:]
1047         result = None
1048         for i, doclines in enumerate(docstrings):
1049             # no lines in docstring, no match
1050             if not doclines:
1051                 continue
1052             # match first line of docstring against signature RE
1053             match = py_ext_sig_re.match(doclines[0])
1054             if not match:
1055                 continue
1056             exmod, path, base, args, retann = match.groups()
1057             # the base name must match ours
1058             valid_names = [self.objpath[-1]]  # type: ignore
1059             if isinstance(self, ClassDocumenter):
1060                 valid_names.append('__init__')
1061                 if hasattr(self.object, '__mro__'):
1062                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1063             if base not in valid_names:
1064                 continue
1065             # re-prepare docstring to ignore more leading indentation
1066             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1067             self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
1068                                                         tabsize=tab_width)
1069             result = args, retann
1070             # don't look any further
1071             break
1072         return result
1073 
1074     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1075         if encoding is not None:
1076             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1077                           % self.__class__.__name__,
1078                           RemovedInSphinx40Warning, stacklevel=2)
1079         lines = getattr(self, '_new_docstrings', None)
1080         if lines is not None:
1081             return lines
1082         return super().get_doc(None, ignore)  # type: ignore
1083 
1084     def format_signature(self, **kwargs: Any) -> str:
1085         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1086             # only act if a signature is not explicitly given already, and if
1087             # the feature is enabled
1088             result = self._find_signature()
1089             if result is not None:
1090                 self.args, self.retann = result
1091         return super().format_signature(**kwargs)  # type: ignore
1092 
1093 
1094 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1095     """
1096     Mixin for AttributeDocumenter to provide the
1097     feature of stripping any function signature from the docstring.
1098     """
1099     def format_signature(self, **kwargs: Any) -> str:
1100         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1101             # only act if a signature is not explicitly given already, and if
1102             # the feature is enabled
1103             result = self._find_signature()
1104             if result is not None:
1105                 # Discarding _args is a only difference with
1106                 # DocstringSignatureMixin.format_signature.
1107                 # Documenter.format_signature use self.args value to format.
1108                 _args, self.retann = result
1109         return super().format_signature(**kwargs)
1110 
1111 
1112 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1113     """
1114     Specialized Documenter subclass for functions.
1115     """
1116     objtype = 'function'
1117     member_order = 30
1118 
1119     @classmethod
1120     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1121                             ) -> bool:
1122         # supports functions, builtins and bound methods exported at the module level
1123         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1124                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1125 
1126     def format_args(self, **kwargs: Any) -> str:
1127         if self.env.config.autodoc_typehints in ('none', 'description'):
1128             kwargs.setdefault('show_annotation', False)
1129 
1130         try:
1131             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1132             if inspect.is_singledispatch_function(self.object):
1133                 sig = inspect.signature(self.object, follow_wrapped=True)
1134             else:
1135                 sig = inspect.signature(self.object)
1136             args = stringify_signature(sig, **kwargs)
1137         except TypeError as exc:
1138             logger.warning(__("Failed to get a function signature for %s: %s"),
1139                            self.fullname, exc)
1140             return None
1141         except ValueError:
1142             args = ''
1143 
1144         if self.env.config.strip_signature_backslash:
1145             # escape backslashes for reST
1146             args = args.replace('\\', '\\\\')
1147         return args
1148 
1149     def document_members(self, all_members: bool = False) -> None:
1150         pass
1151 
1152     def add_directive_header(self, sig: str) -> None:
1153         sourcename = self.get_sourcename()
1154         super().add_directive_header(sig)
1155 
1156         if inspect.iscoroutinefunction(self.object):
1157             self.add_line('   :async:', sourcename)
1158 
1159     def format_signature(self, **kwargs: Any) -> str:
1160         sig = super().format_signature(**kwargs)
1161         sigs = [sig]
1162 
1163         if inspect.is_singledispatch_function(self.object):
1164             # append signature of singledispatch'ed functions
1165             for typ, func in self.object.registry.items():
1166                 if typ is object:
1167                     pass  # default implementation. skipped.
1168                 else:
1169                     self.annotate_to_first_argument(func, typ)
1170 
1171                     documenter = FunctionDocumenter(self.directive, '')
1172                     documenter.object = func
1173                     sigs.append(documenter.format_signature())
1174 
1175         return "\n".join(sigs)
1176 
1177     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1178         """Annotate type hint to the first argument of function if needed."""
1179         sig = inspect.signature(func)
1180         if len(sig.parameters) == 0:
1181             return
1182 
1183         params = list(sig.parameters.values())
1184         if params[0].annotation is Parameter.empty:
1185             params[0] = params[0].replace(annotation=typ)
1186             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1187 
1188 
1189 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1190     """
1191     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1192 
1193     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1194     """
1195 
1196 
1197 class DecoratorDocumenter(FunctionDocumenter):
1198     """
1199     Specialized Documenter subclass for decorator functions.
1200     """
1201     objtype = 'decorator'
1202 
1203     # must be lower than FunctionDocumenter
1204     priority = -1
1205 
1206     def format_args(self, **kwargs: Any) -> Any:
1207         args = super().format_args(**kwargs)
1208         if ',' in args:
1209             return args
1210         else:
1211             return None
1212 
1213 
1214 # Types which have confusing metaclass signatures it would be best not to show.
1215 # These are listed by name, rather than storing the objects themselves, to avoid
1216 # needing to import the modules.
1217 _METACLASS_CALL_BLACKLIST = [
1218     'enum.EnumMeta.__call__',
1219 ]
1220 
1221 
1222 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1223     """
1224     Specialized Documenter subclass for classes.
1225     """
1226     objtype = 'class'
1227     member_order = 20
1228     option_spec = {
1229         'members': members_option, 'undoc-members': bool_option,
1230         'noindex': bool_option, 'inherited-members': inherited_members_option,
1231         'show-inheritance': bool_option, 'member-order': member_order_option,
1232         'exclude-members': members_set_option,
1233         'private-members': bool_option, 'special-members': members_option,
1234     }  # type: Dict[str, Callable]
1235 
1236     def __init__(self, *args: Any) -> None:
1237         super().__init__(*args)
1238         merge_special_members_option(self.options)
1239 
1240     @classmethod
1241     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1242                             ) -> bool:
1243         return isinstance(member, type)
1244 
1245     def import_object(self) -> Any:
1246         ret = super().import_object()
1247         # if the class is documented under another name, document it
1248         # as data/attribute
1249         if ret:
1250             if hasattr(self.object, '__name__'):
1251                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1252             else:
1253                 self.doc_as_attr = True
1254         return ret
1255 
1256     def _get_signature(self) -> Optional[Signature]:
1257         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1258             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1259             if inspect.is_builtin_class_method(obj, attr):
1260                 return None
1261             attr = self.get_attr(obj, attr, None)
1262             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1263                 return None
1264             return attr
1265 
1266         # This sequence is copied from inspect._signature_from_callable.
1267         # ValueError means that no signature could be found, so we keep going.
1268 
1269         # First, let's see if it has an overloaded __call__ defined
1270         # in its metaclass
1271         call = get_user_defined_function_or_method(type(self.object), '__call__')
1272 
1273         if call is not None:
1274             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1275                 call = None
1276 
1277         if call is not None:
1278             self.env.app.emit('autodoc-before-process-signature', call, True)
1279             try:
1280                 return inspect.signature(call, bound_method=True)
1281             except ValueError:
1282                 pass
1283 
1284         # Now we check if the 'obj' class has a '__new__' method
1285         new = get_user_defined_function_or_method(self.object, '__new__')
1286         if new is not None:
1287             self.env.app.emit('autodoc-before-process-signature', new, True)
1288             try:
1289                 return inspect.signature(new, bound_method=True)
1290             except ValueError:
1291                 pass
1292 
1293         # Finally, we should have at least __init__ implemented
1294         init = get_user_defined_function_or_method(self.object, '__init__')
1295         if init is not None:
1296             self.env.app.emit('autodoc-before-process-signature', init, True)
1297             try:
1298                 return inspect.signature(init, bound_method=True)
1299             except ValueError:
1300                 pass
1301 
1302         # None of the attributes are user-defined, so fall back to let inspect
1303         # handle it.
1304         # We don't know the exact method that inspect.signature will read
1305         # the signature from, so just pass the object itself to our hook.
1306         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1307         try:
1308             return inspect.signature(self.object, bound_method=False)
1309         except ValueError:
1310             pass
1311 
1312         # Still no signature: happens e.g. for old-style classes
1313         # with __init__ in C and no `__text_signature__`.
1314         return None
1315 
1316     def format_args(self, **kwargs: Any) -> str:
1317         if self.env.config.autodoc_typehints in ('none', 'description'):
1318             kwargs.setdefault('show_annotation', False)
1319 
1320         try:
1321             sig = self._get_signature()
1322         except TypeError as exc:
1323             # __signature__ attribute contained junk
1324             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1325                            self.fullname, exc)
1326             return None
1327 
1328         if sig is None:
1329             return None
1330 
1331         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1332 
1333     def format_signature(self, **kwargs: Any) -> str:
1334         if self.doc_as_attr:
1335             return ''
1336 
1337         return super().format_signature(**kwargs)
1338 
1339     def add_directive_header(self, sig: str) -> None:
1340         sourcename = self.get_sourcename()
1341 
1342         if self.doc_as_attr:
1343             self.directivetype = 'attribute'
1344         super().add_directive_header(sig)
1345 
1346         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1347             self.add_line('   :final:', sourcename)
1348 
1349         # add inheritance info, if wanted
1350         if not self.doc_as_attr and self.options.show_inheritance:
1351             sourcename = self.get_sourcename()
1352             self.add_line('', sourcename)
1353             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1354                 bases = [':class:`%s`' % b.__name__
1355                          if b.__module__ in ('__builtin__', 'builtins')
1356                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1357                          for b in self.object.__bases__]
1358                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1359                               sourcename)
1360 
1361     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1362         if encoding is not None:
1363             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1364                           % self.__class__.__name__,
1365                           RemovedInSphinx40Warning, stacklevel=2)
1366         lines = getattr(self, '_new_docstrings', None)
1367         if lines is not None:
1368             return lines
1369 
1370         content = self.env.config.autoclass_content
1371 
1372         docstrings = []
1373         attrdocstring = self.get_attr(self.object, '__doc__', None)
1374         if attrdocstring:
1375             docstrings.append(attrdocstring)
1376 
1377         # for classes, what the "docstring" is can be controlled via a
1378         # config value; the default is only the class docstring
1379         if content in ('both', 'init'):
1380             __init__ = self.get_attr(self.object, '__init__', None)
1381             initdocstring = getdoc(__init__, self.get_attr,
1382                                    self.env.config.autodoc_inherit_docstrings,
1383                                    self.parent, self.object_name)
1384             # for new-style classes, no __init__ means default __init__
1385             if (initdocstring is not None and
1386                 (initdocstring == object.__init__.__doc__ or  # for pypy
1387                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1388                 initdocstring = None
1389             if not initdocstring:
1390                 # try __new__
1391                 __new__ = self.get_attr(self.object, '__new__', None)
1392                 initdocstring = getdoc(__new__, self.get_attr,
1393                                        self.env.config.autodoc_inherit_docstrings,
1394                                        self.parent, self.object_name)
1395                 # for new-style classes, no __new__ means default __new__
1396                 if (initdocstring is not None and
1397                     (initdocstring == object.__new__.__doc__ or  # for pypy
1398                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1399                     initdocstring = None
1400             if initdocstring:
1401                 if content == 'init':
1402                     docstrings = [initdocstring]
1403                 else:
1404                     docstrings.append(initdocstring)
1405 
1406         tab_width = self.directive.state.document.settings.tab_width
1407         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1408 
1409     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1410         if self.doc_as_attr:
1411             classname = safe_getattr(self.object, '__qualname__', None)
1412             if not classname:
1413                 classname = safe_getattr(self.object, '__name__', None)
1414             if classname:
1415                 module = safe_getattr(self.object, '__module__', None)
1416                 parentmodule = safe_getattr(self.parent, '__module__', None)
1417                 if module and module != parentmodule:
1418                     classname = str(module) + '.' + str(classname)
1419                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1420                 super().add_content(content, no_docstring=True)
1421         else:
1422             super().add_content(more_content)
1423 
1424     def document_members(self, all_members: bool = False) -> None:
1425         if self.doc_as_attr:
1426             return
1427         super().document_members(all_members)
1428 
1429     def generate(self, more_content: Any = None, real_modname: str = None,
1430                  check_module: bool = False, all_members: bool = False) -> None:
1431         # Do not pass real_modname and use the name from the __module__
1432         # attribute of the class.
1433         # If a class gets imported into the module real_modname
1434         # the analyzer won't find the source of the class, if
1435         # it looks in real_modname.
1436         return super().generate(more_content=more_content,
1437                                 check_module=check_module,
1438                                 all_members=all_members)
1439 
1440 
1441 class ExceptionDocumenter(ClassDocumenter):
1442     """
1443     Specialized ClassDocumenter subclass for exceptions.
1444     """
1445     objtype = 'exception'
1446     member_order = 10
1447 
1448     # needs a higher priority than ClassDocumenter
1449     priority = 10
1450 
1451     @classmethod
1452     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1453                             ) -> bool:
1454         return isinstance(member, type) and issubclass(member, BaseException)
1455 
1456 
1457 class DataDocumenter(ModuleLevelDocumenter):
1458     """
1459     Specialized Documenter subclass for data items.
1460     """
1461     objtype = 'data'
1462     member_order = 40
1463     priority = -10
1464     option_spec = dict(ModuleLevelDocumenter.option_spec)
1465     option_spec["annotation"] = annotation_option
1466 
1467     @classmethod
1468     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1469                             ) -> bool:
1470         return isinstance(parent, ModuleDocumenter) and isattr
1471 
1472     def add_directive_header(self, sig: str) -> None:
1473         super().add_directive_header(sig)
1474         sourcename = self.get_sourcename()
1475         if not self.options.annotation:
1476             # obtain annotation for this data
1477             annotations = getattr(self.parent, '__annotations__', {})
1478             if annotations and self.objpath[-1] in annotations:
1479                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1480                 self.add_line('   :type: ' + objrepr, sourcename)
1481             else:
1482                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1483                 if self.analyzer and key in self.analyzer.annotations:
1484                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1485                                   sourcename)
1486 
1487             try:
1488                 if self.object is UNINITIALIZED_ATTR:
1489                     pass
1490                 else:
1491                     objrepr = object_description(self.object)
1492                     self.add_line('   :value: ' + objrepr, sourcename)
1493             except ValueError:
1494                 pass
1495         elif self.options.annotation is SUPPRESS:
1496             pass
1497         else:
1498             self.add_line('   :annotation: %s' % self.options.annotation,
1499                           sourcename)
1500 
1501     def document_members(self, all_members: bool = False) -> None:
1502         pass
1503 
1504     def get_real_modname(self) -> str:
1505         return self.get_attr(self.parent or self.object, '__module__', None) \
1506             or self.modname
1507 
1508 
1509 class DataDeclarationDocumenter(DataDocumenter):
1510     """
1511     Specialized Documenter subclass for data that cannot be imported
1512     because they are declared without initial value (refs: PEP-526).
1513     """
1514     objtype = 'datadecl'
1515     directivetype = 'data'
1516     member_order = 60
1517 
1518     # must be higher than AttributeDocumenter
1519     priority = 11
1520 
1521     @classmethod
1522     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1523                             ) -> bool:
1524         """This documents only INSTANCEATTR members."""
1525         return (isinstance(parent, ModuleDocumenter) and
1526                 isattr and
1527                 member is INSTANCEATTR)
1528 
1529     def import_object(self) -> bool:
1530         """Never import anything."""
1531         # disguise as a data
1532         self.objtype = 'data'
1533         self.object = UNINITIALIZED_ATTR
1534         try:
1535             # import module to obtain type annotation
1536             self.parent = importlib.import_module(self.modname)
1537         except ImportError:
1538             pass
1539 
1540         return True
1541 
1542     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1543         """Never try to get a docstring from the object."""
1544         super().add_content(more_content, no_docstring=True)
1545 
1546 
1547 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1548     """
1549     Specialized Documenter subclass for methods (normal, static and class).
1550     """
1551     objtype = 'method'
1552     directivetype = 'method'
1553     member_order = 50
1554     priority = 1  # must be more than FunctionDocumenter
1555 
1556     @classmethod
1557     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1558                             ) -> bool:
1559         return inspect.isroutine(member) and \
1560             not isinstance(parent, ModuleDocumenter)
1561 
1562     def import_object(self) -> Any:
1563         ret = super().import_object()
1564         if not ret:
1565             return ret
1566 
1567         # to distinguish classmethod/staticmethod
1568         obj = self.parent.__dict__.get(self.object_name)
1569         if obj is None:
1570             obj = self.object
1571 
1572         if (inspect.isclassmethod(obj) or
1573                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1574             # document class and static members before ordinary ones
1575             self.member_order = self.member_order - 1
1576 
1577         return ret
1578 
1579     def format_args(self, **kwargs: Any) -> str:
1580         if self.env.config.autodoc_typehints in ('none', 'description'):
1581             kwargs.setdefault('show_annotation', False)
1582 
1583         try:
1584             if self.object == object.__init__ and self.parent != object:
1585                 # Classes not having own __init__() method are shown as no arguments.
1586                 #
1587                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1588                 #       But it makes users confused.
1589                 args = '()'
1590             else:
1591                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1592                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1593                     sig = inspect.signature(self.object, bound_method=False)
1594                 else:
1595                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1596 
1597                     meth = self.parent.__dict__.get(self.objpath[-1], None)
1598                     if meth and inspect.is_singledispatch_method(meth):
1599                         sig = inspect.signature(self.object, bound_method=True,
1600                                                 follow_wrapped=True)
1601                     else:
1602                         sig = inspect.signature(self.object, bound_method=True)
1603                 args = stringify_signature(sig, **kwargs)
1604         except TypeError as exc:
1605             logger.warning(__("Failed to get a method signature for %s: %s"),
1606                            self.fullname, exc)
1607             return None
1608         except ValueError:
1609             args = ''
1610 
1611         if self.env.config.strip_signature_backslash:
1612             # escape backslashes for reST
1613             args = args.replace('\\', '\\\\')
1614         return args
1615 
1616     def add_directive_header(self, sig: str) -> None:
1617         super().add_directive_header(sig)
1618 
1619         sourcename = self.get_sourcename()
1620         obj = self.parent.__dict__.get(self.object_name, self.object)
1621         if inspect.isabstractmethod(obj):
1622             self.add_line('   :abstractmethod:', sourcename)
1623         if inspect.iscoroutinefunction(obj):
1624             self.add_line('   :async:', sourcename)
1625         if inspect.isclassmethod(obj):
1626             self.add_line('   :classmethod:', sourcename)
1627         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1628             self.add_line('   :staticmethod:', sourcename)
1629         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1630             self.add_line('   :final:', sourcename)
1631 
1632     def document_members(self, all_members: bool = False) -> None:
1633         pass
1634 
1635     def format_signature(self, **kwargs: Any) -> str:
1636         sig = super().format_signature(**kwargs)
1637         sigs = [sig]
1638 
1639         meth = self.parent.__dict__.get(self.objpath[-1])
1640         if inspect.is_singledispatch_method(meth):
1641             # append signature of singledispatch'ed functions
1642             for typ, func in meth.dispatcher.registry.items():
1643                 if typ is object:
1644                     pass  # default implementation. skipped.
1645                 else:
1646                     self.annotate_to_first_argument(func, typ)
1647 
1648                     documenter = MethodDocumenter(self.directive, '')
1649                     documenter.parent = self.parent
1650                     documenter.object = func
1651                     documenter.objpath = [None]
1652                     sigs.append(documenter.format_signature())
1653 
1654         return "\n".join(sigs)
1655 
1656     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1657         """Annotate type hint to the first argument of function if needed."""
1658         sig = inspect.signature(func)
1659         if len(sig.parameters) == 1:
1660             return
1661 
1662         params = list(sig.parameters.values())
1663         if params[1].annotation is Parameter.empty:
1664             params[1] = params[1].replace(annotation=typ)
1665             func.__signature__ = sig.replace(parameters=params)  # type: ignore
1666 
1667 
1668 class SingledispatchMethodDocumenter(MethodDocumenter):
1669     """
1670     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1671 
1672     Retained for backwards compatibility, now does the same as the MethodDocumenter
1673     """
1674 
1675 
1676 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1677     """
1678     Specialized Documenter subclass for attributes.
1679     """
1680     objtype = 'attribute'
1681     member_order = 60
1682     option_spec = dict(ModuleLevelDocumenter.option_spec)
1683     option_spec["annotation"] = annotation_option
1684 
1685     # must be higher than the MethodDocumenter, else it will recognize
1686     # some non-data descriptors as methods
1687     priority = 10
1688 
1689     @staticmethod
1690     def is_function_or_method(obj: Any) -> bool:
1691         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1692 
1693     @classmethod
1694     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1695                             ) -> bool:
1696         if inspect.isattributedescriptor(member):
1697             return True
1698         elif (not isinstance(parent, ModuleDocumenter) and
1699               not inspect.isroutine(member) and
1700               not isinstance(member, type)):
1701             return True
1702         else:
1703             return False
1704 
1705     def document_members(self, all_members: bool = False) -> None:
1706         pass
1707 
1708     def import_object(self) -> Any:
1709         ret = super().import_object()
1710         if inspect.isenumattribute(self.object):
1711             self.object = self.object.value
1712         if inspect.isattributedescriptor(self.object):
1713             self._datadescriptor = True
1714         else:
1715             # if it's not a data descriptor
1716             self._datadescriptor = False
1717         return ret
1718 
1719     def get_real_modname(self) -> str:
1720         return self.get_attr(self.parent or self.object, '__module__', None) \
1721             or self.modname
1722 
1723     def add_directive_header(self, sig: str) -> None:
1724         super().add_directive_header(sig)
1725         sourcename = self.get_sourcename()
1726         if not self.options.annotation:
1727             # obtain type annotation for this attribute
1728             annotations = getattr(self.parent, '__annotations__', {})
1729             if annotations and self.objpath[-1] in annotations:
1730                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1731                 self.add_line('   :type: ' + objrepr, sourcename)
1732             else:
1733                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1734                 if self.analyzer and key in self.analyzer.annotations:
1735                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1736                                   sourcename)
1737 
1738             # data descriptors do not have useful values
1739             if not self._datadescriptor:
1740                 try:
1741                     if self.object is INSTANCEATTR:
1742                         pass
1743                     else:
1744                         objrepr = object_description(self.object)
1745                         self.add_line('   :value: ' + objrepr, sourcename)
1746                 except ValueError:
1747                     pass
1748         elif self.options.annotation is SUPPRESS:
1749             pass
1750         else:
1751             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
1752 
1753     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1754         if not self._datadescriptor:
1755             # if it's not a data descriptor, its docstring is very probably the
1756             # wrong thing to display
1757             no_docstring = True
1758         super().add_content(more_content, no_docstring)
1759 
1760 
1761 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1762     """
1763     Specialized Documenter subclass for properties.
1764     """
1765     objtype = 'property'
1766     directivetype = 'method'
1767     member_order = 60
1768 
1769     # before AttributeDocumenter
1770     priority = AttributeDocumenter.priority + 1
1771 
1772     @classmethod
1773     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1774                             ) -> bool:
1775         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
1776 
1777     def document_members(self, all_members: bool = False) -> None:
1778         pass
1779 
1780     def get_real_modname(self) -> str:
1781         return self.get_attr(self.parent or self.object, '__module__', None) \
1782             or self.modname
1783 
1784     def add_directive_header(self, sig: str) -> None:
1785         super().add_directive_header(sig)
1786         sourcename = self.get_sourcename()
1787         if inspect.isabstractmethod(self.object):
1788             self.add_line('   :abstractmethod:', sourcename)
1789         self.add_line('   :property:', sourcename)
1790 
1791 
1792 class InstanceAttributeDocumenter(AttributeDocumenter):
1793     """
1794     Specialized Documenter subclass for attributes that cannot be imported
1795     because they are instance attributes (e.g. assigned in __init__).
1796     """
1797     objtype = 'instanceattribute'
1798     directivetype = 'attribute'
1799     member_order = 60
1800 
1801     # must be higher than AttributeDocumenter
1802     priority = 11
1803 
1804     @classmethod
1805     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1806                             ) -> bool:
1807         """This documents only INSTANCEATTR members."""
1808         return (not isinstance(parent, ModuleDocumenter) and
1809                 isattr and
1810                 member is INSTANCEATTR)
1811 
1812     def import_object(self) -> bool:
1813         """Never import anything."""
1814         # disguise as an attribute
1815         self.objtype = 'attribute'
1816         self.object = INSTANCEATTR
1817         self._datadescriptor = False
1818         return True
1819 
1820     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1821         """Never try to get a docstring from the object."""
1822         super().add_content(more_content, no_docstring=True)
1823 
1824 
1825 class SlotsAttributeDocumenter(AttributeDocumenter):
1826     """
1827     Specialized Documenter subclass for attributes that cannot be imported
1828     because they are attributes in __slots__.
1829     """
1830     objtype = 'slotsattribute'
1831     directivetype = 'attribute'
1832     member_order = 60
1833 
1834     # must be higher than AttributeDocumenter
1835     priority = 11
1836 
1837     @classmethod
1838     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1839                             ) -> bool:
1840         """This documents only SLOTSATTR members."""
1841         return member is SLOTSATTR
1842 
1843     def import_object(self) -> Any:
1844         """Never import anything."""
1845         # disguise as an attribute
1846         self.objtype = 'attribute'
1847         self._datadescriptor = True
1848 
1849         with mock(self.env.config.autodoc_mock_imports):
1850             try:
1851                 ret = import_object(self.modname, self.objpath[:-1], 'class',
1852                                     attrgetter=self.get_attr,
1853                                     warningiserror=self.env.config.autodoc_warningiserror)
1854                 self.module, _, _, self.parent = ret
1855                 return True
1856             except ImportError as exc:
1857                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1858                 self.env.note_reread()
1859                 return False
1860 
1861     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1862         """Decode and return lines of the docstring(s) for the object."""
1863         if ignore is not None:
1864             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1865                           % self.__class__.__name__,
1866                           RemovedInSphinx50Warning, stacklevel=2)
1867         name = self.objpath[-1]
1868         __slots__ = safe_getattr(self.parent, '__slots__', [])
1869         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
1870             docstring = prepare_docstring(__slots__[name])
1871             return [docstring]
1872         else:
1873             return []
1874 
1875 
1876 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
1877     """Returns registered Documenter classes"""
1878     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
1879     return app.registry.documenters
1880 
1881 
1882 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
1883     """Alternative getattr() for types"""
1884     for typ, func in app.registry.autodoc_attrgettrs.items():
1885         if isinstance(obj, typ):
1886             return func(obj, name, *defargs)
1887 
1888     return safe_getattr(obj, name, *defargs)
1889 
1890 
1891 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
1892     if config.autodoc_member_order == 'alphabetic':
1893         # RemovedInSphinx50Warning
1894         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
1895                           'instead of "alphabetic". Please update your setting.'))
1896         config.autodoc_member_order = 'alphabetical'  # type: ignore
1897 
1898 
1899 def setup(app: Sphinx) -> Dict[str, Any]:
1900     app.add_autodocumenter(ModuleDocumenter)
1901     app.add_autodocumenter(ClassDocumenter)
1902     app.add_autodocumenter(ExceptionDocumenter)
1903     app.add_autodocumenter(DataDocumenter)
1904     app.add_autodocumenter(DataDeclarationDocumenter)
1905     app.add_autodocumenter(FunctionDocumenter)
1906     app.add_autodocumenter(DecoratorDocumenter)
1907     app.add_autodocumenter(MethodDocumenter)
1908     app.add_autodocumenter(AttributeDocumenter)
1909     app.add_autodocumenter(PropertyDocumenter)
1910     app.add_autodocumenter(InstanceAttributeDocumenter)
1911     app.add_autodocumenter(SlotsAttributeDocumenter)
1912 
1913     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
1914     app.add_config_value('autodoc_member_order', 'alphabetical', True,
1915                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
1916     app.add_config_value('autodoc_default_options', {}, True)
1917     app.add_config_value('autodoc_docstring_signature', True, True)
1918     app.add_config_value('autodoc_mock_imports', [], True)
1919     app.add_config_value('autodoc_typehints', "signature", True,
1920                          ENUM("signature", "description", "none"))
1921     app.add_config_value('autodoc_warningiserror', True, True)
1922     app.add_config_value('autodoc_inherit_docstrings', True, True)
1923     app.add_event('autodoc-before-process-signature')
1924     app.add_event('autodoc-process-docstring')
1925     app.add_event('autodoc-process-signature')
1926     app.add_event('autodoc-skip-member')
1927 
1928     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
1929 
1930     app.setup_extension('sphinx.ext.autodoc.type_comment')
1931     app.setup_extension('sphinx.ext.autodoc.typehints')
1932 
1933     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>Modify the logic that parses method signatures from docstrings to iteratively capture all signatures present for overloaded methods. The modified code should ensure that each overloaded method signature is identified, parsed, and included in the generated documentation, rather than only recognizing the first signature. This enhancement should preserve the existing functionality of handling single-method docstrings while extending support for overloaded method signatures.</intended_behavior>, <file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import inspect
14 import re
15 from functools import partial
16 from typing import Any, Callable, Dict, List, Tuple, Union
17 
18 from sphinx.application import Sphinx
19 from sphinx.config import Config as SphinxConfig
20 from sphinx.ext.napoleon.iterators import modify_iter
21 from sphinx.locale import _
22 
23 if False:
24     # For type annotation
25     from typing import Type  # for python3.5.1
26 
27 
28 _directive_regex = re.compile(r'\.\. \S+::')
29 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
30 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
31 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
32 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
33 _xref_or_code_regex = re.compile(
34     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
35     r'(?:``.+``))')
36 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
37 _enumerated_list_regex = re.compile(
38     r'^(?P<paren>\()?'
39     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
40     r'(?(paren)\)|\.)(\s+\S|\s*$)')
41 
42 
43 class GoogleDocstring:
44     """Convert Google style docstrings to reStructuredText.
45 
46     Parameters
47     ----------
48     docstring : :obj:`str` or :obj:`list` of :obj:`str`
49         The docstring to parse, given either as a string or split into
50         individual lines.
51     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
52         The configuration settings to use. If not given, defaults to the
53         config object on `app`; or if `app` is not given defaults to the
54         a new :class:`sphinx.ext.napoleon.Config` object.
55 
56 
57     Other Parameters
58     ----------------
59     app : :class:`sphinx.application.Sphinx`, optional
60         Application object representing the Sphinx process.
61     what : :obj:`str`, optional
62         A string specifying the type of the object to which the docstring
63         belongs. Valid values: "module", "class", "exception", "function",
64         "method", "attribute".
65     name : :obj:`str`, optional
66         The fully qualified name of the object.
67     obj : module, class, exception, function, method, or attribute
68         The object to which the docstring belongs.
69     options : :class:`sphinx.ext.autodoc.Options`, optional
70         The options given to the directive: an object with attributes
71         inherited_members, undoc_members, show_inheritance and noindex that
72         are True if the flag option of same name was given to the auto
73         directive.
74 
75 
76     Example
77     -------
78     >>> from sphinx.ext.napoleon import Config
79     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
80     >>> docstring = '''One line summary.
81     ...
82     ... Extended description.
83     ...
84     ... Args:
85     ...   arg1(int): Description of `arg1`
86     ...   arg2(str): Description of `arg2`
87     ... Returns:
88     ...   str: Description of return value.
89     ... '''
90     >>> print(GoogleDocstring(docstring, config))
91     One line summary.
92     <BLANKLINE>
93     Extended description.
94     <BLANKLINE>
95     :param arg1: Description of `arg1`
96     :type arg1: int
97     :param arg2: Description of `arg2`
98     :type arg2: str
99     <BLANKLINE>
100     :returns: Description of return value.
101     :rtype: str
102     <BLANKLINE>
103 
104     """
105 
106     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
107                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
108 
109     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
110                  app: Sphinx = None, what: str = '', name: str = '',
111                  obj: Any = None, options: Any = None) -> None:
112         self._config = config
113         self._app = app
114 
115         if not self._config:
116             from sphinx.ext.napoleon import Config
117             self._config = self._app.config if self._app else Config()  # type: ignore
118 
119         if not what:
120             if inspect.isclass(obj):
121                 what = 'class'
122             elif inspect.ismodule(obj):
123                 what = 'module'
124             elif callable(obj):
125                 what = 'function'
126             else:
127                 what = 'object'
128 
129         self._what = what
130         self._name = name
131         self._obj = obj
132         self._opt = options
133         if isinstance(docstring, str):
134             lines = docstring.splitlines()
135         else:
136             lines = docstring
137         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
138         self._parsed_lines = []  # type: List[str]
139         self._is_in_section = False
140         self._section_indent = 0
141         if not hasattr(self, '_directive_sections'):
142             self._directive_sections = []  # type: List[str]
143         if not hasattr(self, '_sections'):
144             self._sections = {
145                 'args': self._parse_parameters_section,
146                 'arguments': self._parse_parameters_section,
147                 'attention': partial(self._parse_admonition, 'attention'),
148                 'attributes': self._parse_attributes_section,
149                 'caution': partial(self._parse_admonition, 'caution'),
150                 'danger': partial(self._parse_admonition, 'danger'),
151                 'error': partial(self._parse_admonition, 'error'),
152                 'example': self._parse_examples_section,
153                 'examples': self._parse_examples_section,
154                 'hint': partial(self._parse_admonition, 'hint'),
155                 'important': partial(self._parse_admonition, 'important'),
156                 'keyword args': self._parse_keyword_arguments_section,
157                 'keyword arguments': self._parse_keyword_arguments_section,
158                 'methods': self._parse_methods_section,
159                 'note': partial(self._parse_admonition, 'note'),
160                 'notes': self._parse_notes_section,
161                 'other parameters': self._parse_other_parameters_section,
162                 'parameters': self._parse_parameters_section,
163                 'return': self._parse_returns_section,
164                 'returns': self._parse_returns_section,
165                 'raises': self._parse_raises_section,
166                 'references': self._parse_references_section,
167                 'see also': self._parse_see_also_section,
168                 'tip': partial(self._parse_admonition, 'tip'),
169                 'todo': partial(self._parse_admonition, 'todo'),
170                 'warning': partial(self._parse_admonition, 'warning'),
171                 'warnings': partial(self._parse_admonition, 'warning'),
172                 'warns': self._parse_warns_section,
173                 'yield': self._parse_yields_section,
174                 'yields': self._parse_yields_section,
175             }  # type: Dict[str, Callable]
176 
177         self._load_custom_sections()
178 
179         self._parse()
180 
181     def __str__(self) -> str:
182         """Return the parsed docstring in reStructuredText format.
183 
184         Returns
185         -------
186         unicode
187             Unicode version of the docstring.
188 
189         """
190         return '\n'.join(self.lines())
191 
192     def lines(self) -> List[str]:
193         """Return the parsed lines of the docstring in reStructuredText format.
194 
195         Returns
196         -------
197         list(str)
198             The lines of the docstring in a list.
199 
200         """
201         return self._parsed_lines
202 
203     def _consume_indented_block(self, indent: int = 1) -> List[str]:
204         lines = []
205         line = self._line_iter.peek()
206         while(not self._is_section_break() and
207               (not line or self._is_indented(line, indent))):
208             lines.append(next(self._line_iter))
209             line = self._line_iter.peek()
210         return lines
211 
212     def _consume_contiguous(self) -> List[str]:
213         lines = []
214         while (self._line_iter.has_next() and
215                self._line_iter.peek() and
216                not self._is_section_header()):
217             lines.append(next(self._line_iter))
218         return lines
219 
220     def _consume_empty(self) -> List[str]:
221         lines = []
222         line = self._line_iter.peek()
223         while self._line_iter.has_next() and not line:
224             lines.append(next(self._line_iter))
225             line = self._line_iter.peek()
226         return lines
227 
228     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
229                        ) -> Tuple[str, str, List[str]]:
230         line = next(self._line_iter)
231 
232         before, colon, after = self._partition_field_on_colon(line)
233         _name, _type, _desc = before, '', after
234 
235         if parse_type:
236             match = _google_typed_arg_regex.match(before)
237             if match:
238                 _name = match.group(1)
239                 _type = match.group(2)
240 
241         _name = self._escape_args_and_kwargs(_name)
242 
243         if prefer_type and not _type:
244             _type, _name = _name, _type
245         indent = self._get_indent(line) + 1
246         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
247         _descs = self.__class__(_descs, self._config).lines()
248         return _name, _type, _descs
249 
250     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False
251                         ) -> List[Tuple[str, str, List[str]]]:
252         self._consume_empty()
253         fields = []
254         while not self._is_section_break():
255             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
256             if _name or _type or _desc:
257                 fields.append((_name, _type, _desc,))
258         return fields
259 
260     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
261         line = next(self._line_iter)
262         _type, colon, _desc = self._partition_field_on_colon(line)
263         if not colon or not _desc:
264             _type, _desc = _desc, _type
265             _desc += colon
266         _descs = [_desc] + self._dedent(self._consume_to_end())
267         _descs = self.__class__(_descs, self._config).lines()
268         return _type, _descs
269 
270     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
271         lines = self._dedent(self._consume_to_next_section())
272         if lines:
273             before, colon, after = self._partition_field_on_colon(lines[0])
274             _name, _type, _desc = '', '', lines
275 
276             if colon:
277                 if after:
278                     _desc = [after] + lines[1:]
279                 else:
280                     _desc = lines[1:]
281 
282                 _type = before
283 
284             _desc = self.__class__(_desc, self._config).lines()
285             return [(_name, _type, _desc,)]
286         else:
287             return []
288 
289     def _consume_usage_section(self) -> List[str]:
290         lines = self._dedent(self._consume_to_next_section())
291         return lines
292 
293     def _consume_section_header(self) -> str:
294         section = next(self._line_iter)
295         stripped_section = section.strip(':')
296         if stripped_section.lower() in self._sections:
297             section = stripped_section
298         return section
299 
300     def _consume_to_end(self) -> List[str]:
301         lines = []
302         while self._line_iter.has_next():
303             lines.append(next(self._line_iter))
304         return lines
305 
306     def _consume_to_next_section(self) -> List[str]:
307         self._consume_empty()
308         lines = []
309         while not self._is_section_break():
310             lines.append(next(self._line_iter))
311         return lines + self._consume_empty()
312 
313     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
314         if full:
315             return [line.lstrip() for line in lines]
316         else:
317             min_indent = self._get_min_indent(lines)
318             return [line[min_indent:] for line in lines]
319 
320     def _escape_args_and_kwargs(self, name: str) -> str:
321         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):
322             name = name[:-1] + r'\_'
323 
324         if name[:2] == '**':
325             return r'\*\*' + name[2:]
326         elif name[:1] == '*':
327             return r'\*' + name[1:]
328         else:
329             return name
330 
331     def _fix_field_desc(self, desc: List[str]) -> List[str]:
332         if self._is_list(desc):
333             desc = [''] + desc
334         elif desc[0].endswith('::'):
335             desc_block = desc[1:]
336             indent = self._get_indent(desc[0])
337             block_indent = self._get_initial_indent(desc_block)
338             if block_indent > indent:
339                 desc = [''] + desc
340             else:
341                 desc = ['', desc[0]] + self._indent(desc_block, 4)
342         return desc
343 
344     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
345         lines = self._strip_empty(lines)
346         if len(lines) == 1:
347             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
348         elif lines:
349             lines = self._indent(self._dedent(lines), 3)
350             return ['.. %s::' % admonition, ''] + lines + ['']
351         else:
352             return ['.. %s::' % admonition, '']
353 
354     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
355         if lines:
356             if padding is None:
357                 padding = ' ' * len(prefix)
358             result_lines = []
359             for i, line in enumerate(lines):
360                 if i == 0:
361                     result_lines.append((prefix + line).rstrip())
362                 elif line:
363                     result_lines.append(padding + line)
364                 else:
365                     result_lines.append('')
366             return result_lines
367         else:
368             return [prefix]
369 
370     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
371                                 field_role: str = 'param', type_role: str = 'type'
372                                 ) -> List[str]:
373         lines = []
374         for _name, _type, _desc in fields:
375             _desc = self._strip_empty(_desc)
376             if any(_desc):
377                 _desc = self._fix_field_desc(_desc)
378                 field = ':%s %s: ' % (field_role, _name)
379                 lines.extend(self._format_block(field, _desc))
380             else:
381                 lines.append(':%s %s:' % (field_role, _name))
382 
383             if _type:
384                 lines.append(':%s %s: %s' % (type_role, _name, _type))
385         return lines + ['']
386 
387     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
388         _desc = self._strip_empty(_desc)
389         has_desc = any(_desc)
390         separator = ' -- ' if has_desc else ''
391         if _name:
392             if _type:
393                 if '`' in _type:
394                     field = '**%s** (%s)%s' % (_name, _type, separator)
395                 else:
396                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
397             else:
398                 field = '**%s**%s' % (_name, separator)
399         elif _type:
400             if '`' in _type:
401                 field = '%s%s' % (_type, separator)
402             else:
403                 field = '*%s*%s' % (_type, separator)
404         else:
405             field = ''
406 
407         if has_desc:
408             _desc = self._fix_field_desc(_desc)
409             if _desc[0]:
410                 return [field + _desc[0]] + _desc[1:]
411             else:
412                 return [field] + _desc
413         else:
414             return [field]
415 
416     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
417                        ) -> List[str]:
418         field_type = ':%s:' % field_type.strip()
419         padding = ' ' * len(field_type)
420         multi = len(fields) > 1
421         lines = []  # type: List[str]
422         for _name, _type, _desc in fields:
423             field = self._format_field(_name, _type, _desc)
424             if multi:
425                 if lines:
426                     lines.extend(self._format_block(padding + ' * ', field))
427                 else:
428                     lines.extend(self._format_block(field_type + ' * ', field))
429             else:
430                 lines.extend(self._format_block(field_type + ' ', field))
431         if lines and lines[-1]:
432             lines.append('')
433         return lines
434 
435     def _get_current_indent(self, peek_ahead: int = 0) -> int:
436         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
437         while line != self._line_iter.sentinel:
438             if line:
439                 return self._get_indent(line)
440             peek_ahead += 1
441             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
442         return 0
443 
444     def _get_indent(self, line: str) -> int:
445         for i, s in enumerate(line):
446             if not s.isspace():
447                 return i
448         return len(line)
449 
450     def _get_initial_indent(self, lines: List[str]) -> int:
451         for line in lines:
452             if line:
453                 return self._get_indent(line)
454         return 0
455 
456     def _get_min_indent(self, lines: List[str]) -> int:
457         min_indent = None
458         for line in lines:
459             if line:
460                 indent = self._get_indent(line)
461                 if min_indent is None:
462                     min_indent = indent
463                 elif indent < min_indent:
464                     min_indent = indent
465         return min_indent or 0
466 
467     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
468         return [(' ' * n) + line for line in lines]
469 
470     def _is_indented(self, line: str, indent: int = 1) -> bool:
471         for i, s in enumerate(line):
472             if i >= indent:
473                 return True
474             elif not s.isspace():
475                 return False
476         return False
477 
478     def _is_list(self, lines: List[str]) -> bool:
479         if not lines:
480             return False
481         if _bullet_list_regex.match(lines[0]):
482             return True
483         if _enumerated_list_regex.match(lines[0]):
484             return True
485         if len(lines) < 2 or lines[0].endswith('::'):
486             return False
487         indent = self._get_indent(lines[0])
488         next_indent = indent
489         for line in lines[1:]:
490             if line:
491                 next_indent = self._get_indent(line)
492                 break
493         return next_indent > indent
494 
495     def _is_section_header(self) -> bool:
496         section = self._line_iter.peek().lower()
497         match = _google_section_regex.match(section)
498         if match and section.strip(':') in self._sections:
499             header_indent = self._get_indent(section)
500             section_indent = self._get_current_indent(peek_ahead=1)
501             return section_indent > header_indent
502         elif self._directive_sections:
503             if _directive_regex.match(section):
504                 for directive_section in self._directive_sections:
505                     if section.startswith(directive_section):
506                         return True
507         return False
508 
509     def _is_section_break(self) -> bool:
510         line = self._line_iter.peek()
511         return (not self._line_iter.has_next() or
512                 self._is_section_header() or
513                 (self._is_in_section and
514                     line and
515                     not self._is_indented(line, self._section_indent)))
516 
517     def _load_custom_sections(self) -> None:
518         if self._config.napoleon_custom_sections is not None:
519             for entry in self._config.napoleon_custom_sections:
520                 if isinstance(entry, str):
521                     # if entry is just a label, add to sections list,
522                     # using generic section logic.
523                     self._sections[entry.lower()] = self._parse_custom_generic_section
524                 else:
525                     # otherwise, assume entry is container;
526                     # [0] is new section, [1] is the section to alias.
527                     # in the case of key mismatch, just handle as generic section.
528                     self._sections[entry[0].lower()] = \
529                         self._sections.get(entry[1].lower(),
530                                            self._parse_custom_generic_section)
531 
532     def _parse(self) -> None:
533         self._parsed_lines = self._consume_empty()
534 
535         if self._name and self._what in ('attribute', 'data', 'property'):
536             # Implicit stop using StopIteration no longer allowed in
537             # Python 3.7; see PEP 479
538             res = []  # type: List[str]
539             try:
540                 res = self._parse_attribute_docstring()
541             except StopIteration:
542                 pass
543             self._parsed_lines.extend(res)
544             return
545 
546         while self._line_iter.has_next():
547             if self._is_section_header():
548                 try:
549                     section = self._consume_section_header()
550                     self._is_in_section = True
551                     self._section_indent = self._get_current_indent()
552                     if _directive_regex.match(section):
553                         lines = [section] + self._consume_to_next_section()
554                     else:
555                         lines = self._sections[section.lower()](section)
556                 finally:
557                     self._is_in_section = False
558                     self._section_indent = 0
559             else:
560                 if not self._parsed_lines:
561                     lines = self._consume_contiguous() + self._consume_empty()
562                 else:
563                     lines = self._consume_to_next_section()
564             self._parsed_lines.extend(lines)
565 
566     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
567         # type (str, str) -> List[str]
568         lines = self._consume_to_next_section()
569         return self._format_admonition(admonition, lines)
570 
571     def _parse_attribute_docstring(self) -> List[str]:
572         _type, _desc = self._consume_inline_attribute()
573         lines = self._format_field('', '', _desc)
574         if _type:
575             lines.extend(['', ':type: %s' % _type])
576         return lines
577 
578     def _parse_attributes_section(self, section: str) -> List[str]:
579         lines = []
580         for _name, _type, _desc in self._consume_fields():
581             if self._config.napoleon_use_ivar:
582                 _name = self._qualify_name(_name, self._obj)
583                 field = ':ivar %s: ' % _name
584                 lines.extend(self._format_block(field, _desc))
585                 if _type:
586                     lines.append(':vartype %s: %s' % (_name, _type))
587             else:
588                 lines.append('.. attribute:: ' + _name)
589                 if self._opt and 'noindex' in self._opt:
590                     lines.append('   :noindex:')
591                 if _type:
592                     lines.extend(self._indent([':type: %s' % _type], 3))
593                 lines.append('')
594 
595                 fields = self._format_field('', '', _desc)
596                 lines.extend(self._indent(fields, 3))
597                 lines.append('')
598         if self._config.napoleon_use_ivar:
599             lines.append('')
600         return lines
601 
602     def _parse_examples_section(self, section: str) -> List[str]:
603         labels = {
604             'example': _('Example'),
605             'examples': _('Examples'),
606         }
607         use_admonition = self._config.napoleon_use_admonition_for_examples
608         label = labels.get(section.lower(), section)
609         return self._parse_generic_section(label, use_admonition)
610 
611     def _parse_custom_generic_section(self, section: str) -> List[str]:
612         # for now, no admonition for simple custom sections
613         return self._parse_generic_section(section, False)
614 
615     def _parse_usage_section(self, section: str) -> List[str]:
616         header = ['.. rubric:: Usage:', '']
617         block = ['.. code-block:: python', '']
618         lines = self._consume_usage_section()
619         lines = self._indent(lines, 3)
620         return header + block + lines + ['']
621 
622     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
623         lines = self._strip_empty(self._consume_to_next_section())
624         lines = self._dedent(lines)
625         if use_admonition:
626             header = '.. admonition:: %s' % section
627             lines = self._indent(lines, 3)
628         else:
629             header = '.. rubric:: %s' % section
630         if lines:
631             return [header, ''] + lines + ['']
632         else:
633             return [header, '']
634 
635     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
636         fields = self._consume_fields()
637         if self._config.napoleon_use_keyword:
638             return self._format_docutils_params(
639                 fields,
640                 field_role="keyword",
641                 type_role="kwtype")
642         else:
643             return self._format_fields(_('Keyword Arguments'), fields)
644 
645     def _parse_methods_section(self, section: str) -> List[str]:
646         lines = []  # type: List[str]
647         for _name, _type, _desc in self._consume_fields(parse_type=False):
648             lines.append('.. method:: %s' % _name)
649             if self._opt and 'noindex' in self._opt:
650                 lines.append('   :noindex:')
651             if _desc:
652                 lines.extend([''] + self._indent(_desc, 3))
653             lines.append('')
654         return lines
655 
656     def _parse_notes_section(self, section: str) -> List[str]:
657         use_admonition = self._config.napoleon_use_admonition_for_notes
658         return self._parse_generic_section(_('Notes'), use_admonition)
659 
660     def _parse_other_parameters_section(self, section: str) -> List[str]:
661         return self._format_fields(_('Other Parameters'), self._consume_fields())
662 
663     def _parse_parameters_section(self, section: str) -> List[str]:
664         fields = self._consume_fields()
665         if self._config.napoleon_use_param:
666             return self._format_docutils_params(fields)
667         else:
668             return self._format_fields(_('Parameters'), fields)
669 
670     def _parse_raises_section(self, section: str) -> List[str]:
671         fields = self._consume_fields(parse_type=False, prefer_type=True)
672         lines = []  # type: List[str]
673         for _name, _type, _desc in fields:
674             m = self._name_rgx.match(_type)
675             if m and m.group('name'):
676                 _type = m.group('name')
677             _type = ' ' + _type if _type else ''
678             _desc = self._strip_empty(_desc)
679             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
680             lines.append(':raises%s:%s' % (_type, _descs))
681         if lines:
682             lines.append('')
683         return lines
684 
685     def _parse_references_section(self, section: str) -> List[str]:
686         use_admonition = self._config.napoleon_use_admonition_for_references
687         return self._parse_generic_section(_('References'), use_admonition)
688 
689     def _parse_returns_section(self, section: str) -> List[str]:
690         fields = self._consume_returns_section()
691         multi = len(fields) > 1
692         if multi:
693             use_rtype = False
694         else:
695             use_rtype = self._config.napoleon_use_rtype
696 
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             if use_rtype:
700                 field = self._format_field(_name, '', _desc)
701             else:
702                 field = self._format_field(_name, _type, _desc)
703 
704             if multi:
705                 if lines:
706                     lines.extend(self._format_block('          * ', field))
707                 else:
708                     lines.extend(self._format_block(':returns: * ', field))
709             else:
710                 lines.extend(self._format_block(':returns: ', field))
711                 if _type and use_rtype:
712                     lines.extend([':rtype: %s' % _type, ''])
713         if lines and lines[-1]:
714             lines.append('')
715         return lines
716 
717     def _parse_see_also_section(self, section: str) -> List[str]:
718         return self._parse_admonition('seealso', section)
719 
720     def _parse_warns_section(self, section: str) -> List[str]:
721         return self._format_fields(_('Warns'), self._consume_fields())
722 
723     def _parse_yields_section(self, section: str) -> List[str]:
724         fields = self._consume_returns_section()
725         return self._format_fields(_('Yields'), fields)
726 
727     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
728         before_colon = []
729         after_colon = []
730         colon = ''
731         found_colon = False
732         for i, source in enumerate(_xref_or_code_regex.split(line)):
733             if found_colon:
734                 after_colon.append(source)
735             else:
736                 m = _single_colon_regex.search(source)
737                 if (i % 2) == 0 and m:
738                     found_colon = True
739                     colon = source[m.start(): m.end()]
740                     before_colon.append(source[:m.start()])
741                     after_colon.append(source[m.end():])
742                 else:
743                     before_colon.append(source)
744 
745         return ("".join(before_colon).strip(),
746                 colon,
747                 "".join(after_colon).strip())
748 
749     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
750         if klass and '.' not in attr_name:
751             if attr_name.startswith('~'):
752                 attr_name = attr_name[1:]
753             try:
754                 q = klass.__qualname__
755             except AttributeError:
756                 q = klass.__name__
757             return '~%s.%s' % (q, attr_name)
758         return attr_name
759 
760     def _strip_empty(self, lines: List[str]) -> List[str]:
761         if lines:
762             start = -1
763             for i, line in enumerate(lines):
764                 if line:
765                     start = i
766                     break
767             if start == -1:
768                 lines = []
769             end = -1
770             for i in reversed(range(len(lines))):
771                 line = lines[i]
772                 if line:
773                     end = i
774                     break
775             if start > 0 or end + 1 < len(lines):
776                 lines = lines[start:end + 1]
777         return lines
778 
779 
780 class NumpyDocstring(GoogleDocstring):
781     """Convert NumPy style docstrings to reStructuredText.
782 
783     Parameters
784     ----------
785     docstring : :obj:`str` or :obj:`list` of :obj:`str`
786         The docstring to parse, given either as a string or split into
787         individual lines.
788     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
789         The configuration settings to use. If not given, defaults to the
790         config object on `app`; or if `app` is not given defaults to the
791         a new :class:`sphinx.ext.napoleon.Config` object.
792 
793 
794     Other Parameters
795     ----------------
796     app : :class:`sphinx.application.Sphinx`, optional
797         Application object representing the Sphinx process.
798     what : :obj:`str`, optional
799         A string specifying the type of the object to which the docstring
800         belongs. Valid values: "module", "class", "exception", "function",
801         "method", "attribute".
802     name : :obj:`str`, optional
803         The fully qualified name of the object.
804     obj : module, class, exception, function, method, or attribute
805         The object to which the docstring belongs.
806     options : :class:`sphinx.ext.autodoc.Options`, optional
807         The options given to the directive: an object with attributes
808         inherited_members, undoc_members, show_inheritance and noindex that
809         are True if the flag option of same name was given to the auto
810         directive.
811 
812 
813     Example
814     -------
815     >>> from sphinx.ext.napoleon import Config
816     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
817     >>> docstring = '''One line summary.
818     ...
819     ... Extended description.
820     ...
821     ... Parameters
822     ... ----------
823     ... arg1 : int
824     ...     Description of `arg1`
825     ... arg2 : str
826     ...     Description of `arg2`
827     ... Returns
828     ... -------
829     ... str
830     ...     Description of return value.
831     ... '''
832     >>> print(NumpyDocstring(docstring, config))
833     One line summary.
834     <BLANKLINE>
835     Extended description.
836     <BLANKLINE>
837     :param arg1: Description of `arg1`
838     :type arg1: int
839     :param arg2: Description of `arg2`
840     :type arg2: str
841     <BLANKLINE>
842     :returns: Description of return value.
843     :rtype: str
844     <BLANKLINE>
845 
846     Methods
847     -------
848     __str__()
849         Return the parsed docstring in reStructuredText format.
850 
851         Returns
852         -------
853         str
854             UTF-8 encoded version of the docstring.
855 
856     __unicode__()
857         Return the parsed docstring in reStructuredText format.
858 
859         Returns
860         -------
861         unicode
862             Unicode version of the docstring.
863 
864     lines()
865         Return the parsed lines of the docstring in reStructuredText format.
866 
867         Returns
868         -------
869         list(str)
870             The lines of the docstring in a list.
871 
872     """
873     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
874                  app: Sphinx = None, what: str = '', name: str = '',
875                  obj: Any = None, options: Any = None) -> None:
876         self._directive_sections = ['.. index::']
877         super().__init__(docstring, config, app, what, name, obj, options)
878 
879     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
880                        ) -> Tuple[str, str, List[str]]:
881         line = next(self._line_iter)
882         if parse_type:
883             _name, _, _type = self._partition_field_on_colon(line)
884         else:
885             _name, _type = line, ''
886         _name, _type = _name.strip(), _type.strip()
887         _name = self._escape_args_and_kwargs(_name)
888 
889         if prefer_type and not _type:
890             _type, _name = _name, _type
891         indent = self._get_indent(line) + 1
892         _desc = self._dedent(self._consume_indented_block(indent))
893         _desc = self.__class__(_desc, self._config).lines()
894         return _name, _type, _desc
895 
896     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
897         return self._consume_fields(prefer_type=True)
898 
899     def _consume_section_header(self) -> str:
900         section = next(self._line_iter)
901         if not _directive_regex.match(section):
902             # Consume the header underline
903             next(self._line_iter)
904         return section
905 
906     def _is_section_break(self) -> bool:
907         line1, line2 = self._line_iter.peek(2)
908         return (not self._line_iter.has_next() or
909                 self._is_section_header() or
910                 ['', ''] == [line1, line2] or
911                 (self._is_in_section and
912                     line1 and
913                     not self._is_indented(line1, self._section_indent)))
914 
915     def _is_section_header(self) -> bool:
916         section, underline = self._line_iter.peek(2)
917         section = section.lower()
918         if section in self._sections and isinstance(underline, str):
919             return bool(_numpy_section_regex.match(underline))
920         elif self._directive_sections:
921             if _directive_regex.match(section):
922                 for directive_section in self._directive_sections:
923                     if section.startswith(directive_section):
924                         return True
925         return False
926 
927     def _parse_see_also_section(self, section: str) -> List[str]:
928         lines = self._consume_to_next_section()
929         try:
930             return self._parse_numpydoc_see_also_section(lines)
931         except ValueError:
932             return self._format_admonition('seealso', lines)
933 
934     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
935         """
936         Derived from the NumpyDoc implementation of _parse_see_also.
937 
938         See Also
939         --------
940         func_name : Descriptive text
941             continued text
942         another_func_name : Descriptive text
943         func_name1, func_name2, :meth:`func_name`, func_name3
944 
945         """
946         items = []
947 
948         def parse_item_name(text: str) -> Tuple[str, str]:
949             """Match ':role:`name`' or 'name'"""
950             m = self._name_rgx.match(text)
951             if m:
952                 g = m.groups()
953                 if g[1] is None:
954                     return g[3], None
955                 else:
956                     return g[2], g[1]
957             raise ValueError("%s is not a item name" % text)
958 
959         def push_item(name: str, rest: List[str]) -> None:
960             if not name:
961                 return
962             name, role = parse_item_name(name)
963             items.append((name, list(rest), role))
964             del rest[:]
965 
966         current_func = None
967         rest = []  # type: List[str]
968 
969         for line in content:
970             if not line.strip():
971                 continue
972 
973             m = self._name_rgx.match(line)
974             if m and line[m.end():].strip().startswith(':'):
975                 push_item(current_func, rest)
976                 current_func, line = line[:m.end()], line[m.end():]
977                 rest = [line.split(':', 1)[1].strip()]
978                 if not rest[0]:
979                     rest = []
980             elif not line.startswith(' '):
981                 push_item(current_func, rest)
982                 current_func = None
983                 if ',' in line:
984                     for func in line.split(','):
985                         if func.strip():
986                             push_item(func, [])
987                 elif line.strip():
988                     current_func = line
989             elif current_func is not None:
990                 rest.append(line.strip())
991         push_item(current_func, rest)
992 
993         if not items:
994             return []
995 
996         roles = {
997             'method': 'meth',
998             'meth': 'meth',
999             'function': 'func',
1000             'func': 'func',
1001             'class': 'class',
1002             'exception': 'exc',
1003             'exc': 'exc',
1004             'object': 'obj',
1005             'obj': 'obj',
1006             'module': 'mod',
1007             'mod': 'mod',
1008             'data': 'data',
1009             'constant': 'const',
1010             'const': 'const',
1011             'attribute': 'attr',
1012             'attr': 'attr'
1013         }
1014         if self._what is None:
1015             func_role = 'obj'
1016         else:
1017             func_role = roles.get(self._what, '')
1018         lines = []  # type: List[str]
1019         last_had_desc = True
1020         for func, desc, role in items:
1021             if role:
1022                 link = ':%s:`%s`' % (role, func)
1023             elif func_role:
1024                 link = ':%s:`%s`' % (func_role, func)
1025             else:
1026                 link = "`%s`_" % func
1027             if desc or last_had_desc:
1028                 lines += ['']
1029                 lines += [link]
1030             else:
1031                 lines[-1] += ", %s" % link
1032             if desc:
1033                 lines += self._indent([' '.join(desc)])
1034                 last_had_desc = True
1035             else:
1036                 last_had_desc = False
1037         lines += ['']
1038 
1039         return self._format_admonition('seealso', lines)

</code><intended_behavior>If this file contributes to the handling of specific docstring styles (e.g., Google or NumPy), the parsing logic here may require adjustments to similarly accommodate and correctly interpret multiple overloaded method signatures within a single docstring. The adjustment would ensure that the Napoleon extension does not overlook additional signatures after the first, aligning with the enhanced behavior in `sphinx/ext/autodoc/__init__.py` to support a comprehensive documentation process for overloaded methods.</intended_behavior>]
2025-10-16 00:45:39.246 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:45:39.247 | INFO     | Search-only: skipping patch selection
2025-10-16 00:45:39.325 | INFO     | Task sphinx-doc__sphinx-7748 completed successfully.
2025-10-16 00:45:39.326 | INFO     | No patch generated. You can try running ACR again.
