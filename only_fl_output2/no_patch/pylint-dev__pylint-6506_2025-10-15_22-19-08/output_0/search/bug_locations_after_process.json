[
    {
        "rel_file_path": "pylint/config/config_initialization.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/config_initialization.py",
        "start": 20,
        "end": 106,
        "class_name": null,
        "method_name": "_config_initialization",
        "code": "20 def _config_initialization(\n21     linter: PyLinter,\n22     args_list: list[str],\n23     reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n24     config_file: None | str | Path = None,\n25     verbose_mode: bool = False,\n26 ) -> list[str]:\n27     \"\"\"Parse all available options, read config files and command line arguments and\n28     set options accordingly.\n29     \"\"\"\n30     config_file = Path(config_file) if config_file else None\n31 \n32     # Set the current module to the configuration file\n33     # to allow raising messages on the configuration file.\n34     linter.set_current_module(str(config_file) if config_file else None)\n35 \n36     # Read the configuration file\n37     config_file_parser = _ConfigurationFileParser(verbose_mode, linter)\n38     try:\n39         config_data, config_args = config_file_parser.parse_config_file(\n40             file_path=config_file\n41         )\n42     except OSError as ex:\n43         print(ex, file=sys.stderr)\n44         sys.exit(32)\n45 \n46     # Run init hook, if present, before loading plugins\n47     if \"init-hook\" in config_data:\n48         exec(utils._unquote(config_data[\"init-hook\"]))  # pylint: disable=exec-used\n49 \n50     # Load plugins if specified in the config file\n51     if \"load-plugins\" in config_data:\n52         linter.load_plugin_modules(utils._splitstrip(config_data[\"load-plugins\"]))\n53 \n54     # First we parse any options from a configuration file\n55     try:\n56         linter._parse_configuration_file(config_args)\n57     except _UnrecognizedOptionError as exc:\n58         msg = \", \".join(exc.options)\n59         linter.add_message(\"unrecognized-option\", line=0, args=msg)\n60 \n61     # Then, if a custom reporter is provided as argument, it may be overridden\n62     # by file parameters, so we re-set it here. We do this before command line\n63     # parsing, so it's still overridable by command line options\n64     if reporter:\n65         linter.set_reporter(reporter)\n66 \n67     # Set the current module to the command line\n68     # to allow raising messages on it\n69     linter.set_current_module(\"Command line\")\n70 \n71     # Now we parse any options from the command line, so they can override\n72     # the configuration file\n73     parsed_args_list = linter._parse_command_line_configuration(args_list)\n74 \n75     # Check if there are any options that we do not recognize\n76     unrecognized_options: list[str] = []\n77     for opt in parsed_args_list:\n78         if opt.startswith(\"--\"):\n79             unrecognized_options.append(opt[2:])\n80         elif opt.startswith(\"-\"):\n81             unrecognized_options.append(opt[1:])\n82     if unrecognized_options:\n83         msg = \", \".join(unrecognized_options)\n84         linter.add_message(\"unrecognized-option\", line=0, args=msg)\n85         raise _UnrecognizedOptionError(options=unrecognized_options)\n86 \n87     # Set the current module to configuration as we don't know where\n88     # the --load-plugins key is coming from\n89     linter.set_current_module(\"Command line or configuration file\")\n90 \n91     # We have loaded configuration from config file and command line. Now, we can\n92     # load plugin specific configuration.\n93     linter.load_plugin_configuration()\n94 \n95     # parsed_args_list should now only be a list of files/directories to lint.\n96     # All other options have been removed from the list.\n97     if not parsed_args_list:\n98         print(linter.help())\n99         sys.exit(32)\n100 \n101     # Now that plugins are loaded, get list of all fail_on messages, and enable them\n102     linter.enable_fail_on_messages()\n103 \n104     linter._parse_error_mode()\n105 \n106     return parsed_args_list\n",
        "intended_behavior": "This function should handle `_UnrecognizedOptionError` explicitly to prevent a traceback from being printed directly to the user. Instead, upon catching the error, the function should print a concise, user-friendly error message (e.g., 'Error: Unrecognized option -Q. Use --help to see available options.') and then gracefully exit the application (e.g., `sys.exit(1)`). This change aims to improve user experience by providing clear guidance on next steps rather than exposing internal execution details."
    },
    {
        "rel_file_path": "pylint/config/exceptions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/exceptions.py",
        "start": 14,
        "end": 19,
        "class_name": "_UnrecognizedOptionError",
        "method_name": null,
        "code": "14 class _UnrecognizedOptionError(Exception):\n15     \"\"\"Raised if an ArgumentManager instance tries to parse an option that is unknown.\"\"\"\n16 \n17     def __init__(self, options: list[str], *args: object) -> None:\n18         self.options = options\n19         super().__init__(*args)\n",
        "intended_behavior": "While the exception itself may not necessarily require changes to its definition, the documentation/comments around this exception could be enhanced to suggest expected handling practices, emphasizing user-friendly error messages and potential usage tips upon catching this error. This would guide future maintenance and enhancement efforts to align with best practices for exception handling within the tool, without altering its current functionality."
    }
]