2025-10-15 20:33:40.118 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 20:33:43.460 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1120, output_tokens=12, cost=0.011560
2025-10-15 20:34:00.286 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1300, output_tokens=388, cost=0.024640
2025-10-15 20:34:02.817 | INFO     | registered non reproducing test 0
2025-10-15 20:34:19.569 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1970, output_tokens=681, cost=0.040130
2025-10-15 20:34:21.148 | INFO     | registered non reproducing test 1
2025-10-15 20:34:35.726 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2268, output_tokens=618, cost=0.041220
2025-10-15 20:34:37.096 | INFO     | registered non reproducing test 2
2025-10-15 20:34:37.096 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 20:34:37.101 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:34:44.234 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1399, output_tokens=298, cost=0.022930
2025-10-15 20:34:44.238 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:34:46.649 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=75, cost=0.008770
2025-10-15 20:34:46.651 | DEBUG    | Extracted a valid json.
2025-10-15 20:34:46.651 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogNorm\")",
        "search_method_in_file(\"update_scalarmappable\", \"matplotlib/collections.py\")",
        "search_code(\"plot.norm = LogNorm(vmin, vmax)\")",
        "search_code(\"fig.colorbar(plot, ax=ax)\")"
    ],
    "bug_locations": []
}
2025-10-15 20:34:46.722 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 20:34:46.722 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 20:35:04.685 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2802, output_tokens=783, cost=0.051510
2025-10-15 20:35:04.701 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:35:13.527 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3801, output_tokens=339, cost=0.048180
2025-10-15 20:35:13.534 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:35:21.573 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=693, output_tokens=304, cost=0.016050
2025-10-15 20:35:21.574 | DEBUG    | Extracted a valid json.
2025-10-15 20:35:21.574 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "lib/matplotlib/collections.py", "class": "Collection", "method": "update_scalarmappable", "intended_behavior": "This method should ensure that when the norm is updated, especially to LogNorm, it properly checks and applies vmin and vmax values to avoid raising an 'Invalid vmin or vmax' error. It should allow for dynamic updates to the norm of the collection used in a plot with an associated colorbar. When plot.norm is set to a new norm (like LogNorm) after initial creation and display, it should trigger a re-evaluation of the collection's scalar mappable properties (self._A in this context) based on the new normalization parameters. This might involve ensuring that: - The collection's internal representations of vmin and vmax are updated to reflect those of the newly applied norm. - Any transformations required by the new norm (e.g., logarithmic scaling by LogNorm) are correctly applied to the scalar mappable array. - The method handles re-mapping of color values effectively without error and ensures the colorbar is also updated to reflect changes in the norm. The correction might include checks or updates to normalization parameters (vmin and vmax) within this method or prior to its invocation to ensure they are compatible with the applied norm. Additionally, it may require adjustments to the sequence of operations within update_scalarmappable or mechanisms to properly propagate norm updates from the plot to the associated colorbar."}]
}
2025-10-15 20:35:21.581 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/collections.py</file>
<class>Collection</class>
<method>update_scalarmappable</method>
<code>
861     def update_scalarmappable(self):
862         """
863         Update colors from the scalar mappable array, if any.
864 
865         Assign colors to edges and faces based on the array and/or
866         colors that were directly set, as appropriate.
867         """
868         if not self._set_mappable_flags():
869             return
870         # Allow possibility to call 'self.set_array(None)'.
871         if self._A is not None:
872             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)
873             if self._A.ndim > 1 and not isinstance(self, QuadMesh):
874                 raise ValueError('Collections can only map rank 1 arrays')
875             if np.iterable(self._alpha):
876                 if self._alpha.size != self._A.size:
877                     raise ValueError(
878                         f'Data array shape, {self._A.shape} '
879                         'is incompatible with alpha array shape, '
880                         f'{self._alpha.shape}. '
881                         'This can occur with the deprecated '
882                         'behavior of the "flat" shading option, '
883                         'in which a row and/or column of the data '
884                         'array is dropped.')
885                 # pcolormesh, scatter, maybe others flatten their _A
886                 self._alpha = self._alpha.reshape(self._A.shape)
887             self._mapped_colors = self.to_rgba(self._A, self._alpha)
888 
889         if self._face_is_mapped:
890             self._facecolors = self._mapped_colors
891         else:
892             self._set_facecolor(self._original_facecolor)
893         if self._edge_is_mapped:
894             self._edgecolors = self._mapped_colors
895         else:
896             self._set_edgecolor(self._original_edgecolor)
897         self.stale = True

</code><intended_behavior>This method should ensure that when the norm is updated, especially to LogNorm, it properly checks and applies vmin and vmax values to avoid raising an 'Invalid vmin or vmax' error. It should allow for dynamic updates to the norm of the collection used in a plot with an associated colorbar. When plot.norm is set to a new norm (like LogNorm) after initial creation and display, it should trigger a re-evaluation of the collection's scalar mappable properties (self._A in this context) based on the new normalization parameters. This might involve ensuring that: - The collection's internal representations of vmin and vmax are updated to reflect those of the newly applied norm. - Any transformations required by the new norm (e.g., logarithmic scaling by LogNorm) are correctly applied to the scalar mappable array. - The method handles re-mapping of color values effectively without error and ensures the colorbar is also updated to reflect changes in the norm. The correction might include checks or updates to normalization parameters (vmin and vmax) within this method or prior to its invocation to ensure they are compatible with the applied norm. Additionally, it may require adjustments to the sequence of operations within update_scalarmappable or mechanisms to properly propagate norm updates from the plot to the associated colorbar.</intended_behavior>, <file>lib/matplotlib/collections.py</file>
<class>Collection</class>
<method>None</method>
<code>
34 class Collection(artist.Artist, cm.ScalarMappable):
35     r"""
36     Base class for Collections. Must be subclassed to be usable.
37 
38     A Collection represents a sequence of `.Patch`\es that can be drawn
39     more efficiently together than individually. For example, when a single
40     path is being drawn repeatedly at different offsets, the renderer can
41     typically execute a ``draw_marker()`` call much more efficiently than a
42     series of repeated calls to ``draw_path()`` with the offsets put in
43     one-by-one.
44 
45     Most properties of a collection can be configured per-element. Therefore,
46     Collections have "plural" versions of many of the properties of a `.Patch`
47     (e.g. `.Collection.get_paths` instead of `.Patch.get_path`). Exceptions are
48     the *zorder*, *hatch*, *pickradius*, *capstyle* and *joinstyle* properties,
49     which can only be set globally for the whole collection.
50 
51     Besides these exceptions, all properties can be specified as single values
52     (applying to all elements) or sequences of values. The property of the
53     ``i``\th element of the collection is::
54 
55       prop[i % len(prop)]
56 
57     Each Collection can optionally be used as its own `.ScalarMappable` by
58     passing the *norm* and *cmap* parameters to its constructor. If the
59     Collection's `.ScalarMappable` matrix ``_A`` has been set (via a call
60     to `.Collection.set_array`), then at draw time this internal scalar
61     mappable will be used to set the ``facecolors`` and ``edgecolors``,
62     ignoring those that were manually passed in.
63     """
64     #: Either a list of 3x3 arrays or an Nx3x3 array (representing N
65     #: transforms), suitable for the `all_transforms` argument to
66     #: `~matplotlib.backend_bases.RendererBase.draw_path_collection`;
67     #: each 3x3 array is used to initialize an
68     #: `~matplotlib.transforms.Affine2D` object.
69     #: Each kind of collection defines this based on its arguments.
70     _transforms = np.empty((0, 3, 3))
71 
72     # Whether to draw an edge by default.  Set on a
73     # subclass-by-subclass basis.
74     _edge_default = False
75 
76     @_docstring.interpd
77     @_api.make_keyword_only("3.6", name="edgecolors")
78     def __init__(self,
79                  edgecolors=None,
80                  facecolors=None,
81                  linewidths=None,
82                  linestyles='solid',
83                  capstyle=None,
84                  joinstyle=None,
85                  antialiaseds=None,
86                  offsets=None,
87                  offset_transform=None,
88                  norm=None,  # optional for ScalarMappable
89                  cmap=None,  # ditto
90                  pickradius=5.0,
91                  hatch=None,
92                  urls=None,
93                  *,
94                  zorder=1,
95                  **kwargs
96                  ):
97         """
98         Parameters
99         ----------
100         edgecolors : color or list of colors, default: :rc:`patch.edgecolor`
101             Edge color for each patch making up the collection. The special
102             value 'face' can be passed to make the edgecolor match the
103             facecolor.
104         facecolors : color or list of colors, default: :rc:`patch.facecolor`
105             Face color for each patch making up the collection.
106         linewidths : float or list of floats, default: :rc:`patch.linewidth`
107             Line width for each patch making up the collection.
108         linestyles : str or tuple or list thereof, default: 'solid'
109             Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', '-',
110             '--', '-.', ':']. Dash tuples should be of the form::
111 
112                 (offset, onoffseq),
113 
114             where *onoffseq* is an even length tuple of on and off ink lengths
115             in points. For examples, see
116             :doc:`/gallery/lines_bars_and_markers/linestyles`.
117         capstyle : `.CapStyle`-like, default: :rc:`patch.capstyle`
118             Style to use for capping lines for all paths in the collection.
119             Allowed values are %(CapStyle)s.
120         joinstyle : `.JoinStyle`-like, default: :rc:`patch.joinstyle`
121             Style to use for joining lines for all paths in the collection.
122             Allowed values are %(JoinStyle)s.
123         antialiaseds : bool or list of bool, default: :rc:`patch.antialiased`
124             Whether each patch in the collection should be drawn with
125             antialiasing.
126         offsets : (float, float) or list thereof, default: (0, 0)
127             A vector by which to translate each patch after rendering (default
128             is no translation). The translation is performed in screen (pixel)
129             coordinates (i.e. after the Artist's transform is applied).
130         offset_transform : `~.Transform`, default: `.IdentityTransform`
131             A single transform which will be applied to each *offsets* vector
132             before it is used.
133         cmap, norm
134             Data normalization and colormapping parameters. See
135             `.ScalarMappable` for a detailed description.
136         hatch : str, optional
137             Hatching pattern to use in filled paths, if any. Valid strings are
138             ['/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See
139             :doc:`/gallery/shapes_and_collections/hatch_style_reference` for
140             the meaning of each hatch type.
141         pickradius : float, default: 5.0
142             If ``pickradius <= 0``, then `.Collection.contains` will return
143             ``True`` whenever the test point is inside of one of the polygons
144             formed by the control points of a Path in the Collection. On the
145             other hand, if it is greater than 0, then we instead check if the
146             test point is contained in a stroke of width ``2*pickradius``
147             following any of the Paths in the Collection.
148         urls : list of str, default: None
149             A URL for each patch to link to once drawn. Currently only works
150             for the SVG backend. See :doc:`/gallery/misc/hyperlinks_sgskip` for
151             examples.
152         zorder : float, default: 1
153             The drawing order, shared by all Patches in the Collection. See
154             :doc:`/gallery/misc/zorder_demo` for all defaults and examples.
155         """
156         artist.Artist.__init__(self)
157         cm.ScalarMappable.__init__(self, norm, cmap)
158         # list of un-scaled dash patterns
159         # this is needed scaling the dash pattern by linewidth
160         self._us_linestyles = [(0, None)]
161         # list of dash patterns
162         self._linestyles = [(0, None)]
163         # list of unbroadcast/scaled linewidths
164         self._us_lw = [0]
165         self._linewidths = [0]
166         # Flags set by _set_mappable_flags: are colors from mapping an array?
167         self._face_is_mapped = None
168         self._edge_is_mapped = None
169         self._mapped_colors = None  # calculated in update_scalarmappable
170         self._hatch_color = mcolors.to_rgba(mpl.rcParams['hatch.color'])
171         self.set_facecolor(facecolors)
172         self.set_edgecolor(edgecolors)
173         self.set_linewidth(linewidths)
174         self.set_linestyle(linestyles)
175         self.set_antialiased(antialiaseds)
176         self.set_pickradius(pickradius)
177         self.set_urls(urls)
178         self.set_hatch(hatch)
179         self.set_zorder(zorder)
180 
181         if capstyle:
182             self.set_capstyle(capstyle)
183         else:
184             self._capstyle = None
185 
186         if joinstyle:
187             self.set_joinstyle(joinstyle)
188         else:
189             self._joinstyle = None
190 
191         if offsets is not None:
192             offsets = np.asanyarray(offsets, float)
193             # Broadcast (2,) -> (1, 2) but nothing else.
194             if offsets.shape == (2,):
195                 offsets = offsets[None, :]
196 
197         self._offsets = offsets
198         self._offset_transform = offset_transform
199 
200         self._path_effects = None
201         self._internal_update(kwargs)
202         self._paths = None
203 
204     def get_paths(self):
205         return self._paths
206 
207     def set_paths(self, paths):
208         raise NotImplementedError
209 
210     def get_transforms(self):
211         return self._transforms
212 
213     def get_offset_transform(self):
214         """Return the `.Transform` instance used by this artist offset."""
215         if self._offset_transform is None:
216             self._offset_transform = transforms.IdentityTransform()
217         elif (not isinstance(self._offset_transform, transforms.Transform)
218               and hasattr(self._offset_transform, '_as_mpl_transform')):
219             self._offset_transform = \
220                 self._offset_transform._as_mpl_transform(self.axes)
221         return self._offset_transform
222 
223     @_api.rename_parameter("3.6", "transOffset", "offset_transform")
224     def set_offset_transform(self, offset_transform):
225         """
226         Set the artist offset transform.
227 
228         Parameters
229         ----------
230         offset_transform : `.Transform`
231         """
232         self._offset_transform = offset_transform
233 
234     def get_datalim(self, transData):
235         # Calculate the data limits and return them as a `.Bbox`.
236         #
237         # This operation depends on the transforms for the data in the
238         # collection and whether the collection has offsets:
239         #
240         # 1. offsets = None, transform child of transData: use the paths for
241         # the automatic limits (i.e. for LineCollection in streamline).
242         # 2. offsets != None: offset_transform is child of transData:
243         #
244         #    a. transform is child of transData: use the path + offset for
245         #       limits (i.e for bar).
246         #    b. transform is not a child of transData: just use the offsets
247         #       for the limits (i.e. for scatter)
248         #
249         # 3. otherwise return a null Bbox.
250 
251         transform = self.get_transform()
252         offset_trf = self.get_offset_transform()
253         if not (isinstance(offset_trf, transforms.IdentityTransform)
254                 or offset_trf.contains_branch(transData)):
255             # if the offsets are in some coords other than data,
256             # then don't use them for autoscaling.
257             return transforms.Bbox.null()
258         offsets = self.get_offsets()
259 
260         paths = self.get_paths()
261         if not len(paths):
262             # No paths to transform
263             return transforms.Bbox.null()
264 
265         if not transform.is_affine:
266             paths = [transform.transform_path_non_affine(p) for p in paths]
267             # Don't convert transform to transform.get_affine() here because
268             # we may have transform.contains_branch(transData) but not
269             # transforms.get_affine().contains_branch(transData).  But later,
270             # be careful to only apply the affine part that remains.
271 
272         if any(transform.contains_branch_seperately(transData)):
273             # collections that are just in data units (like quiver)
274             # can properly have the axes limits set by their shape +
275             # offset.  LineCollections that have no offsets can
276             # also use this algorithm (like streamplot).
277             if isinstance(offsets, np.ma.MaskedArray):
278                 offsets = offsets.filled(np.nan)
279                 # get_path_collection_extents handles nan but not masked arrays
280             return mpath.get_path_collection_extents(
281                 transform.get_affine() - transData, paths,
282                 self.get_transforms(),
283                 offset_trf.transform_non_affine(offsets),
284                 offset_trf.get_affine().frozen())
285 
286         # NOTE: None is the default case where no offsets were passed in
287         if self._offsets is not None:
288             # this is for collections that have their paths (shapes)
289             # in physical, axes-relative, or figure-relative units
290             # (i.e. like scatter). We can't uniquely set limits based on
291             # those shapes, so we just set the limits based on their
292             # location.
293             offsets = (offset_trf - transData).transform(offsets)
294             # note A-B means A B^{-1}
295             offsets = np.ma.masked_invalid(offsets)
296             if not offsets.mask.all():
297                 bbox = transforms.Bbox.null()
298                 bbox.update_from_data_xy(offsets)
299                 return bbox
300         return transforms.Bbox.null()
301 
302     def get_window_extent(self, renderer=None):
303         # TODO: check to ensure that this does not fail for
304         # cases other than scatter plot legend
305         return self.get_datalim(transforms.IdentityTransform())
306 
307     def _prepare_points(self):
308         # Helper for drawing and hit testing.
309 
310         transform = self.get_transform()
311         offset_trf = self.get_offset_transform()
312         offsets = self.get_offsets()
313         paths = self.get_paths()
314 
315         if self.have_units():
316             paths = []
317             for path in self.get_paths():
318                 vertices = path.vertices
319                 xs, ys = vertices[:, 0], vertices[:, 1]
320                 xs = self.convert_xunits(xs)
321                 ys = self.convert_yunits(ys)
322                 paths.append(mpath.Path(np.column_stack([xs, ys]), path.codes))
323             xs = self.convert_xunits(offsets[:, 0])
324             ys = self.convert_yunits(offsets[:, 1])
325             offsets = np.ma.column_stack([xs, ys])
326 
327         if not transform.is_affine:
328             paths = [transform.transform_path_non_affine(path)
329                      for path in paths]
330             transform = transform.get_affine()
331         if not offset_trf.is_affine:
332             offsets = offset_trf.transform_non_affine(offsets)
333             # This might have changed an ndarray into a masked array.
334             offset_trf = offset_trf.get_affine()
335 
336         if isinstance(offsets, np.ma.MaskedArray):
337             offsets = offsets.filled(np.nan)
338             # Changing from a masked array to nan-filled ndarray
339             # is probably most efficient at this point.
340 
341         return transform, offset_trf, offsets, paths
342 
343     @artist.allow_rasterization
344     def draw(self, renderer):
345         if not self.get_visible():
346             return
347         renderer.open_group(self.__class__.__name__, self.get_gid())
348 
349         self.update_scalarmappable()
350 
351         transform, offset_trf, offsets, paths = self._prepare_points()
352 
353         gc = renderer.new_gc()
354         self._set_gc_clip(gc)
355         gc.set_snap(self.get_snap())
356 
357         if self._hatch:
358             gc.set_hatch(self._hatch)
359             gc.set_hatch_color(self._hatch_color)
360 
361         if self.get_sketch_params() is not None:
362             gc.set_sketch_params(*self.get_sketch_params())
363 
364         if self.get_path_effects():
365             from matplotlib.patheffects import PathEffectRenderer
366             renderer = PathEffectRenderer(self.get_path_effects(), renderer)
367 
368         # If the collection is made up of a single shape/color/stroke,
369         # it can be rendered once and blitted multiple times, using
370         # `draw_markers` rather than `draw_path_collection`.  This is
371         # *much* faster for Agg, and results in smaller file sizes in
372         # PDF/SVG/PS.
373 
374         trans = self.get_transforms()
375         facecolors = self.get_facecolor()
376         edgecolors = self.get_edgecolor()
377         do_single_path_optimization = False
378         if (len(paths) == 1 and len(trans) <= 1 and
379                 len(facecolors) == 1 and len(edgecolors) == 1 and
380                 len(self._linewidths) == 1 and
381                 all(ls[1] is None for ls in self._linestyles) and
382                 len(self._antialiaseds) == 1 and len(self._urls) == 1 and
383                 self.get_hatch() is None):
384             if len(trans):
385                 combined_transform = transforms.Affine2D(trans[0]) + transform
386             else:
387                 combined_transform = transform
388             extents = paths[0].get_extents(combined_transform)
389             if (extents.width < self.figure.bbox.width
390                     and extents.height < self.figure.bbox.height):
391                 do_single_path_optimization = True
392 
393         if self._joinstyle:
394             gc.set_joinstyle(self._joinstyle)
395 
396         if self._capstyle:
397             gc.set_capstyle(self._capstyle)
398 
399         if do_single_path_optimization:
400             gc.set_foreground(tuple(edgecolors[0]))
401             gc.set_linewidth(self._linewidths[0])
402             gc.set_dashes(*self._linestyles[0])
403             gc.set_antialiased(self._antialiaseds[0])
404             gc.set_url(self._urls[0])
405             renderer.draw_markers(
406                 gc, paths[0], combined_transform.frozen(),
407                 mpath.Path(offsets), offset_trf, tuple(facecolors[0]))
408         else:
409             renderer.draw_path_collection(
410                 gc, transform.frozen(), paths,
411                 self.get_transforms(), offsets, offset_trf,
412                 self.get_facecolor(), self.get_edgecolor(),
413                 self._linewidths, self._linestyles,
414                 self._antialiaseds, self._urls,
415                 "screen")  # offset_position, kept for backcompat.
416 
417         gc.restore()
418         renderer.close_group(self.__class__.__name__)
419         self.stale = False
420 
421     @_api.rename_parameter("3.6", "pr", "pickradius")
422     def set_pickradius(self, pickradius):
423         """
424         Set the pick radius used for containment tests.
425 
426         Parameters
427         ----------
428         pickradius : float
429             Pick radius, in points.
430         """
431         self._pickradius = pickradius
432 
433     def get_pickradius(self):
434         return self._pickradius
435 
436     def contains(self, mouseevent):
437         """
438         Test whether the mouse event occurred in the collection.
439 
440         Returns ``bool, dict(ind=itemlist)``, where every item in itemlist
441         contains the event.
442         """
443         inside, info = self._default_contains(mouseevent)
444         if inside is not None:
445             return inside, info
446 
447         if not self.get_visible():
448             return False, {}
449 
450         pickradius = (
451             float(self._picker)
452             if isinstance(self._picker, Number) and
453                self._picker is not True  # the bool, not just nonzero or 1
454             else self._pickradius)
455 
456         if self.axes:
457             self.axes._unstale_viewLim()
458 
459         transform, offset_trf, offsets, paths = self._prepare_points()
460 
461         # Tests if the point is contained on one of the polygons formed
462         # by the control points of each of the paths. A point is considered
463         # "on" a path if it would lie within a stroke of width 2*pickradius
464         # following the path. If pickradius <= 0, then we instead simply check
465         # if the point is *inside* of the path instead.
466         ind = _path.point_in_path_collection(
467             mouseevent.x, mouseevent.y, pickradius,
468             transform.frozen(), paths, self.get_transforms(),
469             offsets, offset_trf, pickradius <= 0)
470 
471         return len(ind) > 0, dict(ind=ind)
472 
473     def set_urls(self, urls):
474         """
475         Parameters
476         ----------
477         urls : list of str or None
478 
479         Notes
480         -----
481         URLs are currently only implemented by the SVG backend. They are
482         ignored by all other backends.
483         """
484         self._urls = urls if urls is not None else [None]
485         self.stale = True
486 
487     def get_urls(self):
488         """
489         Return a list of URLs, one for each element of the collection.
490 
491         The list contains *None* for elements without a URL. See
492         :doc:`/gallery/misc/hyperlinks_sgskip` for an example.
493         """
494         return self._urls
495 
496     def set_hatch(self, hatch):
497         r"""
498         Set the hatching pattern
499 
500         *hatch* can be one of::
501 
502           /   - diagonal hatching
503           \   - back diagonal
504           |   - vertical
505           -   - horizontal
506           +   - crossed
507           x   - crossed diagonal
508           o   - small circle
509           O   - large circle
510           .   - dots
511           *   - stars
512 
513         Letters can be combined, in which case all the specified
514         hatchings are done.  If same letter repeats, it increases the
515         density of hatching of that pattern.
516 
517         Hatching is supported in the PostScript, PDF, SVG and Agg
518         backends only.
519 
520         Unlike other properties such as linewidth and colors, hatching
521         can only be specified for the collection as a whole, not separately
522         for each member.
523 
524         Parameters
525         ----------
526         hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
527         """
528         # Use validate_hatch(list) after deprecation.
529         mhatch._validate_hatch_pattern(hatch)
530         self._hatch = hatch
531         self.stale = True
532 
533     def get_hatch(self):
534         """Return the current hatching pattern."""
535         return self._hatch
536 
537     def set_offsets(self, offsets):
538         """
539         Set the offsets for the collection.
540 
541         Parameters
542         ----------
543         offsets : (N, 2) or (2,) array-like
544         """
545         offsets = np.asanyarray(offsets)
546         if offsets.shape == (2,):  # Broadcast (2,) -> (1, 2) but nothing else.
547             offsets = offsets[None, :]
548         cstack = (np.ma.column_stack if isinstance(offsets, np.ma.MaskedArray)
549                   else np.column_stack)
550         self._offsets = cstack(
551             (np.asanyarray(self.convert_xunits(offsets[:, 0]), float),
552              np.asanyarray(self.convert_yunits(offsets[:, 1]), float)))
553         self.stale = True
554 
555     def get_offsets(self):
556         """Return the offsets for the collection."""
557         # Default to zeros in the no-offset (None) case
558         return np.zeros((1, 2)) if self._offsets is None else self._offsets
559 
560     def _get_default_linewidth(self):
561         # This may be overridden in a subclass.
562         return mpl.rcParams['patch.linewidth']  # validated as float
563 
564     def set_linewidth(self, lw):
565         """
566         Set the linewidth(s) for the collection.  *lw* can be a scalar
567         or a sequence; if it is a sequence the patches will cycle
568         through the sequence
569 
570         Parameters
571         ----------
572         lw : float or list of floats
573         """
574         if lw is None:
575             lw = self._get_default_linewidth()
576         # get the un-scaled/broadcast lw
577         self._us_lw = np.atleast_1d(lw)
578 
579         # scale all of the dash patterns.
580         self._linewidths, self._linestyles = self._bcast_lwls(
581             self._us_lw, self._us_linestyles)
582         self.stale = True
583 
584     def set_linestyle(self, ls):
585         """
586         Set the linestyle(s) for the collection.
587 
588         ===========================   =================
589         linestyle                     description
590         ===========================   =================
591         ``'-'`` or ``'solid'``        solid line
592         ``'--'`` or  ``'dashed'``     dashed line
593         ``'-.'`` or  ``'dashdot'``    dash-dotted line
594         ``':'`` or ``'dotted'``       dotted line
595         ===========================   =================
596 
597         Alternatively a dash tuple of the following form can be provided::
598 
599             (offset, onoffseq),
600 
601         where ``onoffseq`` is an even length tuple of on and off ink in points.
602 
603         Parameters
604         ----------
605         ls : str or tuple or list thereof
606             Valid values for individual linestyles include {'-', '--', '-.',
607             ':', '', (offset, on-off-seq)}. See `.Line2D.set_linestyle` for a
608             complete description.
609         """
610         try:
611             dashes = [mlines._get_dash_pattern(ls)]
612         except ValueError:
613             try:
614                 dashes = [mlines._get_dash_pattern(x) for x in ls]
615             except ValueError as err:
616                 emsg = f'Do not know how to convert {ls!r} to dashes'
617                 raise ValueError(emsg) from err
618 
619         # get the list of raw 'unscaled' dash patterns
620         self._us_linestyles = dashes
621 
622         # broadcast and scale the lw and dash patterns
623         self._linewidths, self._linestyles = self._bcast_lwls(
624             self._us_lw, self._us_linestyles)
625 
626     @_docstring.interpd
627     def set_capstyle(self, cs):
628         """
629         Set the `.CapStyle` for the collection (for all its elements).
630 
631         Parameters
632         ----------
633         cs : `.CapStyle` or %(CapStyle)s
634         """
635         self._capstyle = CapStyle(cs)
636 
637     def get_capstyle(self):
638         return self._capstyle.name
639 
640     @_docstring.interpd
641     def set_joinstyle(self, js):
642         """
643         Set the `.JoinStyle` for the collection (for all its elements).
644 
645         Parameters
646         ----------
647         js : `.JoinStyle` or %(JoinStyle)s
648         """
649         self._joinstyle = JoinStyle(js)
650 
651     def get_joinstyle(self):
652         return self._joinstyle.name
653 
654     @staticmethod
655     def _bcast_lwls(linewidths, dashes):
656         """
657         Internal helper function to broadcast + scale ls/lw
658 
659         In the collection drawing code, the linewidth and linestyle are cycled
660         through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are
661         going to scale the dash pattern at set time (not draw time) we need to
662         do the broadcasting now and expand both lists to be the same length.
663 
664         Parameters
665         ----------
666         linewidths : list
667             line widths of collection
668         dashes : list
669             dash specification (offset, (dash pattern tuple))
670 
671         Returns
672         -------
673         linewidths, dashes : list
674             Will be the same length, dashes are scaled by paired linewidth
675         """
676         if mpl.rcParams['_internal.classic_mode']:
677             return linewidths, dashes
678         # make sure they are the same length so we can zip them
679         if len(dashes) != len(linewidths):
680             l_dashes = len(dashes)
681             l_lw = len(linewidths)
682             gcd = math.gcd(l_dashes, l_lw)
683             dashes = list(dashes) * (l_lw // gcd)
684             linewidths = list(linewidths) * (l_dashes // gcd)
685 
686         # scale the dash patterns
687         dashes = [mlines._scale_dashes(o, d, lw)
688                   for (o, d), lw in zip(dashes, linewidths)]
689 
690         return linewidths, dashes
691 
692     def set_antialiased(self, aa):
693         """
694         Set the antialiasing state for rendering.
695 
696         Parameters
697         ----------
698         aa : bool or list of bools
699         """
700         if aa is None:
701             aa = self._get_default_antialiased()
702         self._antialiaseds = np.atleast_1d(np.asarray(aa, bool))
703         self.stale = True
704 
705     def _get_default_antialiased(self):
706         # This may be overridden in a subclass.
707         return mpl.rcParams['patch.antialiased']
708 
709     def set_color(self, c):
710         """
711         Set both the edgecolor and the facecolor.
712 
713         Parameters
714         ----------
715         c : color or list of RGBA tuples
716 
717         See Also
718         --------
719         Collection.set_facecolor, Collection.set_edgecolor
720             For setting the edge or face color individually.
721         """
722         self.set_facecolor(c)
723         self.set_edgecolor(c)
724 
725     def _get_default_facecolor(self):
726         # This may be overridden in a subclass.
727         return mpl.rcParams['patch.facecolor']
728 
729     def _set_facecolor(self, c):
730         if c is None:
731             c = self._get_default_facecolor()
732 
733         self._facecolors = mcolors.to_rgba_array(c, self._alpha)
734         self.stale = True
735 
736     def set_facecolor(self, c):
737         """
738         Set the facecolor(s) of the collection. *c* can be a color (all patches
739         have same color), or a sequence of colors; if it is a sequence the
740         patches will cycle through the sequence.
741 
742         If *c* is 'none', the patch will not be filled.
743 
744         Parameters
745         ----------
746         c : color or list of colors
747         """
748         if isinstance(c, str) and c.lower() in ("none", "face"):
749             c = c.lower()
750         self._original_facecolor = c
751         self._set_facecolor(c)
752 
753     def get_facecolor(self):
754         return self._facecolors
755 
756     def get_edgecolor(self):
757         if cbook._str_equal(self._edgecolors, 'face'):
758             return self.get_facecolor()
759         else:
760             return self._edgecolors
761 
762     def _get_default_edgecolor(self):
763         # This may be overridden in a subclass.
764         return mpl.rcParams['patch.edgecolor']
765 
766     def _set_edgecolor(self, c):
767         set_hatch_color = True
768         if c is None:
769             if (mpl.rcParams['patch.force_edgecolor']
770                     or self._edge_default
771                     or cbook._str_equal(self._original_facecolor, 'none')):
772                 c = self._get_default_edgecolor()
773             else:
774                 c = 'none'
775                 set_hatch_color = False
776         if cbook._str_lower_equal(c, 'face'):
777             self._edgecolors = 'face'
778             self.stale = True
779             return
780         self._edgecolors = mcolors.to_rgba_array(c, self._alpha)
781         if set_hatch_color and len(self._edgecolors):
782             self._hatch_color = tuple(self._edgecolors[0])
783         self.stale = True
784 
785     def set_edgecolor(self, c):
786         """
787         Set the edgecolor(s) of the collection.
788 
789         Parameters
790         ----------
791         c : color or list of colors or 'face'
792             The collection edgecolor(s).  If a sequence, the patches cycle
793             through it.  If 'face', match the facecolor.
794         """
795         # We pass through a default value for use in LineCollection.
796         # This allows us to maintain None as the default indicator in
797         # _original_edgecolor.
798         if isinstance(c, str) and c.lower() in ("none", "face"):
799             c = c.lower()
800         self._original_edgecolor = c
801         self._set_edgecolor(c)
802 
803     def set_alpha(self, alpha):
804         """
805         Set the transparency of the collection.
806 
807         Parameters
808         ----------
809         alpha : float or array of float or None
810             If not None, *alpha* values must be between 0 and 1, inclusive.
811             If an array is provided, its length must match the number of
812             elements in the collection.  Masked values and nans are not
813             supported.
814         """
815         artist.Artist._set_alpha_for_array(self, alpha)
816         self._set_facecolor(self._original_facecolor)
817         self._set_edgecolor(self._original_edgecolor)
818 
819     set_alpha.__doc__ = artist.Artist._set_alpha_for_array.__doc__
820 
821     def get_linewidth(self):
822         return self._linewidths
823 
824     def get_linestyle(self):
825         return self._linestyles
826 
827     def _set_mappable_flags(self):
828         """
829         Determine whether edges and/or faces are color-mapped.
830 
831         This is a helper for update_scalarmappable.
832         It sets Boolean flags '_edge_is_mapped' and '_face_is_mapped'.
833 
834         Returns
835         -------
836         mapping_change : bool
837             True if either flag is True, or if a flag has changed.
838         """
839         # The flags are initialized to None to ensure this returns True
840         # the first time it is called.
841         edge0 = self._edge_is_mapped
842         face0 = self._face_is_mapped
843         # After returning, the flags must be Booleans, not None.
844         self._edge_is_mapped = False
845         self._face_is_mapped = False
846         if self._A is not None:
847             if not cbook._str_equal(self._original_facecolor, 'none'):
848                 self._face_is_mapped = True
849                 if cbook._str_equal(self._original_edgecolor, 'face'):
850                     self._edge_is_mapped = True
851             else:
852                 if self._original_edgecolor is None:
853                     self._edge_is_mapped = True
854 
855         mapped = self._face_is_mapped or self._edge_is_mapped
856         changed = (edge0 is None or face0 is None
857                    or self._edge_is_mapped != edge0
858                    or self._face_is_mapped != face0)
859         return mapped or changed
860 
861     def update_scalarmappable(self):
862         """
863         Update colors from the scalar mappable array, if any.
864 
865         Assign colors to edges and faces based on the array and/or
866         colors that were directly set, as appropriate.
867         """
868         if not self._set_mappable_flags():
869             return
870         # Allow possibility to call 'self.set_array(None)'.
871         if self._A is not None:
872             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)
873             if self._A.ndim > 1 and not isinstance(self, QuadMesh):
874                 raise ValueError('Collections can only map rank 1 arrays')
875             if np.iterable(self._alpha):
876                 if self._alpha.size != self._A.size:
877                     raise ValueError(
878                         f'Data array shape, {self._A.shape} '
879                         'is incompatible with alpha array shape, '
880                         f'{self._alpha.shape}. '
881                         'This can occur with the deprecated '
882                         'behavior of the "flat" shading option, '
883                         'in which a row and/or column of the data '
884                         'array is dropped.')
885                 # pcolormesh, scatter, maybe others flatten their _A
886                 self._alpha = self._alpha.reshape(self._A.shape)
887             self._mapped_colors = self.to_rgba(self._A, self._alpha)
888 
889         if self._face_is_mapped:
890             self._facecolors = self._mapped_colors
891         else:
892             self._set_facecolor(self._original_facecolor)
893         if self._edge_is_mapped:
894             self._edgecolors = self._mapped_colors
895         else:
896             self._set_edgecolor(self._original_edgecolor)
897         self.stale = True
898 
899     def get_fill(self):
900         """Return whether face is colored."""
901         return not cbook._str_lower_equal(self._original_facecolor, "none")
902 
903     def update_from(self, other):
904         """Copy properties from other to self."""
905 
906         artist.Artist.update_from(self, other)
907         self._antialiaseds = other._antialiaseds
908         self._mapped_colors = other._mapped_colors
909         self._edge_is_mapped = other._edge_is_mapped
910         self._original_edgecolor = other._original_edgecolor
911         self._edgecolors = other._edgecolors
912         self._face_is_mapped = other._face_is_mapped
913         self._original_facecolor = other._original_facecolor
914         self._facecolors = other._facecolors
915         self._linewidths = other._linewidths
916         self._linestyles = other._linestyles
917         self._us_linestyles = other._us_linestyles
918         self._pickradius = other._pickradius
919         self._hatch = other._hatch
920 
921         # update_from for scalarmappable
922         self._A = other._A
923         self.norm = other.norm
924         self.cmap = other.cmap
925         self.stale = True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 20:35:21.582 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/collections.py</file>
<class>Collection</class>
<method>update_scalarmappable</method>
<code>
861     def update_scalarmappable(self):
862         """
863         Update colors from the scalar mappable array, if any.
864 
865         Assign colors to edges and faces based on the array and/or
866         colors that were directly set, as appropriate.
867         """
868         if not self._set_mappable_flags():
869             return
870         # Allow possibility to call 'self.set_array(None)'.
871         if self._A is not None:
872             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)
873             if self._A.ndim > 1 and not isinstance(self, QuadMesh):
874                 raise ValueError('Collections can only map rank 1 arrays')
875             if np.iterable(self._alpha):
876                 if self._alpha.size != self._A.size:
877                     raise ValueError(
878                         f'Data array shape, {self._A.shape} '
879                         'is incompatible with alpha array shape, '
880                         f'{self._alpha.shape}. '
881                         'This can occur with the deprecated '
882                         'behavior of the "flat" shading option, '
883                         'in which a row and/or column of the data '
884                         'array is dropped.')
885                 # pcolormesh, scatter, maybe others flatten their _A
886                 self._alpha = self._alpha.reshape(self._A.shape)
887             self._mapped_colors = self.to_rgba(self._A, self._alpha)
888 
889         if self._face_is_mapped:
890             self._facecolors = self._mapped_colors
891         else:
892             self._set_facecolor(self._original_facecolor)
893         if self._edge_is_mapped:
894             self._edgecolors = self._mapped_colors
895         else:
896             self._set_edgecolor(self._original_edgecolor)
897         self.stale = True

</code><intended_behavior>This method should ensure that when the norm is updated, especially to LogNorm, it properly checks and applies vmin and vmax values to avoid raising an 'Invalid vmin or vmax' error. It should allow for dynamic updates to the norm of the collection used in a plot with an associated colorbar. When plot.norm is set to a new norm (like LogNorm) after initial creation and display, it should trigger a re-evaluation of the collection's scalar mappable properties (self._A in this context) based on the new normalization parameters. This might involve ensuring that: - The collection's internal representations of vmin and vmax are updated to reflect those of the newly applied norm. - Any transformations required by the new norm (e.g., logarithmic scaling by LogNorm) are correctly applied to the scalar mappable array. - The method handles re-mapping of color values effectively without error and ensures the colorbar is also updated to reflect changes in the norm. The correction might include checks or updates to normalization parameters (vmin and vmax) within this method or prior to its invocation to ensure they are compatible with the applied norm. Additionally, it may require adjustments to the sequence of operations within update_scalarmappable or mechanisms to properly propagate norm updates from the plot to the associated colorbar.</intended_behavior>, <file>lib/matplotlib/collections.py</file>
<class>Collection</class>
<method>None</method>
<code>
34 class Collection(artist.Artist, cm.ScalarMappable):
35     r"""
36     Base class for Collections. Must be subclassed to be usable.
37 
38     A Collection represents a sequence of `.Patch`\es that can be drawn
39     more efficiently together than individually. For example, when a single
40     path is being drawn repeatedly at different offsets, the renderer can
41     typically execute a ``draw_marker()`` call much more efficiently than a
42     series of repeated calls to ``draw_path()`` with the offsets put in
43     one-by-one.
44 
45     Most properties of a collection can be configured per-element. Therefore,
46     Collections have "plural" versions of many of the properties of a `.Patch`
47     (e.g. `.Collection.get_paths` instead of `.Patch.get_path`). Exceptions are
48     the *zorder*, *hatch*, *pickradius*, *capstyle* and *joinstyle* properties,
49     which can only be set globally for the whole collection.
50 
51     Besides these exceptions, all properties can be specified as single values
52     (applying to all elements) or sequences of values. The property of the
53     ``i``\th element of the collection is::
54 
55       prop[i % len(prop)]
56 
57     Each Collection can optionally be used as its own `.ScalarMappable` by
58     passing the *norm* and *cmap* parameters to its constructor. If the
59     Collection's `.ScalarMappable` matrix ``_A`` has been set (via a call
60     to `.Collection.set_array`), then at draw time this internal scalar
61     mappable will be used to set the ``facecolors`` and ``edgecolors``,
62     ignoring those that were manually passed in.
63     """
64     #: Either a list of 3x3 arrays or an Nx3x3 array (representing N
65     #: transforms), suitable for the `all_transforms` argument to
66     #: `~matplotlib.backend_bases.RendererBase.draw_path_collection`;
67     #: each 3x3 array is used to initialize an
68     #: `~matplotlib.transforms.Affine2D` object.
69     #: Each kind of collection defines this based on its arguments.
70     _transforms = np.empty((0, 3, 3))
71 
72     # Whether to draw an edge by default.  Set on a
73     # subclass-by-subclass basis.
74     _edge_default = False
75 
76     @_docstring.interpd
77     @_api.make_keyword_only("3.6", name="edgecolors")
78     def __init__(self,
79                  edgecolors=None,
80                  facecolors=None,
81                  linewidths=None,
82                  linestyles='solid',
83                  capstyle=None,
84                  joinstyle=None,
85                  antialiaseds=None,
86                  offsets=None,
87                  offset_transform=None,
88                  norm=None,  # optional for ScalarMappable
89                  cmap=None,  # ditto
90                  pickradius=5.0,
91                  hatch=None,
92                  urls=None,
93                  *,
94                  zorder=1,
95                  **kwargs
96                  ):
97         """
98         Parameters
99         ----------
100         edgecolors : color or list of colors, default: :rc:`patch.edgecolor`
101             Edge color for each patch making up the collection. The special
102             value 'face' can be passed to make the edgecolor match the
103             facecolor.
104         facecolors : color or list of colors, default: :rc:`patch.facecolor`
105             Face color for each patch making up the collection.
106         linewidths : float or list of floats, default: :rc:`patch.linewidth`
107             Line width for each patch making up the collection.
108         linestyles : str or tuple or list thereof, default: 'solid'
109             Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', '-',
110             '--', '-.', ':']. Dash tuples should be of the form::
111 
112                 (offset, onoffseq),
113 
114             where *onoffseq* is an even length tuple of on and off ink lengths
115             in points. For examples, see
116             :doc:`/gallery/lines_bars_and_markers/linestyles`.
117         capstyle : `.CapStyle`-like, default: :rc:`patch.capstyle`
118             Style to use for capping lines for all paths in the collection.
119             Allowed values are %(CapStyle)s.
120         joinstyle : `.JoinStyle`-like, default: :rc:`patch.joinstyle`
121             Style to use for joining lines for all paths in the collection.
122             Allowed values are %(JoinStyle)s.
123         antialiaseds : bool or list of bool, default: :rc:`patch.antialiased`
124             Whether each patch in the collection should be drawn with
125             antialiasing.
126         offsets : (float, float) or list thereof, default: (0, 0)
127             A vector by which to translate each patch after rendering (default
128             is no translation). The translation is performed in screen (pixel)
129             coordinates (i.e. after the Artist's transform is applied).
130         offset_transform : `~.Transform`, default: `.IdentityTransform`
131             A single transform which will be applied to each *offsets* vector
132             before it is used.
133         cmap, norm
134             Data normalization and colormapping parameters. See
135             `.ScalarMappable` for a detailed description.
136         hatch : str, optional
137             Hatching pattern to use in filled paths, if any. Valid strings are
138             ['/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See
139             :doc:`/gallery/shapes_and_collections/hatch_style_reference` for
140             the meaning of each hatch type.
141         pickradius : float, default: 5.0
142             If ``pickradius <= 0``, then `.Collection.contains` will return
143             ``True`` whenever the test point is inside of one of the polygons
144             formed by the control points of a Path in the Collection. On the
145             other hand, if it is greater than 0, then we instead check if the
146             test point is contained in a stroke of width ``2*pickradius``
147             following any of the Paths in the Collection.
148         urls : list of str, default: None
149             A URL for each patch to link to once drawn. Currently only works
150             for the SVG backend. See :doc:`/gallery/misc/hyperlinks_sgskip` for
151             examples.
152         zorder : float, default: 1
153             The drawing order, shared by all Patches in the Collection. See
154             :doc:`/gallery/misc/zorder_demo` for all defaults and examples.
155         """
156         artist.Artist.__init__(self)
157         cm.ScalarMappable.__init__(self, norm, cmap)
158         # list of un-scaled dash patterns
159         # this is needed scaling the dash pattern by linewidth
160         self._us_linestyles = [(0, None)]
161         # list of dash patterns
162         self._linestyles = [(0, None)]
163         # list of unbroadcast/scaled linewidths
164         self._us_lw = [0]
165         self._linewidths = [0]
166         # Flags set by _set_mappable_flags: are colors from mapping an array?
167         self._face_is_mapped = None
168         self._edge_is_mapped = None
169         self._mapped_colors = None  # calculated in update_scalarmappable
170         self._hatch_color = mcolors.to_rgba(mpl.rcParams['hatch.color'])
171         self.set_facecolor(facecolors)
172         self.set_edgecolor(edgecolors)
173         self.set_linewidth(linewidths)
174         self.set_linestyle(linestyles)
175         self.set_antialiased(antialiaseds)
176         self.set_pickradius(pickradius)
177         self.set_urls(urls)
178         self.set_hatch(hatch)
179         self.set_zorder(zorder)
180 
181         if capstyle:
182             self.set_capstyle(capstyle)
183         else:
184             self._capstyle = None
185 
186         if joinstyle:
187             self.set_joinstyle(joinstyle)
188         else:
189             self._joinstyle = None
190 
191         if offsets is not None:
192             offsets = np.asanyarray(offsets, float)
193             # Broadcast (2,) -> (1, 2) but nothing else.
194             if offsets.shape == (2,):
195                 offsets = offsets[None, :]
196 
197         self._offsets = offsets
198         self._offset_transform = offset_transform
199 
200         self._path_effects = None
201         self._internal_update(kwargs)
202         self._paths = None
203 
204     def get_paths(self):
205         return self._paths
206 
207     def set_paths(self, paths):
208         raise NotImplementedError
209 
210     def get_transforms(self):
211         return self._transforms
212 
213     def get_offset_transform(self):
214         """Return the `.Transform` instance used by this artist offset."""
215         if self._offset_transform is None:
216             self._offset_transform = transforms.IdentityTransform()
217         elif (not isinstance(self._offset_transform, transforms.Transform)
218               and hasattr(self._offset_transform, '_as_mpl_transform')):
219             self._offset_transform = \
220                 self._offset_transform._as_mpl_transform(self.axes)
221         return self._offset_transform
222 
223     @_api.rename_parameter("3.6", "transOffset", "offset_transform")
224     def set_offset_transform(self, offset_transform):
225         """
226         Set the artist offset transform.
227 
228         Parameters
229         ----------
230         offset_transform : `.Transform`
231         """
232         self._offset_transform = offset_transform
233 
234     def get_datalim(self, transData):
235         # Calculate the data limits and return them as a `.Bbox`.
236         #
237         # This operation depends on the transforms for the data in the
238         # collection and whether the collection has offsets:
239         #
240         # 1. offsets = None, transform child of transData: use the paths for
241         # the automatic limits (i.e. for LineCollection in streamline).
242         # 2. offsets != None: offset_transform is child of transData:
243         #
244         #    a. transform is child of transData: use the path + offset for
245         #       limits (i.e for bar).
246         #    b. transform is not a child of transData: just use the offsets
247         #       for the limits (i.e. for scatter)
248         #
249         # 3. otherwise return a null Bbox.
250 
251         transform = self.get_transform()
252         offset_trf = self.get_offset_transform()
253         if not (isinstance(offset_trf, transforms.IdentityTransform)
254                 or offset_trf.contains_branch(transData)):
255             # if the offsets are in some coords other than data,
256             # then don't use them for autoscaling.
257             return transforms.Bbox.null()
258         offsets = self.get_offsets()
259 
260         paths = self.get_paths()
261         if not len(paths):
262             # No paths to transform
263             return transforms.Bbox.null()
264 
265         if not transform.is_affine:
266             paths = [transform.transform_path_non_affine(p) for p in paths]
267             # Don't convert transform to transform.get_affine() here because
268             # we may have transform.contains_branch(transData) but not
269             # transforms.get_affine().contains_branch(transData).  But later,
270             # be careful to only apply the affine part that remains.
271 
272         if any(transform.contains_branch_seperately(transData)):
273             # collections that are just in data units (like quiver)
274             # can properly have the axes limits set by their shape +
275             # offset.  LineCollections that have no offsets can
276             # also use this algorithm (like streamplot).
277             if isinstance(offsets, np.ma.MaskedArray):
278                 offsets = offsets.filled(np.nan)
279                 # get_path_collection_extents handles nan but not masked arrays
280             return mpath.get_path_collection_extents(
281                 transform.get_affine() - transData, paths,
282                 self.get_transforms(),
283                 offset_trf.transform_non_affine(offsets),
284                 offset_trf.get_affine().frozen())
285 
286         # NOTE: None is the default case where no offsets were passed in
287         if self._offsets is not None:
288             # this is for collections that have their paths (shapes)
289             # in physical, axes-relative, or figure-relative units
290             # (i.e. like scatter). We can't uniquely set limits based on
291             # those shapes, so we just set the limits based on their
292             # location.
293             offsets = (offset_trf - transData).transform(offsets)
294             # note A-B means A B^{-1}
295             offsets = np.ma.masked_invalid(offsets)
296             if not offsets.mask.all():
297                 bbox = transforms.Bbox.null()
298                 bbox.update_from_data_xy(offsets)
299                 return bbox
300         return transforms.Bbox.null()
301 
302     def get_window_extent(self, renderer=None):
303         # TODO: check to ensure that this does not fail for
304         # cases other than scatter plot legend
305         return self.get_datalim(transforms.IdentityTransform())
306 
307     def _prepare_points(self):
308         # Helper for drawing and hit testing.
309 
310         transform = self.get_transform()
311         offset_trf = self.get_offset_transform()
312         offsets = self.get_offsets()
313         paths = self.get_paths()
314 
315         if self.have_units():
316             paths = []
317             for path in self.get_paths():
318                 vertices = path.vertices
319                 xs, ys = vertices[:, 0], vertices[:, 1]
320                 xs = self.convert_xunits(xs)
321                 ys = self.convert_yunits(ys)
322                 paths.append(mpath.Path(np.column_stack([xs, ys]), path.codes))
323             xs = self.convert_xunits(offsets[:, 0])
324             ys = self.convert_yunits(offsets[:, 1])
325             offsets = np.ma.column_stack([xs, ys])
326 
327         if not transform.is_affine:
328             paths = [transform.transform_path_non_affine(path)
329                      for path in paths]
330             transform = transform.get_affine()
331         if not offset_trf.is_affine:
332             offsets = offset_trf.transform_non_affine(offsets)
333             # This might have changed an ndarray into a masked array.
334             offset_trf = offset_trf.get_affine()
335 
336         if isinstance(offsets, np.ma.MaskedArray):
337             offsets = offsets.filled(np.nan)
338             # Changing from a masked array to nan-filled ndarray
339             # is probably most efficient at this point.
340 
341         return transform, offset_trf, offsets, paths
342 
343     @artist.allow_rasterization
344     def draw(self, renderer):
345         if not self.get_visible():
346             return
347         renderer.open_group(self.__class__.__name__, self.get_gid())
348 
349         self.update_scalarmappable()
350 
351         transform, offset_trf, offsets, paths = self._prepare_points()
352 
353         gc = renderer.new_gc()
354         self._set_gc_clip(gc)
355         gc.set_snap(self.get_snap())
356 
357         if self._hatch:
358             gc.set_hatch(self._hatch)
359             gc.set_hatch_color(self._hatch_color)
360 
361         if self.get_sketch_params() is not None:
362             gc.set_sketch_params(*self.get_sketch_params())
363 
364         if self.get_path_effects():
365             from matplotlib.patheffects import PathEffectRenderer
366             renderer = PathEffectRenderer(self.get_path_effects(), renderer)
367 
368         # If the collection is made up of a single shape/color/stroke,
369         # it can be rendered once and blitted multiple times, using
370         # `draw_markers` rather than `draw_path_collection`.  This is
371         # *much* faster for Agg, and results in smaller file sizes in
372         # PDF/SVG/PS.
373 
374         trans = self.get_transforms()
375         facecolors = self.get_facecolor()
376         edgecolors = self.get_edgecolor()
377         do_single_path_optimization = False
378         if (len(paths) == 1 and len(trans) <= 1 and
379                 len(facecolors) == 1 and len(edgecolors) == 1 and
380                 len(self._linewidths) == 1 and
381                 all(ls[1] is None for ls in self._linestyles) and
382                 len(self._antialiaseds) == 1 and len(self._urls) == 1 and
383                 self.get_hatch() is None):
384             if len(trans):
385                 combined_transform = transforms.Affine2D(trans[0]) + transform
386             else:
387                 combined_transform = transform
388             extents = paths[0].get_extents(combined_transform)
389             if (extents.width < self.figure.bbox.width
390                     and extents.height < self.figure.bbox.height):
391                 do_single_path_optimization = True
392 
393         if self._joinstyle:
394             gc.set_joinstyle(self._joinstyle)
395 
396         if self._capstyle:
397             gc.set_capstyle(self._capstyle)
398 
399         if do_single_path_optimization:
400             gc.set_foreground(tuple(edgecolors[0]))
401             gc.set_linewidth(self._linewidths[0])
402             gc.set_dashes(*self._linestyles[0])
403             gc.set_antialiased(self._antialiaseds[0])
404             gc.set_url(self._urls[0])
405             renderer.draw_markers(
406                 gc, paths[0], combined_transform.frozen(),
407                 mpath.Path(offsets), offset_trf, tuple(facecolors[0]))
408         else:
409             renderer.draw_path_collection(
410                 gc, transform.frozen(), paths,
411                 self.get_transforms(), offsets, offset_trf,
412                 self.get_facecolor(), self.get_edgecolor(),
413                 self._linewidths, self._linestyles,
414                 self._antialiaseds, self._urls,
415                 "screen")  # offset_position, kept for backcompat.
416 
417         gc.restore()
418         renderer.close_group(self.__class__.__name__)
419         self.stale = False
420 
421     @_api.rename_parameter("3.6", "pr", "pickradius")
422     def set_pickradius(self, pickradius):
423         """
424         Set the pick radius used for containment tests.
425 
426         Parameters
427         ----------
428         pickradius : float
429             Pick radius, in points.
430         """
431         self._pickradius = pickradius
432 
433     def get_pickradius(self):
434         return self._pickradius
435 
436     def contains(self, mouseevent):
437         """
438         Test whether the mouse event occurred in the collection.
439 
440         Returns ``bool, dict(ind=itemlist)``, where every item in itemlist
441         contains the event.
442         """
443         inside, info = self._default_contains(mouseevent)
444         if inside is not None:
445             return inside, info
446 
447         if not self.get_visible():
448             return False, {}
449 
450         pickradius = (
451             float(self._picker)
452             if isinstance(self._picker, Number) and
453                self._picker is not True  # the bool, not just nonzero or 1
454             else self._pickradius)
455 
456         if self.axes:
457             self.axes._unstale_viewLim()
458 
459         transform, offset_trf, offsets, paths = self._prepare_points()
460 
461         # Tests if the point is contained on one of the polygons formed
462         # by the control points of each of the paths. A point is considered
463         # "on" a path if it would lie within a stroke of width 2*pickradius
464         # following the path. If pickradius <= 0, then we instead simply check
465         # if the point is *inside* of the path instead.
466         ind = _path.point_in_path_collection(
467             mouseevent.x, mouseevent.y, pickradius,
468             transform.frozen(), paths, self.get_transforms(),
469             offsets, offset_trf, pickradius <= 0)
470 
471         return len(ind) > 0, dict(ind=ind)
472 
473     def set_urls(self, urls):
474         """
475         Parameters
476         ----------
477         urls : list of str or None
478 
479         Notes
480         -----
481         URLs are currently only implemented by the SVG backend. They are
482         ignored by all other backends.
483         """
484         self._urls = urls if urls is not None else [None]
485         self.stale = True
486 
487     def get_urls(self):
488         """
489         Return a list of URLs, one for each element of the collection.
490 
491         The list contains *None* for elements without a URL. See
492         :doc:`/gallery/misc/hyperlinks_sgskip` for an example.
493         """
494         return self._urls
495 
496     def set_hatch(self, hatch):
497         r"""
498         Set the hatching pattern
499 
500         *hatch* can be one of::
501 
502           /   - diagonal hatching
503           \   - back diagonal
504           |   - vertical
505           -   - horizontal
506           +   - crossed
507           x   - crossed diagonal
508           o   - small circle
509           O   - large circle
510           .   - dots
511           *   - stars
512 
513         Letters can be combined, in which case all the specified
514         hatchings are done.  If same letter repeats, it increases the
515         density of hatching of that pattern.
516 
517         Hatching is supported in the PostScript, PDF, SVG and Agg
518         backends only.
519 
520         Unlike other properties such as linewidth and colors, hatching
521         can only be specified for the collection as a whole, not separately
522         for each member.
523 
524         Parameters
525         ----------
526         hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}
527         """
528         # Use validate_hatch(list) after deprecation.
529         mhatch._validate_hatch_pattern(hatch)
530         self._hatch = hatch
531         self.stale = True
532 
533     def get_hatch(self):
534         """Return the current hatching pattern."""
535         return self._hatch
536 
537     def set_offsets(self, offsets):
538         """
539         Set the offsets for the collection.
540 
541         Parameters
542         ----------
543         offsets : (N, 2) or (2,) array-like
544         """
545         offsets = np.asanyarray(offsets)
546         if offsets.shape == (2,):  # Broadcast (2,) -> (1, 2) but nothing else.
547             offsets = offsets[None, :]
548         cstack = (np.ma.column_stack if isinstance(offsets, np.ma.MaskedArray)
549                   else np.column_stack)
550         self._offsets = cstack(
551             (np.asanyarray(self.convert_xunits(offsets[:, 0]), float),
552              np.asanyarray(self.convert_yunits(offsets[:, 1]), float)))
553         self.stale = True
554 
555     def get_offsets(self):
556         """Return the offsets for the collection."""
557         # Default to zeros in the no-offset (None) case
558         return np.zeros((1, 2)) if self._offsets is None else self._offsets
559 
560     def _get_default_linewidth(self):
561         # This may be overridden in a subclass.
562         return mpl.rcParams['patch.linewidth']  # validated as float
563 
564     def set_linewidth(self, lw):
565         """
566         Set the linewidth(s) for the collection.  *lw* can be a scalar
567         or a sequence; if it is a sequence the patches will cycle
568         through the sequence
569 
570         Parameters
571         ----------
572         lw : float or list of floats
573         """
574         if lw is None:
575             lw = self._get_default_linewidth()
576         # get the un-scaled/broadcast lw
577         self._us_lw = np.atleast_1d(lw)
578 
579         # scale all of the dash patterns.
580         self._linewidths, self._linestyles = self._bcast_lwls(
581             self._us_lw, self._us_linestyles)
582         self.stale = True
583 
584     def set_linestyle(self, ls):
585         """
586         Set the linestyle(s) for the collection.
587 
588         ===========================   =================
589         linestyle                     description
590         ===========================   =================
591         ``'-'`` or ``'solid'``        solid line
592         ``'--'`` or  ``'dashed'``     dashed line
593         ``'-.'`` or  ``'dashdot'``    dash-dotted line
594         ``':'`` or ``'dotted'``       dotted line
595         ===========================   =================
596 
597         Alternatively a dash tuple of the following form can be provided::
598 
599             (offset, onoffseq),
600 
601         where ``onoffseq`` is an even length tuple of on and off ink in points.
602 
603         Parameters
604         ----------
605         ls : str or tuple or list thereof
606             Valid values for individual linestyles include {'-', '--', '-.',
607             ':', '', (offset, on-off-seq)}. See `.Line2D.set_linestyle` for a
608             complete description.
609         """
610         try:
611             dashes = [mlines._get_dash_pattern(ls)]
612         except ValueError:
613             try:
614                 dashes = [mlines._get_dash_pattern(x) for x in ls]
615             except ValueError as err:
616                 emsg = f'Do not know how to convert {ls!r} to dashes'
617                 raise ValueError(emsg) from err
618 
619         # get the list of raw 'unscaled' dash patterns
620         self._us_linestyles = dashes
621 
622         # broadcast and scale the lw and dash patterns
623         self._linewidths, self._linestyles = self._bcast_lwls(
624             self._us_lw, self._us_linestyles)
625 
626     @_docstring.interpd
627     def set_capstyle(self, cs):
628         """
629         Set the `.CapStyle` for the collection (for all its elements).
630 
631         Parameters
632         ----------
633         cs : `.CapStyle` or %(CapStyle)s
634         """
635         self._capstyle = CapStyle(cs)
636 
637     def get_capstyle(self):
638         return self._capstyle.name
639 
640     @_docstring.interpd
641     def set_joinstyle(self, js):
642         """
643         Set the `.JoinStyle` for the collection (for all its elements).
644 
645         Parameters
646         ----------
647         js : `.JoinStyle` or %(JoinStyle)s
648         """
649         self._joinstyle = JoinStyle(js)
650 
651     def get_joinstyle(self):
652         return self._joinstyle.name
653 
654     @staticmethod
655     def _bcast_lwls(linewidths, dashes):
656         """
657         Internal helper function to broadcast + scale ls/lw
658 
659         In the collection drawing code, the linewidth and linestyle are cycled
660         through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are
661         going to scale the dash pattern at set time (not draw time) we need to
662         do the broadcasting now and expand both lists to be the same length.
663 
664         Parameters
665         ----------
666         linewidths : list
667             line widths of collection
668         dashes : list
669             dash specification (offset, (dash pattern tuple))
670 
671         Returns
672         -------
673         linewidths, dashes : list
674             Will be the same length, dashes are scaled by paired linewidth
675         """
676         if mpl.rcParams['_internal.classic_mode']:
677             return linewidths, dashes
678         # make sure they are the same length so we can zip them
679         if len(dashes) != len(linewidths):
680             l_dashes = len(dashes)
681             l_lw = len(linewidths)
682             gcd = math.gcd(l_dashes, l_lw)
683             dashes = list(dashes) * (l_lw // gcd)
684             linewidths = list(linewidths) * (l_dashes // gcd)
685 
686         # scale the dash patterns
687         dashes = [mlines._scale_dashes(o, d, lw)
688                   for (o, d), lw in zip(dashes, linewidths)]
689 
690         return linewidths, dashes
691 
692     def set_antialiased(self, aa):
693         """
694         Set the antialiasing state for rendering.
695 
696         Parameters
697         ----------
698         aa : bool or list of bools
699         """
700         if aa is None:
701             aa = self._get_default_antialiased()
702         self._antialiaseds = np.atleast_1d(np.asarray(aa, bool))
703         self.stale = True
704 
705     def _get_default_antialiased(self):
706         # This may be overridden in a subclass.
707         return mpl.rcParams['patch.antialiased']
708 
709     def set_color(self, c):
710         """
711         Set both the edgecolor and the facecolor.
712 
713         Parameters
714         ----------
715         c : color or list of RGBA tuples
716 
717         See Also
718         --------
719         Collection.set_facecolor, Collection.set_edgecolor
720             For setting the edge or face color individually.
721         """
722         self.set_facecolor(c)
723         self.set_edgecolor(c)
724 
725     def _get_default_facecolor(self):
726         # This may be overridden in a subclass.
727         return mpl.rcParams['patch.facecolor']
728 
729     def _set_facecolor(self, c):
730         if c is None:
731             c = self._get_default_facecolor()
732 
733         self._facecolors = mcolors.to_rgba_array(c, self._alpha)
734         self.stale = True
735 
736     def set_facecolor(self, c):
737         """
738         Set the facecolor(s) of the collection. *c* can be a color (all patches
739         have same color), or a sequence of colors; if it is a sequence the
740         patches will cycle through the sequence.
741 
742         If *c* is 'none', the patch will not be filled.
743 
744         Parameters
745         ----------
746         c : color or list of colors
747         """
748         if isinstance(c, str) and c.lower() in ("none", "face"):
749             c = c.lower()
750         self._original_facecolor = c
751         self._set_facecolor(c)
752 
753     def get_facecolor(self):
754         return self._facecolors
755 
756     def get_edgecolor(self):
757         if cbook._str_equal(self._edgecolors, 'face'):
758             return self.get_facecolor()
759         else:
760             return self._edgecolors
761 
762     def _get_default_edgecolor(self):
763         # This may be overridden in a subclass.
764         return mpl.rcParams['patch.edgecolor']
765 
766     def _set_edgecolor(self, c):
767         set_hatch_color = True
768         if c is None:
769             if (mpl.rcParams['patch.force_edgecolor']
770                     or self._edge_default
771                     or cbook._str_equal(self._original_facecolor, 'none')):
772                 c = self._get_default_edgecolor()
773             else:
774                 c = 'none'
775                 set_hatch_color = False
776         if cbook._str_lower_equal(c, 'face'):
777             self._edgecolors = 'face'
778             self.stale = True
779             return
780         self._edgecolors = mcolors.to_rgba_array(c, self._alpha)
781         if set_hatch_color and len(self._edgecolors):
782             self._hatch_color = tuple(self._edgecolors[0])
783         self.stale = True
784 
785     def set_edgecolor(self, c):
786         """
787         Set the edgecolor(s) of the collection.
788 
789         Parameters
790         ----------
791         c : color or list of colors or 'face'
792             The collection edgecolor(s).  If a sequence, the patches cycle
793             through it.  If 'face', match the facecolor.
794         """
795         # We pass through a default value for use in LineCollection.
796         # This allows us to maintain None as the default indicator in
797         # _original_edgecolor.
798         if isinstance(c, str) and c.lower() in ("none", "face"):
799             c = c.lower()
800         self._original_edgecolor = c
801         self._set_edgecolor(c)
802 
803     def set_alpha(self, alpha):
804         """
805         Set the transparency of the collection.
806 
807         Parameters
808         ----------
809         alpha : float or array of float or None
810             If not None, *alpha* values must be between 0 and 1, inclusive.
811             If an array is provided, its length must match the number of
812             elements in the collection.  Masked values and nans are not
813             supported.
814         """
815         artist.Artist._set_alpha_for_array(self, alpha)
816         self._set_facecolor(self._original_facecolor)
817         self._set_edgecolor(self._original_edgecolor)
818 
819     set_alpha.__doc__ = artist.Artist._set_alpha_for_array.__doc__
820 
821     def get_linewidth(self):
822         return self._linewidths
823 
824     def get_linestyle(self):
825         return self._linestyles
826 
827     def _set_mappable_flags(self):
828         """
829         Determine whether edges and/or faces are color-mapped.
830 
831         This is a helper for update_scalarmappable.
832         It sets Boolean flags '_edge_is_mapped' and '_face_is_mapped'.
833 
834         Returns
835         -------
836         mapping_change : bool
837             True if either flag is True, or if a flag has changed.
838         """
839         # The flags are initialized to None to ensure this returns True
840         # the first time it is called.
841         edge0 = self._edge_is_mapped
842         face0 = self._face_is_mapped
843         # After returning, the flags must be Booleans, not None.
844         self._edge_is_mapped = False
845         self._face_is_mapped = False
846         if self._A is not None:
847             if not cbook._str_equal(self._original_facecolor, 'none'):
848                 self._face_is_mapped = True
849                 if cbook._str_equal(self._original_edgecolor, 'face'):
850                     self._edge_is_mapped = True
851             else:
852                 if self._original_edgecolor is None:
853                     self._edge_is_mapped = True
854 
855         mapped = self._face_is_mapped or self._edge_is_mapped
856         changed = (edge0 is None or face0 is None
857                    or self._edge_is_mapped != edge0
858                    or self._face_is_mapped != face0)
859         return mapped or changed
860 
861     def update_scalarmappable(self):
862         """
863         Update colors from the scalar mappable array, if any.
864 
865         Assign colors to edges and faces based on the array and/or
866         colors that were directly set, as appropriate.
867         """
868         if not self._set_mappable_flags():
869             return
870         # Allow possibility to call 'self.set_array(None)'.
871         if self._A is not None:
872             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)
873             if self._A.ndim > 1 and not isinstance(self, QuadMesh):
874                 raise ValueError('Collections can only map rank 1 arrays')
875             if np.iterable(self._alpha):
876                 if self._alpha.size != self._A.size:
877                     raise ValueError(
878                         f'Data array shape, {self._A.shape} '
879                         'is incompatible with alpha array shape, '
880                         f'{self._alpha.shape}. '
881                         'This can occur with the deprecated '
882                         'behavior of the "flat" shading option, '
883                         'in which a row and/or column of the data '
884                         'array is dropped.')
885                 # pcolormesh, scatter, maybe others flatten their _A
886                 self._alpha = self._alpha.reshape(self._A.shape)
887             self._mapped_colors = self.to_rgba(self._A, self._alpha)
888 
889         if self._face_is_mapped:
890             self._facecolors = self._mapped_colors
891         else:
892             self._set_facecolor(self._original_facecolor)
893         if self._edge_is_mapped:
894             self._edgecolors = self._mapped_colors
895         else:
896             self._set_edgecolor(self._original_edgecolor)
897         self.stale = True
898 
899     def get_fill(self):
900         """Return whether face is colored."""
901         return not cbook._str_lower_equal(self._original_facecolor, "none")
902 
903     def update_from(self, other):
904         """Copy properties from other to self."""
905 
906         artist.Artist.update_from(self, other)
907         self._antialiaseds = other._antialiaseds
908         self._mapped_colors = other._mapped_colors
909         self._edge_is_mapped = other._edge_is_mapped
910         self._original_edgecolor = other._original_edgecolor
911         self._edgecolors = other._edgecolors
912         self._face_is_mapped = other._face_is_mapped
913         self._original_facecolor = other._original_facecolor
914         self._facecolors = other._facecolors
915         self._linewidths = other._linewidths
916         self._linestyles = other._linestyles
917         self._us_linestyles = other._us_linestyles
918         self._pickradius = other._pickradius
919         self._hatch = other._hatch
920 
921         # update_from for scalarmappable
922         self._A = other._A
923         self.norm = other.norm
924         self.cmap = other.cmap
925         self.stale = True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 20:35:21.582 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 20:35:21.582 | INFO     | Search-only: skipping patch selection
2025-10-15 20:35:21.667 | INFO     | Task matplotlib__matplotlib-25079 completed successfully.
2025-10-15 20:35:21.668 | INFO     | No patch generated. You can try running ACR again.
