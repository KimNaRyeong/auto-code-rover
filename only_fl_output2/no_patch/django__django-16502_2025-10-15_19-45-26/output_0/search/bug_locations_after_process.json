[
    {
        "rel_file_path": "django/core/handlers/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/core/handlers/base.py",
        "start": 1,
        "end": 373,
        "class_name": null,
        "method_name": null,
        "code": "1 import asyncio\n2 import logging\n3 import types\n4 \n5 from asgiref.sync import async_to_sync, iscoroutinefunction, sync_to_async\n6 \n7 from django.conf import settings\n8 from django.core.exceptions import ImproperlyConfigured, MiddlewareNotUsed\n9 from django.core.signals import request_finished\n10 from django.db import connections, transaction\n11 from django.urls import get_resolver, set_urlconf\n12 from django.utils.log import log_response\n13 from django.utils.module_loading import import_string\n14 \n15 from .exception import convert_exception_to_response\n16 \n17 logger = logging.getLogger(\"django.request\")\n18 \n19 \n20 class BaseHandler:\n21     _view_middleware = None\n22     _template_response_middleware = None\n23     _exception_middleware = None\n24     _middleware_chain = None\n25 \n26     def load_middleware(self, is_async=False):\n27         \"\"\"\n28         Populate middleware lists from settings.MIDDLEWARE.\n29 \n30         Must be called after the environment is fixed (see __call__ in subclasses).\n31         \"\"\"\n32         self._view_middleware = []\n33         self._template_response_middleware = []\n34         self._exception_middleware = []\n35 \n36         get_response = self._get_response_async if is_async else self._get_response\n37         handler = convert_exception_to_response(get_response)\n38         handler_is_async = is_async\n39         for middleware_path in reversed(settings.MIDDLEWARE):\n40             middleware = import_string(middleware_path)\n41             middleware_can_sync = getattr(middleware, \"sync_capable\", True)\n42             middleware_can_async = getattr(middleware, \"async_capable\", False)\n43             if not middleware_can_sync and not middleware_can_async:\n44                 raise RuntimeError(\n45                     \"Middleware %s must have at least one of \"\n46                     \"sync_capable/async_capable set to True.\" % middleware_path\n47                 )\n48             elif not handler_is_async and middleware_can_sync:\n49                 middleware_is_async = False\n50             else:\n51                 middleware_is_async = middleware_can_async\n52             try:\n53                 # Adapt handler, if needed.\n54                 adapted_handler = self.adapt_method_mode(\n55                     middleware_is_async,\n56                     handler,\n57                     handler_is_async,\n58                     debug=settings.DEBUG,\n59                     name=\"middleware %s\" % middleware_path,\n60                 )\n61                 mw_instance = middleware(adapted_handler)\n62             except MiddlewareNotUsed as exc:\n63                 if settings.DEBUG:\n64                     if str(exc):\n65                         logger.debug(\"MiddlewareNotUsed(%r): %s\", middleware_path, exc)\n66                     else:\n67                         logger.debug(\"MiddlewareNotUsed: %r\", middleware_path)\n68                 continue\n69             else:\n70                 handler = adapted_handler\n71 \n72             if mw_instance is None:\n73                 raise ImproperlyConfigured(\n74                     \"Middleware factory %s returned None.\" % middleware_path\n75                 )\n76 \n77             if hasattr(mw_instance, \"process_view\"):\n78                 self._view_middleware.insert(\n79                     0,\n80                     self.adapt_method_mode(is_async, mw_instance.process_view),\n81                 )\n82             if hasattr(mw_instance, \"process_template_response\"):\n83                 self._template_response_middleware.append(\n84                     self.adapt_method_mode(\n85                         is_async, mw_instance.process_template_response\n86                     ),\n87                 )\n88             if hasattr(mw_instance, \"process_exception\"):\n89                 # The exception-handling stack is still always synchronous for\n90                 # now, so adapt that way.\n91                 self._exception_middleware.append(\n92                     self.adapt_method_mode(False, mw_instance.process_exception),\n93                 )\n94 \n95             handler = convert_exception_to_response(mw_instance)\n96             handler_is_async = middleware_is_async\n97 \n98         # Adapt the top of the stack, if needed.\n99         handler = self.adapt_method_mode(is_async, handler, handler_is_async)\n100         # We only assign to this when initialization is complete as it is used\n101         # as a flag for initialization being complete.\n102         self._middleware_chain = handler\n103 \n104     def adapt_method_mode(\n105         self,\n106         is_async,\n107         method,\n108         method_is_async=None,\n109         debug=False,\n110         name=None,\n111     ):\n112         \"\"\"\n113         Adapt a method to be in the correct \"mode\":\n114         - If is_async is False:\n115           - Synchronous methods are left alone\n116           - Asynchronous methods are wrapped with async_to_sync\n117         - If is_async is True:\n118           - Synchronous methods are wrapped with sync_to_async()\n119           - Asynchronous methods are left alone\n120         \"\"\"\n121         if method_is_async is None:\n122             method_is_async = iscoroutinefunction(method)\n123         if debug and not name:\n124             name = name or \"method %s()\" % method.__qualname__\n125         if is_async:\n126             if not method_is_async:\n127                 if debug:\n128                     logger.debug(\"Synchronous handler adapted for %s.\", name)\n129                 return sync_to_async(method, thread_sensitive=True)\n130         elif method_is_async:\n131             if debug:\n132                 logger.debug(\"Asynchronous handler adapted for %s.\", name)\n133             return async_to_sync(method)\n134         return method\n135 \n136     def get_response(self, request):\n137         \"\"\"Return an HttpResponse object for the given HttpRequest.\"\"\"\n138         # Setup default url resolver for this thread\n139         set_urlconf(settings.ROOT_URLCONF)\n140         response = self._middleware_chain(request)\n141         response._resource_closers.append(request.close)\n142         if response.status_code >= 400:\n143             log_response(\n144                 \"%s: %s\",\n145                 response.reason_phrase,\n146                 request.path,\n147                 response=response,\n148                 request=request,\n149             )\n150         return response\n151 \n152     async def get_response_async(self, request):\n153         \"\"\"\n154         Asynchronous version of get_response.\n155 \n156         Funneling everything, including WSGI, into a single async\n157         get_response() is too slow. Avoid the context switch by using\n158         a separate async response path.\n159         \"\"\"\n160         # Setup default url resolver for this thread.\n161         set_urlconf(settings.ROOT_URLCONF)\n162         response = await self._middleware_chain(request)\n163         response._resource_closers.append(request.close)\n164         if response.status_code >= 400:\n165             await sync_to_async(log_response, thread_sensitive=False)(\n166                 \"%s: %s\",\n167                 response.reason_phrase,\n168                 request.path,\n169                 response=response,\n170                 request=request,\n171             )\n172         return response\n173 \n174     def _get_response(self, request):\n175         \"\"\"\n176         Resolve and call the view, then apply view, exception, and\n177         template_response middleware. This method is everything that happens\n178         inside the request/response middleware.\n179         \"\"\"\n180         response = None\n181         callback, callback_args, callback_kwargs = self.resolve_request(request)\n182 \n183         # Apply view middleware\n184         for middleware_method in self._view_middleware:\n185             response = middleware_method(\n186                 request, callback, callback_args, callback_kwargs\n187             )\n188             if response:\n189                 break\n190 \n191         if response is None:\n192             wrapped_callback = self.make_view_atomic(callback)\n193             # If it is an asynchronous view, run it in a subthread.\n194             if iscoroutinefunction(wrapped_callback):\n195                 wrapped_callback = async_to_sync(wrapped_callback)\n196             try:\n197                 response = wrapped_callback(request, *callback_args, **callback_kwargs)\n198             except Exception as e:\n199                 response = self.process_exception_by_middleware(e, request)\n200                 if response is None:\n201                     raise\n202 \n203         # Complain if the view returned None (a common error).\n204         self.check_response(response, callback)\n205 \n206         # If the response supports deferred rendering, apply template\n207         # response middleware and then render the response\n208         if hasattr(response, \"render\") and callable(response.render):\n209             for middleware_method in self._template_response_middleware:\n210                 response = middleware_method(request, response)\n211                 # Complain if the template response middleware returned None\n212                 # (a common error).\n213                 self.check_response(\n214                     response,\n215                     middleware_method,\n216                     name=\"%s.process_template_response\"\n217                     % (middleware_method.__self__.__class__.__name__,),\n218                 )\n219             try:\n220                 response = response.render()\n221             except Exception as e:\n222                 response = self.process_exception_by_middleware(e, request)\n223                 if response is None:\n224                     raise\n225 \n226         return response\n227 \n228     async def _get_response_async(self, request):\n229         \"\"\"\n230         Resolve and call the view, then apply view, exception, and\n231         template_response middleware. This method is everything that happens\n232         inside the request/response middleware.\n233         \"\"\"\n234         response = None\n235         callback, callback_args, callback_kwargs = self.resolve_request(request)\n236 \n237         # Apply view middleware.\n238         for middleware_method in self._view_middleware:\n239             response = await middleware_method(\n240                 request, callback, callback_args, callback_kwargs\n241             )\n242             if response:\n243                 break\n244 \n245         if response is None:\n246             wrapped_callback = self.make_view_atomic(callback)\n247             # If it is a synchronous view, run it in a subthread\n248             if not iscoroutinefunction(wrapped_callback):\n249                 wrapped_callback = sync_to_async(\n250                     wrapped_callback, thread_sensitive=True\n251                 )\n252             try:\n253                 response = await wrapped_callback(\n254                     request, *callback_args, **callback_kwargs\n255                 )\n256             except Exception as e:\n257                 response = await sync_to_async(\n258                     self.process_exception_by_middleware,\n259                     thread_sensitive=True,\n260                 )(e, request)\n261                 if response is None:\n262                     raise\n263 \n264         # Complain if the view returned None or an uncalled coroutine.\n265         self.check_response(response, callback)\n266 \n267         # If the response supports deferred rendering, apply template\n268         # response middleware and then render the response\n269         if hasattr(response, \"render\") and callable(response.render):\n270             for middleware_method in self._template_response_middleware:\n271                 response = await middleware_method(request, response)\n272                 # Complain if the template response middleware returned None or\n273                 # an uncalled coroutine.\n274                 self.check_response(\n275                     response,\n276                     middleware_method,\n277                     name=\"%s.process_template_response\"\n278                     % (middleware_method.__self__.__class__.__name__,),\n279                 )\n280             try:\n281                 if iscoroutinefunction(response.render):\n282                     response = await response.render()\n283                 else:\n284                     response = await sync_to_async(\n285                         response.render, thread_sensitive=True\n286                     )()\n287             except Exception as e:\n288                 response = await sync_to_async(\n289                     self.process_exception_by_middleware,\n290                     thread_sensitive=True,\n291                 )(e, request)\n292                 if response is None:\n293                     raise\n294 \n295         # Make sure the response is not a coroutine\n296         if asyncio.iscoroutine(response):\n297             raise RuntimeError(\"Response is still a coroutine.\")\n298         return response\n299 \n300     def resolve_request(self, request):\n301         \"\"\"\n302         Retrieve/set the urlconf for the request. Return the view resolved,\n303         with its args and kwargs.\n304         \"\"\"\n305         # Work out the resolver.\n306         if hasattr(request, \"urlconf\"):\n307             urlconf = request.urlconf\n308             set_urlconf(urlconf)\n309             resolver = get_resolver(urlconf)\n310         else:\n311             resolver = get_resolver()\n312         # Resolve the view, and assign the match object back to the request.\n313         resolver_match = resolver.resolve(request.path_info)\n314         request.resolver_match = resolver_match\n315         return resolver_match\n316 \n317     def check_response(self, response, callback, name=None):\n318         \"\"\"\n319         Raise an error if the view returned None or an uncalled coroutine.\n320         \"\"\"\n321         if not (response is None or asyncio.iscoroutine(response)):\n322             return\n323         if not name:\n324             if isinstance(callback, types.FunctionType):  # FBV\n325                 name = \"The view %s.%s\" % (callback.__module__, callback.__name__)\n326             else:  # CBV\n327                 name = \"The view %s.%s.__call__\" % (\n328                     callback.__module__,\n329                     callback.__class__.__name__,\n330                 )\n331         if response is None:\n332             raise ValueError(\n333                 \"%s didn't return an HttpResponse object. It returned None \"\n334                 \"instead.\" % name\n335             )\n336         elif asyncio.iscoroutine(response):\n337             raise ValueError(\n338                 \"%s didn't return an HttpResponse object. It returned an \"\n339                 \"unawaited coroutine instead. You may need to add an 'await' \"\n340                 \"into your view.\" % name\n341             )\n342 \n343     # Other utility methods.\n344 \n345     def make_view_atomic(self, view):\n346         non_atomic_requests = getattr(view, \"_non_atomic_requests\", set())\n347         for alias, settings_dict in connections.settings.items():\n348             if settings_dict[\"ATOMIC_REQUESTS\"] and alias not in non_atomic_requests:\n349                 if iscoroutinefunction(view):\n350                     raise RuntimeError(\n351                         \"You cannot use ATOMIC_REQUESTS with async views.\"\n352                     )\n353                 view = transaction.atomic(using=alias)(view)\n354         return view\n355 \n356     def process_exception_by_middleware(self, exception, request):\n357         \"\"\"\n358         Pass the exception to the exception middleware. If no middleware\n359         return a response for this exception, return None.\n360         \"\"\"\n361         for middleware_method in self._exception_middleware:\n362             response = middleware_method(request, exception)\n363             if response:\n364                 return response\n365         return None\n366 \n367 \n368 def reset_urlconf(sender, **kwargs):\n369     \"\"\"Reset the URLconf after each request is finished.\"\"\"\n370     set_urlconf(None)\n371 \n372 \n373 request_finished.connect(reset_urlconf)\n",
        "intended_behavior": "Detects when a response is the result of a HEAD request and ensures that before such a response is finalized and sent back to the client, its body is stripped or omitted, aligning with HTTP specification requirements for HEAD responses. This adjustment should not alter the existing functionality for other types of requests but should specifically address and rectify the handling of HEAD requests to prevent sending a response body, thus maintaining compliance with the stated HTTP standard."
    }
]