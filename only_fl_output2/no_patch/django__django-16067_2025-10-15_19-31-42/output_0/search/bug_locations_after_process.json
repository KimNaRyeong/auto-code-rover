[
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 402,
        "end": 417,
        "class_name": "DecimalField",
        "method_name": "to_python",
        "code": "402     def to_python(self, value):\n403         \"\"\"\n404         Validate that the input is a decimal number. Return a Decimal\n405         instance or None for empty values. Ensure that there are no more\n406         than max_digits in the number and no more than decimal_places digits\n407         after the decimal point.\n408         \"\"\"\n409         if value in self.empty_values:\n410             return None\n411         if self.localize:\n412             value = formats.sanitize_separators(value)\n413         try:\n414             value = Decimal(str(value))\n415         except DecimalException:\n416             raise ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")\n417         return value\n",
        "intended_behavior": "The `to_python` method should be enhanced to gracefully handle and validate decimal numbers expressed in scientific notation, specifically the representation of zero (e.g., '0E+1', '0E+2'). This enhancement entails recognizing such inputs as valid representations of zero and ensuring they do not raise a `ValidationError` when they meet the field's defined `max_digits` and `decimal_places` criteria. It should correctly parse scientific notation before applying any digit and decimal place constraints. This would involve normalizing the decimal to its expanded form or directly assessing its equivalency to zero (since any scientific notation of zero is still zero). Implementing this change should preserve the existing validation functionality while extending support for scientifically notated zero inputs."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 1702,
        "end": 1722,
        "class_name": "DecimalField",
        "method_name": "to_python",
        "code": "1702     def to_python(self, value):\n1703         if value is None:\n1704             return value\n1705         try:\n1706             if isinstance(value, float):\n1707                 decimal_value = self.context.create_decimal_from_float(value)\n1708             else:\n1709                 decimal_value = decimal.Decimal(value)\n1710         except (decimal.InvalidOperation, TypeError, ValueError):\n1711             raise exceptions.ValidationError(\n1712                 self.error_messages[\"invalid\"],\n1713                 code=\"invalid\",\n1714                 params={\"value\": value},\n1715             )\n1716         if not decimal_value.is_finite():\n1717             raise exceptions.ValidationError(\n1718                 self.error_messages[\"invalid\"],\n1719                 code=\"invalid\",\n1720                 params={\"value\": value},\n1721             )\n1722         return decimal_value\n",
        "intended_behavior": "The `to_python` method should be enhanced to gracefully handle and validate decimal numbers expressed in scientific notation, specifically the representation of zero (e.g., '0E+1', '0E+2'). This enhancement entails recognizing such inputs as valid representations of zero and ensuring they do not raise a `ValidationError` when they meet the field's defined `max_digits` and `decimal_places` criteria. It should correctly parse scientific notation before applying any digit and decimal place constraints. This would involve normalizing the decimal to its expanded form or directly assessing its equivalency to zero (since any scientific notation of zero is still zero). Implementing this change should preserve the existing validation functionality while extending support for scientifically notated zero inputs."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/forms/fields.py",
        "start": 384,
        "end": 440,
        "class_name": "DecimalField",
        "method_name": null,
        "code": "384 class DecimalField(IntegerField):\n385     default_error_messages = {\n386         \"invalid\": _(\"Enter a number.\"),\n387     }\n388 \n389     def __init__(\n390         self,\n391         *,\n392         max_value=None,\n393         min_value=None,\n394         max_digits=None,\n395         decimal_places=None,\n396         **kwargs,\n397     ):\n398         self.max_digits, self.decimal_places = max_digits, decimal_places\n399         super().__init__(max_value=max_value, min_value=min_value, **kwargs)\n400         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))\n401 \n402     def to_python(self, value):\n403         \"\"\"\n404         Validate that the input is a decimal number. Return a Decimal\n405         instance or None for empty values. Ensure that there are no more\n406         than max_digits in the number and no more than decimal_places digits\n407         after the decimal point.\n408         \"\"\"\n409         if value in self.empty_values:\n410             return None\n411         if self.localize:\n412             value = formats.sanitize_separators(value)\n413         try:\n414             value = Decimal(str(value))\n415         except DecimalException:\n416             raise ValidationError(self.error_messages[\"invalid\"], code=\"invalid\")\n417         return value\n418 \n419     def validate(self, value):\n420         super().validate(value)\n421         if value in self.empty_values:\n422             return\n423         if not value.is_finite():\n424             raise ValidationError(\n425                 self.error_messages[\"invalid\"],\n426                 code=\"invalid\",\n427                 params={\"value\": value},\n428             )\n429 \n430     def widget_attrs(self, widget):\n431         attrs = super().widget_attrs(widget)\n432         if isinstance(widget, NumberInput) and \"step\" not in widget.attrs:\n433             if self.decimal_places is not None:\n434                 # Use exponential notation for small values since they might\n435                 # be parsed as 0 otherwise. ref #20765\n436                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()\n437             else:\n438                 step = \"any\"\n439             attrs.setdefault(\"step\", step)\n440         return attrs\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/models/fields/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/__init__.py",
        "start": 1591,
        "end": 1741,
        "class_name": "DecimalField",
        "method_name": null,
        "code": "1591 class DecimalField(Field):\n1592     empty_strings_allowed = False\n1593     default_error_messages = {\n1594         \"invalid\": _(\"\u201c%(value)s\u201d value must be a decimal number.\"),\n1595     }\n1596     description = _(\"Decimal number\")\n1597 \n1598     def __init__(\n1599         self,\n1600         verbose_name=None,\n1601         name=None,\n1602         max_digits=None,\n1603         decimal_places=None,\n1604         **kwargs,\n1605     ):\n1606         self.max_digits, self.decimal_places = max_digits, decimal_places\n1607         super().__init__(verbose_name, name, **kwargs)\n1608 \n1609     def check(self, **kwargs):\n1610         errors = super().check(**kwargs)\n1611 \n1612         digits_errors = [\n1613             *self._check_decimal_places(),\n1614             *self._check_max_digits(),\n1615         ]\n1616         if not digits_errors:\n1617             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1618         else:\n1619             errors.extend(digits_errors)\n1620         return errors\n1621 \n1622     def _check_decimal_places(self):\n1623         try:\n1624             decimal_places = int(self.decimal_places)\n1625             if decimal_places < 0:\n1626                 raise ValueError()\n1627         except TypeError:\n1628             return [\n1629                 checks.Error(\n1630                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1631                     obj=self,\n1632                     id=\"fields.E130\",\n1633                 )\n1634             ]\n1635         except ValueError:\n1636             return [\n1637                 checks.Error(\n1638                     \"'decimal_places' must be a non-negative integer.\",\n1639                     obj=self,\n1640                     id=\"fields.E131\",\n1641                 )\n1642             ]\n1643         else:\n1644             return []\n1645 \n1646     def _check_max_digits(self):\n1647         try:\n1648             max_digits = int(self.max_digits)\n1649             if max_digits <= 0:\n1650                 raise ValueError()\n1651         except TypeError:\n1652             return [\n1653                 checks.Error(\n1654                     \"DecimalFields must define a 'max_digits' attribute.\",\n1655                     obj=self,\n1656                     id=\"fields.E132\",\n1657                 )\n1658             ]\n1659         except ValueError:\n1660             return [\n1661                 checks.Error(\n1662                     \"'max_digits' must be a positive integer.\",\n1663                     obj=self,\n1664                     id=\"fields.E133\",\n1665                 )\n1666             ]\n1667         else:\n1668             return []\n1669 \n1670     def _check_decimal_places_and_max_digits(self, **kwargs):\n1671         if int(self.decimal_places) > int(self.max_digits):\n1672             return [\n1673                 checks.Error(\n1674                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1675                     obj=self,\n1676                     id=\"fields.E134\",\n1677                 )\n1678             ]\n1679         return []\n1680 \n1681     @cached_property\n1682     def validators(self):\n1683         return super().validators + [\n1684             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1685         ]\n1686 \n1687     @cached_property\n1688     def context(self):\n1689         return decimal.Context(prec=self.max_digits)\n1690 \n1691     def deconstruct(self):\n1692         name, path, args, kwargs = super().deconstruct()\n1693         if self.max_digits is not None:\n1694             kwargs[\"max_digits\"] = self.max_digits\n1695         if self.decimal_places is not None:\n1696             kwargs[\"decimal_places\"] = self.decimal_places\n1697         return name, path, args, kwargs\n1698 \n1699     def get_internal_type(self):\n1700         return \"DecimalField\"\n1701 \n1702     def to_python(self, value):\n1703         if value is None:\n1704             return value\n1705         try:\n1706             if isinstance(value, float):\n1707                 decimal_value = self.context.create_decimal_from_float(value)\n1708             else:\n1709                 decimal_value = decimal.Decimal(value)\n1710         except (decimal.InvalidOperation, TypeError, ValueError):\n1711             raise exceptions.ValidationError(\n1712                 self.error_messages[\"invalid\"],\n1713                 code=\"invalid\",\n1714                 params={\"value\": value},\n1715             )\n1716         if not decimal_value.is_finite():\n1717             raise exceptions.ValidationError(\n1718                 self.error_messages[\"invalid\"],\n1719                 code=\"invalid\",\n1720                 params={\"value\": value},\n1721             )\n1722         return decimal_value\n1723 \n1724     def get_db_prep_save(self, value, connection):\n1725         return connection.ops.adapt_decimalfield_value(\n1726             self.to_python(value), self.max_digits, self.decimal_places\n1727         )\n1728 \n1729     def get_prep_value(self, value):\n1730         value = super().get_prep_value(value)\n1731         return self.to_python(value)\n1732 \n1733     def formfield(self, **kwargs):\n1734         return super().formfield(\n1735             **{\n1736                 \"max_digits\": self.max_digits,\n1737                 \"decimal_places\": self.decimal_places,\n1738                 \"form_class\": forms.DecimalField,\n1739                 **kwargs,\n1740             }\n1741         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]