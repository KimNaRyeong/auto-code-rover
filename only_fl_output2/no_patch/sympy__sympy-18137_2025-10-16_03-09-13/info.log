2025-10-16 03:09:13.443 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 03:09:22.328 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=891, output_tokens=12, cost=0.009270
2025-10-16 03:09:29.722 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1071, output_tokens=269, cost=0.018780
2025-10-16 03:09:31.283 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:09:37.412 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1127, output_tokens=281, cost=0.019700
2025-10-16 03:09:37.419 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:09:39.762 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=635, output_tokens=60, cost=0.008150
2025-10-16 03:09:39.763 | DEBUG    | Extracted a valid json.
2025-10-16 03:09:39.764 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Range\")",
        "search_method_in_class(\"intersect\", \"Range\")",
        "search_class(\"FiniteSet\")",
        "search_code(\"cannot determine truth value of Relational\")"
    ],
    "bug_locations": []
}
2025-10-16 03:09:39.858 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 03:09:39.859 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 03:09:57.046 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2378, output_tokens=718, cost=0.045320
2025-10-16 03:09:57.058 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:10:07.584 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3312, output_tokens=385, cost=0.044670
2025-10-16 03:10:07.593 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:10:16.742 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=335, cost=0.017440
2025-10-16 03:10:16.743 | DEBUG    | Extracted a valid json.
2025-10-16 03:10:16.744 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/sets/fancysets.py",
            "class": "Range",
            "method": "_contains",
            "intended_behavior": "The `_contains` method in the `Range` class should be adjusted to handle symbolic variables more gracefully. When the method encounters a symbolic variable, instead of attempting to evaluate its truthiness directly—which leads to the TypeError—it should return a symbolic condition that represents whether the variable is contained within the range. This would likely involve enhancing the method to return unevaluated expressions or conditions when the direct truth value cannot be determined due to the presence of symbols. The specifics of the implementation will depend on how `sympy` expects to handle such symbolic logic internally."
        },
        {
            "file": "sympy/core/relational.py",
            "function": "__nonzero__ (or `__bool__` in Python 3)",
            "intended_behavior": "While the direct modification in `__nonzero__` (or `__bool__` in Python 3) might not be necessary for resolving the issue, understanding and possibly enhancing how relational expressions involving symbols are handled might provide a workaround or ancillary solution. The intended behavior, though, is not to alter the raising of the TypeError but to ensure that operations leading to this function account for symbolic cases differently. Therefore, the solution might not be in changing this function but ensuring that set operations like `intersect` do not rely on operations that inherently cannot be performed with symbolic arguments without explicit evaluation strategies in place."
        }
    ]
}
2025-10-16 03:10:16.749 | DEBUG    | Found override of _contains in Set
2025-10-16 03:10:16.749 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x7fd54d722c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x7fd45b357080>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x7fd45d67e3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x7fd45b357080>, <app.raw_tasks.RawSweTask object at 0x7fd45b3570b0>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x7fd45d67e480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x7fd45b291ca0>
    └ <function run_task_in_subprocess at 0x7fd45d67e660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x7fd45b291ca0>
    │        │      └ <function run_raw_task at 0x7fd45d67e700>
    │        └ <function ProcessPoolExecutor.submit at 0x7fd54d336020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x7fd54d335da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x7fd54d335ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x7fd54d335f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x7fd54d4fcea0>
    └ <ForkProcess name='ForkProcess-470' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-470' parent=188003 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x7fd54d56e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-470' parent=188003 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-470' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-470' parent=188003 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-470' parent=188003 started>
    │    └ <function Popen._launch at 0x7fd45b6737e0>
    └ <multiprocessing.popen_fork.Popen object at 0x7fd45c0ad6d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x7fd54d4fd8a0>
           └ <ForkProcess name='ForkProcess-470' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x7fd54d4fce00>
    └ <ForkProcess name='ForkProcess-470' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-470' parent=188003 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x7fd45d89a150>, <multiprocessing.queues.SimpleQueue object at 0x7fd45e5e9a...
    │    │        └ <ForkProcess name='ForkProcess-470' parent=188003 started>
    │    └ <function _process_worker at 0x7fd54d3351c0>
    └ <ForkProcess name='ForkProcess-470' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x7fd45c961b20>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>
        │         └ <function run_raw_task at 0x7fd45d67e700>
        └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output2/sympy__sympy-18137_2025-10-16_03-09-13'
             │            │    └ <function RawSweTask.to_task at 0x7fd45d67d6c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x7fd45c961b20>
             └ <function do_inference at 0x7fd45d67e8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x7fd45d8e0400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7fd45dd084a0>
       │                 │         │            └ SweTask(task_id='sympy__sympy-18137', problem_statement='Range(1).intersect(FiniteSet(n)) raises TypeError: cannot determine ...
       │                 │         └ <app.manage.ProjectApiManager object at 0x7fd54c9f17f0>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output2/sympy__sympy-18137_2025-10-16_03-09-13/output_0')
       └ <function _run_one_task at 0x7fd45d8e18a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x7fd45d995bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x7fd45d8dd3a0>
                                  └ <app.manage.ProjectApiManager object at 0x7fd54c9f17f0>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'sympy/sets/fancysets.py', 'class': 'Range', 'method': '_contains', 'intended_behavior': 'The `_contains` method in ...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x7fd45d9958a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x7fd45d6433b0>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x7fd45d8dd3a0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '_contains'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/sets/fancy...
    │    │                      │   └ 'Range'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/sets/fancy...
    │    └ <function SearchBackend._get_inherited_methods at 0x7fd45d995800>
    └ <app.search.search_backend.SearchBackend object at 0x7fd45d6433b0>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'Set', 'method_name': '_contains'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x7fd45d994f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x7fd45d6433b0>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x7fd45d6433b0>, {'class_name': 'Set', 'method_name': '_contains'})
           └ <function SearchBackend.search_method_in_class at 0x7fd45d994ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-16 03:10:16.758 | DEBUG    | Bug location extracted successfully: [<file>sympy/sets/fancysets.py</file>
<class>Range</class>
<method>_contains</method>
<code>
670     def _contains(self, other):
671         if not self:
672             return S.false
673         if other.is_infinite:
674             return S.false
675         if not other.is_integer:
676             return other.is_integer
677         if self.has(Symbol):
678             try:
679                 _ = self.size  # validate
680             except ValueError:
681                 return
682         if self.start.is_finite:
683             ref = self.start
684         elif self.stop.is_finite:
685             ref = self.stop
686         else:
687             return other.is_Integer
688         if (ref - other) % self.step:  # off sequence
689             return S.false
690         return _sympify(other >= self.inf and other <= self.sup)

</code><intended_behavior>The `_contains` method in the `Range` class should be adjusted to handle symbolic variables more gracefully. When the method encounters a symbolic variable, instead of attempting to evaluate its truthiness directly—which leads to the TypeError—it should return a symbolic condition that represents whether the variable is contained within the range. This would likely involve enhancing the method to return unevaluated expressions or conditions when the direct truth value cannot be determined due to the presence of symbols. The specifics of the implementation will depend on how `sympy` expects to handle such symbolic logic internally.</intended_behavior>, <file>sympy/sets/fancysets.py</file>
<class>Range</class>
<method>None</method>
<code>
499 class Range(Set):
500     """
501     Represents a range of integers. Can be called as Range(stop),
502     Range(start, stop), or Range(start, stop, step); when stop is
503     not given it defaults to 1.
504 
505     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value
506     (juse as for Python ranges) is not included in the Range values.
507 
508         >>> from sympy import Range
509         >>> list(Range(3))
510         [0, 1, 2]
511 
512     The step can also be negative:
513 
514         >>> list(Range(10, 0, -2))
515         [10, 8, 6, 4, 2]
516 
517     The stop value is made canonical so equivalent ranges always
518     have the same args:
519 
520         >>> Range(0, 10, 3)
521         Range(0, 12, 3)
522 
523     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the
524     set (``Range`` is always a subset of ``Integers``). If the starting point
525     is infinite, then the final value is ``stop - step``. To iterate such a
526     range, it needs to be reversed:
527 
528         >>> from sympy import oo
529         >>> r = Range(-oo, 1)
530         >>> r[-1]
531         0
532         >>> next(iter(r))
533         Traceback (most recent call last):
534         ...
535         TypeError: Cannot iterate over Range with infinite start
536         >>> next(iter(r.reversed))
537         0
538 
539     Although Range is a set (and supports the normal set
540     operations) it maintains the order of the elements and can
541     be used in contexts where `range` would be used.
542 
543         >>> from sympy import Interval
544         >>> Range(0, 10, 2).intersect(Interval(3, 7))
545         Range(4, 8, 2)
546         >>> list(_)
547         [4, 6]
548 
549     Although slicing of a Range will always return a Range -- possibly
550     empty -- an empty set will be returned from any intersection that
551     is empty:
552 
553         >>> Range(3)[:0]
554         Range(0, 0, 1)
555         >>> Range(3).intersect(Interval(4, oo))
556         EmptySet
557         >>> Range(3).intersect(Range(4, oo))
558         EmptySet
559 
560     Range will accept symbolic arguments but has very limited support
561     for doing anything other than displaying the Range:
562 
563         >>> from sympy import Symbol, pprint
564         >>> from sympy.abc import i, j, k
565         >>> Range(i, j, k).start
566         i
567         >>> Range(i, j, k).inf
568         Traceback (most recent call last):
569         ...
570         ValueError: invalid method for symbolic range
571 
572     Better success will be had when using integer symbols:
573 
574         >>> n = Symbol('n', integer=True)
575         >>> r = Range(n, n + 20, 3)
576         >>> r.inf
577         n
578         >>> pprint(r)
579         {n, n + 3, ..., n + 17}
580     """
581 
582     is_iterable = True
583 
584     def __new__(cls, *args):
585         from sympy.functions.elementary.integers import ceiling
586         if len(args) == 1:
587             if isinstance(args[0], range):
588                 raise TypeError(
589                     'use sympify(%s) to convert range to Range' % args[0])
590 
591         # expand range
592         slc = slice(*args)
593 
594         if slc.step == 0:
595             raise ValueError("step cannot be 0")
596 
597         start, stop, step = slc.start or 0, slc.stop, slc.step or 1
598         try:
599             ok = []
600             for w in (start, stop, step):
601                 w = sympify(w)
602                 if w in [S.NegativeInfinity, S.Infinity] or (
603                         w.has(Symbol) and w.is_integer != False):
604                     ok.append(w)
605                 elif not w.is_Integer:
606                     raise ValueError
607                 else:
608                     ok.append(w)
609         except ValueError:
610             raise ValueError(filldedent('''
611     Finite arguments to Range must be integers; `imageset` can define
612     other cases, e.g. use `imageset(i, i/10, Range(3))` to give
613     [0, 1/10, 1/5].'''))
614         start, stop, step = ok
615 
616         null = False
617         if any(i.has(Symbol) for i in (start, stop, step)):
618             if start == stop:
619                 null = True
620             else:
621                 end = stop
622         elif start.is_infinite:
623             span = step*(stop - start)
624             if span is S.NaN or span <= 0:
625                 null = True
626             elif step.is_Integer and stop.is_infinite and abs(step) != 1:
627                 raise ValueError(filldedent('''
628                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))
629             else:
630                 end = stop
631         else:
632             oostep = step.is_infinite
633             if oostep:
634                 step = S.One if step > 0 else S.NegativeOne
635             n = ceiling((stop - start)/step)
636             if n <= 0:
637                 null = True
638             elif oostep:
639                 end = start + 1
640                 step = S.One  # make it a canonical single step
641             else:
642                 end = start + n*step
643         if null:
644             start = end = S.Zero
645             step = S.One
646         return Basic.__new__(cls, start, end, step)
647 
648     start = property(lambda self: self.args[0])
649     stop = property(lambda self: self.args[1])
650     step = property(lambda self: self.args[2])
651 
652     @property
653     def reversed(self):
654         """Return an equivalent Range in the opposite order.
655 
656         Examples
657         ========
658 
659         >>> from sympy import Range
660         >>> Range(10).reversed
661         Range(9, -1, -1)
662         """
663         if self.has(Symbol):
664             _ = self.size  # validate
665         if not self:
666             return self
667         return self.func(
668             self.stop - self.step, self.start - self.step, -self.step)
669 
670     def _contains(self, other):
671         if not self:
672             return S.false
673         if other.is_infinite:
674             return S.false
675         if not other.is_integer:
676             return other.is_integer
677         if self.has(Symbol):
678             try:
679                 _ = self.size  # validate
680             except ValueError:
681                 return
682         if self.start.is_finite:
683             ref = self.start
684         elif self.stop.is_finite:
685             ref = self.stop
686         else:
687             return other.is_Integer
688         if (ref - other) % self.step:  # off sequence
689             return S.false
690         return _sympify(other >= self.inf and other <= self.sup)
691 
692     def __iter__(self):
693         if self.has(Symbol):
694             _ = self.size  # validate
695         if self.start in [S.NegativeInfinity, S.Infinity]:
696             raise TypeError("Cannot iterate over Range with infinite start")
697         elif self:
698             i = self.start
699             step = self.step
700 
701             while True:
702                 if (step > 0 and not (self.start <= i < self.stop)) or \
703                    (step < 0 and not (self.stop < i <= self.start)):
704                     break
705                 yield i
706                 i += step
707 
708     def __len__(self):
709         rv = self.size
710         if rv is S.Infinity:
711             raise ValueError('Use .size to get the length of an infinite Range')
712         return int(rv)
713 
714     @property
715     def size(self):
716         if not self:
717             return S.Zero
718         dif = self.stop - self.start
719         if self.has(Symbol):
720             if dif.has(Symbol) or self.step.has(Symbol) or (
721                     not self.start.is_integer and not self.stop.is_integer):
722                 raise ValueError('invalid method for symbolic range')
723         if dif.is_infinite:
724             return S.Infinity
725         return Integer(abs(dif//self.step))
726 
727     def __nonzero__(self):
728         return self.start != self.stop
729 
730     __bool__ = __nonzero__
731 
732     def __getitem__(self, i):
733         from sympy.functions.elementary.integers import ceiling
734         ooslice = "cannot slice from the end with an infinite value"
735         zerostep = "slice step cannot be zero"
736         # if we had to take every other element in the following
737         # oo, ..., 6, 4, 2, 0
738         # we might get oo, ..., 4, 0 or oo, ..., 6, 2
739         ambiguous = "cannot unambiguously re-stride from the end " + \
740             "with an infinite value"
741         if isinstance(i, slice):
742             if self.size.is_finite:  # validates, too
743                 start, stop, step = i.indices(self.size)
744                 n = ceiling((stop - start)/step)
745                 if n <= 0:
746                     return Range(0)
747                 canonical_stop = start + n*step
748                 end = canonical_stop - step
749                 ss = step*self.step
750                 return Range(self[start], self[end] + ss, ss)
751             else:  # infinite Range
752                 start = i.start
753                 stop = i.stop
754                 if i.step == 0:
755                     raise ValueError(zerostep)
756                 step = i.step or 1
757                 ss = step*self.step
758                 #---------------------
759                 # handle infinite on right
760                 #   e.g. Range(0, oo) or Range(0, -oo, -1)
761                 # --------------------
762                 if self.stop.is_infinite:
763                     # start and stop are not interdependent --
764                     # they only depend on step --so we use the
765                     # equivalent reversed values
766                     return self.reversed[
767                         stop if stop is None else -stop + 1:
768                         start if start is None else -start:
769                         step].reversed
770                 #---------------------
771                 # handle infinite on the left
772                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)
773                 # --------------------
774                 # consider combinations of
775                 # start/stop {== None, < 0, == 0, > 0} and
776                 # step {< 0, > 0}
777                 if start is None:
778                     if stop is None:
779                         if step < 0:
780                             return Range(self[-1], self.start, ss)
781                         elif step > 1:
782                             raise ValueError(ambiguous)
783                         else:  # == 1
784                             return self
785                     elif stop < 0:
786                         if step < 0:
787                             return Range(self[-1], self[stop], ss)
788                         else:  # > 0
789                             return Range(self.start, self[stop], ss)
790                     elif stop == 0:
791                         if step > 0:
792                             return Range(0)
793                         else:  # < 0
794                             raise ValueError(ooslice)
795                     elif stop == 1:
796                         if step > 0:
797                             raise ValueError(ooslice)  # infinite singleton
798                         else:  # < 0
799                             raise ValueError(ooslice)
800                     else:  # > 1
801                         raise ValueError(ooslice)
802                 elif start < 0:
803                     if stop is None:
804                         if step < 0:
805                             return Range(self[start], self.start, ss)
806                         else:  # > 0
807                             return Range(self[start], self.stop, ss)
808                     elif stop < 0:
809                         return Range(self[start], self[stop], ss)
810                     elif stop == 0:
811                         if step < 0:
812                             raise ValueError(ooslice)
813                         else:  # > 0
814                             return Range(0)
815                     elif stop > 0:
816                         raise ValueError(ooslice)
817                 elif start == 0:
818                     if stop is None:
819                         if step < 0:
820                             raise ValueError(ooslice)  # infinite singleton
821                         elif step > 1:
822                             raise ValueError(ambiguous)
823                         else:  # == 1
824                             return self
825                     elif stop < 0:
826                         if step > 1:
827                             raise ValueError(ambiguous)
828                         elif step == 1:
829                             return Range(self.start, self[stop], ss)
830                         else:  # < 0
831                             return Range(0)
832                     else:  # >= 0
833                         raise ValueError(ooslice)
834                 elif start > 0:
835                     raise ValueError(ooslice)
836         else:
837             if not self:
838                 raise IndexError('Range index out of range')
839             if i == 0:
840                 if self.start.is_infinite:
841                     raise ValueError(ooslice)
842                 if self.has(Symbol):
843                     if (self.stop > self.start) == self.step.is_positive and self.step.is_positive is not None:
844                         pass
845                     else:
846                         _ = self.size  # validate
847                 return self.start
848             if i == -1:
849                 if self.stop.is_infinite:
850                     raise ValueError(ooslice)
851                 n = self.stop - self.step
852                 if n.is_Integer or (
853                         n.is_integer and (
854                             (n - self.start).is_nonnegative ==
855                             self.step.is_positive)):
856                     return n
857             _ = self.size  # validate
858             rv = (self.stop if i < 0 else self.start) + i*self.step
859             if rv.is_infinite:
860                 raise ValueError(ooslice)
861             if rv < self.inf or rv > self.sup:
862                 raise IndexError("Range index out of range")
863             return rv
864 
865     @property
866     def _inf(self):
867         if not self:
868             raise NotImplementedError
869         if self.has(Symbol):
870             if self.step.is_positive:
871                 return self[0]
872             elif self.step.is_negative:
873                 return self[-1]
874             _ = self.size  # validate
875         if self.step > 0:
876             return self.start
877         else:
878             return self.stop - self.step
879 
880     @property
881     def _sup(self):
882         if not self:
883             raise NotImplementedError
884         if self.has(Symbol):
885             if self.step.is_positive:
886                 return self[-1]
887             elif self.step.is_negative:
888                 return self[0]
889             _ = self.size  # validate
890         if self.step > 0:
891             return self.stop - self.step
892         else:
893             return self.start
894 
895     @property
896     def _boundary(self):
897         return self
898 
899     def as_relational(self, x):
900         """Rewrite a Range in terms of equalities and logic operators. """
901         from sympy.functions.elementary.integers import floor
902         return And(
903             Eq(x, floor(x)),
904             x >= self.inf if self.inf in self else x > self.inf,
905             x <= self.sup if self.sup in self else x < self.sup)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/relational.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.utilities.exceptions import SymPyDeprecationWarning
4 from .add import _unevaluated_Add, Add
5 from .basic import S
6 from .compatibility import ordered
7 from .expr import Expr
8 from .evalf import EvalfMixin
9 from .sympify import _sympify
10 from .evaluate import global_evaluate
11 
12 from sympy.logic.boolalg import Boolean, BooleanAtom
13 
14 __all__ = (
15     'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',
16     'Relational', 'Equality', 'Unequality', 'StrictLessThan', 'LessThan',
17     'StrictGreaterThan', 'GreaterThan',
18 )
19 
20 
21 
22 # Note, see issue 4986.  Ideally, we wouldn't want to subclass both Boolean
23 # and Expr.
24 
25 def _canonical(cond):
26     # return a condition in which all relationals are canonical
27     reps = {r: r.canonical for r in cond.atoms(Relational)}
28     return cond.xreplace(reps)
29     # XXX: AttributeError was being caught here but it wasn't triggered by any of
30     # the tests so I've removed it...
31 
32 
33 class Relational(Boolean, Expr, EvalfMixin):
34     """Base class for all relation types.
35 
36     Subclasses of Relational should generally be instantiated directly, but
37     Relational can be instantiated with a valid ``rop`` value to dispatch to
38     the appropriate subclass.
39 
40     Parameters
41     ==========
42     rop : str or None
43         Indicates what subclass to instantiate.  Valid values can be found
44         in the keys of Relational.ValidRelationalOperator.
45 
46     Examples
47     ========
48 
49     >>> from sympy import Rel
50     >>> from sympy.abc import x, y
51     >>> Rel(y, x + x**2, '==')
52     Eq(y, x**2 + x)
53 
54     """
55     __slots__ = []
56 
57     is_Relational = True
58 
59     # ValidRelationOperator - Defined below, because the necessary classes
60     #   have not yet been defined
61 
62     def __new__(cls, lhs, rhs, rop=None, **assumptions):
63         # If called by a subclass, do nothing special and pass on to Expr.
64         if cls is not Relational:
65             return Expr.__new__(cls, lhs, rhs, **assumptions)
66         # If called directly with an operator, look up the subclass
67         # corresponding to that operator and delegate to it
68         try:
69             cls = cls.ValidRelationOperator[rop]
70             rv = cls(lhs, rhs, **assumptions)
71             # /// drop when Py2 is no longer supported
72             # validate that Booleans are not being used in a relational
73             # other than Eq/Ne;
74             if isinstance(rv, (Eq, Ne)):
75                 pass
76             elif isinstance(rv, Relational):  # could it be otherwise?
77                 from sympy.core.symbol import Symbol
78                 from sympy.logic.boolalg import Boolean
79                 for a in rv.args:
80                     if isinstance(a, Symbol):
81                         continue
82                     if isinstance(a, Boolean):
83                         from sympy.utilities.misc import filldedent
84                         raise TypeError(filldedent('''
85                             A Boolean argument can only be used in
86                             Eq and Ne; all other relationals expect
87                             real expressions.
88                         '''))
89             # \\\
90             return rv
91         except KeyError:
92             raise ValueError(
93                 "Invalid relational operator symbol: %r" % rop)
94 
95     @property
96     def lhs(self):
97         """The left-hand side of the relation."""
98         return self._args[0]
99 
100     @property
101     def rhs(self):
102         """The right-hand side of the relation."""
103         return self._args[1]
104 
105     @property
106     def reversed(self):
107         """Return the relationship with sides reversed.
108 
109         Examples
110         ========
111 
112         >>> from sympy import Eq
113         >>> from sympy.abc import x
114         >>> Eq(x, 1)
115         Eq(x, 1)
116         >>> _.reversed
117         Eq(1, x)
118         >>> x < 1
119         x < 1
120         >>> _.reversed
121         1 > x
122         """
123         ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}
124         a, b = self.args
125         return Relational.__new__(ops.get(self.func, self.func), b, a)
126 
127     @property
128     def reversedsign(self):
129         """Return the relationship with signs reversed.
130 
131         Examples
132         ========
133 
134         >>> from sympy import Eq
135         >>> from sympy.abc import x
136         >>> Eq(x, 1)
137         Eq(x, 1)
138         >>> _.reversedsign
139         Eq(-x, -1)
140         >>> x < 1
141         x < 1
142         >>> _.reversedsign
143         -x > -1
144         """
145         a, b = self.args
146         if not (isinstance(a, BooleanAtom) or isinstance(b, BooleanAtom)):
147             ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}
148             return Relational.__new__(ops.get(self.func, self.func), -a, -b)
149         else:
150             return self
151 
152     @property
153     def negated(self):
154         """Return the negated relationship.
155 
156         Examples
157         ========
158 
159         >>> from sympy import Eq
160         >>> from sympy.abc import x
161         >>> Eq(x, 1)
162         Eq(x, 1)
163         >>> _.negated
164         Ne(x, 1)
165         >>> x < 1
166         x < 1
167         >>> _.negated
168         x >= 1
169 
170         Notes
171         =====
172 
173         This works more or less identical to ``~``/``Not``. The difference is
174         that ``negated`` returns the relationship even if ``evaluate=False``.
175         Hence, this is useful in code when checking for e.g. negated relations
176         to existing ones as it will not be affected by the `evaluate` flag.
177 
178         """
179         ops = {Eq: Ne, Ge: Lt, Gt: Le, Le: Gt, Lt: Ge, Ne: Eq}
180         # If there ever will be new Relational subclasses, the following line
181         # will work until it is properly sorted out
182         # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,
183         #      b, evaluate=evaluate)))(*self.args, evaluate=False)
184         return Relational.__new__(ops.get(self.func), *self.args)
185 
186     def _eval_evalf(self, prec):
187         return self.func(*[s._evalf(prec) for s in self.args])
188 
189     @property
190     def canonical(self):
191         """Return a canonical form of the relational by putting a
192         Number on the rhs else ordering the args. The relation is also changed
193         so that the left-hand side expression does not start with a ``-``.
194         No other simplification is attempted.
195 
196         Examples
197         ========
198 
199         >>> from sympy.abc import x, y
200         >>> x < 2
201         x < 2
202         >>> _.reversed.canonical
203         x < 2
204         >>> (-y < x).canonical
205         x > -y
206         >>> (-y > x).canonical
207         x < -y
208         """
209         args = self.args
210         r = self
211         if r.rhs.is_number:
212             if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:
213                 r = r.reversed
214         elif r.lhs.is_number:
215             r = r.reversed
216         elif tuple(ordered(args)) != args:
217             r = r.reversed
218 
219         LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)
220         RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)
221 
222         if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):
223             return r
224 
225         # Check if first value has negative sign
226         if LHS_CEMS and LHS_CEMS():
227             return r.reversedsign
228         elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():
229             # Right hand side has a minus, but not lhs.
230             # How does the expression with reversed signs behave?
231             # This is so that expressions of the type
232             # Eq(x, -y) and Eq(-x, y)
233             # have the same canonical representation
234             expr1, _ = ordered([r.lhs, -r.rhs])
235             if expr1 != r.lhs:
236                 return r.reversed.reversedsign
237 
238         return r
239 
240     def equals(self, other, failing_expression=False):
241         """Return True if the sides of the relationship are mathematically
242         identical and the type of relationship is the same.
243         If failing_expression is True, return the expression whose truth value
244         was unknown."""
245         if isinstance(other, Relational):
246             if self == other or self.reversed == other:
247                 return True
248             a, b = self, other
249             if a.func in (Eq, Ne) or b.func in (Eq, Ne):
250                 if a.func != b.func:
251                     return False
252                 left, right = [i.equals(j,
253                                         failing_expression=failing_expression)
254                                for i, j in zip(a.args, b.args)]
255                 if left is True:
256                     return right
257                 if right is True:
258                     return left
259                 lr, rl = [i.equals(j, failing_expression=failing_expression)
260                           for i, j in zip(a.args, b.reversed.args)]
261                 if lr is True:
262                     return rl
263                 if rl is True:
264                     return lr
265                 e = (left, right, lr, rl)
266                 if all(i is False for i in e):
267                     return False
268                 for i in e:
269                     if i not in (True, False):
270                         return i
271             else:
272                 if b.func != a.func:
273                     b = b.reversed
274                 if a.func != b.func:
275                     return False
276                 left = a.lhs.equals(b.lhs,
277                                     failing_expression=failing_expression)
278                 if left is False:
279                     return False
280                 right = a.rhs.equals(b.rhs,
281                                      failing_expression=failing_expression)
282                 if right is False:
283                     return False
284                 if left is True:
285                     return right
286                 return left
287 
288     def _eval_simplify(self, **kwargs):
289         r = self
290         r = r.func(*[i.simplify(**kwargs) for i in r.args])
291         if r.is_Relational:
292             dif = r.lhs - r.rhs
293             # replace dif with a valid Number that will
294             # allow a definitive comparison with 0
295             v = None
296             if dif.is_comparable:
297                 v = dif.n(2)
298             elif dif.equals(0):  # XXX this is expensive
299                 v = S.Zero
300             if v is not None:
301                 r = r.func._eval_relation(v, S.Zero)
302             r = r.canonical
303             # If there is only one symbol in the expression,
304             # try to write it on a simplified form
305             free = list(filter(lambda x: x.is_real is not False, r.free_symbols))
306             if len(free) == 1:
307                 try:
308                     from sympy.solvers.solveset import linear_coeffs
309                     x = free.pop()
310                     dif = r.lhs - r.rhs
311                     m, b = linear_coeffs(dif, x)
312                     if m.is_zero is False:
313                         if m.is_negative:
314                             # Dividing with a negative number, so change order of arguments
315                             # canonical will put the symbol back on the lhs later
316                             r = r.func(-b/m, x)
317                         else:
318                             r = r.func(x, -b/m)
319                     else:
320                         r = r.func(b, S.zero)
321                 except ValueError:
322                     # maybe not a linear function, try polynomial
323                     from sympy.polys import Poly, poly, PolynomialError, gcd
324                     try:
325                         p = poly(dif, x)
326                         c = p.all_coeffs()
327                         constant = c[-1]
328                         c[-1] = 0
329                         scale = gcd(c)
330                         c = [ctmp/scale for ctmp in c]
331                         r = r.func(Poly.from_list(c, x).as_expr(), -constant/scale)
332                     except PolynomialError:
333                         pass
334             elif len(free) >= 2:
335                 try:
336                     from sympy.solvers.solveset import linear_coeffs
337                     from sympy.polys import gcd
338                     free = list(ordered(free))
339                     dif = r.lhs - r.rhs
340                     m = linear_coeffs(dif, *free)
341                     constant = m[-1]
342                     del m[-1]
343                     scale = gcd(m)
344                     m = [mtmp/scale for mtmp in m]
345                     nzm = list(filter(lambda f: f[0] != 0, list(zip(m, free))))
346                     if scale.is_zero is False:
347                         if constant != 0:
348                             # lhs: expression, rhs: constant
349                             newexpr = Add(*[i*j for i, j in nzm])
350                             r = r.func(newexpr, -constant/scale)
351                         else:
352                             # keep first term on lhs
353                             lhsterm = nzm[0][0]*nzm[0][1]
354                             del nzm[0]
355                             newexpr = Add(*[i*j for i, j in nzm])
356                             r = r.func(lhsterm, -newexpr)
357 
358                     else:
359                         r = r.func(constant, S.zero)
360                 except ValueError:
361                     pass
362         # Did we get a simplified result?
363         r = r.canonical
364         measure = kwargs['measure']
365         if measure(r) < kwargs['ratio']*measure(self):
366             return r
367         else:
368             return self
369 
370     def _eval_trigsimp(self, **opts):
371         from sympy.simplify import trigsimp
372         return self.func(trigsimp(self.lhs, **opts), trigsimp(self.rhs, **opts))
373 
374 
375     def __nonzero__(self):
376         raise TypeError("cannot determine truth value of Relational")
377 
378     __bool__ = __nonzero__
379 
380     def _eval_as_set(self):
381         # self is univariate and periodicity(self, x) in (0, None)
382         from sympy.solvers.inequalities import solve_univariate_inequality
383         syms = self.free_symbols
384         assert len(syms) == 1
385         x = syms.pop()
386         return solve_univariate_inequality(self, x, relational=False)
387 
388     @property
389     def binary_symbols(self):
390         # override where necessary
391         return set()
392 
393 
394 Rel = Relational
395 
396 
397 class Equality(Relational):
398     """An equal relation between two objects.
399 
400     Represents that two objects are equal.  If they can be easily shown
401     to be definitively equal (or unequal), this will reduce to True (or
402     False).  Otherwise, the relation is maintained as an unevaluated
403     Equality object.  Use the ``simplify`` function on this object for
404     more nontrivial evaluation of the equality relation.
405 
406     As usual, the keyword argument ``evaluate=False`` can be used to
407     prevent any evaluation.
408 
409     Examples
410     ========
411 
412     >>> from sympy import Eq, simplify, exp, cos
413     >>> from sympy.abc import x, y
414     >>> Eq(y, x + x**2)
415     Eq(y, x**2 + x)
416     >>> Eq(2, 5)
417     False
418     >>> Eq(2, 5, evaluate=False)
419     Eq(2, 5)
420     >>> _.doit()
421     False
422     >>> Eq(exp(x), exp(x).rewrite(cos))
423     Eq(exp(x), sinh(x) + cosh(x))
424     >>> simplify(_)
425     True
426 
427     See Also
428     ========
429 
430     sympy.logic.boolalg.Equivalent : for representing equality between two
431         boolean expressions
432 
433     Notes
434     =====
435 
436     This class is not the same as the == operator.  The == operator tests
437     for exact structural equality between two expressions; this class
438     compares expressions mathematically.
439 
440     If either object defines an `_eval_Eq` method, it can be used in place of
441     the default algorithm.  If `lhs._eval_Eq(rhs)` or `rhs._eval_Eq(lhs)`
442     returns anything other than None, that return value will be substituted for
443     the Equality.  If None is returned by `_eval_Eq`, an Equality object will
444     be created as usual.
445 
446     Since this object is already an expression, it does not respond to
447     the method `as_expr` if one tries to create `x - y` from Eq(x, y).
448     This can be done with the `rewrite(Add)` method.
449     """
450     rel_op = '=='
451 
452     __slots__ = []
453 
454     is_Equality = True
455 
456     def __new__(cls, lhs, rhs=None, **options):
457         from sympy.core.add import Add
458         from sympy.core.containers import Tuple
459         from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not
460         from sympy.core.expr import _n2
461         from sympy.functions.elementary.complexes import arg
462         from sympy.simplify.simplify import clear_coefficients
463         from sympy.utilities.iterables import sift
464 
465         if rhs is None:
466             SymPyDeprecationWarning(
467                 feature="Eq(expr) with rhs default to 0",
468                 useinstead="Eq(expr, 0)",
469                 issue=16587,
470                 deprecated_since_version="1.5"
471             ).warn()
472             rhs = 0
473 
474         lhs = _sympify(lhs)
475         rhs = _sympify(rhs)
476 
477         evaluate = options.pop('evaluate', global_evaluate[0])
478 
479         if evaluate:
480             # If one expression has an _eval_Eq, return its results.
481             if hasattr(lhs, '_eval_Eq'):
482                 r = lhs._eval_Eq(rhs)
483                 if r is not None:
484                     return r
485             if hasattr(rhs, '_eval_Eq'):
486                 r = rhs._eval_Eq(lhs)
487                 if r is not None:
488                     return r
489             # If expressions have the same structure, they must be equal.
490             if lhs == rhs:
491                 return S.true  # e.g. True == True
492             elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):
493                 return S.false  # True != False
494             elif not (lhs.is_Symbol or rhs.is_Symbol) and (
495                     isinstance(lhs, Boolean) !=
496                     isinstance(rhs, Boolean)):
497                 return S.false  # only Booleans can equal Booleans
498 
499             if lhs.is_infinite or rhs.is_infinite:
500                 if fuzzy_xor([lhs.is_infinite, rhs.is_infinite]):
501                     return S.false
502                 if fuzzy_xor([lhs.is_extended_real, rhs.is_extended_real]):
503                     return S.false
504                 if fuzzy_and([lhs.is_extended_real, rhs.is_extended_real]):
505                     r = fuzzy_xor([lhs.is_extended_positive, fuzzy_not(rhs.is_extended_positive)])
506                     return S(r)
507 
508                 # Try to split real/imaginary parts and equate them
509                 I = S.ImaginaryUnit
510 
511                 def split_real_imag(expr):
512                     real_imag = lambda t: (
513                             'real' if t.is_extended_real else
514                             'imag' if (I*t).is_extended_real else None)
515                     return sift(Add.make_args(expr), real_imag)
516 
517                 lhs_ri = split_real_imag(lhs)
518                 if not lhs_ri[None]:
519                     rhs_ri = split_real_imag(rhs)
520                     if not rhs_ri[None]:
521                         eq_real = Eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']))
522                         eq_imag = Eq(I*Add(*lhs_ri['imag']), I*Add(*rhs_ri['imag']))
523                         res = fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))
524                         if res is not None:
525                             return S(res)
526 
527                 # Compare e.g. zoo with 1+I*oo by comparing args
528                 arglhs = arg(lhs)
529                 argrhs = arg(rhs)
530                 # Guard against Eq(nan, nan) -> False
531                 if not (arglhs == S.NaN and argrhs == S.NaN):
532                     res = fuzzy_bool(Eq(arglhs, argrhs))
533                     if res is not None:
534                         return S(res)
535 
536                 return Relational.__new__(cls, lhs, rhs, **options)
537 
538             if all(isinstance(i, Expr) for i in (lhs, rhs)):
539                 # see if the difference evaluates
540                 dif = lhs - rhs
541                 z = dif.is_zero
542                 if z is not None:
543                     if z is False and dif.is_commutative:  # issue 10728
544                         return S.false
545                     if z:
546                         return S.true
547                 # evaluate numerically if possible
548                 n2 = _n2(lhs, rhs)
549                 if n2 is not None:
550                     return _sympify(n2 == 0)
551                 # see if the ratio evaluates
552                 n, d = dif.as_numer_denom()
553                 rv = None
554                 if n.is_zero:
555                     rv = d.is_nonzero
556                 elif n.is_finite:
557                     if d.is_infinite:
558                         rv = S.true
559                     elif n.is_zero is False:
560                         rv = d.is_infinite
561                         if rv is None:
562                             # if the condition that makes the denominator
563                             # infinite does not make the original expression
564                             # True then False can be returned
565                             l, r = clear_coefficients(d, S.Infinity)
566                             args = [_.subs(l, r) for _ in (lhs, rhs)]
567                             if args != [lhs, rhs]:
568                                 rv = fuzzy_bool(Eq(*args))
569                                 if rv is True:
570                                     rv = None
571                 elif any(a.is_infinite for a in Add.make_args(n)):
572                     # (inf or nan)/x != 0
573                     rv = S.false
574                 if rv is not None:
575                     return _sympify(rv)
576 
577         return Relational.__new__(cls, lhs, rhs, **options)
578 
579     @classmethod
580     def _eval_relation(cls, lhs, rhs):
581         return _sympify(lhs == rhs)
582 
583     def _eval_rewrite_as_Add(self, *args, **kwargs):
584         """return Eq(L, R) as L - R. To control the evaluation of
585         the result set pass `evaluate=True` to give L - R;
586         if `evaluate=None` then terms in L and R will not cancel
587         but they will be listed in canonical order; otherwise
588         non-canonical args will be returned.
589 
590         Examples
591         ========
592 
593         >>> from sympy import Eq, Add
594         >>> from sympy.abc import b, x
595         >>> eq = Eq(x + b, x - b)
596         >>> eq.rewrite(Add)
597         2*b
598         >>> eq.rewrite(Add, evaluate=None).args
599         (b, b, x, -x)
600         >>> eq.rewrite(Add, evaluate=False).args
601         (b, x, b, -x)
602         """
603         L, R = args
604         evaluate = kwargs.get('evaluate', True)
605         if evaluate:
606             # allow cancellation of args
607             return L - R
608         args = Add.make_args(L) + Add.make_args(-R)
609         if evaluate is None:
610             # no cancellation, but canonical
611             return _unevaluated_Add(*args)
612         # no cancellation, not canonical
613         return Add._from_args(args)
614 
615     @property
616     def binary_symbols(self):
617         if S.true in self.args or S.false in self.args:
618             if self.lhs.is_Symbol:
619                 return set([self.lhs])
620             elif self.rhs.is_Symbol:
621                 return set([self.rhs])
622         return set()
623 
624     def _eval_simplify(self, **kwargs):
625         from sympy.solvers.solveset import linear_coeffs
626         # standard simplify
627         e = super(Equality, self)._eval_simplify(**kwargs)
628         if not isinstance(e, Equality):
629             return e
630         free = self.free_symbols
631         if len(free) == 1:
632             try:
633                 x = free.pop()
634                 m, b = linear_coeffs(
635                     e.rewrite(Add, evaluate=False), x)
636                 if m.is_zero is False:
637                     enew = e.func(x, -b/m)
638                 else:
639                     enew = e.func(m*x, -b)
640                 measure = kwargs['measure']
641                 if measure(enew) <= kwargs['ratio']*measure(e):
642                     e = enew
643             except ValueError:
644                 pass
645         return e.canonical
646 
647 
648 Eq = Equality
649 
650 
651 class Unequality(Relational):
652     """An unequal relation between two objects.
653 
654     Represents that two objects are not equal.  If they can be shown to be
655     definitively equal, this will reduce to False; if definitively unequal,
656     this will reduce to True.  Otherwise, the relation is maintained as an
657     Unequality object.
658 
659     Examples
660     ========
661 
662     >>> from sympy import Ne
663     >>> from sympy.abc import x, y
664     >>> Ne(y, x+x**2)
665     Ne(y, x**2 + x)
666 
667     See Also
668     ========
669     Equality
670 
671     Notes
672     =====
673     This class is not the same as the != operator.  The != operator tests
674     for exact structural equality between two expressions; this class
675     compares expressions mathematically.
676 
677     This class is effectively the inverse of Equality.  As such, it uses the
678     same algorithms, including any available `_eval_Eq` methods.
679 
680     """
681     rel_op = '!='
682 
683     __slots__ = []
684 
685     def __new__(cls, lhs, rhs, **options):
686         lhs = _sympify(lhs)
687         rhs = _sympify(rhs)
688 
689         evaluate = options.pop('evaluate', global_evaluate[0])
690 
691         if evaluate:
692             is_equal = Equality(lhs, rhs)
693             if isinstance(is_equal, BooleanAtom):
694                 return is_equal.negated
695 
696         return Relational.__new__(cls, lhs, rhs, **options)
697 
698     @classmethod
699     def _eval_relation(cls, lhs, rhs):
700         return _sympify(lhs != rhs)
701 
702     @property
703     def binary_symbols(self):
704         if S.true in self.args or S.false in self.args:
705             if self.lhs.is_Symbol:
706                 return set([self.lhs])
707             elif self.rhs.is_Symbol:
708                 return set([self.rhs])
709         return set()
710 
711     def _eval_simplify(self, **kwargs):
712         # simplify as an equality
713         eq = Equality(*self.args)._eval_simplify(**kwargs)
714         if isinstance(eq, Equality):
715             # send back Ne with the new args
716             return self.func(*eq.args)
717         return eq.negated  # result of Ne is the negated Eq
718 
719 
720 Ne = Unequality
721 
722 
723 class _Inequality(Relational):
724     """Internal base class for all *Than types.
725 
726     Each subclass must implement _eval_relation to provide the method for
727     comparing two real numbers.
728 
729     """
730     __slots__ = []
731 
732     def __new__(cls, lhs, rhs, **options):
733         lhs = _sympify(lhs)
734         rhs = _sympify(rhs)
735 
736         evaluate = options.pop('evaluate', global_evaluate[0])
737 
738         if evaluate:
739             # First we invoke the appropriate inequality method of `lhs`
740             # (e.g., `lhs.__lt__`).  That method will try to reduce to
741             # boolean or raise an exception.  It may keep calling
742             # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).
743             # In some cases, `Expr` will just invoke us again (if neither it
744             # nor a subclass was able to reduce to boolean or raise an
745             # exception).  In that case, it must call us with
746             # `evaluate=False` to prevent infinite recursion.
747             r = cls._eval_relation(lhs, rhs)
748             if r is not None:
749                 return r
750             # Note: not sure r could be None, perhaps we never take this
751             # path?  In principle, could use this to shortcut out if a
752             # class realizes the inequality cannot be evaluated further.
753 
754         # make a "non-evaluated" Expr for the inequality
755         return Relational.__new__(cls, lhs, rhs, **options)
756 
757 class _Greater(_Inequality):
758     """Not intended for general use
759 
760     _Greater is only used so that GreaterThan and StrictGreaterThan may
761     subclass it for the .gts and .lts properties.
762 
763     """
764     __slots__ = ()
765 
766     @property
767     def gts(self):
768         return self._args[0]
769 
770     @property
771     def lts(self):
772         return self._args[1]
773 
774 
775 class _Less(_Inequality):
776     """Not intended for general use.
777 
778     _Less is only used so that LessThan and StrictLessThan may subclass it for
779     the .gts and .lts properties.
780 
781     """
782     __slots__ = ()
783 
784     @property
785     def gts(self):
786         return self._args[1]
787 
788     @property
789     def lts(self):
790         return self._args[0]
791 
792 
793 class GreaterThan(_Greater):
794     """Class representations of inequalities.
795 
796     Extended Summary
797     ================
798 
799     The ``*Than`` classes represent inequal relationships, where the left-hand
800     side is generally bigger or smaller than the right-hand side.  For example,
801     the GreaterThan class represents an inequal relationship where the
802     left-hand side is at least as big as the right side, if not bigger.  In
803     mathematical notation:
804 
805     lhs >= rhs
806 
807     In total, there are four ``*Than`` classes, to represent the four
808     inequalities:
809 
810     +-----------------+--------+
811     |Class Name       | Symbol |
812     +=================+========+
813     |GreaterThan      | (>=)   |
814     +-----------------+--------+
815     |LessThan         | (<=)   |
816     +-----------------+--------+
817     |StrictGreaterThan| (>)    |
818     +-----------------+--------+
819     |StrictLessThan   | (<)    |
820     +-----------------+--------+
821 
822     All classes take two arguments, lhs and rhs.
823 
824     +----------------------------+-----------------+
825     |Signature Example           | Math equivalent |
826     +============================+=================+
827     |GreaterThan(lhs, rhs)       |   lhs >= rhs    |
828     +----------------------------+-----------------+
829     |LessThan(lhs, rhs)          |   lhs <= rhs    |
830     +----------------------------+-----------------+
831     |StrictGreaterThan(lhs, rhs) |   lhs >  rhs    |
832     +----------------------------+-----------------+
833     |StrictLessThan(lhs, rhs)    |   lhs <  rhs    |
834     +----------------------------+-----------------+
835 
836     In addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality
837     objects also have the .lts and .gts properties, which represent the "less
838     than side" and "greater than side" of the operator.  Use of .lts and .gts
839     in an algorithm rather than .lhs and .rhs as an assumption of inequality
840     direction will make more explicit the intent of a certain section of code,
841     and will make it similarly more robust to client code changes:
842 
843     >>> from sympy import GreaterThan, StrictGreaterThan
844     >>> from sympy import LessThan,    StrictLessThan
845     >>> from sympy import And, Ge, Gt, Le, Lt, Rel, S
846     >>> from sympy.abc import x, y, z
847     >>> from sympy.core.relational import Relational
848 
849     >>> e = GreaterThan(x, 1)
850     >>> e
851     x >= 1
852     >>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)
853     'x >= 1 is the same as 1 <= x'
854 
855     Examples
856     ========
857 
858     One generally does not instantiate these classes directly, but uses various
859     convenience methods:
860 
861     >>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers
862     ...     print(f(x, 2))
863     x >= 2
864     x > 2
865     x <= 2
866     x < 2
867 
868     Another option is to use the Python inequality operators (>=, >, <=, <)
869     directly.  Their main advantage over the Ge, Gt, Le, and Lt counterparts,
870     is that one can write a more "mathematical looking" statement rather than
871     littering the math with oddball function calls.  However there are certain
872     (minor) caveats of which to be aware (search for 'gotcha', below).
873 
874     >>> x >= 2
875     x >= 2
876     >>> _ == Ge(x, 2)
877     True
878 
879     However, it is also perfectly valid to instantiate a ``*Than`` class less
880     succinctly and less conveniently:
881 
882     >>> Rel(x, 1, ">")
883     x > 1
884     >>> Relational(x, 1, ">")
885     x > 1
886 
887     >>> StrictGreaterThan(x, 1)
888     x > 1
889     >>> GreaterThan(x, 1)
890     x >= 1
891     >>> LessThan(x, 1)
892     x <= 1
893     >>> StrictLessThan(x, 1)
894     x < 1
895 
896     Notes
897     =====
898 
899     There are a couple of "gotchas" to be aware of when using Python's
900     operators.
901 
902     The first is that what your write is not always what you get:
903 
904         >>> 1 < x
905         x > 1
906 
907         Due to the order that Python parses a statement, it may
908         not immediately find two objects comparable.  When "1 < x"
909         is evaluated, Python recognizes that the number 1 is a native
910         number and that x is *not*.  Because a native Python number does
911         not know how to compare itself with a SymPy object
912         Python will try the reflective operation, "x > 1" and that is the
913         form that gets evaluated, hence returned.
914 
915         If the order of the statement is important (for visual output to
916         the console, perhaps), one can work around this annoyance in a
917         couple ways:
918 
919         (1) "sympify" the literal before comparison
920 
921         >>> S(1) < x
922         1 < x
923 
924         (2) use one of the wrappers or less succinct methods described
925         above
926 
927         >>> Lt(1, x)
928         1 < x
929         >>> Relational(1, x, "<")
930         1 < x
931 
932     The second gotcha involves writing equality tests between relationals
933     when one or both sides of the test involve a literal relational:
934 
935         >>> e = x < 1; e
936         x < 1
937         >>> e == e  # neither side is a literal
938         True
939         >>> e == x < 1  # expecting True, too
940         False
941         >>> e != x < 1  # expecting False
942         x < 1
943         >>> x < 1 != x < 1  # expecting False or the same thing as before
944         Traceback (most recent call last):
945         ...
946         TypeError: cannot determine truth value of Relational
947 
948         The solution for this case is to wrap literal relationals in
949         parentheses:
950 
951         >>> e == (x < 1)
952         True
953         >>> e != (x < 1)
954         False
955         >>> (x < 1) != (x < 1)
956         False
957 
958     The third gotcha involves chained inequalities not involving
959     '==' or '!='. Occasionally, one may be tempted to write:
960 
961         >>> e = x < y < z
962         Traceback (most recent call last):
963         ...
964         TypeError: symbolic boolean expression has no truth value.
965 
966         Due to an implementation detail or decision of Python [1]_,
967         there is no way for SymPy to create a chained inequality with
968         that syntax so one must use And:
969 
970         >>> e = And(x < y, y < z)
971         >>> type( e )
972         And
973         >>> e
974         (x < y) & (y < z)
975 
976         Although this can also be done with the '&' operator, it cannot
977         be done with the 'and' operarator:
978 
979         >>> (x < y) & (y < z)
980         (x < y) & (y < z)
981         >>> (x < y) and (y < z)
982         Traceback (most recent call last):
983         ...
984         TypeError: cannot determine truth value of Relational
985 
986     .. [1] This implementation detail is that Python provides no reliable
987        method to determine that a chained inequality is being built.
988        Chained comparison operators are evaluated pairwise, using "and"
989        logic (see
990        http://docs.python.org/2/reference/expressions.html#notin). This
991        is done in an efficient way, so that each object being compared
992        is only evaluated once and the comparison can short-circuit. For
993        example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2
994        > 3)``. The ``and`` operator coerces each side into a bool,
995        returning the object itself when it short-circuits. The bool of
996        the --Than operators will raise TypeError on purpose, because
997        SymPy cannot determine the mathematical ordering of symbolic
998        expressions. Thus, if we were to compute ``x > y > z``, with
999        ``x``, ``y``, and ``z`` being Symbols, Python converts the
1000        statement (roughly) into these steps:
1001 
1002         (1) x > y > z
1003         (2) (x > y) and (y > z)
1004         (3) (GreaterThanObject) and (y > z)
1005         (4) (GreaterThanObject.__nonzero__()) and (y > z)
1006         (5) TypeError
1007 
1008        Because of the "and" added at step 2, the statement gets turned into a
1009        weak ternary statement, and the first object's __nonzero__ method will
1010        raise TypeError.  Thus, creating a chained inequality is not possible.
1011 
1012            In Python, there is no way to override the ``and`` operator, or to
1013            control how it short circuits, so it is impossible to make something
1014            like ``x > y > z`` work.  There was a PEP to change this,
1015            :pep:`335`, but it was officially closed in March, 2012.
1016 
1017     """
1018     __slots__ = ()
1019 
1020     rel_op = '>='
1021 
1022     @classmethod
1023     def _eval_relation(cls, lhs, rhs):
1024         # We don't use the op symbol here: workaround issue #7951
1025         return _sympify(lhs.__ge__(rhs))
1026 
1027 
1028 Ge = GreaterThan
1029 
1030 
1031 class LessThan(_Less):
1032     __doc__ = GreaterThan.__doc__
1033     __slots__ = ()
1034 
1035     rel_op = '<='
1036 
1037     @classmethod
1038     def _eval_relation(cls, lhs, rhs):
1039         # We don't use the op symbol here: workaround issue #7951
1040         return _sympify(lhs.__le__(rhs))
1041 
1042 
1043 Le = LessThan
1044 
1045 
1046 class StrictGreaterThan(_Greater):
1047     __doc__ = GreaterThan.__doc__
1048     __slots__ = ()
1049 
1050     rel_op = '>'
1051 
1052     @classmethod
1053     def _eval_relation(cls, lhs, rhs):
1054         # We don't use the op symbol here: workaround issue #7951
1055         return _sympify(lhs.__gt__(rhs))
1056 
1057 
1058 Gt = StrictGreaterThan
1059 
1060 
1061 class StrictLessThan(_Less):
1062     __doc__ = GreaterThan.__doc__
1063     __slots__ = ()
1064 
1065     rel_op = '<'
1066 
1067     @classmethod
1068     def _eval_relation(cls, lhs, rhs):
1069         # We don't use the op symbol here: workaround issue #7951
1070         return _sympify(lhs.__lt__(rhs))
1071 
1072 
1073 Lt = StrictLessThan
1074 
1075 
1076 # A class-specific (not object-specific) data item used for a minor speedup.
1077 # It is defined here, rather than directly in the class, because the classes
1078 # that it references have not been defined until now (e.g. StrictLessThan).
1079 Relational.ValidRelationOperator = {
1080     None: Equality,
1081     '==': Equality,
1082     'eq': Equality,
1083     '!=': Unequality,
1084     '<>': Unequality,
1085     'ne': Unequality,
1086     '>=': GreaterThan,
1087     'ge': GreaterThan,
1088     '<=': LessThan,
1089     'le': LessThan,
1090     '>': StrictGreaterThan,
1091     'gt': StrictGreaterThan,
1092     '<': StrictLessThan,
1093     'lt': StrictLessThan,
1094 }

</code><intended_behavior>While the direct modification in `__nonzero__` (or `__bool__` in Python 3) might not be necessary for resolving the issue, understanding and possibly enhancing how relational expressions involving symbols are handled might provide a workaround or ancillary solution. The intended behavior, though, is not to alter the raising of the TypeError but to ensure that operations leading to this function account for symbolic cases differently. Therefore, the solution might not be in changing this function but ensuring that set operations like `intersect` do not rely on operations that inherently cannot be performed with symbolic arguments without explicit evaluation strategies in place.</intended_behavior>]
2025-10-16 03:10:16.758 | INFO     | Search completed. Bug locations: [<file>sympy/sets/fancysets.py</file>
<class>Range</class>
<method>_contains</method>
<code>
670     def _contains(self, other):
671         if not self:
672             return S.false
673         if other.is_infinite:
674             return S.false
675         if not other.is_integer:
676             return other.is_integer
677         if self.has(Symbol):
678             try:
679                 _ = self.size  # validate
680             except ValueError:
681                 return
682         if self.start.is_finite:
683             ref = self.start
684         elif self.stop.is_finite:
685             ref = self.stop
686         else:
687             return other.is_Integer
688         if (ref - other) % self.step:  # off sequence
689             return S.false
690         return _sympify(other >= self.inf and other <= self.sup)

</code><intended_behavior>The `_contains` method in the `Range` class should be adjusted to handle symbolic variables more gracefully. When the method encounters a symbolic variable, instead of attempting to evaluate its truthiness directly—which leads to the TypeError—it should return a symbolic condition that represents whether the variable is contained within the range. This would likely involve enhancing the method to return unevaluated expressions or conditions when the direct truth value cannot be determined due to the presence of symbols. The specifics of the implementation will depend on how `sympy` expects to handle such symbolic logic internally.</intended_behavior>, <file>sympy/sets/fancysets.py</file>
<class>Range</class>
<method>None</method>
<code>
499 class Range(Set):
500     """
501     Represents a range of integers. Can be called as Range(stop),
502     Range(start, stop), or Range(start, stop, step); when stop is
503     not given it defaults to 1.
504 
505     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value
506     (juse as for Python ranges) is not included in the Range values.
507 
508         >>> from sympy import Range
509         >>> list(Range(3))
510         [0, 1, 2]
511 
512     The step can also be negative:
513 
514         >>> list(Range(10, 0, -2))
515         [10, 8, 6, 4, 2]
516 
517     The stop value is made canonical so equivalent ranges always
518     have the same args:
519 
520         >>> Range(0, 10, 3)
521         Range(0, 12, 3)
522 
523     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the
524     set (``Range`` is always a subset of ``Integers``). If the starting point
525     is infinite, then the final value is ``stop - step``. To iterate such a
526     range, it needs to be reversed:
527 
528         >>> from sympy import oo
529         >>> r = Range(-oo, 1)
530         >>> r[-1]
531         0
532         >>> next(iter(r))
533         Traceback (most recent call last):
534         ...
535         TypeError: Cannot iterate over Range with infinite start
536         >>> next(iter(r.reversed))
537         0
538 
539     Although Range is a set (and supports the normal set
540     operations) it maintains the order of the elements and can
541     be used in contexts where `range` would be used.
542 
543         >>> from sympy import Interval
544         >>> Range(0, 10, 2).intersect(Interval(3, 7))
545         Range(4, 8, 2)
546         >>> list(_)
547         [4, 6]
548 
549     Although slicing of a Range will always return a Range -- possibly
550     empty -- an empty set will be returned from any intersection that
551     is empty:
552 
553         >>> Range(3)[:0]
554         Range(0, 0, 1)
555         >>> Range(3).intersect(Interval(4, oo))
556         EmptySet
557         >>> Range(3).intersect(Range(4, oo))
558         EmptySet
559 
560     Range will accept symbolic arguments but has very limited support
561     for doing anything other than displaying the Range:
562 
563         >>> from sympy import Symbol, pprint
564         >>> from sympy.abc import i, j, k
565         >>> Range(i, j, k).start
566         i
567         >>> Range(i, j, k).inf
568         Traceback (most recent call last):
569         ...
570         ValueError: invalid method for symbolic range
571 
572     Better success will be had when using integer symbols:
573 
574         >>> n = Symbol('n', integer=True)
575         >>> r = Range(n, n + 20, 3)
576         >>> r.inf
577         n
578         >>> pprint(r)
579         {n, n + 3, ..., n + 17}
580     """
581 
582     is_iterable = True
583 
584     def __new__(cls, *args):
585         from sympy.functions.elementary.integers import ceiling
586         if len(args) == 1:
587             if isinstance(args[0], range):
588                 raise TypeError(
589                     'use sympify(%s) to convert range to Range' % args[0])
590 
591         # expand range
592         slc = slice(*args)
593 
594         if slc.step == 0:
595             raise ValueError("step cannot be 0")
596 
597         start, stop, step = slc.start or 0, slc.stop, slc.step or 1
598         try:
599             ok = []
600             for w in (start, stop, step):
601                 w = sympify(w)
602                 if w in [S.NegativeInfinity, S.Infinity] or (
603                         w.has(Symbol) and w.is_integer != False):
604                     ok.append(w)
605                 elif not w.is_Integer:
606                     raise ValueError
607                 else:
608                     ok.append(w)
609         except ValueError:
610             raise ValueError(filldedent('''
611     Finite arguments to Range must be integers; `imageset` can define
612     other cases, e.g. use `imageset(i, i/10, Range(3))` to give
613     [0, 1/10, 1/5].'''))
614         start, stop, step = ok
615 
616         null = False
617         if any(i.has(Symbol) for i in (start, stop, step)):
618             if start == stop:
619                 null = True
620             else:
621                 end = stop
622         elif start.is_infinite:
623             span = step*(stop - start)
624             if span is S.NaN or span <= 0:
625                 null = True
626             elif step.is_Integer and stop.is_infinite and abs(step) != 1:
627                 raise ValueError(filldedent('''
628                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))
629             else:
630                 end = stop
631         else:
632             oostep = step.is_infinite
633             if oostep:
634                 step = S.One if step > 0 else S.NegativeOne
635             n = ceiling((stop - start)/step)
636             if n <= 0:
637                 null = True
638             elif oostep:
639                 end = start + 1
640                 step = S.One  # make it a canonical single step
641             else:
642                 end = start + n*step
643         if null:
644             start = end = S.Zero
645             step = S.One
646         return Basic.__new__(cls, start, end, step)
647 
648     start = property(lambda self: self.args[0])
649     stop = property(lambda self: self.args[1])
650     step = property(lambda self: self.args[2])
651 
652     @property
653     def reversed(self):
654         """Return an equivalent Range in the opposite order.
655 
656         Examples
657         ========
658 
659         >>> from sympy import Range
660         >>> Range(10).reversed
661         Range(9, -1, -1)
662         """
663         if self.has(Symbol):
664             _ = self.size  # validate
665         if not self:
666             return self
667         return self.func(
668             self.stop - self.step, self.start - self.step, -self.step)
669 
670     def _contains(self, other):
671         if not self:
672             return S.false
673         if other.is_infinite:
674             return S.false
675         if not other.is_integer:
676             return other.is_integer
677         if self.has(Symbol):
678             try:
679                 _ = self.size  # validate
680             except ValueError:
681                 return
682         if self.start.is_finite:
683             ref = self.start
684         elif self.stop.is_finite:
685             ref = self.stop
686         else:
687             return other.is_Integer
688         if (ref - other) % self.step:  # off sequence
689             return S.false
690         return _sympify(other >= self.inf and other <= self.sup)
691 
692     def __iter__(self):
693         if self.has(Symbol):
694             _ = self.size  # validate
695         if self.start in [S.NegativeInfinity, S.Infinity]:
696             raise TypeError("Cannot iterate over Range with infinite start")
697         elif self:
698             i = self.start
699             step = self.step
700 
701             while True:
702                 if (step > 0 and not (self.start <= i < self.stop)) or \
703                    (step < 0 and not (self.stop < i <= self.start)):
704                     break
705                 yield i
706                 i += step
707 
708     def __len__(self):
709         rv = self.size
710         if rv is S.Infinity:
711             raise ValueError('Use .size to get the length of an infinite Range')
712         return int(rv)
713 
714     @property
715     def size(self):
716         if not self:
717             return S.Zero
718         dif = self.stop - self.start
719         if self.has(Symbol):
720             if dif.has(Symbol) or self.step.has(Symbol) or (
721                     not self.start.is_integer and not self.stop.is_integer):
722                 raise ValueError('invalid method for symbolic range')
723         if dif.is_infinite:
724             return S.Infinity
725         return Integer(abs(dif//self.step))
726 
727     def __nonzero__(self):
728         return self.start != self.stop
729 
730     __bool__ = __nonzero__
731 
732     def __getitem__(self, i):
733         from sympy.functions.elementary.integers import ceiling
734         ooslice = "cannot slice from the end with an infinite value"
735         zerostep = "slice step cannot be zero"
736         # if we had to take every other element in the following
737         # oo, ..., 6, 4, 2, 0
738         # we might get oo, ..., 4, 0 or oo, ..., 6, 2
739         ambiguous = "cannot unambiguously re-stride from the end " + \
740             "with an infinite value"
741         if isinstance(i, slice):
742             if self.size.is_finite:  # validates, too
743                 start, stop, step = i.indices(self.size)
744                 n = ceiling((stop - start)/step)
745                 if n <= 0:
746                     return Range(0)
747                 canonical_stop = start + n*step
748                 end = canonical_stop - step
749                 ss = step*self.step
750                 return Range(self[start], self[end] + ss, ss)
751             else:  # infinite Range
752                 start = i.start
753                 stop = i.stop
754                 if i.step == 0:
755                     raise ValueError(zerostep)
756                 step = i.step or 1
757                 ss = step*self.step
758                 #---------------------
759                 # handle infinite on right
760                 #   e.g. Range(0, oo) or Range(0, -oo, -1)
761                 # --------------------
762                 if self.stop.is_infinite:
763                     # start and stop are not interdependent --
764                     # they only depend on step --so we use the
765                     # equivalent reversed values
766                     return self.reversed[
767                         stop if stop is None else -stop + 1:
768                         start if start is None else -start:
769                         step].reversed
770                 #---------------------
771                 # handle infinite on the left
772                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)
773                 # --------------------
774                 # consider combinations of
775                 # start/stop {== None, < 0, == 0, > 0} and
776                 # step {< 0, > 0}
777                 if start is None:
778                     if stop is None:
779                         if step < 0:
780                             return Range(self[-1], self.start, ss)
781                         elif step > 1:
782                             raise ValueError(ambiguous)
783                         else:  # == 1
784                             return self
785                     elif stop < 0:
786                         if step < 0:
787                             return Range(self[-1], self[stop], ss)
788                         else:  # > 0
789                             return Range(self.start, self[stop], ss)
790                     elif stop == 0:
791                         if step > 0:
792                             return Range(0)
793                         else:  # < 0
794                             raise ValueError(ooslice)
795                     elif stop == 1:
796                         if step > 0:
797                             raise ValueError(ooslice)  # infinite singleton
798                         else:  # < 0
799                             raise ValueError(ooslice)
800                     else:  # > 1
801                         raise ValueError(ooslice)
802                 elif start < 0:
803                     if stop is None:
804                         if step < 0:
805                             return Range(self[start], self.start, ss)
806                         else:  # > 0
807                             return Range(self[start], self.stop, ss)
808                     elif stop < 0:
809                         return Range(self[start], self[stop], ss)
810                     elif stop == 0:
811                         if step < 0:
812                             raise ValueError(ooslice)
813                         else:  # > 0
814                             return Range(0)
815                     elif stop > 0:
816                         raise ValueError(ooslice)
817                 elif start == 0:
818                     if stop is None:
819                         if step < 0:
820                             raise ValueError(ooslice)  # infinite singleton
821                         elif step > 1:
822                             raise ValueError(ambiguous)
823                         else:  # == 1
824                             return self
825                     elif stop < 0:
826                         if step > 1:
827                             raise ValueError(ambiguous)
828                         elif step == 1:
829                             return Range(self.start, self[stop], ss)
830                         else:  # < 0
831                             return Range(0)
832                     else:  # >= 0
833                         raise ValueError(ooslice)
834                 elif start > 0:
835                     raise ValueError(ooslice)
836         else:
837             if not self:
838                 raise IndexError('Range index out of range')
839             if i == 0:
840                 if self.start.is_infinite:
841                     raise ValueError(ooslice)
842                 if self.has(Symbol):
843                     if (self.stop > self.start) == self.step.is_positive and self.step.is_positive is not None:
844                         pass
845                     else:
846                         _ = self.size  # validate
847                 return self.start
848             if i == -1:
849                 if self.stop.is_infinite:
850                     raise ValueError(ooslice)
851                 n = self.stop - self.step
852                 if n.is_Integer or (
853                         n.is_integer and (
854                             (n - self.start).is_nonnegative ==
855                             self.step.is_positive)):
856                     return n
857             _ = self.size  # validate
858             rv = (self.stop if i < 0 else self.start) + i*self.step
859             if rv.is_infinite:
860                 raise ValueError(ooslice)
861             if rv < self.inf or rv > self.sup:
862                 raise IndexError("Range index out of range")
863             return rv
864 
865     @property
866     def _inf(self):
867         if not self:
868             raise NotImplementedError
869         if self.has(Symbol):
870             if self.step.is_positive:
871                 return self[0]
872             elif self.step.is_negative:
873                 return self[-1]
874             _ = self.size  # validate
875         if self.step > 0:
876             return self.start
877         else:
878             return self.stop - self.step
879 
880     @property
881     def _sup(self):
882         if not self:
883             raise NotImplementedError
884         if self.has(Symbol):
885             if self.step.is_positive:
886                 return self[-1]
887             elif self.step.is_negative:
888                 return self[0]
889             _ = self.size  # validate
890         if self.step > 0:
891             return self.stop - self.step
892         else:
893             return self.start
894 
895     @property
896     def _boundary(self):
897         return self
898 
899     def as_relational(self, x):
900         """Rewrite a Range in terms of equalities and logic operators. """
901         from sympy.functions.elementary.integers import floor
902         return And(
903             Eq(x, floor(x)),
904             x >= self.inf if self.inf in self else x > self.inf,
905             x <= self.sup if self.sup in self else x < self.sup)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/relational.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.utilities.exceptions import SymPyDeprecationWarning
4 from .add import _unevaluated_Add, Add
5 from .basic import S
6 from .compatibility import ordered
7 from .expr import Expr
8 from .evalf import EvalfMixin
9 from .sympify import _sympify
10 from .evaluate import global_evaluate
11 
12 from sympy.logic.boolalg import Boolean, BooleanAtom
13 
14 __all__ = (
15     'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',
16     'Relational', 'Equality', 'Unequality', 'StrictLessThan', 'LessThan',
17     'StrictGreaterThan', 'GreaterThan',
18 )
19 
20 
21 
22 # Note, see issue 4986.  Ideally, we wouldn't want to subclass both Boolean
23 # and Expr.
24 
25 def _canonical(cond):
26     # return a condition in which all relationals are canonical
27     reps = {r: r.canonical for r in cond.atoms(Relational)}
28     return cond.xreplace(reps)
29     # XXX: AttributeError was being caught here but it wasn't triggered by any of
30     # the tests so I've removed it...
31 
32 
33 class Relational(Boolean, Expr, EvalfMixin):
34     """Base class for all relation types.
35 
36     Subclasses of Relational should generally be instantiated directly, but
37     Relational can be instantiated with a valid ``rop`` value to dispatch to
38     the appropriate subclass.
39 
40     Parameters
41     ==========
42     rop : str or None
43         Indicates what subclass to instantiate.  Valid values can be found
44         in the keys of Relational.ValidRelationalOperator.
45 
46     Examples
47     ========
48 
49     >>> from sympy import Rel
50     >>> from sympy.abc import x, y
51     >>> Rel(y, x + x**2, '==')
52     Eq(y, x**2 + x)
53 
54     """
55     __slots__ = []
56 
57     is_Relational = True
58 
59     # ValidRelationOperator - Defined below, because the necessary classes
60     #   have not yet been defined
61 
62     def __new__(cls, lhs, rhs, rop=None, **assumptions):
63         # If called by a subclass, do nothing special and pass on to Expr.
64         if cls is not Relational:
65             return Expr.__new__(cls, lhs, rhs, **assumptions)
66         # If called directly with an operator, look up the subclass
67         # corresponding to that operator and delegate to it
68         try:
69             cls = cls.ValidRelationOperator[rop]
70             rv = cls(lhs, rhs, **assumptions)
71             # /// drop when Py2 is no longer supported
72             # validate that Booleans are not being used in a relational
73             # other than Eq/Ne;
74             if isinstance(rv, (Eq, Ne)):
75                 pass
76             elif isinstance(rv, Relational):  # could it be otherwise?
77                 from sympy.core.symbol import Symbol
78                 from sympy.logic.boolalg import Boolean
79                 for a in rv.args:
80                     if isinstance(a, Symbol):
81                         continue
82                     if isinstance(a, Boolean):
83                         from sympy.utilities.misc import filldedent
84                         raise TypeError(filldedent('''
85                             A Boolean argument can only be used in
86                             Eq and Ne; all other relationals expect
87                             real expressions.
88                         '''))
89             # \\\
90             return rv
91         except KeyError:
92             raise ValueError(
93                 "Invalid relational operator symbol: %r" % rop)
94 
95     @property
96     def lhs(self):
97         """The left-hand side of the relation."""
98         return self._args[0]
99 
100     @property
101     def rhs(self):
102         """The right-hand side of the relation."""
103         return self._args[1]
104 
105     @property
106     def reversed(self):
107         """Return the relationship with sides reversed.
108 
109         Examples
110         ========
111 
112         >>> from sympy import Eq
113         >>> from sympy.abc import x
114         >>> Eq(x, 1)
115         Eq(x, 1)
116         >>> _.reversed
117         Eq(1, x)
118         >>> x < 1
119         x < 1
120         >>> _.reversed
121         1 > x
122         """
123         ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}
124         a, b = self.args
125         return Relational.__new__(ops.get(self.func, self.func), b, a)
126 
127     @property
128     def reversedsign(self):
129         """Return the relationship with signs reversed.
130 
131         Examples
132         ========
133 
134         >>> from sympy import Eq
135         >>> from sympy.abc import x
136         >>> Eq(x, 1)
137         Eq(x, 1)
138         >>> _.reversedsign
139         Eq(-x, -1)
140         >>> x < 1
141         x < 1
142         >>> _.reversedsign
143         -x > -1
144         """
145         a, b = self.args
146         if not (isinstance(a, BooleanAtom) or isinstance(b, BooleanAtom)):
147             ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}
148             return Relational.__new__(ops.get(self.func, self.func), -a, -b)
149         else:
150             return self
151 
152     @property
153     def negated(self):
154         """Return the negated relationship.
155 
156         Examples
157         ========
158 
159         >>> from sympy import Eq
160         >>> from sympy.abc import x
161         >>> Eq(x, 1)
162         Eq(x, 1)
163         >>> _.negated
164         Ne(x, 1)
165         >>> x < 1
166         x < 1
167         >>> _.negated
168         x >= 1
169 
170         Notes
171         =====
172 
173         This works more or less identical to ``~``/``Not``. The difference is
174         that ``negated`` returns the relationship even if ``evaluate=False``.
175         Hence, this is useful in code when checking for e.g. negated relations
176         to existing ones as it will not be affected by the `evaluate` flag.
177 
178         """
179         ops = {Eq: Ne, Ge: Lt, Gt: Le, Le: Gt, Lt: Ge, Ne: Eq}
180         # If there ever will be new Relational subclasses, the following line
181         # will work until it is properly sorted out
182         # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,
183         #      b, evaluate=evaluate)))(*self.args, evaluate=False)
184         return Relational.__new__(ops.get(self.func), *self.args)
185 
186     def _eval_evalf(self, prec):
187         return self.func(*[s._evalf(prec) for s in self.args])
188 
189     @property
190     def canonical(self):
191         """Return a canonical form of the relational by putting a
192         Number on the rhs else ordering the args. The relation is also changed
193         so that the left-hand side expression does not start with a ``-``.
194         No other simplification is attempted.
195 
196         Examples
197         ========
198 
199         >>> from sympy.abc import x, y
200         >>> x < 2
201         x < 2
202         >>> _.reversed.canonical
203         x < 2
204         >>> (-y < x).canonical
205         x > -y
206         >>> (-y > x).canonical
207         x < -y
208         """
209         args = self.args
210         r = self
211         if r.rhs.is_number:
212             if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:
213                 r = r.reversed
214         elif r.lhs.is_number:
215             r = r.reversed
216         elif tuple(ordered(args)) != args:
217             r = r.reversed
218 
219         LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)
220         RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)
221 
222         if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):
223             return r
224 
225         # Check if first value has negative sign
226         if LHS_CEMS and LHS_CEMS():
227             return r.reversedsign
228         elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():
229             # Right hand side has a minus, but not lhs.
230             # How does the expression with reversed signs behave?
231             # This is so that expressions of the type
232             # Eq(x, -y) and Eq(-x, y)
233             # have the same canonical representation
234             expr1, _ = ordered([r.lhs, -r.rhs])
235             if expr1 != r.lhs:
236                 return r.reversed.reversedsign
237 
238         return r
239 
240     def equals(self, other, failing_expression=False):
241         """Return True if the sides of the relationship are mathematically
242         identical and the type of relationship is the same.
243         If failing_expression is True, return the expression whose truth value
244         was unknown."""
245         if isinstance(other, Relational):
246             if self == other or self.reversed == other:
247                 return True
248             a, b = self, other
249             if a.func in (Eq, Ne) or b.func in (Eq, Ne):
250                 if a.func != b.func:
251                     return False
252                 left, right = [i.equals(j,
253                                         failing_expression=failing_expression)
254                                for i, j in zip(a.args, b.args)]
255                 if left is True:
256                     return right
257                 if right is True:
258                     return left
259                 lr, rl = [i.equals(j, failing_expression=failing_expression)
260                           for i, j in zip(a.args, b.reversed.args)]
261                 if lr is True:
262                     return rl
263                 if rl is True:
264                     return lr
265                 e = (left, right, lr, rl)
266                 if all(i is False for i in e):
267                     return False
268                 for i in e:
269                     if i not in (True, False):
270                         return i
271             else:
272                 if b.func != a.func:
273                     b = b.reversed
274                 if a.func != b.func:
275                     return False
276                 left = a.lhs.equals(b.lhs,
277                                     failing_expression=failing_expression)
278                 if left is False:
279                     return False
280                 right = a.rhs.equals(b.rhs,
281                                      failing_expression=failing_expression)
282                 if right is False:
283                     return False
284                 if left is True:
285                     return right
286                 return left
287 
288     def _eval_simplify(self, **kwargs):
289         r = self
290         r = r.func(*[i.simplify(**kwargs) for i in r.args])
291         if r.is_Relational:
292             dif = r.lhs - r.rhs
293             # replace dif with a valid Number that will
294             # allow a definitive comparison with 0
295             v = None
296             if dif.is_comparable:
297                 v = dif.n(2)
298             elif dif.equals(0):  # XXX this is expensive
299                 v = S.Zero
300             if v is not None:
301                 r = r.func._eval_relation(v, S.Zero)
302             r = r.canonical
303             # If there is only one symbol in the expression,
304             # try to write it on a simplified form
305             free = list(filter(lambda x: x.is_real is not False, r.free_symbols))
306             if len(free) == 1:
307                 try:
308                     from sympy.solvers.solveset import linear_coeffs
309                     x = free.pop()
310                     dif = r.lhs - r.rhs
311                     m, b = linear_coeffs(dif, x)
312                     if m.is_zero is False:
313                         if m.is_negative:
314                             # Dividing with a negative number, so change order of arguments
315                             # canonical will put the symbol back on the lhs later
316                             r = r.func(-b/m, x)
317                         else:
318                             r = r.func(x, -b/m)
319                     else:
320                         r = r.func(b, S.zero)
321                 except ValueError:
322                     # maybe not a linear function, try polynomial
323                     from sympy.polys import Poly, poly, PolynomialError, gcd
324                     try:
325                         p = poly(dif, x)
326                         c = p.all_coeffs()
327                         constant = c[-1]
328                         c[-1] = 0
329                         scale = gcd(c)
330                         c = [ctmp/scale for ctmp in c]
331                         r = r.func(Poly.from_list(c, x).as_expr(), -constant/scale)
332                     except PolynomialError:
333                         pass
334             elif len(free) >= 2:
335                 try:
336                     from sympy.solvers.solveset import linear_coeffs
337                     from sympy.polys import gcd
338                     free = list(ordered(free))
339                     dif = r.lhs - r.rhs
340                     m = linear_coeffs(dif, *free)
341                     constant = m[-1]
342                     del m[-1]
343                     scale = gcd(m)
344                     m = [mtmp/scale for mtmp in m]
345                     nzm = list(filter(lambda f: f[0] != 0, list(zip(m, free))))
346                     if scale.is_zero is False:
347                         if constant != 0:
348                             # lhs: expression, rhs: constant
349                             newexpr = Add(*[i*j for i, j in nzm])
350                             r = r.func(newexpr, -constant/scale)
351                         else:
352                             # keep first term on lhs
353                             lhsterm = nzm[0][0]*nzm[0][1]
354                             del nzm[0]
355                             newexpr = Add(*[i*j for i, j in nzm])
356                             r = r.func(lhsterm, -newexpr)
357 
358                     else:
359                         r = r.func(constant, S.zero)
360                 except ValueError:
361                     pass
362         # Did we get a simplified result?
363         r = r.canonical
364         measure = kwargs['measure']
365         if measure(r) < kwargs['ratio']*measure(self):
366             return r
367         else:
368             return self
369 
370     def _eval_trigsimp(self, **opts):
371         from sympy.simplify import trigsimp
372         return self.func(trigsimp(self.lhs, **opts), trigsimp(self.rhs, **opts))
373 
374 
375     def __nonzero__(self):
376         raise TypeError("cannot determine truth value of Relational")
377 
378     __bool__ = __nonzero__
379 
380     def _eval_as_set(self):
381         # self is univariate and periodicity(self, x) in (0, None)
382         from sympy.solvers.inequalities import solve_univariate_inequality
383         syms = self.free_symbols
384         assert len(syms) == 1
385         x = syms.pop()
386         return solve_univariate_inequality(self, x, relational=False)
387 
388     @property
389     def binary_symbols(self):
390         # override where necessary
391         return set()
392 
393 
394 Rel = Relational
395 
396 
397 class Equality(Relational):
398     """An equal relation between two objects.
399 
400     Represents that two objects are equal.  If they can be easily shown
401     to be definitively equal (or unequal), this will reduce to True (or
402     False).  Otherwise, the relation is maintained as an unevaluated
403     Equality object.  Use the ``simplify`` function on this object for
404     more nontrivial evaluation of the equality relation.
405 
406     As usual, the keyword argument ``evaluate=False`` can be used to
407     prevent any evaluation.
408 
409     Examples
410     ========
411 
412     >>> from sympy import Eq, simplify, exp, cos
413     >>> from sympy.abc import x, y
414     >>> Eq(y, x + x**2)
415     Eq(y, x**2 + x)
416     >>> Eq(2, 5)
417     False
418     >>> Eq(2, 5, evaluate=False)
419     Eq(2, 5)
420     >>> _.doit()
421     False
422     >>> Eq(exp(x), exp(x).rewrite(cos))
423     Eq(exp(x), sinh(x) + cosh(x))
424     >>> simplify(_)
425     True
426 
427     See Also
428     ========
429 
430     sympy.logic.boolalg.Equivalent : for representing equality between two
431         boolean expressions
432 
433     Notes
434     =====
435 
436     This class is not the same as the == operator.  The == operator tests
437     for exact structural equality between two expressions; this class
438     compares expressions mathematically.
439 
440     If either object defines an `_eval_Eq` method, it can be used in place of
441     the default algorithm.  If `lhs._eval_Eq(rhs)` or `rhs._eval_Eq(lhs)`
442     returns anything other than None, that return value will be substituted for
443     the Equality.  If None is returned by `_eval_Eq`, an Equality object will
444     be created as usual.
445 
446     Since this object is already an expression, it does not respond to
447     the method `as_expr` if one tries to create `x - y` from Eq(x, y).
448     This can be done with the `rewrite(Add)` method.
449     """
450     rel_op = '=='
451 
452     __slots__ = []
453 
454     is_Equality = True
455 
456     def __new__(cls, lhs, rhs=None, **options):
457         from sympy.core.add import Add
458         from sympy.core.containers import Tuple
459         from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not
460         from sympy.core.expr import _n2
461         from sympy.functions.elementary.complexes import arg
462         from sympy.simplify.simplify import clear_coefficients
463         from sympy.utilities.iterables import sift
464 
465         if rhs is None:
466             SymPyDeprecationWarning(
467                 feature="Eq(expr) with rhs default to 0",
468                 useinstead="Eq(expr, 0)",
469                 issue=16587,
470                 deprecated_since_version="1.5"
471             ).warn()
472             rhs = 0
473 
474         lhs = _sympify(lhs)
475         rhs = _sympify(rhs)
476 
477         evaluate = options.pop('evaluate', global_evaluate[0])
478 
479         if evaluate:
480             # If one expression has an _eval_Eq, return its results.
481             if hasattr(lhs, '_eval_Eq'):
482                 r = lhs._eval_Eq(rhs)
483                 if r is not None:
484                     return r
485             if hasattr(rhs, '_eval_Eq'):
486                 r = rhs._eval_Eq(lhs)
487                 if r is not None:
488                     return r
489             # If expressions have the same structure, they must be equal.
490             if lhs == rhs:
491                 return S.true  # e.g. True == True
492             elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):
493                 return S.false  # True != False
494             elif not (lhs.is_Symbol or rhs.is_Symbol) and (
495                     isinstance(lhs, Boolean) !=
496                     isinstance(rhs, Boolean)):
497                 return S.false  # only Booleans can equal Booleans
498 
499             if lhs.is_infinite or rhs.is_infinite:
500                 if fuzzy_xor([lhs.is_infinite, rhs.is_infinite]):
501                     return S.false
502                 if fuzzy_xor([lhs.is_extended_real, rhs.is_extended_real]):
503                     return S.false
504                 if fuzzy_and([lhs.is_extended_real, rhs.is_extended_real]):
505                     r = fuzzy_xor([lhs.is_extended_positive, fuzzy_not(rhs.is_extended_positive)])
506                     return S(r)
507 
508                 # Try to split real/imaginary parts and equate them
509                 I = S.ImaginaryUnit
510 
511                 def split_real_imag(expr):
512                     real_imag = lambda t: (
513                             'real' if t.is_extended_real else
514                             'imag' if (I*t).is_extended_real else None)
515                     return sift(Add.make_args(expr), real_imag)
516 
517                 lhs_ri = split_real_imag(lhs)
518                 if not lhs_ri[None]:
519                     rhs_ri = split_real_imag(rhs)
520                     if not rhs_ri[None]:
521                         eq_real = Eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']))
522                         eq_imag = Eq(I*Add(*lhs_ri['imag']), I*Add(*rhs_ri['imag']))
523                         res = fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))
524                         if res is not None:
525                             return S(res)
526 
527                 # Compare e.g. zoo with 1+I*oo by comparing args
528                 arglhs = arg(lhs)
529                 argrhs = arg(rhs)
530                 # Guard against Eq(nan, nan) -> False
531                 if not (arglhs == S.NaN and argrhs == S.NaN):
532                     res = fuzzy_bool(Eq(arglhs, argrhs))
533                     if res is not None:
534                         return S(res)
535 
536                 return Relational.__new__(cls, lhs, rhs, **options)
537 
538             if all(isinstance(i, Expr) for i in (lhs, rhs)):
539                 # see if the difference evaluates
540                 dif = lhs - rhs
541                 z = dif.is_zero
542                 if z is not None:
543                     if z is False and dif.is_commutative:  # issue 10728
544                         return S.false
545                     if z:
546                         return S.true
547                 # evaluate numerically if possible
548                 n2 = _n2(lhs, rhs)
549                 if n2 is not None:
550                     return _sympify(n2 == 0)
551                 # see if the ratio evaluates
552                 n, d = dif.as_numer_denom()
553                 rv = None
554                 if n.is_zero:
555                     rv = d.is_nonzero
556                 elif n.is_finite:
557                     if d.is_infinite:
558                         rv = S.true
559                     elif n.is_zero is False:
560                         rv = d.is_infinite
561                         if rv is None:
562                             # if the condition that makes the denominator
563                             # infinite does not make the original expression
564                             # True then False can be returned
565                             l, r = clear_coefficients(d, S.Infinity)
566                             args = [_.subs(l, r) for _ in (lhs, rhs)]
567                             if args != [lhs, rhs]:
568                                 rv = fuzzy_bool(Eq(*args))
569                                 if rv is True:
570                                     rv = None
571                 elif any(a.is_infinite for a in Add.make_args(n)):
572                     # (inf or nan)/x != 0
573                     rv = S.false
574                 if rv is not None:
575                     return _sympify(rv)
576 
577         return Relational.__new__(cls, lhs, rhs, **options)
578 
579     @classmethod
580     def _eval_relation(cls, lhs, rhs):
581         return _sympify(lhs == rhs)
582 
583     def _eval_rewrite_as_Add(self, *args, **kwargs):
584         """return Eq(L, R) as L - R. To control the evaluation of
585         the result set pass `evaluate=True` to give L - R;
586         if `evaluate=None` then terms in L and R will not cancel
587         but they will be listed in canonical order; otherwise
588         non-canonical args will be returned.
589 
590         Examples
591         ========
592 
593         >>> from sympy import Eq, Add
594         >>> from sympy.abc import b, x
595         >>> eq = Eq(x + b, x - b)
596         >>> eq.rewrite(Add)
597         2*b
598         >>> eq.rewrite(Add, evaluate=None).args
599         (b, b, x, -x)
600         >>> eq.rewrite(Add, evaluate=False).args
601         (b, x, b, -x)
602         """
603         L, R = args
604         evaluate = kwargs.get('evaluate', True)
605         if evaluate:
606             # allow cancellation of args
607             return L - R
608         args = Add.make_args(L) + Add.make_args(-R)
609         if evaluate is None:
610             # no cancellation, but canonical
611             return _unevaluated_Add(*args)
612         # no cancellation, not canonical
613         return Add._from_args(args)
614 
615     @property
616     def binary_symbols(self):
617         if S.true in self.args or S.false in self.args:
618             if self.lhs.is_Symbol:
619                 return set([self.lhs])
620             elif self.rhs.is_Symbol:
621                 return set([self.rhs])
622         return set()
623 
624     def _eval_simplify(self, **kwargs):
625         from sympy.solvers.solveset import linear_coeffs
626         # standard simplify
627         e = super(Equality, self)._eval_simplify(**kwargs)
628         if not isinstance(e, Equality):
629             return e
630         free = self.free_symbols
631         if len(free) == 1:
632             try:
633                 x = free.pop()
634                 m, b = linear_coeffs(
635                     e.rewrite(Add, evaluate=False), x)
636                 if m.is_zero is False:
637                     enew = e.func(x, -b/m)
638                 else:
639                     enew = e.func(m*x, -b)
640                 measure = kwargs['measure']
641                 if measure(enew) <= kwargs['ratio']*measure(e):
642                     e = enew
643             except ValueError:
644                 pass
645         return e.canonical
646 
647 
648 Eq = Equality
649 
650 
651 class Unequality(Relational):
652     """An unequal relation between two objects.
653 
654     Represents that two objects are not equal.  If they can be shown to be
655     definitively equal, this will reduce to False; if definitively unequal,
656     this will reduce to True.  Otherwise, the relation is maintained as an
657     Unequality object.
658 
659     Examples
660     ========
661 
662     >>> from sympy import Ne
663     >>> from sympy.abc import x, y
664     >>> Ne(y, x+x**2)
665     Ne(y, x**2 + x)
666 
667     See Also
668     ========
669     Equality
670 
671     Notes
672     =====
673     This class is not the same as the != operator.  The != operator tests
674     for exact structural equality between two expressions; this class
675     compares expressions mathematically.
676 
677     This class is effectively the inverse of Equality.  As such, it uses the
678     same algorithms, including any available `_eval_Eq` methods.
679 
680     """
681     rel_op = '!='
682 
683     __slots__ = []
684 
685     def __new__(cls, lhs, rhs, **options):
686         lhs = _sympify(lhs)
687         rhs = _sympify(rhs)
688 
689         evaluate = options.pop('evaluate', global_evaluate[0])
690 
691         if evaluate:
692             is_equal = Equality(lhs, rhs)
693             if isinstance(is_equal, BooleanAtom):
694                 return is_equal.negated
695 
696         return Relational.__new__(cls, lhs, rhs, **options)
697 
698     @classmethod
699     def _eval_relation(cls, lhs, rhs):
700         return _sympify(lhs != rhs)
701 
702     @property
703     def binary_symbols(self):
704         if S.true in self.args or S.false in self.args:
705             if self.lhs.is_Symbol:
706                 return set([self.lhs])
707             elif self.rhs.is_Symbol:
708                 return set([self.rhs])
709         return set()
710 
711     def _eval_simplify(self, **kwargs):
712         # simplify as an equality
713         eq = Equality(*self.args)._eval_simplify(**kwargs)
714         if isinstance(eq, Equality):
715             # send back Ne with the new args
716             return self.func(*eq.args)
717         return eq.negated  # result of Ne is the negated Eq
718 
719 
720 Ne = Unequality
721 
722 
723 class _Inequality(Relational):
724     """Internal base class for all *Than types.
725 
726     Each subclass must implement _eval_relation to provide the method for
727     comparing two real numbers.
728 
729     """
730     __slots__ = []
731 
732     def __new__(cls, lhs, rhs, **options):
733         lhs = _sympify(lhs)
734         rhs = _sympify(rhs)
735 
736         evaluate = options.pop('evaluate', global_evaluate[0])
737 
738         if evaluate:
739             # First we invoke the appropriate inequality method of `lhs`
740             # (e.g., `lhs.__lt__`).  That method will try to reduce to
741             # boolean or raise an exception.  It may keep calling
742             # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).
743             # In some cases, `Expr` will just invoke us again (if neither it
744             # nor a subclass was able to reduce to boolean or raise an
745             # exception).  In that case, it must call us with
746             # `evaluate=False` to prevent infinite recursion.
747             r = cls._eval_relation(lhs, rhs)
748             if r is not None:
749                 return r
750             # Note: not sure r could be None, perhaps we never take this
751             # path?  In principle, could use this to shortcut out if a
752             # class realizes the inequality cannot be evaluated further.
753 
754         # make a "non-evaluated" Expr for the inequality
755         return Relational.__new__(cls, lhs, rhs, **options)
756 
757 class _Greater(_Inequality):
758     """Not intended for general use
759 
760     _Greater is only used so that GreaterThan and StrictGreaterThan may
761     subclass it for the .gts and .lts properties.
762 
763     """
764     __slots__ = ()
765 
766     @property
767     def gts(self):
768         return self._args[0]
769 
770     @property
771     def lts(self):
772         return self._args[1]
773 
774 
775 class _Less(_Inequality):
776     """Not intended for general use.
777 
778     _Less is only used so that LessThan and StrictLessThan may subclass it for
779     the .gts and .lts properties.
780 
781     """
782     __slots__ = ()
783 
784     @property
785     def gts(self):
786         return self._args[1]
787 
788     @property
789     def lts(self):
790         return self._args[0]
791 
792 
793 class GreaterThan(_Greater):
794     """Class representations of inequalities.
795 
796     Extended Summary
797     ================
798 
799     The ``*Than`` classes represent inequal relationships, where the left-hand
800     side is generally bigger or smaller than the right-hand side.  For example,
801     the GreaterThan class represents an inequal relationship where the
802     left-hand side is at least as big as the right side, if not bigger.  In
803     mathematical notation:
804 
805     lhs >= rhs
806 
807     In total, there are four ``*Than`` classes, to represent the four
808     inequalities:
809 
810     +-----------------+--------+
811     |Class Name       | Symbol |
812     +=================+========+
813     |GreaterThan      | (>=)   |
814     +-----------------+--------+
815     |LessThan         | (<=)   |
816     +-----------------+--------+
817     |StrictGreaterThan| (>)    |
818     +-----------------+--------+
819     |StrictLessThan   | (<)    |
820     +-----------------+--------+
821 
822     All classes take two arguments, lhs and rhs.
823 
824     +----------------------------+-----------------+
825     |Signature Example           | Math equivalent |
826     +============================+=================+
827     |GreaterThan(lhs, rhs)       |   lhs >= rhs    |
828     +----------------------------+-----------------+
829     |LessThan(lhs, rhs)          |   lhs <= rhs    |
830     +----------------------------+-----------------+
831     |StrictGreaterThan(lhs, rhs) |   lhs >  rhs    |
832     +----------------------------+-----------------+
833     |StrictLessThan(lhs, rhs)    |   lhs <  rhs    |
834     +----------------------------+-----------------+
835 
836     In addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality
837     objects also have the .lts and .gts properties, which represent the "less
838     than side" and "greater than side" of the operator.  Use of .lts and .gts
839     in an algorithm rather than .lhs and .rhs as an assumption of inequality
840     direction will make more explicit the intent of a certain section of code,
841     and will make it similarly more robust to client code changes:
842 
843     >>> from sympy import GreaterThan, StrictGreaterThan
844     >>> from sympy import LessThan,    StrictLessThan
845     >>> from sympy import And, Ge, Gt, Le, Lt, Rel, S
846     >>> from sympy.abc import x, y, z
847     >>> from sympy.core.relational import Relational
848 
849     >>> e = GreaterThan(x, 1)
850     >>> e
851     x >= 1
852     >>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)
853     'x >= 1 is the same as 1 <= x'
854 
855     Examples
856     ========
857 
858     One generally does not instantiate these classes directly, but uses various
859     convenience methods:
860 
861     >>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers
862     ...     print(f(x, 2))
863     x >= 2
864     x > 2
865     x <= 2
866     x < 2
867 
868     Another option is to use the Python inequality operators (>=, >, <=, <)
869     directly.  Their main advantage over the Ge, Gt, Le, and Lt counterparts,
870     is that one can write a more "mathematical looking" statement rather than
871     littering the math with oddball function calls.  However there are certain
872     (minor) caveats of which to be aware (search for 'gotcha', below).
873 
874     >>> x >= 2
875     x >= 2
876     >>> _ == Ge(x, 2)
877     True
878 
879     However, it is also perfectly valid to instantiate a ``*Than`` class less
880     succinctly and less conveniently:
881 
882     >>> Rel(x, 1, ">")
883     x > 1
884     >>> Relational(x, 1, ">")
885     x > 1
886 
887     >>> StrictGreaterThan(x, 1)
888     x > 1
889     >>> GreaterThan(x, 1)
890     x >= 1
891     >>> LessThan(x, 1)
892     x <= 1
893     >>> StrictLessThan(x, 1)
894     x < 1
895 
896     Notes
897     =====
898 
899     There are a couple of "gotchas" to be aware of when using Python's
900     operators.
901 
902     The first is that what your write is not always what you get:
903 
904         >>> 1 < x
905         x > 1
906 
907         Due to the order that Python parses a statement, it may
908         not immediately find two objects comparable.  When "1 < x"
909         is evaluated, Python recognizes that the number 1 is a native
910         number and that x is *not*.  Because a native Python number does
911         not know how to compare itself with a SymPy object
912         Python will try the reflective operation, "x > 1" and that is the
913         form that gets evaluated, hence returned.
914 
915         If the order of the statement is important (for visual output to
916         the console, perhaps), one can work around this annoyance in a
917         couple ways:
918 
919         (1) "sympify" the literal before comparison
920 
921         >>> S(1) < x
922         1 < x
923 
924         (2) use one of the wrappers or less succinct methods described
925         above
926 
927         >>> Lt(1, x)
928         1 < x
929         >>> Relational(1, x, "<")
930         1 < x
931 
932     The second gotcha involves writing equality tests between relationals
933     when one or both sides of the test involve a literal relational:
934 
935         >>> e = x < 1; e
936         x < 1
937         >>> e == e  # neither side is a literal
938         True
939         >>> e == x < 1  # expecting True, too
940         False
941         >>> e != x < 1  # expecting False
942         x < 1
943         >>> x < 1 != x < 1  # expecting False or the same thing as before
944         Traceback (most recent call last):
945         ...
946         TypeError: cannot determine truth value of Relational
947 
948         The solution for this case is to wrap literal relationals in
949         parentheses:
950 
951         >>> e == (x < 1)
952         True
953         >>> e != (x < 1)
954         False
955         >>> (x < 1) != (x < 1)
956         False
957 
958     The third gotcha involves chained inequalities not involving
959     '==' or '!='. Occasionally, one may be tempted to write:
960 
961         >>> e = x < y < z
962         Traceback (most recent call last):
963         ...
964         TypeError: symbolic boolean expression has no truth value.
965 
966         Due to an implementation detail or decision of Python [1]_,
967         there is no way for SymPy to create a chained inequality with
968         that syntax so one must use And:
969 
970         >>> e = And(x < y, y < z)
971         >>> type( e )
972         And
973         >>> e
974         (x < y) & (y < z)
975 
976         Although this can also be done with the '&' operator, it cannot
977         be done with the 'and' operarator:
978 
979         >>> (x < y) & (y < z)
980         (x < y) & (y < z)
981         >>> (x < y) and (y < z)
982         Traceback (most recent call last):
983         ...
984         TypeError: cannot determine truth value of Relational
985 
986     .. [1] This implementation detail is that Python provides no reliable
987        method to determine that a chained inequality is being built.
988        Chained comparison operators are evaluated pairwise, using "and"
989        logic (see
990        http://docs.python.org/2/reference/expressions.html#notin). This
991        is done in an efficient way, so that each object being compared
992        is only evaluated once and the comparison can short-circuit. For
993        example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2
994        > 3)``. The ``and`` operator coerces each side into a bool,
995        returning the object itself when it short-circuits. The bool of
996        the --Than operators will raise TypeError on purpose, because
997        SymPy cannot determine the mathematical ordering of symbolic
998        expressions. Thus, if we were to compute ``x > y > z``, with
999        ``x``, ``y``, and ``z`` being Symbols, Python converts the
1000        statement (roughly) into these steps:
1001 
1002         (1) x > y > z
1003         (2) (x > y) and (y > z)
1004         (3) (GreaterThanObject) and (y > z)
1005         (4) (GreaterThanObject.__nonzero__()) and (y > z)
1006         (5) TypeError
1007 
1008        Because of the "and" added at step 2, the statement gets turned into a
1009        weak ternary statement, and the first object's __nonzero__ method will
1010        raise TypeError.  Thus, creating a chained inequality is not possible.
1011 
1012            In Python, there is no way to override the ``and`` operator, or to
1013            control how it short circuits, so it is impossible to make something
1014            like ``x > y > z`` work.  There was a PEP to change this,
1015            :pep:`335`, but it was officially closed in March, 2012.
1016 
1017     """
1018     __slots__ = ()
1019 
1020     rel_op = '>='
1021 
1022     @classmethod
1023     def _eval_relation(cls, lhs, rhs):
1024         # We don't use the op symbol here: workaround issue #7951
1025         return _sympify(lhs.__ge__(rhs))
1026 
1027 
1028 Ge = GreaterThan
1029 
1030 
1031 class LessThan(_Less):
1032     __doc__ = GreaterThan.__doc__
1033     __slots__ = ()
1034 
1035     rel_op = '<='
1036 
1037     @classmethod
1038     def _eval_relation(cls, lhs, rhs):
1039         # We don't use the op symbol here: workaround issue #7951
1040         return _sympify(lhs.__le__(rhs))
1041 
1042 
1043 Le = LessThan
1044 
1045 
1046 class StrictGreaterThan(_Greater):
1047     __doc__ = GreaterThan.__doc__
1048     __slots__ = ()
1049 
1050     rel_op = '>'
1051 
1052     @classmethod
1053     def _eval_relation(cls, lhs, rhs):
1054         # We don't use the op symbol here: workaround issue #7951
1055         return _sympify(lhs.__gt__(rhs))
1056 
1057 
1058 Gt = StrictGreaterThan
1059 
1060 
1061 class StrictLessThan(_Less):
1062     __doc__ = GreaterThan.__doc__
1063     __slots__ = ()
1064 
1065     rel_op = '<'
1066 
1067     @classmethod
1068     def _eval_relation(cls, lhs, rhs):
1069         # We don't use the op symbol here: workaround issue #7951
1070         return _sympify(lhs.__lt__(rhs))
1071 
1072 
1073 Lt = StrictLessThan
1074 
1075 
1076 # A class-specific (not object-specific) data item used for a minor speedup.
1077 # It is defined here, rather than directly in the class, because the classes
1078 # that it references have not been defined until now (e.g. StrictLessThan).
1079 Relational.ValidRelationOperator = {
1080     None: Equality,
1081     '==': Equality,
1082     'eq': Equality,
1083     '!=': Unequality,
1084     '<>': Unequality,
1085     'ne': Unequality,
1086     '>=': GreaterThan,
1087     'ge': GreaterThan,
1088     '<=': LessThan,
1089     'le': LessThan,
1090     '>': StrictGreaterThan,
1091     'gt': StrictGreaterThan,
1092     '<': StrictLessThan,
1093     'lt': StrictLessThan,
1094 }

</code><intended_behavior>While the direct modification in `__nonzero__` (or `__bool__` in Python 3) might not be necessary for resolving the issue, understanding and possibly enhancing how relational expressions involving symbols are handled might provide a workaround or ancillary solution. The intended behavior, though, is not to alter the raising of the TypeError but to ensure that operations leading to this function account for symbolic cases differently. Therefore, the solution might not be in changing this function but ensuring that set operations like `intersect` do not rely on operations that inherently cannot be performed with symbolic arguments without explicit evaluation strategies in place.</intended_behavior>]
2025-10-16 03:10:16.758 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 03:10:16.759 | INFO     | Search-only: skipping patch selection
2025-10-16 03:10:16.852 | INFO     | Task sympy__sympy-18137 completed successfully.
2025-10-16 03:10:16.853 | INFO     | No patch generated. You can try running ACR again.
