[
    {
        "rel_file_path": "sympy/sets/fancysets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/sets/fancysets.py",
        "start": 670,
        "end": 690,
        "class_name": "Range",
        "method_name": "_contains",
        "code": "670     def _contains(self, other):\n671         if not self:\n672             return S.false\n673         if other.is_infinite:\n674             return S.false\n675         if not other.is_integer:\n676             return other.is_integer\n677         if self.has(Symbol):\n678             try:\n679                 _ = self.size  # validate\n680             except ValueError:\n681                 return\n682         if self.start.is_finite:\n683             ref = self.start\n684         elif self.stop.is_finite:\n685             ref = self.stop\n686         else:\n687             return other.is_Integer\n688         if (ref - other) % self.step:  # off sequence\n689             return S.false\n690         return _sympify(other >= self.inf and other <= self.sup)\n",
        "intended_behavior": "The `_contains` method in the `Range` class should be adjusted to handle symbolic variables more gracefully. When the method encounters a symbolic variable, instead of attempting to evaluate its truthiness directly\u2014which leads to the TypeError\u2014it should return a symbolic condition that represents whether the variable is contained within the range. This would likely involve enhancing the method to return unevaluated expressions or conditions when the direct truth value cannot be determined due to the presence of symbols. The specifics of the implementation will depend on how `sympy` expects to handle such symbolic logic internally."
    },
    {
        "rel_file_path": "sympy/sets/fancysets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/sets/fancysets.py",
        "start": 499,
        "end": 905,
        "class_name": "Range",
        "method_name": null,
        "code": "499 class Range(Set):\n500     \"\"\"\n501     Represents a range of integers. Can be called as Range(stop),\n502     Range(start, stop), or Range(start, stop, step); when stop is\n503     not given it defaults to 1.\n504 \n505     `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value\n506     (juse as for Python ranges) is not included in the Range values.\n507 \n508         >>> from sympy import Range\n509         >>> list(Range(3))\n510         [0, 1, 2]\n511 \n512     The step can also be negative:\n513 \n514         >>> list(Range(10, 0, -2))\n515         [10, 8, 6, 4, 2]\n516 \n517     The stop value is made canonical so equivalent ranges always\n518     have the same args:\n519 \n520         >>> Range(0, 10, 3)\n521         Range(0, 12, 3)\n522 \n523     Infinite ranges are allowed. ``oo`` and ``-oo`` are never included in the\n524     set (``Range`` is always a subset of ``Integers``). If the starting point\n525     is infinite, then the final value is ``stop - step``. To iterate such a\n526     range, it needs to be reversed:\n527 \n528         >>> from sympy import oo\n529         >>> r = Range(-oo, 1)\n530         >>> r[-1]\n531         0\n532         >>> next(iter(r))\n533         Traceback (most recent call last):\n534         ...\n535         TypeError: Cannot iterate over Range with infinite start\n536         >>> next(iter(r.reversed))\n537         0\n538 \n539     Although Range is a set (and supports the normal set\n540     operations) it maintains the order of the elements and can\n541     be used in contexts where `range` would be used.\n542 \n543         >>> from sympy import Interval\n544         >>> Range(0, 10, 2).intersect(Interval(3, 7))\n545         Range(4, 8, 2)\n546         >>> list(_)\n547         [4, 6]\n548 \n549     Although slicing of a Range will always return a Range -- possibly\n550     empty -- an empty set will be returned from any intersection that\n551     is empty:\n552 \n553         >>> Range(3)[:0]\n554         Range(0, 0, 1)\n555         >>> Range(3).intersect(Interval(4, oo))\n556         EmptySet\n557         >>> Range(3).intersect(Range(4, oo))\n558         EmptySet\n559 \n560     Range will accept symbolic arguments but has very limited support\n561     for doing anything other than displaying the Range:\n562 \n563         >>> from sympy import Symbol, pprint\n564         >>> from sympy.abc import i, j, k\n565         >>> Range(i, j, k).start\n566         i\n567         >>> Range(i, j, k).inf\n568         Traceback (most recent call last):\n569         ...\n570         ValueError: invalid method for symbolic range\n571 \n572     Better success will be had when using integer symbols:\n573 \n574         >>> n = Symbol('n', integer=True)\n575         >>> r = Range(n, n + 20, 3)\n576         >>> r.inf\n577         n\n578         >>> pprint(r)\n579         {n, n + 3, ..., n + 17}\n580     \"\"\"\n581 \n582     is_iterable = True\n583 \n584     def __new__(cls, *args):\n585         from sympy.functions.elementary.integers import ceiling\n586         if len(args) == 1:\n587             if isinstance(args[0], range):\n588                 raise TypeError(\n589                     'use sympify(%s) to convert range to Range' % args[0])\n590 \n591         # expand range\n592         slc = slice(*args)\n593 \n594         if slc.step == 0:\n595             raise ValueError(\"step cannot be 0\")\n596 \n597         start, stop, step = slc.start or 0, slc.stop, slc.step or 1\n598         try:\n599             ok = []\n600             for w in (start, stop, step):\n601                 w = sympify(w)\n602                 if w in [S.NegativeInfinity, S.Infinity] or (\n603                         w.has(Symbol) and w.is_integer != False):\n604                     ok.append(w)\n605                 elif not w.is_Integer:\n606                     raise ValueError\n607                 else:\n608                     ok.append(w)\n609         except ValueError:\n610             raise ValueError(filldedent('''\n611     Finite arguments to Range must be integers; `imageset` can define\n612     other cases, e.g. use `imageset(i, i/10, Range(3))` to give\n613     [0, 1/10, 1/5].'''))\n614         start, stop, step = ok\n615 \n616         null = False\n617         if any(i.has(Symbol) for i in (start, stop, step)):\n618             if start == stop:\n619                 null = True\n620             else:\n621                 end = stop\n622         elif start.is_infinite:\n623             span = step*(stop - start)\n624             if span is S.NaN or span <= 0:\n625                 null = True\n626             elif step.is_Integer and stop.is_infinite and abs(step) != 1:\n627                 raise ValueError(filldedent('''\n628                     Step size must be %s in this case.''' % (1 if step > 0 else -1)))\n629             else:\n630                 end = stop\n631         else:\n632             oostep = step.is_infinite\n633             if oostep:\n634                 step = S.One if step > 0 else S.NegativeOne\n635             n = ceiling((stop - start)/step)\n636             if n <= 0:\n637                 null = True\n638             elif oostep:\n639                 end = start + 1\n640                 step = S.One  # make it a canonical single step\n641             else:\n642                 end = start + n*step\n643         if null:\n644             start = end = S.Zero\n645             step = S.One\n646         return Basic.__new__(cls, start, end, step)\n647 \n648     start = property(lambda self: self.args[0])\n649     stop = property(lambda self: self.args[1])\n650     step = property(lambda self: self.args[2])\n651 \n652     @property\n653     def reversed(self):\n654         \"\"\"Return an equivalent Range in the opposite order.\n655 \n656         Examples\n657         ========\n658 \n659         >>> from sympy import Range\n660         >>> Range(10).reversed\n661         Range(9, -1, -1)\n662         \"\"\"\n663         if self.has(Symbol):\n664             _ = self.size  # validate\n665         if not self:\n666             return self\n667         return self.func(\n668             self.stop - self.step, self.start - self.step, -self.step)\n669 \n670     def _contains(self, other):\n671         if not self:\n672             return S.false\n673         if other.is_infinite:\n674             return S.false\n675         if not other.is_integer:\n676             return other.is_integer\n677         if self.has(Symbol):\n678             try:\n679                 _ = self.size  # validate\n680             except ValueError:\n681                 return\n682         if self.start.is_finite:\n683             ref = self.start\n684         elif self.stop.is_finite:\n685             ref = self.stop\n686         else:\n687             return other.is_Integer\n688         if (ref - other) % self.step:  # off sequence\n689             return S.false\n690         return _sympify(other >= self.inf and other <= self.sup)\n691 \n692     def __iter__(self):\n693         if self.has(Symbol):\n694             _ = self.size  # validate\n695         if self.start in [S.NegativeInfinity, S.Infinity]:\n696             raise TypeError(\"Cannot iterate over Range with infinite start\")\n697         elif self:\n698             i = self.start\n699             step = self.step\n700 \n701             while True:\n702                 if (step > 0 and not (self.start <= i < self.stop)) or \\\n703                    (step < 0 and not (self.stop < i <= self.start)):\n704                     break\n705                 yield i\n706                 i += step\n707 \n708     def __len__(self):\n709         rv = self.size\n710         if rv is S.Infinity:\n711             raise ValueError('Use .size to get the length of an infinite Range')\n712         return int(rv)\n713 \n714     @property\n715     def size(self):\n716         if not self:\n717             return S.Zero\n718         dif = self.stop - self.start\n719         if self.has(Symbol):\n720             if dif.has(Symbol) or self.step.has(Symbol) or (\n721                     not self.start.is_integer and not self.stop.is_integer):\n722                 raise ValueError('invalid method for symbolic range')\n723         if dif.is_infinite:\n724             return S.Infinity\n725         return Integer(abs(dif//self.step))\n726 \n727     def __nonzero__(self):\n728         return self.start != self.stop\n729 \n730     __bool__ = __nonzero__\n731 \n732     def __getitem__(self, i):\n733         from sympy.functions.elementary.integers import ceiling\n734         ooslice = \"cannot slice from the end with an infinite value\"\n735         zerostep = \"slice step cannot be zero\"\n736         # if we had to take every other element in the following\n737         # oo, ..., 6, 4, 2, 0\n738         # we might get oo, ..., 4, 0 or oo, ..., 6, 2\n739         ambiguous = \"cannot unambiguously re-stride from the end \" + \\\n740             \"with an infinite value\"\n741         if isinstance(i, slice):\n742             if self.size.is_finite:  # validates, too\n743                 start, stop, step = i.indices(self.size)\n744                 n = ceiling((stop - start)/step)\n745                 if n <= 0:\n746                     return Range(0)\n747                 canonical_stop = start + n*step\n748                 end = canonical_stop - step\n749                 ss = step*self.step\n750                 return Range(self[start], self[end] + ss, ss)\n751             else:  # infinite Range\n752                 start = i.start\n753                 stop = i.stop\n754                 if i.step == 0:\n755                     raise ValueError(zerostep)\n756                 step = i.step or 1\n757                 ss = step*self.step\n758                 #---------------------\n759                 # handle infinite on right\n760                 #   e.g. Range(0, oo) or Range(0, -oo, -1)\n761                 # --------------------\n762                 if self.stop.is_infinite:\n763                     # start and stop are not interdependent --\n764                     # they only depend on step --so we use the\n765                     # equivalent reversed values\n766                     return self.reversed[\n767                         stop if stop is None else -stop + 1:\n768                         start if start is None else -start:\n769                         step].reversed\n770                 #---------------------\n771                 # handle infinite on the left\n772                 #   e.g. Range(oo, 0, -1) or Range(-oo, 0)\n773                 # --------------------\n774                 # consider combinations of\n775                 # start/stop {== None, < 0, == 0, > 0} and\n776                 # step {< 0, > 0}\n777                 if start is None:\n778                     if stop is None:\n779                         if step < 0:\n780                             return Range(self[-1], self.start, ss)\n781                         elif step > 1:\n782                             raise ValueError(ambiguous)\n783                         else:  # == 1\n784                             return self\n785                     elif stop < 0:\n786                         if step < 0:\n787                             return Range(self[-1], self[stop], ss)\n788                         else:  # > 0\n789                             return Range(self.start, self[stop], ss)\n790                     elif stop == 0:\n791                         if step > 0:\n792                             return Range(0)\n793                         else:  # < 0\n794                             raise ValueError(ooslice)\n795                     elif stop == 1:\n796                         if step > 0:\n797                             raise ValueError(ooslice)  # infinite singleton\n798                         else:  # < 0\n799                             raise ValueError(ooslice)\n800                     else:  # > 1\n801                         raise ValueError(ooslice)\n802                 elif start < 0:\n803                     if stop is None:\n804                         if step < 0:\n805                             return Range(self[start], self.start, ss)\n806                         else:  # > 0\n807                             return Range(self[start], self.stop, ss)\n808                     elif stop < 0:\n809                         return Range(self[start], self[stop], ss)\n810                     elif stop == 0:\n811                         if step < 0:\n812                             raise ValueError(ooslice)\n813                         else:  # > 0\n814                             return Range(0)\n815                     elif stop > 0:\n816                         raise ValueError(ooslice)\n817                 elif start == 0:\n818                     if stop is None:\n819                         if step < 0:\n820                             raise ValueError(ooslice)  # infinite singleton\n821                         elif step > 1:\n822                             raise ValueError(ambiguous)\n823                         else:  # == 1\n824                             return self\n825                     elif stop < 0:\n826                         if step > 1:\n827                             raise ValueError(ambiguous)\n828                         elif step == 1:\n829                             return Range(self.start, self[stop], ss)\n830                         else:  # < 0\n831                             return Range(0)\n832                     else:  # >= 0\n833                         raise ValueError(ooslice)\n834                 elif start > 0:\n835                     raise ValueError(ooslice)\n836         else:\n837             if not self:\n838                 raise IndexError('Range index out of range')\n839             if i == 0:\n840                 if self.start.is_infinite:\n841                     raise ValueError(ooslice)\n842                 if self.has(Symbol):\n843                     if (self.stop > self.start) == self.step.is_positive and self.step.is_positive is not None:\n844                         pass\n845                     else:\n846                         _ = self.size  # validate\n847                 return self.start\n848             if i == -1:\n849                 if self.stop.is_infinite:\n850                     raise ValueError(ooslice)\n851                 n = self.stop - self.step\n852                 if n.is_Integer or (\n853                         n.is_integer and (\n854                             (n - self.start).is_nonnegative ==\n855                             self.step.is_positive)):\n856                     return n\n857             _ = self.size  # validate\n858             rv = (self.stop if i < 0 else self.start) + i*self.step\n859             if rv.is_infinite:\n860                 raise ValueError(ooslice)\n861             if rv < self.inf or rv > self.sup:\n862                 raise IndexError(\"Range index out of range\")\n863             return rv\n864 \n865     @property\n866     def _inf(self):\n867         if not self:\n868             raise NotImplementedError\n869         if self.has(Symbol):\n870             if self.step.is_positive:\n871                 return self[0]\n872             elif self.step.is_negative:\n873                 return self[-1]\n874             _ = self.size  # validate\n875         if self.step > 0:\n876             return self.start\n877         else:\n878             return self.stop - self.step\n879 \n880     @property\n881     def _sup(self):\n882         if not self:\n883             raise NotImplementedError\n884         if self.has(Symbol):\n885             if self.step.is_positive:\n886                 return self[-1]\n887             elif self.step.is_negative:\n888                 return self[0]\n889             _ = self.size  # validate\n890         if self.step > 0:\n891             return self.stop - self.step\n892         else:\n893             return self.start\n894 \n895     @property\n896     def _boundary(self):\n897         return self\n898 \n899     def as_relational(self, x):\n900         \"\"\"Rewrite a Range in terms of equalities and logic operators. \"\"\"\n901         from sympy.functions.elementary.integers import floor\n902         return And(\n903             Eq(x, floor(x)),\n904             x >= self.inf if self.inf in self else x > self.inf,\n905             x <= self.sup if self.sup in self else x < self.sup)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sympy/core/relational.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/relational.py",
        "start": 1,
        "end": 1094,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.utilities.exceptions import SymPyDeprecationWarning\n4 from .add import _unevaluated_Add, Add\n5 from .basic import S\n6 from .compatibility import ordered\n7 from .expr import Expr\n8 from .evalf import EvalfMixin\n9 from .sympify import _sympify\n10 from .evaluate import global_evaluate\n11 \n12 from sympy.logic.boolalg import Boolean, BooleanAtom\n13 \n14 __all__ = (\n15     'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',\n16     'Relational', 'Equality', 'Unequality', 'StrictLessThan', 'LessThan',\n17     'StrictGreaterThan', 'GreaterThan',\n18 )\n19 \n20 \n21 \n22 # Note, see issue 4986.  Ideally, we wouldn't want to subclass both Boolean\n23 # and Expr.\n24 \n25 def _canonical(cond):\n26     # return a condition in which all relationals are canonical\n27     reps = {r: r.canonical for r in cond.atoms(Relational)}\n28     return cond.xreplace(reps)\n29     # XXX: AttributeError was being caught here but it wasn't triggered by any of\n30     # the tests so I've removed it...\n31 \n32 \n33 class Relational(Boolean, Expr, EvalfMixin):\n34     \"\"\"Base class for all relation types.\n35 \n36     Subclasses of Relational should generally be instantiated directly, but\n37     Relational can be instantiated with a valid ``rop`` value to dispatch to\n38     the appropriate subclass.\n39 \n40     Parameters\n41     ==========\n42     rop : str or None\n43         Indicates what subclass to instantiate.  Valid values can be found\n44         in the keys of Relational.ValidRelationalOperator.\n45 \n46     Examples\n47     ========\n48 \n49     >>> from sympy import Rel\n50     >>> from sympy.abc import x, y\n51     >>> Rel(y, x + x**2, '==')\n52     Eq(y, x**2 + x)\n53 \n54     \"\"\"\n55     __slots__ = []\n56 \n57     is_Relational = True\n58 \n59     # ValidRelationOperator - Defined below, because the necessary classes\n60     #   have not yet been defined\n61 \n62     def __new__(cls, lhs, rhs, rop=None, **assumptions):\n63         # If called by a subclass, do nothing special and pass on to Expr.\n64         if cls is not Relational:\n65             return Expr.__new__(cls, lhs, rhs, **assumptions)\n66         # If called directly with an operator, look up the subclass\n67         # corresponding to that operator and delegate to it\n68         try:\n69             cls = cls.ValidRelationOperator[rop]\n70             rv = cls(lhs, rhs, **assumptions)\n71             # /// drop when Py2 is no longer supported\n72             # validate that Booleans are not being used in a relational\n73             # other than Eq/Ne;\n74             if isinstance(rv, (Eq, Ne)):\n75                 pass\n76             elif isinstance(rv, Relational):  # could it be otherwise?\n77                 from sympy.core.symbol import Symbol\n78                 from sympy.logic.boolalg import Boolean\n79                 for a in rv.args:\n80                     if isinstance(a, Symbol):\n81                         continue\n82                     if isinstance(a, Boolean):\n83                         from sympy.utilities.misc import filldedent\n84                         raise TypeError(filldedent('''\n85                             A Boolean argument can only be used in\n86                             Eq and Ne; all other relationals expect\n87                             real expressions.\n88                         '''))\n89             # \\\\\\\n90             return rv\n91         except KeyError:\n92             raise ValueError(\n93                 \"Invalid relational operator symbol: %r\" % rop)\n94 \n95     @property\n96     def lhs(self):\n97         \"\"\"The left-hand side of the relation.\"\"\"\n98         return self._args[0]\n99 \n100     @property\n101     def rhs(self):\n102         \"\"\"The right-hand side of the relation.\"\"\"\n103         return self._args[1]\n104 \n105     @property\n106     def reversed(self):\n107         \"\"\"Return the relationship with sides reversed.\n108 \n109         Examples\n110         ========\n111 \n112         >>> from sympy import Eq\n113         >>> from sympy.abc import x\n114         >>> Eq(x, 1)\n115         Eq(x, 1)\n116         >>> _.reversed\n117         Eq(1, x)\n118         >>> x < 1\n119         x < 1\n120         >>> _.reversed\n121         1 > x\n122         \"\"\"\n123         ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}\n124         a, b = self.args\n125         return Relational.__new__(ops.get(self.func, self.func), b, a)\n126 \n127     @property\n128     def reversedsign(self):\n129         \"\"\"Return the relationship with signs reversed.\n130 \n131         Examples\n132         ========\n133 \n134         >>> from sympy import Eq\n135         >>> from sympy.abc import x\n136         >>> Eq(x, 1)\n137         Eq(x, 1)\n138         >>> _.reversedsign\n139         Eq(-x, -1)\n140         >>> x < 1\n141         x < 1\n142         >>> _.reversedsign\n143         -x > -1\n144         \"\"\"\n145         a, b = self.args\n146         if not (isinstance(a, BooleanAtom) or isinstance(b, BooleanAtom)):\n147             ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}\n148             return Relational.__new__(ops.get(self.func, self.func), -a, -b)\n149         else:\n150             return self\n151 \n152     @property\n153     def negated(self):\n154         \"\"\"Return the negated relationship.\n155 \n156         Examples\n157         ========\n158 \n159         >>> from sympy import Eq\n160         >>> from sympy.abc import x\n161         >>> Eq(x, 1)\n162         Eq(x, 1)\n163         >>> _.negated\n164         Ne(x, 1)\n165         >>> x < 1\n166         x < 1\n167         >>> _.negated\n168         x >= 1\n169 \n170         Notes\n171         =====\n172 \n173         This works more or less identical to ``~``/``Not``. The difference is\n174         that ``negated`` returns the relationship even if ``evaluate=False``.\n175         Hence, this is useful in code when checking for e.g. negated relations\n176         to existing ones as it will not be affected by the `evaluate` flag.\n177 \n178         \"\"\"\n179         ops = {Eq: Ne, Ge: Lt, Gt: Le, Le: Gt, Lt: Ge, Ne: Eq}\n180         # If there ever will be new Relational subclasses, the following line\n181         # will work until it is properly sorted out\n182         # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,\n183         #      b, evaluate=evaluate)))(*self.args, evaluate=False)\n184         return Relational.__new__(ops.get(self.func), *self.args)\n185 \n186     def _eval_evalf(self, prec):\n187         return self.func(*[s._evalf(prec) for s in self.args])\n188 \n189     @property\n190     def canonical(self):\n191         \"\"\"Return a canonical form of the relational by putting a\n192         Number on the rhs else ordering the args. The relation is also changed\n193         so that the left-hand side expression does not start with a ``-``.\n194         No other simplification is attempted.\n195 \n196         Examples\n197         ========\n198 \n199         >>> from sympy.abc import x, y\n200         >>> x < 2\n201         x < 2\n202         >>> _.reversed.canonical\n203         x < 2\n204         >>> (-y < x).canonical\n205         x > -y\n206         >>> (-y > x).canonical\n207         x < -y\n208         \"\"\"\n209         args = self.args\n210         r = self\n211         if r.rhs.is_number:\n212             if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:\n213                 r = r.reversed\n214         elif r.lhs.is_number:\n215             r = r.reversed\n216         elif tuple(ordered(args)) != args:\n217             r = r.reversed\n218 \n219         LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)\n220         RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)\n221 \n222         if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):\n223             return r\n224 \n225         # Check if first value has negative sign\n226         if LHS_CEMS and LHS_CEMS():\n227             return r.reversedsign\n228         elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():\n229             # Right hand side has a minus, but not lhs.\n230             # How does the expression with reversed signs behave?\n231             # This is so that expressions of the type\n232             # Eq(x, -y) and Eq(-x, y)\n233             # have the same canonical representation\n234             expr1, _ = ordered([r.lhs, -r.rhs])\n235             if expr1 != r.lhs:\n236                 return r.reversed.reversedsign\n237 \n238         return r\n239 \n240     def equals(self, other, failing_expression=False):\n241         \"\"\"Return True if the sides of the relationship are mathematically\n242         identical and the type of relationship is the same.\n243         If failing_expression is True, return the expression whose truth value\n244         was unknown.\"\"\"\n245         if isinstance(other, Relational):\n246             if self == other or self.reversed == other:\n247                 return True\n248             a, b = self, other\n249             if a.func in (Eq, Ne) or b.func in (Eq, Ne):\n250                 if a.func != b.func:\n251                     return False\n252                 left, right = [i.equals(j,\n253                                         failing_expression=failing_expression)\n254                                for i, j in zip(a.args, b.args)]\n255                 if left is True:\n256                     return right\n257                 if right is True:\n258                     return left\n259                 lr, rl = [i.equals(j, failing_expression=failing_expression)\n260                           for i, j in zip(a.args, b.reversed.args)]\n261                 if lr is True:\n262                     return rl\n263                 if rl is True:\n264                     return lr\n265                 e = (left, right, lr, rl)\n266                 if all(i is False for i in e):\n267                     return False\n268                 for i in e:\n269                     if i not in (True, False):\n270                         return i\n271             else:\n272                 if b.func != a.func:\n273                     b = b.reversed\n274                 if a.func != b.func:\n275                     return False\n276                 left = a.lhs.equals(b.lhs,\n277                                     failing_expression=failing_expression)\n278                 if left is False:\n279                     return False\n280                 right = a.rhs.equals(b.rhs,\n281                                      failing_expression=failing_expression)\n282                 if right is False:\n283                     return False\n284                 if left is True:\n285                     return right\n286                 return left\n287 \n288     def _eval_simplify(self, **kwargs):\n289         r = self\n290         r = r.func(*[i.simplify(**kwargs) for i in r.args])\n291         if r.is_Relational:\n292             dif = r.lhs - r.rhs\n293             # replace dif with a valid Number that will\n294             # allow a definitive comparison with 0\n295             v = None\n296             if dif.is_comparable:\n297                 v = dif.n(2)\n298             elif dif.equals(0):  # XXX this is expensive\n299                 v = S.Zero\n300             if v is not None:\n301                 r = r.func._eval_relation(v, S.Zero)\n302             r = r.canonical\n303             # If there is only one symbol in the expression,\n304             # try to write it on a simplified form\n305             free = list(filter(lambda x: x.is_real is not False, r.free_symbols))\n306             if len(free) == 1:\n307                 try:\n308                     from sympy.solvers.solveset import linear_coeffs\n309                     x = free.pop()\n310                     dif = r.lhs - r.rhs\n311                     m, b = linear_coeffs(dif, x)\n312                     if m.is_zero is False:\n313                         if m.is_negative:\n314                             # Dividing with a negative number, so change order of arguments\n315                             # canonical will put the symbol back on the lhs later\n316                             r = r.func(-b/m, x)\n317                         else:\n318                             r = r.func(x, -b/m)\n319                     else:\n320                         r = r.func(b, S.zero)\n321                 except ValueError:\n322                     # maybe not a linear function, try polynomial\n323                     from sympy.polys import Poly, poly, PolynomialError, gcd\n324                     try:\n325                         p = poly(dif, x)\n326                         c = p.all_coeffs()\n327                         constant = c[-1]\n328                         c[-1] = 0\n329                         scale = gcd(c)\n330                         c = [ctmp/scale for ctmp in c]\n331                         r = r.func(Poly.from_list(c, x).as_expr(), -constant/scale)\n332                     except PolynomialError:\n333                         pass\n334             elif len(free) >= 2:\n335                 try:\n336                     from sympy.solvers.solveset import linear_coeffs\n337                     from sympy.polys import gcd\n338                     free = list(ordered(free))\n339                     dif = r.lhs - r.rhs\n340                     m = linear_coeffs(dif, *free)\n341                     constant = m[-1]\n342                     del m[-1]\n343                     scale = gcd(m)\n344                     m = [mtmp/scale for mtmp in m]\n345                     nzm = list(filter(lambda f: f[0] != 0, list(zip(m, free))))\n346                     if scale.is_zero is False:\n347                         if constant != 0:\n348                             # lhs: expression, rhs: constant\n349                             newexpr = Add(*[i*j for i, j in nzm])\n350                             r = r.func(newexpr, -constant/scale)\n351                         else:\n352                             # keep first term on lhs\n353                             lhsterm = nzm[0][0]*nzm[0][1]\n354                             del nzm[0]\n355                             newexpr = Add(*[i*j for i, j in nzm])\n356                             r = r.func(lhsterm, -newexpr)\n357 \n358                     else:\n359                         r = r.func(constant, S.zero)\n360                 except ValueError:\n361                     pass\n362         # Did we get a simplified result?\n363         r = r.canonical\n364         measure = kwargs['measure']\n365         if measure(r) < kwargs['ratio']*measure(self):\n366             return r\n367         else:\n368             return self\n369 \n370     def _eval_trigsimp(self, **opts):\n371         from sympy.simplify import trigsimp\n372         return self.func(trigsimp(self.lhs, **opts), trigsimp(self.rhs, **opts))\n373 \n374 \n375     def __nonzero__(self):\n376         raise TypeError(\"cannot determine truth value of Relational\")\n377 \n378     __bool__ = __nonzero__\n379 \n380     def _eval_as_set(self):\n381         # self is univariate and periodicity(self, x) in (0, None)\n382         from sympy.solvers.inequalities import solve_univariate_inequality\n383         syms = self.free_symbols\n384         assert len(syms) == 1\n385         x = syms.pop()\n386         return solve_univariate_inequality(self, x, relational=False)\n387 \n388     @property\n389     def binary_symbols(self):\n390         # override where necessary\n391         return set()\n392 \n393 \n394 Rel = Relational\n395 \n396 \n397 class Equality(Relational):\n398     \"\"\"An equal relation between two objects.\n399 \n400     Represents that two objects are equal.  If they can be easily shown\n401     to be definitively equal (or unequal), this will reduce to True (or\n402     False).  Otherwise, the relation is maintained as an unevaluated\n403     Equality object.  Use the ``simplify`` function on this object for\n404     more nontrivial evaluation of the equality relation.\n405 \n406     As usual, the keyword argument ``evaluate=False`` can be used to\n407     prevent any evaluation.\n408 \n409     Examples\n410     ========\n411 \n412     >>> from sympy import Eq, simplify, exp, cos\n413     >>> from sympy.abc import x, y\n414     >>> Eq(y, x + x**2)\n415     Eq(y, x**2 + x)\n416     >>> Eq(2, 5)\n417     False\n418     >>> Eq(2, 5, evaluate=False)\n419     Eq(2, 5)\n420     >>> _.doit()\n421     False\n422     >>> Eq(exp(x), exp(x).rewrite(cos))\n423     Eq(exp(x), sinh(x) + cosh(x))\n424     >>> simplify(_)\n425     True\n426 \n427     See Also\n428     ========\n429 \n430     sympy.logic.boolalg.Equivalent : for representing equality between two\n431         boolean expressions\n432 \n433     Notes\n434     =====\n435 \n436     This class is not the same as the == operator.  The == operator tests\n437     for exact structural equality between two expressions; this class\n438     compares expressions mathematically.\n439 \n440     If either object defines an `_eval_Eq` method, it can be used in place of\n441     the default algorithm.  If `lhs._eval_Eq(rhs)` or `rhs._eval_Eq(lhs)`\n442     returns anything other than None, that return value will be substituted for\n443     the Equality.  If None is returned by `_eval_Eq`, an Equality object will\n444     be created as usual.\n445 \n446     Since this object is already an expression, it does not respond to\n447     the method `as_expr` if one tries to create `x - y` from Eq(x, y).\n448     This can be done with the `rewrite(Add)` method.\n449     \"\"\"\n450     rel_op = '=='\n451 \n452     __slots__ = []\n453 \n454     is_Equality = True\n455 \n456     def __new__(cls, lhs, rhs=None, **options):\n457         from sympy.core.add import Add\n458         from sympy.core.containers import Tuple\n459         from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not\n460         from sympy.core.expr import _n2\n461         from sympy.functions.elementary.complexes import arg\n462         from sympy.simplify.simplify import clear_coefficients\n463         from sympy.utilities.iterables import sift\n464 \n465         if rhs is None:\n466             SymPyDeprecationWarning(\n467                 feature=\"Eq(expr) with rhs default to 0\",\n468                 useinstead=\"Eq(expr, 0)\",\n469                 issue=16587,\n470                 deprecated_since_version=\"1.5\"\n471             ).warn()\n472             rhs = 0\n473 \n474         lhs = _sympify(lhs)\n475         rhs = _sympify(rhs)\n476 \n477         evaluate = options.pop('evaluate', global_evaluate[0])\n478 \n479         if evaluate:\n480             # If one expression has an _eval_Eq, return its results.\n481             if hasattr(lhs, '_eval_Eq'):\n482                 r = lhs._eval_Eq(rhs)\n483                 if r is not None:\n484                     return r\n485             if hasattr(rhs, '_eval_Eq'):\n486                 r = rhs._eval_Eq(lhs)\n487                 if r is not None:\n488                     return r\n489             # If expressions have the same structure, they must be equal.\n490             if lhs == rhs:\n491                 return S.true  # e.g. True == True\n492             elif all(isinstance(i, BooleanAtom) for i in (rhs, lhs)):\n493                 return S.false  # True != False\n494             elif not (lhs.is_Symbol or rhs.is_Symbol) and (\n495                     isinstance(lhs, Boolean) !=\n496                     isinstance(rhs, Boolean)):\n497                 return S.false  # only Booleans can equal Booleans\n498 \n499             if lhs.is_infinite or rhs.is_infinite:\n500                 if fuzzy_xor([lhs.is_infinite, rhs.is_infinite]):\n501                     return S.false\n502                 if fuzzy_xor([lhs.is_extended_real, rhs.is_extended_real]):\n503                     return S.false\n504                 if fuzzy_and([lhs.is_extended_real, rhs.is_extended_real]):\n505                     r = fuzzy_xor([lhs.is_extended_positive, fuzzy_not(rhs.is_extended_positive)])\n506                     return S(r)\n507 \n508                 # Try to split real/imaginary parts and equate them\n509                 I = S.ImaginaryUnit\n510 \n511                 def split_real_imag(expr):\n512                     real_imag = lambda t: (\n513                             'real' if t.is_extended_real else\n514                             'imag' if (I*t).is_extended_real else None)\n515                     return sift(Add.make_args(expr), real_imag)\n516 \n517                 lhs_ri = split_real_imag(lhs)\n518                 if not lhs_ri[None]:\n519                     rhs_ri = split_real_imag(rhs)\n520                     if not rhs_ri[None]:\n521                         eq_real = Eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']))\n522                         eq_imag = Eq(I*Add(*lhs_ri['imag']), I*Add(*rhs_ri['imag']))\n523                         res = fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n524                         if res is not None:\n525                             return S(res)\n526 \n527                 # Compare e.g. zoo with 1+I*oo by comparing args\n528                 arglhs = arg(lhs)\n529                 argrhs = arg(rhs)\n530                 # Guard against Eq(nan, nan) -> False\n531                 if not (arglhs == S.NaN and argrhs == S.NaN):\n532                     res = fuzzy_bool(Eq(arglhs, argrhs))\n533                     if res is not None:\n534                         return S(res)\n535 \n536                 return Relational.__new__(cls, lhs, rhs, **options)\n537 \n538             if all(isinstance(i, Expr) for i in (lhs, rhs)):\n539                 # see if the difference evaluates\n540                 dif = lhs - rhs\n541                 z = dif.is_zero\n542                 if z is not None:\n543                     if z is False and dif.is_commutative:  # issue 10728\n544                         return S.false\n545                     if z:\n546                         return S.true\n547                 # evaluate numerically if possible\n548                 n2 = _n2(lhs, rhs)\n549                 if n2 is not None:\n550                     return _sympify(n2 == 0)\n551                 # see if the ratio evaluates\n552                 n, d = dif.as_numer_denom()\n553                 rv = None\n554                 if n.is_zero:\n555                     rv = d.is_nonzero\n556                 elif n.is_finite:\n557                     if d.is_infinite:\n558                         rv = S.true\n559                     elif n.is_zero is False:\n560                         rv = d.is_infinite\n561                         if rv is None:\n562                             # if the condition that makes the denominator\n563                             # infinite does not make the original expression\n564                             # True then False can be returned\n565                             l, r = clear_coefficients(d, S.Infinity)\n566                             args = [_.subs(l, r) for _ in (lhs, rhs)]\n567                             if args != [lhs, rhs]:\n568                                 rv = fuzzy_bool(Eq(*args))\n569                                 if rv is True:\n570                                     rv = None\n571                 elif any(a.is_infinite for a in Add.make_args(n)):\n572                     # (inf or nan)/x != 0\n573                     rv = S.false\n574                 if rv is not None:\n575                     return _sympify(rv)\n576 \n577         return Relational.__new__(cls, lhs, rhs, **options)\n578 \n579     @classmethod\n580     def _eval_relation(cls, lhs, rhs):\n581         return _sympify(lhs == rhs)\n582 \n583     def _eval_rewrite_as_Add(self, *args, **kwargs):\n584         \"\"\"return Eq(L, R) as L - R. To control the evaluation of\n585         the result set pass `evaluate=True` to give L - R;\n586         if `evaluate=None` then terms in L and R will not cancel\n587         but they will be listed in canonical order; otherwise\n588         non-canonical args will be returned.\n589 \n590         Examples\n591         ========\n592 \n593         >>> from sympy import Eq, Add\n594         >>> from sympy.abc import b, x\n595         >>> eq = Eq(x + b, x - b)\n596         >>> eq.rewrite(Add)\n597         2*b\n598         >>> eq.rewrite(Add, evaluate=None).args\n599         (b, b, x, -x)\n600         >>> eq.rewrite(Add, evaluate=False).args\n601         (b, x, b, -x)\n602         \"\"\"\n603         L, R = args\n604         evaluate = kwargs.get('evaluate', True)\n605         if evaluate:\n606             # allow cancellation of args\n607             return L - R\n608         args = Add.make_args(L) + Add.make_args(-R)\n609         if evaluate is None:\n610             # no cancellation, but canonical\n611             return _unevaluated_Add(*args)\n612         # no cancellation, not canonical\n613         return Add._from_args(args)\n614 \n615     @property\n616     def binary_symbols(self):\n617         if S.true in self.args or S.false in self.args:\n618             if self.lhs.is_Symbol:\n619                 return set([self.lhs])\n620             elif self.rhs.is_Symbol:\n621                 return set([self.rhs])\n622         return set()\n623 \n624     def _eval_simplify(self, **kwargs):\n625         from sympy.solvers.solveset import linear_coeffs\n626         # standard simplify\n627         e = super(Equality, self)._eval_simplify(**kwargs)\n628         if not isinstance(e, Equality):\n629             return e\n630         free = self.free_symbols\n631         if len(free) == 1:\n632             try:\n633                 x = free.pop()\n634                 m, b = linear_coeffs(\n635                     e.rewrite(Add, evaluate=False), x)\n636                 if m.is_zero is False:\n637                     enew = e.func(x, -b/m)\n638                 else:\n639                     enew = e.func(m*x, -b)\n640                 measure = kwargs['measure']\n641                 if measure(enew) <= kwargs['ratio']*measure(e):\n642                     e = enew\n643             except ValueError:\n644                 pass\n645         return e.canonical\n646 \n647 \n648 Eq = Equality\n649 \n650 \n651 class Unequality(Relational):\n652     \"\"\"An unequal relation between two objects.\n653 \n654     Represents that two objects are not equal.  If they can be shown to be\n655     definitively equal, this will reduce to False; if definitively unequal,\n656     this will reduce to True.  Otherwise, the relation is maintained as an\n657     Unequality object.\n658 \n659     Examples\n660     ========\n661 \n662     >>> from sympy import Ne\n663     >>> from sympy.abc import x, y\n664     >>> Ne(y, x+x**2)\n665     Ne(y, x**2 + x)\n666 \n667     See Also\n668     ========\n669     Equality\n670 \n671     Notes\n672     =====\n673     This class is not the same as the != operator.  The != operator tests\n674     for exact structural equality between two expressions; this class\n675     compares expressions mathematically.\n676 \n677     This class is effectively the inverse of Equality.  As such, it uses the\n678     same algorithms, including any available `_eval_Eq` methods.\n679 \n680     \"\"\"\n681     rel_op = '!='\n682 \n683     __slots__ = []\n684 \n685     def __new__(cls, lhs, rhs, **options):\n686         lhs = _sympify(lhs)\n687         rhs = _sympify(rhs)\n688 \n689         evaluate = options.pop('evaluate', global_evaluate[0])\n690 \n691         if evaluate:\n692             is_equal = Equality(lhs, rhs)\n693             if isinstance(is_equal, BooleanAtom):\n694                 return is_equal.negated\n695 \n696         return Relational.__new__(cls, lhs, rhs, **options)\n697 \n698     @classmethod\n699     def _eval_relation(cls, lhs, rhs):\n700         return _sympify(lhs != rhs)\n701 \n702     @property\n703     def binary_symbols(self):\n704         if S.true in self.args or S.false in self.args:\n705             if self.lhs.is_Symbol:\n706                 return set([self.lhs])\n707             elif self.rhs.is_Symbol:\n708                 return set([self.rhs])\n709         return set()\n710 \n711     def _eval_simplify(self, **kwargs):\n712         # simplify as an equality\n713         eq = Equality(*self.args)._eval_simplify(**kwargs)\n714         if isinstance(eq, Equality):\n715             # send back Ne with the new args\n716             return self.func(*eq.args)\n717         return eq.negated  # result of Ne is the negated Eq\n718 \n719 \n720 Ne = Unequality\n721 \n722 \n723 class _Inequality(Relational):\n724     \"\"\"Internal base class for all *Than types.\n725 \n726     Each subclass must implement _eval_relation to provide the method for\n727     comparing two real numbers.\n728 \n729     \"\"\"\n730     __slots__ = []\n731 \n732     def __new__(cls, lhs, rhs, **options):\n733         lhs = _sympify(lhs)\n734         rhs = _sympify(rhs)\n735 \n736         evaluate = options.pop('evaluate', global_evaluate[0])\n737 \n738         if evaluate:\n739             # First we invoke the appropriate inequality method of `lhs`\n740             # (e.g., `lhs.__lt__`).  That method will try to reduce to\n741             # boolean or raise an exception.  It may keep calling\n742             # superclasses until it reaches `Expr` (e.g., `Expr.__lt__`).\n743             # In some cases, `Expr` will just invoke us again (if neither it\n744             # nor a subclass was able to reduce to boolean or raise an\n745             # exception).  In that case, it must call us with\n746             # `evaluate=False` to prevent infinite recursion.\n747             r = cls._eval_relation(lhs, rhs)\n748             if r is not None:\n749                 return r\n750             # Note: not sure r could be None, perhaps we never take this\n751             # path?  In principle, could use this to shortcut out if a\n752             # class realizes the inequality cannot be evaluated further.\n753 \n754         # make a \"non-evaluated\" Expr for the inequality\n755         return Relational.__new__(cls, lhs, rhs, **options)\n756 \n757 class _Greater(_Inequality):\n758     \"\"\"Not intended for general use\n759 \n760     _Greater is only used so that GreaterThan and StrictGreaterThan may\n761     subclass it for the .gts and .lts properties.\n762 \n763     \"\"\"\n764     __slots__ = ()\n765 \n766     @property\n767     def gts(self):\n768         return self._args[0]\n769 \n770     @property\n771     def lts(self):\n772         return self._args[1]\n773 \n774 \n775 class _Less(_Inequality):\n776     \"\"\"Not intended for general use.\n777 \n778     _Less is only used so that LessThan and StrictLessThan may subclass it for\n779     the .gts and .lts properties.\n780 \n781     \"\"\"\n782     __slots__ = ()\n783 \n784     @property\n785     def gts(self):\n786         return self._args[1]\n787 \n788     @property\n789     def lts(self):\n790         return self._args[0]\n791 \n792 \n793 class GreaterThan(_Greater):\n794     \"\"\"Class representations of inequalities.\n795 \n796     Extended Summary\n797     ================\n798 \n799     The ``*Than`` classes represent inequal relationships, where the left-hand\n800     side is generally bigger or smaller than the right-hand side.  For example,\n801     the GreaterThan class represents an inequal relationship where the\n802     left-hand side is at least as big as the right side, if not bigger.  In\n803     mathematical notation:\n804 \n805     lhs >= rhs\n806 \n807     In total, there are four ``*Than`` classes, to represent the four\n808     inequalities:\n809 \n810     +-----------------+--------+\n811     |Class Name       | Symbol |\n812     +=================+========+\n813     |GreaterThan      | (>=)   |\n814     +-----------------+--------+\n815     |LessThan         | (<=)   |\n816     +-----------------+--------+\n817     |StrictGreaterThan| (>)    |\n818     +-----------------+--------+\n819     |StrictLessThan   | (<)    |\n820     +-----------------+--------+\n821 \n822     All classes take two arguments, lhs and rhs.\n823 \n824     +----------------------------+-----------------+\n825     |Signature Example           | Math equivalent |\n826     +============================+=================+\n827     |GreaterThan(lhs, rhs)       |   lhs >= rhs    |\n828     +----------------------------+-----------------+\n829     |LessThan(lhs, rhs)          |   lhs <= rhs    |\n830     +----------------------------+-----------------+\n831     |StrictGreaterThan(lhs, rhs) |   lhs >  rhs    |\n832     +----------------------------+-----------------+\n833     |StrictLessThan(lhs, rhs)    |   lhs <  rhs    |\n834     +----------------------------+-----------------+\n835 \n836     In addition to the normal .lhs and .rhs of Relations, ``*Than`` inequality\n837     objects also have the .lts and .gts properties, which represent the \"less\n838     than side\" and \"greater than side\" of the operator.  Use of .lts and .gts\n839     in an algorithm rather than .lhs and .rhs as an assumption of inequality\n840     direction will make more explicit the intent of a certain section of code,\n841     and will make it similarly more robust to client code changes:\n842 \n843     >>> from sympy import GreaterThan, StrictGreaterThan\n844     >>> from sympy import LessThan,    StrictLessThan\n845     >>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n846     >>> from sympy.abc import x, y, z\n847     >>> from sympy.core.relational import Relational\n848 \n849     >>> e = GreaterThan(x, 1)\n850     >>> e\n851     x >= 1\n852     >>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n853     'x >= 1 is the same as 1 <= x'\n854 \n855     Examples\n856     ========\n857 \n858     One generally does not instantiate these classes directly, but uses various\n859     convenience methods:\n860 \n861     >>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n862     ...     print(f(x, 2))\n863     x >= 2\n864     x > 2\n865     x <= 2\n866     x < 2\n867 \n868     Another option is to use the Python inequality operators (>=, >, <=, <)\n869     directly.  Their main advantage over the Ge, Gt, Le, and Lt counterparts,\n870     is that one can write a more \"mathematical looking\" statement rather than\n871     littering the math with oddball function calls.  However there are certain\n872     (minor) caveats of which to be aware (search for 'gotcha', below).\n873 \n874     >>> x >= 2\n875     x >= 2\n876     >>> _ == Ge(x, 2)\n877     True\n878 \n879     However, it is also perfectly valid to instantiate a ``*Than`` class less\n880     succinctly and less conveniently:\n881 \n882     >>> Rel(x, 1, \">\")\n883     x > 1\n884     >>> Relational(x, 1, \">\")\n885     x > 1\n886 \n887     >>> StrictGreaterThan(x, 1)\n888     x > 1\n889     >>> GreaterThan(x, 1)\n890     x >= 1\n891     >>> LessThan(x, 1)\n892     x <= 1\n893     >>> StrictLessThan(x, 1)\n894     x < 1\n895 \n896     Notes\n897     =====\n898 \n899     There are a couple of \"gotchas\" to be aware of when using Python's\n900     operators.\n901 \n902     The first is that what your write is not always what you get:\n903 \n904         >>> 1 < x\n905         x > 1\n906 \n907         Due to the order that Python parses a statement, it may\n908         not immediately find two objects comparable.  When \"1 < x\"\n909         is evaluated, Python recognizes that the number 1 is a native\n910         number and that x is *not*.  Because a native Python number does\n911         not know how to compare itself with a SymPy object\n912         Python will try the reflective operation, \"x > 1\" and that is the\n913         form that gets evaluated, hence returned.\n914 \n915         If the order of the statement is important (for visual output to\n916         the console, perhaps), one can work around this annoyance in a\n917         couple ways:\n918 \n919         (1) \"sympify\" the literal before comparison\n920 \n921         >>> S(1) < x\n922         1 < x\n923 \n924         (2) use one of the wrappers or less succinct methods described\n925         above\n926 \n927         >>> Lt(1, x)\n928         1 < x\n929         >>> Relational(1, x, \"<\")\n930         1 < x\n931 \n932     The second gotcha involves writing equality tests between relationals\n933     when one or both sides of the test involve a literal relational:\n934 \n935         >>> e = x < 1; e\n936         x < 1\n937         >>> e == e  # neither side is a literal\n938         True\n939         >>> e == x < 1  # expecting True, too\n940         False\n941         >>> e != x < 1  # expecting False\n942         x < 1\n943         >>> x < 1 != x < 1  # expecting False or the same thing as before\n944         Traceback (most recent call last):\n945         ...\n946         TypeError: cannot determine truth value of Relational\n947 \n948         The solution for this case is to wrap literal relationals in\n949         parentheses:\n950 \n951         >>> e == (x < 1)\n952         True\n953         >>> e != (x < 1)\n954         False\n955         >>> (x < 1) != (x < 1)\n956         False\n957 \n958     The third gotcha involves chained inequalities not involving\n959     '==' or '!='. Occasionally, one may be tempted to write:\n960 \n961         >>> e = x < y < z\n962         Traceback (most recent call last):\n963         ...\n964         TypeError: symbolic boolean expression has no truth value.\n965 \n966         Due to an implementation detail or decision of Python [1]_,\n967         there is no way for SymPy to create a chained inequality with\n968         that syntax so one must use And:\n969 \n970         >>> e = And(x < y, y < z)\n971         >>> type( e )\n972         And\n973         >>> e\n974         (x < y) & (y < z)\n975 \n976         Although this can also be done with the '&' operator, it cannot\n977         be done with the 'and' operarator:\n978 \n979         >>> (x < y) & (y < z)\n980         (x < y) & (y < z)\n981         >>> (x < y) and (y < z)\n982         Traceback (most recent call last):\n983         ...\n984         TypeError: cannot determine truth value of Relational\n985 \n986     .. [1] This implementation detail is that Python provides no reliable\n987        method to determine that a chained inequality is being built.\n988        Chained comparison operators are evaluated pairwise, using \"and\"\n989        logic (see\n990        http://docs.python.org/2/reference/expressions.html#notin). This\n991        is done in an efficient way, so that each object being compared\n992        is only evaluated once and the comparison can short-circuit. For\n993        example, ``1 > 2 > 3`` is evaluated by Python as ``(1 > 2) and (2\n994        > 3)``. The ``and`` operator coerces each side into a bool,\n995        returning the object itself when it short-circuits. The bool of\n996        the --Than operators will raise TypeError on purpose, because\n997        SymPy cannot determine the mathematical ordering of symbolic\n998        expressions. Thus, if we were to compute ``x > y > z``, with\n999        ``x``, ``y``, and ``z`` being Symbols, Python converts the\n1000        statement (roughly) into these steps:\n1001 \n1002         (1) x > y > z\n1003         (2) (x > y) and (y > z)\n1004         (3) (GreaterThanObject) and (y > z)\n1005         (4) (GreaterThanObject.__nonzero__()) and (y > z)\n1006         (5) TypeError\n1007 \n1008        Because of the \"and\" added at step 2, the statement gets turned into a\n1009        weak ternary statement, and the first object's __nonzero__ method will\n1010        raise TypeError.  Thus, creating a chained inequality is not possible.\n1011 \n1012            In Python, there is no way to override the ``and`` operator, or to\n1013            control how it short circuits, so it is impossible to make something\n1014            like ``x > y > z`` work.  There was a PEP to change this,\n1015            :pep:`335`, but it was officially closed in March, 2012.\n1016 \n1017     \"\"\"\n1018     __slots__ = ()\n1019 \n1020     rel_op = '>='\n1021 \n1022     @classmethod\n1023     def _eval_relation(cls, lhs, rhs):\n1024         # We don't use the op symbol here: workaround issue #7951\n1025         return _sympify(lhs.__ge__(rhs))\n1026 \n1027 \n1028 Ge = GreaterThan\n1029 \n1030 \n1031 class LessThan(_Less):\n1032     __doc__ = GreaterThan.__doc__\n1033     __slots__ = ()\n1034 \n1035     rel_op = '<='\n1036 \n1037     @classmethod\n1038     def _eval_relation(cls, lhs, rhs):\n1039         # We don't use the op symbol here: workaround issue #7951\n1040         return _sympify(lhs.__le__(rhs))\n1041 \n1042 \n1043 Le = LessThan\n1044 \n1045 \n1046 class StrictGreaterThan(_Greater):\n1047     __doc__ = GreaterThan.__doc__\n1048     __slots__ = ()\n1049 \n1050     rel_op = '>'\n1051 \n1052     @classmethod\n1053     def _eval_relation(cls, lhs, rhs):\n1054         # We don't use the op symbol here: workaround issue #7951\n1055         return _sympify(lhs.__gt__(rhs))\n1056 \n1057 \n1058 Gt = StrictGreaterThan\n1059 \n1060 \n1061 class StrictLessThan(_Less):\n1062     __doc__ = GreaterThan.__doc__\n1063     __slots__ = ()\n1064 \n1065     rel_op = '<'\n1066 \n1067     @classmethod\n1068     def _eval_relation(cls, lhs, rhs):\n1069         # We don't use the op symbol here: workaround issue #7951\n1070         return _sympify(lhs.__lt__(rhs))\n1071 \n1072 \n1073 Lt = StrictLessThan\n1074 \n1075 \n1076 # A class-specific (not object-specific) data item used for a minor speedup.\n1077 # It is defined here, rather than directly in the class, because the classes\n1078 # that it references have not been defined until now (e.g. StrictLessThan).\n1079 Relational.ValidRelationOperator = {\n1080     None: Equality,\n1081     '==': Equality,\n1082     'eq': Equality,\n1083     '!=': Unequality,\n1084     '<>': Unequality,\n1085     'ne': Unequality,\n1086     '>=': GreaterThan,\n1087     'ge': GreaterThan,\n1088     '<=': LessThan,\n1089     'le': LessThan,\n1090     '>': StrictGreaterThan,\n1091     'gt': StrictGreaterThan,\n1092     '<': StrictLessThan,\n1093     'lt': StrictLessThan,\n1094 }\n",
        "intended_behavior": "While the direct modification in `__nonzero__` (or `__bool__` in Python 3) might not be necessary for resolving the issue, understanding and possibly enhancing how relational expressions involving symbols are handled might provide a workaround or ancillary solution. The intended behavior, though, is not to alter the raising of the TypeError but to ensure that operations leading to this function account for symbolic cases differently. Therefore, the solution might not be in changing this function but ensuring that set operations like `intersect` do not rely on operations that inherently cannot be performed with symbolic arguments without explicit evaluation strategies in place."
    }
]