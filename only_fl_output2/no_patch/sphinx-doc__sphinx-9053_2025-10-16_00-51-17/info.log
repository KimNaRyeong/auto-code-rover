2025-10-16 00:51:17.968 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:51:20.014 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=109, output_tokens=12, cost=0.001450
2025-10-16 00:51:20.015 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 00:51:20.019 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:51:34.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=418, output_tokens=446, cost=0.017560
2025-10-16 00:51:34.157 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:51:38.256 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=80, cost=0.010400
2025-10-16 00:51:38.257 | DEBUG    | Extracted a valid json.
2025-10-16 00:51:38.257 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"docutils==0.17b1\")",
        "search_code(\"docutils\")",
        "search_code_in_file(\"docutils\", \"requirements.txt\")",
        "search_code_in_file(\"docutils\", \"setup.py\")",
        "search_code(\"import docutils\")"
    ],
    "bug_locations": []
}
2025-10-16 00:51:38.646 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:51:38.647 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:51:56.518 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3300, output_tokens=787, cost=0.056610
2025-10-16 00:51:56.526 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:52:04.185 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4303, output_tokens=294, cost=0.051850
2025-10-16 00:52:04.189 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:52:05.556 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=14, cost=0.006900
2025-10-16 00:52:05.557 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:05.557 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 00:52:06.683 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=14, cost=0.006900
2025-10-16 00:52:06.684 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:06.684 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 00:52:08.321 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=14, cost=0.006900
2025-10-16 00:52:08.322 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:08.322 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 00:52:10.253 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=14, cost=0.006900
2025-10-16 00:52:10.254 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:10.260 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 00:52:11.757 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=14, cost=0.006900
2025-10-16 00:52:11.758 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:11.758 | DEBUG    | Agent proxy return the following json: None
2025-10-16 00:52:11.759 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 00:52:11.760 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 00:52:11.760 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:52:14.638 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4624, output_tokens=86, cost=0.048820
2025-10-16 00:52:14.641 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:52:15.643 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=14, cost=0.004820
2025-10-16 00:52:15.644 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:15.650 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 00:52:19.150 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=14, cost=0.004820
2025-10-16 00:52:19.150 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:19.151 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 00:52:21.344 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=14, cost=0.004820
2025-10-16 00:52:21.345 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:21.345 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 00:52:23.456 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=14, cost=0.004820
2025-10-16 00:52:23.457 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:23.457 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 00:52:24.715 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=14, cost=0.004820
2025-10-16 00:52:24.716 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:24.716 | DEBUG    | Agent proxy return the following json: None
2025-10-16 00:52:24.716 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 00:52:24.717 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 00:52:24.717 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:52:31.795 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4737, output_tokens=279, cost=0.055740
2025-10-16 00:52:31.801 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:52:33.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=14, cost=0.006750
2025-10-16 00:52:33.842 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:33.842 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 00:52:35.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=14, cost=0.006750
2025-10-16 00:52:35.663 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:35.663 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 00:52:37.136 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=14, cost=0.006750
2025-10-16 00:52:37.137 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:37.137 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 00:52:39.679 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=14, cost=0.006750
2025-10-16 00:52:39.680 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:39.680 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 00:52:41.352 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=14, cost=0.006750
2025-10-16 00:52:41.353 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 00:52:41.353 | DEBUG    | Agent proxy return the following json: None
2025-10-16 00:52:41.353 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 00:52:41.354 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 00:52:41.354 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:52:53.400 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5043, output_tokens=500, cost=0.065430
2025-10-16 00:52:53.408 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:52:55.979 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=854, output_tokens=34, cost=0.009560
2025-10-16 00:52:55.980 | DEBUG    | Extracted a valid json.
2025-10-16 00:52:55.980 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"deprecated\")",
        "search_code(\"import docutils\")"
    ],
    "bug_locations": []
}
2025-10-16 00:52:56.096 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:52:56.097 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:53:14.502 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6549, output_tokens=722, cost=0.087150
2025-10-16 00:53:14.512 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:53:25.725 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7487, output_tokens=436, cost=0.087950
2025-10-16 00:53:25.734 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:53:33.441 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=243, cost=0.015190
2025-10-16 00:53:33.442 | DEBUG    | Extracted a valid json.
2025-10-16 00:53:33.442 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that automatic documentation generation from docstrings continues to work seamlessly with `docutils-0.17b1`, without introducing any regressions or incompatibilities."
        },
        {
            "file": "sphinx/parsers.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that all document parsing functionalities maintain their behavior with the newer version of `docutils`. Adjustments may be necessary if `0.17b1` modifies any parsing APIs or behaviors that Sphinx relies upon."
        },
        {
            "file": "sphinx/deprecation.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that no deprecated `docutils` APIs are used by Sphinx, or if they are, to update them to the current APIs provided by `docutils-0.17b1`. Shift away from deprecated APIs, ensuring compatibility with new versions."
        }
    ]
}
2025-10-16 00:53:33.454 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,
18                     Set, Tuple, Type, TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning
26 from sphinx.environment import BuildEnvironment
27 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
28                                          import_object)
29 from sphinx.ext.autodoc.mock import ismock, mock, undecorate
30 from sphinx.locale import _, __
31 from sphinx.pycode import ModuleAnalyzer, PycodeError
32 from sphinx.util import inspect, logging
33 from sphinx.util.docstrings import extract_metadata, prepare_docstring
34 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
35                                  stringify_signature)
36 from sphinx.util.typing import OptionSpec, get_type_hints, restify
37 from sphinx.util.typing import stringify as stringify_typehint
38 
39 if TYPE_CHECKING:
40     from sphinx.ext.autodoc.directive import DocumenterBridge
41 
42 
43 logger = logging.getLogger(__name__)
44 
45 
46 # This type isn't exposed directly in any modules, but can be found
47 # here in most Python versions
48 MethodDescriptorType = type(type.__subclasses__)
49 
50 
51 #: extended signature RE: with explicit module name separated by ::
52 py_ext_sig_re = re.compile(
53     r'''^ ([\w.]+::)?            # explicit module name
54           ([\w.]+\.)?            # module and/or class name(s)
55           (\w+)  \s*             # thing name
56           (?: \((.*)\)           # optional: arguments
57            (?:\s* -> \s* (.*))?  #           return annotation
58           )? $                   # and nothing more
59           ''', re.VERBOSE)
60 special_member_re = re.compile(r'^__\S+__$')
61 
62 
63 def identity(x: Any) -> Any:
64     return x
65 
66 
67 class _All:
68     """A special value for :*-members: that matches to any member."""
69 
70     def __contains__(self, item: Any) -> bool:
71         return True
72 
73 
74 class _Empty:
75     """A special value for :exclude-members: that never matches to any member."""
76 
77     def __contains__(self, item: Any) -> bool:
78         return False
79 
80 
81 ALL = _All()
82 EMPTY = _Empty()
83 UNINITIALIZED_ATTR = object()
84 INSTANCEATTR = object()
85 SLOTSATTR = object()
86 
87 
88 def members_option(arg: Any) -> Union[object, List[str]]:
89     """Used to convert the :members: option to auto directives."""
90     if arg in (None, True):
91         return ALL
92     elif arg is False:
93         return None
94     else:
95         return [x.strip() for x in arg.split(',') if x.strip()]
96 
97 
98 def members_set_option(arg: Any) -> Union[object, Set[str]]:
99     """Used to convert the :members: option to auto directives."""
100     warnings.warn("members_set_option() is deprecated.",
101                   RemovedInSphinx50Warning, stacklevel=2)
102     if arg is None:
103         return ALL
104     return {x.strip() for x in arg.split(',') if x.strip()}
105 
106 
107 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
108     """Used to convert the :exclude-members: option."""
109     if arg in (None, True):
110         return EMPTY
111     return {x.strip() for x in arg.split(',') if x.strip()}
112 
113 
114 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
115     """Used to convert the :members: option to auto directives."""
116     if arg in (None, True):
117         return 'object'
118     else:
119         return arg
120 
121 
122 def member_order_option(arg: Any) -> Optional[str]:
123     """Used to convert the :members: option to auto directives."""
124     if arg in (None, True):
125         return None
126     elif arg in ('alphabetical', 'bysource', 'groupwise'):
127         return arg
128     else:
129         raise ValueError(__('invalid value for member-order option: %s') % arg)
130 
131 
132 SUPPRESS = object()
133 
134 
135 def annotation_option(arg: Any) -> Any:
136     if arg in (None, True):
137         # suppress showing the representation of the object
138         return SUPPRESS
139     else:
140         return arg
141 
142 
143 def bool_option(arg: Any) -> bool:
144     """Used to convert flag options to auto directives.  (Instead of
145     directives.flag(), which returns None).
146     """
147     return True
148 
149 
150 def merge_special_members_option(options: Dict) -> None:
151     """Merge :special-members: option to :members: option."""
152     warnings.warn("merge_special_members_option() is deprecated.",
153                   RemovedInSphinx50Warning, stacklevel=2)
154     if 'special-members' in options and options['special-members'] is not ALL:
155         if options.get('members') is ALL:
156             pass
157         elif options.get('members'):
158             for member in options['special-members']:
159                 if member not in options['members']:
160                     options['members'].append(member)
161         else:
162             options['members'] = options['special-members']
163 
164 
165 def merge_members_option(options: Dict) -> None:
166     """Merge :*-members: option to the :members: option."""
167     if options.get('members') is ALL:
168         # merging is not needed when members: ALL
169         return
170 
171     members = options.setdefault('members', [])
172     for key in {'private-members', 'special-members'}:
173         if key in options and options[key] not in (ALL, None):
174             for member in options[key]:
175                 if member not in members:
176                     members.append(member)
177 
178 
179 # Some useful event listener factories for autodoc-process-docstring.
180 
181 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
182     """Return a listener that removes the first *pre* and last *post*
183     lines of every docstring.  If *what* is a sequence of strings,
184     only docstrings of a type in *what* will be processed.
185 
186     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
187 
188        from sphinx.ext.autodoc import cut_lines
189        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
190 
191     This can (and should) be used in place of :confval:`automodule_skip_lines`.
192     """
193     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
194                 ) -> None:
195         if what and what_ not in what:
196             return
197         del lines[:pre]
198         if post:
199             # remove one trailing blank line.
200             if lines and not lines[-1]:
201                 lines.pop(-1)
202             del lines[-post:]
203         # make sure there is a blank line at the end
204         if lines and lines[-1]:
205             lines.append('')
206     return process
207 
208 
209 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
210             exclude: bool = False) -> Callable:
211     """Return a listener that either keeps, or if *exclude* is True excludes,
212     lines between lines that match the *marker* regular expression.  If no line
213     matches, the resulting docstring would be empty, so no change will be made
214     unless *keepempty* is true.
215 
216     If *what* is a sequence of strings, only docstrings of a type in *what* will
217     be processed.
218     """
219     marker_re = re.compile(marker)
220 
221     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
222                 ) -> None:
223         if what and what_ not in what:
224             return
225         deleted = 0
226         delete = not exclude
227         orig_lines = lines[:]
228         for i, line in enumerate(orig_lines):
229             if delete:
230                 lines.pop(i - deleted)
231                 deleted += 1
232             if marker_re.match(line):
233                 delete = not delete
234                 if delete:
235                     lines.pop(i - deleted)
236                     deleted += 1
237         if not lines and not keepempty:
238             lines[:] = orig_lines
239         # make sure there is a blank line at the end
240         if lines and lines[-1]:
241             lines.append('')
242     return process
243 
244 
245 # This class is used only in ``sphinx.ext.autodoc.directive``,
246 # But we define this class here to keep compatibility (see #4538)
247 class Options(dict):
248     """A dict/attribute hybrid that returns None on nonexisting keys."""
249     def __getattr__(self, name: str) -> Any:
250         try:
251             return self[name.replace('_', '-')]
252         except KeyError:
253             return None
254 
255 
256 class ObjectMember(tuple):
257     """A member of object.
258 
259     This is used for the result of `Documenter.get_object_members()` to
260     represent each member of the object.
261 
262     .. Note::
263 
264        An instance of this class behaves as a tuple of (name, object)
265        for compatibility to old Sphinx.  The behavior will be dropped
266        in the future.  Therefore extensions should not use the tuple
267        interface.
268     """
269 
270     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
271         return super().__new__(cls, (name, obj))  # type: ignore
272 
273     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
274                  class_: Any = None, skipped: bool = False) -> None:
275         self.__name__ = name
276         self.object = obj
277         self.docstring = docstring
278         self.skipped = skipped
279         self.class_ = class_
280 
281 
282 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
283 
284 
285 class Documenter:
286     """
287     A Documenter knows how to autodocument a single object type.  When
288     registered with the AutoDirective, it will be used to document objects
289     of that type when needed by autodoc.
290 
291     Its *objtype* attribute selects what auto directive it is assigned to
292     (the directive name is 'auto' + objtype), and what directive it generates
293     by default, though that can be overridden by an attribute called
294     *directivetype*.
295 
296     A Documenter has an *option_spec* that works like a docutils directive's;
297     in fact, it will be used to parse an auto directive's options that matches
298     the documenter.
299     """
300     #: name by which the directive is called (auto...) and the default
301     #: generated directive name
302     objtype = 'object'
303     #: indentation by which to indent the directive content
304     content_indent = '   '
305     #: priority if multiple documenters return True from can_document_member
306     priority = 0
307     #: order if autodoc_member_order is set to 'groupwise'
308     member_order = 0
309     #: true if the generated content may contain titles
310     titles_allowed = False
311 
312     option_spec: OptionSpec = {
313         'noindex': bool_option
314     }
315 
316     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
317         """getattr() override for types such as Zope interfaces."""
318         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
319 
320     @classmethod
321     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
322                             ) -> bool:
323         """Called to see if a member can be documented by this documenter."""
324         raise NotImplementedError('must be implemented in subclasses')
325 
326     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
327         self.directive = directive
328         self.config: Config = directive.env.config
329         self.env: BuildEnvironment = directive.env
330         self.options = directive.genopt
331         self.name = name
332         self.indent = indent
333         # the module and object path within the module, and the fully
334         # qualified name (all set after resolve_name succeeds)
335         self.modname: str = None
336         self.module: ModuleType = None
337         self.objpath: List[str] = None
338         self.fullname: str = None
339         # extra signature items (arguments and return annotation,
340         # also set after resolve_name succeeds)
341         self.args: str = None
342         self.retann: str = None
343         # the object to document (set after import_object succeeds)
344         self.object: Any = None
345         self.object_name: str = None
346         # the parent/owner of the object to document
347         self.parent: Any = None
348         # the module analyzer to get at attribute docs, or None
349         self.analyzer: ModuleAnalyzer = None
350 
351     @property
352     def documenters(self) -> Dict[str, Type["Documenter"]]:
353         """Returns registered Documenter classes"""
354         return self.env.app.registry.documenters
355 
356     def add_line(self, line: str, source: str, *lineno: int) -> None:
357         """Append one line of generated reST to the output."""
358         if line.strip():  # not a blank line
359             self.directive.result.append(self.indent + line, source, *lineno)
360         else:
361             self.directive.result.append('', source, *lineno)
362 
363     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
364                      ) -> Tuple[str, List[str]]:
365         """Resolve the module and name of the object to document given by the
366         arguments and the current module/class.
367 
368         Must return a pair of the module name and a chain of attributes; for
369         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
370         ``zipfile.ZipFile.open`` method.
371         """
372         raise NotImplementedError('must be implemented in subclasses')
373 
374     def parse_name(self) -> bool:
375         """Determine what module to import and what attribute to document.
376 
377         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
378         *self.args* and *self.retann* if parsing and resolving was successful.
379         """
380         # first, parse the definition -- auto directives for classes and
381         # functions can contain a signature which is then used instead of
382         # an autogenerated one
383         try:
384             explicit_modname, path, base, args, retann = \
385                 py_ext_sig_re.match(self.name).groups()
386         except AttributeError:
387             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
388                            type='autodoc')
389             return False
390 
391         # support explicit module and class name separation via ::
392         if explicit_modname is not None:
393             modname = explicit_modname[:-2]
394             parents = path.rstrip('.').split('.') if path else []
395         else:
396             modname = None
397             parents = []
398 
399         with mock(self.config.autodoc_mock_imports):
400             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
401 
402         if not self.modname:
403             return False
404 
405         self.args = args
406         self.retann = retann
407         self.fullname = (self.modname or '') + \
408                         ('.' + '.'.join(self.objpath) if self.objpath else '')
409         return True
410 
411     def import_object(self, raiseerror: bool = False) -> bool:
412         """Import the object given by *self.modname* and *self.objpath* and set
413         it as *self.object*.
414 
415         Returns True if successful, False if an error occurred.
416         """
417         with mock(self.config.autodoc_mock_imports):
418             try:
419                 ret = import_object(self.modname, self.objpath, self.objtype,
420                                     attrgetter=self.get_attr,
421                                     warningiserror=self.config.autodoc_warningiserror)
422                 self.module, self.parent, self.object_name, self.object = ret
423                 if ismock(self.object):
424                     self.object = undecorate(self.object)
425                 return True
426             except ImportError as exc:
427                 if raiseerror:
428                     raise
429                 else:
430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
431                     self.env.note_reread()
432                     return False
433 
434     def get_real_modname(self) -> str:
435         """Get the real module name of an object to document.
436 
437         It can differ from the name of the module through which the object was
438         imported.
439         """
440         return self.get_attr(self.object, '__module__', None) or self.modname
441 
442     def check_module(self) -> bool:
443         """Check if *self.object* is really defined in the module given by
444         *self.modname*.
445         """
446         if self.options.imported_members:
447             return True
448 
449         subject = inspect.unpartial(self.object)
450         modname = self.get_attr(subject, '__module__', None)
451         if modname and modname != self.modname:
452             return False
453         return True
454 
455     def format_args(self, **kwargs: Any) -> str:
456         """Format the argument signature of *self.object*.
457 
458         Should return None if the object does not have a signature.
459         """
460         return None
461 
462     def format_name(self) -> str:
463         """Format the name of *self.object*.
464 
465         This normally should be something that can be parsed by the generated
466         directive, but doesn't need to be (Sphinx will display it unparsed
467         then).
468         """
469         # normally the name doesn't contain the module (except for module
470         # directives of course)
471         return '.'.join(self.objpath) or self.modname
472 
473     def _call_format_args(self, **kwargs: Any) -> str:
474         if kwargs:
475             try:
476                 return self.format_args(**kwargs)
477             except TypeError:
478                 # avoid chaining exceptions, by putting nothing here
479                 pass
480 
481         # retry without arguments for old documenters
482         return self.format_args()
483 
484     def format_signature(self, **kwargs: Any) -> str:
485         """Format the signature (arguments and return annotation) of the object.
486 
487         Let the user process it via the ``autodoc-process-signature`` event.
488         """
489         if self.args is not None:
490             # signature given explicitly
491             args = "(%s)" % self.args
492             retann = self.retann
493         else:
494             # try to introspect the signature
495             try:
496                 retann = None
497                 args = self._call_format_args(**kwargs)
498                 if args:
499                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
500                     if matched:
501                         args = matched.group(1)
502                         retann = matched.group(2)
503             except Exception as exc:
504                 logger.warning(__('error while formatting arguments for %s: %s'),
505                                self.fullname, exc, type='autodoc')
506                 args = None
507 
508         result = self.env.events.emit_firstresult('autodoc-process-signature',
509                                                   self.objtype, self.fullname,
510                                                   self.object, self.options, args, retann)
511         if result:
512             args, retann = result
513 
514         if args is not None:
515             return args + ((' -> %s' % retann) if retann else '')
516         else:
517             return ''
518 
519     def add_directive_header(self, sig: str) -> None:
520         """Add the directive header and options to the generated content."""
521         domain = getattr(self, 'domain', 'py')
522         directive = getattr(self, 'directivetype', self.objtype)
523         name = self.format_name()
524         sourcename = self.get_sourcename()
525 
526         # one signature per line, indented by column
527         prefix = '.. %s:%s:: ' % (domain, directive)
528         for i, sig_line in enumerate(sig.split("\n")):
529             self.add_line('%s%s%s' % (prefix, name, sig_line),
530                           sourcename)
531             if i == 0:
532                 prefix = " " * len(prefix)
533 
534         if self.options.noindex:
535             self.add_line('   :noindex:', sourcename)
536         if self.objpath:
537             # Be explicit about the module, this is necessary since .. class::
538             # etc. don't support a prepended module name
539             self.add_line('   :module: %s' % self.modname, sourcename)
540 
541     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
542         """Decode and return lines of the docstring(s) for the object.
543 
544         When it returns None value, autodoc-process-docstring will not be called for this
545         object.
546         """
547         if ignore is not None:
548             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
549                           % self.__class__.__name__,
550                           RemovedInSphinx50Warning, stacklevel=2)
551         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
552                            self.parent, self.object_name)
553         if docstring:
554             tab_width = self.directive.state.document.settings.tab_width
555             return [prepare_docstring(docstring, ignore, tab_width)]
556         return []
557 
558     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
559         """Let the user process the docstrings before adding them."""
560         for docstringlines in docstrings:
561             if self.env.app:
562                 # let extensions preprocess docstrings
563                 self.env.app.emit('autodoc-process-docstring',
564                                   self.objtype, self.fullname, self.object,
565                                   self.options, docstringlines)
566 
567                 if docstringlines and docstringlines[-1] != '':
568                     # append a blank line to the end of the docstring
569                     docstringlines.append('')
570 
571             yield from docstringlines
572 
573     def get_sourcename(self) -> str:
574         if (getattr(self.object, '__module__', None) and
575                 getattr(self.object, '__qualname__', None)):
576             # Get the correct location of docstring from self.object
577             # to support inherited methods
578             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
579         else:
580             fullname = self.fullname
581 
582         if self.analyzer:
583             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
584         else:
585             return 'docstring of %s' % fullname
586 
587     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
588                     ) -> None:
589         """Add content from docstrings, attribute documentation and user."""
590         if no_docstring:
591             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
592                           % self.__class__.__name__,
593                           RemovedInSphinx50Warning, stacklevel=2)
594 
595         # set sourcename and add content from attribute documentation
596         sourcename = self.get_sourcename()
597         if self.analyzer:
598             attr_docs = self.analyzer.find_attr_docs()
599             if self.objpath:
600                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
601                 if key in attr_docs:
602                     no_docstring = True
603                     # make a copy of docstring for attributes to avoid cache
604                     # the change of autodoc-process-docstring event.
605                     docstrings = [list(attr_docs[key])]
606 
607                     for i, line in enumerate(self.process_doc(docstrings)):
608                         self.add_line(line, sourcename, i)
609 
610         # add content from docstrings
611         if not no_docstring:
612             docstrings = self.get_doc()
613             if docstrings is None:
614                 # Do not call autodoc-process-docstring on get_doc() returns None.
615                 pass
616             else:
617                 if not docstrings:
618                     # append at least a dummy docstring, so that the event
619                     # autodoc-process-docstring is fired and can add some
620                     # content if desired
621                     docstrings.append([])
622                 for i, line in enumerate(self.process_doc(docstrings)):
623                     self.add_line(line, sourcename, i)
624 
625         # add additional content (e.g. from document), if present
626         if more_content:
627             for line, src in zip(more_content.data, more_content.items):
628                 self.add_line(line, src[0], src[1])
629 
630     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
631         """Return `(members_check_module, members)` where `members` is a
632         list of `(membername, member)` pairs of the members of *self.object*.
633 
634         If *want_all* is True, return all members.  Else, only return those
635         members given by *self.options.members* (which may also be none).
636         """
637         warnings.warn('The implementation of Documenter.get_object_members() will be '
638                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
639         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
640         if not want_all:
641             if not self.options.members:
642                 return False, []  # type: ignore
643             # specific members given
644             selected = []
645             for name in self.options.members:  # type: str
646                 if name in members:
647                     selected.append((name, members[name].value))
648                 else:
649                     logger.warning(__('missing attribute %s in object %s') %
650                                    (name, self.fullname), type='autodoc')
651             return False, selected
652         elif self.options.inherited_members:
653             return False, [(m.name, m.value) for m in members.values()]
654         else:
655             return False, [(m.name, m.value) for m in members.values()
656                            if m.directly_defined]
657 
658     def filter_members(self, members: ObjectMembers, want_all: bool
659                        ) -> List[Tuple[str, Any, bool]]:
660         """Filter the given member list.
661 
662         Members are skipped if
663 
664         - they are private (except if given explicitly or the private-members
665           option is set)
666         - they are special methods (except if given explicitly or the
667           special-members option is set)
668         - they are undocumented (except if the undoc-members option is set)
669 
670         The user can override the skipping decision by connecting to the
671         ``autodoc-skip-member`` event.
672         """
673         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
674             if inspect.isclass(self.object):
675                 for cls in self.object.__mro__:
676                     if cls.__name__ == self.options.inherited_members and cls != self.object:
677                         # given member is a member of specified *super class*
678                         return True
679                     elif name in cls.__dict__:
680                         return False
681                     elif name in self.get_attr(cls, '__annotations__', {}):
682                         return False
683                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
684                         return False
685 
686             return False
687 
688         ret = []
689 
690         # search for members in source code too
691         namespace = '.'.join(self.objpath)  # will be empty for modules
692 
693         if self.analyzer:
694             attr_docs = self.analyzer.find_attr_docs()
695         else:
696             attr_docs = {}
697 
698         # process members and determine which to skip
699         for obj in members:
700             membername, member = obj
701             # if isattr is True, the member is documented as an attribute
702             if member is INSTANCEATTR:
703                 isattr = True
704             else:
705                 isattr = False
706 
707             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
708                          self.parent, self.object_name)
709             if not isinstance(doc, str):
710                 # Ignore non-string __doc__
711                 doc = None
712 
713             # if the member __doc__ is the same as self's __doc__, it's just
714             # inherited and therefore not the member's doc
715             cls = self.get_attr(member, '__class__', None)
716             if cls:
717                 cls_doc = self.get_attr(cls, '__doc__', None)
718                 if cls_doc == doc:
719                     doc = None
720 
721             if isinstance(obj, ObjectMember) and obj.docstring:
722                 # hack for ClassDocumenter to inject docstring via ObjectMember
723                 doc = obj.docstring
724 
725             has_doc = bool(doc)
726 
727             metadata = extract_metadata(doc)
728             if 'private' in metadata:
729                 # consider a member private if docstring has "private" metadata
730                 isprivate = True
731             elif 'public' in metadata:
732                 # consider a member public if docstring has "public" metadata
733                 isprivate = False
734             else:
735                 isprivate = membername.startswith('_')
736 
737             keep = False
738             if ismock(member):
739                 # mocked module or object
740                 pass
741             elif self.options.exclude_members and membername in self.options.exclude_members:
742                 # remove members given by exclude-members
743                 keep = False
744             elif want_all and special_member_re.match(membername):
745                 # special __methods__
746                 if self.options.special_members and membername in self.options.special_members:
747                     if membername == '__doc__':
748                         keep = False
749                     elif is_filtered_inherited_member(membername, obj):
750                         keep = False
751                     else:
752                         keep = has_doc or self.options.undoc_members
753                 else:
754                     keep = False
755             elif (namespace, membername) in attr_docs:
756                 if want_all and isprivate:
757                     if self.options.private_members is None:
758                         keep = False
759                     else:
760                         keep = membername in self.options.private_members
761                 else:
762                     # keep documented attributes
763                     keep = True
764                 isattr = True
765             elif want_all and isprivate:
766                 if has_doc or self.options.undoc_members:
767                     if self.options.private_members is None:
768                         keep = False
769                     elif is_filtered_inherited_member(membername, obj):
770                         keep = False
771                     else:
772                         keep = membername in self.options.private_members
773                 else:
774                     keep = False
775             else:
776                 if (self.options.members is ALL and
777                         is_filtered_inherited_member(membername, obj)):
778                     keep = False
779                 else:
780                     # ignore undocumented members if :undoc-members: is not given
781                     keep = has_doc or self.options.undoc_members
782 
783             if isinstance(obj, ObjectMember) and obj.skipped:
784                 # forcedly skipped member (ex. a module attribute not defined in __all__)
785                 keep = False
786 
787             # give the user a chance to decide whether this member
788             # should be skipped
789             if self.env.app:
790                 # let extensions preprocess docstrings
791                 try:
792                     skip_user = self.env.app.emit_firstresult(
793                         'autodoc-skip-member', self.objtype, membername, member,
794                         not keep, self.options)
795                     if skip_user is not None:
796                         keep = not skip_user
797                 except Exception as exc:
798                     logger.warning(__('autodoc: failed to determine %r to be documented, '
799                                       'the following exception was raised:\n%s'),
800                                    member, exc, type='autodoc')
801                     keep = False
802 
803             if keep:
804                 ret.append((membername, member, isattr))
805 
806         return ret
807 
808     def document_members(self, all_members: bool = False) -> None:
809         """Generate reST for member documentation.
810 
811         If *all_members* is True, do all members, else those given by
812         *self.options.members*.
813         """
814         # set current namespace for finding members
815         self.env.temp_data['autodoc:module'] = self.modname
816         if self.objpath:
817             self.env.temp_data['autodoc:class'] = self.objpath[0]
818 
819         want_all = all_members or self.options.inherited_members or \
820             self.options.members is ALL
821         # find out which members are documentable
822         members_check_module, members = self.get_object_members(want_all)
823 
824         # document non-skipped members
825         memberdocumenters: List[Tuple[Documenter, bool]] = []
826         for (mname, member, isattr) in self.filter_members(members, want_all):
827             classes = [cls for cls in self.documenters.values()
828                        if cls.can_document_member(member, mname, isattr, self)]
829             if not classes:
830                 # don't know how to document this member
831                 continue
832             # prefer the documenter with the highest priority
833             classes.sort(key=lambda cls: cls.priority)
834             # give explicitly separated module name, so that members
835             # of inner classes can be documented
836             full_mname = self.modname + '::' + \
837                 '.'.join(self.objpath + [mname])
838             documenter = classes[-1](self.directive, full_mname, self.indent)
839             memberdocumenters.append((documenter, isattr))
840 
841         member_order = self.options.member_order or self.config.autodoc_member_order
842         memberdocumenters = self.sort_members(memberdocumenters, member_order)
843 
844         for documenter, isattr in memberdocumenters:
845             documenter.generate(
846                 all_members=True, real_modname=self.real_modname,
847                 check_module=members_check_module and not isattr)
848 
849         # reset current objects
850         self.env.temp_data['autodoc:module'] = None
851         self.env.temp_data['autodoc:class'] = None
852 
853     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
854                      order: str) -> List[Tuple["Documenter", bool]]:
855         """Sort the given member list."""
856         if order == 'groupwise':
857             # sort by group; alphabetically within groups
858             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
859         elif order == 'bysource':
860             if self.analyzer:
861                 # sort by source order, by virtue of the module analyzer
862                 tagorder = self.analyzer.tagorder
863 
864                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
865                     fullname = entry[0].name.split('::')[1]
866                     return tagorder.get(fullname, len(tagorder))
867                 documenters.sort(key=keyfunc)
868             else:
869                 # Assume that member discovery order matches source order.
870                 # This is a reasonable assumption in Python 3.6 and up, where
871                 # module.__dict__ is insertion-ordered.
872                 pass
873         else:  # alphabetical
874             documenters.sort(key=lambda e: e[0].name)
875 
876         return documenters
877 
878     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
879                  check_module: bool = False, all_members: bool = False) -> None:
880         """Generate reST for the object given by *self.name*, and possibly for
881         its members.
882 
883         If *more_content* is given, include that content. If *real_modname* is
884         given, use that module name to find attribute docs. If *check_module* is
885         True, only generate if the object is defined in the module name it is
886         imported from. If *all_members* is True, document all members.
887         """
888         if not self.parse_name():
889             # need a module to import
890             logger.warning(
891                 __('don\'t know which module to import for autodocumenting '
892                    '%r (try placing a "module" or "currentmodule" directive '
893                    'in the document, or giving an explicit module name)') %
894                 self.name, type='autodoc')
895             return
896 
897         # now, import the module and get object to document
898         if not self.import_object():
899             return
900 
901         # If there is no real module defined, figure out which to use.
902         # The real module is used in the module analyzer to look up the module
903         # where the attribute documentation would actually be found in.
904         # This is used for situations where you have a module that collects the
905         # functions and classes of internal submodules.
906         guess_modname = self.get_real_modname()
907         self.real_modname: str = real_modname or guess_modname
908 
909         # try to also get a source code analyzer for attribute docs
910         try:
911             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
912             # parse right now, to get PycodeErrors on parsing (results will
913             # be cached anyway)
914             self.analyzer.find_attr_docs()
915         except PycodeError as exc:
916             logger.debug('[autodoc] module analyzer failed: %s', exc)
917             # no source file -- e.g. for builtin and C modules
918             self.analyzer = None
919             # at least add the module.__file__ as a dependency
920             if hasattr(self.module, '__file__') and self.module.__file__:
921                 self.directive.record_dependencies.add(self.module.__file__)
922         else:
923             self.directive.record_dependencies.add(self.analyzer.srcname)
924 
925         if self.real_modname != guess_modname:
926             # Add module to dependency list if target object is defined in other module.
927             try:
928                 analyzer = ModuleAnalyzer.for_module(guess_modname)
929                 self.directive.record_dependencies.add(analyzer.srcname)
930             except PycodeError:
931                 pass
932 
933         # check __module__ of object (for members not given explicitly)
934         if check_module:
935             if not self.check_module():
936                 return
937 
938         sourcename = self.get_sourcename()
939 
940         # make sure that the result starts with an empty line.  This is
941         # necessary for some situations where another directive preprocesses
942         # reST and no starting newline is present
943         self.add_line('', sourcename)
944 
945         # format the object's signature, if any
946         try:
947             sig = self.format_signature()
948         except Exception as exc:
949             logger.warning(__('error while formatting signature for %s: %s'),
950                            self.fullname, exc, type='autodoc')
951             return
952 
953         # generate the directive header and options, if applicable
954         self.add_directive_header(sig)
955         self.add_line('', sourcename)
956 
957         # e.g. the module directive doesn't have content
958         self.indent += self.content_indent
959 
960         # add all content (from docstrings, attribute docs etc.)
961         self.add_content(more_content)
962 
963         # document members, if possible
964         self.document_members(all_members)
965 
966 
967 class ModuleDocumenter(Documenter):
968     """
969     Specialized Documenter subclass for modules.
970     """
971     objtype = 'module'
972     content_indent = ''
973     titles_allowed = True
974 
975     option_spec: OptionSpec = {
976         'members': members_option, 'undoc-members': bool_option,
977         'noindex': bool_option, 'inherited-members': inherited_members_option,
978         'show-inheritance': bool_option, 'synopsis': identity,
979         'platform': identity, 'deprecated': bool_option,
980         'member-order': member_order_option, 'exclude-members': exclude_members_option,
981         'private-members': members_option, 'special-members': members_option,
982         'imported-members': bool_option, 'ignore-module-all': bool_option
983     }
984 
985     def __init__(self, *args: Any) -> None:
986         super().__init__(*args)
987         merge_members_option(self.options)
988         self.__all__: Optional[Sequence[str]] = None
989 
990     @classmethod
991     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
992                             ) -> bool:
993         # don't document submodules automatically
994         return False
995 
996     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
997                      ) -> Tuple[str, List[str]]:
998         if modname is not None:
999             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1000                            type='autodoc')
1001         return (path or '') + base, []
1002 
1003     def parse_name(self) -> bool:
1004         ret = super().parse_name()
1005         if self.args or self.retann:
1006             logger.warning(__('signature arguments or return annotation '
1007                               'given for automodule %s') % self.fullname,
1008                            type='autodoc')
1009         return ret
1010 
1011     def import_object(self, raiseerror: bool = False) -> bool:
1012         ret = super().import_object(raiseerror)
1013 
1014         try:
1015             if not self.options.ignore_module_all:
1016                 self.__all__ = inspect.getall(self.object)
1017         except ValueError as exc:
1018             # invalid __all__ found.
1019             logger.warning(__('__all__ should be a list of strings, not %r '
1020                               '(in module %s) -- ignoring __all__') %
1021                            (exc.args[0], self.fullname), type='autodoc')
1022 
1023         return ret
1024 
1025     def add_directive_header(self, sig: str) -> None:
1026         Documenter.add_directive_header(self, sig)
1027 
1028         sourcename = self.get_sourcename()
1029 
1030         # add some module-specific options
1031         if self.options.synopsis:
1032             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1033         if self.options.platform:
1034             self.add_line('   :platform: ' + self.options.platform, sourcename)
1035         if self.options.deprecated:
1036             self.add_line('   :deprecated:', sourcename)
1037 
1038     def get_module_members(self) -> Dict[str, ObjectMember]:
1039         """Get members of target module."""
1040         if self.analyzer:
1041             attr_docs = self.analyzer.attr_docs
1042         else:
1043             attr_docs = {}
1044 
1045         members: Dict[str, ObjectMember] = {}
1046         for name in dir(self.object):
1047             try:
1048                 value = safe_getattr(self.object, name, None)
1049                 if ismock(value):
1050                     value = undecorate(value)
1051                 docstring = attr_docs.get(('', name), [])
1052                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1053             except AttributeError:
1054                 continue
1055 
1056         # annotation only member (ex. attr: int)
1057         for name in inspect.getannotations(self.object):
1058             if name not in members:
1059                 docstring = attr_docs.get(('', name), [])
1060                 members[name] = ObjectMember(name, INSTANCEATTR,
1061                                              docstring="\n".join(docstring))
1062 
1063         return members
1064 
1065     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1066         members = self.get_module_members()
1067         if want_all:
1068             if self.__all__ is None:
1069                 # for implicit module members, check __module__ to avoid
1070                 # documenting imported objects
1071                 return True, list(members.values())
1072             else:
1073                 for member in members.values():
1074                     if member.__name__ not in self.__all__:
1075                         member.skipped = True
1076 
1077                 return False, list(members.values())
1078         else:
1079             memberlist = self.options.members or []
1080             ret = []
1081             for name in memberlist:
1082                 if name in members:
1083                     ret.append(members[name])
1084                 else:
1085                     logger.warning(__('missing attribute mentioned in :members: option: '
1086                                       'module %s, attribute %s') %
1087                                    (safe_getattr(self.object, '__name__', '???'), name),
1088                                    type='autodoc')
1089             return False, ret
1090 
1091     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1092                      order: str) -> List[Tuple["Documenter", bool]]:
1093         if order == 'bysource' and self.__all__:
1094             # Sort alphabetically first (for members not listed on the __all__)
1095             documenters.sort(key=lambda e: e[0].name)
1096 
1097             # Sort by __all__
1098             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1099                 name = entry[0].name.split('::')[1]
1100                 if self.__all__ and name in self.__all__:
1101                     return self.__all__.index(name)
1102                 else:
1103                     return len(self.__all__)
1104             documenters.sort(key=keyfunc)
1105 
1106             return documenters
1107         else:
1108             return super().sort_members(documenters, order)
1109 
1110 
1111 class ModuleLevelDocumenter(Documenter):
1112     """
1113     Specialized Documenter subclass for objects on module level (functions,
1114     classes, data/constants).
1115     """
1116     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1117                      ) -> Tuple[str, List[str]]:
1118         if modname is None:
1119             if path:
1120                 modname = path.rstrip('.')
1121             else:
1122                 # if documenting a toplevel object without explicit module,
1123                 # it can be contained in another auto directive ...
1124                 modname = self.env.temp_data.get('autodoc:module')
1125                 # ... or in the scope of a module directive
1126                 if not modname:
1127                     modname = self.env.ref_context.get('py:module')
1128                 # ... else, it stays None, which means invalid
1129         return modname, parents + [base]
1130 
1131 
1132 class ClassLevelDocumenter(Documenter):
1133     """
1134     Specialized Documenter subclass for objects on class level (methods,
1135     attributes).
1136     """
1137     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1138                      ) -> Tuple[str, List[str]]:
1139         if modname is None:
1140             if path:
1141                 mod_cls = path.rstrip('.')
1142             else:
1143                 mod_cls = None
1144                 # if documenting a class-level object without path,
1145                 # there must be a current class, either from a parent
1146                 # auto directive ...
1147                 mod_cls = self.env.temp_data.get('autodoc:class')
1148                 # ... or from a class directive
1149                 if mod_cls is None:
1150                     mod_cls = self.env.ref_context.get('py:class')
1151                 # ... if still None, there's no way to know
1152                 if mod_cls is None:
1153                     return None, []
1154             modname, sep, cls = mod_cls.rpartition('.')
1155             parents = [cls]
1156             # if the module name is still missing, get it like above
1157             if not modname:
1158                 modname = self.env.temp_data.get('autodoc:module')
1159             if not modname:
1160                 modname = self.env.ref_context.get('py:module')
1161             # ... else, it stays None, which means invalid
1162         return modname, parents + [base]
1163 
1164 
1165 class DocstringSignatureMixin:
1166     """
1167     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1168     feature of reading the signature from the docstring.
1169     """
1170     _new_docstrings: List[List[str]] = None
1171     _signatures: List[str] = None
1172 
1173     def _find_signature(self) -> Tuple[str, str]:
1174         # candidates of the object name
1175         valid_names = [self.objpath[-1]]  # type: ignore
1176         if isinstance(self, ClassDocumenter):
1177             valid_names.append('__init__')
1178             if hasattr(self.object, '__mro__'):
1179                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1180 
1181         docstrings = self.get_doc()
1182         if docstrings is None:
1183             return None, None
1184         self._new_docstrings = docstrings[:]
1185         self._signatures = []
1186         result = None
1187         for i, doclines in enumerate(docstrings):
1188             for j, line in enumerate(doclines):
1189                 if not line:
1190                     # no lines in docstring, no match
1191                     break
1192 
1193                 if line.endswith('\\'):
1194                     line = line.rstrip('\\').rstrip()
1195 
1196                 # match first line of docstring against signature RE
1197                 match = py_ext_sig_re.match(line)
1198                 if not match:
1199                     break
1200                 exmod, path, base, args, retann = match.groups()
1201 
1202                 # the base name must match ours
1203                 if base not in valid_names:
1204                     break
1205 
1206                 # re-prepare docstring to ignore more leading indentation
1207                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1208                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1209                                                             tabsize=tab_width)
1210 
1211                 if result is None:
1212                     # first signature
1213                     result = args, retann
1214                 else:
1215                     # subsequent signatures
1216                     self._signatures.append("(%s) -> %s" % (args, retann))
1217 
1218             if result:
1219                 # finish the loop when signature found
1220                 break
1221 
1222         return result
1223 
1224     def get_doc(self, ignore: int = None) -> List[List[str]]:
1225         if self._new_docstrings is not None:
1226             return self._new_docstrings
1227         return super().get_doc(ignore)  # type: ignore
1228 
1229     def format_signature(self, **kwargs: Any) -> str:
1230         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1231             # only act if a signature is not explicitly given already, and if
1232             # the feature is enabled
1233             result = self._find_signature()
1234             if result is not None:
1235                 self.args, self.retann = result
1236         sig = super().format_signature(**kwargs)  # type: ignore
1237         if self._signatures:
1238             return "\n".join([sig] + self._signatures)
1239         else:
1240             return sig
1241 
1242 
1243 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1244     """
1245     Mixin for AttributeDocumenter to provide the
1246     feature of stripping any function signature from the docstring.
1247     """
1248     def format_signature(self, **kwargs: Any) -> str:
1249         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1250             # only act if a signature is not explicitly given already, and if
1251             # the feature is enabled
1252             result = self._find_signature()
1253             if result is not None:
1254                 # Discarding _args is a only difference with
1255                 # DocstringSignatureMixin.format_signature.
1256                 # Documenter.format_signature use self.args value to format.
1257                 _args, self.retann = result
1258         return super().format_signature(**kwargs)
1259 
1260 
1261 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1262     """
1263     Specialized Documenter subclass for functions.
1264     """
1265     objtype = 'function'
1266     member_order = 30
1267 
1268     @classmethod
1269     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1270                             ) -> bool:
1271         # supports functions, builtins and bound methods exported at the module level
1272         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1273                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1274 
1275     def format_args(self, **kwargs: Any) -> str:
1276         if self.config.autodoc_typehints in ('none', 'description'):
1277             kwargs.setdefault('show_annotation', False)
1278 
1279         try:
1280             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1281             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1282             args = stringify_signature(sig, **kwargs)
1283         except TypeError as exc:
1284             logger.warning(__("Failed to get a function signature for %s: %s"),
1285                            self.fullname, exc)
1286             return None
1287         except ValueError:
1288             args = ''
1289 
1290         if self.config.strip_signature_backslash:
1291             # escape backslashes for reST
1292             args = args.replace('\\', '\\\\')
1293         return args
1294 
1295     def document_members(self, all_members: bool = False) -> None:
1296         pass
1297 
1298     def add_directive_header(self, sig: str) -> None:
1299         sourcename = self.get_sourcename()
1300         super().add_directive_header(sig)
1301 
1302         if inspect.iscoroutinefunction(self.object):
1303             self.add_line('   :async:', sourcename)
1304 
1305     def format_signature(self, **kwargs: Any) -> str:
1306         sigs = []
1307         if (self.analyzer and
1308                 '.'.join(self.objpath) in self.analyzer.overloads and
1309                 self.config.autodoc_typehints == 'signature'):
1310             # Use signatures for overloaded functions instead of the implementation function.
1311             overloaded = True
1312         else:
1313             overloaded = False
1314             sig = super().format_signature(**kwargs)
1315             sigs.append(sig)
1316 
1317         if inspect.is_singledispatch_function(self.object):
1318             # append signature of singledispatch'ed functions
1319             for typ, func in self.object.registry.items():
1320                 if typ is object:
1321                     pass  # default implementation. skipped.
1322                 else:
1323                     self.annotate_to_first_argument(func, typ)
1324 
1325                     documenter = FunctionDocumenter(self.directive, '')
1326                     documenter.object = func
1327                     documenter.objpath = [None]
1328                     sigs.append(documenter.format_signature())
1329         if overloaded:
1330             actual = inspect.signature(self.object,
1331                                        type_aliases=self.config.autodoc_type_aliases)
1332             __globals__ = safe_getattr(self.object, '__globals__', {})
1333             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1334                 overload = self.merge_default_value(actual, overload)
1335                 overload = evaluate_signature(overload, __globals__,
1336                                               self.config.autodoc_type_aliases)
1337 
1338                 sig = stringify_signature(overload, **kwargs)
1339                 sigs.append(sig)
1340 
1341         return "\n".join(sigs)
1342 
1343     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
1344         """Merge default values of actual implementation to the overload variants."""
1345         parameters = list(overload.parameters.values())
1346         for i, param in enumerate(parameters):
1347             actual_param = actual.parameters.get(param.name)
1348             if actual_param and param.default == '...':
1349                 parameters[i] = param.replace(default=actual_param.default)
1350 
1351         return overload.replace(parameters=parameters)
1352 
1353     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1354         """Annotate type hint to the first argument of function if needed."""
1355         try:
1356             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1357         except TypeError as exc:
1358             logger.warning(__("Failed to get a function signature for %s: %s"),
1359                            self.fullname, exc)
1360             return
1361         except ValueError:
1362             return
1363 
1364         if len(sig.parameters) == 0:
1365             return
1366 
1367         params = list(sig.parameters.values())
1368         if params[0].annotation is Parameter.empty:
1369             params[0] = params[0].replace(annotation=typ)
1370             try:
1371                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1372             except (AttributeError, TypeError):
1373                 # failed to update signature (ex. built-in or extension types)
1374                 return
1375 
1376 
1377 class DecoratorDocumenter(FunctionDocumenter):
1378     """
1379     Specialized Documenter subclass for decorator functions.
1380     """
1381     objtype = 'decorator'
1382 
1383     # must be lower than FunctionDocumenter
1384     priority = -1
1385 
1386     def format_args(self, **kwargs: Any) -> Any:
1387         args = super().format_args(**kwargs)
1388         if ',' in args:
1389             return args
1390         else:
1391             return None
1392 
1393 
1394 # Types which have confusing metaclass signatures it would be best not to show.
1395 # These are listed by name, rather than storing the objects themselves, to avoid
1396 # needing to import the modules.
1397 _METACLASS_CALL_BLACKLIST = [
1398     'enum.EnumMeta.__call__',
1399 ]
1400 
1401 
1402 # Types whose __new__ signature is a pass-thru.
1403 _CLASS_NEW_BLACKLIST = [
1404     'typing.Generic.__new__',
1405 ]
1406 
1407 
1408 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1409     """
1410     Specialized Documenter subclass for classes.
1411     """
1412     objtype = 'class'
1413     member_order = 20
1414     option_spec: OptionSpec = {
1415         'members': members_option, 'undoc-members': bool_option,
1416         'noindex': bool_option, 'inherited-members': inherited_members_option,
1417         'show-inheritance': bool_option, 'member-order': member_order_option,
1418         'exclude-members': exclude_members_option,
1419         'private-members': members_option, 'special-members': members_option,
1420     }
1421 
1422     _signature_class: Any = None
1423     _signature_method_name: str = None
1424 
1425     def __init__(self, *args: Any) -> None:
1426         super().__init__(*args)
1427         merge_members_option(self.options)
1428 
1429     @classmethod
1430     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1431                             ) -> bool:
1432         return isinstance(member, type)
1433 
1434     def import_object(self, raiseerror: bool = False) -> bool:
1435         ret = super().import_object(raiseerror)
1436         # if the class is documented under another name, document it
1437         # as data/attribute
1438         if ret:
1439             if hasattr(self.object, '__name__'):
1440                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1441             else:
1442                 self.doc_as_attr = True
1443         return ret
1444 
1445     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1446         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1447             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1448             if inspect.is_builtin_class_method(obj, attr):
1449                 return None
1450             attr = self.get_attr(obj, attr, None)
1451             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1452                 return None
1453             return attr
1454 
1455         # This sequence is copied from inspect._signature_from_callable.
1456         # ValueError means that no signature could be found, so we keep going.
1457 
1458         # First, we check the obj has a __signature__ attribute
1459         if (hasattr(self.object, '__signature__') and
1460                 isinstance(self.object.__signature__, Signature)):
1461             return None, None, self.object.__signature__
1462 
1463         # Next, let's see if it has an overloaded __call__ defined
1464         # in its metaclass
1465         call = get_user_defined_function_or_method(type(self.object), '__call__')
1466 
1467         if call is not None:
1468             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1469                 call = None
1470 
1471         if call is not None:
1472             self.env.app.emit('autodoc-before-process-signature', call, True)
1473             try:
1474                 sig = inspect.signature(call, bound_method=True,
1475                                         type_aliases=self.config.autodoc_type_aliases)
1476                 return type(self.object), '__call__', sig
1477             except ValueError:
1478                 pass
1479 
1480         # Now we check if the 'obj' class has a '__new__' method
1481         new = get_user_defined_function_or_method(self.object, '__new__')
1482 
1483         if new is not None:
1484             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1485                 new = None
1486 
1487         if new is not None:
1488             self.env.app.emit('autodoc-before-process-signature', new, True)
1489             try:
1490                 sig = inspect.signature(new, bound_method=True,
1491                                         type_aliases=self.config.autodoc_type_aliases)
1492                 return self.object, '__new__', sig
1493             except ValueError:
1494                 pass
1495 
1496         # Finally, we should have at least __init__ implemented
1497         init = get_user_defined_function_or_method(self.object, '__init__')
1498         if init is not None:
1499             self.env.app.emit('autodoc-before-process-signature', init, True)
1500             try:
1501                 sig = inspect.signature(init, bound_method=True,
1502                                         type_aliases=self.config.autodoc_type_aliases)
1503                 return self.object, '__init__', sig
1504             except ValueError:
1505                 pass
1506 
1507         # None of the attributes are user-defined, so fall back to let inspect
1508         # handle it.
1509         # We don't know the exact method that inspect.signature will read
1510         # the signature from, so just pass the object itself to our hook.
1511         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1512         try:
1513             sig = inspect.signature(self.object, bound_method=False,
1514                                     type_aliases=self.config.autodoc_type_aliases)
1515             return None, None, sig
1516         except ValueError:
1517             pass
1518 
1519         # Still no signature: happens e.g. for old-style classes
1520         # with __init__ in C and no `__text_signature__`.
1521         return None, None, None
1522 
1523     def format_args(self, **kwargs: Any) -> str:
1524         if self.config.autodoc_typehints in ('none', 'description'):
1525             kwargs.setdefault('show_annotation', False)
1526 
1527         try:
1528             self._signature_class, self._signature_method_name, sig = self._get_signature()
1529         except TypeError as exc:
1530             # __signature__ attribute contained junk
1531             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1532                            self.fullname, exc)
1533             return None
1534 
1535         if sig is None:
1536             return None
1537 
1538         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1539 
1540     def format_signature(self, **kwargs: Any) -> str:
1541         if self.doc_as_attr:
1542             return ''
1543 
1544         sig = super().format_signature()
1545         sigs = []
1546 
1547         overloads = self.get_overloaded_signatures()
1548         if overloads and self.config.autodoc_typehints == 'signature':
1549             # Use signatures for overloaded methods instead of the implementation method.
1550             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1551             __globals__ = safe_getattr(method, '__globals__', {})
1552             for overload in overloads:
1553                 overload = evaluate_signature(overload, __globals__,
1554                                               self.config.autodoc_type_aliases)
1555 
1556                 parameters = list(overload.parameters.values())
1557                 overload = overload.replace(parameters=parameters[1:],
1558                                             return_annotation=Parameter.empty)
1559                 sig = stringify_signature(overload, **kwargs)
1560                 sigs.append(sig)
1561         else:
1562             sigs.append(sig)
1563 
1564         return "\n".join(sigs)
1565 
1566     def get_overloaded_signatures(self) -> List[Signature]:
1567         if self._signature_class and self._signature_method_name:
1568             for cls in self._signature_class.__mro__:
1569                 try:
1570                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1571                     analyzer.analyze()
1572                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1573                     if qualname in analyzer.overloads:
1574                         return analyzer.overloads.get(qualname)
1575                     elif qualname in analyzer.tagorder:
1576                         # the constructor is defined in the class, but not overrided.
1577                         return []
1578                 except PycodeError:
1579                     pass
1580 
1581         return []
1582 
1583     def get_canonical_fullname(self) -> Optional[str]:
1584         __modname__ = safe_getattr(self.object, '__module__', self.modname)
1585         __qualname__ = safe_getattr(self.object, '__qualname__', None)
1586         if __qualname__ is None:
1587             __qualname__ = safe_getattr(self.object, '__name__', None)
1588         if __qualname__ and '<locals>' in __qualname__:
1589             # No valid qualname found if the object is defined as locals
1590             __qualname__ = None
1591 
1592         if __modname__ and __qualname__:
1593             return '.'.join([__modname__, __qualname__])
1594         else:
1595             return None
1596 
1597     def add_directive_header(self, sig: str) -> None:
1598         sourcename = self.get_sourcename()
1599 
1600         if self.doc_as_attr:
1601             self.directivetype = 'attribute'
1602         super().add_directive_header(sig)
1603 
1604         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1605             self.add_line('   :final:', sourcename)
1606 
1607         canonical_fullname = self.get_canonical_fullname()
1608         if not self.doc_as_attr and canonical_fullname and self.fullname != canonical_fullname:
1609             self.add_line('   :canonical: %s' % canonical_fullname, sourcename)
1610 
1611         # add inheritance info, if wanted
1612         if not self.doc_as_attr and self.options.show_inheritance:
1613             sourcename = self.get_sourcename()
1614             self.add_line('', sourcename)
1615 
1616             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1617                 # A subclass of generic types
1618                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1619                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1620                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1621             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1622                 # A normal class
1623                 bases = [restify(cls) for cls in self.object.__bases__]
1624                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1625 
1626     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1627         members = get_class_members(self.object, self.objpath, self.get_attr)
1628         if not want_all:
1629             if not self.options.members:
1630                 return False, []  # type: ignore
1631             # specific members given
1632             selected = []
1633             for name in self.options.members:  # type: str
1634                 if name in members:
1635                     selected.append(members[name])
1636                 else:
1637                     logger.warning(__('missing attribute %s in object %s') %
1638                                    (name, self.fullname), type='autodoc')
1639             return False, selected
1640         elif self.options.inherited_members:
1641             return False, list(members.values())
1642         else:
1643             return False, [m for m in members.values() if m.class_ == self.object]
1644 
1645     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1646         if self.doc_as_attr:
1647             # Don't show the docstring of the class when it is an alias.
1648             return None
1649 
1650         lines = getattr(self, '_new_docstrings', None)
1651         if lines is not None:
1652             return lines
1653 
1654         content = self.config.autoclass_content
1655 
1656         docstrings = []
1657         attrdocstring = self.get_attr(self.object, '__doc__', None)
1658         if attrdocstring:
1659             docstrings.append(attrdocstring)
1660 
1661         # for classes, what the "docstring" is can be controlled via a
1662         # config value; the default is only the class docstring
1663         if content in ('both', 'init'):
1664             __init__ = self.get_attr(self.object, '__init__', None)
1665             initdocstring = getdoc(__init__, self.get_attr,
1666                                    self.config.autodoc_inherit_docstrings,
1667                                    self.parent, self.object_name)
1668             # for new-style classes, no __init__ means default __init__
1669             if (initdocstring is not None and
1670                 (initdocstring == object.__init__.__doc__ or  # for pypy
1671                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1672                 initdocstring = None
1673             if not initdocstring:
1674                 # try __new__
1675                 __new__ = self.get_attr(self.object, '__new__', None)
1676                 initdocstring = getdoc(__new__, self.get_attr,
1677                                        self.config.autodoc_inherit_docstrings,
1678                                        self.parent, self.object_name)
1679                 # for new-style classes, no __new__ means default __new__
1680                 if (initdocstring is not None and
1681                     (initdocstring == object.__new__.__doc__ or  # for pypy
1682                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1683                     initdocstring = None
1684             if initdocstring:
1685                 if content == 'init':
1686                     docstrings = [initdocstring]
1687                 else:
1688                     docstrings.append(initdocstring)
1689 
1690         tab_width = self.directive.state.document.settings.tab_width
1691         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1692 
1693     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1694                     ) -> None:
1695         if self.doc_as_attr:
1696             try:
1697                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1698             except AttributeError:
1699                 pass  # Invalid class object is passed.
1700 
1701         super().add_content(more_content)
1702 
1703     def document_members(self, all_members: bool = False) -> None:
1704         if self.doc_as_attr:
1705             return
1706         super().document_members(all_members)
1707 
1708     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1709                  check_module: bool = False, all_members: bool = False) -> None:
1710         # Do not pass real_modname and use the name from the __module__
1711         # attribute of the class.
1712         # If a class gets imported into the module real_modname
1713         # the analyzer won't find the source of the class, if
1714         # it looks in real_modname.
1715         return super().generate(more_content=more_content,
1716                                 check_module=check_module,
1717                                 all_members=all_members)
1718 
1719 
1720 class ExceptionDocumenter(ClassDocumenter):
1721     """
1722     Specialized ClassDocumenter subclass for exceptions.
1723     """
1724     objtype = 'exception'
1725     member_order = 10
1726 
1727     # needs a higher priority than ClassDocumenter
1728     priority = 10
1729 
1730     @classmethod
1731     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1732                             ) -> bool:
1733         return isinstance(member, type) and issubclass(member, BaseException)
1734 
1735 
1736 class DataDocumenterMixinBase:
1737     # define types of instance variables
1738     config: Config = None
1739     env: BuildEnvironment = None
1740     modname: str = None
1741     parent: Any = None
1742     object: Any = None
1743     objpath: List[str] = None
1744 
1745     def should_suppress_directive_header(self) -> bool:
1746         """Check directive header should be suppressed."""
1747         return False
1748 
1749     def should_suppress_value_header(self) -> bool:
1750         """Check :value: header should be suppressed."""
1751         return False
1752 
1753     def update_content(self, more_content: StringList) -> None:
1754         """Update docstring for the NewType object."""
1755         pass
1756 
1757 
1758 class GenericAliasMixin(DataDocumenterMixinBase):
1759     """
1760     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1761     supporting GenericAliases.
1762     """
1763 
1764     def should_suppress_directive_header(self) -> bool:
1765         return (inspect.isgenericalias(self.object) or
1766                 super().should_suppress_directive_header())
1767 
1768     def update_content(self, more_content: StringList) -> None:
1769         if inspect.isgenericalias(self.object):
1770             alias = stringify_typehint(self.object)
1771             more_content.append(_('alias of %s') % alias, '')
1772             more_content.append('', '')
1773 
1774         super().update_content(more_content)
1775 
1776 
1777 class NewTypeMixin(DataDocumenterMixinBase):
1778     """
1779     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1780     supporting NewTypes.
1781     """
1782 
1783     def should_suppress_directive_header(self) -> bool:
1784         return (inspect.isNewType(self.object) or
1785                 super().should_suppress_directive_header())
1786 
1787     def update_content(self, more_content: StringList) -> None:
1788         if inspect.isNewType(self.object):
1789             supertype = restify(self.object.__supertype__)
1790             more_content.append(_('alias of %s') % supertype, '')
1791             more_content.append('', '')
1792 
1793         super().update_content(more_content)
1794 
1795 
1796 class TypeVarMixin(DataDocumenterMixinBase):
1797     """
1798     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1799     supporting TypeVars.
1800     """
1801 
1802     def should_suppress_directive_header(self) -> bool:
1803         return (isinstance(self.object, TypeVar) or
1804                 super().should_suppress_directive_header())
1805 
1806     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1807         if ignore is not None:
1808             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1809                           % self.__class__.__name__,
1810                           RemovedInSphinx50Warning, stacklevel=2)
1811 
1812         if isinstance(self.object, TypeVar):
1813             if self.object.__doc__ != TypeVar.__doc__:
1814                 return super().get_doc()  # type: ignore
1815             else:
1816                 return []
1817         else:
1818             return super().get_doc()  # type: ignore
1819 
1820     def update_content(self, more_content: StringList) -> None:
1821         if isinstance(self.object, TypeVar):
1822             attrs = [repr(self.object.__name__)]
1823             for constraint in self.object.__constraints__:
1824                 attrs.append(stringify_typehint(constraint))
1825             if self.object.__bound__:
1826                 attrs.append(r"bound=\ " + restify(self.object.__bound__))
1827             if self.object.__covariant__:
1828                 attrs.append("covariant=True")
1829             if self.object.__contravariant__:
1830                 attrs.append("contravariant=True")
1831 
1832             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1833             more_content.append('', '')
1834 
1835         super().update_content(more_content)
1836 
1837 
1838 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1839     """
1840     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1841     (type annotation only) global variables.
1842     """
1843 
1844     def import_object(self, raiseerror: bool = False) -> bool:
1845         try:
1846             return super().import_object(raiseerror=True)  # type: ignore
1847         except ImportError as exc:
1848             # annotation only instance variable (PEP-526)
1849             try:
1850                 with mock(self.config.autodoc_mock_imports):
1851                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1852                     annotations = get_type_hints(parent, None,
1853                                                  self.config.autodoc_type_aliases)
1854                     if self.objpath[-1] in annotations:
1855                         self.object = UNINITIALIZED_ATTR
1856                         self.parent = parent
1857                         return True
1858             except ImportError:
1859                 pass
1860 
1861             if raiseerror:
1862                 raise
1863             else:
1864                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1865                 self.env.note_reread()
1866                 return False
1867 
1868     def should_suppress_value_header(self) -> bool:
1869         return (self.object is UNINITIALIZED_ATTR or
1870                 super().should_suppress_value_header())
1871 
1872     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1873         if self.object is UNINITIALIZED_ATTR:
1874             return []
1875         else:
1876             return super().get_doc(ignore)  # type: ignore
1877 
1878 
1879 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1880                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1881     """
1882     Specialized Documenter subclass for data items.
1883     """
1884     objtype = 'data'
1885     member_order = 40
1886     priority = -10
1887     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)
1888     option_spec["annotation"] = annotation_option
1889     option_spec["no-value"] = bool_option
1890 
1891     @classmethod
1892     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1893                             ) -> bool:
1894         return isinstance(parent, ModuleDocumenter) and isattr
1895 
1896     def update_annotations(self, parent: Any) -> None:
1897         """Update __annotations__ to support type_comment and so on."""
1898         annotations = dict(inspect.getannotations(parent))
1899         parent.__annotations__ = annotations
1900 
1901         try:
1902             analyzer = ModuleAnalyzer.for_module(self.modname)
1903             analyzer.analyze()
1904             for (classname, attrname), annotation in analyzer.annotations.items():
1905                 if classname == '' and attrname not in annotations:
1906                     annotations[attrname] = annotation
1907         except PycodeError:
1908             pass
1909 
1910     def import_object(self, raiseerror: bool = False) -> bool:
1911         ret = super().import_object(raiseerror)
1912         if self.parent:
1913             self.update_annotations(self.parent)
1914 
1915         return ret
1916 
1917     def should_suppress_value_header(self) -> bool:
1918         if super().should_suppress_value_header():
1919             return True
1920         else:
1921             doc = self.get_doc()
1922             metadata = extract_metadata('\n'.join(sum(doc, [])))
1923             if 'hide-value' in metadata:
1924                 return True
1925 
1926         return False
1927 
1928     def add_directive_header(self, sig: str) -> None:
1929         super().add_directive_header(sig)
1930         sourcename = self.get_sourcename()
1931         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1932             pass
1933         elif self.options.annotation:
1934             self.add_line('   :annotation: %s' % self.options.annotation,
1935                           sourcename)
1936         else:
1937             # obtain annotation for this data
1938             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1939             if self.objpath[-1] in annotations:
1940                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1941                 self.add_line('   :type: ' + objrepr, sourcename)
1942 
1943             try:
1944                 if self.options.no_value or self.should_suppress_value_header():
1945                     pass
1946                 else:
1947                     objrepr = object_description(self.object)
1948                     self.add_line('   :value: ' + objrepr, sourcename)
1949             except ValueError:
1950                 pass
1951 
1952     def document_members(self, all_members: bool = False) -> None:
1953         pass
1954 
1955     def get_real_modname(self) -> str:
1956         return self.get_attr(self.parent or self.object, '__module__', None) \
1957             or self.modname
1958 
1959     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1960         try:
1961             analyzer = ModuleAnalyzer.for_module(self.modname)
1962             analyzer.analyze()
1963             key = ('', attrname)
1964             if key in analyzer.attr_docs:
1965                 return list(analyzer.attr_docs[key])
1966         except PycodeError:
1967             pass
1968 
1969         return None
1970 
1971     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1972         # Check the variable has a docstring-comment
1973         comment = self.get_module_comment(self.objpath[-1])
1974         if comment:
1975             return [comment]
1976         else:
1977             return super().get_doc(ignore)
1978 
1979     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1980                     ) -> None:
1981         # Disable analyzing variable comment on Documenter.add_content() to control it on
1982         # DataDocumenter.add_content()
1983         self.analyzer = None
1984 
1985         if not more_content:
1986             more_content = StringList()
1987 
1988         self.update_content(more_content)
1989         super().add_content(more_content, no_docstring=no_docstring)
1990 
1991 
1992 class NewTypeDataDocumenter(DataDocumenter):
1993     """
1994     Specialized Documenter subclass for NewTypes.
1995 
1996     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
1997     function object.
1998     """
1999 
2000     objtype = 'newtypedata'
2001     directivetype = 'data'
2002     priority = FunctionDocumenter.priority + 1
2003 
2004     @classmethod
2005     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2006                             ) -> bool:
2007         return inspect.isNewType(member) and isattr
2008 
2009 
2010 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2011     """
2012     Specialized Documenter subclass for methods (normal, static and class).
2013     """
2014     objtype = 'method'
2015     directivetype = 'method'
2016     member_order = 50
2017     priority = 1  # must be more than FunctionDocumenter
2018 
2019     @classmethod
2020     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2021                             ) -> bool:
2022         return inspect.isroutine(member) and \
2023             not isinstance(parent, ModuleDocumenter)
2024 
2025     def import_object(self, raiseerror: bool = False) -> bool:
2026         ret = super().import_object(raiseerror)
2027         if not ret:
2028             return ret
2029 
2030         # to distinguish classmethod/staticmethod
2031         obj = self.parent.__dict__.get(self.object_name)
2032         if obj is None:
2033             obj = self.object
2034 
2035         if (inspect.isclassmethod(obj) or
2036                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2037             # document class and static members before ordinary ones
2038             self.member_order = self.member_order - 1
2039 
2040         return ret
2041 
2042     def format_args(self, **kwargs: Any) -> str:
2043         if self.config.autodoc_typehints in ('none', 'description'):
2044             kwargs.setdefault('show_annotation', False)
2045 
2046         try:
2047             if self.object == object.__init__ and self.parent != object:
2048                 # Classes not having own __init__() method are shown as no arguments.
2049                 #
2050                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2051                 #       But it makes users confused.
2052                 args = '()'
2053             else:
2054                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2055                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2056                     sig = inspect.signature(self.object, bound_method=False,
2057                                             type_aliases=self.config.autodoc_type_aliases)
2058                 else:
2059                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2060                     sig = inspect.signature(self.object, bound_method=True,
2061                                             type_aliases=self.config.autodoc_type_aliases)
2062                 args = stringify_signature(sig, **kwargs)
2063         except TypeError as exc:
2064             logger.warning(__("Failed to get a method signature for %s: %s"),
2065                            self.fullname, exc)
2066             return None
2067         except ValueError:
2068             args = ''
2069 
2070         if self.config.strip_signature_backslash:
2071             # escape backslashes for reST
2072             args = args.replace('\\', '\\\\')
2073         return args
2074 
2075     def add_directive_header(self, sig: str) -> None:
2076         super().add_directive_header(sig)
2077 
2078         sourcename = self.get_sourcename()
2079         obj = self.parent.__dict__.get(self.object_name, self.object)
2080         if inspect.isabstractmethod(obj):
2081             self.add_line('   :abstractmethod:', sourcename)
2082         if inspect.iscoroutinefunction(obj):
2083             self.add_line('   :async:', sourcename)
2084         if inspect.isclassmethod(obj):
2085             self.add_line('   :classmethod:', sourcename)
2086         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2087             self.add_line('   :staticmethod:', sourcename)
2088         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2089             self.add_line('   :final:', sourcename)
2090 
2091     def document_members(self, all_members: bool = False) -> None:
2092         pass
2093 
2094     def format_signature(self, **kwargs: Any) -> str:
2095         sigs = []
2096         if (self.analyzer and
2097                 '.'.join(self.objpath) in self.analyzer.overloads and
2098                 self.config.autodoc_typehints == 'signature'):
2099             # Use signatures for overloaded methods instead of the implementation method.
2100             overloaded = True
2101         else:
2102             overloaded = False
2103             sig = super().format_signature(**kwargs)
2104             sigs.append(sig)
2105 
2106         meth = self.parent.__dict__.get(self.objpath[-1])
2107         if inspect.is_singledispatch_method(meth):
2108             # append signature of singledispatch'ed functions
2109             for typ, func in meth.dispatcher.registry.items():
2110                 if typ is object:
2111                     pass  # default implementation. skipped.
2112                 else:
2113                     self.annotate_to_first_argument(func, typ)
2114 
2115                     documenter = MethodDocumenter(self.directive, '')
2116                     documenter.parent = self.parent
2117                     documenter.object = func
2118                     documenter.objpath = [None]
2119                     sigs.append(documenter.format_signature())
2120         if overloaded:
2121             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2122                 actual = inspect.signature(self.object, bound_method=False,
2123                                            type_aliases=self.config.autodoc_type_aliases)
2124             else:
2125                 actual = inspect.signature(self.object, bound_method=True,
2126                                            type_aliases=self.config.autodoc_type_aliases)
2127 
2128             __globals__ = safe_getattr(self.object, '__globals__', {})
2129             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2130                 overload = self.merge_default_value(actual, overload)
2131                 overload = evaluate_signature(overload, __globals__,
2132                                               self.config.autodoc_type_aliases)
2133 
2134                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2135                                               name=self.object_name):
2136                     parameters = list(overload.parameters.values())
2137                     overload = overload.replace(parameters=parameters[1:])
2138                 sig = stringify_signature(overload, **kwargs)
2139                 sigs.append(sig)
2140 
2141         return "\n".join(sigs)
2142 
2143     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
2144         """Merge default values of actual implementation to the overload variants."""
2145         parameters = list(overload.parameters.values())
2146         for i, param in enumerate(parameters):
2147             actual_param = actual.parameters.get(param.name)
2148             if actual_param and param.default == '...':
2149                 parameters[i] = param.replace(default=actual_param.default)
2150 
2151         return overload.replace(parameters=parameters)
2152 
2153     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2154         """Annotate type hint to the first argument of function if needed."""
2155         try:
2156             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2157         except TypeError as exc:
2158             logger.warning(__("Failed to get a method signature for %s: %s"),
2159                            self.fullname, exc)
2160             return
2161         except ValueError:
2162             return
2163         if len(sig.parameters) == 1:
2164             return
2165 
2166         params = list(sig.parameters.values())
2167         if params[1].annotation is Parameter.empty:
2168             params[1] = params[1].replace(annotation=typ)
2169             try:
2170                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2171             except (AttributeError, TypeError):
2172                 # failed to update signature (ex. built-in or extension types)
2173                 return
2174 
2175 
2176 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2177     """
2178     Mixin for AttributeDocumenter to provide the feature for supporting non
2179     data-descriptors.
2180 
2181     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2182               and :value: header will be suppressed unexpectedly.
2183     """
2184 
2185     def import_object(self, raiseerror: bool = False) -> bool:
2186         ret = super().import_object(raiseerror)  # type: ignore
2187         if ret and not inspect.isattributedescriptor(self.object):
2188             self.non_data_descriptor = True
2189         else:
2190             self.non_data_descriptor = False
2191 
2192         return ret
2193 
2194     def should_suppress_value_header(self) -> bool:
2195         return (not getattr(self, 'non_data_descriptor', False) or
2196                 super().should_suppress_directive_header())
2197 
2198     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2199         if getattr(self, 'non_data_descriptor', False):
2200             # the docstring of non datadescriptor is very probably the wrong thing
2201             # to display
2202             return None
2203         else:
2204             return super().get_doc(ignore)  # type: ignore
2205 
2206 
2207 class SlotsMixin(DataDocumenterMixinBase):
2208     """
2209     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2210     """
2211 
2212     def isslotsattribute(self) -> bool:
2213         """Check the subject is an attribute in __slots__."""
2214         try:
2215             __slots__ = inspect.getslots(self.parent)
2216             if __slots__ and self.objpath[-1] in __slots__:
2217                 return True
2218             else:
2219                 return False
2220         except (ValueError, TypeError):
2221             return False
2222 
2223     def import_object(self, raiseerror: bool = False) -> bool:
2224         ret = super().import_object(raiseerror)  # type: ignore
2225         if self.isslotsattribute():
2226             self.object = SLOTSATTR
2227 
2228         return ret
2229 
2230     def should_suppress_directive_header(self) -> bool:
2231         if self.object is SLOTSATTR:
2232             self._datadescriptor = True
2233             return True
2234         else:
2235             return super().should_suppress_directive_header()
2236 
2237     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2238         if self.object is SLOTSATTR:
2239             try:
2240                 __slots__ = inspect.getslots(self.parent)
2241                 if __slots__ and __slots__.get(self.objpath[-1]):
2242                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2243                     return [docstring]
2244                 else:
2245                     return []
2246             except ValueError as exc:
2247                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2248                                (self.parent.__qualname__, exc), type='autodoc')
2249                 return []
2250         else:
2251             return super().get_doc(ignore)  # type: ignore
2252 
2253 
2254 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2255     """
2256     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2257     instance attributes (that are defined in __init__() methods with doc-comments).
2258 
2259     Example:
2260 
2261         class Foo:
2262             def __init__(self):
2263                 self.attr = None  #: This is a target of this mix-in.
2264     """
2265 
2266     RUNTIME_INSTANCE_ATTRIBUTE = object()
2267 
2268     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2269         """Check the subject is an attribute defined in __init__()."""
2270         # An instance variable defined in __init__().
2271         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2272             return True
2273         else:
2274             return False
2275 
2276     def import_object(self, raiseerror: bool = False) -> bool:
2277         """Check the existence of runtime instance attribute when failed to import the
2278         attribute."""
2279         try:
2280             return super().import_object(raiseerror=True)  # type: ignore
2281         except ImportError as exc:
2282             try:
2283                 with mock(self.config.autodoc_mock_imports):
2284                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2285                                         attrgetter=self.get_attr,  # type: ignore
2286                                         warningiserror=self.config.autodoc_warningiserror)
2287                     parent = ret[3]
2288                     if self.is_runtime_instance_attribute(parent):
2289                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2290                         self.parent = parent
2291                         return True
2292             except ImportError:
2293                 pass
2294 
2295             if raiseerror:
2296                 raise
2297             else:
2298                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2299                 self.env.note_reread()
2300                 return False
2301 
2302     def should_suppress_value_header(self) -> bool:
2303         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2304                 super().should_suppress_value_header())
2305 
2306 
2307 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2308     """
2309     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2310     instance attributes (PEP-526 styled, annotation only attributes).
2311 
2312     Example:
2313 
2314         class Foo:
2315             attr: int  #: This is a target of this mix-in.
2316     """
2317 
2318     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2319         """Check the subject is an annotation only attribute."""
2320         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2321         if self.objpath[-1] in annotations:
2322             return True
2323         else:
2324             return False
2325 
2326     def import_object(self, raiseerror: bool = False) -> bool:
2327         """Check the exisitence of uninitialized instance attribute when failed to import
2328         the attribute."""
2329         try:
2330             return super().import_object(raiseerror=True)  # type: ignore
2331         except ImportError as exc:
2332             try:
2333                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2334                                     attrgetter=self.get_attr,  # type: ignore
2335                                     warningiserror=self.config.autodoc_warningiserror)
2336                 parent = ret[3]
2337                 if self.is_uninitialized_instance_attribute(parent):
2338                     self.object = UNINITIALIZED_ATTR
2339                     self.parent = parent
2340                     return True
2341             except ImportError:
2342                 pass
2343 
2344             if raiseerror:
2345                 raise
2346             else:
2347                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2348                 self.env.note_reread()
2349                 return False
2350 
2351     def should_suppress_value_header(self) -> bool:
2352         return (self.object is UNINITIALIZED_ATTR or
2353                 super().should_suppress_value_header())
2354 
2355     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2356         if self.object is UNINITIALIZED_ATTR:
2357             return None
2358         else:
2359             return super().get_doc(ignore)  # type: ignore
2360 
2361 
2362 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2363                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2364                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2365                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2366     """
2367     Specialized Documenter subclass for attributes.
2368     """
2369     objtype = 'attribute'
2370     member_order = 60
2371     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)
2372     option_spec["annotation"] = annotation_option
2373     option_spec["no-value"] = bool_option
2374 
2375     # must be higher than the MethodDocumenter, else it will recognize
2376     # some non-data descriptors as methods
2377     priority = 10
2378 
2379     @staticmethod
2380     def is_function_or_method(obj: Any) -> bool:
2381         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2382 
2383     @classmethod
2384     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2385                             ) -> bool:
2386         if inspect.isattributedescriptor(member):
2387             return True
2388         elif (not isinstance(parent, ModuleDocumenter) and
2389               not inspect.isroutine(member) and
2390               not isinstance(member, type)):
2391             return True
2392         else:
2393             return False
2394 
2395     def document_members(self, all_members: bool = False) -> None:
2396         pass
2397 
2398     def isinstanceattribute(self) -> bool:
2399         """Check the subject is an instance attribute."""
2400         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2401                       RemovedInSphinx50Warning)
2402         # uninitialized instance variable (PEP-526)
2403         with mock(self.config.autodoc_mock_imports):
2404             try:
2405                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2406                                     attrgetter=self.get_attr,
2407                                     warningiserror=self.config.autodoc_warningiserror)
2408                 self.parent = ret[3]
2409                 annotations = get_type_hints(self.parent, None,
2410                                              self.config.autodoc_type_aliases)
2411                 if self.objpath[-1] in annotations:
2412                     self.object = UNINITIALIZED_ATTR
2413                     return True
2414             except ImportError:
2415                 pass
2416 
2417         return False
2418 
2419     def update_annotations(self, parent: Any) -> None:
2420         """Update __annotations__ to support type_comment and so on."""
2421         try:
2422             annotations = dict(inspect.getannotations(parent))
2423             parent.__annotations__ = annotations
2424 
2425             for cls in inspect.getmro(parent):
2426                 try:
2427                     module = safe_getattr(cls, '__module__')
2428                     qualname = safe_getattr(cls, '__qualname__')
2429 
2430                     analyzer = ModuleAnalyzer.for_module(module)
2431                     analyzer.analyze()
2432                     for (classname, attrname), annotation in analyzer.annotations.items():
2433                         if classname == qualname and attrname not in annotations:
2434                             annotations[attrname] = annotation
2435                 except (AttributeError, PycodeError):
2436                     pass
2437         except (AttributeError, TypeError):
2438             # Failed to set __annotations__ (built-in, extensions, etc.)
2439             pass
2440 
2441     def import_object(self, raiseerror: bool = False) -> bool:
2442         ret = super().import_object(raiseerror)
2443         if inspect.isenumattribute(self.object):
2444             self.object = self.object.value
2445         if self.parent:
2446             self.update_annotations(self.parent)
2447 
2448         return ret
2449 
2450     def get_real_modname(self) -> str:
2451         return self.get_attr(self.parent or self.object, '__module__', None) \
2452             or self.modname
2453 
2454     def should_suppress_value_header(self) -> bool:
2455         if super().should_suppress_value_header():
2456             return True
2457         else:
2458             doc = self.get_doc()
2459             if doc:
2460                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2461                 if 'hide-value' in metadata:
2462                     return True
2463 
2464         return False
2465 
2466     def add_directive_header(self, sig: str) -> None:
2467         super().add_directive_header(sig)
2468         sourcename = self.get_sourcename()
2469         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2470             pass
2471         elif self.options.annotation:
2472             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2473         else:
2474             # obtain type annotation for this attribute
2475             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2476             if self.objpath[-1] in annotations:
2477                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2478                 self.add_line('   :type: ' + objrepr, sourcename)
2479 
2480             try:
2481                 if self.options.no_value or self.should_suppress_value_header():
2482                     pass
2483                 else:
2484                     objrepr = object_description(self.object)
2485                     self.add_line('   :value: ' + objrepr, sourcename)
2486             except ValueError:
2487                 pass
2488 
2489     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2490         for cls in inspect.getmro(parent):
2491             try:
2492                 module = safe_getattr(cls, '__module__')
2493                 qualname = safe_getattr(cls, '__qualname__')
2494 
2495                 analyzer = ModuleAnalyzer.for_module(module)
2496                 analyzer.analyze()
2497                 if qualname and self.objpath:
2498                     key = (qualname, attrname)
2499                     if key in analyzer.attr_docs:
2500                         return list(analyzer.attr_docs[key])
2501             except (AttributeError, PycodeError):
2502                 pass
2503 
2504         return None
2505 
2506     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2507         # Check the attribute has a docstring-comment
2508         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2509         if comment:
2510             return [comment]
2511 
2512         try:
2513             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2514             # a docstring from the value which descriptor returns unexpectedly.
2515             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2516             orig = self.config.autodoc_inherit_docstrings
2517             self.config.autodoc_inherit_docstrings = False  # type: ignore
2518             return super().get_doc(ignore)
2519         finally:
2520             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2521 
2522     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2523                     ) -> None:
2524         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2525         # AttributeDocumenter.add_content()
2526         self.analyzer = None
2527 
2528         if more_content is None:
2529             more_content = StringList()
2530         self.update_content(more_content)
2531         super().add_content(more_content, no_docstring)
2532 
2533 
2534 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2535     """
2536     Specialized Documenter subclass for properties.
2537     """
2538     objtype = 'property'
2539     member_order = 60
2540 
2541     # before AttributeDocumenter
2542     priority = AttributeDocumenter.priority + 1
2543 
2544     @classmethod
2545     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2546                             ) -> bool:
2547         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2548 
2549     def document_members(self, all_members: bool = False) -> None:
2550         pass
2551 
2552     def get_real_modname(self) -> str:
2553         return self.get_attr(self.parent or self.object, '__module__', None) \
2554             or self.modname
2555 
2556     def add_directive_header(self, sig: str) -> None:
2557         super().add_directive_header(sig)
2558         sourcename = self.get_sourcename()
2559         if inspect.isabstractmethod(self.object):
2560             self.add_line('   :abstractmethod:', sourcename)
2561 
2562         if safe_getattr(self.object, 'fget', None):
2563             try:
2564                 signature = inspect.signature(self.object.fget,
2565                                               type_aliases=self.config.autodoc_type_aliases)
2566                 if signature.return_annotation is not Parameter.empty:
2567                     objrepr = stringify_typehint(signature.return_annotation)
2568                     self.add_line('   :type: ' + objrepr, sourcename)
2569             except TypeError as exc:
2570                 logger.warning(__("Failed to get a function signature for %s: %s"),
2571                                self.fullname, exc)
2572                 return None
2573             except ValueError:
2574                 raise
2575 
2576 
2577 class NewTypeAttributeDocumenter(AttributeDocumenter):
2578     """
2579     Specialized Documenter subclass for NewTypes.
2580 
2581     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2582     function object.
2583     """
2584 
2585     objtype = 'newvarattribute'
2586     directivetype = 'attribute'
2587     priority = MethodDocumenter.priority + 1
2588 
2589     @classmethod
2590     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2591                             ) -> bool:
2592         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2593 
2594 
2595 def get_documenters(app: Sphinx) -> Dict[str, Type[Documenter]]:
2596     """Returns registered Documenter classes"""
2597     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2598     return app.registry.documenters
2599 
2600 
2601 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2602     """Alternative getattr() for types"""
2603     for typ, func in app.registry.autodoc_attrgettrs.items():
2604         if isinstance(obj, typ):
2605             return func(obj, name, *defargs)
2606 
2607     return safe_getattr(obj, name, *defargs)
2608 
2609 
2610 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2611     if config.autodoc_member_order == 'alphabetic':
2612         # RemovedInSphinx50Warning
2613         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2614                           'instead of "alphabetic". Please update your setting.'))
2615         config.autodoc_member_order = 'alphabetical'  # type: ignore
2616 
2617 
2618 # for compatibility
2619 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2620 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2621 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2622 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2623 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2624 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2625 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2626 
2627 
2628 def setup(app: Sphinx) -> Dict[str, Any]:
2629     app.add_autodocumenter(ModuleDocumenter)
2630     app.add_autodocumenter(ClassDocumenter)
2631     app.add_autodocumenter(ExceptionDocumenter)
2632     app.add_autodocumenter(DataDocumenter)
2633     app.add_autodocumenter(NewTypeDataDocumenter)
2634     app.add_autodocumenter(FunctionDocumenter)
2635     app.add_autodocumenter(DecoratorDocumenter)
2636     app.add_autodocumenter(MethodDocumenter)
2637     app.add_autodocumenter(AttributeDocumenter)
2638     app.add_autodocumenter(PropertyDocumenter)
2639     app.add_autodocumenter(NewTypeAttributeDocumenter)
2640 
2641     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2642     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2643                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2644     app.add_config_value('autodoc_default_options', {}, True)
2645     app.add_config_value('autodoc_docstring_signature', True, True)
2646     app.add_config_value('autodoc_mock_imports', [], True)
2647     app.add_config_value('autodoc_typehints', "signature", True,
2648                          ENUM("signature", "description", "none"))
2649     app.add_config_value('autodoc_typehints_description_target', 'all', True,
2650                          ENUM('all', 'documented'))
2651     app.add_config_value('autodoc_type_aliases', {}, True)
2652     app.add_config_value('autodoc_warningiserror', True, True)
2653     app.add_config_value('autodoc_inherit_docstrings', True, True)
2654     app.add_event('autodoc-before-process-signature')
2655     app.add_event('autodoc-process-docstring')
2656     app.add_event('autodoc-process-signature')
2657     app.add_event('autodoc-skip-member')
2658 
2659     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2660 
2661     app.setup_extension('sphinx.ext.autodoc.preserve_defaults')
2662     app.setup_extension('sphinx.ext.autodoc.type_comment')
2663     app.setup_extension('sphinx.ext.autodoc.typehints')
2664 
2665     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>Ensure that automatic documentation generation from docstrings continues to work seamlessly with `docutils-0.17b1`, without introducing any regressions or incompatibilities.</intended_behavior>, <file>sphinx/parsers.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.parsers
3     ~~~~~~~~~~~~~~
4 
5     A Base class for additional parsers.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import warnings
12 from typing import TYPE_CHECKING, Any, Dict, List, Type, Union
13 
14 import docutils.parsers
15 import docutils.parsers.rst
16 from docutils import nodes
17 from docutils.parsers.rst import states
18 from docutils.statemachine import StringList
19 from docutils.transforms import Transform
20 from docutils.transforms.universal import SmartQuotes
21 
22 from sphinx.deprecation import RemovedInSphinx50Warning
23 from sphinx.util.rst import append_epilog, prepend_prolog
24 
25 if TYPE_CHECKING:
26     from sphinx.application import Sphinx
27 
28 
29 class Parser(docutils.parsers.Parser):
30     """
31     A base class of source parsers.  The additional parsers should inherit this class instead
32     of ``docutils.parsers.Parser``.  Compared with ``docutils.parsers.Parser``, this class
33     improves accessibility to Sphinx APIs.
34 
35     The subclasses can access following objects and functions:
36 
37     self.app
38         The application object (:class:`sphinx.application.Sphinx`)
39     self.config
40         The config object (:class:`sphinx.config.Config`)
41     self.env
42         The environment object (:class:`sphinx.environment.BuildEnvironment`)
43     self.warn()
44         Emit a warning. (Same as :meth:`sphinx.application.Sphinx.warn()`)
45     self.info()
46         Emit a informational message. (Same as :meth:`sphinx.application.Sphinx.info()`)
47 
48     .. deprecated:: 1.6
49        ``warn()`` and ``info()`` is deprecated.  Use :mod:`sphinx.util.logging` instead.
50     .. deprecated:: 3.0
51        parser.app is deprecated.
52     """
53 
54     def set_application(self, app: "Sphinx") -> None:
55         """set_application will be called from Sphinx to set app and other instance variables
56 
57         :param sphinx.application.Sphinx app: Sphinx application object
58         """
59         self._app = app
60         self.config = app.config
61         self.env = app.env
62 
63     @property
64     def app(self) -> "Sphinx":
65         warnings.warn('parser.app is deprecated.', RemovedInSphinx50Warning, stacklevel=2)
66         return self._app
67 
68 
69 class RSTParser(docutils.parsers.rst.Parser, Parser):
70     """A reST parser for Sphinx."""
71 
72     def get_transforms(self) -> List[Type[Transform]]:
73         """Sphinx's reST parser replaces a transform class for smart-quotes by own's
74 
75         refs: sphinx.io.SphinxStandaloneReader
76         """
77         transforms = super().get_transforms()
78         transforms.remove(SmartQuotes)
79         return transforms
80 
81     def parse(self, inputstring: Union[str, StringList], document: nodes.document) -> None:
82         """Parse text and generate a document tree."""
83         self.setup_parse(inputstring, document)  # type: ignore
84         self.statemachine = states.RSTStateMachine(
85             state_classes=self.state_classes,
86             initial_state=self.initial_state,
87             debug=document.reporter.debug_flag)
88 
89         # preprocess inputstring
90         if isinstance(inputstring, str):
91             lines = docutils.statemachine.string2lines(
92                 inputstring, tab_width=document.settings.tab_width,
93                 convert_whitespace=True)
94 
95             inputlines = StringList(lines, document.current_source)
96         else:
97             inputlines = inputstring
98 
99         self.decorate(inputlines)
100         self.statemachine.run(inputlines, document, inliner=self.inliner)
101         self.finish_parse()
102 
103     def decorate(self, content: StringList) -> None:
104         """Preprocess reST content before parsing."""
105         prepend_prolog(content, self.config.rst_prolog)
106         append_epilog(content, self.config.rst_epilog)
107 
108 
109 def setup(app: "Sphinx") -> Dict[str, Any]:
110     app.add_source_parser(RSTParser)
111 
112     return {
113         'version': 'builtin',
114         'parallel_read_safe': True,
115         'parallel_write_safe': True,
116     }

</code><intended_behavior>Ensure that all document parsing functionalities maintain their behavior with the newer version of `docutils`. Adjustments may be necessary if `0.17b1` modifies any parsing APIs or behaviors that Sphinx relies upon.</intended_behavior>, <file>sphinx/deprecation.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.deprecation
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx deprecation classes and utilities.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import sys
12 import warnings
13 from importlib import import_module
14 from typing import Any, Dict, Type
15 
16 
17 class RemovedInSphinx40Warning(DeprecationWarning):
18     pass
19 
20 
21 class RemovedInSphinx50Warning(DeprecationWarning):
22     pass
23 
24 
25 class RemovedInSphinx60Warning(PendingDeprecationWarning):
26     pass
27 
28 
29 RemovedInNextVersionWarning = RemovedInSphinx50Warning
30 
31 
32 def deprecated_alias(modname: str, objects: Dict[str, object],
33                      warning: Type[Warning], names: Dict[str, str] = {}) -> None:
34     module = import_module(modname)
35     sys.modules[modname] = _ModuleWrapper(  # type: ignore
36         module, modname, objects, warning, names)
37 
38 
39 class _ModuleWrapper:
40     def __init__(self, module: Any, modname: str,
41                  objects: Dict[str, object],
42                  warning: Type[Warning],
43                  names: Dict[str, str]) -> None:
44         self._module = module
45         self._modname = modname
46         self._objects = objects
47         self._warning = warning
48         self._names = names
49 
50     def __getattr__(self, name: str) -> Any:
51         if name not in self._objects:
52             return getattr(self._module, name)
53 
54         canonical_name = self._names.get(name, None)
55         if canonical_name is not None:
56             warnings.warn(
57                 "The alias '{}.{}' is deprecated, use '{}' instead. Check CHANGES for "
58                 "Sphinx API modifications.".format(self._modname, name, canonical_name),
59                 self._warning, stacklevel=3)
60         else:
61             warnings.warn("{}.{} is deprecated. Check CHANGES for Sphinx "
62                           "API modifications.".format(self._modname, name),
63                           self._warning, stacklevel=3)
64         return self._objects[name]
65 
66 
67 class DeprecatedDict(dict):
68     """A deprecated dict which warns on each access."""
69 
70     def __init__(self, data: Dict, message: str, warning: Type[Warning]) -> None:
71         self.message = message
72         self.warning = warning
73         super().__init__(data)
74 
75     def __setitem__(self, key: str, value: Any) -> None:
76         warnings.warn(self.message, self.warning, stacklevel=2)
77         super().__setitem__(key, value)
78 
79     def setdefault(self, key: str, default: Any = None) -> Any:
80         warnings.warn(self.message, self.warning, stacklevel=2)
81         return super().setdefault(key, default)
82 
83     def __getitem__(self, key: str) -> None:
84         warnings.warn(self.message, self.warning, stacklevel=2)
85         return super().__getitem__(key)
86 
87     def get(self, key: str, default: Any = None) -> Any:
88         warnings.warn(self.message, self.warning, stacklevel=2)
89         return super().get(key, default)
90 
91     def update(self, other: Dict) -> None:  # type: ignore
92         warnings.warn(self.message, self.warning, stacklevel=2)
93         super().update(other)

</code><intended_behavior>Ensure that no deprecated `docutils` APIs are used by Sphinx, or if they are, to update them to the current APIs provided by `docutils-0.17b1`. Shift away from deprecated APIs, ensuring compatibility with new versions.</intended_behavior>]
2025-10-16 00:53:33.454 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,
18                     Set, Tuple, Type, TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning
26 from sphinx.environment import BuildEnvironment
27 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
28                                          import_object)
29 from sphinx.ext.autodoc.mock import ismock, mock, undecorate
30 from sphinx.locale import _, __
31 from sphinx.pycode import ModuleAnalyzer, PycodeError
32 from sphinx.util import inspect, logging
33 from sphinx.util.docstrings import extract_metadata, prepare_docstring
34 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
35                                  stringify_signature)
36 from sphinx.util.typing import OptionSpec, get_type_hints, restify
37 from sphinx.util.typing import stringify as stringify_typehint
38 
39 if TYPE_CHECKING:
40     from sphinx.ext.autodoc.directive import DocumenterBridge
41 
42 
43 logger = logging.getLogger(__name__)
44 
45 
46 # This type isn't exposed directly in any modules, but can be found
47 # here in most Python versions
48 MethodDescriptorType = type(type.__subclasses__)
49 
50 
51 #: extended signature RE: with explicit module name separated by ::
52 py_ext_sig_re = re.compile(
53     r'''^ ([\w.]+::)?            # explicit module name
54           ([\w.]+\.)?            # module and/or class name(s)
55           (\w+)  \s*             # thing name
56           (?: \((.*)\)           # optional: arguments
57            (?:\s* -> \s* (.*))?  #           return annotation
58           )? $                   # and nothing more
59           ''', re.VERBOSE)
60 special_member_re = re.compile(r'^__\S+__$')
61 
62 
63 def identity(x: Any) -> Any:
64     return x
65 
66 
67 class _All:
68     """A special value for :*-members: that matches to any member."""
69 
70     def __contains__(self, item: Any) -> bool:
71         return True
72 
73 
74 class _Empty:
75     """A special value for :exclude-members: that never matches to any member."""
76 
77     def __contains__(self, item: Any) -> bool:
78         return False
79 
80 
81 ALL = _All()
82 EMPTY = _Empty()
83 UNINITIALIZED_ATTR = object()
84 INSTANCEATTR = object()
85 SLOTSATTR = object()
86 
87 
88 def members_option(arg: Any) -> Union[object, List[str]]:
89     """Used to convert the :members: option to auto directives."""
90     if arg in (None, True):
91         return ALL
92     elif arg is False:
93         return None
94     else:
95         return [x.strip() for x in arg.split(',') if x.strip()]
96 
97 
98 def members_set_option(arg: Any) -> Union[object, Set[str]]:
99     """Used to convert the :members: option to auto directives."""
100     warnings.warn("members_set_option() is deprecated.",
101                   RemovedInSphinx50Warning, stacklevel=2)
102     if arg is None:
103         return ALL
104     return {x.strip() for x in arg.split(',') if x.strip()}
105 
106 
107 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
108     """Used to convert the :exclude-members: option."""
109     if arg in (None, True):
110         return EMPTY
111     return {x.strip() for x in arg.split(',') if x.strip()}
112 
113 
114 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
115     """Used to convert the :members: option to auto directives."""
116     if arg in (None, True):
117         return 'object'
118     else:
119         return arg
120 
121 
122 def member_order_option(arg: Any) -> Optional[str]:
123     """Used to convert the :members: option to auto directives."""
124     if arg in (None, True):
125         return None
126     elif arg in ('alphabetical', 'bysource', 'groupwise'):
127         return arg
128     else:
129         raise ValueError(__('invalid value for member-order option: %s') % arg)
130 
131 
132 SUPPRESS = object()
133 
134 
135 def annotation_option(arg: Any) -> Any:
136     if arg in (None, True):
137         # suppress showing the representation of the object
138         return SUPPRESS
139     else:
140         return arg
141 
142 
143 def bool_option(arg: Any) -> bool:
144     """Used to convert flag options to auto directives.  (Instead of
145     directives.flag(), which returns None).
146     """
147     return True
148 
149 
150 def merge_special_members_option(options: Dict) -> None:
151     """Merge :special-members: option to :members: option."""
152     warnings.warn("merge_special_members_option() is deprecated.",
153                   RemovedInSphinx50Warning, stacklevel=2)
154     if 'special-members' in options and options['special-members'] is not ALL:
155         if options.get('members') is ALL:
156             pass
157         elif options.get('members'):
158             for member in options['special-members']:
159                 if member not in options['members']:
160                     options['members'].append(member)
161         else:
162             options['members'] = options['special-members']
163 
164 
165 def merge_members_option(options: Dict) -> None:
166     """Merge :*-members: option to the :members: option."""
167     if options.get('members') is ALL:
168         # merging is not needed when members: ALL
169         return
170 
171     members = options.setdefault('members', [])
172     for key in {'private-members', 'special-members'}:
173         if key in options and options[key] not in (ALL, None):
174             for member in options[key]:
175                 if member not in members:
176                     members.append(member)
177 
178 
179 # Some useful event listener factories for autodoc-process-docstring.
180 
181 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
182     """Return a listener that removes the first *pre* and last *post*
183     lines of every docstring.  If *what* is a sequence of strings,
184     only docstrings of a type in *what* will be processed.
185 
186     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
187 
188        from sphinx.ext.autodoc import cut_lines
189        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
190 
191     This can (and should) be used in place of :confval:`automodule_skip_lines`.
192     """
193     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
194                 ) -> None:
195         if what and what_ not in what:
196             return
197         del lines[:pre]
198         if post:
199             # remove one trailing blank line.
200             if lines and not lines[-1]:
201                 lines.pop(-1)
202             del lines[-post:]
203         # make sure there is a blank line at the end
204         if lines and lines[-1]:
205             lines.append('')
206     return process
207 
208 
209 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
210             exclude: bool = False) -> Callable:
211     """Return a listener that either keeps, or if *exclude* is True excludes,
212     lines between lines that match the *marker* regular expression.  If no line
213     matches, the resulting docstring would be empty, so no change will be made
214     unless *keepempty* is true.
215 
216     If *what* is a sequence of strings, only docstrings of a type in *what* will
217     be processed.
218     """
219     marker_re = re.compile(marker)
220 
221     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
222                 ) -> None:
223         if what and what_ not in what:
224             return
225         deleted = 0
226         delete = not exclude
227         orig_lines = lines[:]
228         for i, line in enumerate(orig_lines):
229             if delete:
230                 lines.pop(i - deleted)
231                 deleted += 1
232             if marker_re.match(line):
233                 delete = not delete
234                 if delete:
235                     lines.pop(i - deleted)
236                     deleted += 1
237         if not lines and not keepempty:
238             lines[:] = orig_lines
239         # make sure there is a blank line at the end
240         if lines and lines[-1]:
241             lines.append('')
242     return process
243 
244 
245 # This class is used only in ``sphinx.ext.autodoc.directive``,
246 # But we define this class here to keep compatibility (see #4538)
247 class Options(dict):
248     """A dict/attribute hybrid that returns None on nonexisting keys."""
249     def __getattr__(self, name: str) -> Any:
250         try:
251             return self[name.replace('_', '-')]
252         except KeyError:
253             return None
254 
255 
256 class ObjectMember(tuple):
257     """A member of object.
258 
259     This is used for the result of `Documenter.get_object_members()` to
260     represent each member of the object.
261 
262     .. Note::
263 
264        An instance of this class behaves as a tuple of (name, object)
265        for compatibility to old Sphinx.  The behavior will be dropped
266        in the future.  Therefore extensions should not use the tuple
267        interface.
268     """
269 
270     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
271         return super().__new__(cls, (name, obj))  # type: ignore
272 
273     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
274                  class_: Any = None, skipped: bool = False) -> None:
275         self.__name__ = name
276         self.object = obj
277         self.docstring = docstring
278         self.skipped = skipped
279         self.class_ = class_
280 
281 
282 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
283 
284 
285 class Documenter:
286     """
287     A Documenter knows how to autodocument a single object type.  When
288     registered with the AutoDirective, it will be used to document objects
289     of that type when needed by autodoc.
290 
291     Its *objtype* attribute selects what auto directive it is assigned to
292     (the directive name is 'auto' + objtype), and what directive it generates
293     by default, though that can be overridden by an attribute called
294     *directivetype*.
295 
296     A Documenter has an *option_spec* that works like a docutils directive's;
297     in fact, it will be used to parse an auto directive's options that matches
298     the documenter.
299     """
300     #: name by which the directive is called (auto...) and the default
301     #: generated directive name
302     objtype = 'object'
303     #: indentation by which to indent the directive content
304     content_indent = '   '
305     #: priority if multiple documenters return True from can_document_member
306     priority = 0
307     #: order if autodoc_member_order is set to 'groupwise'
308     member_order = 0
309     #: true if the generated content may contain titles
310     titles_allowed = False
311 
312     option_spec: OptionSpec = {
313         'noindex': bool_option
314     }
315 
316     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
317         """getattr() override for types such as Zope interfaces."""
318         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
319 
320     @classmethod
321     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
322                             ) -> bool:
323         """Called to see if a member can be documented by this documenter."""
324         raise NotImplementedError('must be implemented in subclasses')
325 
326     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
327         self.directive = directive
328         self.config: Config = directive.env.config
329         self.env: BuildEnvironment = directive.env
330         self.options = directive.genopt
331         self.name = name
332         self.indent = indent
333         # the module and object path within the module, and the fully
334         # qualified name (all set after resolve_name succeeds)
335         self.modname: str = None
336         self.module: ModuleType = None
337         self.objpath: List[str] = None
338         self.fullname: str = None
339         # extra signature items (arguments and return annotation,
340         # also set after resolve_name succeeds)
341         self.args: str = None
342         self.retann: str = None
343         # the object to document (set after import_object succeeds)
344         self.object: Any = None
345         self.object_name: str = None
346         # the parent/owner of the object to document
347         self.parent: Any = None
348         # the module analyzer to get at attribute docs, or None
349         self.analyzer: ModuleAnalyzer = None
350 
351     @property
352     def documenters(self) -> Dict[str, Type["Documenter"]]:
353         """Returns registered Documenter classes"""
354         return self.env.app.registry.documenters
355 
356     def add_line(self, line: str, source: str, *lineno: int) -> None:
357         """Append one line of generated reST to the output."""
358         if line.strip():  # not a blank line
359             self.directive.result.append(self.indent + line, source, *lineno)
360         else:
361             self.directive.result.append('', source, *lineno)
362 
363     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
364                      ) -> Tuple[str, List[str]]:
365         """Resolve the module and name of the object to document given by the
366         arguments and the current module/class.
367 
368         Must return a pair of the module name and a chain of attributes; for
369         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
370         ``zipfile.ZipFile.open`` method.
371         """
372         raise NotImplementedError('must be implemented in subclasses')
373 
374     def parse_name(self) -> bool:
375         """Determine what module to import and what attribute to document.
376 
377         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
378         *self.args* and *self.retann* if parsing and resolving was successful.
379         """
380         # first, parse the definition -- auto directives for classes and
381         # functions can contain a signature which is then used instead of
382         # an autogenerated one
383         try:
384             explicit_modname, path, base, args, retann = \
385                 py_ext_sig_re.match(self.name).groups()
386         except AttributeError:
387             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
388                            type='autodoc')
389             return False
390 
391         # support explicit module and class name separation via ::
392         if explicit_modname is not None:
393             modname = explicit_modname[:-2]
394             parents = path.rstrip('.').split('.') if path else []
395         else:
396             modname = None
397             parents = []
398 
399         with mock(self.config.autodoc_mock_imports):
400             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
401 
402         if not self.modname:
403             return False
404 
405         self.args = args
406         self.retann = retann
407         self.fullname = (self.modname or '') + \
408                         ('.' + '.'.join(self.objpath) if self.objpath else '')
409         return True
410 
411     def import_object(self, raiseerror: bool = False) -> bool:
412         """Import the object given by *self.modname* and *self.objpath* and set
413         it as *self.object*.
414 
415         Returns True if successful, False if an error occurred.
416         """
417         with mock(self.config.autodoc_mock_imports):
418             try:
419                 ret = import_object(self.modname, self.objpath, self.objtype,
420                                     attrgetter=self.get_attr,
421                                     warningiserror=self.config.autodoc_warningiserror)
422                 self.module, self.parent, self.object_name, self.object = ret
423                 if ismock(self.object):
424                     self.object = undecorate(self.object)
425                 return True
426             except ImportError as exc:
427                 if raiseerror:
428                     raise
429                 else:
430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
431                     self.env.note_reread()
432                     return False
433 
434     def get_real_modname(self) -> str:
435         """Get the real module name of an object to document.
436 
437         It can differ from the name of the module through which the object was
438         imported.
439         """
440         return self.get_attr(self.object, '__module__', None) or self.modname
441 
442     def check_module(self) -> bool:
443         """Check if *self.object* is really defined in the module given by
444         *self.modname*.
445         """
446         if self.options.imported_members:
447             return True
448 
449         subject = inspect.unpartial(self.object)
450         modname = self.get_attr(subject, '__module__', None)
451         if modname and modname != self.modname:
452             return False
453         return True
454 
455     def format_args(self, **kwargs: Any) -> str:
456         """Format the argument signature of *self.object*.
457 
458         Should return None if the object does not have a signature.
459         """
460         return None
461 
462     def format_name(self) -> str:
463         """Format the name of *self.object*.
464 
465         This normally should be something that can be parsed by the generated
466         directive, but doesn't need to be (Sphinx will display it unparsed
467         then).
468         """
469         # normally the name doesn't contain the module (except for module
470         # directives of course)
471         return '.'.join(self.objpath) or self.modname
472 
473     def _call_format_args(self, **kwargs: Any) -> str:
474         if kwargs:
475             try:
476                 return self.format_args(**kwargs)
477             except TypeError:
478                 # avoid chaining exceptions, by putting nothing here
479                 pass
480 
481         # retry without arguments for old documenters
482         return self.format_args()
483 
484     def format_signature(self, **kwargs: Any) -> str:
485         """Format the signature (arguments and return annotation) of the object.
486 
487         Let the user process it via the ``autodoc-process-signature`` event.
488         """
489         if self.args is not None:
490             # signature given explicitly
491             args = "(%s)" % self.args
492             retann = self.retann
493         else:
494             # try to introspect the signature
495             try:
496                 retann = None
497                 args = self._call_format_args(**kwargs)
498                 if args:
499                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
500                     if matched:
501                         args = matched.group(1)
502                         retann = matched.group(2)
503             except Exception as exc:
504                 logger.warning(__('error while formatting arguments for %s: %s'),
505                                self.fullname, exc, type='autodoc')
506                 args = None
507 
508         result = self.env.events.emit_firstresult('autodoc-process-signature',
509                                                   self.objtype, self.fullname,
510                                                   self.object, self.options, args, retann)
511         if result:
512             args, retann = result
513 
514         if args is not None:
515             return args + ((' -> %s' % retann) if retann else '')
516         else:
517             return ''
518 
519     def add_directive_header(self, sig: str) -> None:
520         """Add the directive header and options to the generated content."""
521         domain = getattr(self, 'domain', 'py')
522         directive = getattr(self, 'directivetype', self.objtype)
523         name = self.format_name()
524         sourcename = self.get_sourcename()
525 
526         # one signature per line, indented by column
527         prefix = '.. %s:%s:: ' % (domain, directive)
528         for i, sig_line in enumerate(sig.split("\n")):
529             self.add_line('%s%s%s' % (prefix, name, sig_line),
530                           sourcename)
531             if i == 0:
532                 prefix = " " * len(prefix)
533 
534         if self.options.noindex:
535             self.add_line('   :noindex:', sourcename)
536         if self.objpath:
537             # Be explicit about the module, this is necessary since .. class::
538             # etc. don't support a prepended module name
539             self.add_line('   :module: %s' % self.modname, sourcename)
540 
541     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
542         """Decode and return lines of the docstring(s) for the object.
543 
544         When it returns None value, autodoc-process-docstring will not be called for this
545         object.
546         """
547         if ignore is not None:
548             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
549                           % self.__class__.__name__,
550                           RemovedInSphinx50Warning, stacklevel=2)
551         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
552                            self.parent, self.object_name)
553         if docstring:
554             tab_width = self.directive.state.document.settings.tab_width
555             return [prepare_docstring(docstring, ignore, tab_width)]
556         return []
557 
558     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
559         """Let the user process the docstrings before adding them."""
560         for docstringlines in docstrings:
561             if self.env.app:
562                 # let extensions preprocess docstrings
563                 self.env.app.emit('autodoc-process-docstring',
564                                   self.objtype, self.fullname, self.object,
565                                   self.options, docstringlines)
566 
567                 if docstringlines and docstringlines[-1] != '':
568                     # append a blank line to the end of the docstring
569                     docstringlines.append('')
570 
571             yield from docstringlines
572 
573     def get_sourcename(self) -> str:
574         if (getattr(self.object, '__module__', None) and
575                 getattr(self.object, '__qualname__', None)):
576             # Get the correct location of docstring from self.object
577             # to support inherited methods
578             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
579         else:
580             fullname = self.fullname
581 
582         if self.analyzer:
583             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
584         else:
585             return 'docstring of %s' % fullname
586 
587     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
588                     ) -> None:
589         """Add content from docstrings, attribute documentation and user."""
590         if no_docstring:
591             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
592                           % self.__class__.__name__,
593                           RemovedInSphinx50Warning, stacklevel=2)
594 
595         # set sourcename and add content from attribute documentation
596         sourcename = self.get_sourcename()
597         if self.analyzer:
598             attr_docs = self.analyzer.find_attr_docs()
599             if self.objpath:
600                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
601                 if key in attr_docs:
602                     no_docstring = True
603                     # make a copy of docstring for attributes to avoid cache
604                     # the change of autodoc-process-docstring event.
605                     docstrings = [list(attr_docs[key])]
606 
607                     for i, line in enumerate(self.process_doc(docstrings)):
608                         self.add_line(line, sourcename, i)
609 
610         # add content from docstrings
611         if not no_docstring:
612             docstrings = self.get_doc()
613             if docstrings is None:
614                 # Do not call autodoc-process-docstring on get_doc() returns None.
615                 pass
616             else:
617                 if not docstrings:
618                     # append at least a dummy docstring, so that the event
619                     # autodoc-process-docstring is fired and can add some
620                     # content if desired
621                     docstrings.append([])
622                 for i, line in enumerate(self.process_doc(docstrings)):
623                     self.add_line(line, sourcename, i)
624 
625         # add additional content (e.g. from document), if present
626         if more_content:
627             for line, src in zip(more_content.data, more_content.items):
628                 self.add_line(line, src[0], src[1])
629 
630     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
631         """Return `(members_check_module, members)` where `members` is a
632         list of `(membername, member)` pairs of the members of *self.object*.
633 
634         If *want_all* is True, return all members.  Else, only return those
635         members given by *self.options.members* (which may also be none).
636         """
637         warnings.warn('The implementation of Documenter.get_object_members() will be '
638                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
639         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
640         if not want_all:
641             if not self.options.members:
642                 return False, []  # type: ignore
643             # specific members given
644             selected = []
645             for name in self.options.members:  # type: str
646                 if name in members:
647                     selected.append((name, members[name].value))
648                 else:
649                     logger.warning(__('missing attribute %s in object %s') %
650                                    (name, self.fullname), type='autodoc')
651             return False, selected
652         elif self.options.inherited_members:
653             return False, [(m.name, m.value) for m in members.values()]
654         else:
655             return False, [(m.name, m.value) for m in members.values()
656                            if m.directly_defined]
657 
658     def filter_members(self, members: ObjectMembers, want_all: bool
659                        ) -> List[Tuple[str, Any, bool]]:
660         """Filter the given member list.
661 
662         Members are skipped if
663 
664         - they are private (except if given explicitly or the private-members
665           option is set)
666         - they are special methods (except if given explicitly or the
667           special-members option is set)
668         - they are undocumented (except if the undoc-members option is set)
669 
670         The user can override the skipping decision by connecting to the
671         ``autodoc-skip-member`` event.
672         """
673         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
674             if inspect.isclass(self.object):
675                 for cls in self.object.__mro__:
676                     if cls.__name__ == self.options.inherited_members and cls != self.object:
677                         # given member is a member of specified *super class*
678                         return True
679                     elif name in cls.__dict__:
680                         return False
681                     elif name in self.get_attr(cls, '__annotations__', {}):
682                         return False
683                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
684                         return False
685 
686             return False
687 
688         ret = []
689 
690         # search for members in source code too
691         namespace = '.'.join(self.objpath)  # will be empty for modules
692 
693         if self.analyzer:
694             attr_docs = self.analyzer.find_attr_docs()
695         else:
696             attr_docs = {}
697 
698         # process members and determine which to skip
699         for obj in members:
700             membername, member = obj
701             # if isattr is True, the member is documented as an attribute
702             if member is INSTANCEATTR:
703                 isattr = True
704             else:
705                 isattr = False
706 
707             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
708                          self.parent, self.object_name)
709             if not isinstance(doc, str):
710                 # Ignore non-string __doc__
711                 doc = None
712 
713             # if the member __doc__ is the same as self's __doc__, it's just
714             # inherited and therefore not the member's doc
715             cls = self.get_attr(member, '__class__', None)
716             if cls:
717                 cls_doc = self.get_attr(cls, '__doc__', None)
718                 if cls_doc == doc:
719                     doc = None
720 
721             if isinstance(obj, ObjectMember) and obj.docstring:
722                 # hack for ClassDocumenter to inject docstring via ObjectMember
723                 doc = obj.docstring
724 
725             has_doc = bool(doc)
726 
727             metadata = extract_metadata(doc)
728             if 'private' in metadata:
729                 # consider a member private if docstring has "private" metadata
730                 isprivate = True
731             elif 'public' in metadata:
732                 # consider a member public if docstring has "public" metadata
733                 isprivate = False
734             else:
735                 isprivate = membername.startswith('_')
736 
737             keep = False
738             if ismock(member):
739                 # mocked module or object
740                 pass
741             elif self.options.exclude_members and membername in self.options.exclude_members:
742                 # remove members given by exclude-members
743                 keep = False
744             elif want_all and special_member_re.match(membername):
745                 # special __methods__
746                 if self.options.special_members and membername in self.options.special_members:
747                     if membername == '__doc__':
748                         keep = False
749                     elif is_filtered_inherited_member(membername, obj):
750                         keep = False
751                     else:
752                         keep = has_doc or self.options.undoc_members
753                 else:
754                     keep = False
755             elif (namespace, membername) in attr_docs:
756                 if want_all and isprivate:
757                     if self.options.private_members is None:
758                         keep = False
759                     else:
760                         keep = membername in self.options.private_members
761                 else:
762                     # keep documented attributes
763                     keep = True
764                 isattr = True
765             elif want_all and isprivate:
766                 if has_doc or self.options.undoc_members:
767                     if self.options.private_members is None:
768                         keep = False
769                     elif is_filtered_inherited_member(membername, obj):
770                         keep = False
771                     else:
772                         keep = membername in self.options.private_members
773                 else:
774                     keep = False
775             else:
776                 if (self.options.members is ALL and
777                         is_filtered_inherited_member(membername, obj)):
778                     keep = False
779                 else:
780                     # ignore undocumented members if :undoc-members: is not given
781                     keep = has_doc or self.options.undoc_members
782 
783             if isinstance(obj, ObjectMember) and obj.skipped:
784                 # forcedly skipped member (ex. a module attribute not defined in __all__)
785                 keep = False
786 
787             # give the user a chance to decide whether this member
788             # should be skipped
789             if self.env.app:
790                 # let extensions preprocess docstrings
791                 try:
792                     skip_user = self.env.app.emit_firstresult(
793                         'autodoc-skip-member', self.objtype, membername, member,
794                         not keep, self.options)
795                     if skip_user is not None:
796                         keep = not skip_user
797                 except Exception as exc:
798                     logger.warning(__('autodoc: failed to determine %r to be documented, '
799                                       'the following exception was raised:\n%s'),
800                                    member, exc, type='autodoc')
801                     keep = False
802 
803             if keep:
804                 ret.append((membername, member, isattr))
805 
806         return ret
807 
808     def document_members(self, all_members: bool = False) -> None:
809         """Generate reST for member documentation.
810 
811         If *all_members* is True, do all members, else those given by
812         *self.options.members*.
813         """
814         # set current namespace for finding members
815         self.env.temp_data['autodoc:module'] = self.modname
816         if self.objpath:
817             self.env.temp_data['autodoc:class'] = self.objpath[0]
818 
819         want_all = all_members or self.options.inherited_members or \
820             self.options.members is ALL
821         # find out which members are documentable
822         members_check_module, members = self.get_object_members(want_all)
823 
824         # document non-skipped members
825         memberdocumenters: List[Tuple[Documenter, bool]] = []
826         for (mname, member, isattr) in self.filter_members(members, want_all):
827             classes = [cls for cls in self.documenters.values()
828                        if cls.can_document_member(member, mname, isattr, self)]
829             if not classes:
830                 # don't know how to document this member
831                 continue
832             # prefer the documenter with the highest priority
833             classes.sort(key=lambda cls: cls.priority)
834             # give explicitly separated module name, so that members
835             # of inner classes can be documented
836             full_mname = self.modname + '::' + \
837                 '.'.join(self.objpath + [mname])
838             documenter = classes[-1](self.directive, full_mname, self.indent)
839             memberdocumenters.append((documenter, isattr))
840 
841         member_order = self.options.member_order or self.config.autodoc_member_order
842         memberdocumenters = self.sort_members(memberdocumenters, member_order)
843 
844         for documenter, isattr in memberdocumenters:
845             documenter.generate(
846                 all_members=True, real_modname=self.real_modname,
847                 check_module=members_check_module and not isattr)
848 
849         # reset current objects
850         self.env.temp_data['autodoc:module'] = None
851         self.env.temp_data['autodoc:class'] = None
852 
853     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
854                      order: str) -> List[Tuple["Documenter", bool]]:
855         """Sort the given member list."""
856         if order == 'groupwise':
857             # sort by group; alphabetically within groups
858             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
859         elif order == 'bysource':
860             if self.analyzer:
861                 # sort by source order, by virtue of the module analyzer
862                 tagorder = self.analyzer.tagorder
863 
864                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
865                     fullname = entry[0].name.split('::')[1]
866                     return tagorder.get(fullname, len(tagorder))
867                 documenters.sort(key=keyfunc)
868             else:
869                 # Assume that member discovery order matches source order.
870                 # This is a reasonable assumption in Python 3.6 and up, where
871                 # module.__dict__ is insertion-ordered.
872                 pass
873         else:  # alphabetical
874             documenters.sort(key=lambda e: e[0].name)
875 
876         return documenters
877 
878     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
879                  check_module: bool = False, all_members: bool = False) -> None:
880         """Generate reST for the object given by *self.name*, and possibly for
881         its members.
882 
883         If *more_content* is given, include that content. If *real_modname* is
884         given, use that module name to find attribute docs. If *check_module* is
885         True, only generate if the object is defined in the module name it is
886         imported from. If *all_members* is True, document all members.
887         """
888         if not self.parse_name():
889             # need a module to import
890             logger.warning(
891                 __('don\'t know which module to import for autodocumenting '
892                    '%r (try placing a "module" or "currentmodule" directive '
893                    'in the document, or giving an explicit module name)') %
894                 self.name, type='autodoc')
895             return
896 
897         # now, import the module and get object to document
898         if not self.import_object():
899             return
900 
901         # If there is no real module defined, figure out which to use.
902         # The real module is used in the module analyzer to look up the module
903         # where the attribute documentation would actually be found in.
904         # This is used for situations where you have a module that collects the
905         # functions and classes of internal submodules.
906         guess_modname = self.get_real_modname()
907         self.real_modname: str = real_modname or guess_modname
908 
909         # try to also get a source code analyzer for attribute docs
910         try:
911             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
912             # parse right now, to get PycodeErrors on parsing (results will
913             # be cached anyway)
914             self.analyzer.find_attr_docs()
915         except PycodeError as exc:
916             logger.debug('[autodoc] module analyzer failed: %s', exc)
917             # no source file -- e.g. for builtin and C modules
918             self.analyzer = None
919             # at least add the module.__file__ as a dependency
920             if hasattr(self.module, '__file__') and self.module.__file__:
921                 self.directive.record_dependencies.add(self.module.__file__)
922         else:
923             self.directive.record_dependencies.add(self.analyzer.srcname)
924 
925         if self.real_modname != guess_modname:
926             # Add module to dependency list if target object is defined in other module.
927             try:
928                 analyzer = ModuleAnalyzer.for_module(guess_modname)
929                 self.directive.record_dependencies.add(analyzer.srcname)
930             except PycodeError:
931                 pass
932 
933         # check __module__ of object (for members not given explicitly)
934         if check_module:
935             if not self.check_module():
936                 return
937 
938         sourcename = self.get_sourcename()
939 
940         # make sure that the result starts with an empty line.  This is
941         # necessary for some situations where another directive preprocesses
942         # reST and no starting newline is present
943         self.add_line('', sourcename)
944 
945         # format the object's signature, if any
946         try:
947             sig = self.format_signature()
948         except Exception as exc:
949             logger.warning(__('error while formatting signature for %s: %s'),
950                            self.fullname, exc, type='autodoc')
951             return
952 
953         # generate the directive header and options, if applicable
954         self.add_directive_header(sig)
955         self.add_line('', sourcename)
956 
957         # e.g. the module directive doesn't have content
958         self.indent += self.content_indent
959 
960         # add all content (from docstrings, attribute docs etc.)
961         self.add_content(more_content)
962 
963         # document members, if possible
964         self.document_members(all_members)
965 
966 
967 class ModuleDocumenter(Documenter):
968     """
969     Specialized Documenter subclass for modules.
970     """
971     objtype = 'module'
972     content_indent = ''
973     titles_allowed = True
974 
975     option_spec: OptionSpec = {
976         'members': members_option, 'undoc-members': bool_option,
977         'noindex': bool_option, 'inherited-members': inherited_members_option,
978         'show-inheritance': bool_option, 'synopsis': identity,
979         'platform': identity, 'deprecated': bool_option,
980         'member-order': member_order_option, 'exclude-members': exclude_members_option,
981         'private-members': members_option, 'special-members': members_option,
982         'imported-members': bool_option, 'ignore-module-all': bool_option
983     }
984 
985     def __init__(self, *args: Any) -> None:
986         super().__init__(*args)
987         merge_members_option(self.options)
988         self.__all__: Optional[Sequence[str]] = None
989 
990     @classmethod
991     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
992                             ) -> bool:
993         # don't document submodules automatically
994         return False
995 
996     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
997                      ) -> Tuple[str, List[str]]:
998         if modname is not None:
999             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1000                            type='autodoc')
1001         return (path or '') + base, []
1002 
1003     def parse_name(self) -> bool:
1004         ret = super().parse_name()
1005         if self.args or self.retann:
1006             logger.warning(__('signature arguments or return annotation '
1007                               'given for automodule %s') % self.fullname,
1008                            type='autodoc')
1009         return ret
1010 
1011     def import_object(self, raiseerror: bool = False) -> bool:
1012         ret = super().import_object(raiseerror)
1013 
1014         try:
1015             if not self.options.ignore_module_all:
1016                 self.__all__ = inspect.getall(self.object)
1017         except ValueError as exc:
1018             # invalid __all__ found.
1019             logger.warning(__('__all__ should be a list of strings, not %r '
1020                               '(in module %s) -- ignoring __all__') %
1021                            (exc.args[0], self.fullname), type='autodoc')
1022 
1023         return ret
1024 
1025     def add_directive_header(self, sig: str) -> None:
1026         Documenter.add_directive_header(self, sig)
1027 
1028         sourcename = self.get_sourcename()
1029 
1030         # add some module-specific options
1031         if self.options.synopsis:
1032             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1033         if self.options.platform:
1034             self.add_line('   :platform: ' + self.options.platform, sourcename)
1035         if self.options.deprecated:
1036             self.add_line('   :deprecated:', sourcename)
1037 
1038     def get_module_members(self) -> Dict[str, ObjectMember]:
1039         """Get members of target module."""
1040         if self.analyzer:
1041             attr_docs = self.analyzer.attr_docs
1042         else:
1043             attr_docs = {}
1044 
1045         members: Dict[str, ObjectMember] = {}
1046         for name in dir(self.object):
1047             try:
1048                 value = safe_getattr(self.object, name, None)
1049                 if ismock(value):
1050                     value = undecorate(value)
1051                 docstring = attr_docs.get(('', name), [])
1052                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1053             except AttributeError:
1054                 continue
1055 
1056         # annotation only member (ex. attr: int)
1057         for name in inspect.getannotations(self.object):
1058             if name not in members:
1059                 docstring = attr_docs.get(('', name), [])
1060                 members[name] = ObjectMember(name, INSTANCEATTR,
1061                                              docstring="\n".join(docstring))
1062 
1063         return members
1064 
1065     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1066         members = self.get_module_members()
1067         if want_all:
1068             if self.__all__ is None:
1069                 # for implicit module members, check __module__ to avoid
1070                 # documenting imported objects
1071                 return True, list(members.values())
1072             else:
1073                 for member in members.values():
1074                     if member.__name__ not in self.__all__:
1075                         member.skipped = True
1076 
1077                 return False, list(members.values())
1078         else:
1079             memberlist = self.options.members or []
1080             ret = []
1081             for name in memberlist:
1082                 if name in members:
1083                     ret.append(members[name])
1084                 else:
1085                     logger.warning(__('missing attribute mentioned in :members: option: '
1086                                       'module %s, attribute %s') %
1087                                    (safe_getattr(self.object, '__name__', '???'), name),
1088                                    type='autodoc')
1089             return False, ret
1090 
1091     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1092                      order: str) -> List[Tuple["Documenter", bool]]:
1093         if order == 'bysource' and self.__all__:
1094             # Sort alphabetically first (for members not listed on the __all__)
1095             documenters.sort(key=lambda e: e[0].name)
1096 
1097             # Sort by __all__
1098             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1099                 name = entry[0].name.split('::')[1]
1100                 if self.__all__ and name in self.__all__:
1101                     return self.__all__.index(name)
1102                 else:
1103                     return len(self.__all__)
1104             documenters.sort(key=keyfunc)
1105 
1106             return documenters
1107         else:
1108             return super().sort_members(documenters, order)
1109 
1110 
1111 class ModuleLevelDocumenter(Documenter):
1112     """
1113     Specialized Documenter subclass for objects on module level (functions,
1114     classes, data/constants).
1115     """
1116     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1117                      ) -> Tuple[str, List[str]]:
1118         if modname is None:
1119             if path:
1120                 modname = path.rstrip('.')
1121             else:
1122                 # if documenting a toplevel object without explicit module,
1123                 # it can be contained in another auto directive ...
1124                 modname = self.env.temp_data.get('autodoc:module')
1125                 # ... or in the scope of a module directive
1126                 if not modname:
1127                     modname = self.env.ref_context.get('py:module')
1128                 # ... else, it stays None, which means invalid
1129         return modname, parents + [base]
1130 
1131 
1132 class ClassLevelDocumenter(Documenter):
1133     """
1134     Specialized Documenter subclass for objects on class level (methods,
1135     attributes).
1136     """
1137     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1138                      ) -> Tuple[str, List[str]]:
1139         if modname is None:
1140             if path:
1141                 mod_cls = path.rstrip('.')
1142             else:
1143                 mod_cls = None
1144                 # if documenting a class-level object without path,
1145                 # there must be a current class, either from a parent
1146                 # auto directive ...
1147                 mod_cls = self.env.temp_data.get('autodoc:class')
1148                 # ... or from a class directive
1149                 if mod_cls is None:
1150                     mod_cls = self.env.ref_context.get('py:class')
1151                 # ... if still None, there's no way to know
1152                 if mod_cls is None:
1153                     return None, []
1154             modname, sep, cls = mod_cls.rpartition('.')
1155             parents = [cls]
1156             # if the module name is still missing, get it like above
1157             if not modname:
1158                 modname = self.env.temp_data.get('autodoc:module')
1159             if not modname:
1160                 modname = self.env.ref_context.get('py:module')
1161             # ... else, it stays None, which means invalid
1162         return modname, parents + [base]
1163 
1164 
1165 class DocstringSignatureMixin:
1166     """
1167     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1168     feature of reading the signature from the docstring.
1169     """
1170     _new_docstrings: List[List[str]] = None
1171     _signatures: List[str] = None
1172 
1173     def _find_signature(self) -> Tuple[str, str]:
1174         # candidates of the object name
1175         valid_names = [self.objpath[-1]]  # type: ignore
1176         if isinstance(self, ClassDocumenter):
1177             valid_names.append('__init__')
1178             if hasattr(self.object, '__mro__'):
1179                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1180 
1181         docstrings = self.get_doc()
1182         if docstrings is None:
1183             return None, None
1184         self._new_docstrings = docstrings[:]
1185         self._signatures = []
1186         result = None
1187         for i, doclines in enumerate(docstrings):
1188             for j, line in enumerate(doclines):
1189                 if not line:
1190                     # no lines in docstring, no match
1191                     break
1192 
1193                 if line.endswith('\\'):
1194                     line = line.rstrip('\\').rstrip()
1195 
1196                 # match first line of docstring against signature RE
1197                 match = py_ext_sig_re.match(line)
1198                 if not match:
1199                     break
1200                 exmod, path, base, args, retann = match.groups()
1201 
1202                 # the base name must match ours
1203                 if base not in valid_names:
1204                     break
1205 
1206                 # re-prepare docstring to ignore more leading indentation
1207                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1208                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1209                                                             tabsize=tab_width)
1210 
1211                 if result is None:
1212                     # first signature
1213                     result = args, retann
1214                 else:
1215                     # subsequent signatures
1216                     self._signatures.append("(%s) -> %s" % (args, retann))
1217 
1218             if result:
1219                 # finish the loop when signature found
1220                 break
1221 
1222         return result
1223 
1224     def get_doc(self, ignore: int = None) -> List[List[str]]:
1225         if self._new_docstrings is not None:
1226             return self._new_docstrings
1227         return super().get_doc(ignore)  # type: ignore
1228 
1229     def format_signature(self, **kwargs: Any) -> str:
1230         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1231             # only act if a signature is not explicitly given already, and if
1232             # the feature is enabled
1233             result = self._find_signature()
1234             if result is not None:
1235                 self.args, self.retann = result
1236         sig = super().format_signature(**kwargs)  # type: ignore
1237         if self._signatures:
1238             return "\n".join([sig] + self._signatures)
1239         else:
1240             return sig
1241 
1242 
1243 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1244     """
1245     Mixin for AttributeDocumenter to provide the
1246     feature of stripping any function signature from the docstring.
1247     """
1248     def format_signature(self, **kwargs: Any) -> str:
1249         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1250             # only act if a signature is not explicitly given already, and if
1251             # the feature is enabled
1252             result = self._find_signature()
1253             if result is not None:
1254                 # Discarding _args is a only difference with
1255                 # DocstringSignatureMixin.format_signature.
1256                 # Documenter.format_signature use self.args value to format.
1257                 _args, self.retann = result
1258         return super().format_signature(**kwargs)
1259 
1260 
1261 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1262     """
1263     Specialized Documenter subclass for functions.
1264     """
1265     objtype = 'function'
1266     member_order = 30
1267 
1268     @classmethod
1269     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1270                             ) -> bool:
1271         # supports functions, builtins and bound methods exported at the module level
1272         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1273                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1274 
1275     def format_args(self, **kwargs: Any) -> str:
1276         if self.config.autodoc_typehints in ('none', 'description'):
1277             kwargs.setdefault('show_annotation', False)
1278 
1279         try:
1280             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1281             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1282             args = stringify_signature(sig, **kwargs)
1283         except TypeError as exc:
1284             logger.warning(__("Failed to get a function signature for %s: %s"),
1285                            self.fullname, exc)
1286             return None
1287         except ValueError:
1288             args = ''
1289 
1290         if self.config.strip_signature_backslash:
1291             # escape backslashes for reST
1292             args = args.replace('\\', '\\\\')
1293         return args
1294 
1295     def document_members(self, all_members: bool = False) -> None:
1296         pass
1297 
1298     def add_directive_header(self, sig: str) -> None:
1299         sourcename = self.get_sourcename()
1300         super().add_directive_header(sig)
1301 
1302         if inspect.iscoroutinefunction(self.object):
1303             self.add_line('   :async:', sourcename)
1304 
1305     def format_signature(self, **kwargs: Any) -> str:
1306         sigs = []
1307         if (self.analyzer and
1308                 '.'.join(self.objpath) in self.analyzer.overloads and
1309                 self.config.autodoc_typehints == 'signature'):
1310             # Use signatures for overloaded functions instead of the implementation function.
1311             overloaded = True
1312         else:
1313             overloaded = False
1314             sig = super().format_signature(**kwargs)
1315             sigs.append(sig)
1316 
1317         if inspect.is_singledispatch_function(self.object):
1318             # append signature of singledispatch'ed functions
1319             for typ, func in self.object.registry.items():
1320                 if typ is object:
1321                     pass  # default implementation. skipped.
1322                 else:
1323                     self.annotate_to_first_argument(func, typ)
1324 
1325                     documenter = FunctionDocumenter(self.directive, '')
1326                     documenter.object = func
1327                     documenter.objpath = [None]
1328                     sigs.append(documenter.format_signature())
1329         if overloaded:
1330             actual = inspect.signature(self.object,
1331                                        type_aliases=self.config.autodoc_type_aliases)
1332             __globals__ = safe_getattr(self.object, '__globals__', {})
1333             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1334                 overload = self.merge_default_value(actual, overload)
1335                 overload = evaluate_signature(overload, __globals__,
1336                                               self.config.autodoc_type_aliases)
1337 
1338                 sig = stringify_signature(overload, **kwargs)
1339                 sigs.append(sig)
1340 
1341         return "\n".join(sigs)
1342 
1343     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
1344         """Merge default values of actual implementation to the overload variants."""
1345         parameters = list(overload.parameters.values())
1346         for i, param in enumerate(parameters):
1347             actual_param = actual.parameters.get(param.name)
1348             if actual_param and param.default == '...':
1349                 parameters[i] = param.replace(default=actual_param.default)
1350 
1351         return overload.replace(parameters=parameters)
1352 
1353     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1354         """Annotate type hint to the first argument of function if needed."""
1355         try:
1356             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1357         except TypeError as exc:
1358             logger.warning(__("Failed to get a function signature for %s: %s"),
1359                            self.fullname, exc)
1360             return
1361         except ValueError:
1362             return
1363 
1364         if len(sig.parameters) == 0:
1365             return
1366 
1367         params = list(sig.parameters.values())
1368         if params[0].annotation is Parameter.empty:
1369             params[0] = params[0].replace(annotation=typ)
1370             try:
1371                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1372             except (AttributeError, TypeError):
1373                 # failed to update signature (ex. built-in or extension types)
1374                 return
1375 
1376 
1377 class DecoratorDocumenter(FunctionDocumenter):
1378     """
1379     Specialized Documenter subclass for decorator functions.
1380     """
1381     objtype = 'decorator'
1382 
1383     # must be lower than FunctionDocumenter
1384     priority = -1
1385 
1386     def format_args(self, **kwargs: Any) -> Any:
1387         args = super().format_args(**kwargs)
1388         if ',' in args:
1389             return args
1390         else:
1391             return None
1392 
1393 
1394 # Types which have confusing metaclass signatures it would be best not to show.
1395 # These are listed by name, rather than storing the objects themselves, to avoid
1396 # needing to import the modules.
1397 _METACLASS_CALL_BLACKLIST = [
1398     'enum.EnumMeta.__call__',
1399 ]
1400 
1401 
1402 # Types whose __new__ signature is a pass-thru.
1403 _CLASS_NEW_BLACKLIST = [
1404     'typing.Generic.__new__',
1405 ]
1406 
1407 
1408 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1409     """
1410     Specialized Documenter subclass for classes.
1411     """
1412     objtype = 'class'
1413     member_order = 20
1414     option_spec: OptionSpec = {
1415         'members': members_option, 'undoc-members': bool_option,
1416         'noindex': bool_option, 'inherited-members': inherited_members_option,
1417         'show-inheritance': bool_option, 'member-order': member_order_option,
1418         'exclude-members': exclude_members_option,
1419         'private-members': members_option, 'special-members': members_option,
1420     }
1421 
1422     _signature_class: Any = None
1423     _signature_method_name: str = None
1424 
1425     def __init__(self, *args: Any) -> None:
1426         super().__init__(*args)
1427         merge_members_option(self.options)
1428 
1429     @classmethod
1430     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1431                             ) -> bool:
1432         return isinstance(member, type)
1433 
1434     def import_object(self, raiseerror: bool = False) -> bool:
1435         ret = super().import_object(raiseerror)
1436         # if the class is documented under another name, document it
1437         # as data/attribute
1438         if ret:
1439             if hasattr(self.object, '__name__'):
1440                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1441             else:
1442                 self.doc_as_attr = True
1443         return ret
1444 
1445     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1446         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1447             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1448             if inspect.is_builtin_class_method(obj, attr):
1449                 return None
1450             attr = self.get_attr(obj, attr, None)
1451             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1452                 return None
1453             return attr
1454 
1455         # This sequence is copied from inspect._signature_from_callable.
1456         # ValueError means that no signature could be found, so we keep going.
1457 
1458         # First, we check the obj has a __signature__ attribute
1459         if (hasattr(self.object, '__signature__') and
1460                 isinstance(self.object.__signature__, Signature)):
1461             return None, None, self.object.__signature__
1462 
1463         # Next, let's see if it has an overloaded __call__ defined
1464         # in its metaclass
1465         call = get_user_defined_function_or_method(type(self.object), '__call__')
1466 
1467         if call is not None:
1468             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1469                 call = None
1470 
1471         if call is not None:
1472             self.env.app.emit('autodoc-before-process-signature', call, True)
1473             try:
1474                 sig = inspect.signature(call, bound_method=True,
1475                                         type_aliases=self.config.autodoc_type_aliases)
1476                 return type(self.object), '__call__', sig
1477             except ValueError:
1478                 pass
1479 
1480         # Now we check if the 'obj' class has a '__new__' method
1481         new = get_user_defined_function_or_method(self.object, '__new__')
1482 
1483         if new is not None:
1484             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1485                 new = None
1486 
1487         if new is not None:
1488             self.env.app.emit('autodoc-before-process-signature', new, True)
1489             try:
1490                 sig = inspect.signature(new, bound_method=True,
1491                                         type_aliases=self.config.autodoc_type_aliases)
1492                 return self.object, '__new__', sig
1493             except ValueError:
1494                 pass
1495 
1496         # Finally, we should have at least __init__ implemented
1497         init = get_user_defined_function_or_method(self.object, '__init__')
1498         if init is not None:
1499             self.env.app.emit('autodoc-before-process-signature', init, True)
1500             try:
1501                 sig = inspect.signature(init, bound_method=True,
1502                                         type_aliases=self.config.autodoc_type_aliases)
1503                 return self.object, '__init__', sig
1504             except ValueError:
1505                 pass
1506 
1507         # None of the attributes are user-defined, so fall back to let inspect
1508         # handle it.
1509         # We don't know the exact method that inspect.signature will read
1510         # the signature from, so just pass the object itself to our hook.
1511         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1512         try:
1513             sig = inspect.signature(self.object, bound_method=False,
1514                                     type_aliases=self.config.autodoc_type_aliases)
1515             return None, None, sig
1516         except ValueError:
1517             pass
1518 
1519         # Still no signature: happens e.g. for old-style classes
1520         # with __init__ in C and no `__text_signature__`.
1521         return None, None, None
1522 
1523     def format_args(self, **kwargs: Any) -> str:
1524         if self.config.autodoc_typehints in ('none', 'description'):
1525             kwargs.setdefault('show_annotation', False)
1526 
1527         try:
1528             self._signature_class, self._signature_method_name, sig = self._get_signature()
1529         except TypeError as exc:
1530             # __signature__ attribute contained junk
1531             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1532                            self.fullname, exc)
1533             return None
1534 
1535         if sig is None:
1536             return None
1537 
1538         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1539 
1540     def format_signature(self, **kwargs: Any) -> str:
1541         if self.doc_as_attr:
1542             return ''
1543 
1544         sig = super().format_signature()
1545         sigs = []
1546 
1547         overloads = self.get_overloaded_signatures()
1548         if overloads and self.config.autodoc_typehints == 'signature':
1549             # Use signatures for overloaded methods instead of the implementation method.
1550             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1551             __globals__ = safe_getattr(method, '__globals__', {})
1552             for overload in overloads:
1553                 overload = evaluate_signature(overload, __globals__,
1554                                               self.config.autodoc_type_aliases)
1555 
1556                 parameters = list(overload.parameters.values())
1557                 overload = overload.replace(parameters=parameters[1:],
1558                                             return_annotation=Parameter.empty)
1559                 sig = stringify_signature(overload, **kwargs)
1560                 sigs.append(sig)
1561         else:
1562             sigs.append(sig)
1563 
1564         return "\n".join(sigs)
1565 
1566     def get_overloaded_signatures(self) -> List[Signature]:
1567         if self._signature_class and self._signature_method_name:
1568             for cls in self._signature_class.__mro__:
1569                 try:
1570                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1571                     analyzer.analyze()
1572                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1573                     if qualname in analyzer.overloads:
1574                         return analyzer.overloads.get(qualname)
1575                     elif qualname in analyzer.tagorder:
1576                         # the constructor is defined in the class, but not overrided.
1577                         return []
1578                 except PycodeError:
1579                     pass
1580 
1581         return []
1582 
1583     def get_canonical_fullname(self) -> Optional[str]:
1584         __modname__ = safe_getattr(self.object, '__module__', self.modname)
1585         __qualname__ = safe_getattr(self.object, '__qualname__', None)
1586         if __qualname__ is None:
1587             __qualname__ = safe_getattr(self.object, '__name__', None)
1588         if __qualname__ and '<locals>' in __qualname__:
1589             # No valid qualname found if the object is defined as locals
1590             __qualname__ = None
1591 
1592         if __modname__ and __qualname__:
1593             return '.'.join([__modname__, __qualname__])
1594         else:
1595             return None
1596 
1597     def add_directive_header(self, sig: str) -> None:
1598         sourcename = self.get_sourcename()
1599 
1600         if self.doc_as_attr:
1601             self.directivetype = 'attribute'
1602         super().add_directive_header(sig)
1603 
1604         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1605             self.add_line('   :final:', sourcename)
1606 
1607         canonical_fullname = self.get_canonical_fullname()
1608         if not self.doc_as_attr and canonical_fullname and self.fullname != canonical_fullname:
1609             self.add_line('   :canonical: %s' % canonical_fullname, sourcename)
1610 
1611         # add inheritance info, if wanted
1612         if not self.doc_as_attr and self.options.show_inheritance:
1613             sourcename = self.get_sourcename()
1614             self.add_line('', sourcename)
1615 
1616             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1617                 # A subclass of generic types
1618                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1619                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1620                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1621             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1622                 # A normal class
1623                 bases = [restify(cls) for cls in self.object.__bases__]
1624                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1625 
1626     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1627         members = get_class_members(self.object, self.objpath, self.get_attr)
1628         if not want_all:
1629             if not self.options.members:
1630                 return False, []  # type: ignore
1631             # specific members given
1632             selected = []
1633             for name in self.options.members:  # type: str
1634                 if name in members:
1635                     selected.append(members[name])
1636                 else:
1637                     logger.warning(__('missing attribute %s in object %s') %
1638                                    (name, self.fullname), type='autodoc')
1639             return False, selected
1640         elif self.options.inherited_members:
1641             return False, list(members.values())
1642         else:
1643             return False, [m for m in members.values() if m.class_ == self.object]
1644 
1645     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1646         if self.doc_as_attr:
1647             # Don't show the docstring of the class when it is an alias.
1648             return None
1649 
1650         lines = getattr(self, '_new_docstrings', None)
1651         if lines is not None:
1652             return lines
1653 
1654         content = self.config.autoclass_content
1655 
1656         docstrings = []
1657         attrdocstring = self.get_attr(self.object, '__doc__', None)
1658         if attrdocstring:
1659             docstrings.append(attrdocstring)
1660 
1661         # for classes, what the "docstring" is can be controlled via a
1662         # config value; the default is only the class docstring
1663         if content in ('both', 'init'):
1664             __init__ = self.get_attr(self.object, '__init__', None)
1665             initdocstring = getdoc(__init__, self.get_attr,
1666                                    self.config.autodoc_inherit_docstrings,
1667                                    self.parent, self.object_name)
1668             # for new-style classes, no __init__ means default __init__
1669             if (initdocstring is not None and
1670                 (initdocstring == object.__init__.__doc__ or  # for pypy
1671                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1672                 initdocstring = None
1673             if not initdocstring:
1674                 # try __new__
1675                 __new__ = self.get_attr(self.object, '__new__', None)
1676                 initdocstring = getdoc(__new__, self.get_attr,
1677                                        self.config.autodoc_inherit_docstrings,
1678                                        self.parent, self.object_name)
1679                 # for new-style classes, no __new__ means default __new__
1680                 if (initdocstring is not None and
1681                     (initdocstring == object.__new__.__doc__ or  # for pypy
1682                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1683                     initdocstring = None
1684             if initdocstring:
1685                 if content == 'init':
1686                     docstrings = [initdocstring]
1687                 else:
1688                     docstrings.append(initdocstring)
1689 
1690         tab_width = self.directive.state.document.settings.tab_width
1691         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1692 
1693     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1694                     ) -> None:
1695         if self.doc_as_attr:
1696             try:
1697                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1698             except AttributeError:
1699                 pass  # Invalid class object is passed.
1700 
1701         super().add_content(more_content)
1702 
1703     def document_members(self, all_members: bool = False) -> None:
1704         if self.doc_as_attr:
1705             return
1706         super().document_members(all_members)
1707 
1708     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1709                  check_module: bool = False, all_members: bool = False) -> None:
1710         # Do not pass real_modname and use the name from the __module__
1711         # attribute of the class.
1712         # If a class gets imported into the module real_modname
1713         # the analyzer won't find the source of the class, if
1714         # it looks in real_modname.
1715         return super().generate(more_content=more_content,
1716                                 check_module=check_module,
1717                                 all_members=all_members)
1718 
1719 
1720 class ExceptionDocumenter(ClassDocumenter):
1721     """
1722     Specialized ClassDocumenter subclass for exceptions.
1723     """
1724     objtype = 'exception'
1725     member_order = 10
1726 
1727     # needs a higher priority than ClassDocumenter
1728     priority = 10
1729 
1730     @classmethod
1731     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1732                             ) -> bool:
1733         return isinstance(member, type) and issubclass(member, BaseException)
1734 
1735 
1736 class DataDocumenterMixinBase:
1737     # define types of instance variables
1738     config: Config = None
1739     env: BuildEnvironment = None
1740     modname: str = None
1741     parent: Any = None
1742     object: Any = None
1743     objpath: List[str] = None
1744 
1745     def should_suppress_directive_header(self) -> bool:
1746         """Check directive header should be suppressed."""
1747         return False
1748 
1749     def should_suppress_value_header(self) -> bool:
1750         """Check :value: header should be suppressed."""
1751         return False
1752 
1753     def update_content(self, more_content: StringList) -> None:
1754         """Update docstring for the NewType object."""
1755         pass
1756 
1757 
1758 class GenericAliasMixin(DataDocumenterMixinBase):
1759     """
1760     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1761     supporting GenericAliases.
1762     """
1763 
1764     def should_suppress_directive_header(self) -> bool:
1765         return (inspect.isgenericalias(self.object) or
1766                 super().should_suppress_directive_header())
1767 
1768     def update_content(self, more_content: StringList) -> None:
1769         if inspect.isgenericalias(self.object):
1770             alias = stringify_typehint(self.object)
1771             more_content.append(_('alias of %s') % alias, '')
1772             more_content.append('', '')
1773 
1774         super().update_content(more_content)
1775 
1776 
1777 class NewTypeMixin(DataDocumenterMixinBase):
1778     """
1779     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1780     supporting NewTypes.
1781     """
1782 
1783     def should_suppress_directive_header(self) -> bool:
1784         return (inspect.isNewType(self.object) or
1785                 super().should_suppress_directive_header())
1786 
1787     def update_content(self, more_content: StringList) -> None:
1788         if inspect.isNewType(self.object):
1789             supertype = restify(self.object.__supertype__)
1790             more_content.append(_('alias of %s') % supertype, '')
1791             more_content.append('', '')
1792 
1793         super().update_content(more_content)
1794 
1795 
1796 class TypeVarMixin(DataDocumenterMixinBase):
1797     """
1798     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1799     supporting TypeVars.
1800     """
1801 
1802     def should_suppress_directive_header(self) -> bool:
1803         return (isinstance(self.object, TypeVar) or
1804                 super().should_suppress_directive_header())
1805 
1806     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1807         if ignore is not None:
1808             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1809                           % self.__class__.__name__,
1810                           RemovedInSphinx50Warning, stacklevel=2)
1811 
1812         if isinstance(self.object, TypeVar):
1813             if self.object.__doc__ != TypeVar.__doc__:
1814                 return super().get_doc()  # type: ignore
1815             else:
1816                 return []
1817         else:
1818             return super().get_doc()  # type: ignore
1819 
1820     def update_content(self, more_content: StringList) -> None:
1821         if isinstance(self.object, TypeVar):
1822             attrs = [repr(self.object.__name__)]
1823             for constraint in self.object.__constraints__:
1824                 attrs.append(stringify_typehint(constraint))
1825             if self.object.__bound__:
1826                 attrs.append(r"bound=\ " + restify(self.object.__bound__))
1827             if self.object.__covariant__:
1828                 attrs.append("covariant=True")
1829             if self.object.__contravariant__:
1830                 attrs.append("contravariant=True")
1831 
1832             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1833             more_content.append('', '')
1834 
1835         super().update_content(more_content)
1836 
1837 
1838 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1839     """
1840     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1841     (type annotation only) global variables.
1842     """
1843 
1844     def import_object(self, raiseerror: bool = False) -> bool:
1845         try:
1846             return super().import_object(raiseerror=True)  # type: ignore
1847         except ImportError as exc:
1848             # annotation only instance variable (PEP-526)
1849             try:
1850                 with mock(self.config.autodoc_mock_imports):
1851                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1852                     annotations = get_type_hints(parent, None,
1853                                                  self.config.autodoc_type_aliases)
1854                     if self.objpath[-1] in annotations:
1855                         self.object = UNINITIALIZED_ATTR
1856                         self.parent = parent
1857                         return True
1858             except ImportError:
1859                 pass
1860 
1861             if raiseerror:
1862                 raise
1863             else:
1864                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1865                 self.env.note_reread()
1866                 return False
1867 
1868     def should_suppress_value_header(self) -> bool:
1869         return (self.object is UNINITIALIZED_ATTR or
1870                 super().should_suppress_value_header())
1871 
1872     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1873         if self.object is UNINITIALIZED_ATTR:
1874             return []
1875         else:
1876             return super().get_doc(ignore)  # type: ignore
1877 
1878 
1879 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1880                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1881     """
1882     Specialized Documenter subclass for data items.
1883     """
1884     objtype = 'data'
1885     member_order = 40
1886     priority = -10
1887     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)
1888     option_spec["annotation"] = annotation_option
1889     option_spec["no-value"] = bool_option
1890 
1891     @classmethod
1892     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1893                             ) -> bool:
1894         return isinstance(parent, ModuleDocumenter) and isattr
1895 
1896     def update_annotations(self, parent: Any) -> None:
1897         """Update __annotations__ to support type_comment and so on."""
1898         annotations = dict(inspect.getannotations(parent))
1899         parent.__annotations__ = annotations
1900 
1901         try:
1902             analyzer = ModuleAnalyzer.for_module(self.modname)
1903             analyzer.analyze()
1904             for (classname, attrname), annotation in analyzer.annotations.items():
1905                 if classname == '' and attrname not in annotations:
1906                     annotations[attrname] = annotation
1907         except PycodeError:
1908             pass
1909 
1910     def import_object(self, raiseerror: bool = False) -> bool:
1911         ret = super().import_object(raiseerror)
1912         if self.parent:
1913             self.update_annotations(self.parent)
1914 
1915         return ret
1916 
1917     def should_suppress_value_header(self) -> bool:
1918         if super().should_suppress_value_header():
1919             return True
1920         else:
1921             doc = self.get_doc()
1922             metadata = extract_metadata('\n'.join(sum(doc, [])))
1923             if 'hide-value' in metadata:
1924                 return True
1925 
1926         return False
1927 
1928     def add_directive_header(self, sig: str) -> None:
1929         super().add_directive_header(sig)
1930         sourcename = self.get_sourcename()
1931         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1932             pass
1933         elif self.options.annotation:
1934             self.add_line('   :annotation: %s' % self.options.annotation,
1935                           sourcename)
1936         else:
1937             # obtain annotation for this data
1938             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1939             if self.objpath[-1] in annotations:
1940                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1941                 self.add_line('   :type: ' + objrepr, sourcename)
1942 
1943             try:
1944                 if self.options.no_value or self.should_suppress_value_header():
1945                     pass
1946                 else:
1947                     objrepr = object_description(self.object)
1948                     self.add_line('   :value: ' + objrepr, sourcename)
1949             except ValueError:
1950                 pass
1951 
1952     def document_members(self, all_members: bool = False) -> None:
1953         pass
1954 
1955     def get_real_modname(self) -> str:
1956         return self.get_attr(self.parent or self.object, '__module__', None) \
1957             or self.modname
1958 
1959     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1960         try:
1961             analyzer = ModuleAnalyzer.for_module(self.modname)
1962             analyzer.analyze()
1963             key = ('', attrname)
1964             if key in analyzer.attr_docs:
1965                 return list(analyzer.attr_docs[key])
1966         except PycodeError:
1967             pass
1968 
1969         return None
1970 
1971     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
1972         # Check the variable has a docstring-comment
1973         comment = self.get_module_comment(self.objpath[-1])
1974         if comment:
1975             return [comment]
1976         else:
1977             return super().get_doc(ignore)
1978 
1979     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1980                     ) -> None:
1981         # Disable analyzing variable comment on Documenter.add_content() to control it on
1982         # DataDocumenter.add_content()
1983         self.analyzer = None
1984 
1985         if not more_content:
1986             more_content = StringList()
1987 
1988         self.update_content(more_content)
1989         super().add_content(more_content, no_docstring=no_docstring)
1990 
1991 
1992 class NewTypeDataDocumenter(DataDocumenter):
1993     """
1994     Specialized Documenter subclass for NewTypes.
1995 
1996     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
1997     function object.
1998     """
1999 
2000     objtype = 'newtypedata'
2001     directivetype = 'data'
2002     priority = FunctionDocumenter.priority + 1
2003 
2004     @classmethod
2005     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2006                             ) -> bool:
2007         return inspect.isNewType(member) and isattr
2008 
2009 
2010 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2011     """
2012     Specialized Documenter subclass for methods (normal, static and class).
2013     """
2014     objtype = 'method'
2015     directivetype = 'method'
2016     member_order = 50
2017     priority = 1  # must be more than FunctionDocumenter
2018 
2019     @classmethod
2020     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2021                             ) -> bool:
2022         return inspect.isroutine(member) and \
2023             not isinstance(parent, ModuleDocumenter)
2024 
2025     def import_object(self, raiseerror: bool = False) -> bool:
2026         ret = super().import_object(raiseerror)
2027         if not ret:
2028             return ret
2029 
2030         # to distinguish classmethod/staticmethod
2031         obj = self.parent.__dict__.get(self.object_name)
2032         if obj is None:
2033             obj = self.object
2034 
2035         if (inspect.isclassmethod(obj) or
2036                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2037             # document class and static members before ordinary ones
2038             self.member_order = self.member_order - 1
2039 
2040         return ret
2041 
2042     def format_args(self, **kwargs: Any) -> str:
2043         if self.config.autodoc_typehints in ('none', 'description'):
2044             kwargs.setdefault('show_annotation', False)
2045 
2046         try:
2047             if self.object == object.__init__ and self.parent != object:
2048                 # Classes not having own __init__() method are shown as no arguments.
2049                 #
2050                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2051                 #       But it makes users confused.
2052                 args = '()'
2053             else:
2054                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2055                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2056                     sig = inspect.signature(self.object, bound_method=False,
2057                                             type_aliases=self.config.autodoc_type_aliases)
2058                 else:
2059                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2060                     sig = inspect.signature(self.object, bound_method=True,
2061                                             type_aliases=self.config.autodoc_type_aliases)
2062                 args = stringify_signature(sig, **kwargs)
2063         except TypeError as exc:
2064             logger.warning(__("Failed to get a method signature for %s: %s"),
2065                            self.fullname, exc)
2066             return None
2067         except ValueError:
2068             args = ''
2069 
2070         if self.config.strip_signature_backslash:
2071             # escape backslashes for reST
2072             args = args.replace('\\', '\\\\')
2073         return args
2074 
2075     def add_directive_header(self, sig: str) -> None:
2076         super().add_directive_header(sig)
2077 
2078         sourcename = self.get_sourcename()
2079         obj = self.parent.__dict__.get(self.object_name, self.object)
2080         if inspect.isabstractmethod(obj):
2081             self.add_line('   :abstractmethod:', sourcename)
2082         if inspect.iscoroutinefunction(obj):
2083             self.add_line('   :async:', sourcename)
2084         if inspect.isclassmethod(obj):
2085             self.add_line('   :classmethod:', sourcename)
2086         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2087             self.add_line('   :staticmethod:', sourcename)
2088         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2089             self.add_line('   :final:', sourcename)
2090 
2091     def document_members(self, all_members: bool = False) -> None:
2092         pass
2093 
2094     def format_signature(self, **kwargs: Any) -> str:
2095         sigs = []
2096         if (self.analyzer and
2097                 '.'.join(self.objpath) in self.analyzer.overloads and
2098                 self.config.autodoc_typehints == 'signature'):
2099             # Use signatures for overloaded methods instead of the implementation method.
2100             overloaded = True
2101         else:
2102             overloaded = False
2103             sig = super().format_signature(**kwargs)
2104             sigs.append(sig)
2105 
2106         meth = self.parent.__dict__.get(self.objpath[-1])
2107         if inspect.is_singledispatch_method(meth):
2108             # append signature of singledispatch'ed functions
2109             for typ, func in meth.dispatcher.registry.items():
2110                 if typ is object:
2111                     pass  # default implementation. skipped.
2112                 else:
2113                     self.annotate_to_first_argument(func, typ)
2114 
2115                     documenter = MethodDocumenter(self.directive, '')
2116                     documenter.parent = self.parent
2117                     documenter.object = func
2118                     documenter.objpath = [None]
2119                     sigs.append(documenter.format_signature())
2120         if overloaded:
2121             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2122                 actual = inspect.signature(self.object, bound_method=False,
2123                                            type_aliases=self.config.autodoc_type_aliases)
2124             else:
2125                 actual = inspect.signature(self.object, bound_method=True,
2126                                            type_aliases=self.config.autodoc_type_aliases)
2127 
2128             __globals__ = safe_getattr(self.object, '__globals__', {})
2129             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2130                 overload = self.merge_default_value(actual, overload)
2131                 overload = evaluate_signature(overload, __globals__,
2132                                               self.config.autodoc_type_aliases)
2133 
2134                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2135                                               name=self.object_name):
2136                     parameters = list(overload.parameters.values())
2137                     overload = overload.replace(parameters=parameters[1:])
2138                 sig = stringify_signature(overload, **kwargs)
2139                 sigs.append(sig)
2140 
2141         return "\n".join(sigs)
2142 
2143     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
2144         """Merge default values of actual implementation to the overload variants."""
2145         parameters = list(overload.parameters.values())
2146         for i, param in enumerate(parameters):
2147             actual_param = actual.parameters.get(param.name)
2148             if actual_param and param.default == '...':
2149                 parameters[i] = param.replace(default=actual_param.default)
2150 
2151         return overload.replace(parameters=parameters)
2152 
2153     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2154         """Annotate type hint to the first argument of function if needed."""
2155         try:
2156             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2157         except TypeError as exc:
2158             logger.warning(__("Failed to get a method signature for %s: %s"),
2159                            self.fullname, exc)
2160             return
2161         except ValueError:
2162             return
2163         if len(sig.parameters) == 1:
2164             return
2165 
2166         params = list(sig.parameters.values())
2167         if params[1].annotation is Parameter.empty:
2168             params[1] = params[1].replace(annotation=typ)
2169             try:
2170                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2171             except (AttributeError, TypeError):
2172                 # failed to update signature (ex. built-in or extension types)
2173                 return
2174 
2175 
2176 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2177     """
2178     Mixin for AttributeDocumenter to provide the feature for supporting non
2179     data-descriptors.
2180 
2181     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2182               and :value: header will be suppressed unexpectedly.
2183     """
2184 
2185     def import_object(self, raiseerror: bool = False) -> bool:
2186         ret = super().import_object(raiseerror)  # type: ignore
2187         if ret and not inspect.isattributedescriptor(self.object):
2188             self.non_data_descriptor = True
2189         else:
2190             self.non_data_descriptor = False
2191 
2192         return ret
2193 
2194     def should_suppress_value_header(self) -> bool:
2195         return (not getattr(self, 'non_data_descriptor', False) or
2196                 super().should_suppress_directive_header())
2197 
2198     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2199         if getattr(self, 'non_data_descriptor', False):
2200             # the docstring of non datadescriptor is very probably the wrong thing
2201             # to display
2202             return None
2203         else:
2204             return super().get_doc(ignore)  # type: ignore
2205 
2206 
2207 class SlotsMixin(DataDocumenterMixinBase):
2208     """
2209     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2210     """
2211 
2212     def isslotsattribute(self) -> bool:
2213         """Check the subject is an attribute in __slots__."""
2214         try:
2215             __slots__ = inspect.getslots(self.parent)
2216             if __slots__ and self.objpath[-1] in __slots__:
2217                 return True
2218             else:
2219                 return False
2220         except (ValueError, TypeError):
2221             return False
2222 
2223     def import_object(self, raiseerror: bool = False) -> bool:
2224         ret = super().import_object(raiseerror)  # type: ignore
2225         if self.isslotsattribute():
2226             self.object = SLOTSATTR
2227 
2228         return ret
2229 
2230     def should_suppress_directive_header(self) -> bool:
2231         if self.object is SLOTSATTR:
2232             self._datadescriptor = True
2233             return True
2234         else:
2235             return super().should_suppress_directive_header()
2236 
2237     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2238         if self.object is SLOTSATTR:
2239             try:
2240                 __slots__ = inspect.getslots(self.parent)
2241                 if __slots__ and __slots__.get(self.objpath[-1]):
2242                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2243                     return [docstring]
2244                 else:
2245                     return []
2246             except ValueError as exc:
2247                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2248                                (self.parent.__qualname__, exc), type='autodoc')
2249                 return []
2250         else:
2251             return super().get_doc(ignore)  # type: ignore
2252 
2253 
2254 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2255     """
2256     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2257     instance attributes (that are defined in __init__() methods with doc-comments).
2258 
2259     Example:
2260 
2261         class Foo:
2262             def __init__(self):
2263                 self.attr = None  #: This is a target of this mix-in.
2264     """
2265 
2266     RUNTIME_INSTANCE_ATTRIBUTE = object()
2267 
2268     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2269         """Check the subject is an attribute defined in __init__()."""
2270         # An instance variable defined in __init__().
2271         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2272             return True
2273         else:
2274             return False
2275 
2276     def import_object(self, raiseerror: bool = False) -> bool:
2277         """Check the existence of runtime instance attribute when failed to import the
2278         attribute."""
2279         try:
2280             return super().import_object(raiseerror=True)  # type: ignore
2281         except ImportError as exc:
2282             try:
2283                 with mock(self.config.autodoc_mock_imports):
2284                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2285                                         attrgetter=self.get_attr,  # type: ignore
2286                                         warningiserror=self.config.autodoc_warningiserror)
2287                     parent = ret[3]
2288                     if self.is_runtime_instance_attribute(parent):
2289                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2290                         self.parent = parent
2291                         return True
2292             except ImportError:
2293                 pass
2294 
2295             if raiseerror:
2296                 raise
2297             else:
2298                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2299                 self.env.note_reread()
2300                 return False
2301 
2302     def should_suppress_value_header(self) -> bool:
2303         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2304                 super().should_suppress_value_header())
2305 
2306 
2307 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2308     """
2309     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2310     instance attributes (PEP-526 styled, annotation only attributes).
2311 
2312     Example:
2313 
2314         class Foo:
2315             attr: int  #: This is a target of this mix-in.
2316     """
2317 
2318     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2319         """Check the subject is an annotation only attribute."""
2320         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2321         if self.objpath[-1] in annotations:
2322             return True
2323         else:
2324             return False
2325 
2326     def import_object(self, raiseerror: bool = False) -> bool:
2327         """Check the exisitence of uninitialized instance attribute when failed to import
2328         the attribute."""
2329         try:
2330             return super().import_object(raiseerror=True)  # type: ignore
2331         except ImportError as exc:
2332             try:
2333                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2334                                     attrgetter=self.get_attr,  # type: ignore
2335                                     warningiserror=self.config.autodoc_warningiserror)
2336                 parent = ret[3]
2337                 if self.is_uninitialized_instance_attribute(parent):
2338                     self.object = UNINITIALIZED_ATTR
2339                     self.parent = parent
2340                     return True
2341             except ImportError:
2342                 pass
2343 
2344             if raiseerror:
2345                 raise
2346             else:
2347                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2348                 self.env.note_reread()
2349                 return False
2350 
2351     def should_suppress_value_header(self) -> bool:
2352         return (self.object is UNINITIALIZED_ATTR or
2353                 super().should_suppress_value_header())
2354 
2355     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2356         if self.object is UNINITIALIZED_ATTR:
2357             return None
2358         else:
2359             return super().get_doc(ignore)  # type: ignore
2360 
2361 
2362 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2363                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2364                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2365                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2366     """
2367     Specialized Documenter subclass for attributes.
2368     """
2369     objtype = 'attribute'
2370     member_order = 60
2371     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)
2372     option_spec["annotation"] = annotation_option
2373     option_spec["no-value"] = bool_option
2374 
2375     # must be higher than the MethodDocumenter, else it will recognize
2376     # some non-data descriptors as methods
2377     priority = 10
2378 
2379     @staticmethod
2380     def is_function_or_method(obj: Any) -> bool:
2381         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2382 
2383     @classmethod
2384     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2385                             ) -> bool:
2386         if inspect.isattributedescriptor(member):
2387             return True
2388         elif (not isinstance(parent, ModuleDocumenter) and
2389               not inspect.isroutine(member) and
2390               not isinstance(member, type)):
2391             return True
2392         else:
2393             return False
2394 
2395     def document_members(self, all_members: bool = False) -> None:
2396         pass
2397 
2398     def isinstanceattribute(self) -> bool:
2399         """Check the subject is an instance attribute."""
2400         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2401                       RemovedInSphinx50Warning)
2402         # uninitialized instance variable (PEP-526)
2403         with mock(self.config.autodoc_mock_imports):
2404             try:
2405                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2406                                     attrgetter=self.get_attr,
2407                                     warningiserror=self.config.autodoc_warningiserror)
2408                 self.parent = ret[3]
2409                 annotations = get_type_hints(self.parent, None,
2410                                              self.config.autodoc_type_aliases)
2411                 if self.objpath[-1] in annotations:
2412                     self.object = UNINITIALIZED_ATTR
2413                     return True
2414             except ImportError:
2415                 pass
2416 
2417         return False
2418 
2419     def update_annotations(self, parent: Any) -> None:
2420         """Update __annotations__ to support type_comment and so on."""
2421         try:
2422             annotations = dict(inspect.getannotations(parent))
2423             parent.__annotations__ = annotations
2424 
2425             for cls in inspect.getmro(parent):
2426                 try:
2427                     module = safe_getattr(cls, '__module__')
2428                     qualname = safe_getattr(cls, '__qualname__')
2429 
2430                     analyzer = ModuleAnalyzer.for_module(module)
2431                     analyzer.analyze()
2432                     for (classname, attrname), annotation in analyzer.annotations.items():
2433                         if classname == qualname and attrname not in annotations:
2434                             annotations[attrname] = annotation
2435                 except (AttributeError, PycodeError):
2436                     pass
2437         except (AttributeError, TypeError):
2438             # Failed to set __annotations__ (built-in, extensions, etc.)
2439             pass
2440 
2441     def import_object(self, raiseerror: bool = False) -> bool:
2442         ret = super().import_object(raiseerror)
2443         if inspect.isenumattribute(self.object):
2444             self.object = self.object.value
2445         if self.parent:
2446             self.update_annotations(self.parent)
2447 
2448         return ret
2449 
2450     def get_real_modname(self) -> str:
2451         return self.get_attr(self.parent or self.object, '__module__', None) \
2452             or self.modname
2453 
2454     def should_suppress_value_header(self) -> bool:
2455         if super().should_suppress_value_header():
2456             return True
2457         else:
2458             doc = self.get_doc()
2459             if doc:
2460                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2461                 if 'hide-value' in metadata:
2462                     return True
2463 
2464         return False
2465 
2466     def add_directive_header(self, sig: str) -> None:
2467         super().add_directive_header(sig)
2468         sourcename = self.get_sourcename()
2469         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2470             pass
2471         elif self.options.annotation:
2472             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2473         else:
2474             # obtain type annotation for this attribute
2475             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2476             if self.objpath[-1] in annotations:
2477                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2478                 self.add_line('   :type: ' + objrepr, sourcename)
2479 
2480             try:
2481                 if self.options.no_value or self.should_suppress_value_header():
2482                     pass
2483                 else:
2484                     objrepr = object_description(self.object)
2485                     self.add_line('   :value: ' + objrepr, sourcename)
2486             except ValueError:
2487                 pass
2488 
2489     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2490         for cls in inspect.getmro(parent):
2491             try:
2492                 module = safe_getattr(cls, '__module__')
2493                 qualname = safe_getattr(cls, '__qualname__')
2494 
2495                 analyzer = ModuleAnalyzer.for_module(module)
2496                 analyzer.analyze()
2497                 if qualname and self.objpath:
2498                     key = (qualname, attrname)
2499                     if key in analyzer.attr_docs:
2500                         return list(analyzer.attr_docs[key])
2501             except (AttributeError, PycodeError):
2502                 pass
2503 
2504         return None
2505 
2506     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:
2507         # Check the attribute has a docstring-comment
2508         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2509         if comment:
2510             return [comment]
2511 
2512         try:
2513             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2514             # a docstring from the value which descriptor returns unexpectedly.
2515             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2516             orig = self.config.autodoc_inherit_docstrings
2517             self.config.autodoc_inherit_docstrings = False  # type: ignore
2518             return super().get_doc(ignore)
2519         finally:
2520             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2521 
2522     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2523                     ) -> None:
2524         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2525         # AttributeDocumenter.add_content()
2526         self.analyzer = None
2527 
2528         if more_content is None:
2529             more_content = StringList()
2530         self.update_content(more_content)
2531         super().add_content(more_content, no_docstring)
2532 
2533 
2534 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2535     """
2536     Specialized Documenter subclass for properties.
2537     """
2538     objtype = 'property'
2539     member_order = 60
2540 
2541     # before AttributeDocumenter
2542     priority = AttributeDocumenter.priority + 1
2543 
2544     @classmethod
2545     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2546                             ) -> bool:
2547         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2548 
2549     def document_members(self, all_members: bool = False) -> None:
2550         pass
2551 
2552     def get_real_modname(self) -> str:
2553         return self.get_attr(self.parent or self.object, '__module__', None) \
2554             or self.modname
2555 
2556     def add_directive_header(self, sig: str) -> None:
2557         super().add_directive_header(sig)
2558         sourcename = self.get_sourcename()
2559         if inspect.isabstractmethod(self.object):
2560             self.add_line('   :abstractmethod:', sourcename)
2561 
2562         if safe_getattr(self.object, 'fget', None):
2563             try:
2564                 signature = inspect.signature(self.object.fget,
2565                                               type_aliases=self.config.autodoc_type_aliases)
2566                 if signature.return_annotation is not Parameter.empty:
2567                     objrepr = stringify_typehint(signature.return_annotation)
2568                     self.add_line('   :type: ' + objrepr, sourcename)
2569             except TypeError as exc:
2570                 logger.warning(__("Failed to get a function signature for %s: %s"),
2571                                self.fullname, exc)
2572                 return None
2573             except ValueError:
2574                 raise
2575 
2576 
2577 class NewTypeAttributeDocumenter(AttributeDocumenter):
2578     """
2579     Specialized Documenter subclass for NewTypes.
2580 
2581     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2582     function object.
2583     """
2584 
2585     objtype = 'newvarattribute'
2586     directivetype = 'attribute'
2587     priority = MethodDocumenter.priority + 1
2588 
2589     @classmethod
2590     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2591                             ) -> bool:
2592         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2593 
2594 
2595 def get_documenters(app: Sphinx) -> Dict[str, Type[Documenter]]:
2596     """Returns registered Documenter classes"""
2597     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2598     return app.registry.documenters
2599 
2600 
2601 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2602     """Alternative getattr() for types"""
2603     for typ, func in app.registry.autodoc_attrgettrs.items():
2604         if isinstance(obj, typ):
2605             return func(obj, name, *defargs)
2606 
2607     return safe_getattr(obj, name, *defargs)
2608 
2609 
2610 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2611     if config.autodoc_member_order == 'alphabetic':
2612         # RemovedInSphinx50Warning
2613         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2614                           'instead of "alphabetic". Please update your setting.'))
2615         config.autodoc_member_order = 'alphabetical'  # type: ignore
2616 
2617 
2618 # for compatibility
2619 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2620 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2621 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2622 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2623 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2624 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2625 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2626 
2627 
2628 def setup(app: Sphinx) -> Dict[str, Any]:
2629     app.add_autodocumenter(ModuleDocumenter)
2630     app.add_autodocumenter(ClassDocumenter)
2631     app.add_autodocumenter(ExceptionDocumenter)
2632     app.add_autodocumenter(DataDocumenter)
2633     app.add_autodocumenter(NewTypeDataDocumenter)
2634     app.add_autodocumenter(FunctionDocumenter)
2635     app.add_autodocumenter(DecoratorDocumenter)
2636     app.add_autodocumenter(MethodDocumenter)
2637     app.add_autodocumenter(AttributeDocumenter)
2638     app.add_autodocumenter(PropertyDocumenter)
2639     app.add_autodocumenter(NewTypeAttributeDocumenter)
2640 
2641     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2642     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2643                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2644     app.add_config_value('autodoc_default_options', {}, True)
2645     app.add_config_value('autodoc_docstring_signature', True, True)
2646     app.add_config_value('autodoc_mock_imports', [], True)
2647     app.add_config_value('autodoc_typehints', "signature", True,
2648                          ENUM("signature", "description", "none"))
2649     app.add_config_value('autodoc_typehints_description_target', 'all', True,
2650                          ENUM('all', 'documented'))
2651     app.add_config_value('autodoc_type_aliases', {}, True)
2652     app.add_config_value('autodoc_warningiserror', True, True)
2653     app.add_config_value('autodoc_inherit_docstrings', True, True)
2654     app.add_event('autodoc-before-process-signature')
2655     app.add_event('autodoc-process-docstring')
2656     app.add_event('autodoc-process-signature')
2657     app.add_event('autodoc-skip-member')
2658 
2659     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2660 
2661     app.setup_extension('sphinx.ext.autodoc.preserve_defaults')
2662     app.setup_extension('sphinx.ext.autodoc.type_comment')
2663     app.setup_extension('sphinx.ext.autodoc.typehints')
2664 
2665     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>Ensure that automatic documentation generation from docstrings continues to work seamlessly with `docutils-0.17b1`, without introducing any regressions or incompatibilities.</intended_behavior>, <file>sphinx/parsers.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.parsers
3     ~~~~~~~~~~~~~~
4 
5     A Base class for additional parsers.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import warnings
12 from typing import TYPE_CHECKING, Any, Dict, List, Type, Union
13 
14 import docutils.parsers
15 import docutils.parsers.rst
16 from docutils import nodes
17 from docutils.parsers.rst import states
18 from docutils.statemachine import StringList
19 from docutils.transforms import Transform
20 from docutils.transforms.universal import SmartQuotes
21 
22 from sphinx.deprecation import RemovedInSphinx50Warning
23 from sphinx.util.rst import append_epilog, prepend_prolog
24 
25 if TYPE_CHECKING:
26     from sphinx.application import Sphinx
27 
28 
29 class Parser(docutils.parsers.Parser):
30     """
31     A base class of source parsers.  The additional parsers should inherit this class instead
32     of ``docutils.parsers.Parser``.  Compared with ``docutils.parsers.Parser``, this class
33     improves accessibility to Sphinx APIs.
34 
35     The subclasses can access following objects and functions:
36 
37     self.app
38         The application object (:class:`sphinx.application.Sphinx`)
39     self.config
40         The config object (:class:`sphinx.config.Config`)
41     self.env
42         The environment object (:class:`sphinx.environment.BuildEnvironment`)
43     self.warn()
44         Emit a warning. (Same as :meth:`sphinx.application.Sphinx.warn()`)
45     self.info()
46         Emit a informational message. (Same as :meth:`sphinx.application.Sphinx.info()`)
47 
48     .. deprecated:: 1.6
49        ``warn()`` and ``info()`` is deprecated.  Use :mod:`sphinx.util.logging` instead.
50     .. deprecated:: 3.0
51        parser.app is deprecated.
52     """
53 
54     def set_application(self, app: "Sphinx") -> None:
55         """set_application will be called from Sphinx to set app and other instance variables
56 
57         :param sphinx.application.Sphinx app: Sphinx application object
58         """
59         self._app = app
60         self.config = app.config
61         self.env = app.env
62 
63     @property
64     def app(self) -> "Sphinx":
65         warnings.warn('parser.app is deprecated.', RemovedInSphinx50Warning, stacklevel=2)
66         return self._app
67 
68 
69 class RSTParser(docutils.parsers.rst.Parser, Parser):
70     """A reST parser for Sphinx."""
71 
72     def get_transforms(self) -> List[Type[Transform]]:
73         """Sphinx's reST parser replaces a transform class for smart-quotes by own's
74 
75         refs: sphinx.io.SphinxStandaloneReader
76         """
77         transforms = super().get_transforms()
78         transforms.remove(SmartQuotes)
79         return transforms
80 
81     def parse(self, inputstring: Union[str, StringList], document: nodes.document) -> None:
82         """Parse text and generate a document tree."""
83         self.setup_parse(inputstring, document)  # type: ignore
84         self.statemachine = states.RSTStateMachine(
85             state_classes=self.state_classes,
86             initial_state=self.initial_state,
87             debug=document.reporter.debug_flag)
88 
89         # preprocess inputstring
90         if isinstance(inputstring, str):
91             lines = docutils.statemachine.string2lines(
92                 inputstring, tab_width=document.settings.tab_width,
93                 convert_whitespace=True)
94 
95             inputlines = StringList(lines, document.current_source)
96         else:
97             inputlines = inputstring
98 
99         self.decorate(inputlines)
100         self.statemachine.run(inputlines, document, inliner=self.inliner)
101         self.finish_parse()
102 
103     def decorate(self, content: StringList) -> None:
104         """Preprocess reST content before parsing."""
105         prepend_prolog(content, self.config.rst_prolog)
106         append_epilog(content, self.config.rst_epilog)
107 
108 
109 def setup(app: "Sphinx") -> Dict[str, Any]:
110     app.add_source_parser(RSTParser)
111 
112     return {
113         'version': 'builtin',
114         'parallel_read_safe': True,
115         'parallel_write_safe': True,
116     }

</code><intended_behavior>Ensure that all document parsing functionalities maintain their behavior with the newer version of `docutils`. Adjustments may be necessary if `0.17b1` modifies any parsing APIs or behaviors that Sphinx relies upon.</intended_behavior>, <file>sphinx/deprecation.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.deprecation
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx deprecation classes and utilities.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import sys
12 import warnings
13 from importlib import import_module
14 from typing import Any, Dict, Type
15 
16 
17 class RemovedInSphinx40Warning(DeprecationWarning):
18     pass
19 
20 
21 class RemovedInSphinx50Warning(DeprecationWarning):
22     pass
23 
24 
25 class RemovedInSphinx60Warning(PendingDeprecationWarning):
26     pass
27 
28 
29 RemovedInNextVersionWarning = RemovedInSphinx50Warning
30 
31 
32 def deprecated_alias(modname: str, objects: Dict[str, object],
33                      warning: Type[Warning], names: Dict[str, str] = {}) -> None:
34     module = import_module(modname)
35     sys.modules[modname] = _ModuleWrapper(  # type: ignore
36         module, modname, objects, warning, names)
37 
38 
39 class _ModuleWrapper:
40     def __init__(self, module: Any, modname: str,
41                  objects: Dict[str, object],
42                  warning: Type[Warning],
43                  names: Dict[str, str]) -> None:
44         self._module = module
45         self._modname = modname
46         self._objects = objects
47         self._warning = warning
48         self._names = names
49 
50     def __getattr__(self, name: str) -> Any:
51         if name not in self._objects:
52             return getattr(self._module, name)
53 
54         canonical_name = self._names.get(name, None)
55         if canonical_name is not None:
56             warnings.warn(
57                 "The alias '{}.{}' is deprecated, use '{}' instead. Check CHANGES for "
58                 "Sphinx API modifications.".format(self._modname, name, canonical_name),
59                 self._warning, stacklevel=3)
60         else:
61             warnings.warn("{}.{} is deprecated. Check CHANGES for Sphinx "
62                           "API modifications.".format(self._modname, name),
63                           self._warning, stacklevel=3)
64         return self._objects[name]
65 
66 
67 class DeprecatedDict(dict):
68     """A deprecated dict which warns on each access."""
69 
70     def __init__(self, data: Dict, message: str, warning: Type[Warning]) -> None:
71         self.message = message
72         self.warning = warning
73         super().__init__(data)
74 
75     def __setitem__(self, key: str, value: Any) -> None:
76         warnings.warn(self.message, self.warning, stacklevel=2)
77         super().__setitem__(key, value)
78 
79     def setdefault(self, key: str, default: Any = None) -> Any:
80         warnings.warn(self.message, self.warning, stacklevel=2)
81         return super().setdefault(key, default)
82 
83     def __getitem__(self, key: str) -> None:
84         warnings.warn(self.message, self.warning, stacklevel=2)
85         return super().__getitem__(key)
86 
87     def get(self, key: str, default: Any = None) -> Any:
88         warnings.warn(self.message, self.warning, stacklevel=2)
89         return super().get(key, default)
90 
91     def update(self, other: Dict) -> None:  # type: ignore
92         warnings.warn(self.message, self.warning, stacklevel=2)
93         super().update(other)

</code><intended_behavior>Ensure that no deprecated `docutils` APIs are used by Sphinx, or if they are, to update them to the current APIs provided by `docutils-0.17b1`. Shift away from deprecated APIs, ensuring compatibility with new versions.</intended_behavior>]
2025-10-16 00:53:33.455 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:53:33.455 | INFO     | Search-only: skipping patch selection
2025-10-16 00:53:33.586 | INFO     | Task sphinx-doc__sphinx-9053 completed successfully.
2025-10-16 00:53:33.587 | INFO     | No patch generated. You can try running ACR again.
