[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2665,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import re\n14 import warnings\n15 from inspect import Parameter, Signature\n16 from types import ModuleType\n17 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,\n18                     Set, Tuple, Type, TypeVar, Union)\n19 \n20 from docutils.statemachine import StringList\n21 \n22 import sphinx\n23 from sphinx.application import Sphinx\n24 from sphinx.config import ENUM, Config\n25 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning\n26 from sphinx.environment import BuildEnvironment\n27 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,\n28                                          import_object)\n29 from sphinx.ext.autodoc.mock import ismock, mock, undecorate\n30 from sphinx.locale import _, __\n31 from sphinx.pycode import ModuleAnalyzer, PycodeError\n32 from sphinx.util import inspect, logging\n33 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n34 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n35                                  stringify_signature)\n36 from sphinx.util.typing import OptionSpec, get_type_hints, restify\n37 from sphinx.util.typing import stringify as stringify_typehint\n38 \n39 if TYPE_CHECKING:\n40     from sphinx.ext.autodoc.directive import DocumenterBridge\n41 \n42 \n43 logger = logging.getLogger(__name__)\n44 \n45 \n46 # This type isn't exposed directly in any modules, but can be found\n47 # here in most Python versions\n48 MethodDescriptorType = type(type.__subclasses__)\n49 \n50 \n51 #: extended signature RE: with explicit module name separated by ::\n52 py_ext_sig_re = re.compile(\n53     r'''^ ([\\w.]+::)?            # explicit module name\n54           ([\\w.]+\\.)?            # module and/or class name(s)\n55           (\\w+)  \\s*             # thing name\n56           (?: \\((.*)\\)           # optional: arguments\n57            (?:\\s* -> \\s* (.*))?  #           return annotation\n58           )? $                   # and nothing more\n59           ''', re.VERBOSE)\n60 special_member_re = re.compile(r'^__\\S+__$')\n61 \n62 \n63 def identity(x: Any) -> Any:\n64     return x\n65 \n66 \n67 class _All:\n68     \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n69 \n70     def __contains__(self, item: Any) -> bool:\n71         return True\n72 \n73 \n74 class _Empty:\n75     \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n76 \n77     def __contains__(self, item: Any) -> bool:\n78         return False\n79 \n80 \n81 ALL = _All()\n82 EMPTY = _Empty()\n83 UNINITIALIZED_ATTR = object()\n84 INSTANCEATTR = object()\n85 SLOTSATTR = object()\n86 \n87 \n88 def members_option(arg: Any) -> Union[object, List[str]]:\n89     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n90     if arg in (None, True):\n91         return ALL\n92     elif arg is False:\n93         return None\n94     else:\n95         return [x.strip() for x in arg.split(',') if x.strip()]\n96 \n97 \n98 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n99     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n100     warnings.warn(\"members_set_option() is deprecated.\",\n101                   RemovedInSphinx50Warning, stacklevel=2)\n102     if arg is None:\n103         return ALL\n104     return {x.strip() for x in arg.split(',') if x.strip()}\n105 \n106 \n107 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n108     \"\"\"Used to convert the :exclude-members: option.\"\"\"\n109     if arg in (None, True):\n110         return EMPTY\n111     return {x.strip() for x in arg.split(',') if x.strip()}\n112 \n113 \n114 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n115     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n116     if arg in (None, True):\n117         return 'object'\n118     else:\n119         return arg\n120 \n121 \n122 def member_order_option(arg: Any) -> Optional[str]:\n123     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n124     if arg in (None, True):\n125         return None\n126     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n127         return arg\n128     else:\n129         raise ValueError(__('invalid value for member-order option: %s') % arg)\n130 \n131 \n132 SUPPRESS = object()\n133 \n134 \n135 def annotation_option(arg: Any) -> Any:\n136     if arg in (None, True):\n137         # suppress showing the representation of the object\n138         return SUPPRESS\n139     else:\n140         return arg\n141 \n142 \n143 def bool_option(arg: Any) -> bool:\n144     \"\"\"Used to convert flag options to auto directives.  (Instead of\n145     directives.flag(), which returns None).\n146     \"\"\"\n147     return True\n148 \n149 \n150 def merge_special_members_option(options: Dict) -> None:\n151     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n152     warnings.warn(\"merge_special_members_option() is deprecated.\",\n153                   RemovedInSphinx50Warning, stacklevel=2)\n154     if 'special-members' in options and options['special-members'] is not ALL:\n155         if options.get('members') is ALL:\n156             pass\n157         elif options.get('members'):\n158             for member in options['special-members']:\n159                 if member not in options['members']:\n160                     options['members'].append(member)\n161         else:\n162             options['members'] = options['special-members']\n163 \n164 \n165 def merge_members_option(options: Dict) -> None:\n166     \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n167     if options.get('members') is ALL:\n168         # merging is not needed when members: ALL\n169         return\n170 \n171     members = options.setdefault('members', [])\n172     for key in {'private-members', 'special-members'}:\n173         if key in options and options[key] not in (ALL, None):\n174             for member in options[key]:\n175                 if member not in members:\n176                     members.append(member)\n177 \n178 \n179 # Some useful event listener factories for autodoc-process-docstring.\n180 \n181 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n182     \"\"\"Return a listener that removes the first *pre* and last *post*\n183     lines of every docstring.  If *what* is a sequence of strings,\n184     only docstrings of a type in *what* will be processed.\n185 \n186     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n187 \n188        from sphinx.ext.autodoc import cut_lines\n189        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n190 \n191     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n192     \"\"\"\n193     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n194                 ) -> None:\n195         if what and what_ not in what:\n196             return\n197         del lines[:pre]\n198         if post:\n199             # remove one trailing blank line.\n200             if lines and not lines[-1]:\n201                 lines.pop(-1)\n202             del lines[-post:]\n203         # make sure there is a blank line at the end\n204         if lines and lines[-1]:\n205             lines.append('')\n206     return process\n207 \n208 \n209 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n210             exclude: bool = False) -> Callable:\n211     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n212     lines between lines that match the *marker* regular expression.  If no line\n213     matches, the resulting docstring would be empty, so no change will be made\n214     unless *keepempty* is true.\n215 \n216     If *what* is a sequence of strings, only docstrings of a type in *what* will\n217     be processed.\n218     \"\"\"\n219     marker_re = re.compile(marker)\n220 \n221     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n222                 ) -> None:\n223         if what and what_ not in what:\n224             return\n225         deleted = 0\n226         delete = not exclude\n227         orig_lines = lines[:]\n228         for i, line in enumerate(orig_lines):\n229             if delete:\n230                 lines.pop(i - deleted)\n231                 deleted += 1\n232             if marker_re.match(line):\n233                 delete = not delete\n234                 if delete:\n235                     lines.pop(i - deleted)\n236                     deleted += 1\n237         if not lines and not keepempty:\n238             lines[:] = orig_lines\n239         # make sure there is a blank line at the end\n240         if lines and lines[-1]:\n241             lines.append('')\n242     return process\n243 \n244 \n245 # This class is used only in ``sphinx.ext.autodoc.directive``,\n246 # But we define this class here to keep compatibility (see #4538)\n247 class Options(dict):\n248     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n249     def __getattr__(self, name: str) -> Any:\n250         try:\n251             return self[name.replace('_', '-')]\n252         except KeyError:\n253             return None\n254 \n255 \n256 class ObjectMember(tuple):\n257     \"\"\"A member of object.\n258 \n259     This is used for the result of `Documenter.get_object_members()` to\n260     represent each member of the object.\n261 \n262     .. Note::\n263 \n264        An instance of this class behaves as a tuple of (name, object)\n265        for compatibility to old Sphinx.  The behavior will be dropped\n266        in the future.  Therefore extensions should not use the tuple\n267        interface.\n268     \"\"\"\n269 \n270     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n271         return super().__new__(cls, (name, obj))  # type: ignore\n272 \n273     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,\n274                  class_: Any = None, skipped: bool = False) -> None:\n275         self.__name__ = name\n276         self.object = obj\n277         self.docstring = docstring\n278         self.skipped = skipped\n279         self.class_ = class_\n280 \n281 \n282 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n283 \n284 \n285 class Documenter:\n286     \"\"\"\n287     A Documenter knows how to autodocument a single object type.  When\n288     registered with the AutoDirective, it will be used to document objects\n289     of that type when needed by autodoc.\n290 \n291     Its *objtype* attribute selects what auto directive it is assigned to\n292     (the directive name is 'auto' + objtype), and what directive it generates\n293     by default, though that can be overridden by an attribute called\n294     *directivetype*.\n295 \n296     A Documenter has an *option_spec* that works like a docutils directive's;\n297     in fact, it will be used to parse an auto directive's options that matches\n298     the documenter.\n299     \"\"\"\n300     #: name by which the directive is called (auto...) and the default\n301     #: generated directive name\n302     objtype = 'object'\n303     #: indentation by which to indent the directive content\n304     content_indent = '   '\n305     #: priority if multiple documenters return True from can_document_member\n306     priority = 0\n307     #: order if autodoc_member_order is set to 'groupwise'\n308     member_order = 0\n309     #: true if the generated content may contain titles\n310     titles_allowed = False\n311 \n312     option_spec: OptionSpec = {\n313         'noindex': bool_option\n314     }\n315 \n316     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n317         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n318         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n319 \n320     @classmethod\n321     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n322                             ) -> bool:\n323         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n324         raise NotImplementedError('must be implemented in subclasses')\n325 \n326     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n327         self.directive = directive\n328         self.config: Config = directive.env.config\n329         self.env: BuildEnvironment = directive.env\n330         self.options = directive.genopt\n331         self.name = name\n332         self.indent = indent\n333         # the module and object path within the module, and the fully\n334         # qualified name (all set after resolve_name succeeds)\n335         self.modname: str = None\n336         self.module: ModuleType = None\n337         self.objpath: List[str] = None\n338         self.fullname: str = None\n339         # extra signature items (arguments and return annotation,\n340         # also set after resolve_name succeeds)\n341         self.args: str = None\n342         self.retann: str = None\n343         # the object to document (set after import_object succeeds)\n344         self.object: Any = None\n345         self.object_name: str = None\n346         # the parent/owner of the object to document\n347         self.parent: Any = None\n348         # the module analyzer to get at attribute docs, or None\n349         self.analyzer: ModuleAnalyzer = None\n350 \n351     @property\n352     def documenters(self) -> Dict[str, Type[\"Documenter\"]]:\n353         \"\"\"Returns registered Documenter classes\"\"\"\n354         return self.env.app.registry.documenters\n355 \n356     def add_line(self, line: str, source: str, *lineno: int) -> None:\n357         \"\"\"Append one line of generated reST to the output.\"\"\"\n358         if line.strip():  # not a blank line\n359             self.directive.result.append(self.indent + line, source, *lineno)\n360         else:\n361             self.directive.result.append('', source, *lineno)\n362 \n363     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n364                      ) -> Tuple[str, List[str]]:\n365         \"\"\"Resolve the module and name of the object to document given by the\n366         arguments and the current module/class.\n367 \n368         Must return a pair of the module name and a chain of attributes; for\n369         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n370         ``zipfile.ZipFile.open`` method.\n371         \"\"\"\n372         raise NotImplementedError('must be implemented in subclasses')\n373 \n374     def parse_name(self) -> bool:\n375         \"\"\"Determine what module to import and what attribute to document.\n376 \n377         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n378         *self.args* and *self.retann* if parsing and resolving was successful.\n379         \"\"\"\n380         # first, parse the definition -- auto directives for classes and\n381         # functions can contain a signature which is then used instead of\n382         # an autogenerated one\n383         try:\n384             explicit_modname, path, base, args, retann = \\\n385                 py_ext_sig_re.match(self.name).groups()\n386         except AttributeError:\n387             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n388                            type='autodoc')\n389             return False\n390 \n391         # support explicit module and class name separation via ::\n392         if explicit_modname is not None:\n393             modname = explicit_modname[:-2]\n394             parents = path.rstrip('.').split('.') if path else []\n395         else:\n396             modname = None\n397             parents = []\n398 \n399         with mock(self.config.autodoc_mock_imports):\n400             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n401 \n402         if not self.modname:\n403             return False\n404 \n405         self.args = args\n406         self.retann = retann\n407         self.fullname = (self.modname or '') + \\\n408                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n409         return True\n410 \n411     def import_object(self, raiseerror: bool = False) -> bool:\n412         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n413         it as *self.object*.\n414 \n415         Returns True if successful, False if an error occurred.\n416         \"\"\"\n417         with mock(self.config.autodoc_mock_imports):\n418             try:\n419                 ret = import_object(self.modname, self.objpath, self.objtype,\n420                                     attrgetter=self.get_attr,\n421                                     warningiserror=self.config.autodoc_warningiserror)\n422                 self.module, self.parent, self.object_name, self.object = ret\n423                 if ismock(self.object):\n424                     self.object = undecorate(self.object)\n425                 return True\n426             except ImportError as exc:\n427                 if raiseerror:\n428                     raise\n429                 else:\n430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n431                     self.env.note_reread()\n432                     return False\n433 \n434     def get_real_modname(self) -> str:\n435         \"\"\"Get the real module name of an object to document.\n436 \n437         It can differ from the name of the module through which the object was\n438         imported.\n439         \"\"\"\n440         return self.get_attr(self.object, '__module__', None) or self.modname\n441 \n442     def check_module(self) -> bool:\n443         \"\"\"Check if *self.object* is really defined in the module given by\n444         *self.modname*.\n445         \"\"\"\n446         if self.options.imported_members:\n447             return True\n448 \n449         subject = inspect.unpartial(self.object)\n450         modname = self.get_attr(subject, '__module__', None)\n451         if modname and modname != self.modname:\n452             return False\n453         return True\n454 \n455     def format_args(self, **kwargs: Any) -> str:\n456         \"\"\"Format the argument signature of *self.object*.\n457 \n458         Should return None if the object does not have a signature.\n459         \"\"\"\n460         return None\n461 \n462     def format_name(self) -> str:\n463         \"\"\"Format the name of *self.object*.\n464 \n465         This normally should be something that can be parsed by the generated\n466         directive, but doesn't need to be (Sphinx will display it unparsed\n467         then).\n468         \"\"\"\n469         # normally the name doesn't contain the module (except for module\n470         # directives of course)\n471         return '.'.join(self.objpath) or self.modname\n472 \n473     def _call_format_args(self, **kwargs: Any) -> str:\n474         if kwargs:\n475             try:\n476                 return self.format_args(**kwargs)\n477             except TypeError:\n478                 # avoid chaining exceptions, by putting nothing here\n479                 pass\n480 \n481         # retry without arguments for old documenters\n482         return self.format_args()\n483 \n484     def format_signature(self, **kwargs: Any) -> str:\n485         \"\"\"Format the signature (arguments and return annotation) of the object.\n486 \n487         Let the user process it via the ``autodoc-process-signature`` event.\n488         \"\"\"\n489         if self.args is not None:\n490             # signature given explicitly\n491             args = \"(%s)\" % self.args\n492             retann = self.retann\n493         else:\n494             # try to introspect the signature\n495             try:\n496                 retann = None\n497                 args = self._call_format_args(**kwargs)\n498                 if args:\n499                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n500                     if matched:\n501                         args = matched.group(1)\n502                         retann = matched.group(2)\n503             except Exception as exc:\n504                 logger.warning(__('error while formatting arguments for %s: %s'),\n505                                self.fullname, exc, type='autodoc')\n506                 args = None\n507 \n508         result = self.env.events.emit_firstresult('autodoc-process-signature',\n509                                                   self.objtype, self.fullname,\n510                                                   self.object, self.options, args, retann)\n511         if result:\n512             args, retann = result\n513 \n514         if args is not None:\n515             return args + ((' -> %s' % retann) if retann else '')\n516         else:\n517             return ''\n518 \n519     def add_directive_header(self, sig: str) -> None:\n520         \"\"\"Add the directive header and options to the generated content.\"\"\"\n521         domain = getattr(self, 'domain', 'py')\n522         directive = getattr(self, 'directivetype', self.objtype)\n523         name = self.format_name()\n524         sourcename = self.get_sourcename()\n525 \n526         # one signature per line, indented by column\n527         prefix = '.. %s:%s:: ' % (domain, directive)\n528         for i, sig_line in enumerate(sig.split(\"\\n\")):\n529             self.add_line('%s%s%s' % (prefix, name, sig_line),\n530                           sourcename)\n531             if i == 0:\n532                 prefix = \" \" * len(prefix)\n533 \n534         if self.options.noindex:\n535             self.add_line('   :noindex:', sourcename)\n536         if self.objpath:\n537             # Be explicit about the module, this is necessary since .. class::\n538             # etc. don't support a prepended module name\n539             self.add_line('   :module: %s' % self.modname, sourcename)\n540 \n541     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n542         \"\"\"Decode and return lines of the docstring(s) for the object.\n543 \n544         When it returns None value, autodoc-process-docstring will not be called for this\n545         object.\n546         \"\"\"\n547         if ignore is not None:\n548             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n549                           % self.__class__.__name__,\n550                           RemovedInSphinx50Warning, stacklevel=2)\n551         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n552                            self.parent, self.object_name)\n553         if docstring:\n554             tab_width = self.directive.state.document.settings.tab_width\n555             return [prepare_docstring(docstring, ignore, tab_width)]\n556         return []\n557 \n558     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n559         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n560         for docstringlines in docstrings:\n561             if self.env.app:\n562                 # let extensions preprocess docstrings\n563                 self.env.app.emit('autodoc-process-docstring',\n564                                   self.objtype, self.fullname, self.object,\n565                                   self.options, docstringlines)\n566 \n567                 if docstringlines and docstringlines[-1] != '':\n568                     # append a blank line to the end of the docstring\n569                     docstringlines.append('')\n570 \n571             yield from docstringlines\n572 \n573     def get_sourcename(self) -> str:\n574         if (getattr(self.object, '__module__', None) and\n575                 getattr(self.object, '__qualname__', None)):\n576             # Get the correct location of docstring from self.object\n577             # to support inherited methods\n578             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n579         else:\n580             fullname = self.fullname\n581 \n582         if self.analyzer:\n583             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n584         else:\n585             return 'docstring of %s' % fullname\n586 \n587     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n588                     ) -> None:\n589         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n590         if no_docstring:\n591             warnings.warn(\"The 'no_docstring' argument to %s.add_content() is deprecated.\"\n592                           % self.__class__.__name__,\n593                           RemovedInSphinx50Warning, stacklevel=2)\n594 \n595         # set sourcename and add content from attribute documentation\n596         sourcename = self.get_sourcename()\n597         if self.analyzer:\n598             attr_docs = self.analyzer.find_attr_docs()\n599             if self.objpath:\n600                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n601                 if key in attr_docs:\n602                     no_docstring = True\n603                     # make a copy of docstring for attributes to avoid cache\n604                     # the change of autodoc-process-docstring event.\n605                     docstrings = [list(attr_docs[key])]\n606 \n607                     for i, line in enumerate(self.process_doc(docstrings)):\n608                         self.add_line(line, sourcename, i)\n609 \n610         # add content from docstrings\n611         if not no_docstring:\n612             docstrings = self.get_doc()\n613             if docstrings is None:\n614                 # Do not call autodoc-process-docstring on get_doc() returns None.\n615                 pass\n616             else:\n617                 if not docstrings:\n618                     # append at least a dummy docstring, so that the event\n619                     # autodoc-process-docstring is fired and can add some\n620                     # content if desired\n621                     docstrings.append([])\n622                 for i, line in enumerate(self.process_doc(docstrings)):\n623                     self.add_line(line, sourcename, i)\n624 \n625         # add additional content (e.g. from document), if present\n626         if more_content:\n627             for line, src in zip(more_content.data, more_content.items):\n628                 self.add_line(line, src[0], src[1])\n629 \n630     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n631         \"\"\"Return `(members_check_module, members)` where `members` is a\n632         list of `(membername, member)` pairs of the members of *self.object*.\n633 \n634         If *want_all* is True, return all members.  Else, only return those\n635         members given by *self.options.members* (which may also be none).\n636         \"\"\"\n637         warnings.warn('The implementation of Documenter.get_object_members() will be '\n638                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)\n639         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n640         if not want_all:\n641             if not self.options.members:\n642                 return False, []  # type: ignore\n643             # specific members given\n644             selected = []\n645             for name in self.options.members:  # type: str\n646                 if name in members:\n647                     selected.append((name, members[name].value))\n648                 else:\n649                     logger.warning(__('missing attribute %s in object %s') %\n650                                    (name, self.fullname), type='autodoc')\n651             return False, selected\n652         elif self.options.inherited_members:\n653             return False, [(m.name, m.value) for m in members.values()]\n654         else:\n655             return False, [(m.name, m.value) for m in members.values()\n656                            if m.directly_defined]\n657 \n658     def filter_members(self, members: ObjectMembers, want_all: bool\n659                        ) -> List[Tuple[str, Any, bool]]:\n660         \"\"\"Filter the given member list.\n661 \n662         Members are skipped if\n663 \n664         - they are private (except if given explicitly or the private-members\n665           option is set)\n666         - they are special methods (except if given explicitly or the\n667           special-members option is set)\n668         - they are undocumented (except if the undoc-members option is set)\n669 \n670         The user can override the skipping decision by connecting to the\n671         ``autodoc-skip-member`` event.\n672         \"\"\"\n673         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n674             if inspect.isclass(self.object):\n675                 for cls in self.object.__mro__:\n676                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n677                         # given member is a member of specified *super class*\n678                         return True\n679                     elif name in cls.__dict__:\n680                         return False\n681                     elif name in self.get_attr(cls, '__annotations__', {}):\n682                         return False\n683                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n684                         return False\n685 \n686             return False\n687 \n688         ret = []\n689 \n690         # search for members in source code too\n691         namespace = '.'.join(self.objpath)  # will be empty for modules\n692 \n693         if self.analyzer:\n694             attr_docs = self.analyzer.find_attr_docs()\n695         else:\n696             attr_docs = {}\n697 \n698         # process members and determine which to skip\n699         for obj in members:\n700             membername, member = obj\n701             # if isattr is True, the member is documented as an attribute\n702             if member is INSTANCEATTR:\n703                 isattr = True\n704             else:\n705                 isattr = False\n706 \n707             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n708                          self.parent, self.object_name)\n709             if not isinstance(doc, str):\n710                 # Ignore non-string __doc__\n711                 doc = None\n712 \n713             # if the member __doc__ is the same as self's __doc__, it's just\n714             # inherited and therefore not the member's doc\n715             cls = self.get_attr(member, '__class__', None)\n716             if cls:\n717                 cls_doc = self.get_attr(cls, '__doc__', None)\n718                 if cls_doc == doc:\n719                     doc = None\n720 \n721             if isinstance(obj, ObjectMember) and obj.docstring:\n722                 # hack for ClassDocumenter to inject docstring via ObjectMember\n723                 doc = obj.docstring\n724 \n725             has_doc = bool(doc)\n726 \n727             metadata = extract_metadata(doc)\n728             if 'private' in metadata:\n729                 # consider a member private if docstring has \"private\" metadata\n730                 isprivate = True\n731             elif 'public' in metadata:\n732                 # consider a member public if docstring has \"public\" metadata\n733                 isprivate = False\n734             else:\n735                 isprivate = membername.startswith('_')\n736 \n737             keep = False\n738             if ismock(member):\n739                 # mocked module or object\n740                 pass\n741             elif self.options.exclude_members and membername in self.options.exclude_members:\n742                 # remove members given by exclude-members\n743                 keep = False\n744             elif want_all and special_member_re.match(membername):\n745                 # special __methods__\n746                 if self.options.special_members and membername in self.options.special_members:\n747                     if membername == '__doc__':\n748                         keep = False\n749                     elif is_filtered_inherited_member(membername, obj):\n750                         keep = False\n751                     else:\n752                         keep = has_doc or self.options.undoc_members\n753                 else:\n754                     keep = False\n755             elif (namespace, membername) in attr_docs:\n756                 if want_all and isprivate:\n757                     if self.options.private_members is None:\n758                         keep = False\n759                     else:\n760                         keep = membername in self.options.private_members\n761                 else:\n762                     # keep documented attributes\n763                     keep = True\n764                 isattr = True\n765             elif want_all and isprivate:\n766                 if has_doc or self.options.undoc_members:\n767                     if self.options.private_members is None:\n768                         keep = False\n769                     elif is_filtered_inherited_member(membername, obj):\n770                         keep = False\n771                     else:\n772                         keep = membername in self.options.private_members\n773                 else:\n774                     keep = False\n775             else:\n776                 if (self.options.members is ALL and\n777                         is_filtered_inherited_member(membername, obj)):\n778                     keep = False\n779                 else:\n780                     # ignore undocumented members if :undoc-members: is not given\n781                     keep = has_doc or self.options.undoc_members\n782 \n783             if isinstance(obj, ObjectMember) and obj.skipped:\n784                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n785                 keep = False\n786 \n787             # give the user a chance to decide whether this member\n788             # should be skipped\n789             if self.env.app:\n790                 # let extensions preprocess docstrings\n791                 try:\n792                     skip_user = self.env.app.emit_firstresult(\n793                         'autodoc-skip-member', self.objtype, membername, member,\n794                         not keep, self.options)\n795                     if skip_user is not None:\n796                         keep = not skip_user\n797                 except Exception as exc:\n798                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n799                                       'the following exception was raised:\\n%s'),\n800                                    member, exc, type='autodoc')\n801                     keep = False\n802 \n803             if keep:\n804                 ret.append((membername, member, isattr))\n805 \n806         return ret\n807 \n808     def document_members(self, all_members: bool = False) -> None:\n809         \"\"\"Generate reST for member documentation.\n810 \n811         If *all_members* is True, do all members, else those given by\n812         *self.options.members*.\n813         \"\"\"\n814         # set current namespace for finding members\n815         self.env.temp_data['autodoc:module'] = self.modname\n816         if self.objpath:\n817             self.env.temp_data['autodoc:class'] = self.objpath[0]\n818 \n819         want_all = all_members or self.options.inherited_members or \\\n820             self.options.members is ALL\n821         # find out which members are documentable\n822         members_check_module, members = self.get_object_members(want_all)\n823 \n824         # document non-skipped members\n825         memberdocumenters: List[Tuple[Documenter, bool]] = []\n826         for (mname, member, isattr) in self.filter_members(members, want_all):\n827             classes = [cls for cls in self.documenters.values()\n828                        if cls.can_document_member(member, mname, isattr, self)]\n829             if not classes:\n830                 # don't know how to document this member\n831                 continue\n832             # prefer the documenter with the highest priority\n833             classes.sort(key=lambda cls: cls.priority)\n834             # give explicitly separated module name, so that members\n835             # of inner classes can be documented\n836             full_mname = self.modname + '::' + \\\n837                 '.'.join(self.objpath + [mname])\n838             documenter = classes[-1](self.directive, full_mname, self.indent)\n839             memberdocumenters.append((documenter, isattr))\n840 \n841         member_order = self.options.member_order or self.config.autodoc_member_order\n842         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n843 \n844         for documenter, isattr in memberdocumenters:\n845             documenter.generate(\n846                 all_members=True, real_modname=self.real_modname,\n847                 check_module=members_check_module and not isattr)\n848 \n849         # reset current objects\n850         self.env.temp_data['autodoc:module'] = None\n851         self.env.temp_data['autodoc:class'] = None\n852 \n853     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n854                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n855         \"\"\"Sort the given member list.\"\"\"\n856         if order == 'groupwise':\n857             # sort by group; alphabetically within groups\n858             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n859         elif order == 'bysource':\n860             if self.analyzer:\n861                 # sort by source order, by virtue of the module analyzer\n862                 tagorder = self.analyzer.tagorder\n863 \n864                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n865                     fullname = entry[0].name.split('::')[1]\n866                     return tagorder.get(fullname, len(tagorder))\n867                 documenters.sort(key=keyfunc)\n868             else:\n869                 # Assume that member discovery order matches source order.\n870                 # This is a reasonable assumption in Python 3.6 and up, where\n871                 # module.__dict__ is insertion-ordered.\n872                 pass\n873         else:  # alphabetical\n874             documenters.sort(key=lambda e: e[0].name)\n875 \n876         return documenters\n877 \n878     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n879                  check_module: bool = False, all_members: bool = False) -> None:\n880         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n881         its members.\n882 \n883         If *more_content* is given, include that content. If *real_modname* is\n884         given, use that module name to find attribute docs. If *check_module* is\n885         True, only generate if the object is defined in the module name it is\n886         imported from. If *all_members* is True, document all members.\n887         \"\"\"\n888         if not self.parse_name():\n889             # need a module to import\n890             logger.warning(\n891                 __('don\\'t know which module to import for autodocumenting '\n892                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n893                    'in the document, or giving an explicit module name)') %\n894                 self.name, type='autodoc')\n895             return\n896 \n897         # now, import the module and get object to document\n898         if not self.import_object():\n899             return\n900 \n901         # If there is no real module defined, figure out which to use.\n902         # The real module is used in the module analyzer to look up the module\n903         # where the attribute documentation would actually be found in.\n904         # This is used for situations where you have a module that collects the\n905         # functions and classes of internal submodules.\n906         guess_modname = self.get_real_modname()\n907         self.real_modname: str = real_modname or guess_modname\n908 \n909         # try to also get a source code analyzer for attribute docs\n910         try:\n911             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n912             # parse right now, to get PycodeErrors on parsing (results will\n913             # be cached anyway)\n914             self.analyzer.find_attr_docs()\n915         except PycodeError as exc:\n916             logger.debug('[autodoc] module analyzer failed: %s', exc)\n917             # no source file -- e.g. for builtin and C modules\n918             self.analyzer = None\n919             # at least add the module.__file__ as a dependency\n920             if hasattr(self.module, '__file__') and self.module.__file__:\n921                 self.directive.record_dependencies.add(self.module.__file__)\n922         else:\n923             self.directive.record_dependencies.add(self.analyzer.srcname)\n924 \n925         if self.real_modname != guess_modname:\n926             # Add module to dependency list if target object is defined in other module.\n927             try:\n928                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n929                 self.directive.record_dependencies.add(analyzer.srcname)\n930             except PycodeError:\n931                 pass\n932 \n933         # check __module__ of object (for members not given explicitly)\n934         if check_module:\n935             if not self.check_module():\n936                 return\n937 \n938         sourcename = self.get_sourcename()\n939 \n940         # make sure that the result starts with an empty line.  This is\n941         # necessary for some situations where another directive preprocesses\n942         # reST and no starting newline is present\n943         self.add_line('', sourcename)\n944 \n945         # format the object's signature, if any\n946         try:\n947             sig = self.format_signature()\n948         except Exception as exc:\n949             logger.warning(__('error while formatting signature for %s: %s'),\n950                            self.fullname, exc, type='autodoc')\n951             return\n952 \n953         # generate the directive header and options, if applicable\n954         self.add_directive_header(sig)\n955         self.add_line('', sourcename)\n956 \n957         # e.g. the module directive doesn't have content\n958         self.indent += self.content_indent\n959 \n960         # add all content (from docstrings, attribute docs etc.)\n961         self.add_content(more_content)\n962 \n963         # document members, if possible\n964         self.document_members(all_members)\n965 \n966 \n967 class ModuleDocumenter(Documenter):\n968     \"\"\"\n969     Specialized Documenter subclass for modules.\n970     \"\"\"\n971     objtype = 'module'\n972     content_indent = ''\n973     titles_allowed = True\n974 \n975     option_spec: OptionSpec = {\n976         'members': members_option, 'undoc-members': bool_option,\n977         'noindex': bool_option, 'inherited-members': inherited_members_option,\n978         'show-inheritance': bool_option, 'synopsis': identity,\n979         'platform': identity, 'deprecated': bool_option,\n980         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n981         'private-members': members_option, 'special-members': members_option,\n982         'imported-members': bool_option, 'ignore-module-all': bool_option\n983     }\n984 \n985     def __init__(self, *args: Any) -> None:\n986         super().__init__(*args)\n987         merge_members_option(self.options)\n988         self.__all__: Optional[Sequence[str]] = None\n989 \n990     @classmethod\n991     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n992                             ) -> bool:\n993         # don't document submodules automatically\n994         return False\n995 \n996     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n997                      ) -> Tuple[str, List[str]]:\n998         if modname is not None:\n999             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1000                            type='autodoc')\n1001         return (path or '') + base, []\n1002 \n1003     def parse_name(self) -> bool:\n1004         ret = super().parse_name()\n1005         if self.args or self.retann:\n1006             logger.warning(__('signature arguments or return annotation '\n1007                               'given for automodule %s') % self.fullname,\n1008                            type='autodoc')\n1009         return ret\n1010 \n1011     def import_object(self, raiseerror: bool = False) -> bool:\n1012         ret = super().import_object(raiseerror)\n1013 \n1014         try:\n1015             if not self.options.ignore_module_all:\n1016                 self.__all__ = inspect.getall(self.object)\n1017         except ValueError as exc:\n1018             # invalid __all__ found.\n1019             logger.warning(__('__all__ should be a list of strings, not %r '\n1020                               '(in module %s) -- ignoring __all__') %\n1021                            (exc.args[0], self.fullname), type='autodoc')\n1022 \n1023         return ret\n1024 \n1025     def add_directive_header(self, sig: str) -> None:\n1026         Documenter.add_directive_header(self, sig)\n1027 \n1028         sourcename = self.get_sourcename()\n1029 \n1030         # add some module-specific options\n1031         if self.options.synopsis:\n1032             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1033         if self.options.platform:\n1034             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1035         if self.options.deprecated:\n1036             self.add_line('   :deprecated:', sourcename)\n1037 \n1038     def get_module_members(self) -> Dict[str, ObjectMember]:\n1039         \"\"\"Get members of target module.\"\"\"\n1040         if self.analyzer:\n1041             attr_docs = self.analyzer.attr_docs\n1042         else:\n1043             attr_docs = {}\n1044 \n1045         members: Dict[str, ObjectMember] = {}\n1046         for name in dir(self.object):\n1047             try:\n1048                 value = safe_getattr(self.object, name, None)\n1049                 if ismock(value):\n1050                     value = undecorate(value)\n1051                 docstring = attr_docs.get(('', name), [])\n1052                 members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n1053             except AttributeError:\n1054                 continue\n1055 \n1056         # annotation only member (ex. attr: int)\n1057         for name in inspect.getannotations(self.object):\n1058             if name not in members:\n1059                 docstring = attr_docs.get(('', name), [])\n1060                 members[name] = ObjectMember(name, INSTANCEATTR,\n1061                                              docstring=\"\\n\".join(docstring))\n1062 \n1063         return members\n1064 \n1065     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1066         members = self.get_module_members()\n1067         if want_all:\n1068             if self.__all__ is None:\n1069                 # for implicit module members, check __module__ to avoid\n1070                 # documenting imported objects\n1071                 return True, list(members.values())\n1072             else:\n1073                 for member in members.values():\n1074                     if member.__name__ not in self.__all__:\n1075                         member.skipped = True\n1076 \n1077                 return False, list(members.values())\n1078         else:\n1079             memberlist = self.options.members or []\n1080             ret = []\n1081             for name in memberlist:\n1082                 if name in members:\n1083                     ret.append(members[name])\n1084                 else:\n1085                     logger.warning(__('missing attribute mentioned in :members: option: '\n1086                                       'module %s, attribute %s') %\n1087                                    (safe_getattr(self.object, '__name__', '???'), name),\n1088                                    type='autodoc')\n1089             return False, ret\n1090 \n1091     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1092                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1093         if order == 'bysource' and self.__all__:\n1094             # Sort alphabetically first (for members not listed on the __all__)\n1095             documenters.sort(key=lambda e: e[0].name)\n1096 \n1097             # Sort by __all__\n1098             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1099                 name = entry[0].name.split('::')[1]\n1100                 if self.__all__ and name in self.__all__:\n1101                     return self.__all__.index(name)\n1102                 else:\n1103                     return len(self.__all__)\n1104             documenters.sort(key=keyfunc)\n1105 \n1106             return documenters\n1107         else:\n1108             return super().sort_members(documenters, order)\n1109 \n1110 \n1111 class ModuleLevelDocumenter(Documenter):\n1112     \"\"\"\n1113     Specialized Documenter subclass for objects on module level (functions,\n1114     classes, data/constants).\n1115     \"\"\"\n1116     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1117                      ) -> Tuple[str, List[str]]:\n1118         if modname is None:\n1119             if path:\n1120                 modname = path.rstrip('.')\n1121             else:\n1122                 # if documenting a toplevel object without explicit module,\n1123                 # it can be contained in another auto directive ...\n1124                 modname = self.env.temp_data.get('autodoc:module')\n1125                 # ... or in the scope of a module directive\n1126                 if not modname:\n1127                     modname = self.env.ref_context.get('py:module')\n1128                 # ... else, it stays None, which means invalid\n1129         return modname, parents + [base]\n1130 \n1131 \n1132 class ClassLevelDocumenter(Documenter):\n1133     \"\"\"\n1134     Specialized Documenter subclass for objects on class level (methods,\n1135     attributes).\n1136     \"\"\"\n1137     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1138                      ) -> Tuple[str, List[str]]:\n1139         if modname is None:\n1140             if path:\n1141                 mod_cls = path.rstrip('.')\n1142             else:\n1143                 mod_cls = None\n1144                 # if documenting a class-level object without path,\n1145                 # there must be a current class, either from a parent\n1146                 # auto directive ...\n1147                 mod_cls = self.env.temp_data.get('autodoc:class')\n1148                 # ... or from a class directive\n1149                 if mod_cls is None:\n1150                     mod_cls = self.env.ref_context.get('py:class')\n1151                 # ... if still None, there's no way to know\n1152                 if mod_cls is None:\n1153                     return None, []\n1154             modname, sep, cls = mod_cls.rpartition('.')\n1155             parents = [cls]\n1156             # if the module name is still missing, get it like above\n1157             if not modname:\n1158                 modname = self.env.temp_data.get('autodoc:module')\n1159             if not modname:\n1160                 modname = self.env.ref_context.get('py:module')\n1161             # ... else, it stays None, which means invalid\n1162         return modname, parents + [base]\n1163 \n1164 \n1165 class DocstringSignatureMixin:\n1166     \"\"\"\n1167     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1168     feature of reading the signature from the docstring.\n1169     \"\"\"\n1170     _new_docstrings: List[List[str]] = None\n1171     _signatures: List[str] = None\n1172 \n1173     def _find_signature(self) -> Tuple[str, str]:\n1174         # candidates of the object name\n1175         valid_names = [self.objpath[-1]]  # type: ignore\n1176         if isinstance(self, ClassDocumenter):\n1177             valid_names.append('__init__')\n1178             if hasattr(self.object, '__mro__'):\n1179                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1180 \n1181         docstrings = self.get_doc()\n1182         if docstrings is None:\n1183             return None, None\n1184         self._new_docstrings = docstrings[:]\n1185         self._signatures = []\n1186         result = None\n1187         for i, doclines in enumerate(docstrings):\n1188             for j, line in enumerate(doclines):\n1189                 if not line:\n1190                     # no lines in docstring, no match\n1191                     break\n1192 \n1193                 if line.endswith('\\\\'):\n1194                     line = line.rstrip('\\\\').rstrip()\n1195 \n1196                 # match first line of docstring against signature RE\n1197                 match = py_ext_sig_re.match(line)\n1198                 if not match:\n1199                     break\n1200                 exmod, path, base, args, retann = match.groups()\n1201 \n1202                 # the base name must match ours\n1203                 if base not in valid_names:\n1204                     break\n1205 \n1206                 # re-prepare docstring to ignore more leading indentation\n1207                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1208                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1209                                                             tabsize=tab_width)\n1210 \n1211                 if result is None:\n1212                     # first signature\n1213                     result = args, retann\n1214                 else:\n1215                     # subsequent signatures\n1216                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1217 \n1218             if result:\n1219                 # finish the loop when signature found\n1220                 break\n1221 \n1222         return result\n1223 \n1224     def get_doc(self, ignore: int = None) -> List[List[str]]:\n1225         if self._new_docstrings is not None:\n1226             return self._new_docstrings\n1227         return super().get_doc(ignore)  # type: ignore\n1228 \n1229     def format_signature(self, **kwargs: Any) -> str:\n1230         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1231             # only act if a signature is not explicitly given already, and if\n1232             # the feature is enabled\n1233             result = self._find_signature()\n1234             if result is not None:\n1235                 self.args, self.retann = result\n1236         sig = super().format_signature(**kwargs)  # type: ignore\n1237         if self._signatures:\n1238             return \"\\n\".join([sig] + self._signatures)\n1239         else:\n1240             return sig\n1241 \n1242 \n1243 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1244     \"\"\"\n1245     Mixin for AttributeDocumenter to provide the\n1246     feature of stripping any function signature from the docstring.\n1247     \"\"\"\n1248     def format_signature(self, **kwargs: Any) -> str:\n1249         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1250             # only act if a signature is not explicitly given already, and if\n1251             # the feature is enabled\n1252             result = self._find_signature()\n1253             if result is not None:\n1254                 # Discarding _args is a only difference with\n1255                 # DocstringSignatureMixin.format_signature.\n1256                 # Documenter.format_signature use self.args value to format.\n1257                 _args, self.retann = result\n1258         return super().format_signature(**kwargs)\n1259 \n1260 \n1261 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1262     \"\"\"\n1263     Specialized Documenter subclass for functions.\n1264     \"\"\"\n1265     objtype = 'function'\n1266     member_order = 30\n1267 \n1268     @classmethod\n1269     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1270                             ) -> bool:\n1271         # supports functions, builtins and bound methods exported at the module level\n1272         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1273                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1274 \n1275     def format_args(self, **kwargs: Any) -> str:\n1276         if self.config.autodoc_typehints in ('none', 'description'):\n1277             kwargs.setdefault('show_annotation', False)\n1278 \n1279         try:\n1280             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1281             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n1282             args = stringify_signature(sig, **kwargs)\n1283         except TypeError as exc:\n1284             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1285                            self.fullname, exc)\n1286             return None\n1287         except ValueError:\n1288             args = ''\n1289 \n1290         if self.config.strip_signature_backslash:\n1291             # escape backslashes for reST\n1292             args = args.replace('\\\\', '\\\\\\\\')\n1293         return args\n1294 \n1295     def document_members(self, all_members: bool = False) -> None:\n1296         pass\n1297 \n1298     def add_directive_header(self, sig: str) -> None:\n1299         sourcename = self.get_sourcename()\n1300         super().add_directive_header(sig)\n1301 \n1302         if inspect.iscoroutinefunction(self.object):\n1303             self.add_line('   :async:', sourcename)\n1304 \n1305     def format_signature(self, **kwargs: Any) -> str:\n1306         sigs = []\n1307         if (self.analyzer and\n1308                 '.'.join(self.objpath) in self.analyzer.overloads and\n1309                 self.config.autodoc_typehints == 'signature'):\n1310             # Use signatures for overloaded functions instead of the implementation function.\n1311             overloaded = True\n1312         else:\n1313             overloaded = False\n1314             sig = super().format_signature(**kwargs)\n1315             sigs.append(sig)\n1316 \n1317         if inspect.is_singledispatch_function(self.object):\n1318             # append signature of singledispatch'ed functions\n1319             for typ, func in self.object.registry.items():\n1320                 if typ is object:\n1321                     pass  # default implementation. skipped.\n1322                 else:\n1323                     self.annotate_to_first_argument(func, typ)\n1324 \n1325                     documenter = FunctionDocumenter(self.directive, '')\n1326                     documenter.object = func\n1327                     documenter.objpath = [None]\n1328                     sigs.append(documenter.format_signature())\n1329         if overloaded:\n1330             actual = inspect.signature(self.object,\n1331                                        type_aliases=self.config.autodoc_type_aliases)\n1332             __globals__ = safe_getattr(self.object, '__globals__', {})\n1333             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1334                 overload = self.merge_default_value(actual, overload)\n1335                 overload = evaluate_signature(overload, __globals__,\n1336                                               self.config.autodoc_type_aliases)\n1337 \n1338                 sig = stringify_signature(overload, **kwargs)\n1339                 sigs.append(sig)\n1340 \n1341         return \"\\n\".join(sigs)\n1342 \n1343     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n1344         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n1345         parameters = list(overload.parameters.values())\n1346         for i, param in enumerate(parameters):\n1347             actual_param = actual.parameters.get(param.name)\n1348             if actual_param and param.default == '...':\n1349                 parameters[i] = param.replace(default=actual_param.default)\n1350 \n1351         return overload.replace(parameters=parameters)\n1352 \n1353     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1354         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1355         try:\n1356             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n1357         except TypeError as exc:\n1358             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1359                            self.fullname, exc)\n1360             return\n1361         except ValueError:\n1362             return\n1363 \n1364         if len(sig.parameters) == 0:\n1365             return\n1366 \n1367         params = list(sig.parameters.values())\n1368         if params[0].annotation is Parameter.empty:\n1369             params[0] = params[0].replace(annotation=typ)\n1370             try:\n1371                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1372             except (AttributeError, TypeError):\n1373                 # failed to update signature (ex. built-in or extension types)\n1374                 return\n1375 \n1376 \n1377 class DecoratorDocumenter(FunctionDocumenter):\n1378     \"\"\"\n1379     Specialized Documenter subclass for decorator functions.\n1380     \"\"\"\n1381     objtype = 'decorator'\n1382 \n1383     # must be lower than FunctionDocumenter\n1384     priority = -1\n1385 \n1386     def format_args(self, **kwargs: Any) -> Any:\n1387         args = super().format_args(**kwargs)\n1388         if ',' in args:\n1389             return args\n1390         else:\n1391             return None\n1392 \n1393 \n1394 # Types which have confusing metaclass signatures it would be best not to show.\n1395 # These are listed by name, rather than storing the objects themselves, to avoid\n1396 # needing to import the modules.\n1397 _METACLASS_CALL_BLACKLIST = [\n1398     'enum.EnumMeta.__call__',\n1399 ]\n1400 \n1401 \n1402 # Types whose __new__ signature is a pass-thru.\n1403 _CLASS_NEW_BLACKLIST = [\n1404     'typing.Generic.__new__',\n1405 ]\n1406 \n1407 \n1408 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1409     \"\"\"\n1410     Specialized Documenter subclass for classes.\n1411     \"\"\"\n1412     objtype = 'class'\n1413     member_order = 20\n1414     option_spec: OptionSpec = {\n1415         'members': members_option, 'undoc-members': bool_option,\n1416         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1417         'show-inheritance': bool_option, 'member-order': member_order_option,\n1418         'exclude-members': exclude_members_option,\n1419         'private-members': members_option, 'special-members': members_option,\n1420     }\n1421 \n1422     _signature_class: Any = None\n1423     _signature_method_name: str = None\n1424 \n1425     def __init__(self, *args: Any) -> None:\n1426         super().__init__(*args)\n1427         merge_members_option(self.options)\n1428 \n1429     @classmethod\n1430     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1431                             ) -> bool:\n1432         return isinstance(member, type)\n1433 \n1434     def import_object(self, raiseerror: bool = False) -> bool:\n1435         ret = super().import_object(raiseerror)\n1436         # if the class is documented under another name, document it\n1437         # as data/attribute\n1438         if ret:\n1439             if hasattr(self.object, '__name__'):\n1440                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1441             else:\n1442                 self.doc_as_attr = True\n1443         return ret\n1444 \n1445     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1446         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1447             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1448             if inspect.is_builtin_class_method(obj, attr):\n1449                 return None\n1450             attr = self.get_attr(obj, attr, None)\n1451             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1452                 return None\n1453             return attr\n1454 \n1455         # This sequence is copied from inspect._signature_from_callable.\n1456         # ValueError means that no signature could be found, so we keep going.\n1457 \n1458         # First, we check the obj has a __signature__ attribute\n1459         if (hasattr(self.object, '__signature__') and\n1460                 isinstance(self.object.__signature__, Signature)):\n1461             return None, None, self.object.__signature__\n1462 \n1463         # Next, let's see if it has an overloaded __call__ defined\n1464         # in its metaclass\n1465         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1466 \n1467         if call is not None:\n1468             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1469                 call = None\n1470 \n1471         if call is not None:\n1472             self.env.app.emit('autodoc-before-process-signature', call, True)\n1473             try:\n1474                 sig = inspect.signature(call, bound_method=True,\n1475                                         type_aliases=self.config.autodoc_type_aliases)\n1476                 return type(self.object), '__call__', sig\n1477             except ValueError:\n1478                 pass\n1479 \n1480         # Now we check if the 'obj' class has a '__new__' method\n1481         new = get_user_defined_function_or_method(self.object, '__new__')\n1482 \n1483         if new is not None:\n1484             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1485                 new = None\n1486 \n1487         if new is not None:\n1488             self.env.app.emit('autodoc-before-process-signature', new, True)\n1489             try:\n1490                 sig = inspect.signature(new, bound_method=True,\n1491                                         type_aliases=self.config.autodoc_type_aliases)\n1492                 return self.object, '__new__', sig\n1493             except ValueError:\n1494                 pass\n1495 \n1496         # Finally, we should have at least __init__ implemented\n1497         init = get_user_defined_function_or_method(self.object, '__init__')\n1498         if init is not None:\n1499             self.env.app.emit('autodoc-before-process-signature', init, True)\n1500             try:\n1501                 sig = inspect.signature(init, bound_method=True,\n1502                                         type_aliases=self.config.autodoc_type_aliases)\n1503                 return self.object, '__init__', sig\n1504             except ValueError:\n1505                 pass\n1506 \n1507         # None of the attributes are user-defined, so fall back to let inspect\n1508         # handle it.\n1509         # We don't know the exact method that inspect.signature will read\n1510         # the signature from, so just pass the object itself to our hook.\n1511         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1512         try:\n1513             sig = inspect.signature(self.object, bound_method=False,\n1514                                     type_aliases=self.config.autodoc_type_aliases)\n1515             return None, None, sig\n1516         except ValueError:\n1517             pass\n1518 \n1519         # Still no signature: happens e.g. for old-style classes\n1520         # with __init__ in C and no `__text_signature__`.\n1521         return None, None, None\n1522 \n1523     def format_args(self, **kwargs: Any) -> str:\n1524         if self.config.autodoc_typehints in ('none', 'description'):\n1525             kwargs.setdefault('show_annotation', False)\n1526 \n1527         try:\n1528             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1529         except TypeError as exc:\n1530             # __signature__ attribute contained junk\n1531             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1532                            self.fullname, exc)\n1533             return None\n1534 \n1535         if sig is None:\n1536             return None\n1537 \n1538         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1539 \n1540     def format_signature(self, **kwargs: Any) -> str:\n1541         if self.doc_as_attr:\n1542             return ''\n1543 \n1544         sig = super().format_signature()\n1545         sigs = []\n1546 \n1547         overloads = self.get_overloaded_signatures()\n1548         if overloads and self.config.autodoc_typehints == 'signature':\n1549             # Use signatures for overloaded methods instead of the implementation method.\n1550             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1551             __globals__ = safe_getattr(method, '__globals__', {})\n1552             for overload in overloads:\n1553                 overload = evaluate_signature(overload, __globals__,\n1554                                               self.config.autodoc_type_aliases)\n1555 \n1556                 parameters = list(overload.parameters.values())\n1557                 overload = overload.replace(parameters=parameters[1:],\n1558                                             return_annotation=Parameter.empty)\n1559                 sig = stringify_signature(overload, **kwargs)\n1560                 sigs.append(sig)\n1561         else:\n1562             sigs.append(sig)\n1563 \n1564         return \"\\n\".join(sigs)\n1565 \n1566     def get_overloaded_signatures(self) -> List[Signature]:\n1567         if self._signature_class and self._signature_method_name:\n1568             for cls in self._signature_class.__mro__:\n1569                 try:\n1570                     analyzer = ModuleAnalyzer.for_module(cls.__module__)\n1571                     analyzer.analyze()\n1572                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n1573                     if qualname in analyzer.overloads:\n1574                         return analyzer.overloads.get(qualname)\n1575                     elif qualname in analyzer.tagorder:\n1576                         # the constructor is defined in the class, but not overrided.\n1577                         return []\n1578                 except PycodeError:\n1579                     pass\n1580 \n1581         return []\n1582 \n1583     def get_canonical_fullname(self) -> Optional[str]:\n1584         __modname__ = safe_getattr(self.object, '__module__', self.modname)\n1585         __qualname__ = safe_getattr(self.object, '__qualname__', None)\n1586         if __qualname__ is None:\n1587             __qualname__ = safe_getattr(self.object, '__name__', None)\n1588         if __qualname__ and '<locals>' in __qualname__:\n1589             # No valid qualname found if the object is defined as locals\n1590             __qualname__ = None\n1591 \n1592         if __modname__ and __qualname__:\n1593             return '.'.join([__modname__, __qualname__])\n1594         else:\n1595             return None\n1596 \n1597     def add_directive_header(self, sig: str) -> None:\n1598         sourcename = self.get_sourcename()\n1599 \n1600         if self.doc_as_attr:\n1601             self.directivetype = 'attribute'\n1602         super().add_directive_header(sig)\n1603 \n1604         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1605             self.add_line('   :final:', sourcename)\n1606 \n1607         canonical_fullname = self.get_canonical_fullname()\n1608         if not self.doc_as_attr and canonical_fullname and self.fullname != canonical_fullname:\n1609             self.add_line('   :canonical: %s' % canonical_fullname, sourcename)\n1610 \n1611         # add inheritance info, if wanted\n1612         if not self.doc_as_attr and self.options.show_inheritance:\n1613             sourcename = self.get_sourcename()\n1614             self.add_line('', sourcename)\n1615 \n1616             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n1617                 # A subclass of generic types\n1618                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n1619                 bases = [restify(cls) for cls in self.object.__orig_bases__]\n1620                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1621             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1622                 # A normal class\n1623                 bases = [restify(cls) for cls in self.object.__bases__]\n1624                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1625 \n1626     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1627         members = get_class_members(self.object, self.objpath, self.get_attr)\n1628         if not want_all:\n1629             if not self.options.members:\n1630                 return False, []  # type: ignore\n1631             # specific members given\n1632             selected = []\n1633             for name in self.options.members:  # type: str\n1634                 if name in members:\n1635                     selected.append(members[name])\n1636                 else:\n1637                     logger.warning(__('missing attribute %s in object %s') %\n1638                                    (name, self.fullname), type='autodoc')\n1639             return False, selected\n1640         elif self.options.inherited_members:\n1641             return False, list(members.values())\n1642         else:\n1643             return False, [m for m in members.values() if m.class_ == self.object]\n1644 \n1645     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1646         if self.doc_as_attr:\n1647             # Don't show the docstring of the class when it is an alias.\n1648             return None\n1649 \n1650         lines = getattr(self, '_new_docstrings', None)\n1651         if lines is not None:\n1652             return lines\n1653 \n1654         content = self.config.autoclass_content\n1655 \n1656         docstrings = []\n1657         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1658         if attrdocstring:\n1659             docstrings.append(attrdocstring)\n1660 \n1661         # for classes, what the \"docstring\" is can be controlled via a\n1662         # config value; the default is only the class docstring\n1663         if content in ('both', 'init'):\n1664             __init__ = self.get_attr(self.object, '__init__', None)\n1665             initdocstring = getdoc(__init__, self.get_attr,\n1666                                    self.config.autodoc_inherit_docstrings,\n1667                                    self.parent, self.object_name)\n1668             # for new-style classes, no __init__ means default __init__\n1669             if (initdocstring is not None and\n1670                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1671                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1672                 initdocstring = None\n1673             if not initdocstring:\n1674                 # try __new__\n1675                 __new__ = self.get_attr(self.object, '__new__', None)\n1676                 initdocstring = getdoc(__new__, self.get_attr,\n1677                                        self.config.autodoc_inherit_docstrings,\n1678                                        self.parent, self.object_name)\n1679                 # for new-style classes, no __new__ means default __new__\n1680                 if (initdocstring is not None and\n1681                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1682                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1683                     initdocstring = None\n1684             if initdocstring:\n1685                 if content == 'init':\n1686                     docstrings = [initdocstring]\n1687                 else:\n1688                     docstrings.append(initdocstring)\n1689 \n1690         tab_width = self.directive.state.document.settings.tab_width\n1691         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1692 \n1693     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1694                     ) -> None:\n1695         if self.doc_as_attr:\n1696             try:\n1697                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n1698             except AttributeError:\n1699                 pass  # Invalid class object is passed.\n1700 \n1701         super().add_content(more_content)\n1702 \n1703     def document_members(self, all_members: bool = False) -> None:\n1704         if self.doc_as_attr:\n1705             return\n1706         super().document_members(all_members)\n1707 \n1708     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n1709                  check_module: bool = False, all_members: bool = False) -> None:\n1710         # Do not pass real_modname and use the name from the __module__\n1711         # attribute of the class.\n1712         # If a class gets imported into the module real_modname\n1713         # the analyzer won't find the source of the class, if\n1714         # it looks in real_modname.\n1715         return super().generate(more_content=more_content,\n1716                                 check_module=check_module,\n1717                                 all_members=all_members)\n1718 \n1719 \n1720 class ExceptionDocumenter(ClassDocumenter):\n1721     \"\"\"\n1722     Specialized ClassDocumenter subclass for exceptions.\n1723     \"\"\"\n1724     objtype = 'exception'\n1725     member_order = 10\n1726 \n1727     # needs a higher priority than ClassDocumenter\n1728     priority = 10\n1729 \n1730     @classmethod\n1731     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1732                             ) -> bool:\n1733         return isinstance(member, type) and issubclass(member, BaseException)\n1734 \n1735 \n1736 class DataDocumenterMixinBase:\n1737     # define types of instance variables\n1738     config: Config = None\n1739     env: BuildEnvironment = None\n1740     modname: str = None\n1741     parent: Any = None\n1742     object: Any = None\n1743     objpath: List[str] = None\n1744 \n1745     def should_suppress_directive_header(self) -> bool:\n1746         \"\"\"Check directive header should be suppressed.\"\"\"\n1747         return False\n1748 \n1749     def should_suppress_value_header(self) -> bool:\n1750         \"\"\"Check :value: header should be suppressed.\"\"\"\n1751         return False\n1752 \n1753     def update_content(self, more_content: StringList) -> None:\n1754         \"\"\"Update docstring for the NewType object.\"\"\"\n1755         pass\n1756 \n1757 \n1758 class GenericAliasMixin(DataDocumenterMixinBase):\n1759     \"\"\"\n1760     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1761     supporting GenericAliases.\n1762     \"\"\"\n1763 \n1764     def should_suppress_directive_header(self) -> bool:\n1765         return (inspect.isgenericalias(self.object) or\n1766                 super().should_suppress_directive_header())\n1767 \n1768     def update_content(self, more_content: StringList) -> None:\n1769         if inspect.isgenericalias(self.object):\n1770             alias = stringify_typehint(self.object)\n1771             more_content.append(_('alias of %s') % alias, '')\n1772             more_content.append('', '')\n1773 \n1774         super().update_content(more_content)\n1775 \n1776 \n1777 class NewTypeMixin(DataDocumenterMixinBase):\n1778     \"\"\"\n1779     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1780     supporting NewTypes.\n1781     \"\"\"\n1782 \n1783     def should_suppress_directive_header(self) -> bool:\n1784         return (inspect.isNewType(self.object) or\n1785                 super().should_suppress_directive_header())\n1786 \n1787     def update_content(self, more_content: StringList) -> None:\n1788         if inspect.isNewType(self.object):\n1789             supertype = restify(self.object.__supertype__)\n1790             more_content.append(_('alias of %s') % supertype, '')\n1791             more_content.append('', '')\n1792 \n1793         super().update_content(more_content)\n1794 \n1795 \n1796 class TypeVarMixin(DataDocumenterMixinBase):\n1797     \"\"\"\n1798     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1799     supporting TypeVars.\n1800     \"\"\"\n1801 \n1802     def should_suppress_directive_header(self) -> bool:\n1803         return (isinstance(self.object, TypeVar) or\n1804                 super().should_suppress_directive_header())\n1805 \n1806     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1807         if ignore is not None:\n1808             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1809                           % self.__class__.__name__,\n1810                           RemovedInSphinx50Warning, stacklevel=2)\n1811 \n1812         if isinstance(self.object, TypeVar):\n1813             if self.object.__doc__ != TypeVar.__doc__:\n1814                 return super().get_doc()  # type: ignore\n1815             else:\n1816                 return []\n1817         else:\n1818             return super().get_doc()  # type: ignore\n1819 \n1820     def update_content(self, more_content: StringList) -> None:\n1821         if isinstance(self.object, TypeVar):\n1822             attrs = [repr(self.object.__name__)]\n1823             for constraint in self.object.__constraints__:\n1824                 attrs.append(stringify_typehint(constraint))\n1825             if self.object.__bound__:\n1826                 attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n1827             if self.object.__covariant__:\n1828                 attrs.append(\"covariant=True\")\n1829             if self.object.__contravariant__:\n1830                 attrs.append(\"contravariant=True\")\n1831 \n1832             more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n1833             more_content.append('', '')\n1834 \n1835         super().update_content(more_content)\n1836 \n1837 \n1838 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\n1839     \"\"\"\n1840     Mixin for DataDocumenter to provide the feature for supporting uninitialized\n1841     (type annotation only) global variables.\n1842     \"\"\"\n1843 \n1844     def import_object(self, raiseerror: bool = False) -> bool:\n1845         try:\n1846             return super().import_object(raiseerror=True)  # type: ignore\n1847         except ImportError as exc:\n1848             # annotation only instance variable (PEP-526)\n1849             try:\n1850                 with mock(self.config.autodoc_mock_imports):\n1851                     parent = import_module(self.modname, self.config.autodoc_warningiserror)\n1852                     annotations = get_type_hints(parent, None,\n1853                                                  self.config.autodoc_type_aliases)\n1854                     if self.objpath[-1] in annotations:\n1855                         self.object = UNINITIALIZED_ATTR\n1856                         self.parent = parent\n1857                         return True\n1858             except ImportError:\n1859                 pass\n1860 \n1861             if raiseerror:\n1862                 raise\n1863             else:\n1864                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1865                 self.env.note_reread()\n1866                 return False\n1867 \n1868     def should_suppress_value_header(self) -> bool:\n1869         return (self.object is UNINITIALIZED_ATTR or\n1870                 super().should_suppress_value_header())\n1871 \n1872     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1873         if self.object is UNINITIALIZED_ATTR:\n1874             return []\n1875         else:\n1876             return super().get_doc(ignore)  # type: ignore\n1877 \n1878 \n1879 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n1880                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n1881     \"\"\"\n1882     Specialized Documenter subclass for data items.\n1883     \"\"\"\n1884     objtype = 'data'\n1885     member_order = 40\n1886     priority = -10\n1887     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n1888     option_spec[\"annotation\"] = annotation_option\n1889     option_spec[\"no-value\"] = bool_option\n1890 \n1891     @classmethod\n1892     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1893                             ) -> bool:\n1894         return isinstance(parent, ModuleDocumenter) and isattr\n1895 \n1896     def update_annotations(self, parent: Any) -> None:\n1897         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n1898         annotations = dict(inspect.getannotations(parent))\n1899         parent.__annotations__ = annotations\n1900 \n1901         try:\n1902             analyzer = ModuleAnalyzer.for_module(self.modname)\n1903             analyzer.analyze()\n1904             for (classname, attrname), annotation in analyzer.annotations.items():\n1905                 if classname == '' and attrname not in annotations:\n1906                     annotations[attrname] = annotation\n1907         except PycodeError:\n1908             pass\n1909 \n1910     def import_object(self, raiseerror: bool = False) -> bool:\n1911         ret = super().import_object(raiseerror)\n1912         if self.parent:\n1913             self.update_annotations(self.parent)\n1914 \n1915         return ret\n1916 \n1917     def should_suppress_value_header(self) -> bool:\n1918         if super().should_suppress_value_header():\n1919             return True\n1920         else:\n1921             doc = self.get_doc()\n1922             metadata = extract_metadata('\\n'.join(sum(doc, [])))\n1923             if 'hide-value' in metadata:\n1924                 return True\n1925 \n1926         return False\n1927 \n1928     def add_directive_header(self, sig: str) -> None:\n1929         super().add_directive_header(sig)\n1930         sourcename = self.get_sourcename()\n1931         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n1932             pass\n1933         elif self.options.annotation:\n1934             self.add_line('   :annotation: %s' % self.options.annotation,\n1935                           sourcename)\n1936         else:\n1937             # obtain annotation for this data\n1938             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n1939             if self.objpath[-1] in annotations:\n1940                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1941                 self.add_line('   :type: ' + objrepr, sourcename)\n1942 \n1943             try:\n1944                 if self.options.no_value or self.should_suppress_value_header():\n1945                     pass\n1946                 else:\n1947                     objrepr = object_description(self.object)\n1948                     self.add_line('   :value: ' + objrepr, sourcename)\n1949             except ValueError:\n1950                 pass\n1951 \n1952     def document_members(self, all_members: bool = False) -> None:\n1953         pass\n1954 \n1955     def get_real_modname(self) -> str:\n1956         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1957             or self.modname\n1958 \n1959     def get_module_comment(self, attrname: str) -> Optional[List[str]]:\n1960         try:\n1961             analyzer = ModuleAnalyzer.for_module(self.modname)\n1962             analyzer.analyze()\n1963             key = ('', attrname)\n1964             if key in analyzer.attr_docs:\n1965                 return list(analyzer.attr_docs[key])\n1966         except PycodeError:\n1967             pass\n1968 \n1969         return None\n1970 \n1971     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1972         # Check the variable has a docstring-comment\n1973         comment = self.get_module_comment(self.objpath[-1])\n1974         if comment:\n1975             return [comment]\n1976         else:\n1977             return super().get_doc(ignore)\n1978 \n1979     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1980                     ) -> None:\n1981         # Disable analyzing variable comment on Documenter.add_content() to control it on\n1982         # DataDocumenter.add_content()\n1983         self.analyzer = None\n1984 \n1985         if not more_content:\n1986             more_content = StringList()\n1987 \n1988         self.update_content(more_content)\n1989         super().add_content(more_content, no_docstring=no_docstring)\n1990 \n1991 \n1992 class NewTypeDataDocumenter(DataDocumenter):\n1993     \"\"\"\n1994     Specialized Documenter subclass for NewTypes.\n1995 \n1996     Note: This must be invoked before FunctionDocumenter because NewType is a kind of\n1997     function object.\n1998     \"\"\"\n1999 \n2000     objtype = 'newtypedata'\n2001     directivetype = 'data'\n2002     priority = FunctionDocumenter.priority + 1\n2003 \n2004     @classmethod\n2005     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2006                             ) -> bool:\n2007         return inspect.isNewType(member) and isattr\n2008 \n2009 \n2010 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2011     \"\"\"\n2012     Specialized Documenter subclass for methods (normal, static and class).\n2013     \"\"\"\n2014     objtype = 'method'\n2015     directivetype = 'method'\n2016     member_order = 50\n2017     priority = 1  # must be more than FunctionDocumenter\n2018 \n2019     @classmethod\n2020     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2021                             ) -> bool:\n2022         return inspect.isroutine(member) and \\\n2023             not isinstance(parent, ModuleDocumenter)\n2024 \n2025     def import_object(self, raiseerror: bool = False) -> bool:\n2026         ret = super().import_object(raiseerror)\n2027         if not ret:\n2028             return ret\n2029 \n2030         # to distinguish classmethod/staticmethod\n2031         obj = self.parent.__dict__.get(self.object_name)\n2032         if obj is None:\n2033             obj = self.object\n2034 \n2035         if (inspect.isclassmethod(obj) or\n2036                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n2037             # document class and static members before ordinary ones\n2038             self.member_order = self.member_order - 1\n2039 \n2040         return ret\n2041 \n2042     def format_args(self, **kwargs: Any) -> str:\n2043         if self.config.autodoc_typehints in ('none', 'description'):\n2044             kwargs.setdefault('show_annotation', False)\n2045 \n2046         try:\n2047             if self.object == object.__init__ and self.parent != object:\n2048                 # Classes not having own __init__() method are shown as no arguments.\n2049                 #\n2050                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n2051                 #       But it makes users confused.\n2052                 args = '()'\n2053             else:\n2054                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2055                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n2056                     sig = inspect.signature(self.object, bound_method=False,\n2057                                             type_aliases=self.config.autodoc_type_aliases)\n2058                 else:\n2059                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n2060                     sig = inspect.signature(self.object, bound_method=True,\n2061                                             type_aliases=self.config.autodoc_type_aliases)\n2062                 args = stringify_signature(sig, **kwargs)\n2063         except TypeError as exc:\n2064             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2065                            self.fullname, exc)\n2066             return None\n2067         except ValueError:\n2068             args = ''\n2069 \n2070         if self.config.strip_signature_backslash:\n2071             # escape backslashes for reST\n2072             args = args.replace('\\\\', '\\\\\\\\')\n2073         return args\n2074 \n2075     def add_directive_header(self, sig: str) -> None:\n2076         super().add_directive_header(sig)\n2077 \n2078         sourcename = self.get_sourcename()\n2079         obj = self.parent.__dict__.get(self.object_name, self.object)\n2080         if inspect.isabstractmethod(obj):\n2081             self.add_line('   :abstractmethod:', sourcename)\n2082         if inspect.iscoroutinefunction(obj):\n2083             self.add_line('   :async:', sourcename)\n2084         if inspect.isclassmethod(obj):\n2085             self.add_line('   :classmethod:', sourcename)\n2086         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n2087             self.add_line('   :staticmethod:', sourcename)\n2088         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n2089             self.add_line('   :final:', sourcename)\n2090 \n2091     def document_members(self, all_members: bool = False) -> None:\n2092         pass\n2093 \n2094     def format_signature(self, **kwargs: Any) -> str:\n2095         sigs = []\n2096         if (self.analyzer and\n2097                 '.'.join(self.objpath) in self.analyzer.overloads and\n2098                 self.config.autodoc_typehints == 'signature'):\n2099             # Use signatures for overloaded methods instead of the implementation method.\n2100             overloaded = True\n2101         else:\n2102             overloaded = False\n2103             sig = super().format_signature(**kwargs)\n2104             sigs.append(sig)\n2105 \n2106         meth = self.parent.__dict__.get(self.objpath[-1])\n2107         if inspect.is_singledispatch_method(meth):\n2108             # append signature of singledispatch'ed functions\n2109             for typ, func in meth.dispatcher.registry.items():\n2110                 if typ is object:\n2111                     pass  # default implementation. skipped.\n2112                 else:\n2113                     self.annotate_to_first_argument(func, typ)\n2114 \n2115                     documenter = MethodDocumenter(self.directive, '')\n2116                     documenter.parent = self.parent\n2117                     documenter.object = func\n2118                     documenter.objpath = [None]\n2119                     sigs.append(documenter.format_signature())\n2120         if overloaded:\n2121             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2122                 actual = inspect.signature(self.object, bound_method=False,\n2123                                            type_aliases=self.config.autodoc_type_aliases)\n2124             else:\n2125                 actual = inspect.signature(self.object, bound_method=True,\n2126                                            type_aliases=self.config.autodoc_type_aliases)\n2127 \n2128             __globals__ = safe_getattr(self.object, '__globals__', {})\n2129             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n2130                 overload = self.merge_default_value(actual, overload)\n2131                 overload = evaluate_signature(overload, __globals__,\n2132                                               self.config.autodoc_type_aliases)\n2133 \n2134                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n2135                                               name=self.object_name):\n2136                     parameters = list(overload.parameters.values())\n2137                     overload = overload.replace(parameters=parameters[1:])\n2138                 sig = stringify_signature(overload, **kwargs)\n2139                 sigs.append(sig)\n2140 \n2141         return \"\\n\".join(sigs)\n2142 \n2143     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n2144         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n2145         parameters = list(overload.parameters.values())\n2146         for i, param in enumerate(parameters):\n2147             actual_param = actual.parameters.get(param.name)\n2148             if actual_param and param.default == '...':\n2149                 parameters[i] = param.replace(default=actual_param.default)\n2150 \n2151         return overload.replace(parameters=parameters)\n2152 \n2153     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n2154         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n2155         try:\n2156             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n2157         except TypeError as exc:\n2158             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2159                            self.fullname, exc)\n2160             return\n2161         except ValueError:\n2162             return\n2163         if len(sig.parameters) == 1:\n2164             return\n2165 \n2166         params = list(sig.parameters.values())\n2167         if params[1].annotation is Parameter.empty:\n2168             params[1] = params[1].replace(annotation=typ)\n2169             try:\n2170                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n2171             except (AttributeError, TypeError):\n2172                 # failed to update signature (ex. built-in or extension types)\n2173                 return\n2174 \n2175 \n2176 class NonDataDescriptorMixin(DataDocumenterMixinBase):\n2177     \"\"\"\n2178     Mixin for AttributeDocumenter to provide the feature for supporting non\n2179     data-descriptors.\n2180 \n2181     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring\n2182               and :value: header will be suppressed unexpectedly.\n2183     \"\"\"\n2184 \n2185     def import_object(self, raiseerror: bool = False) -> bool:\n2186         ret = super().import_object(raiseerror)  # type: ignore\n2187         if ret and not inspect.isattributedescriptor(self.object):\n2188             self.non_data_descriptor = True\n2189         else:\n2190             self.non_data_descriptor = False\n2191 \n2192         return ret\n2193 \n2194     def should_suppress_value_header(self) -> bool:\n2195         return (not getattr(self, 'non_data_descriptor', False) or\n2196                 super().should_suppress_directive_header())\n2197 \n2198     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2199         if getattr(self, 'non_data_descriptor', False):\n2200             # the docstring of non datadescriptor is very probably the wrong thing\n2201             # to display\n2202             return None\n2203         else:\n2204             return super().get_doc(ignore)  # type: ignore\n2205 \n2206 \n2207 class SlotsMixin(DataDocumenterMixinBase):\n2208     \"\"\"\n2209     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.\n2210     \"\"\"\n2211 \n2212     def isslotsattribute(self) -> bool:\n2213         \"\"\"Check the subject is an attribute in __slots__.\"\"\"\n2214         try:\n2215             __slots__ = inspect.getslots(self.parent)\n2216             if __slots__ and self.objpath[-1] in __slots__:\n2217                 return True\n2218             else:\n2219                 return False\n2220         except (ValueError, TypeError):\n2221             return False\n2222 \n2223     def import_object(self, raiseerror: bool = False) -> bool:\n2224         ret = super().import_object(raiseerror)  # type: ignore\n2225         if self.isslotsattribute():\n2226             self.object = SLOTSATTR\n2227 \n2228         return ret\n2229 \n2230     def should_suppress_directive_header(self) -> bool:\n2231         if self.object is SLOTSATTR:\n2232             self._datadescriptor = True\n2233             return True\n2234         else:\n2235             return super().should_suppress_directive_header()\n2236 \n2237     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2238         if self.object is SLOTSATTR:\n2239             try:\n2240                 __slots__ = inspect.getslots(self.parent)\n2241                 if __slots__ and __slots__.get(self.objpath[-1]):\n2242                     docstring = prepare_docstring(__slots__[self.objpath[-1]])\n2243                     return [docstring]\n2244                 else:\n2245                     return []\n2246             except ValueError as exc:\n2247                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),\n2248                                (self.parent.__qualname__, exc), type='autodoc')\n2249                 return []\n2250         else:\n2251             return super().get_doc(ignore)  # type: ignore\n2252 \n2253 \n2254 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\n2255     \"\"\"\n2256     Mixin for AttributeDocumenter to provide the feature for supporting runtime\n2257     instance attributes (that are defined in __init__() methods with doc-comments).\n2258 \n2259     Example:\n2260 \n2261         class Foo:\n2262             def __init__(self):\n2263                 self.attr = None  #: This is a target of this mix-in.\n2264     \"\"\"\n2265 \n2266     RUNTIME_INSTANCE_ATTRIBUTE = object()\n2267 \n2268     def is_runtime_instance_attribute(self, parent: Any) -> bool:\n2269         \"\"\"Check the subject is an attribute defined in __init__().\"\"\"\n2270         # An instance variable defined in __init__().\n2271         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore\n2272             return True\n2273         else:\n2274             return False\n2275 \n2276     def import_object(self, raiseerror: bool = False) -> bool:\n2277         \"\"\"Check the existence of runtime instance attribute when failed to import the\n2278         attribute.\"\"\"\n2279         try:\n2280             return super().import_object(raiseerror=True)  # type: ignore\n2281         except ImportError as exc:\n2282             try:\n2283                 with mock(self.config.autodoc_mock_imports):\n2284                     ret = import_object(self.modname, self.objpath[:-1], 'class',\n2285                                         attrgetter=self.get_attr,  # type: ignore\n2286                                         warningiserror=self.config.autodoc_warningiserror)\n2287                     parent = ret[3]\n2288                     if self.is_runtime_instance_attribute(parent):\n2289                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE\n2290                         self.parent = parent\n2291                         return True\n2292             except ImportError:\n2293                 pass\n2294 \n2295             if raiseerror:\n2296                 raise\n2297             else:\n2298                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2299                 self.env.note_reread()\n2300                 return False\n2301 \n2302     def should_suppress_value_header(self) -> bool:\n2303         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or\n2304                 super().should_suppress_value_header())\n2305 \n2306 \n2307 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\n2308     \"\"\"\n2309     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized\n2310     instance attributes (PEP-526 styled, annotation only attributes).\n2311 \n2312     Example:\n2313 \n2314         class Foo:\n2315             attr: int  #: This is a target of this mix-in.\n2316     \"\"\"\n2317 \n2318     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:\n2319         \"\"\"Check the subject is an annotation only attribute.\"\"\"\n2320         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)\n2321         if self.objpath[-1] in annotations:\n2322             return True\n2323         else:\n2324             return False\n2325 \n2326     def import_object(self, raiseerror: bool = False) -> bool:\n2327         \"\"\"Check the exisitence of uninitialized instance attribute when failed to import\n2328         the attribute.\"\"\"\n2329         try:\n2330             return super().import_object(raiseerror=True)  # type: ignore\n2331         except ImportError as exc:\n2332             try:\n2333                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2334                                     attrgetter=self.get_attr,  # type: ignore\n2335                                     warningiserror=self.config.autodoc_warningiserror)\n2336                 parent = ret[3]\n2337                 if self.is_uninitialized_instance_attribute(parent):\n2338                     self.object = UNINITIALIZED_ATTR\n2339                     self.parent = parent\n2340                     return True\n2341             except ImportError:\n2342                 pass\n2343 \n2344             if raiseerror:\n2345                 raise\n2346             else:\n2347                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2348                 self.env.note_reread()\n2349                 return False\n2350 \n2351     def should_suppress_value_header(self) -> bool:\n2352         return (self.object is UNINITIALIZED_ATTR or\n2353                 super().should_suppress_value_header())\n2354 \n2355     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2356         if self.object is UNINITIALIZED_ATTR:\n2357             return None\n2358         else:\n2359             return super().get_doc(ignore)  # type: ignore\n2360 \n2361 \n2362 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n2363                           TypeVarMixin, RuntimeInstanceAttributeMixin,\n2364                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n2365                           DocstringStripSignatureMixin, ClassLevelDocumenter):\n2366     \"\"\"\n2367     Specialized Documenter subclass for attributes.\n2368     \"\"\"\n2369     objtype = 'attribute'\n2370     member_order = 60\n2371     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n2372     option_spec[\"annotation\"] = annotation_option\n2373     option_spec[\"no-value\"] = bool_option\n2374 \n2375     # must be higher than the MethodDocumenter, else it will recognize\n2376     # some non-data descriptors as methods\n2377     priority = 10\n2378 \n2379     @staticmethod\n2380     def is_function_or_method(obj: Any) -> bool:\n2381         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n2382 \n2383     @classmethod\n2384     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2385                             ) -> bool:\n2386         if inspect.isattributedescriptor(member):\n2387             return True\n2388         elif (not isinstance(parent, ModuleDocumenter) and\n2389               not inspect.isroutine(member) and\n2390               not isinstance(member, type)):\n2391             return True\n2392         else:\n2393             return False\n2394 \n2395     def document_members(self, all_members: bool = False) -> None:\n2396         pass\n2397 \n2398     def isinstanceattribute(self) -> bool:\n2399         \"\"\"Check the subject is an instance attribute.\"\"\"\n2400         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n2401                       RemovedInSphinx50Warning)\n2402         # uninitialized instance variable (PEP-526)\n2403         with mock(self.config.autodoc_mock_imports):\n2404             try:\n2405                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2406                                     attrgetter=self.get_attr,\n2407                                     warningiserror=self.config.autodoc_warningiserror)\n2408                 self.parent = ret[3]\n2409                 annotations = get_type_hints(self.parent, None,\n2410                                              self.config.autodoc_type_aliases)\n2411                 if self.objpath[-1] in annotations:\n2412                     self.object = UNINITIALIZED_ATTR\n2413                     return True\n2414             except ImportError:\n2415                 pass\n2416 \n2417         return False\n2418 \n2419     def update_annotations(self, parent: Any) -> None:\n2420         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n2421         try:\n2422             annotations = dict(inspect.getannotations(parent))\n2423             parent.__annotations__ = annotations\n2424 \n2425             for cls in inspect.getmro(parent):\n2426                 try:\n2427                     module = safe_getattr(cls, '__module__')\n2428                     qualname = safe_getattr(cls, '__qualname__')\n2429 \n2430                     analyzer = ModuleAnalyzer.for_module(module)\n2431                     analyzer.analyze()\n2432                     for (classname, attrname), annotation in analyzer.annotations.items():\n2433                         if classname == qualname and attrname not in annotations:\n2434                             annotations[attrname] = annotation\n2435                 except (AttributeError, PycodeError):\n2436                     pass\n2437         except (AttributeError, TypeError):\n2438             # Failed to set __annotations__ (built-in, extensions, etc.)\n2439             pass\n2440 \n2441     def import_object(self, raiseerror: bool = False) -> bool:\n2442         ret = super().import_object(raiseerror)\n2443         if inspect.isenumattribute(self.object):\n2444             self.object = self.object.value\n2445         if self.parent:\n2446             self.update_annotations(self.parent)\n2447 \n2448         return ret\n2449 \n2450     def get_real_modname(self) -> str:\n2451         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2452             or self.modname\n2453 \n2454     def should_suppress_value_header(self) -> bool:\n2455         if super().should_suppress_value_header():\n2456             return True\n2457         else:\n2458             doc = self.get_doc()\n2459             if doc:\n2460                 metadata = extract_metadata('\\n'.join(sum(doc, [])))\n2461                 if 'hide-value' in metadata:\n2462                     return True\n2463 \n2464         return False\n2465 \n2466     def add_directive_header(self, sig: str) -> None:\n2467         super().add_directive_header(sig)\n2468         sourcename = self.get_sourcename()\n2469         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n2470             pass\n2471         elif self.options.annotation:\n2472             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2473         else:\n2474             # obtain type annotation for this attribute\n2475             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n2476             if self.objpath[-1] in annotations:\n2477                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2478                 self.add_line('   :type: ' + objrepr, sourcename)\n2479 \n2480             try:\n2481                 if self.options.no_value or self.should_suppress_value_header():\n2482                     pass\n2483                 else:\n2484                     objrepr = object_description(self.object)\n2485                     self.add_line('   :value: ' + objrepr, sourcename)\n2486             except ValueError:\n2487                 pass\n2488 \n2489     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:\n2490         for cls in inspect.getmro(parent):\n2491             try:\n2492                 module = safe_getattr(cls, '__module__')\n2493                 qualname = safe_getattr(cls, '__qualname__')\n2494 \n2495                 analyzer = ModuleAnalyzer.for_module(module)\n2496                 analyzer.analyze()\n2497                 if qualname and self.objpath:\n2498                     key = (qualname, attrname)\n2499                     if key in analyzer.attr_docs:\n2500                         return list(analyzer.attr_docs[key])\n2501             except (AttributeError, PycodeError):\n2502                 pass\n2503 \n2504         return None\n2505 \n2506     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2507         # Check the attribute has a docstring-comment\n2508         comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n2509         if comment:\n2510             return [comment]\n2511 \n2512         try:\n2513             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2514             # a docstring from the value which descriptor returns unexpectedly.\n2515             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2516             orig = self.config.autodoc_inherit_docstrings\n2517             self.config.autodoc_inherit_docstrings = False  # type: ignore\n2518             return super().get_doc(ignore)\n2519         finally:\n2520             self.config.autodoc_inherit_docstrings = orig  # type: ignore\n2521 \n2522     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n2523                     ) -> None:\n2524         # Disable analyzing attribute comment on Documenter.add_content() to control it on\n2525         # AttributeDocumenter.add_content()\n2526         self.analyzer = None\n2527 \n2528         if more_content is None:\n2529             more_content = StringList()\n2530         self.update_content(more_content)\n2531         super().add_content(more_content, no_docstring)\n2532 \n2533 \n2534 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2535     \"\"\"\n2536     Specialized Documenter subclass for properties.\n2537     \"\"\"\n2538     objtype = 'property'\n2539     member_order = 60\n2540 \n2541     # before AttributeDocumenter\n2542     priority = AttributeDocumenter.priority + 1\n2543 \n2544     @classmethod\n2545     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2546                             ) -> bool:\n2547         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n2548 \n2549     def document_members(self, all_members: bool = False) -> None:\n2550         pass\n2551 \n2552     def get_real_modname(self) -> str:\n2553         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2554             or self.modname\n2555 \n2556     def add_directive_header(self, sig: str) -> None:\n2557         super().add_directive_header(sig)\n2558         sourcename = self.get_sourcename()\n2559         if inspect.isabstractmethod(self.object):\n2560             self.add_line('   :abstractmethod:', sourcename)\n2561 \n2562         if safe_getattr(self.object, 'fget', None):\n2563             try:\n2564                 signature = inspect.signature(self.object.fget,\n2565                                               type_aliases=self.config.autodoc_type_aliases)\n2566                 if signature.return_annotation is not Parameter.empty:\n2567                     objrepr = stringify_typehint(signature.return_annotation)\n2568                     self.add_line('   :type: ' + objrepr, sourcename)\n2569             except TypeError as exc:\n2570                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n2571                                self.fullname, exc)\n2572                 return None\n2573             except ValueError:\n2574                 raise\n2575 \n2576 \n2577 class NewTypeAttributeDocumenter(AttributeDocumenter):\n2578     \"\"\"\n2579     Specialized Documenter subclass for NewTypes.\n2580 \n2581     Note: This must be invoked before MethodDocumenter because NewType is a kind of\n2582     function object.\n2583     \"\"\"\n2584 \n2585     objtype = 'newvarattribute'\n2586     directivetype = 'attribute'\n2587     priority = MethodDocumenter.priority + 1\n2588 \n2589     @classmethod\n2590     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2591                             ) -> bool:\n2592         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)\n2593 \n2594 \n2595 def get_documenters(app: Sphinx) -> Dict[str, Type[Documenter]]:\n2596     \"\"\"Returns registered Documenter classes\"\"\"\n2597     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2598     return app.registry.documenters\n2599 \n2600 \n2601 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2602     \"\"\"Alternative getattr() for types\"\"\"\n2603     for typ, func in app.registry.autodoc_attrgettrs.items():\n2604         if isinstance(obj, typ):\n2605             return func(obj, name, *defargs)\n2606 \n2607     return safe_getattr(obj, name, *defargs)\n2608 \n2609 \n2610 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2611     if config.autodoc_member_order == 'alphabetic':\n2612         # RemovedInSphinx50Warning\n2613         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2614                           'instead of \"alphabetic\". Please update your setting.'))\n2615         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2616 \n2617 \n2618 # for compatibility\n2619 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2620 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2621 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2622 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2623 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2624 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2625 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2626 \n2627 \n2628 def setup(app: Sphinx) -> Dict[str, Any]:\n2629     app.add_autodocumenter(ModuleDocumenter)\n2630     app.add_autodocumenter(ClassDocumenter)\n2631     app.add_autodocumenter(ExceptionDocumenter)\n2632     app.add_autodocumenter(DataDocumenter)\n2633     app.add_autodocumenter(NewTypeDataDocumenter)\n2634     app.add_autodocumenter(FunctionDocumenter)\n2635     app.add_autodocumenter(DecoratorDocumenter)\n2636     app.add_autodocumenter(MethodDocumenter)\n2637     app.add_autodocumenter(AttributeDocumenter)\n2638     app.add_autodocumenter(PropertyDocumenter)\n2639     app.add_autodocumenter(NewTypeAttributeDocumenter)\n2640 \n2641     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2642     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2643                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2644     app.add_config_value('autodoc_default_options', {}, True)\n2645     app.add_config_value('autodoc_docstring_signature', True, True)\n2646     app.add_config_value('autodoc_mock_imports', [], True)\n2647     app.add_config_value('autodoc_typehints', \"signature\", True,\n2648                          ENUM(\"signature\", \"description\", \"none\"))\n2649     app.add_config_value('autodoc_typehints_description_target', 'all', True,\n2650                          ENUM('all', 'documented'))\n2651     app.add_config_value('autodoc_type_aliases', {}, True)\n2652     app.add_config_value('autodoc_warningiserror', True, True)\n2653     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2654     app.add_event('autodoc-before-process-signature')\n2655     app.add_event('autodoc-process-docstring')\n2656     app.add_event('autodoc-process-signature')\n2657     app.add_event('autodoc-skip-member')\n2658 \n2659     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2660 \n2661     app.setup_extension('sphinx.ext.autodoc.preserve_defaults')\n2662     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2663     app.setup_extension('sphinx.ext.autodoc.typehints')\n2664 \n2665     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "Ensure that automatic documentation generation from docstrings continues to work seamlessly with `docutils-0.17b1`, without introducing any regressions or incompatibilities."
    },
    {
        "rel_file_path": "sphinx/parsers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/parsers.py",
        "start": 1,
        "end": 116,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.parsers\n3     ~~~~~~~~~~~~~~\n4 \n5     A Base class for additional parsers.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import warnings\n12 from typing import TYPE_CHECKING, Any, Dict, List, Type, Union\n13 \n14 import docutils.parsers\n15 import docutils.parsers.rst\n16 from docutils import nodes\n17 from docutils.parsers.rst import states\n18 from docutils.statemachine import StringList\n19 from docutils.transforms import Transform\n20 from docutils.transforms.universal import SmartQuotes\n21 \n22 from sphinx.deprecation import RemovedInSphinx50Warning\n23 from sphinx.util.rst import append_epilog, prepend_prolog\n24 \n25 if TYPE_CHECKING:\n26     from sphinx.application import Sphinx\n27 \n28 \n29 class Parser(docutils.parsers.Parser):\n30     \"\"\"\n31     A base class of source parsers.  The additional parsers should inherit this class instead\n32     of ``docutils.parsers.Parser``.  Compared with ``docutils.parsers.Parser``, this class\n33     improves accessibility to Sphinx APIs.\n34 \n35     The subclasses can access following objects and functions:\n36 \n37     self.app\n38         The application object (:class:`sphinx.application.Sphinx`)\n39     self.config\n40         The config object (:class:`sphinx.config.Config`)\n41     self.env\n42         The environment object (:class:`sphinx.environment.BuildEnvironment`)\n43     self.warn()\n44         Emit a warning. (Same as :meth:`sphinx.application.Sphinx.warn()`)\n45     self.info()\n46         Emit a informational message. (Same as :meth:`sphinx.application.Sphinx.info()`)\n47 \n48     .. deprecated:: 1.6\n49        ``warn()`` and ``info()`` is deprecated.  Use :mod:`sphinx.util.logging` instead.\n50     .. deprecated:: 3.0\n51        parser.app is deprecated.\n52     \"\"\"\n53 \n54     def set_application(self, app: \"Sphinx\") -> None:\n55         \"\"\"set_application will be called from Sphinx to set app and other instance variables\n56 \n57         :param sphinx.application.Sphinx app: Sphinx application object\n58         \"\"\"\n59         self._app = app\n60         self.config = app.config\n61         self.env = app.env\n62 \n63     @property\n64     def app(self) -> \"Sphinx\":\n65         warnings.warn('parser.app is deprecated.', RemovedInSphinx50Warning, stacklevel=2)\n66         return self._app\n67 \n68 \n69 class RSTParser(docutils.parsers.rst.Parser, Parser):\n70     \"\"\"A reST parser for Sphinx.\"\"\"\n71 \n72     def get_transforms(self) -> List[Type[Transform]]:\n73         \"\"\"Sphinx's reST parser replaces a transform class for smart-quotes by own's\n74 \n75         refs: sphinx.io.SphinxStandaloneReader\n76         \"\"\"\n77         transforms = super().get_transforms()\n78         transforms.remove(SmartQuotes)\n79         return transforms\n80 \n81     def parse(self, inputstring: Union[str, StringList], document: nodes.document) -> None:\n82         \"\"\"Parse text and generate a document tree.\"\"\"\n83         self.setup_parse(inputstring, document)  # type: ignore\n84         self.statemachine = states.RSTStateMachine(\n85             state_classes=self.state_classes,\n86             initial_state=self.initial_state,\n87             debug=document.reporter.debug_flag)\n88 \n89         # preprocess inputstring\n90         if isinstance(inputstring, str):\n91             lines = docutils.statemachine.string2lines(\n92                 inputstring, tab_width=document.settings.tab_width,\n93                 convert_whitespace=True)\n94 \n95             inputlines = StringList(lines, document.current_source)\n96         else:\n97             inputlines = inputstring\n98 \n99         self.decorate(inputlines)\n100         self.statemachine.run(inputlines, document, inliner=self.inliner)\n101         self.finish_parse()\n102 \n103     def decorate(self, content: StringList) -> None:\n104         \"\"\"Preprocess reST content before parsing.\"\"\"\n105         prepend_prolog(content, self.config.rst_prolog)\n106         append_epilog(content, self.config.rst_epilog)\n107 \n108 \n109 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n110     app.add_source_parser(RSTParser)\n111 \n112     return {\n113         'version': 'builtin',\n114         'parallel_read_safe': True,\n115         'parallel_write_safe': True,\n116     }\n",
        "intended_behavior": "Ensure that all document parsing functionalities maintain their behavior with the newer version of `docutils`. Adjustments may be necessary if `0.17b1` modifies any parsing APIs or behaviors that Sphinx relies upon."
    },
    {
        "rel_file_path": "sphinx/deprecation.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/deprecation.py",
        "start": 1,
        "end": 93,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.deprecation\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Sphinx deprecation classes and utilities.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import sys\n12 import warnings\n13 from importlib import import_module\n14 from typing import Any, Dict, Type\n15 \n16 \n17 class RemovedInSphinx40Warning(DeprecationWarning):\n18     pass\n19 \n20 \n21 class RemovedInSphinx50Warning(DeprecationWarning):\n22     pass\n23 \n24 \n25 class RemovedInSphinx60Warning(PendingDeprecationWarning):\n26     pass\n27 \n28 \n29 RemovedInNextVersionWarning = RemovedInSphinx50Warning\n30 \n31 \n32 def deprecated_alias(modname: str, objects: Dict[str, object],\n33                      warning: Type[Warning], names: Dict[str, str] = {}) -> None:\n34     module = import_module(modname)\n35     sys.modules[modname] = _ModuleWrapper(  # type: ignore\n36         module, modname, objects, warning, names)\n37 \n38 \n39 class _ModuleWrapper:\n40     def __init__(self, module: Any, modname: str,\n41                  objects: Dict[str, object],\n42                  warning: Type[Warning],\n43                  names: Dict[str, str]) -> None:\n44         self._module = module\n45         self._modname = modname\n46         self._objects = objects\n47         self._warning = warning\n48         self._names = names\n49 \n50     def __getattr__(self, name: str) -> Any:\n51         if name not in self._objects:\n52             return getattr(self._module, name)\n53 \n54         canonical_name = self._names.get(name, None)\n55         if canonical_name is not None:\n56             warnings.warn(\n57                 \"The alias '{}.{}' is deprecated, use '{}' instead. Check CHANGES for \"\n58                 \"Sphinx API modifications.\".format(self._modname, name, canonical_name),\n59                 self._warning, stacklevel=3)\n60         else:\n61             warnings.warn(\"{}.{} is deprecated. Check CHANGES for Sphinx \"\n62                           \"API modifications.\".format(self._modname, name),\n63                           self._warning, stacklevel=3)\n64         return self._objects[name]\n65 \n66 \n67 class DeprecatedDict(dict):\n68     \"\"\"A deprecated dict which warns on each access.\"\"\"\n69 \n70     def __init__(self, data: Dict, message: str, warning: Type[Warning]) -> None:\n71         self.message = message\n72         self.warning = warning\n73         super().__init__(data)\n74 \n75     def __setitem__(self, key: str, value: Any) -> None:\n76         warnings.warn(self.message, self.warning, stacklevel=2)\n77         super().__setitem__(key, value)\n78 \n79     def setdefault(self, key: str, default: Any = None) -> Any:\n80         warnings.warn(self.message, self.warning, stacklevel=2)\n81         return super().setdefault(key, default)\n82 \n83     def __getitem__(self, key: str) -> None:\n84         warnings.warn(self.message, self.warning, stacklevel=2)\n85         return super().__getitem__(key)\n86 \n87     def get(self, key: str, default: Any = None) -> Any:\n88         warnings.warn(self.message, self.warning, stacklevel=2)\n89         return super().get(key, default)\n90 \n91     def update(self, other: Dict) -> None:  # type: ignore\n92         warnings.warn(self.message, self.warning, stacklevel=2)\n93         super().update(other)\n",
        "intended_behavior": "Ensure that no deprecated `docutils` APIs are used by Sphinx, or if they are, to update them to the current APIs provided by `docutils-0.17b1`. Shift away from deprecated APIs, ensuring compatibility with new versions."
    }
]