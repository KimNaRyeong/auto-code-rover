[
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/config.py",
        "start": 1,
        "end": 492,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.config\n3     ~~~~~~~~~~~~~\n4 \n5     Build configuration file handling.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import traceback\n13 import types\n14 import warnings\n15 from collections import OrderedDict\n16 from os import path, getenv\n17 from typing import (\n18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union\n19 )\n20 \n21 from sphinx.deprecation import RemovedInSphinx40Warning\n22 from sphinx.errors import ConfigError, ExtensionError\n23 from sphinx.locale import _, __\n24 from sphinx.util import logging\n25 from sphinx.util.i18n import format_date\n26 from sphinx.util.osutil import cd\n27 from sphinx.util.pycompat import execfile_\n28 from sphinx.util.tags import Tags\n29 from sphinx.util.typing import NoneType\n30 \n31 if False:\n32     # For type annotation\n33     from sphinx.application import Sphinx\n34     from sphinx.environment import BuildEnvironment\n35 \n36 logger = logging.getLogger(__name__)\n37 \n38 CONFIG_FILENAME = 'conf.py'\n39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\n40 copyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n41 \n42 ConfigValue = NamedTuple('ConfigValue', [('name', str),\n43                                          ('value', Any),\n44                                          ('rebuild', Union[bool, str])])\n45 \n46 \n47 def is_serializable(obj: Any) -> bool:\n48     \"\"\"Check if object is serializable or not.\"\"\"\n49     if isinstance(obj, UNSERIALIZABLE_TYPES):\n50         return False\n51     elif isinstance(obj, dict):\n52         for key, value in obj.items():\n53             if not is_serializable(key) or not is_serializable(value):\n54                 return False\n55     elif isinstance(obj, (list, tuple, set)):\n56         return all(is_serializable(i) for i in obj)\n57 \n58     return True\n59 \n60 \n61 class ENUM:\n62     \"\"\"represents the config value should be a one of candidates.\n63 \n64     Example:\n65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))\n66     \"\"\"\n67     def __init__(self, *candidates: str) -> None:\n68         self.candidates = candidates\n69 \n70     def match(self, value: Union[str, List, Tuple]) -> bool:\n71         if isinstance(value, (list, tuple)):\n72             return all(item in self.candidates for item in value)\n73         else:\n74             return value in self.candidates\n75 \n76 \n77 # RemovedInSphinx40Warning\n78 string_classes = [str]  # type: List\n79 \n80 \n81 class Config:\n82     \"\"\"Configuration file abstraction.\n83 \n84     The config object makes the values of all config values available as\n85     attributes.\n86 \n87     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n89     to get the value of :confval:`language`, use either ``app.config.language``\n90     or ``env.config.language``.\n91     \"\"\"\n92 \n93     # the values are: (default, what needs to be rebuilt if changed)\n94 \n95     # If you add a value here, don't forget to include it in the\n96     # quickstart.py file template as well as in the docs!\n97 \n98     config_values = {\n99         # general options\n100         'project': ('Python', 'env', []),\n101         'author': ('unknown', 'env', []),\n102         'copyright': ('', 'html', []),\n103         'version': ('', 'env', []),\n104         'release': ('', 'env', []),\n105         'today': ('', 'env', []),\n106         # the real default is locale-dependent\n107         'today_fmt': (None, 'env', [str]),\n108 \n109         'language': (None, 'env', [str]),\n110         'locale_dirs': (['locales'], 'env', []),\n111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n112 \n113         'master_doc': ('index', 'env', []),\n114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n115         'source_encoding': ('utf-8-sig', 'env', []),\n116         'source_parsers': ({}, 'env', []),\n117         'exclude_patterns': ([], 'env', []),\n118         'default_role': (None, 'env', [str]),\n119         'add_function_parentheses': (True, 'env', []),\n120         'add_module_names': (True, 'env', []),\n121         'trim_footnote_reference_space': (False, 'env', []),\n122         'show_authors': (False, 'env', []),\n123         'pygments_style': (None, 'html', [str]),\n124         'highlight_language': ('default', 'env', []),\n125         'highlight_options': ({}, 'env', []),\n126         'templates_path': ([], 'html', []),\n127         'template_bridge': (None, 'html', [str]),\n128         'keep_warnings': (False, 'env', []),\n129         'suppress_warnings': ([], 'env', []),\n130         'modindex_common_prefix': ([], 'html', []),\n131         'rst_epilog': (None, 'env', [str]),\n132         'rst_prolog': (None, 'env', [str]),\n133         'trim_doctest_flags': (True, 'env', []),\n134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n135         'needs_sphinx': (None, None, [str]),\n136         'needs_extensions': ({}, None, []),\n137         'manpages_url': (None, 'env', []),\n138         'nitpicky': (False, None, []),\n139         'nitpick_ignore': ([], None, []),\n140         'numfig': (False, 'env', []),\n141         'numfig_secnum_depth': (1, 'env', []),\n142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n143 \n144         'math_number_all': (False, 'env', []),\n145         'math_eqref_format': (None, 'env', [str]),\n146         'math_numfig': (True, 'env', []),\n147         'tls_verify': (True, 'env', []),\n148         'tls_cacerts': (None, 'env', []),\n149         'user_agent': (None, 'env', [str]),\n150         'smartquotes': (True, 'env', []),\n151         'smartquotes_action': ('qDe', 'env', []),\n152         'smartquotes_excludes': ({'languages': ['ja'],\n153                                   'builders': ['man', 'text']},\n154                                  'env', []),\n155     }  # type: Dict[str, Tuple]\n156 \n157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n158         self.overrides = dict(overrides)\n159         self.values = Config.config_values.copy()\n160         self._raw_config = config\n161         self.setup = config.get('setup', None)  # type: Callable\n162 \n163         if 'extensions' in self.overrides:\n164             if isinstance(self.overrides['extensions'], str):\n165                 config['extensions'] = self.overrides.pop('extensions').split(',')\n166             else:\n167                 config['extensions'] = self.overrides.pop('extensions')\n168         self.extensions = config.get('extensions', [])  # type: List[str]\n169 \n170     @classmethod\n171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n172         \"\"\"Create a Config object from configuration file.\"\"\"\n173         filename = path.join(confdir, CONFIG_FILENAME)\n174         namespace = eval_config_file(filename, tags)\n175         return cls(namespace, overrides or {})\n176 \n177     def convert_overrides(self, name: str, value: Any) -> Any:\n178         if not isinstance(value, str):\n179             return value\n180         else:\n181             defvalue = self.values[name][0]\n182             if self.values[name][2] == Any:\n183                 return value\n184             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n185                 if value == '0':\n186                     # given falsy string from command line option\n187                     return False\n188                 else:\n189                     return bool(value)\n190             elif isinstance(defvalue, dict):\n191                 raise ValueError(__('cannot override dictionary config setting %r, '\n192                                     'ignoring (use %r to set individual elements)') %\n193                                  (name, name + '.key=value'))\n194             elif isinstance(defvalue, list):\n195                 return value.split(',')\n196             elif isinstance(defvalue, int):\n197                 try:\n198                     return int(value)\n199                 except ValueError:\n200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n201                                      (value, name))\n202             elif hasattr(defvalue, '__call__'):\n203                 return value\n204             elif defvalue is not None and not isinstance(defvalue, str):\n205                 raise ValueError(__('cannot override config setting %r with unsupported '\n206                                     'type, ignoring') % name)\n207             else:\n208                 return value\n209 \n210     def pre_init_values(self) -> None:\n211         \"\"\"\n212         Initialize some limited config variables before initialize i18n and loading extensions\n213         \"\"\"\n214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n215         for name in variables:\n216             try:\n217                 if name in self.overrides:\n218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n219                 elif name in self._raw_config:\n220                     self.__dict__[name] = self._raw_config[name]\n221             except ValueError as exc:\n222                 logger.warning(\"%s\", exc)\n223 \n224     def init_values(self) -> None:\n225         config = self._raw_config\n226         for valname, value in self.overrides.items():\n227             try:\n228                 if '.' in valname:\n229                     realvalname, key = valname.split('.', 1)\n230                     config.setdefault(realvalname, {})[key] = value\n231                     continue\n232                 elif valname not in self.values:\n233                     logger.warning(__('unknown config value %r in override, ignoring'),\n234                                    valname)\n235                     continue\n236                 if isinstance(value, str):\n237                     config[valname] = self.convert_overrides(valname, value)\n238                 else:\n239                     config[valname] = value\n240             except ValueError as exc:\n241                 logger.warning(\"%s\", exc)\n242         for name in config:\n243             if name in self.values:\n244                 self.__dict__[name] = config[name]\n245 \n246     def __getattr__(self, name: str) -> Any:\n247         if name.startswith('_'):\n248             raise AttributeError(name)\n249         if name not in self.values:\n250             raise AttributeError(__('No such config value: %s') % name)\n251         default = self.values[name][0]\n252         if hasattr(default, '__call__'):\n253             return default(self)\n254         return default\n255 \n256     def __getitem__(self, name: str) -> str:\n257         return getattr(self, name)\n258 \n259     def __setitem__(self, name: str, value: Any) -> None:\n260         setattr(self, name, value)\n261 \n262     def __delitem__(self, name: str) -> None:\n263         delattr(self, name)\n264 \n265     def __contains__(self, name: str) -> bool:\n266         return name in self.values\n267 \n268     def __iter__(self) -> Generator[ConfigValue, None, None]:\n269         for name, value in self.values.items():\n270             yield ConfigValue(name, getattr(self, name), value[1])\n271 \n272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n273         if name in self.values:\n274             raise ExtensionError(__('Config value %r already present') % name)\n275         else:\n276             self.values[name] = (default, rebuild, types)\n277 \n278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n279         if isinstance(rebuild, str):\n280             rebuild = [rebuild]\n281         return (value for value in self if value.rebuild in rebuild)\n282 \n283     def __getstate__(self) -> Dict:\n284         \"\"\"Obtains serializable data for pickling.\"\"\"\n285         # remove potentially pickling-problematic values from config\n286         __dict__ = {}\n287         for key, value in self.__dict__.items():\n288             if key.startswith('_') or not is_serializable(value):\n289                 pass\n290             else:\n291                 __dict__[key] = value\n292 \n293         # create a picklable copy of values list\n294         __dict__['values'] = {}\n295         for key, value in self.values.items():\n296             real_value = getattr(self, key)\n297             if not is_serializable(real_value):\n298                 # omit unserializable value\n299                 real_value = None\n300 \n301             # types column is also omitted\n302             __dict__['values'][key] = (real_value, value[1], None)\n303 \n304         return __dict__\n305 \n306     def __setstate__(self, state: Dict) -> None:\n307         self.__dict__.update(state)\n308 \n309 \n310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:\n311     \"\"\"Evaluate a config file.\"\"\"\n312     namespace = {}  # type: Dict[str, Any]\n313     namespace['__file__'] = filename\n314     namespace['tags'] = tags\n315 \n316     with cd(path.dirname(filename)):\n317         # during executing config file, current dir is changed to ``confdir``.\n318         try:\n319             execfile_(filename, namespace)\n320         except SyntaxError as err:\n321             msg = __(\"There is a syntax error in your configuration file: %s\\n\")\n322             raise ConfigError(msg % err)\n323         except SystemExit:\n324             msg = __(\"The configuration file (or one of the modules it imports) \"\n325                      \"called sys.exit()\")\n326             raise ConfigError(msg)\n327         except ConfigError:\n328             # pass through ConfigError from conf.py as is.  It will be shown in console.\n329             raise\n330         except Exception:\n331             msg = __(\"There is a programmable error in your configuration file:\\n\\n%s\")\n332             raise ConfigError(msg % traceback.format_exc())\n333 \n334     return namespace\n335 \n336 \n337 def convert_source_suffix(app: \"Sphinx\", config: Config) -> None:\n338     \"\"\"This converts old styled source_suffix to new styled one.\n339 \n340     * old style: str or list\n341     * new style: a dict which maps from fileext to filetype\n342     \"\"\"\n343     source_suffix = config.source_suffix\n344     if isinstance(source_suffix, str):\n345         # if str, considers as default filetype (None)\n346         #\n347         # The default filetype is determined on later step.\n348         # By default, it is considered as restructuredtext.\n349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore\n350     elif isinstance(source_suffix, (list, tuple)):\n351         # if list, considers as all of them are default filetype\n352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA\n353     elif isinstance(source_suffix, dict):\n354         # if dict, convert it to OrderedDict\n355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore\n356     else:\n357         logger.warning(__(\"The config value `source_suffix' expects \"\n358                           \"a string, list of strings, or dictionary. \"\n359                           \"But `%r' is given.\" % source_suffix))\n360 \n361 \n362 def init_numfig_format(app: \"Sphinx\", config: Config) -> None:\n363     \"\"\"Initialize :confval:`numfig_format`.\"\"\"\n364     numfig_format = {'section': _('Section %s'),\n365                      'figure': _('Fig. %s'),\n366                      'table': _('Table %s'),\n367                      'code-block': _('Listing %s')}\n368 \n369     # override default labels by configuration\n370     numfig_format.update(config.numfig_format)\n371     config.numfig_format = numfig_format  # type: ignore\n372 \n373 \n374 def correct_copyright_year(app: \"Sphinx\", config: Config) -> None:\n375     \"\"\"correct values of copyright year that are not coherent with\n376     the SOURCE_DATE_EPOCH environment variable (if set)\n377 \n378     See https://reproducible-builds.org/specs/source-date-epoch/\n379     \"\"\"\n380     if getenv('SOURCE_DATE_EPOCH') is not None:\n381         for k in ('copyright', 'epub_copyright'):\n382             if k in config:\n383                 replace = r'\\g<1>%s' % format_date('%Y')\n384                 config[k] = copyright_year_re.sub(replace, config[k])\n385 \n386 \n387 def check_confval_types(app: \"Sphinx\", config: Config) -> None:\n388     \"\"\"check all values for deviation from the default value's type, since\n389     that can result in TypeErrors all over the place NB.\n390     \"\"\"\n391     for confval in config:\n392         default, rebuild, annotations = config.values[confval.name]\n393 \n394         if hasattr(default, '__call__'):\n395             default = default(config)  # evaluate default value\n396         if default is None and not annotations:\n397             continue  # neither inferrable nor expliclitly annotated types\n398 \n399         if annotations is Any:\n400             # any type of value is accepted\n401             pass\n402         elif isinstance(annotations, ENUM):\n403             if not annotations.match(confval.value):\n404                 msg = __(\"The config value `{name}` has to be a one of {candidates}, \"\n405                          \"but `{current}` is given.\")\n406                 logger.warning(msg.format(name=confval.name,\n407                                           current=confval.value,\n408                                           candidates=annotations.candidates))\n409         else:\n410             if type(confval.value) is type(default):\n411                 continue\n412             if type(confval.value) in annotations:\n413                 continue\n414 \n415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &\n416                             set(type(default).__bases__))\n417             common_bases.discard(object)\n418             if common_bases:\n419                 continue  # at least we share a non-trivial base class\n420 \n421             if annotations:\n422                 msg = __(\"The config value `{name}' has type `{current.__name__}'; \"\n423                          \"expected {permitted}.\")\n424                 wrapped_annotations = [\"`{}'\".format(c.__name__) for c in annotations]\n425                 if len(wrapped_annotations) > 2:\n426                     permitted = \"{}, or {}\".format(\n427                         \", \".join(wrapped_annotations[:-1]),\n428                         wrapped_annotations[-1])\n429                 else:\n430                     permitted = \" or \".join(wrapped_annotations)\n431                 logger.warning(msg.format(name=confval.name,\n432                                           current=type(confval.value),\n433                                           permitted=permitted))\n434             else:\n435                 msg = __(\"The config value `{name}' has type `{current.__name__}', \"\n436                          \"defaults to `{default.__name__}'.\")\n437                 logger.warning(msg.format(name=confval.name,\n438                                           current=type(confval.value),\n439                                           default=type(default)))\n440 \n441 \n442 def check_unicode(config: Config) -> None:\n443     \"\"\"check all string values for non-ASCII characters in bytestrings,\n444     since that can result in UnicodeErrors all over the place\n445     \"\"\"\n446     warnings.warn('sphinx.config.check_unicode() is deprecated.',\n447                   RemovedInSphinx40Warning)\n448 \n449     nonascii_re = re.compile(br'[\\x80-\\xff]')\n450 \n451     for name, value in config._raw_config.items():\n452         if isinstance(value, bytes) and nonascii_re.search(value):\n453             logger.warning(__('the config value %r is set to a string with non-ASCII '\n454                               'characters; this can lead to Unicode errors occurring. '\n455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')\n456 \n457 \n458 def check_primary_domain(app: \"Sphinx\", config: Config) -> None:\n459     primary_domain = config.primary_domain\n460     if primary_domain and not app.registry.has_domain(primary_domain):\n461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)\n462         config.primary_domain = None  # type: ignore\n463 \n464 \n465 def check_master_doc(app: \"Sphinx\", env: \"BuildEnvironment\", added: Set[str],\n466                      changed: Set[str], removed: Set[str]) -> Set[str]:\n467     \"\"\"Adjust master_doc to 'contents' to support an old project which does not have\n468     no master_doc setting.\n469     \"\"\"\n470     if (app.config.master_doc == 'index' and\n471             'index' not in app.project.docnames and\n472             'contents' in app.project.docnames):\n473         logger.warning(__('Since v2.0, Sphinx uses \"index\" as master_doc by default. '\n474                           'Please add \"master_doc = \\'contents\\'\" to your conf.py.'))\n475         app.config.master_doc = \"contents\"  # type: ignore\n476 \n477     return changed\n478 \n479 \n480 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n481     app.connect('config-inited', convert_source_suffix)\n482     app.connect('config-inited', init_numfig_format)\n483     app.connect('config-inited', correct_copyright_year)\n484     app.connect('config-inited', check_confval_types)\n485     app.connect('config-inited', check_primary_domain)\n486     app.connect('env-get-outdated', check_master_doc)\n487 \n488     return {\n489         'version': 'builtin',\n490         'parallel_read_safe': True,\n491         'parallel_write_safe': True,\n492     }\n",
        "intended_behavior": "This configuration file should be enhanced to allow users to specify preferences for handling situations where files have the same name but different extensions. Introducing a new configuration option like `file_extension_precedence` would enable users to define an ordered list of extensions that Sphinx should use to resolve conflicts. This list would be checked whenever Sphinx encounters files with the same base name, ensuring the user-preferred extension is selected. Existing functionality for projects not using this configuration should remain unchanged, preserving backward compatibility."
    },
    {
        "rel_file_path": "sphinx/environment/adapters/toctree.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/environment/adapters/toctree.py",
        "start": 1,
        "end": 336,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.environment.adapters.toctree\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Toctree adapter for sphinx.environment.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Iterable, List\n12 from typing import cast\n13 \n14 from docutils import nodes\n15 from docutils.nodes import Element, Node\n16 \n17 from sphinx import addnodes\n18 from sphinx.locale import __\n19 from sphinx.util import url_re, logging\n20 from sphinx.util.matching import Matcher\n21 from sphinx.util.nodes import clean_astext, process_only_nodes\n22 \n23 if False:\n24     # For type annotation\n25     from sphinx.builders import Builder\n26     from sphinx.environment import BuildEnvironment\n27 \n28 \n29 logger = logging.getLogger(__name__)\n30 \n31 \n32 class TocTree:\n33     def __init__(self, env: \"BuildEnvironment\") -> None:\n34         self.env = env\n35 \n36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:\n37         \"\"\"Note a TOC tree directive in a document and gather information about\n38         file relations from it.\n39         \"\"\"\n40         if toctreenode['glob']:\n41             self.env.glob_toctrees.add(docname)\n42         if toctreenode.get('numbered'):\n43             self.env.numbered_toctrees.add(docname)\n44         includefiles = toctreenode['includefiles']\n45         for includefile in includefiles:\n46             # note that if the included file is rebuilt, this one must be\n47             # too (since the TOC of the included file could have changed)\n48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)\n49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)\n50 \n51     def resolve(self, docname: str, builder: \"Builder\", toctree: addnodes.toctree,\n52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,\n53                 collapse: bool = False, includehidden: bool = False) -> Element:\n54         \"\"\"Resolve a *toctree* node into individual bullet lists with titles\n55         as items, returning None (if no containing titles are found) or\n56         a new node.\n57 \n58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,\n59         to the value of the *maxdepth* option on the *toctree* node.\n60         If *titles_only* is True, only toplevel document titles will be in the\n61         resulting tree.\n62         If *collapse* is True, all branches not containing docname will\n63         be collapsed.\n64         \"\"\"\n65         if toctree.get('hidden', False) and not includehidden:\n66             return None\n67 \n68         # For reading the following two helper function, it is useful to keep\n69         # in mind the node structure of a toctree (using HTML-like node names\n70         # for brevity):\n71         #\n72         # <ul>\n73         #   <li>\n74         #     <p><a></p>\n75         #     <p><a></p>\n76         #     ...\n77         #     <ul>\n78         #       ...\n79         #     </ul>\n80         #   </li>\n81         # </ul>\n82         #\n83         # The transformation is made in two passes in order to avoid\n84         # interactions between marking and pruning the tree (see bug #1046).\n85 \n86         toctree_ancestors = self.get_toctree_ancestors(docname)\n87         excluded = Matcher(self.env.config.exclude_patterns)\n88 \n89         def _toctree_add_classes(node: Element, depth: int) -> None:\n90             \"\"\"Add 'toctree-l%d' and 'current' classes to the toctree.\"\"\"\n91             for subnode in node.children:\n92                 if isinstance(subnode, (addnodes.compact_paragraph,\n93                                         nodes.list_item)):\n94                     # for <p> and <li>, indicate the depth level and recurse\n95                     subnode['classes'].append('toctree-l%d' % (depth - 1))\n96                     _toctree_add_classes(subnode, depth)\n97                 elif isinstance(subnode, nodes.bullet_list):\n98                     # for <ul>, just recurse\n99                     _toctree_add_classes(subnode, depth + 1)\n100                 elif isinstance(subnode, nodes.reference):\n101                     # for <a>, identify which entries point to the current\n102                     # document and therefore may not be collapsed\n103                     if subnode['refuri'] == docname:\n104                         if not subnode['anchorname']:\n105                             # give the whole branch a 'current' class\n106                             # (useful for styling it differently)\n107                             branchnode = subnode  # type: Element\n108                             while branchnode:\n109                                 branchnode['classes'].append('current')\n110                                 branchnode = branchnode.parent\n111                         # mark the list_item as \"on current page\"\n112                         if subnode.parent.parent.get('iscurrent'):\n113                             # but only if it's not already done\n114                             return\n115                         while subnode:\n116                             subnode['iscurrent'] = True\n117                             subnode = subnode.parent\n118 \n119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],\n120                                   separate: bool = False, subtree: bool = False\n121                                   ) -> List[Element]:\n122             \"\"\"Return TOC entries for a toctree node.\"\"\"\n123             refs = [(e[0], e[1]) for e in toctreenode['entries']]\n124             entries = []  # type: List[Element]\n125             for (title, ref) in refs:\n126                 try:\n127                     refdoc = None\n128                     if url_re.match(ref):\n129                         if title is None:\n130                             title = ref\n131                         reference = nodes.reference('', '', internal=False,\n132                                                     refuri=ref, anchorname='',\n133                                                     *[nodes.Text(title)])\n134                         para = addnodes.compact_paragraph('', '', reference)\n135                         item = nodes.list_item('', para)\n136                         toc = nodes.bullet_list('', item)\n137                     elif ref == 'self':\n138                         # 'self' refers to the document from which this\n139                         # toctree originates\n140                         ref = toctreenode['parent']\n141                         if not title:\n142                             title = clean_astext(self.env.titles[ref])\n143                         reference = nodes.reference('', '', internal=True,\n144                                                     refuri=ref,\n145                                                     anchorname='',\n146                                                     *[nodes.Text(title)])\n147                         para = addnodes.compact_paragraph('', '', reference)\n148                         item = nodes.list_item('', para)\n149                         # don't show subitems\n150                         toc = nodes.bullet_list('', item)\n151                     else:\n152                         if ref in parents:\n153                             logger.warning(__('circular toctree references '\n154                                               'detected, ignoring: %s <- %s'),\n155                                            ref, ' <- '.join(parents),\n156                                            location=ref)\n157                             continue\n158                         refdoc = ref\n159                         toc = self.env.tocs[ref].deepcopy()\n160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)\n161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):\n162                             self._toctree_prune(toc, 2, maxdepth, collapse)\n163                         process_only_nodes(toc, builder.tags)\n164                         if title and toc.children and len(toc.children) == 1:\n165                             child = toc.children[0]\n166                             for refnode in child.traverse(nodes.reference):\n167                                 if refnode['refuri'] == ref and \\\n168                                    not refnode['anchorname']:\n169                                     refnode.children = [nodes.Text(title)]\n170                     if not toc.children:\n171                         # empty toc means: no titles will show up in the toctree\n172                         logger.warning(__('toctree contains reference to document %r that '\n173                                           'doesn\\'t have a title: no link will be generated'),\n174                                        ref, location=toctreenode)\n175                 except KeyError:\n176                     # this is raised if the included file does not exist\n177                     if excluded(self.env.doc2path(ref, None)):\n178                         message = __('toctree contains reference to excluded document %r')\n179                     else:\n180                         message = __('toctree contains reference to nonexisting document %r')\n181 \n182                     logger.warning(message, ref, location=toctreenode)\n183                 else:\n184                     # if titles_only is given, only keep the main title and\n185                     # sub-toctrees\n186                     if titles_only:\n187                         # children of toc are:\n188                         # - list_item + compact_paragraph + (reference and subtoc)\n189                         # - only + subtoc\n190                         # - toctree\n191                         children = cast(Iterable[nodes.Element], toc)\n192 \n193                         # delete everything but the toplevel title(s)\n194                         # and toctrees\n195                         for toplevel in children:\n196                             # nodes with length 1 don't have any children anyway\n197                             if len(toplevel) > 1:\n198                                 subtrees = toplevel.traverse(addnodes.toctree)\n199                                 if subtrees:\n200                                     toplevel[1][:] = subtrees  # type: ignore\n201                                 else:\n202                                     toplevel.pop(1)\n203                     # resolve all sub-toctrees\n204                     for subtocnode in toc.traverse(addnodes.toctree):\n205                         if not (subtocnode.get('hidden', False) and\n206                                 not includehidden):\n207                             i = subtocnode.parent.index(subtocnode) + 1\n208                             for entry in _entries_from_toctree(\n209                                     subtocnode, [refdoc] + parents,\n210                                     subtree=True):\n211                                 subtocnode.parent.insert(i, entry)\n212                                 i += 1\n213                             subtocnode.parent.remove(subtocnode)\n214                     if separate:\n215                         entries.append(toc)\n216                     else:\n217                         children = cast(Iterable[nodes.Element], toc)\n218                         entries.extend(children)\n219             if not subtree and not separate:\n220                 ret = nodes.bullet_list()\n221                 ret += entries\n222                 return [ret]\n223             return entries\n224 \n225         maxdepth = maxdepth or toctree.get('maxdepth', -1)\n226         if not titles_only and toctree.get('titlesonly', False):\n227             titles_only = True\n228         if not includehidden and toctree.get('includehidden', False):\n229             includehidden = True\n230 \n231         # NOTE: previously, this was separate=True, but that leads to artificial\n232         # separation when two or more toctree entries form a logical unit, so\n233         # separating mode is no longer used -- it's kept here for history's sake\n234         tocentries = _entries_from_toctree(toctree, [], separate=False)\n235         if not tocentries:\n236             return None\n237 \n238         newnode = addnodes.compact_paragraph('', '')\n239         caption = toctree.attributes.get('caption')\n240         if caption:\n241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])\n242             caption_node.line = toctree.line\n243             caption_node.source = toctree.source\n244             caption_node.rawsource = toctree['rawcaption']\n245             if hasattr(toctree, 'uid'):\n246                 # move uid to caption_node to translate it\n247                 caption_node.uid = toctree.uid  # type: ignore\n248                 del toctree.uid  # type: ignore\n249             newnode += caption_node\n250         newnode.extend(tocentries)\n251         newnode['toctree'] = True\n252 \n253         # prune the tree to maxdepth, also set toc depth and current classes\n254         _toctree_add_classes(newnode, 1)\n255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)\n256 \n257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found\n258             return None\n259 \n260         # set the target paths in the toctrees (they are not known at TOC\n261         # generation time)\n262         for refnode in newnode.traverse(nodes.reference):\n263             if not url_re.match(refnode['refuri']):\n264                 refnode['refuri'] = builder.get_relative_uri(\n265                     docname, refnode['refuri']) + refnode['anchorname']\n266         return newnode\n267 \n268     def get_toctree_ancestors(self, docname: str) -> List[str]:\n269         parent = {}\n270         for p, children in self.env.toctree_includes.items():\n271             for child in children:\n272                 parent[child] = p\n273         ancestors = []  # type: List[str]\n274         d = docname\n275         while d in parent and d not in ancestors:\n276             ancestors.append(d)\n277             d = parent[d]\n278         return ancestors\n279 \n280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False\n281                        ) -> None:\n282         \"\"\"Utility: Cut a TOC at a specified depth.\"\"\"\n283         for subnode in node.children[:]:\n284             if isinstance(subnode, (addnodes.compact_paragraph,\n285                                     nodes.list_item)):\n286                 # for <p> and <li>, just recurse\n287                 self._toctree_prune(subnode, depth, maxdepth, collapse)\n288             elif isinstance(subnode, nodes.bullet_list):\n289                 # for <ul>, determine if the depth is too large or if the\n290                 # entry is to be collapsed\n291                 if maxdepth > 0 and depth > maxdepth:\n292                     subnode.parent.replace(subnode, [])\n293                 else:\n294                     # cull sub-entries whose parents aren't 'current'\n295                     if (collapse and depth > 1 and\n296                             'iscurrent' not in subnode.parent):\n297                         subnode.parent.remove(subnode)\n298                     else:\n299                         # recurse on visible children\n300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)\n301 \n302     def get_toc_for(self, docname: str, builder: \"Builder\") -> Node:\n303         \"\"\"Return a TOC nodetree -- for use on the same page only!\"\"\"\n304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)\n305         try:\n306             toc = self.env.tocs[docname].deepcopy()\n307             self._toctree_prune(toc, 2, tocdepth)\n308         except KeyError:\n309             # the document does not exist anymore: return a dummy node that\n310             # renders to nothing\n311             return nodes.paragraph()\n312         process_only_nodes(toc, builder.tags)\n313         for node in toc.traverse(nodes.reference):\n314             node['refuri'] = node['anchorname'] or '#'\n315         return toc\n316 \n317     def get_toctree_for(self, docname: str, builder: \"Builder\", collapse: bool,\n318                         **kwargs: Any) -> Element:\n319         \"\"\"Return the global TOC nodetree.\"\"\"\n320         doctree = self.env.get_doctree(self.env.config.master_doc)\n321         toctrees = []  # type: List[Element]\n322         if 'includehidden' not in kwargs:\n323             kwargs['includehidden'] = True\n324         if 'maxdepth' not in kwargs:\n325             kwargs['maxdepth'] = 0\n326         kwargs['collapse'] = collapse\n327         for toctreenode in doctree.traverse(addnodes.toctree):\n328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)\n329             if toctree:\n330                 toctrees.append(toctree)\n331         if not toctrees:\n332             return None\n333         result = toctrees[0]\n334         for toctree in toctrees[1:]:\n335             result.extend(toctree.children)\n336         return result\n",
        "intended_behavior": "Modify the logic that interprets the `toctree` directive to consult the new `file_extension_precedence` configuration (introduced in `sphinx/config.py`). When building the documentation structure, if Sphinx detects multiple files with the same base name (but different extensions) referenced within a toctree, it should use the order specified in `file_extension_precedence` to resolve which file to include. If no preference is specified, Sphinx should either follow a default order or explicitly log a warning indicating the ambiguity and the chosen file, advising the user to specify their preference to avoid unexpected behavior."
    }
]