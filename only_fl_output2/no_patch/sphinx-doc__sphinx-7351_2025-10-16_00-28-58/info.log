2025-10-16 00:28:58.449 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:29:01.590 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=382, output_tokens=12, cost=0.004180
2025-10-16 00:29:17.796 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=562, output_tokens=736, cost=0.027700
2025-10-16 00:29:18.955 | INFO     | registered non reproducing test 0
2025-10-16 00:29:38.050 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2050, output_tokens=854, cost=0.046120
2025-10-16 00:29:39.242 | INFO     | registered non reproducing test 1
2025-10-16 00:29:57.287 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1844, output_tokens=882, cost=0.044900
2025-10-16 00:29:58.472 | INFO     | registered non reproducing test 2
2025-10-16 00:29:58.472 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 00:29:58.475 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:30:05.083 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=684, output_tokens=234, cost=0.013860
2025-10-16 00:30:05.088 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:30:07.284 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=588, output_tokens=54, cost=0.007500
2025-10-16 00:30:07.286 | DEBUG    | Extracted a valid json.
2025-10-16 00:30:07.286 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"toctree\")",
        "search_code(\".rst\")",
        "search_code(\".md\")",
        "search_code(\"myst-parser\")"
    ],
    "bug_locations": []
}
2025-10-16 00:30:07.498 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:30:07.498 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:30:23.434 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2521, output_tokens=781, cost=0.048640
2025-10-16 00:30:23.441 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:30:32.145 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3518, output_tokens=387, cost=0.046790
2025-10-16 00:30:32.153 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:30:41.222 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=741, output_tokens=343, cost=0.017700
2025-10-16 00:30:41.223 | DEBUG    | Extracted a valid json.
2025-10-16 00:30:41.223 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"source_suffix\")",
        "search_code_in_file(\"add_source_parser\", \"sphinx/application.py\")",
        "search_code(\"extensions\")",
        "search_code(\"setup_ext\")"
    ],
    "bug_locations": [
        {
            "file": "sphinx/environment/adapters/toctree.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file, especially within the logic related to the `toctree` directive processing, likely needs adjustments to ensure that when a toctree entry is specified (e.g., `a.md`), Sphinx must prioritize this file if multiple files with the same name but different extensions exist. The intended behavior should include checking the specified extensions in the toctree entries against the available files and prioritizing the inclusion based on this explicit mention. If a configuration option is introduced for users to specify the order of preference for file extensions, this file's logic should consult this configuration when deciding which file to include."
        },
        {
            "file": "sphinx/environment/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Within the environment initialization or file collection process, include logic to detect when multiple files with the same basename but different extensions are present and how to handle their priority. This may involve integrating checks against user configuration for file extension preferences or defaults. A warning mechanism should be introduced to notify the user of the detected files with the same name but different extensions, offering guidance or highlighting a configuration option for setting their preference if not explicitly handled in the toctree."
        }
    ]
}
2025-10-16 00:30:41.356 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:30:41.357 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:30:59.313 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5150, output_tokens=684, cost=0.072020
2025-10-16 00:30:59.320 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:31:07.212 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6050, output_tokens=318, cost=0.070040
2025-10-16 00:31:07.218 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:31:15.399 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=672, output_tokens=302, cost=0.015780
2025-10-16 00:31:15.400 | DEBUG    | Extracted a valid json.
2025-10-16 00:31:15.400 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/config.py",
            "class": "",
            "method": "",
            "intended_behavior": "This configuration file should be enhanced to allow users to specify preferences for handling situations where files have the same name but different extensions. Introducing a new configuration option like `file_extension_precedence` would enable users to define an ordered list of extensions that Sphinx should use to resolve conflicts. This list would be checked whenever Sphinx encounters files with the same base name, ensuring the user-preferred extension is selected. Existing functionality for projects not using this configuration should remain unchanged, preserving backward compatibility."
        },
        {
            "file": "sphinx/environment/adapters/toctree.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the logic that interprets the `toctree` directive to consult the new `file_extension_precedence` configuration (introduced in `sphinx/config.py`). When building the documentation structure, if Sphinx detects multiple files with the same base name (but different extensions) referenced within a toctree, it should use the order specified in `file_extension_precedence` to resolve which file to include. If no preference is specified, Sphinx should either follow a default order or explicitly log a warning indicating the ambiguity and the chosen file, advising the user to specify their preference to avoid unexpected behavior."
        }
    ]
}
2025-10-16 00:31:15.406 | DEBUG    | Bug location extracted successfully: [<file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 import warnings
15 from collections import OrderedDict
16 from os import path, getenv
17 from typing import (
18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union
19 )
20 
21 from sphinx.deprecation import RemovedInSphinx40Warning
22 from sphinx.errors import ConfigError, ExtensionError
23 from sphinx.locale import _, __
24 from sphinx.util import logging
25 from sphinx.util.i18n import format_date
26 from sphinx.util.osutil import cd
27 from sphinx.util.pycompat import execfile_
28 from sphinx.util.tags import Tags
29 from sphinx.util.typing import NoneType
30 
31 if False:
32     # For type annotation
33     from sphinx.application import Sphinx
34     from sphinx.environment import BuildEnvironment
35 
36 logger = logging.getLogger(__name__)
37 
38 CONFIG_FILENAME = 'conf.py'
39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
40 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
41 
42 ConfigValue = NamedTuple('ConfigValue', [('name', str),
43                                          ('value', Any),
44                                          ('rebuild', Union[bool, str])])
45 
46 
47 def is_serializable(obj: Any) -> bool:
48     """Check if object is serializable or not."""
49     if isinstance(obj, UNSERIALIZABLE_TYPES):
50         return False
51     elif isinstance(obj, dict):
52         for key, value in obj.items():
53             if not is_serializable(key) or not is_serializable(value):
54                 return False
55     elif isinstance(obj, (list, tuple, set)):
56         return all(is_serializable(i) for i in obj)
57 
58     return True
59 
60 
61 class ENUM:
62     """represents the config value should be a one of candidates.
63 
64     Example:
65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
66     """
67     def __init__(self, *candidates: str) -> None:
68         self.candidates = candidates
69 
70     def match(self, value: Union[str, List, Tuple]) -> bool:
71         if isinstance(value, (list, tuple)):
72             return all(item in self.candidates for item in value)
73         else:
74             return value in self.candidates
75 
76 
77 # RemovedInSphinx40Warning
78 string_classes = [str]  # type: List
79 
80 
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)
308 
309 
310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:
311     """Evaluate a config file."""
312     namespace = {}  # type: Dict[str, Any]
313     namespace['__file__'] = filename
314     namespace['tags'] = tags
315 
316     with cd(path.dirname(filename)):
317         # during executing config file, current dir is changed to ``confdir``.
318         try:
319             execfile_(filename, namespace)
320         except SyntaxError as err:
321             msg = __("There is a syntax error in your configuration file: %s\n")
322             raise ConfigError(msg % err)
323         except SystemExit:
324             msg = __("The configuration file (or one of the modules it imports) "
325                      "called sys.exit()")
326             raise ConfigError(msg)
327         except ConfigError:
328             # pass through ConfigError from conf.py as is.  It will be shown in console.
329             raise
330         except Exception:
331             msg = __("There is a programmable error in your configuration file:\n\n%s")
332             raise ConfigError(msg % traceback.format_exc())
333 
334     return namespace
335 
336 
337 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
338     """This converts old styled source_suffix to new styled one.
339 
340     * old style: str or list
341     * new style: a dict which maps from fileext to filetype
342     """
343     source_suffix = config.source_suffix
344     if isinstance(source_suffix, str):
345         # if str, considers as default filetype (None)
346         #
347         # The default filetype is determined on later step.
348         # By default, it is considered as restructuredtext.
349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
350     elif isinstance(source_suffix, (list, tuple)):
351         # if list, considers as all of them are default filetype
352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
353     elif isinstance(source_suffix, dict):
354         # if dict, convert it to OrderedDict
355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
356     else:
357         logger.warning(__("The config value `source_suffix' expects "
358                           "a string, list of strings, or dictionary. "
359                           "But `%r' is given." % source_suffix))
360 
361 
362 def init_numfig_format(app: "Sphinx", config: Config) -> None:
363     """Initialize :confval:`numfig_format`."""
364     numfig_format = {'section': _('Section %s'),
365                      'figure': _('Fig. %s'),
366                      'table': _('Table %s'),
367                      'code-block': _('Listing %s')}
368 
369     # override default labels by configuration
370     numfig_format.update(config.numfig_format)
371     config.numfig_format = numfig_format  # type: ignore
372 
373 
374 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
375     """correct values of copyright year that are not coherent with
376     the SOURCE_DATE_EPOCH environment variable (if set)
377 
378     See https://reproducible-builds.org/specs/source-date-epoch/
379     """
380     if getenv('SOURCE_DATE_EPOCH') is not None:
381         for k in ('copyright', 'epub_copyright'):
382             if k in config:
383                 replace = r'\g<1>%s' % format_date('%Y')
384                 config[k] = copyright_year_re.sub(replace, config[k])
385 
386 
387 def check_confval_types(app: "Sphinx", config: Config) -> None:
388     """check all values for deviation from the default value's type, since
389     that can result in TypeErrors all over the place NB.
390     """
391     for confval in config:
392         default, rebuild, annotations = config.values[confval.name]
393 
394         if hasattr(default, '__call__'):
395             default = default(config)  # evaluate default value
396         if default is None and not annotations:
397             continue  # neither inferrable nor expliclitly annotated types
398 
399         if annotations is Any:
400             # any type of value is accepted
401             pass
402         elif isinstance(annotations, ENUM):
403             if not annotations.match(confval.value):
404                 msg = __("The config value `{name}` has to be a one of {candidates}, "
405                          "but `{current}` is given.")
406                 logger.warning(msg.format(name=confval.name,
407                                           current=confval.value,
408                                           candidates=annotations.candidates))
409         else:
410             if type(confval.value) is type(default):
411                 continue
412             if type(confval.value) in annotations:
413                 continue
414 
415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
416                             set(type(default).__bases__))
417             common_bases.discard(object)
418             if common_bases:
419                 continue  # at least we share a non-trivial base class
420 
421             if annotations:
422                 msg = __("The config value `{name}' has type `{current.__name__}'; "
423                          "expected {permitted}.")
424                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
425                 if len(wrapped_annotations) > 2:
426                     permitted = "{}, or {}".format(
427                         ", ".join(wrapped_annotations[:-1]),
428                         wrapped_annotations[-1])
429                 else:
430                     permitted = " or ".join(wrapped_annotations)
431                 logger.warning(msg.format(name=confval.name,
432                                           current=type(confval.value),
433                                           permitted=permitted))
434             else:
435                 msg = __("The config value `{name}' has type `{current.__name__}', "
436                          "defaults to `{default.__name__}'.")
437                 logger.warning(msg.format(name=confval.name,
438                                           current=type(confval.value),
439                                           default=type(default)))
440 
441 
442 def check_unicode(config: Config) -> None:
443     """check all string values for non-ASCII characters in bytestrings,
444     since that can result in UnicodeErrors all over the place
445     """
446     warnings.warn('sphinx.config.check_unicode() is deprecated.',
447                   RemovedInSphinx40Warning)
448 
449     nonascii_re = re.compile(br'[\x80-\xff]')
450 
451     for name, value in config._raw_config.items():
452         if isinstance(value, bytes) and nonascii_re.search(value):
453             logger.warning(__('the config value %r is set to a string with non-ASCII '
454                               'characters; this can lead to Unicode errors occurring. '
455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')
456 
457 
458 def check_primary_domain(app: "Sphinx", config: Config) -> None:
459     primary_domain = config.primary_domain
460     if primary_domain and not app.registry.has_domain(primary_domain):
461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
462         config.primary_domain = None  # type: ignore
463 
464 
465 def check_master_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
466                      changed: Set[str], removed: Set[str]) -> Set[str]:
467     """Adjust master_doc to 'contents' to support an old project which does not have
468     no master_doc setting.
469     """
470     if (app.config.master_doc == 'index' and
471             'index' not in app.project.docnames and
472             'contents' in app.project.docnames):
473         logger.warning(__('Since v2.0, Sphinx uses "index" as master_doc by default. '
474                           'Please add "master_doc = \'contents\'" to your conf.py.'))
475         app.config.master_doc = "contents"  # type: ignore
476 
477     return changed
478 
479 
480 def setup(app: "Sphinx") -> Dict[str, Any]:
481     app.connect('config-inited', convert_source_suffix)
482     app.connect('config-inited', init_numfig_format)
483     app.connect('config-inited', correct_copyright_year)
484     app.connect('config-inited', check_confval_types)
485     app.connect('config-inited', check_primary_domain)
486     app.connect('env-get-outdated', check_master_doc)
487 
488     return {
489         'version': 'builtin',
490         'parallel_read_safe': True,
491         'parallel_write_safe': True,
492     }

</code><intended_behavior>This configuration file should be enhanced to allow users to specify preferences for handling situations where files have the same name but different extensions. Introducing a new configuration option like `file_extension_precedence` would enable users to define an ordered list of extensions that Sphinx should use to resolve conflicts. This list would be checked whenever Sphinx encounters files with the same base name, ensuring the user-preferred extension is selected. Existing functionality for projects not using this configuration should remain unchanged, preserving backward compatibility.</intended_behavior>, <file>sphinx/environment/adapters/toctree.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.toctree
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Toctree adapter for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Iterable, List
12 from typing import cast
13 
14 from docutils import nodes
15 from docutils.nodes import Element, Node
16 
17 from sphinx import addnodes
18 from sphinx.locale import __
19 from sphinx.util import url_re, logging
20 from sphinx.util.matching import Matcher
21 from sphinx.util.nodes import clean_astext, process_only_nodes
22 
23 if False:
24     # For type annotation
25     from sphinx.builders import Builder
26     from sphinx.environment import BuildEnvironment
27 
28 
29 logger = logging.getLogger(__name__)
30 
31 
32 class TocTree:
33     def __init__(self, env: "BuildEnvironment") -> None:
34         self.env = env
35 
36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:
37         """Note a TOC tree directive in a document and gather information about
38         file relations from it.
39         """
40         if toctreenode['glob']:
41             self.env.glob_toctrees.add(docname)
42         if toctreenode.get('numbered'):
43             self.env.numbered_toctrees.add(docname)
44         includefiles = toctreenode['includefiles']
45         for includefile in includefiles:
46             # note that if the included file is rebuilt, this one must be
47             # too (since the TOC of the included file could have changed)
48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)
49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)
50 
51     def resolve(self, docname: str, builder: "Builder", toctree: addnodes.toctree,
52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,
53                 collapse: bool = False, includehidden: bool = False) -> Element:
54         """Resolve a *toctree* node into individual bullet lists with titles
55         as items, returning None (if no containing titles are found) or
56         a new node.
57 
58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
59         to the value of the *maxdepth* option on the *toctree* node.
60         If *titles_only* is True, only toplevel document titles will be in the
61         resulting tree.
62         If *collapse* is True, all branches not containing docname will
63         be collapsed.
64         """
65         if toctree.get('hidden', False) and not includehidden:
66             return None
67 
68         # For reading the following two helper function, it is useful to keep
69         # in mind the node structure of a toctree (using HTML-like node names
70         # for brevity):
71         #
72         # <ul>
73         #   <li>
74         #     <p><a></p>
75         #     <p><a></p>
76         #     ...
77         #     <ul>
78         #       ...
79         #     </ul>
80         #   </li>
81         # </ul>
82         #
83         # The transformation is made in two passes in order to avoid
84         # interactions between marking and pruning the tree (see bug #1046).
85 
86         toctree_ancestors = self.get_toctree_ancestors(docname)
87         excluded = Matcher(self.env.config.exclude_patterns)
88 
89         def _toctree_add_classes(node: Element, depth: int) -> None:
90             """Add 'toctree-l%d' and 'current' classes to the toctree."""
91             for subnode in node.children:
92                 if isinstance(subnode, (addnodes.compact_paragraph,
93                                         nodes.list_item)):
94                     # for <p> and <li>, indicate the depth level and recurse
95                     subnode['classes'].append('toctree-l%d' % (depth - 1))
96                     _toctree_add_classes(subnode, depth)
97                 elif isinstance(subnode, nodes.bullet_list):
98                     # for <ul>, just recurse
99                     _toctree_add_classes(subnode, depth + 1)
100                 elif isinstance(subnode, nodes.reference):
101                     # for <a>, identify which entries point to the current
102                     # document and therefore may not be collapsed
103                     if subnode['refuri'] == docname:
104                         if not subnode['anchorname']:
105                             # give the whole branch a 'current' class
106                             # (useful for styling it differently)
107                             branchnode = subnode  # type: Element
108                             while branchnode:
109                                 branchnode['classes'].append('current')
110                                 branchnode = branchnode.parent
111                         # mark the list_item as "on current page"
112                         if subnode.parent.parent.get('iscurrent'):
113                             # but only if it's not already done
114                             return
115                         while subnode:
116                             subnode['iscurrent'] = True
117                             subnode = subnode.parent
118 
119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],
120                                   separate: bool = False, subtree: bool = False
121                                   ) -> List[Element]:
122             """Return TOC entries for a toctree node."""
123             refs = [(e[0], e[1]) for e in toctreenode['entries']]
124             entries = []  # type: List[Element]
125             for (title, ref) in refs:
126                 try:
127                     refdoc = None
128                     if url_re.match(ref):
129                         if title is None:
130                             title = ref
131                         reference = nodes.reference('', '', internal=False,
132                                                     refuri=ref, anchorname='',
133                                                     *[nodes.Text(title)])
134                         para = addnodes.compact_paragraph('', '', reference)
135                         item = nodes.list_item('', para)
136                         toc = nodes.bullet_list('', item)
137                     elif ref == 'self':
138                         # 'self' refers to the document from which this
139                         # toctree originates
140                         ref = toctreenode['parent']
141                         if not title:
142                             title = clean_astext(self.env.titles[ref])
143                         reference = nodes.reference('', '', internal=True,
144                                                     refuri=ref,
145                                                     anchorname='',
146                                                     *[nodes.Text(title)])
147                         para = addnodes.compact_paragraph('', '', reference)
148                         item = nodes.list_item('', para)
149                         # don't show subitems
150                         toc = nodes.bullet_list('', item)
151                     else:
152                         if ref in parents:
153                             logger.warning(__('circular toctree references '
154                                               'detected, ignoring: %s <- %s'),
155                                            ref, ' <- '.join(parents),
156                                            location=ref)
157                             continue
158                         refdoc = ref
159                         toc = self.env.tocs[ref].deepcopy()
160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)
161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):
162                             self._toctree_prune(toc, 2, maxdepth, collapse)
163                         process_only_nodes(toc, builder.tags)
164                         if title and toc.children and len(toc.children) == 1:
165                             child = toc.children[0]
166                             for refnode in child.traverse(nodes.reference):
167                                 if refnode['refuri'] == ref and \
168                                    not refnode['anchorname']:
169                                     refnode.children = [nodes.Text(title)]
170                     if not toc.children:
171                         # empty toc means: no titles will show up in the toctree
172                         logger.warning(__('toctree contains reference to document %r that '
173                                           'doesn\'t have a title: no link will be generated'),
174                                        ref, location=toctreenode)
175                 except KeyError:
176                     # this is raised if the included file does not exist
177                     if excluded(self.env.doc2path(ref, None)):
178                         message = __('toctree contains reference to excluded document %r')
179                     else:
180                         message = __('toctree contains reference to nonexisting document %r')
181 
182                     logger.warning(message, ref, location=toctreenode)
183                 else:
184                     # if titles_only is given, only keep the main title and
185                     # sub-toctrees
186                     if titles_only:
187                         # children of toc are:
188                         # - list_item + compact_paragraph + (reference and subtoc)
189                         # - only + subtoc
190                         # - toctree
191                         children = cast(Iterable[nodes.Element], toc)
192 
193                         # delete everything but the toplevel title(s)
194                         # and toctrees
195                         for toplevel in children:
196                             # nodes with length 1 don't have any children anyway
197                             if len(toplevel) > 1:
198                                 subtrees = toplevel.traverse(addnodes.toctree)
199                                 if subtrees:
200                                     toplevel[1][:] = subtrees  # type: ignore
201                                 else:
202                                     toplevel.pop(1)
203                     # resolve all sub-toctrees
204                     for subtocnode in toc.traverse(addnodes.toctree):
205                         if not (subtocnode.get('hidden', False) and
206                                 not includehidden):
207                             i = subtocnode.parent.index(subtocnode) + 1
208                             for entry in _entries_from_toctree(
209                                     subtocnode, [refdoc] + parents,
210                                     subtree=True):
211                                 subtocnode.parent.insert(i, entry)
212                                 i += 1
213                             subtocnode.parent.remove(subtocnode)
214                     if separate:
215                         entries.append(toc)
216                     else:
217                         children = cast(Iterable[nodes.Element], toc)
218                         entries.extend(children)
219             if not subtree and not separate:
220                 ret = nodes.bullet_list()
221                 ret += entries
222                 return [ret]
223             return entries
224 
225         maxdepth = maxdepth or toctree.get('maxdepth', -1)
226         if not titles_only and toctree.get('titlesonly', False):
227             titles_only = True
228         if not includehidden and toctree.get('includehidden', False):
229             includehidden = True
230 
231         # NOTE: previously, this was separate=True, but that leads to artificial
232         # separation when two or more toctree entries form a logical unit, so
233         # separating mode is no longer used -- it's kept here for history's sake
234         tocentries = _entries_from_toctree(toctree, [], separate=False)
235         if not tocentries:
236             return None
237 
238         newnode = addnodes.compact_paragraph('', '')
239         caption = toctree.attributes.get('caption')
240         if caption:
241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])
242             caption_node.line = toctree.line
243             caption_node.source = toctree.source
244             caption_node.rawsource = toctree['rawcaption']
245             if hasattr(toctree, 'uid'):
246                 # move uid to caption_node to translate it
247                 caption_node.uid = toctree.uid  # type: ignore
248                 del toctree.uid  # type: ignore
249             newnode += caption_node
250         newnode.extend(tocentries)
251         newnode['toctree'] = True
252 
253         # prune the tree to maxdepth, also set toc depth and current classes
254         _toctree_add_classes(newnode, 1)
255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)
256 
257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found
258             return None
259 
260         # set the target paths in the toctrees (they are not known at TOC
261         # generation time)
262         for refnode in newnode.traverse(nodes.reference):
263             if not url_re.match(refnode['refuri']):
264                 refnode['refuri'] = builder.get_relative_uri(
265                     docname, refnode['refuri']) + refnode['anchorname']
266         return newnode
267 
268     def get_toctree_ancestors(self, docname: str) -> List[str]:
269         parent = {}
270         for p, children in self.env.toctree_includes.items():
271             for child in children:
272                 parent[child] = p
273         ancestors = []  # type: List[str]
274         d = docname
275         while d in parent and d not in ancestors:
276             ancestors.append(d)
277             d = parent[d]
278         return ancestors
279 
280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False
281                        ) -> None:
282         """Utility: Cut a TOC at a specified depth."""
283         for subnode in node.children[:]:
284             if isinstance(subnode, (addnodes.compact_paragraph,
285                                     nodes.list_item)):
286                 # for <p> and <li>, just recurse
287                 self._toctree_prune(subnode, depth, maxdepth, collapse)
288             elif isinstance(subnode, nodes.bullet_list):
289                 # for <ul>, determine if the depth is too large or if the
290                 # entry is to be collapsed
291                 if maxdepth > 0 and depth > maxdepth:
292                     subnode.parent.replace(subnode, [])
293                 else:
294                     # cull sub-entries whose parents aren't 'current'
295                     if (collapse and depth > 1 and
296                             'iscurrent' not in subnode.parent):
297                         subnode.parent.remove(subnode)
298                     else:
299                         # recurse on visible children
300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)
301 
302     def get_toc_for(self, docname: str, builder: "Builder") -> Node:
303         """Return a TOC nodetree -- for use on the same page only!"""
304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)
305         try:
306             toc = self.env.tocs[docname].deepcopy()
307             self._toctree_prune(toc, 2, tocdepth)
308         except KeyError:
309             # the document does not exist anymore: return a dummy node that
310             # renders to nothing
311             return nodes.paragraph()
312         process_only_nodes(toc, builder.tags)
313         for node in toc.traverse(nodes.reference):
314             node['refuri'] = node['anchorname'] or '#'
315         return toc
316 
317     def get_toctree_for(self, docname: str, builder: "Builder", collapse: bool,
318                         **kwargs: Any) -> Element:
319         """Return the global TOC nodetree."""
320         doctree = self.env.get_doctree(self.env.config.master_doc)
321         toctrees = []  # type: List[Element]
322         if 'includehidden' not in kwargs:
323             kwargs['includehidden'] = True
324         if 'maxdepth' not in kwargs:
325             kwargs['maxdepth'] = 0
326         kwargs['collapse'] = collapse
327         for toctreenode in doctree.traverse(addnodes.toctree):
328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)
329             if toctree:
330                 toctrees.append(toctree)
331         if not toctrees:
332             return None
333         result = toctrees[0]
334         for toctree in toctrees[1:]:
335             result.extend(toctree.children)
336         return result

</code><intended_behavior>Modify the logic that interprets the `toctree` directive to consult the new `file_extension_precedence` configuration (introduced in `sphinx/config.py`). When building the documentation structure, if Sphinx detects multiple files with the same base name (but different extensions) referenced within a toctree, it should use the order specified in `file_extension_precedence` to resolve which file to include. If no preference is specified, Sphinx should either follow a default order or explicitly log a warning indicating the ambiguity and the chosen file, advising the user to specify their preference to avoid unexpected behavior.</intended_behavior>]
2025-10-16 00:31:15.406 | INFO     | Search completed. Bug locations: [<file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 import warnings
15 from collections import OrderedDict
16 from os import path, getenv
17 from typing import (
18     Any, Callable, Dict, Generator, Iterator, List, NamedTuple, Set, Tuple, Union
19 )
20 
21 from sphinx.deprecation import RemovedInSphinx40Warning
22 from sphinx.errors import ConfigError, ExtensionError
23 from sphinx.locale import _, __
24 from sphinx.util import logging
25 from sphinx.util.i18n import format_date
26 from sphinx.util.osutil import cd
27 from sphinx.util.pycompat import execfile_
28 from sphinx.util.tags import Tags
29 from sphinx.util.typing import NoneType
30 
31 if False:
32     # For type annotation
33     from sphinx.application import Sphinx
34     from sphinx.environment import BuildEnvironment
35 
36 logger = logging.getLogger(__name__)
37 
38 CONFIG_FILENAME = 'conf.py'
39 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
40 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
41 
42 ConfigValue = NamedTuple('ConfigValue', [('name', str),
43                                          ('value', Any),
44                                          ('rebuild', Union[bool, str])])
45 
46 
47 def is_serializable(obj: Any) -> bool:
48     """Check if object is serializable or not."""
49     if isinstance(obj, UNSERIALIZABLE_TYPES):
50         return False
51     elif isinstance(obj, dict):
52         for key, value in obj.items():
53             if not is_serializable(key) or not is_serializable(value):
54                 return False
55     elif isinstance(obj, (list, tuple, set)):
56         return all(is_serializable(i) for i in obj)
57 
58     return True
59 
60 
61 class ENUM:
62     """represents the config value should be a one of candidates.
63 
64     Example:
65         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
66     """
67     def __init__(self, *candidates: str) -> None:
68         self.candidates = candidates
69 
70     def match(self, value: Union[str, List, Tuple]) -> bool:
71         if isinstance(value, (list, tuple)):
72             return all(item in self.candidates for item in value)
73         else:
74             return value in self.candidates
75 
76 
77 # RemovedInSphinx40Warning
78 string_classes = [str]  # type: List
79 
80 
81 class Config:
82     """Configuration file abstraction.
83 
84     The config object makes the values of all config values available as
85     attributes.
86 
87     It is exposed via the :py:attr:`sphinx.application.Application.config` and
88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
89     to get the value of :confval:`language`, use either ``app.config.language``
90     or ``env.config.language``.
91     """
92 
93     # the values are: (default, what needs to be rebuilt if changed)
94 
95     # If you add a value here, don't forget to include it in the
96     # quickstart.py file template as well as in the docs!
97 
98     config_values = {
99         # general options
100         'project': ('Python', 'env', []),
101         'author': ('unknown', 'env', []),
102         'copyright': ('', 'html', []),
103         'version': ('', 'env', []),
104         'release': ('', 'env', []),
105         'today': ('', 'env', []),
106         # the real default is locale-dependent
107         'today_fmt': (None, 'env', [str]),
108 
109         'language': (None, 'env', [str]),
110         'locale_dirs': (['locales'], 'env', []),
111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
112 
113         'master_doc': ('index', 'env', []),
114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
115         'source_encoding': ('utf-8-sig', 'env', []),
116         'source_parsers': ({}, 'env', []),
117         'exclude_patterns': ([], 'env', []),
118         'default_role': (None, 'env', [str]),
119         'add_function_parentheses': (True, 'env', []),
120         'add_module_names': (True, 'env', []),
121         'trim_footnote_reference_space': (False, 'env', []),
122         'show_authors': (False, 'env', []),
123         'pygments_style': (None, 'html', [str]),
124         'highlight_language': ('default', 'env', []),
125         'highlight_options': ({}, 'env', []),
126         'templates_path': ([], 'html', []),
127         'template_bridge': (None, 'html', [str]),
128         'keep_warnings': (False, 'env', []),
129         'suppress_warnings': ([], 'env', []),
130         'modindex_common_prefix': ([], 'html', []),
131         'rst_epilog': (None, 'env', [str]),
132         'rst_prolog': (None, 'env', [str]),
133         'trim_doctest_flags': (True, 'env', []),
134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore
135         'needs_sphinx': (None, None, [str]),
136         'needs_extensions': ({}, None, []),
137         'manpages_url': (None, 'env', []),
138         'nitpicky': (False, None, []),
139         'nitpick_ignore': ([], None, []),
140         'numfig': (False, 'env', []),
141         'numfig_secnum_depth': (1, 'env', []),
142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
143 
144         'math_number_all': (False, 'env', []),
145         'math_eqref_format': (None, 'env', [str]),
146         'math_numfig': (True, 'env', []),
147         'tls_verify': (True, 'env', []),
148         'tls_cacerts': (None, 'env', []),
149         'user_agent': (None, 'env', [str]),
150         'smartquotes': (True, 'env', []),
151         'smartquotes_action': ('qDe', 'env', []),
152         'smartquotes_excludes': ({'languages': ['ja'],
153                                   'builders': ['man', 'text']},
154                                  'env', []),
155     }  # type: Dict[str, Tuple]
156 
157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
158         self.overrides = dict(overrides)
159         self.values = Config.config_values.copy()
160         self._raw_config = config
161         self.setup = config.get('setup', None)  # type: Callable
162 
163         if 'extensions' in self.overrides:
164             if isinstance(self.overrides['extensions'], str):
165                 config['extensions'] = self.overrides.pop('extensions').split(',')
166             else:
167                 config['extensions'] = self.overrides.pop('extensions')
168         self.extensions = config.get('extensions', [])  # type: List[str]
169 
170     @classmethod
171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
172         """Create a Config object from configuration file."""
173         filename = path.join(confdir, CONFIG_FILENAME)
174         namespace = eval_config_file(filename, tags)
175         return cls(namespace, overrides or {})
176 
177     def convert_overrides(self, name: str, value: Any) -> Any:
178         if not isinstance(value, str):
179             return value
180         else:
181             defvalue = self.values[name][0]
182             if self.values[name][2] == Any:
183                 return value
184             elif type(defvalue) is bool or self.values[name][2] == [bool]:
185                 if value == '0':
186                     # given falsy string from command line option
187                     return False
188                 else:
189                     return bool(value)
190             elif isinstance(defvalue, dict):
191                 raise ValueError(__('cannot override dictionary config setting %r, '
192                                     'ignoring (use %r to set individual elements)') %
193                                  (name, name + '.key=value'))
194             elif isinstance(defvalue, list):
195                 return value.split(',')
196             elif isinstance(defvalue, int):
197                 try:
198                     return int(value)
199                 except ValueError:
200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
201                                      (value, name))
202             elif hasattr(defvalue, '__call__'):
203                 return value
204             elif defvalue is not None and not isinstance(defvalue, str):
205                 raise ValueError(__('cannot override config setting %r with unsupported '
206                                     'type, ignoring') % name)
207             else:
208                 return value
209 
210     def pre_init_values(self) -> None:
211         """
212         Initialize some limited config variables before initialize i18n and loading extensions
213         """
214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
215         for name in variables:
216             try:
217                 if name in self.overrides:
218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
219                 elif name in self._raw_config:
220                     self.__dict__[name] = self._raw_config[name]
221             except ValueError as exc:
222                 logger.warning("%s", exc)
223 
224     def init_values(self) -> None:
225         config = self._raw_config
226         for valname, value in self.overrides.items():
227             try:
228                 if '.' in valname:
229                     realvalname, key = valname.split('.', 1)
230                     config.setdefault(realvalname, {})[key] = value
231                     continue
232                 elif valname not in self.values:
233                     logger.warning(__('unknown config value %r in override, ignoring'),
234                                    valname)
235                     continue
236                 if isinstance(value, str):
237                     config[valname] = self.convert_overrides(valname, value)
238                 else:
239                     config[valname] = value
240             except ValueError as exc:
241                 logger.warning("%s", exc)
242         for name in config:
243             if name in self.values:
244                 self.__dict__[name] = config[name]
245 
246     def __getattr__(self, name: str) -> Any:
247         if name.startswith('_'):
248             raise AttributeError(name)
249         if name not in self.values:
250             raise AttributeError(__('No such config value: %s') % name)
251         default = self.values[name][0]
252         if hasattr(default, '__call__'):
253             return default(self)
254         return default
255 
256     def __getitem__(self, name: str) -> str:
257         return getattr(self, name)
258 
259     def __setitem__(self, name: str, value: Any) -> None:
260         setattr(self, name, value)
261 
262     def __delitem__(self, name: str) -> None:
263         delattr(self, name)
264 
265     def __contains__(self, name: str) -> bool:
266         return name in self.values
267 
268     def __iter__(self) -> Generator[ConfigValue, None, None]:
269         for name, value in self.values.items():
270             yield ConfigValue(name, getattr(self, name), value[1])
271 
272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
273         if name in self.values:
274             raise ExtensionError(__('Config value %r already present') % name)
275         else:
276             self.values[name] = (default, rebuild, types)
277 
278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
279         if isinstance(rebuild, str):
280             rebuild = [rebuild]
281         return (value for value in self if value.rebuild in rebuild)
282 
283     def __getstate__(self) -> Dict:
284         """Obtains serializable data for pickling."""
285         # remove potentially pickling-problematic values from config
286         __dict__ = {}
287         for key, value in self.__dict__.items():
288             if key.startswith('_') or not is_serializable(value):
289                 pass
290             else:
291                 __dict__[key] = value
292 
293         # create a picklable copy of values list
294         __dict__['values'] = {}
295         for key, value in self.values.items():
296             real_value = getattr(self, key)
297             if not is_serializable(real_value):
298                 # omit unserializable value
299                 real_value = None
300 
301             # types column is also omitted
302             __dict__['values'][key] = (real_value, value[1], None)
303 
304         return __dict__
305 
306     def __setstate__(self, state: Dict) -> None:
307         self.__dict__.update(state)
308 
309 
310 def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:
311     """Evaluate a config file."""
312     namespace = {}  # type: Dict[str, Any]
313     namespace['__file__'] = filename
314     namespace['tags'] = tags
315 
316     with cd(path.dirname(filename)):
317         # during executing config file, current dir is changed to ``confdir``.
318         try:
319             execfile_(filename, namespace)
320         except SyntaxError as err:
321             msg = __("There is a syntax error in your configuration file: %s\n")
322             raise ConfigError(msg % err)
323         except SystemExit:
324             msg = __("The configuration file (or one of the modules it imports) "
325                      "called sys.exit()")
326             raise ConfigError(msg)
327         except ConfigError:
328             # pass through ConfigError from conf.py as is.  It will be shown in console.
329             raise
330         except Exception:
331             msg = __("There is a programmable error in your configuration file:\n\n%s")
332             raise ConfigError(msg % traceback.format_exc())
333 
334     return namespace
335 
336 
337 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
338     """This converts old styled source_suffix to new styled one.
339 
340     * old style: str or list
341     * new style: a dict which maps from fileext to filetype
342     """
343     source_suffix = config.source_suffix
344     if isinstance(source_suffix, str):
345         # if str, considers as default filetype (None)
346         #
347         # The default filetype is determined on later step.
348         # By default, it is considered as restructuredtext.
349         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
350     elif isinstance(source_suffix, (list, tuple)):
351         # if list, considers as all of them are default filetype
352         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
353     elif isinstance(source_suffix, dict):
354         # if dict, convert it to OrderedDict
355         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
356     else:
357         logger.warning(__("The config value `source_suffix' expects "
358                           "a string, list of strings, or dictionary. "
359                           "But `%r' is given." % source_suffix))
360 
361 
362 def init_numfig_format(app: "Sphinx", config: Config) -> None:
363     """Initialize :confval:`numfig_format`."""
364     numfig_format = {'section': _('Section %s'),
365                      'figure': _('Fig. %s'),
366                      'table': _('Table %s'),
367                      'code-block': _('Listing %s')}
368 
369     # override default labels by configuration
370     numfig_format.update(config.numfig_format)
371     config.numfig_format = numfig_format  # type: ignore
372 
373 
374 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
375     """correct values of copyright year that are not coherent with
376     the SOURCE_DATE_EPOCH environment variable (if set)
377 
378     See https://reproducible-builds.org/specs/source-date-epoch/
379     """
380     if getenv('SOURCE_DATE_EPOCH') is not None:
381         for k in ('copyright', 'epub_copyright'):
382             if k in config:
383                 replace = r'\g<1>%s' % format_date('%Y')
384                 config[k] = copyright_year_re.sub(replace, config[k])
385 
386 
387 def check_confval_types(app: "Sphinx", config: Config) -> None:
388     """check all values for deviation from the default value's type, since
389     that can result in TypeErrors all over the place NB.
390     """
391     for confval in config:
392         default, rebuild, annotations = config.values[confval.name]
393 
394         if hasattr(default, '__call__'):
395             default = default(config)  # evaluate default value
396         if default is None and not annotations:
397             continue  # neither inferrable nor expliclitly annotated types
398 
399         if annotations is Any:
400             # any type of value is accepted
401             pass
402         elif isinstance(annotations, ENUM):
403             if not annotations.match(confval.value):
404                 msg = __("The config value `{name}` has to be a one of {candidates}, "
405                          "but `{current}` is given.")
406                 logger.warning(msg.format(name=confval.name,
407                                           current=confval.value,
408                                           candidates=annotations.candidates))
409         else:
410             if type(confval.value) is type(default):
411                 continue
412             if type(confval.value) in annotations:
413                 continue
414 
415             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
416                             set(type(default).__bases__))
417             common_bases.discard(object)
418             if common_bases:
419                 continue  # at least we share a non-trivial base class
420 
421             if annotations:
422                 msg = __("The config value `{name}' has type `{current.__name__}'; "
423                          "expected {permitted}.")
424                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
425                 if len(wrapped_annotations) > 2:
426                     permitted = "{}, or {}".format(
427                         ", ".join(wrapped_annotations[:-1]),
428                         wrapped_annotations[-1])
429                 else:
430                     permitted = " or ".join(wrapped_annotations)
431                 logger.warning(msg.format(name=confval.name,
432                                           current=type(confval.value),
433                                           permitted=permitted))
434             else:
435                 msg = __("The config value `{name}' has type `{current.__name__}', "
436                          "defaults to `{default.__name__}'.")
437                 logger.warning(msg.format(name=confval.name,
438                                           current=type(confval.value),
439                                           default=type(default)))
440 
441 
442 def check_unicode(config: Config) -> None:
443     """check all string values for non-ASCII characters in bytestrings,
444     since that can result in UnicodeErrors all over the place
445     """
446     warnings.warn('sphinx.config.check_unicode() is deprecated.',
447                   RemovedInSphinx40Warning)
448 
449     nonascii_re = re.compile(br'[\x80-\xff]')
450 
451     for name, value in config._raw_config.items():
452         if isinstance(value, bytes) and nonascii_re.search(value):
453             logger.warning(__('the config value %r is set to a string with non-ASCII '
454                               'characters; this can lead to Unicode errors occurring. '
455                               'Please use Unicode strings, e.g. %r.'), name, 'Content')
456 
457 
458 def check_primary_domain(app: "Sphinx", config: Config) -> None:
459     primary_domain = config.primary_domain
460     if primary_domain and not app.registry.has_domain(primary_domain):
461         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
462         config.primary_domain = None  # type: ignore
463 
464 
465 def check_master_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
466                      changed: Set[str], removed: Set[str]) -> Set[str]:
467     """Adjust master_doc to 'contents' to support an old project which does not have
468     no master_doc setting.
469     """
470     if (app.config.master_doc == 'index' and
471             'index' not in app.project.docnames and
472             'contents' in app.project.docnames):
473         logger.warning(__('Since v2.0, Sphinx uses "index" as master_doc by default. '
474                           'Please add "master_doc = \'contents\'" to your conf.py.'))
475         app.config.master_doc = "contents"  # type: ignore
476 
477     return changed
478 
479 
480 def setup(app: "Sphinx") -> Dict[str, Any]:
481     app.connect('config-inited', convert_source_suffix)
482     app.connect('config-inited', init_numfig_format)
483     app.connect('config-inited', correct_copyright_year)
484     app.connect('config-inited', check_confval_types)
485     app.connect('config-inited', check_primary_domain)
486     app.connect('env-get-outdated', check_master_doc)
487 
488     return {
489         'version': 'builtin',
490         'parallel_read_safe': True,
491         'parallel_write_safe': True,
492     }

</code><intended_behavior>This configuration file should be enhanced to allow users to specify preferences for handling situations where files have the same name but different extensions. Introducing a new configuration option like `file_extension_precedence` would enable users to define an ordered list of extensions that Sphinx should use to resolve conflicts. This list would be checked whenever Sphinx encounters files with the same base name, ensuring the user-preferred extension is selected. Existing functionality for projects not using this configuration should remain unchanged, preserving backward compatibility.</intended_behavior>, <file>sphinx/environment/adapters/toctree.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.toctree
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Toctree adapter for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Iterable, List
12 from typing import cast
13 
14 from docutils import nodes
15 from docutils.nodes import Element, Node
16 
17 from sphinx import addnodes
18 from sphinx.locale import __
19 from sphinx.util import url_re, logging
20 from sphinx.util.matching import Matcher
21 from sphinx.util.nodes import clean_astext, process_only_nodes
22 
23 if False:
24     # For type annotation
25     from sphinx.builders import Builder
26     from sphinx.environment import BuildEnvironment
27 
28 
29 logger = logging.getLogger(__name__)
30 
31 
32 class TocTree:
33     def __init__(self, env: "BuildEnvironment") -> None:
34         self.env = env
35 
36     def note(self, docname: str, toctreenode: addnodes.toctree) -> None:
37         """Note a TOC tree directive in a document and gather information about
38         file relations from it.
39         """
40         if toctreenode['glob']:
41             self.env.glob_toctrees.add(docname)
42         if toctreenode.get('numbered'):
43             self.env.numbered_toctrees.add(docname)
44         includefiles = toctreenode['includefiles']
45         for includefile in includefiles:
46             # note that if the included file is rebuilt, this one must be
47             # too (since the TOC of the included file could have changed)
48             self.env.files_to_rebuild.setdefault(includefile, set()).add(docname)
49         self.env.toctree_includes.setdefault(docname, []).extend(includefiles)
50 
51     def resolve(self, docname: str, builder: "Builder", toctree: addnodes.toctree,
52                 prune: bool = True, maxdepth: int = 0, titles_only: bool = False,
53                 collapse: bool = False, includehidden: bool = False) -> Element:
54         """Resolve a *toctree* node into individual bullet lists with titles
55         as items, returning None (if no containing titles are found) or
56         a new node.
57 
58         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
59         to the value of the *maxdepth* option on the *toctree* node.
60         If *titles_only* is True, only toplevel document titles will be in the
61         resulting tree.
62         If *collapse* is True, all branches not containing docname will
63         be collapsed.
64         """
65         if toctree.get('hidden', False) and not includehidden:
66             return None
67 
68         # For reading the following two helper function, it is useful to keep
69         # in mind the node structure of a toctree (using HTML-like node names
70         # for brevity):
71         #
72         # <ul>
73         #   <li>
74         #     <p><a></p>
75         #     <p><a></p>
76         #     ...
77         #     <ul>
78         #       ...
79         #     </ul>
80         #   </li>
81         # </ul>
82         #
83         # The transformation is made in two passes in order to avoid
84         # interactions between marking and pruning the tree (see bug #1046).
85 
86         toctree_ancestors = self.get_toctree_ancestors(docname)
87         excluded = Matcher(self.env.config.exclude_patterns)
88 
89         def _toctree_add_classes(node: Element, depth: int) -> None:
90             """Add 'toctree-l%d' and 'current' classes to the toctree."""
91             for subnode in node.children:
92                 if isinstance(subnode, (addnodes.compact_paragraph,
93                                         nodes.list_item)):
94                     # for <p> and <li>, indicate the depth level and recurse
95                     subnode['classes'].append('toctree-l%d' % (depth - 1))
96                     _toctree_add_classes(subnode, depth)
97                 elif isinstance(subnode, nodes.bullet_list):
98                     # for <ul>, just recurse
99                     _toctree_add_classes(subnode, depth + 1)
100                 elif isinstance(subnode, nodes.reference):
101                     # for <a>, identify which entries point to the current
102                     # document and therefore may not be collapsed
103                     if subnode['refuri'] == docname:
104                         if not subnode['anchorname']:
105                             # give the whole branch a 'current' class
106                             # (useful for styling it differently)
107                             branchnode = subnode  # type: Element
108                             while branchnode:
109                                 branchnode['classes'].append('current')
110                                 branchnode = branchnode.parent
111                         # mark the list_item as "on current page"
112                         if subnode.parent.parent.get('iscurrent'):
113                             # but only if it's not already done
114                             return
115                         while subnode:
116                             subnode['iscurrent'] = True
117                             subnode = subnode.parent
118 
119         def _entries_from_toctree(toctreenode: addnodes.toctree, parents: List[str],
120                                   separate: bool = False, subtree: bool = False
121                                   ) -> List[Element]:
122             """Return TOC entries for a toctree node."""
123             refs = [(e[0], e[1]) for e in toctreenode['entries']]
124             entries = []  # type: List[Element]
125             for (title, ref) in refs:
126                 try:
127                     refdoc = None
128                     if url_re.match(ref):
129                         if title is None:
130                             title = ref
131                         reference = nodes.reference('', '', internal=False,
132                                                     refuri=ref, anchorname='',
133                                                     *[nodes.Text(title)])
134                         para = addnodes.compact_paragraph('', '', reference)
135                         item = nodes.list_item('', para)
136                         toc = nodes.bullet_list('', item)
137                     elif ref == 'self':
138                         # 'self' refers to the document from which this
139                         # toctree originates
140                         ref = toctreenode['parent']
141                         if not title:
142                             title = clean_astext(self.env.titles[ref])
143                         reference = nodes.reference('', '', internal=True,
144                                                     refuri=ref,
145                                                     anchorname='',
146                                                     *[nodes.Text(title)])
147                         para = addnodes.compact_paragraph('', '', reference)
148                         item = nodes.list_item('', para)
149                         # don't show subitems
150                         toc = nodes.bullet_list('', item)
151                     else:
152                         if ref in parents:
153                             logger.warning(__('circular toctree references '
154                                               'detected, ignoring: %s <- %s'),
155                                            ref, ' <- '.join(parents),
156                                            location=ref)
157                             continue
158                         refdoc = ref
159                         toc = self.env.tocs[ref].deepcopy()
160                         maxdepth = self.env.metadata[ref].get('tocdepth', 0)
161                         if ref not in toctree_ancestors or (prune and maxdepth > 0):
162                             self._toctree_prune(toc, 2, maxdepth, collapse)
163                         process_only_nodes(toc, builder.tags)
164                         if title and toc.children and len(toc.children) == 1:
165                             child = toc.children[0]
166                             for refnode in child.traverse(nodes.reference):
167                                 if refnode['refuri'] == ref and \
168                                    not refnode['anchorname']:
169                                     refnode.children = [nodes.Text(title)]
170                     if not toc.children:
171                         # empty toc means: no titles will show up in the toctree
172                         logger.warning(__('toctree contains reference to document %r that '
173                                           'doesn\'t have a title: no link will be generated'),
174                                        ref, location=toctreenode)
175                 except KeyError:
176                     # this is raised if the included file does not exist
177                     if excluded(self.env.doc2path(ref, None)):
178                         message = __('toctree contains reference to excluded document %r')
179                     else:
180                         message = __('toctree contains reference to nonexisting document %r')
181 
182                     logger.warning(message, ref, location=toctreenode)
183                 else:
184                     # if titles_only is given, only keep the main title and
185                     # sub-toctrees
186                     if titles_only:
187                         # children of toc are:
188                         # - list_item + compact_paragraph + (reference and subtoc)
189                         # - only + subtoc
190                         # - toctree
191                         children = cast(Iterable[nodes.Element], toc)
192 
193                         # delete everything but the toplevel title(s)
194                         # and toctrees
195                         for toplevel in children:
196                             # nodes with length 1 don't have any children anyway
197                             if len(toplevel) > 1:
198                                 subtrees = toplevel.traverse(addnodes.toctree)
199                                 if subtrees:
200                                     toplevel[1][:] = subtrees  # type: ignore
201                                 else:
202                                     toplevel.pop(1)
203                     # resolve all sub-toctrees
204                     for subtocnode in toc.traverse(addnodes.toctree):
205                         if not (subtocnode.get('hidden', False) and
206                                 not includehidden):
207                             i = subtocnode.parent.index(subtocnode) + 1
208                             for entry in _entries_from_toctree(
209                                     subtocnode, [refdoc] + parents,
210                                     subtree=True):
211                                 subtocnode.parent.insert(i, entry)
212                                 i += 1
213                             subtocnode.parent.remove(subtocnode)
214                     if separate:
215                         entries.append(toc)
216                     else:
217                         children = cast(Iterable[nodes.Element], toc)
218                         entries.extend(children)
219             if not subtree and not separate:
220                 ret = nodes.bullet_list()
221                 ret += entries
222                 return [ret]
223             return entries
224 
225         maxdepth = maxdepth or toctree.get('maxdepth', -1)
226         if not titles_only and toctree.get('titlesonly', False):
227             titles_only = True
228         if not includehidden and toctree.get('includehidden', False):
229             includehidden = True
230 
231         # NOTE: previously, this was separate=True, but that leads to artificial
232         # separation when two or more toctree entries form a logical unit, so
233         # separating mode is no longer used -- it's kept here for history's sake
234         tocentries = _entries_from_toctree(toctree, [], separate=False)
235         if not tocentries:
236             return None
237 
238         newnode = addnodes.compact_paragraph('', '')
239         caption = toctree.attributes.get('caption')
240         if caption:
241             caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])
242             caption_node.line = toctree.line
243             caption_node.source = toctree.source
244             caption_node.rawsource = toctree['rawcaption']
245             if hasattr(toctree, 'uid'):
246                 # move uid to caption_node to translate it
247                 caption_node.uid = toctree.uid  # type: ignore
248                 del toctree.uid  # type: ignore
249             newnode += caption_node
250         newnode.extend(tocentries)
251         newnode['toctree'] = True
252 
253         # prune the tree to maxdepth, also set toc depth and current classes
254         _toctree_add_classes(newnode, 1)
255         self._toctree_prune(newnode, 1, maxdepth if prune else 0, collapse)
256 
257         if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found
258             return None
259 
260         # set the target paths in the toctrees (they are not known at TOC
261         # generation time)
262         for refnode in newnode.traverse(nodes.reference):
263             if not url_re.match(refnode['refuri']):
264                 refnode['refuri'] = builder.get_relative_uri(
265                     docname, refnode['refuri']) + refnode['anchorname']
266         return newnode
267 
268     def get_toctree_ancestors(self, docname: str) -> List[str]:
269         parent = {}
270         for p, children in self.env.toctree_includes.items():
271             for child in children:
272                 parent[child] = p
273         ancestors = []  # type: List[str]
274         d = docname
275         while d in parent and d not in ancestors:
276             ancestors.append(d)
277             d = parent[d]
278         return ancestors
279 
280     def _toctree_prune(self, node: Element, depth: int, maxdepth: int, collapse: bool = False
281                        ) -> None:
282         """Utility: Cut a TOC at a specified depth."""
283         for subnode in node.children[:]:
284             if isinstance(subnode, (addnodes.compact_paragraph,
285                                     nodes.list_item)):
286                 # for <p> and <li>, just recurse
287                 self._toctree_prune(subnode, depth, maxdepth, collapse)
288             elif isinstance(subnode, nodes.bullet_list):
289                 # for <ul>, determine if the depth is too large or if the
290                 # entry is to be collapsed
291                 if maxdepth > 0 and depth > maxdepth:
292                     subnode.parent.replace(subnode, [])
293                 else:
294                     # cull sub-entries whose parents aren't 'current'
295                     if (collapse and depth > 1 and
296                             'iscurrent' not in subnode.parent):
297                         subnode.parent.remove(subnode)
298                     else:
299                         # recurse on visible children
300                         self._toctree_prune(subnode, depth + 1, maxdepth,  collapse)
301 
302     def get_toc_for(self, docname: str, builder: "Builder") -> Node:
303         """Return a TOC nodetree -- for use on the same page only!"""
304         tocdepth = self.env.metadata[docname].get('tocdepth', 0)
305         try:
306             toc = self.env.tocs[docname].deepcopy()
307             self._toctree_prune(toc, 2, tocdepth)
308         except KeyError:
309             # the document does not exist anymore: return a dummy node that
310             # renders to nothing
311             return nodes.paragraph()
312         process_only_nodes(toc, builder.tags)
313         for node in toc.traverse(nodes.reference):
314             node['refuri'] = node['anchorname'] or '#'
315         return toc
316 
317     def get_toctree_for(self, docname: str, builder: "Builder", collapse: bool,
318                         **kwargs: Any) -> Element:
319         """Return the global TOC nodetree."""
320         doctree = self.env.get_doctree(self.env.config.master_doc)
321         toctrees = []  # type: List[Element]
322         if 'includehidden' not in kwargs:
323             kwargs['includehidden'] = True
324         if 'maxdepth' not in kwargs:
325             kwargs['maxdepth'] = 0
326         kwargs['collapse'] = collapse
327         for toctreenode in doctree.traverse(addnodes.toctree):
328             toctree = self.resolve(docname, builder, toctreenode, prune=True, **kwargs)
329             if toctree:
330                 toctrees.append(toctree)
331         if not toctrees:
332             return None
333         result = toctrees[0]
334         for toctree in toctrees[1:]:
335             result.extend(toctree.children)
336         return result

</code><intended_behavior>Modify the logic that interprets the `toctree` directive to consult the new `file_extension_precedence` configuration (introduced in `sphinx/config.py`). When building the documentation structure, if Sphinx detects multiple files with the same base name (but different extensions) referenced within a toctree, it should use the order specified in `file_extension_precedence` to resolve which file to include. If no preference is specified, Sphinx should either follow a default order or explicitly log a warning indicating the ambiguity and the chosen file, advising the user to specify their preference to avoid unexpected behavior.</intended_behavior>]
2025-10-16 00:31:15.407 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:31:15.407 | INFO     | Search-only: skipping patch selection
2025-10-16 00:31:15.482 | INFO     | Task sphinx-doc__sphinx-7351 completed successfully.
2025-10-16 00:31:15.483 | INFO     | No patch generated. You can try running ACR again.
