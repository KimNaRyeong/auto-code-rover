2025-10-16 00:48:14.236 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:48:17.233 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=199, output_tokens=12, cost=0.002350
2025-10-16 00:48:17.234 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 00:48:17.238 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:48:24.161 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=508, output_tokens=303, cost=0.014170
2025-10-16 00:48:24.165 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:48:26.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=657, output_tokens=86, cost=0.009150
2025-10-16 00:48:26.886 | DEBUG    | Extracted a valid json.
2025-10-16 00:48:26.886 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"generateIndex\")",
        "search_method(\"categorizeIndexEntries\")",
        "search_method(\"createHtmlOutput\")",
        "search_class(\"IndexGenerator\")",
        "search_class(\"HtmlOutputCreator\")",
        "search_code(\"special characters in index\")",
        "search_code(\"Symbols section\")"
    ],
    "bug_locations": []
}
2025-10-16 00:48:26.900 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:48:26.900 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:48:36.710 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1075, output_tokens=430, cost=0.023650
2025-10-16 00:48:36.721 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:48:39.403 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1721, output_tokens=86, cost=0.019790
2025-10-16 00:48:39.405 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:48:42.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=96, cost=0.007280
2025-10-16 00:48:42.196 | DEBUG    | Extracted a valid json.
2025-10-16 00:48:42.196 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"indexEntries\")",
        "search_method(\"buildIndex\")",
        "search_code(\"sort index entries\")",
        "search_code(\"categorize entries\")",
        "search_method(\"formatHtml\")",
        "search_method(\"outputHtml\")",
        "search_code(\"non-alphabetic index entries\")",
        "search_code(\"index special handling\")"
    ],
    "bug_locations": []
}
2025-10-16 00:48:42.220 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:48:42.221 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:48:53.141 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2093, output_tokens=439, cost=0.034100
2025-10-16 00:48:53.146 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:48:55.295 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2748, output_tokens=59, cost=0.029250
2025-10-16 00:48:55.297 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:48:57.786 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=413, output_tokens=70, cost=0.006230
2025-10-16 00:48:57.786 | DEBUG    | Extracted a valid json.
2025-10-16 00:48:57.787 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"HTML\")",
        "search_code(\"index page generation\")",
        "search_code(\"character encoding\")",
        "search_code(\"character comparison\")",
        "search_code(\"section titles\")",
        "search_code(\"header generation\")"
    ],
    "bug_locations": []
}
2025-10-16 00:48:57.928 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:48:57.929 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:49:13.327 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3774, output_tokens=702, cost=0.058800
2025-10-16 00:49:13.334 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:49:19.786 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4692, output_tokens=258, cost=0.054660
2025-10-16 00:49:19.789 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:49:25.937 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=612, output_tokens=223, cost=0.012810
2025-10-16 00:49:25.938 | DEBUG    | Extracted a valid json.
2025-10-16 00:49:25.938 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/writers/html.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should contain logic that generates the HTML output for index pages. The intended behavior would be to modify the method responsible for categorizing index entries to ensure that all entries starting with special characters are consolidated under a single \"Symbols\" section. This might involve adjusting how characters are compared or adding a unified category for all such special characters."
        },
        {
            "file": "sphinx/builders/html/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "In this central file for HTML building, the target would be to ensure the logic that organizes index entries into sections recognizes and groups any entries starting with special characters like '@', '£', and '←' into one \"Symbols\" section to prevent duplication. This might require adding specific checks or logic to treat these characters uniformly when categorizing index entries."
        }
    ]
}
2025-10-16 00:49:25.942 | DEBUG    | Bug location extracted successfully: [<file>sphinx/writers/html.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.html
3     ~~~~~~~~~~~~~~~~~~~
4 
5     docutils writers handling Sphinx' custom nodes.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import copy
12 import os
13 import posixpath
14 import re
15 import warnings
16 from typing import Any, Iterable, Tuple
17 from typing import cast
18 
19 from docutils import nodes
20 from docutils.nodes import Element, Node, Text
21 from docutils.writers.html4css1 import Writer, HTMLTranslator as BaseTranslator
22 
23 from sphinx import addnodes
24 from sphinx.builders import Builder
25 from sphinx.deprecation import RemovedInSphinx40Warning
26 from sphinx.locale import admonitionlabels, _, __
27 from sphinx.util import logging
28 from sphinx.util.docutils import SphinxTranslator
29 from sphinx.util.images import get_image_size
30 
31 if False:
32     # For type annotation
33     from sphinx.builders.html import StandaloneHTMLBuilder
34 
35 
36 logger = logging.getLogger(__name__)
37 
38 # A good overview of the purpose behind these classes can be found here:
39 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html
40 
41 
42 def multiply_length(length: str, scale: int) -> str:
43     """Multiply *length* (width or height) by *scale*."""
44     matched = re.match(r'^(\d*\.?\d*)\s*(\S*)$', length)
45     if not matched:
46         return length
47     elif scale == 100:
48         return length
49     else:
50         amount, unit = matched.groups()
51         result = float(amount) * scale / 100
52         return "%s%s" % (int(result), unit)
53 
54 
55 class HTMLWriter(Writer):
56 
57     # override embed-stylesheet default value to 0.
58     settings_spec = copy.deepcopy(Writer.settings_spec)
59     for _setting in settings_spec[2]:
60         if '--embed-stylesheet' in _setting[1]:
61             _setting[2]['default'] = 0
62 
63     def __init__(self, builder: "StandaloneHTMLBuilder") -> None:
64         super().__init__()
65         self.builder = builder
66 
67     def translate(self) -> None:
68         # sadly, this is mostly copied from parent class
69         visitor = self.builder.create_translator(self.document, self.builder)
70         self.visitor = cast(HTMLTranslator, visitor)
71         self.document.walkabout(visitor)
72         self.output = self.visitor.astext()
73         for attr in ('head_prefix', 'stylesheet', 'head', 'body_prefix',
74                      'body_pre_docinfo', 'docinfo', 'body', 'fragment',
75                      'body_suffix', 'meta', 'title', 'subtitle', 'header',
76                      'footer', 'html_prolog', 'html_head', 'html_title',
77                      'html_subtitle', 'html_body', ):
78             setattr(self, attr, getattr(visitor, attr, None))
79         self.clean_meta = ''.join(self.visitor.meta[2:])
80 
81 
82 class HTMLTranslator(SphinxTranslator, BaseTranslator):
83     """
84     Our custom HTML translator.
85     """
86 
87     builder = None  # type: StandaloneHTMLBuilder
88 
89     def __init__(self, *args: Any) -> None:
90         if isinstance(args[0], nodes.document) and isinstance(args[1], Builder):
91             document, builder = args
92         else:
93             warnings.warn('The order of arguments for HTMLTranslator has been changed. '
94                           'Please give "document" as 1st and "builder" as 2nd.',
95                           RemovedInSphinx40Warning, stacklevel=2)
96             builder, document = args
97         super().__init__(document, builder)
98 
99         self.highlighter = self.builder.highlighter
100         self.docnames = [self.builder.current_docname]  # for singlehtml builder
101         self.manpages_url = self.config.manpages_url
102         self.protect_literal_text = 0
103         self.permalink_text = self.config.html_add_permalinks
104         # support backwards-compatible setting to a bool
105         if not isinstance(self.permalink_text, str):
106             self.permalink_text = '¶' if self.permalink_text else ''
107         self.permalink_text = self.encode(self.permalink_text)
108         self.secnumber_suffix = self.config.html_secnumber_suffix
109         self.param_separator = ''
110         self.optional_param_level = 0
111         self._table_row_index = 0
112         self._fieldlist_row_index = 0
113         self.required_params_left = 0
114 
115     def visit_start_of_file(self, node: Element) -> None:
116         # only occurs in the single-file builder
117         self.docnames.append(node['docname'])
118         self.body.append('<span id="document-%s"></span>' % node['docname'])
119 
120     def depart_start_of_file(self, node: Element) -> None:
121         self.docnames.pop()
122 
123     def visit_desc(self, node: Element) -> None:
124         self.body.append(self.starttag(node, 'dl', CLASS=node['objtype']))
125 
126     def depart_desc(self, node: Element) -> None:
127         self.body.append('</dl>\n\n')
128 
129     def visit_desc_signature(self, node: Element) -> None:
130         # the id is set automatically
131         self.body.append(self.starttag(node, 'dt'))
132 
133     def depart_desc_signature(self, node: Element) -> None:
134         if not node.get('is_multiline'):
135             self.add_permalink_ref(node, _('Permalink to this definition'))
136         self.body.append('</dt>\n')
137 
138     def visit_desc_signature_line(self, node: Element) -> None:
139         pass
140 
141     def depart_desc_signature_line(self, node: Element) -> None:
142         if node.get('add_permalink'):
143             # the permalink info is on the parent desc_signature node
144             self.add_permalink_ref(node.parent, _('Permalink to this definition'))
145         self.body.append('<br />')
146 
147     def visit_desc_addname(self, node: Element) -> None:
148         self.body.append(self.starttag(node, 'code', '', CLASS='descclassname'))
149 
150     def depart_desc_addname(self, node: Element) -> None:
151         self.body.append('</code>')
152 
153     def visit_desc_type(self, node: Element) -> None:
154         pass
155 
156     def depart_desc_type(self, node: Element) -> None:
157         pass
158 
159     def visit_desc_returns(self, node: Element) -> None:
160         self.body.append(' &#x2192; ')
161 
162     def depart_desc_returns(self, node: Element) -> None:
163         pass
164 
165     def visit_desc_name(self, node: Element) -> None:
166         self.body.append(self.starttag(node, 'code', '', CLASS='descname'))
167 
168     def depart_desc_name(self, node: Element) -> None:
169         self.body.append('</code>')
170 
171     def visit_desc_parameterlist(self, node: Element) -> None:
172         self.body.append('<span class="sig-paren">(</span>')
173         self.first_param = 1
174         self.optional_param_level = 0
175         # How many required parameters are left.
176         self.required_params_left = sum([isinstance(c, addnodes.desc_parameter)
177                                          for c in node.children])
178         self.param_separator = node.child_text_separator
179 
180     def depart_desc_parameterlist(self, node: Element) -> None:
181         self.body.append('<span class="sig-paren">)</span>')
182 
183     # If required parameters are still to come, then put the comma after
184     # the parameter.  Otherwise, put the comma before.  This ensures that
185     # signatures like the following render correctly (see issue #1001):
186     #
187     #     foo([a, ]b, c[, d])
188     #
189     def visit_desc_parameter(self, node: Element) -> None:
190         if self.first_param:
191             self.first_param = 0
192         elif not self.required_params_left:
193             self.body.append(self.param_separator)
194         if self.optional_param_level == 0:
195             self.required_params_left -= 1
196         if not node.hasattr('noemph'):
197             self.body.append('<em>')
198 
199     def depart_desc_parameter(self, node: Element) -> None:
200         if not node.hasattr('noemph'):
201             self.body.append('</em>')
202         if self.required_params_left:
203             self.body.append(self.param_separator)
204 
205     def visit_desc_optional(self, node: Element) -> None:
206         self.optional_param_level += 1
207         self.body.append('<span class="optional">[</span>')
208 
209     def depart_desc_optional(self, node: Element) -> None:
210         self.optional_param_level -= 1
211         self.body.append('<span class="optional">]</span>')
212 
213     def visit_desc_annotation(self, node: Element) -> None:
214         self.body.append(self.starttag(node, 'em', '', CLASS='property'))
215 
216     def depart_desc_annotation(self, node: Element) -> None:
217         self.body.append('</em>')
218 
219     def visit_desc_content(self, node: Element) -> None:
220         self.body.append(self.starttag(node, 'dd', ''))
221 
222     def depart_desc_content(self, node: Element) -> None:
223         self.body.append('</dd>')
224 
225     def visit_versionmodified(self, node: Element) -> None:
226         self.body.append(self.starttag(node, 'div', CLASS=node['type']))
227 
228     def depart_versionmodified(self, node: Element) -> None:
229         self.body.append('</div>\n')
230 
231     # overwritten
232     def visit_reference(self, node: Element) -> None:
233         atts = {'class': 'reference'}
234         if node.get('internal') or 'refuri' not in node:
235             atts['class'] += ' internal'
236         else:
237             atts['class'] += ' external'
238         if 'refuri' in node:
239             atts['href'] = node['refuri'] or '#'
240             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):
241                 atts['href'] = self.cloak_mailto(atts['href'])
242                 self.in_mailto = True
243         else:
244             assert 'refid' in node, \
245                    'References must have "refuri" or "refid" attribute.'
246             atts['href'] = '#' + node['refid']
247         if not isinstance(node.parent, nodes.TextElement):
248             assert len(node) == 1 and isinstance(node[0], nodes.image)
249             atts['class'] += ' image-reference'
250         if 'reftitle' in node:
251             atts['title'] = node['reftitle']
252         if 'target' in node:
253             atts['target'] = node['target']
254         self.body.append(self.starttag(node, 'a', '', **atts))
255 
256         if node.get('secnumber'):
257             self.body.append(('%s' + self.secnumber_suffix) %
258                              '.'.join(map(str, node['secnumber'])))
259 
260     def visit_number_reference(self, node: Element) -> None:
261         self.visit_reference(node)
262 
263     def depart_number_reference(self, node: Element) -> None:
264         self.depart_reference(node)
265 
266     # overwritten -- we don't want source comments to show up in the HTML
267     def visit_comment(self, node: Element) -> None:  # type: ignore
268         raise nodes.SkipNode
269 
270     # overwritten
271     def visit_admonition(self, node: Element, name: str = '') -> None:
272         self.body.append(self.starttag(
273             node, 'div', CLASS=('admonition ' + name)))
274         if name:
275             node.insert(0, nodes.title(name, admonitionlabels[name]))
276         self.set_first_last(node)
277 
278     def visit_seealso(self, node: Element) -> None:
279         self.visit_admonition(node, 'seealso')
280 
281     def depart_seealso(self, node: Element) -> None:
282         self.depart_admonition(node)
283 
284     def get_secnumber(self, node: Element) -> Tuple[int, ...]:
285         if node.get('secnumber'):
286             return node['secnumber']
287         elif isinstance(node.parent, nodes.section):
288             if self.builder.name == 'singlehtml':
289                 docname = self.docnames[-1]
290                 anchorname = "%s/#%s" % (docname, node.parent['ids'][0])
291                 if anchorname not in self.builder.secnumbers:
292                     anchorname = "%s/" % docname  # try first heading which has no anchor
293             else:
294                 anchorname = '#' + node.parent['ids'][0]
295                 if anchorname not in self.builder.secnumbers:
296                     anchorname = ''  # try first heading which has no anchor
297 
298             if self.builder.secnumbers.get(anchorname):
299                 return self.builder.secnumbers[anchorname]
300 
301         return None
302 
303     def add_secnumber(self, node: Element) -> None:
304         secnumber = self.get_secnumber(node)
305         if secnumber:
306             self.body.append('<span class="section-number">%s</span>' %
307                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))
308 
309     def add_fignumber(self, node: Element) -> None:
310         def append_fignumber(figtype: str, figure_id: str) -> None:
311             if self.builder.name == 'singlehtml':
312                 key = "%s/%s" % (self.docnames[-1], figtype)
313             else:
314                 key = figtype
315 
316             if figure_id in self.builder.fignumbers.get(key, {}):
317                 self.body.append('<span class="caption-number">')
318                 prefix = self.builder.config.numfig_format.get(figtype)
319                 if prefix is None:
320                     msg = __('numfig_format is not defined for %s') % figtype
321                     logger.warning(msg)
322                 else:
323                     numbers = self.builder.fignumbers[key][figure_id]
324                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')
325                     self.body.append('</span>')
326 
327         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)
328         if figtype:
329             if len(node['ids']) == 0:
330                 msg = __('Any IDs not assigned for %s node') % node.tagname
331                 logger.warning(msg, location=node)
332             else:
333                 append_fignumber(figtype, node['ids'][0])
334 
335     def add_permalink_ref(self, node: Element, title: str) -> None:
336         if node['ids'] and self.permalink_text and self.builder.add_permalinks:
337             format = '<a class="headerlink" href="#%s" title="%s">%s</a>'
338             self.body.append(format % (node['ids'][0], title, self.permalink_text))
339 
340     def generate_targets_for_listing(self, node: Element) -> None:
341         """Generate hyperlink targets for listings.
342 
343         Original visit_bullet_list(), visit_definition_list() and visit_enumerated_list()
344         generates hyperlink targets inside listing tags (<ul>, <ol> and <dl>) if multiple
345         IDs are assigned to listings.  That is invalid DOM structure.
346         (This is a bug of docutils <= 0.12)
347 
348         This exports hyperlink targets before listings to make valid DOM structure.
349         """
350         for id in node['ids'][1:]:
351             self.body.append('<span id="%s"></span>' % id)
352             node['ids'].remove(id)
353 
354     # overwritten
355     def visit_bullet_list(self, node: Element) -> None:
356         if len(node) == 1 and isinstance(node[0], addnodes.toctree):
357             # avoid emitting empty <ul></ul>
358             raise nodes.SkipNode
359         self.generate_targets_for_listing(node)
360         super().visit_bullet_list(node)
361 
362     # overwritten
363     def visit_enumerated_list(self, node: Element) -> None:
364         self.generate_targets_for_listing(node)
365         super().visit_enumerated_list(node)
366 
367     # overwritten
368     def visit_definition(self, node: Element) -> None:
369         # don't insert </dt> here.
370         self.body.append(self.starttag(node, 'dd', ''))
371 
372     # overwritten
373     def depart_definition(self, node: Element) -> None:
374         self.body.append('</dd>\n')
375 
376     # overwritten
377     def visit_classifier(self, node: Element) -> None:
378         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))
379 
380     # overwritten
381     def depart_classifier(self, node: Element) -> None:
382         self.body.append('</span>')
383 
384         next_node = node.next_node(descend=False, siblings=True)  # type: Node
385         if not isinstance(next_node, nodes.classifier):
386             # close `<dt>` tag at the tail of classifiers
387             self.body.append('</dt>')
388 
389     # overwritten
390     def visit_term(self, node: Element) -> None:
391         self.body.append(self.starttag(node, 'dt', ''))
392 
393     # overwritten
394     def depart_term(self, node: Element) -> None:
395         next_node = node.next_node(descend=False, siblings=True)  # type: Node
396         if isinstance(next_node, nodes.classifier):
397             # Leave the end tag to `self.depart_classifier()`, in case
398             # there's a classifier.
399             pass
400         else:
401             self.body.append('</dt>')
402 
403     # overwritten
404     def visit_title(self, node: Element) -> None:
405         super().visit_title(node)
406         self.add_secnumber(node)
407         self.add_fignumber(node.parent)
408         if isinstance(node.parent, nodes.table):
409             self.body.append('<span class="caption-text">')
410 
411     def depart_title(self, node: Element) -> None:
412         close_tag = self.context[-1]
413         if (self.permalink_text and self.builder.add_permalinks and
414            node.parent.hasattr('ids') and node.parent['ids']):
415             # add permalink anchor
416             if close_tag.startswith('</h'):
417                 self.add_permalink_ref(node.parent, _('Permalink to this headline'))
418             elif close_tag.startswith('</a></h'):
419                 self.body.append('</a><a class="headerlink" href="#%s" ' %
420                                  node.parent['ids'][0] +
421                                  'title="%s">%s' % (
422                                      _('Permalink to this headline'),
423                                      self.permalink_text))
424             elif isinstance(node.parent, nodes.table):
425                 self.body.append('</span>')
426                 self.add_permalink_ref(node.parent, _('Permalink to this table'))
427         elif isinstance(node.parent, nodes.table):
428             self.body.append('</span>')
429 
430         super().depart_title(node)
431 
432     # overwritten
433     def visit_literal_block(self, node: Element) -> None:
434         if node.rawsource != node.astext():
435             # most probably a parsed-literal block -- don't highlight
436             return super().visit_literal_block(node)
437 
438         lang = node.get('language', 'default')
439         linenos = node.get('linenos', False)
440         highlight_args = node.get('highlight_args', {})
441         highlight_args['force'] = node.get('force', False)
442         if lang is self.builder.config.highlight_language:
443             # only pass highlighter options for original language
444             opts = self.builder.config.highlight_options
445         else:
446             opts = {}
447 
448         if linenos and self.builder.config.html_codeblock_linenos_style:
449             linenos = self.builder.config.html_codeblock_linenos_style
450 
451         highlighted = self.highlighter.highlight_block(
452             node.rawsource, lang, opts=opts, linenos=linenos,
453             location=(self.builder.current_docname, node.line), **highlight_args
454         )
455         starttag = self.starttag(node, 'div', suffix='',
456                                  CLASS='highlight-%s notranslate' % lang)
457         self.body.append(starttag + highlighted + '</div>\n')
458         raise nodes.SkipNode
459 
460     def visit_caption(self, node: Element) -> None:
461         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
462             self.body.append('<div class="code-block-caption">')
463         else:
464             super().visit_caption(node)
465         self.add_fignumber(node.parent)
466         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))
467 
468     def depart_caption(self, node: Element) -> None:
469         self.body.append('</span>')
470 
471         # append permalink if available
472         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
473             self.add_permalink_ref(node.parent, _('Permalink to this code'))
474         elif isinstance(node.parent, nodes.figure):
475             self.add_permalink_ref(node.parent, _('Permalink to this image'))
476         elif node.parent.get('toctree'):
477             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))
478 
479         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
480             self.body.append('</div>\n')
481         else:
482             super().depart_caption(node)
483 
484     def visit_doctest_block(self, node: Element) -> None:
485         self.visit_literal_block(node)
486 
487     # overwritten to add the <div> (for XHTML compliance)
488     def visit_block_quote(self, node: Element) -> None:
489         self.body.append(self.starttag(node, 'blockquote') + '<div>')
490 
491     def depart_block_quote(self, node: Element) -> None:
492         self.body.append('</div></blockquote>\n')
493 
494     # overwritten
495     def visit_literal(self, node: Element) -> None:
496         if 'kbd' in node['classes']:
497             self.body.append(self.starttag(node, 'kbd', '',
498                                            CLASS='docutils literal notranslate'))
499         else:
500             self.body.append(self.starttag(node, 'code', '',
501                                            CLASS='docutils literal notranslate'))
502             self.protect_literal_text += 1
503 
504     def depart_literal(self, node: Element) -> None:
505         if 'kbd' in node['classes']:
506             self.body.append('</kbd>')
507         else:
508             self.protect_literal_text -= 1
509             self.body.append('</code>')
510 
511     def visit_productionlist(self, node: Element) -> None:
512         self.body.append(self.starttag(node, 'pre'))
513         names = []
514         productionlist = cast(Iterable[addnodes.production], node)
515         for production in productionlist:
516             names.append(production['tokenname'])
517         maxlen = max(len(name) for name in names)
518         lastname = None
519         for production in productionlist:
520             if production['tokenname']:
521                 lastname = production['tokenname'].ljust(maxlen)
522                 self.body.append(self.starttag(production, 'strong', ''))
523                 self.body.append(lastname + '</strong> ::= ')
524             elif lastname is not None:
525                 self.body.append('%s     ' % (' ' * len(lastname)))
526             production.walkabout(self)
527             self.body.append('\n')
528         self.body.append('</pre>\n')
529         raise nodes.SkipNode
530 
531     def depart_productionlist(self, node: Element) -> None:
532         pass
533 
534     def visit_production(self, node: Element) -> None:
535         pass
536 
537     def depart_production(self, node: Element) -> None:
538         pass
539 
540     def visit_centered(self, node: Element) -> None:
541         self.body.append(self.starttag(node, 'p', CLASS="centered") +
542                          '<strong>')
543 
544     def depart_centered(self, node: Element) -> None:
545         self.body.append('</strong></p>')
546 
547     # overwritten
548     def should_be_compact_paragraph(self, node: Node) -> bool:
549         """Determine if the <p> tags around paragraph can be omitted."""
550         if isinstance(node.parent, addnodes.desc_content):
551             # Never compact desc_content items.
552             return False
553         if isinstance(node.parent, addnodes.versionmodified):
554             # Never compact versionmodified nodes.
555             return False
556         return super().should_be_compact_paragraph(node)
557 
558     def visit_compact_paragraph(self, node: Element) -> None:
559         pass
560 
561     def depart_compact_paragraph(self, node: Element) -> None:
562         pass
563 
564     def visit_download_reference(self, node: Element) -> None:
565         atts = {'class': 'reference download',
566                 'download': ''}
567 
568         if not self.builder.download_support:
569             self.context.append('')
570         elif 'refuri' in node:
571             atts['class'] += ' external'
572             atts['href'] = node['refuri']
573             self.body.append(self.starttag(node, 'a', '', **atts))
574             self.context.append('</a>')
575         elif 'filename' in node:
576             atts['class'] += ' internal'
577             atts['href'] = posixpath.join(self.builder.dlpath, node['filename'])
578             self.body.append(self.starttag(node, 'a', '', **atts))
579             self.context.append('</a>')
580         else:
581             self.context.append('')
582 
583     def depart_download_reference(self, node: Element) -> None:
584         self.body.append(self.context.pop())
585 
586     # overwritten
587     def visit_image(self, node: Element) -> None:
588         olduri = node['uri']
589         # rewrite the URI if the environment knows about it
590         if olduri in self.builder.images:
591             node['uri'] = posixpath.join(self.builder.imgpath,
592                                          self.builder.images[olduri])
593 
594         if 'scale' in node:
595             # Try to figure out image height and width.  Docutils does that too,
596             # but it tries the final file name, which does not necessarily exist
597             # yet at the time the HTML file is written.
598             if not ('width' in node and 'height' in node):
599                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))
600                 if size is None:
601                     logger.warning(__('Could not obtain image size. :scale: option is ignored.'),  # NOQA
602                                    location=node)
603                 else:
604                     if 'width' not in node:
605                         node['width'] = str(size[0])
606                     if 'height' not in node:
607                         node['height'] = str(size[1])
608 
609         uri = node['uri']
610         if uri.lower().endswith(('svg', 'svgz')):
611             atts = {'src': uri}
612             if 'width' in node:
613                 atts['width'] = node['width']
614             if 'height' in node:
615                 atts['height'] = node['height']
616             if 'scale' in node:
617                 if 'width' in atts:
618                     atts['width'] = multiply_length(atts['width'], node['scale'])
619                 if 'height' in atts:
620                     atts['height'] = multiply_length(atts['height'], node['scale'])
621             atts['alt'] = node.get('alt', uri)
622             if 'align' in node:
623                 atts['class'] = 'align-%s' % node['align']
624             self.body.append(self.emptytag(node, 'img', '', **atts))
625             return
626 
627         super().visit_image(node)
628 
629     # overwritten
630     def depart_image(self, node: Element) -> None:
631         if node['uri'].lower().endswith(('svg', 'svgz')):
632             pass
633         else:
634             super().depart_image(node)
635 
636     def visit_toctree(self, node: Element) -> None:
637         # this only happens when formatting a toc from env.tocs -- in this
638         # case we don't want to include the subtree
639         raise nodes.SkipNode
640 
641     def visit_index(self, node: Element) -> None:
642         raise nodes.SkipNode
643 
644     def visit_tabular_col_spec(self, node: Element) -> None:
645         raise nodes.SkipNode
646 
647     def visit_glossary(self, node: Element) -> None:
648         pass
649 
650     def depart_glossary(self, node: Element) -> None:
651         pass
652 
653     def visit_acks(self, node: Element) -> None:
654         pass
655 
656     def depart_acks(self, node: Element) -> None:
657         pass
658 
659     def visit_hlist(self, node: Element) -> None:
660         self.body.append('<table class="hlist"><tr>')
661 
662     def depart_hlist(self, node: Element) -> None:
663         self.body.append('</tr></table>\n')
664 
665     def visit_hlistcol(self, node: Element) -> None:
666         self.body.append('<td>')
667 
668     def depart_hlistcol(self, node: Element) -> None:
669         self.body.append('</td>')
670 
671     def visit_option_group(self, node: Element) -> None:
672         super().visit_option_group(node)
673         self.context[-2] = self.context[-2].replace('&nbsp;', '&#160;')
674 
675     # overwritten
676     def visit_Text(self, node: Text) -> None:
677         text = node.astext()
678         encoded = self.encode(text)
679         if self.protect_literal_text:
680             # moved here from base class's visit_literal to support
681             # more formatting in literal nodes
682             for token in self.words_and_spaces.findall(encoded):
683                 if token.strip():
684                     # protect literal text from line wrapping
685                     self.body.append('<span class="pre">%s</span>' % token)
686                 elif token in ' \n':
687                     # allow breaks at whitespace
688                     self.body.append(token)
689                 else:
690                     # protect runs of multiple spaces; the last one can wrap
691                     self.body.append('&#160;' * (len(token) - 1) + ' ')
692         else:
693             if self.in_mailto and self.settings.cloak_email_addresses:
694                 encoded = self.cloak_email(encoded)
695             self.body.append(encoded)
696 
697     def visit_note(self, node: Element) -> None:
698         self.visit_admonition(node, 'note')
699 
700     def depart_note(self, node: Element) -> None:
701         self.depart_admonition(node)
702 
703     def visit_warning(self, node: Element) -> None:
704         self.visit_admonition(node, 'warning')
705 
706     def depart_warning(self, node: Element) -> None:
707         self.depart_admonition(node)
708 
709     def visit_attention(self, node: Element) -> None:
710         self.visit_admonition(node, 'attention')
711 
712     def depart_attention(self, node: Element) -> None:
713         self.depart_admonition(node)
714 
715     def visit_caution(self, node: Element) -> None:
716         self.visit_admonition(node, 'caution')
717 
718     def depart_caution(self, node: Element) -> None:
719         self.depart_admonition(node)
720 
721     def visit_danger(self, node: Element) -> None:
722         self.visit_admonition(node, 'danger')
723 
724     def depart_danger(self, node: Element) -> None:
725         self.depart_admonition(node)
726 
727     def visit_error(self, node: Element) -> None:
728         self.visit_admonition(node, 'error')
729 
730     def depart_error(self, node: Element) -> None:
731         self.depart_admonition(node)
732 
733     def visit_hint(self, node: Element) -> None:
734         self.visit_admonition(node, 'hint')
735 
736     def depart_hint(self, node: Element) -> None:
737         self.depart_admonition(node)
738 
739     def visit_important(self, node: Element) -> None:
740         self.visit_admonition(node, 'important')
741 
742     def depart_important(self, node: Element) -> None:
743         self.depart_admonition(node)
744 
745     def visit_tip(self, node: Element) -> None:
746         self.visit_admonition(node, 'tip')
747 
748     def depart_tip(self, node: Element) -> None:
749         self.depart_admonition(node)
750 
751     def visit_literal_emphasis(self, node: Element) -> None:
752         return self.visit_emphasis(node)
753 
754     def depart_literal_emphasis(self, node: Element) -> None:
755         return self.depart_emphasis(node)
756 
757     def visit_literal_strong(self, node: Element) -> None:
758         return self.visit_strong(node)
759 
760     def depart_literal_strong(self, node: Element) -> None:
761         return self.depart_strong(node)
762 
763     def visit_abbreviation(self, node: Element) -> None:
764         attrs = {}
765         if node.hasattr('explanation'):
766             attrs['title'] = node['explanation']
767         self.body.append(self.starttag(node, 'abbr', '', **attrs))
768 
769     def depart_abbreviation(self, node: Element) -> None:
770         self.body.append('</abbr>')
771 
772     def visit_manpage(self, node: Element) -> None:
773         self.visit_literal_emphasis(node)
774         if self.manpages_url:
775             node['refuri'] = self.manpages_url.format(**node.attributes)
776             self.visit_reference(node)
777 
778     def depart_manpage(self, node: Element) -> None:
779         if self.manpages_url:
780             self.depart_reference(node)
781         self.depart_literal_emphasis(node)
782 
783     # overwritten to add even/odd classes
784 
785     def visit_table(self, node: Element) -> None:
786         self._table_row_index = 0
787         return super().visit_table(node)
788 
789     def visit_row(self, node: Element) -> None:
790         self._table_row_index += 1
791         if self._table_row_index % 2 == 0:
792             node['classes'].append('row-even')
793         else:
794             node['classes'].append('row-odd')
795         self.body.append(self.starttag(node, 'tr', ''))
796         node.column = 0  # type: ignore
797 
798     def visit_entry(self, node: Element) -> None:
799         super().visit_entry(node)
800         if self.body[-1] == '&nbsp;':
801             self.body[-1] = '&#160;'
802 
803     def visit_field_list(self, node: Element) -> None:
804         self._fieldlist_row_index = 0
805         return super().visit_field_list(node)
806 
807     def visit_field(self, node: Element) -> None:
808         self._fieldlist_row_index += 1
809         if self._fieldlist_row_index % 2 == 0:
810             node['classes'].append('field-even')
811         else:
812             node['classes'].append('field-odd')
813         self.body.append(self.starttag(node, 'tr', '', CLASS='field'))
814 
815     def visit_field_name(self, node: Element) -> None:
816         context_count = len(self.context)
817         super().visit_field_name(node)
818         if context_count != len(self.context):
819             self.context[-1] = self.context[-1].replace('&nbsp;', '&#160;')
820 
821     def visit_math(self, node: Element, math_env: str = '') -> None:
822         name = self.builder.math_renderer_name
823         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]
824         visit(self, node)
825 
826     def depart_math(self, node: Element, math_env: str = '') -> None:
827         name = self.builder.math_renderer_name
828         _, depart = self.builder.app.registry.html_inline_math_renderers[name]
829         if depart:
830             depart(self, node)
831 
832     def visit_math_block(self, node: Element, math_env: str = '') -> None:
833         name = self.builder.math_renderer_name
834         visit, _ = self.builder.app.registry.html_block_math_renderers[name]
835         visit(self, node)
836 
837     def depart_math_block(self, node: Element, math_env: str = '') -> None:
838         name = self.builder.math_renderer_name
839         _, depart = self.builder.app.registry.html_block_math_renderers[name]
840         if depart:
841             depart(self, node)
842 
843     def unknown_visit(self, node: Node) -> None:
844         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)

</code><intended_behavior>This file should contain logic that generates the HTML output for index pages. The intended behavior would be to modify the method responsible for categorizing index entries to ensure that all entries starting with special characters are consolidated under a single "Symbols" section. This might involve adjusting how characters are compared or adding a unified category for all such special characters.</intended_behavior>, <file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import posixpath
13 import re
14 import sys
15 import warnings
16 from os import path
17 from typing import Any, Dict, IO, Iterable, Iterator, List, Set, Tuple
18 from urllib.parse import quote
19 
20 from docutils import nodes
21 from docutils.core import publish_parts
22 from docutils.frontend import OptionParser
23 from docutils.io import DocTreeInput, StringOutput
24 from docutils.nodes import Node
25 from docutils.utils import relative_path
26 
27 from sphinx import package_dir, __display_version__
28 from sphinx.application import Sphinx
29 from sphinx.builders import Builder
30 from sphinx.config import Config, ENUM
31 from sphinx.deprecation import RemovedInSphinx40Warning
32 from sphinx.domains import Domain, Index, IndexEntry
33 from sphinx.environment.adapters.asset import ImageAdapter
34 from sphinx.environment.adapters.indexentries import IndexEntries
35 from sphinx.environment.adapters.toctree import TocTree
36 from sphinx.errors import ConfigError, ThemeError
37 from sphinx.highlighting import PygmentsBridge
38 from sphinx.locale import _, __
39 from sphinx.search import js_index
40 from sphinx.theming import HTMLThemeFactory
41 from sphinx.util import logging, progress_message, status_iterator, md5
42 from sphinx.util.docutils import is_html5_writer_available, new_document
43 from sphinx.util.fileutil import copy_asset
44 from sphinx.util.i18n import format_date
45 from sphinx.util.inventory import InventoryFile
46 from sphinx.util.matching import patmatch, Matcher, DOTFILES
47 from sphinx.util.osutil import os_path, relative_uri, ensuredir, movefile, copyfile
48 from sphinx.util.tags import Tags
49 from sphinx.writers.html import HTMLWriter, HTMLTranslator
50 
51 if False:
52     # For type annotation
53     from typing import Type  # for python3.5.1
54 
55 
56 # HTML5 Writer is available or not
57 if is_html5_writer_available():
58     from sphinx.writers.html5 import HTML5Translator
59     html5_ready = True
60 else:
61     html5_ready = False
62 
63 #: the filename for the inventory of objects
64 INVENTORY_FILENAME = 'objects.inv'
65 
66 logger = logging.getLogger(__name__)
67 return_codes_re = re.compile('[\r\n]+')
68 
69 
70 def get_stable_hash(obj: Any) -> str:
71     """
72     Return a stable hash for a Python data structure.  We can't just use
73     the md5 of str(obj) since for example dictionary items are enumerated
74     in unpredictable order due to hash randomization in newer Pythons.
75     """
76     if isinstance(obj, dict):
77         return get_stable_hash(list(obj.items()))
78     elif isinstance(obj, (list, tuple)):
79         obj = sorted(get_stable_hash(o) for o in obj)
80     return md5(str(obj).encode()).hexdigest()
81 
82 
83 class Stylesheet(str):
84     """A metadata of stylesheet.
85 
86     To keep compatibility with old themes, an instance of stylesheet behaves as
87     its filename (str).
88     """
89 
90     attributes = None   # type: Dict[str, str]
91     filename = None     # type: str
92 
93     def __new__(cls, filename: str, *args: str, **attributes: str) -> "Stylesheet":
94         self = str.__new__(cls, filename)  # type: ignore
95         self.filename = filename
96         self.attributes = attributes
97         self.attributes.setdefault('rel', 'stylesheet')
98         self.attributes.setdefault('type', 'text/css')
99         if args:  # old style arguments (rel, title)
100             self.attributes['rel'] = args[0]
101             self.attributes['title'] = args[1]
102 
103         return self
104 
105 
106 class JavaScript(str):
107     """A metadata of javascript file.
108 
109     To keep compatibility with old themes, an instance of javascript behaves as
110     its filename (str).
111     """
112 
113     attributes = None   # type: Dict[str, str]
114     filename = None     # type: str
115 
116     def __new__(cls, filename: str, **attributes: str) -> "JavaScript":
117         self = str.__new__(cls, filename)  # type: ignore
118         self.filename = filename
119         self.attributes = attributes
120 
121         return self
122 
123 
124 class BuildInfo:
125     """buildinfo file manipulator.
126 
127     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
128     This class is a manipulator for the file.
129     """
130 
131     @classmethod
132     def load(cls, f: IO) -> "BuildInfo":
133         try:
134             lines = f.readlines()
135             assert lines[0].rstrip() == '# Sphinx build info version 1'
136             assert lines[2].startswith('config: ')
137             assert lines[3].startswith('tags: ')
138 
139             build_info = BuildInfo()
140             build_info.config_hash = lines[2].split()[1].strip()
141             build_info.tags_hash = lines[3].split()[1].strip()
142             return build_info
143         except Exception as exc:
144             raise ValueError(__('build info file is broken: %r') % exc) from exc
145 
146     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
147         self.config_hash = ''
148         self.tags_hash = ''
149 
150         if config:
151             values = {c.name: c.value for c in config.filter(config_categories)}
152             self.config_hash = get_stable_hash(values)
153 
154         if tags:
155             self.tags_hash = get_stable_hash(sorted(tags))
156 
157     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
158         return (self.config_hash == other.config_hash and
159                 self.tags_hash == other.tags_hash)
160 
161     def dump(self, f: IO) -> None:
162         f.write('# Sphinx build info version 1\n'
163                 '# This file hashes the configuration used when building these files.'
164                 ' When it is not found, a full rebuild will be done.\n'
165                 'config: %s\n'
166                 'tags: %s\n' %
167                 (self.config_hash, self.tags_hash))
168 
169 
170 class StandaloneHTMLBuilder(Builder):
171     """
172     Builds standalone HTML docs.
173     """
174     name = 'html'
175     format = 'html'
176     epilog = __('The HTML pages are in %(outdir)s.')
177 
178     copysource = True
179     allow_parallel = True
180     out_suffix = '.html'
181     link_suffix = '.html'  # defaults to matching out_suffix
182     indexer_format = js_index  # type: Any
183     indexer_dumps_unicode = True
184     # create links to original images from images [True/False]
185     html_scaled_image_link = True
186     supported_image_types = ['image/svg+xml', 'image/png',
187                              'image/gif', 'image/jpeg']
188     supported_remote_images = True
189     supported_data_uri_images = True
190     searchindex_filename = 'searchindex.js'
191     add_permalinks = True
192     allow_sharp_as_current_path = True
193     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
194     search = True  # for things like HTML help and Apple help: suppress search
195     use_index = False
196     download_support = True  # enable download role
197 
198     imgpath = None          # type: str
199     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
200 
201     def __init__(self, app: Sphinx) -> None:
202         super().__init__(app)
203 
204         # CSS files
205         self.css_files = []  # type: List[Dict[str, str]]
206 
207         # JS files
208         self.script_files = []  # type: List[JavaScript]
209 
210     def init(self) -> None:
211         self.build_info = self.create_build_info()
212         # basename of images directory
213         self.imagedir = '_images'
214         # section numbers for headings in the currently visited document
215         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
216         # currently written docname
217         self.current_docname = None  # type: str
218 
219         self.init_templates()
220         self.init_highlighter()
221         self.init_css_files()
222         self.init_js_files()
223 
224         html_file_suffix = self.get_builder_config('file_suffix', 'html')
225         if html_file_suffix is not None:
226             self.out_suffix = html_file_suffix
227 
228         html_link_suffix = self.get_builder_config('link_suffix', 'html')
229         if html_link_suffix is not None:
230             self.link_suffix = html_link_suffix
231         else:
232             self.link_suffix = self.out_suffix
233 
234         self.use_index = self.get_builder_config('use_index', 'html')
235 
236     def create_build_info(self) -> BuildInfo:
237         return BuildInfo(self.config, self.tags, ['html'])
238 
239     def _get_translations_js(self) -> str:
240         candidates = [path.join(dir, self.config.language,
241                                 'LC_MESSAGES', 'sphinx.js')
242                       for dir in self.config.locale_dirs] + \
243                      [path.join(package_dir, 'locale', self.config.language,
244                                 'LC_MESSAGES', 'sphinx.js'),
245                       path.join(sys.prefix, 'share/sphinx/locale',
246                                 self.config.language, 'sphinx.js')]
247 
248         for jsfile in candidates:
249             if path.isfile(jsfile):
250                 return jsfile
251         return None
252 
253     def get_theme_config(self) -> Tuple[str, Dict]:
254         return self.config.html_theme, self.config.html_theme_options
255 
256     def init_templates(self) -> None:
257         theme_factory = HTMLThemeFactory(self.app)
258         themename, themeoptions = self.get_theme_config()
259         self.theme = theme_factory.create(themename)
260         self.theme_options = themeoptions.copy()
261         self.create_template_bridge()
262         self.templates.init(self, self.theme)
263 
264     def init_highlighter(self) -> None:
265         # determine Pygments style and create the highlighter
266         if self.config.pygments_style is not None:
267             style = self.config.pygments_style
268         elif self.theme:
269             style = self.theme.get_config('theme', 'pygments_style', 'none')
270         else:
271             style = 'sphinx'
272         self.highlighter = PygmentsBridge('html', style)
273 
274         if self.theme:
275             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
276         else:
277             dark_style = None
278 
279         if dark_style is not None:
280             self.dark_highlighter = PygmentsBridge('html', dark_style)
281             self.add_css_file('pygments_dark.css',
282                               media='(prefers-color-scheme: dark)',
283                               id='pygments_dark_css')
284         else:
285             self.dark_highlighter = None
286 
287     def init_css_files(self) -> None:
288         for filename, attrs in self.app.registry.css_files:
289             self.add_css_file(filename, **attrs)
290 
291         for filename, attrs in self.get_builder_config('css_files', 'html'):
292             self.add_css_file(filename, **attrs)
293 
294     def add_css_file(self, filename: str, **kwargs: str) -> None:
295         if '://' not in filename:
296             filename = posixpath.join('_static', filename)
297 
298         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
299 
300     def init_js_files(self) -> None:
301         self.add_js_file('jquery.js')
302         self.add_js_file('underscore.js')
303         self.add_js_file('doctools.js')
304         self.add_js_file('language_data.js')
305 
306         for filename, attrs in self.app.registry.js_files:
307             self.add_js_file(filename, **attrs)
308 
309         for filename, attrs in self.get_builder_config('js_files', 'html'):
310             self.add_js_file(filename, **attrs)
311 
312         if self.config.language and self._get_translations_js():
313             self.add_js_file('translations.js')
314 
315     def add_js_file(self, filename: str, **kwargs: str) -> None:
316         if filename and '://' not in filename:
317             filename = posixpath.join('_static', filename)
318 
319         self.script_files.append(JavaScript(filename, **kwargs))
320 
321     @property
322     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
323         if not html5_ready or self.config.html4_writer:
324             return HTMLTranslator
325         else:
326             return HTML5Translator
327 
328     @property
329     def math_renderer_name(self) -> str:
330         name = self.get_builder_config('math_renderer', 'html')
331         if name is not None:
332             # use given name
333             return name
334         else:
335             # not given: choose a math_renderer from registered ones as possible
336             renderers = list(self.app.registry.html_inline_math_renderers)
337             if len(renderers) == 1:
338                 # only default math_renderer (mathjax) is registered
339                 return renderers[0]
340             elif len(renderers) == 2:
341                 # default and another math_renderer are registered; prior the another
342                 renderers.remove('mathjax')
343                 return renderers[0]
344             else:
345                 # many math_renderers are registered. can't choose automatically!
346                 return None
347 
348     def get_outdated_docs(self) -> Iterator[str]:
349         try:
350             with open(path.join(self.outdir, '.buildinfo')) as fp:
351                 buildinfo = BuildInfo.load(fp)
352 
353             if self.build_info != buildinfo:
354                 yield from self.env.found_docs
355                 return
356         except ValueError as exc:
357             logger.warning(__('Failed to read build info file: %r'), exc)
358         except OSError:
359             # ignore errors on reading
360             pass
361 
362         if self.templates:
363             template_mtime = self.templates.newest_template_mtime()
364         else:
365             template_mtime = 0
366         for docname in self.env.found_docs:
367             if docname not in self.env.all_docs:
368                 yield docname
369                 continue
370             targetname = self.get_outfilename(docname)
371             try:
372                 targetmtime = path.getmtime(targetname)
373             except Exception:
374                 targetmtime = 0
375             try:
376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
377                                template_mtime)
378                 if srcmtime > targetmtime:
379                     yield docname
380             except OSError:
381                 # source doesn't exist anymore
382                 pass
383 
384     def get_asset_paths(self) -> List[str]:
385         return self.config.html_extra_path + self.config.html_static_path
386 
387     def render_partial(self, node: Node) -> Dict[str, str]:
388         """Utility: Render a lone doctree node."""
389         if node is None:
390             return {'fragment': ''}
391         doc = new_document('<partial node>')
392         doc.append(node)
393 
394         writer = HTMLWriter(self)
395         return publish_parts(reader_name='doctree',
396                              writer=writer,
397                              source_class=DocTreeInput,
398                              settings_overrides={'output_encoding': 'unicode'},
399                              source=doc)
400 
401     def prepare_writing(self, docnames: Set[str]) -> None:
402         # create the search indexer
403         self.indexer = None
404         if self.search:
405             from sphinx.search import IndexBuilder
406             lang = self.config.html_search_language or self.config.language
407             if not lang:
408                 lang = 'en'
409             self.indexer = IndexBuilder(self.env, lang,
410                                         self.config.html_search_options,
411                                         self.config.html_search_scorer)
412             self.load_indexer(docnames)
413 
414         self.docwriter = HTMLWriter(self)
415         self.docsettings = OptionParser(
416             defaults=self.env.settings,
417             components=(self.docwriter,),
418             read_config_files=True).get_default_values()  # type: Any
419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
420 
421         # determine the additional indices to include
422         self.domain_indices = []
423         # html_domain_indices can be False/True or a list of index names
424         indices_config = self.config.html_domain_indices
425         if indices_config:
426             for domain_name in sorted(self.env.domains):
427                 domain = None  # type: Domain
428                 domain = self.env.domains[domain_name]
429                 for indexcls in domain.indices:
430                     indexname = '%s-%s' % (domain.name, indexcls.name)
431                     if isinstance(indices_config, list):
432                         if indexname not in indices_config:
433                             continue
434                     content, collapse = indexcls(domain).generate()
435                     if content:
436                         self.domain_indices.append(
437                             (indexname, indexcls, content, collapse))
438 
439         # format the "last updated on" string, only once is enough since it
440         # typically doesn't include the time of day
441         lufmt = self.config.html_last_updated_fmt
442         if lufmt is not None:
443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
444                                             language=self.config.language)
445         else:
446             self.last_updated = None
447 
448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
450 
451         if not isinstance(self.config.html_use_opensearch, str):
452             logger.warning(__('html_use_opensearch config value must now be a string'))
453 
454         self.relations = self.env.collect_relations()
455 
456         rellinks = []  # type: List[Tuple[str, str, str, str]]
457         if self.use_index:
458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
459         for indexname, indexcls, content, collapse in self.domain_indices:
460             # if it has a short name
461             if indexcls.shortname:
462                 rellinks.append((indexname, indexcls.localname,
463                                  '', indexcls.shortname))
464 
465         if self.config.html_style is not None:
466             stylename = self.config.html_style
467         elif self.theme:
468             stylename = self.theme.get_config('theme', 'stylesheet')
469         else:
470             stylename = 'default.css'
471 
472         self.globalcontext = {
473             'embedded': self.embedded,
474             'project': self.config.project,
475             'release': return_codes_re.sub('', self.config.release),
476             'version': self.config.version,
477             'last_updated': self.last_updated,
478             'copyright': self.config.copyright,
479             'master_doc': self.config.master_doc,
480             'use_opensearch': self.config.html_use_opensearch,
481             'docstitle': self.config.html_title,
482             'shorttitle': self.config.html_short_title,
483             'show_copyright': self.config.html_show_copyright,
484             'show_sphinx': self.config.html_show_sphinx,
485             'has_source': self.config.html_copy_source,
486             'show_source': self.config.html_show_sourcelink,
487             'sourcelink_suffix': self.config.html_sourcelink_suffix,
488             'file_suffix': self.out_suffix,
489             'link_suffix': self.link_suffix,
490             'script_files': self.script_files,
491             'language': self.config.language,
492             'css_files': self.css_files,
493             'sphinx_version': __display_version__,
494             'style': stylename,
495             'rellinks': rellinks,
496             'builder': self.name,
497             'parents': [],
498             'logo': logo,
499             'favicon': favicon,
500             'html5_doctype': html5_ready and not self.config.html4_writer,
501         }
502         if self.theme:
503             self.globalcontext.update(
504                 ('theme_' + key, val) for (key, val) in
505                 self.theme.get_options(self.theme_options).items())
506         self.globalcontext.update(self.config.html_context)
507 
508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
509         """Collect items for the template context of a page."""
510         # find out relations
511         prev = next = None
512         parents = []
513         rellinks = self.globalcontext['rellinks'][:]
514         related = self.relations.get(docname)
515         titles = self.env.titles
516         if related and related[2]:
517             try:
518                 next = {
519                     'link': self.get_relative_uri(docname, related[2]),
520                     'title': self.render_partial(titles[related[2]])['title']
521                 }
522                 rellinks.append((related[2], next['title'], 'N', _('next')))
523             except KeyError:
524                 next = None
525         if related and related[1]:
526             try:
527                 prev = {
528                     'link': self.get_relative_uri(docname, related[1]),
529                     'title': self.render_partial(titles[related[1]])['title']
530                 }
531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
532             except KeyError:
533                 # the relation is (somehow) not in the TOC tree, handle
534                 # that gracefully
535                 prev = None
536         while related and related[0]:
537             try:
538                 parents.append(
539                     {'link': self.get_relative_uri(docname, related[0]),
540                      'title': self.render_partial(titles[related[0]])['title']})
541             except KeyError:
542                 pass
543             related = self.relations.get(related[0])
544         if parents:
545             # remove link to the master file; we have a generic
546             # "back to index" link already
547             parents.pop()
548         parents.reverse()
549 
550         # title rendered as HTML
551         title_node = self.env.longtitles.get(docname)
552         title = self.render_partial(title_node)['title'] if title_node else ''
553 
554         # Suffix for the document
555         source_suffix = self.env.doc2path(docname, False)[len(docname):]
556 
557         # the name for the copied source
558         if self.config.html_copy_source:
559             sourcename = docname + source_suffix
560             if source_suffix != self.config.html_sourcelink_suffix:
561                 sourcename += self.config.html_sourcelink_suffix
562         else:
563             sourcename = ''
564 
565         # metadata for the document
566         meta = self.env.metadata.get(docname)
567 
568         # local TOC and global TOC tree
569         self_toc = TocTree(self.env).get_toc_for(docname, self)
570         toc = self.render_partial(self_toc)['fragment']
571 
572         return {
573             'parents': parents,
574             'prev': prev,
575             'next': next,
576             'title': title,
577             'meta': meta,
578             'body': body,
579             'metatags': metatags,
580             'rellinks': rellinks,
581             'sourcename': sourcename,
582             'toc': toc,
583             # only display a TOC if there's more than one item to show
584             'display_toc': (self.env.toc_num_entries[docname] > 1),
585             'page_source_suffix': source_suffix,
586         }
587 
588     def write_doc(self, docname: str, doctree: nodes.document) -> None:
589         destination = StringOutput(encoding='utf-8')
590         doctree.settings = self.docsettings
591 
592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
596         self.current_docname = docname
597         self.docwriter.write(doctree, destination)
598         self.docwriter.assemble_parts()
599         body = self.docwriter.parts['fragment']
600         metatags = self.docwriter.clean_meta
601 
602         ctx = self.get_doc_context(docname, body, metatags)
603         self.handle_page(docname, ctx, event_arg=doctree)
604 
605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
607         self.post_process_images(doctree)
608         title_node = self.env.longtitles.get(docname)
609         title = self.render_partial(title_node)['title'] if title_node else ''
610         self.index_page(docname, doctree, title)
611 
612     def finish(self) -> None:
613         self.finish_tasks.add_task(self.gen_indices)
614         self.finish_tasks.add_task(self.gen_pages_from_extensions)
615         self.finish_tasks.add_task(self.gen_additional_pages)
616         self.finish_tasks.add_task(self.copy_image_files)
617         self.finish_tasks.add_task(self.copy_download_files)
618         self.finish_tasks.add_task(self.copy_static_files)
619         self.finish_tasks.add_task(self.copy_extra_files)
620         self.finish_tasks.add_task(self.write_buildinfo)
621 
622         # dump the search index
623         self.handle_finish()
624 
625     @progress_message(__('generating indices'))
626     def gen_indices(self) -> None:
627         # the global general index
628         if self.use_index:
629             self.write_genindex()
630 
631         # the global domain-specific indices
632         self.write_domain_indices()
633 
634     def gen_pages_from_extensions(self) -> None:
635         # pages from extensions
636         for pagelist in self.events.emit('html-collect-pages'):
637             for pagename, context, template in pagelist:
638                 self.handle_page(pagename, context, template)
639 
640     @progress_message(__('writing additional pages'))
641     def gen_additional_pages(self) -> None:
642         # additional pages from conf.py
643         for pagename, template in self.config.html_additional_pages.items():
644             logger.info(' ' + pagename, nonl=True)
645             self.handle_page(pagename, {}, template)
646 
647         # the search page
648         if self.search:
649             logger.info(' search', nonl=True)
650             self.handle_page('search', {}, 'search.html')
651 
652         # the opensearch xml file
653         if self.config.html_use_opensearch and self.search:
654             logger.info(' opensearch', nonl=True)
655             fn = path.join(self.outdir, '_static', 'opensearch.xml')
656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
657 
658     def write_genindex(self) -> None:
659         # the total count of lines for each index letter, used to distribute
660         # the entries into two columns
661         genindex = IndexEntries(self.env).create_index(self)
662         indexcounts = []
663         for _k, entries in genindex:
664             indexcounts.append(sum(1 + len(subitems)
665                                    for _, (_, subitems, _) in entries))
666 
667         genindexcontext = {
668             'genindexentries': genindex,
669             'genindexcounts': indexcounts,
670             'split_index': self.config.html_split_index,
671         }
672         logger.info(' genindex', nonl=True)
673 
674         if self.config.html_split_index:
675             self.handle_page('genindex', genindexcontext,
676                              'genindex-split.html')
677             self.handle_page('genindex-all', genindexcontext,
678                              'genindex.html')
679             for (key, entries), count in zip(genindex, indexcounts):
680                 ctx = {'key': key, 'entries': entries, 'count': count,
681                        'genindexentries': genindex}
682                 self.handle_page('genindex-' + key, ctx,
683                                  'genindex-single.html')
684         else:
685             self.handle_page('genindex', genindexcontext, 'genindex.html')
686 
687     def write_domain_indices(self) -> None:
688         for indexname, indexcls, content, collapse in self.domain_indices:
689             indexcontext = {
690                 'indextitle': indexcls.localname,
691                 'content': content,
692                 'collapse_index': collapse,
693             }
694             logger.info(' ' + indexname, nonl=True)
695             self.handle_page(indexname, indexcontext, 'domainindex.html')
696 
697     def copy_image_files(self) -> None:
698         if self.images:
699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
700             ensuredir(path.join(self.outdir, self.imagedir))
701             for src in status_iterator(self.images, __('copying images... '), "brown",
702                                        len(self.images), self.app.verbosity,
703                                        stringify_func=stringify_func):
704                 dest = self.images[src]
705                 try:
706                     copyfile(path.join(self.srcdir, src),
707                              path.join(self.outdir, self.imagedir, dest))
708                 except Exception as err:
709                     logger.warning(__('cannot copy image file %r: %s'),
710                                    path.join(self.srcdir, src), err)
711 
712     def copy_download_files(self) -> None:
713         def to_relpath(f: str) -> str:
714             return relative_path(self.srcdir, f)
715 
716         # copy downloadable files
717         if self.env.dlfiles:
718             ensuredir(path.join(self.outdir, '_downloads'))
719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
720                                        "brown", len(self.env.dlfiles), self.app.verbosity,
721                                        stringify_func=to_relpath):
722                 try:
723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
724                     ensuredir(path.dirname(dest))
725                     copyfile(path.join(self.srcdir, src), dest)
726                 except OSError as err:
727                     logger.warning(__('cannot copy downloadable file %r: %s'),
728                                    path.join(self.srcdir, src), err)
729 
730     def create_pygments_style_file(self) -> None:
731         """create a style file for pygments."""
732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
733             f.write(self.highlighter.get_stylesheet())
734 
735         if self.dark_highlighter:
736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
737                 f.write(self.dark_highlighter.get_stylesheet())
738 
739     def copy_translation_js(self) -> None:
740         """Copy a JavaScript file for translations."""
741         if self.config.language is not None:
742             jsfile = self._get_translations_js()
743             if jsfile:
744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
745 
746     def copy_stemmer_js(self) -> None:
747         """Copy a JavaScript file for stemmer."""
748         if self.indexer is not None:
749             jsfile = self.indexer.get_js_stemmer_rawcode()
750             if jsfile:
751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
752 
753     def copy_theme_static_files(self, context: Dict) -> None:
754         if self.theme:
755             for entry in self.theme.get_theme_dirs()[::-1]:
756                 copy_asset(path.join(entry, 'static'),
757                            path.join(self.outdir, '_static'),
758                            excluded=DOTFILES, context=context, renderer=self.templates)
759 
760     def copy_html_static_files(self, context: Dict) -> None:
761         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
762         for entry in self.config.html_static_path:
763             copy_asset(path.join(self.confdir, entry),
764                        path.join(self.outdir, '_static'),
765                        excluded, context=context, renderer=self.templates)
766 
767     def copy_html_logo(self) -> None:
768         if self.config.html_logo:
769             copy_asset(path.join(self.confdir, self.config.html_logo),
770                        path.join(self.outdir, '_static'))
771 
772     def copy_html_favicon(self) -> None:
773         if self.config.html_favicon:
774             copy_asset(path.join(self.confdir, self.config.html_favicon),
775                        path.join(self.outdir, '_static'))
776 
777     def copy_static_files(self) -> None:
778         try:
779             with progress_message(__('copying static files... ')):
780                 ensuredir(path.join(self.outdir, '_static'))
781 
782                 # prepare context for templates
783                 context = self.globalcontext.copy()
784                 if self.indexer is not None:
785                     context.update(self.indexer.context_for_searchtool())
786 
787                 self.create_pygments_style_file()
788                 self.copy_translation_js()
789                 self.copy_stemmer_js()
790                 self.copy_theme_static_files(context)
791                 self.copy_html_static_files(context)
792                 self.copy_html_logo()
793                 self.copy_html_favicon()
794         except OSError as err:
795             logger.warning(__('cannot copy static file %r'), err)
796 
797     def copy_extra_files(self) -> None:
798         """copy html_extra_path files."""
799         try:
800             with progress_message(__('copying extra files')):
801                 excluded = Matcher(self.config.exclude_patterns)
802                 for extra_path in self.config.html_extra_path:
803                     entry = path.join(self.confdir, extra_path)
804                     copy_asset(entry, self.outdir, excluded)
805         except OSError as err:
806             logger.warning(__('cannot copy extra file %r'), err)
807 
808     def write_buildinfo(self) -> None:
809         try:
810             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
811                 self.build_info.dump(fp)
812         except OSError as exc:
813             logger.warning(__('Failed to write build info file: %r'), exc)
814 
815     def cleanup(self) -> None:
816         # clean up theme stuff
817         if self.theme:
818             self.theme.cleanup()
819 
820     def post_process_images(self, doctree: Node) -> None:
821         """Pick the best candidate for an image and link down-scaled images to
822         their high res version.
823         """
824         Builder.post_process_images(self, doctree)
825 
826         if self.config.html_scaled_image_link and self.html_scaled_image_link:
827             for node in doctree.traverse(nodes.image):
828                 if not any((key in node) for key in ['scale', 'width', 'height']):
829                     # resizing options are not given. scaled image link is available
830                     # only for resized images.
831                     continue
832                 elif isinstance(node.parent, nodes.reference):
833                     # A image having hyperlink target
834                     continue
835                 elif 'no-scaled-link' in node['classes']:
836                     # scaled image link is disabled for this node
837                     continue
838 
839                 uri = node['uri']
840                 reference = nodes.reference('', '', internal=True)
841                 if uri in self.images:
842                     reference['refuri'] = posixpath.join(self.imgpath,
843                                                          self.images[uri])
844                 else:
845                     reference['refuri'] = uri
846                 node.replace_self(reference)
847                 reference.append(node)
848 
849     def load_indexer(self, docnames: Iterable[str]) -> None:
850         keep = set(self.env.all_docs) - set(docnames)
851         try:
852             searchindexfn = path.join(self.outdir, self.searchindex_filename)
853             if self.indexer_dumps_unicode:
854                 with open(searchindexfn, encoding='utf-8') as ft:
855                     self.indexer.load(ft, self.indexer_format)
856             else:
857                 with open(searchindexfn, 'rb') as fb:
858                     self.indexer.load(fb, self.indexer_format)
859         except (OSError, ValueError):
860             if keep:
861                 logger.warning(__('search index couldn\'t be loaded, but not all '
862                                   'documents will be built: the index will be '
863                                   'incomplete.'))
864         # delete all entries for files that will be rebuilt
865         self.indexer.prune(keep)
866 
867     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
868         # only index pages with title
869         if self.indexer is not None and title:
870             filename = self.env.doc2path(pagename, base=None)
871             try:
872                 metadata = self.env.metadata.get(pagename, {})
873                 if 'nosearch' in metadata:
874                     self.indexer.feed(pagename, filename, '', new_document(''))
875                 else:
876                     self.indexer.feed(pagename, filename, title, doctree)
877             except TypeError:
878                 # fallback for old search-adapters
879                 self.indexer.feed(pagename, title, doctree)  # type: ignore
880                 indexer_name = self.indexer.__class__.__name__
881                 warnings.warn(
882                     'The %s.feed() method signature is deprecated. Update to '
883                     '%s.feed(docname, filename, title, doctree).' % (
884                         indexer_name, indexer_name),
885                     RemovedInSphinx40Warning, stacklevel=2)
886 
887     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
888         if 'includehidden' not in kwargs:
889             kwargs['includehidden'] = False
890         if kwargs.get('maxdepth') == '':
891             kwargs.pop('maxdepth')
892         return self.render_partial(TocTree(self.env).get_toctree_for(
893             docname, self, collapse, **kwargs))['fragment']
894 
895     def get_outfilename(self, pagename: str) -> str:
896         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
897 
898     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
899         def has_wildcard(pattern: str) -> bool:
900             return any(char in pattern for char in '*?[')
901 
902         sidebars = None
903         matched = None
904         customsidebar = None
905 
906         # default sidebars settings for selected theme
907         if self.theme.name == 'alabaster':
908             # provide default settings for alabaster (for compatibility)
909             # Note: this will be removed before Sphinx-2.0
910             try:
911                 # get default sidebars settings from alabaster (if defined)
912                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
913                 if theme_default_sidebars:
914                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
915             except Exception:
916                 # fallback to better default settings
917                 sidebars = ['about.html', 'navigation.html', 'relations.html',
918                             'searchbox.html', 'donate.html']
919         else:
920             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
921             if theme_default_sidebars:
922                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
923 
924         # user sidebar settings
925         html_sidebars = self.get_builder_config('sidebars', 'html')
926         for pattern, patsidebars in html_sidebars.items():
927             if patmatch(pagename, pattern):
928                 if matched:
929                     if has_wildcard(pattern):
930                         # warn if both patterns contain wildcards
931                         if has_wildcard(matched):
932                             logger.warning(__('page %s matches two patterns in '
933                                               'html_sidebars: %r and %r'),
934                                            pagename, matched, pattern)
935                         # else the already matched pattern is more specific
936                         # than the present one, because it contains no wildcard
937                         continue
938                 matched = pattern
939                 sidebars = patsidebars
940 
941         if sidebars is None:
942             # keep defaults
943             pass
944 
945         ctx['sidebars'] = sidebars
946         ctx['customsidebar'] = customsidebar
947 
948     # --------- these are overwritten by the serialization builder
949 
950     def get_target_uri(self, docname: str, typ: str = None) -> str:
951         return quote(docname) + self.link_suffix
952 
953     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
954                     outfilename: str = None, event_arg: Any = None) -> None:
955         ctx = self.globalcontext.copy()
956         # current_page_name is backwards compatibility
957         ctx['pagename'] = ctx['current_page_name'] = pagename
958         ctx['encoding'] = self.config.html_output_encoding
959         default_baseuri = self.get_target_uri(pagename)
960         # in the singlehtml builder, default_baseuri still contains an #anchor
961         # part, which relative_uri doesn't really like...
962         default_baseuri = default_baseuri.rsplit('#', 1)[0]
963 
964         if self.config.html_baseurl:
965             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
966                                             pagename + self.out_suffix)
967         else:
968             ctx['pageurl'] = None
969 
970         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
971             if resource and '://' in otheruri:
972                 # allow non-local resources given by scheme
973                 return otheruri
974             elif not resource:
975                 otheruri = self.get_target_uri(otheruri)
976             uri = relative_uri(baseuri, otheruri) or '#'
977             if uri == '#' and not self.allow_sharp_as_current_path:
978                 uri = baseuri
979             return uri
980         ctx['pathto'] = pathto
981 
982         def css_tag(css: Stylesheet) -> str:
983             attrs = []
984             for key in sorted(css.attributes):
985                 value = css.attributes[key]
986                 if value is not None:
987                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
988             attrs.append('href="%s"' % pathto(css.filename, resource=True))
989             return '<link %s />' % ' '.join(attrs)
990         ctx['css_tag'] = css_tag
991 
992         def hasdoc(name: str) -> bool:
993             if name in self.env.all_docs:
994                 return True
995             elif name == 'search' and self.search:
996                 return True
997             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
998                 return True
999             return False
1000         ctx['hasdoc'] = hasdoc
1001 
1002         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1003         self.add_sidebars(pagename, ctx)
1004         ctx.update(addctx)
1005 
1006         self.update_page_context(pagename, templatename, ctx, event_arg)
1007         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1008                                             templatename, ctx, event_arg)
1009         if newtmpl:
1010             templatename = newtmpl
1011 
1012         try:
1013             output = self.templates.render(templatename, ctx)
1014         except UnicodeError:
1015             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1016                               "Please make sure all config values that contain "
1017                               "non-ASCII content are Unicode strings."), pagename)
1018             return
1019         except Exception as exc:
1020             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1021                              (pagename, exc)) from exc
1022 
1023         if not outfilename:
1024             outfilename = self.get_outfilename(pagename)
1025         # outfilename's path is in general different from self.outdir
1026         ensuredir(path.dirname(outfilename))
1027         try:
1028             with open(outfilename, 'w', encoding=ctx['encoding'],
1029                       errors='xmlcharrefreplace') as f:
1030                 f.write(output)
1031         except OSError as err:
1032             logger.warning(__("error writing file %s: %s"), outfilename, err)
1033         if self.copysource and ctx.get('sourcename'):
1034             # copy the source file for the "show source" link
1035             source_name = path.join(self.outdir, '_sources',
1036                                     os_path(ctx['sourcename']))
1037             ensuredir(path.dirname(source_name))
1038             copyfile(self.env.doc2path(pagename), source_name)
1039 
1040     def update_page_context(self, pagename: str, templatename: str,
1041                             ctx: Dict, event_arg: Any) -> None:
1042         pass
1043 
1044     def handle_finish(self) -> None:
1045         if self.indexer:
1046             self.finish_tasks.add_task(self.dump_search_index)
1047         self.finish_tasks.add_task(self.dump_inventory)
1048 
1049     @progress_message(__('dumping object inventory'))
1050     def dump_inventory(self) -> None:
1051         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1052 
1053     def dump_search_index(self) -> None:
1054         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1055             self.indexer.prune(self.env.all_docs)
1056             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1057             # first write to a temporary file, so that if dumping fails,
1058             # the existing index won't be overwritten
1059             if self.indexer_dumps_unicode:
1060                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1061                     self.indexer.dump(ft, self.indexer_format)
1062             else:
1063                 with open(searchindexfn + '.tmp', 'wb') as fb:
1064                     self.indexer.dump(fb, self.indexer_format)
1065             movefile(searchindexfn + '.tmp', searchindexfn)
1066 
1067 
1068 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1069     """This converts string styled html_css_files to tuple styled one."""
1070     html_css_files = []  # type: List[Tuple[str, Dict]]
1071     for entry in config.html_css_files:
1072         if isinstance(entry, str):
1073             html_css_files.append((entry, {}))
1074         else:
1075             try:
1076                 filename, attrs = entry
1077                 html_css_files.append((filename, attrs))
1078             except Exception:
1079                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1080                 continue
1081 
1082     config.html_css_files = html_css_files  # type: ignore
1083 
1084 
1085 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1086     """This converts string styled html_js_files to tuple styled one."""
1087     html_js_files = []  # type: List[Tuple[str, Dict]]
1088     for entry in config.html_js_files:
1089         if isinstance(entry, str):
1090             html_js_files.append((entry, {}))
1091         else:
1092             try:
1093                 filename, attrs = entry
1094                 html_js_files.append((filename, attrs))
1095             except Exception:
1096                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1097                 continue
1098 
1099     config.html_js_files = html_js_files  # type: ignore
1100 
1101 
1102 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1103                         context: Dict, doctree: Node) -> None:
1104     """Set up js_tag() template helper.
1105 
1106     .. note:: This set up function is added to keep compatibility with webhelper.
1107     """
1108     pathto = context.get('pathto')
1109 
1110     def js_tag(js: JavaScript) -> str:
1111         attrs = []
1112         body = ''
1113         if isinstance(js, JavaScript):
1114             for key in sorted(js.attributes):
1115                 value = js.attributes[key]
1116                 if value is not None:
1117                     if key == 'body':
1118                         body = value
1119                     else:
1120                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1121             if js.filename:
1122                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1123         else:
1124             # str value (old styled)
1125             attrs.append('src="%s"' % pathto(js, resource=True))
1126         return '<script %s>%s</script>' % (' '.join(attrs), body)
1127 
1128     context['js_tag'] = js_tag
1129 
1130 
1131 def validate_math_renderer(app: Sphinx) -> None:
1132     if app.builder.format != 'html':
1133         return
1134 
1135     name = app.builder.math_renderer_name  # type: ignore
1136     if name is None:
1137         raise ConfigError(__('Many math_renderers are registered. '
1138                              'But no math_renderer is selected.'))
1139     elif name not in app.registry.html_inline_math_renderers:
1140         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1141 
1142 
1143 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1144     """Check html_extra_paths setting."""
1145     for entry in config.html_extra_path[:]:
1146         extra_path = path.normpath(path.join(app.confdir, entry))
1147         if not path.exists(extra_path):
1148             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1149             config.html_extra_path.remove(entry)
1150         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1151               path.commonpath([app.outdir, extra_path]) == app.outdir):
1152             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1153             config.html_extra_path.remove(entry)
1154 
1155 
1156 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1157     """Check html_static_paths setting."""
1158     for entry in config.html_static_path[:]:
1159         static_path = path.normpath(path.join(app.confdir, entry))
1160         if not path.exists(static_path):
1161             logger.warning(__('html_static_path entry %r does not exist'), entry)
1162             config.html_static_path.remove(entry)
1163         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1164               path.commonpath([app.outdir, static_path]) == app.outdir):
1165             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1166             config.html_static_path.remove(entry)
1167 
1168 
1169 def validate_html_logo(app: Sphinx, config: Config) -> None:
1170     """Check html_logo setting."""
1171     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1172         logger.warning(__('logo file %r does not exist'), config.html_logo)
1173         config.html_logo = None  # type: ignore
1174 
1175 
1176 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1177     """Check html_favicon setting."""
1178     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1179         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1180         config.html_favicon = None  # type: ignore
1181 
1182 
1183 # for compatibility
1184 import sphinx.builders.dirhtml  # NOQA
1185 import sphinx.builders.singlehtml  # NOQA
1186 import sphinxcontrib.serializinghtml  # NOQA
1187 
1188 
1189 def setup(app: Sphinx) -> Dict[str, Any]:
1190     # builders
1191     app.add_builder(StandaloneHTMLBuilder)
1192 
1193     # config values
1194     app.add_config_value('html_theme', 'alabaster', 'html')
1195     app.add_config_value('html_theme_path', [], 'html')
1196     app.add_config_value('html_theme_options', {}, 'html')
1197     app.add_config_value('html_title',
1198                          lambda self: _('%s %s documentation') % (self.project, self.release),
1199                          'html', [str])
1200     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1201     app.add_config_value('html_style', None, 'html', [str])
1202     app.add_config_value('html_logo', None, 'html', [str])
1203     app.add_config_value('html_favicon', None, 'html', [str])
1204     app.add_config_value('html_css_files', [], 'html')
1205     app.add_config_value('html_js_files', [], 'html')
1206     app.add_config_value('html_static_path', [], 'html')
1207     app.add_config_value('html_extra_path', [], 'html')
1208     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1209     app.add_config_value('html_sidebars', {}, 'html')
1210     app.add_config_value('html_additional_pages', {}, 'html')
1211     app.add_config_value('html_domain_indices', True, 'html', [list])
1212     app.add_config_value('html_add_permalinks', '¶', 'html')
1213     app.add_config_value('html_use_index', True, 'html')
1214     app.add_config_value('html_split_index', False, 'html')
1215     app.add_config_value('html_copy_source', True, 'html')
1216     app.add_config_value('html_show_sourcelink', True, 'html')
1217     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1218     app.add_config_value('html_use_opensearch', '', 'html')
1219     app.add_config_value('html_file_suffix', None, 'html', [str])
1220     app.add_config_value('html_link_suffix', None, 'html', [str])
1221     app.add_config_value('html_show_copyright', True, 'html')
1222     app.add_config_value('html_show_sphinx', True, 'html')
1223     app.add_config_value('html_context', {}, 'html')
1224     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1225     app.add_config_value('html_compact_lists', True, 'html')
1226     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1227     app.add_config_value('html_search_language', None, 'html', [str])
1228     app.add_config_value('html_search_options', {}, 'html')
1229     app.add_config_value('html_search_scorer', '', None)
1230     app.add_config_value('html_scaled_image_link', True, 'html')
1231     app.add_config_value('html_baseurl', '', 'html')
1232     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1233                          ENUM('table', 'inline'))
1234     app.add_config_value('html_math_renderer', None, 'env')
1235     app.add_config_value('html4_writer', False, 'html')
1236 
1237     # event handlers
1238     app.connect('config-inited', convert_html_css_files, priority=800)
1239     app.connect('config-inited', convert_html_js_files, priority=800)
1240     app.connect('config-inited', validate_html_extra_path, priority=800)
1241     app.connect('config-inited', validate_html_static_path, priority=800)
1242     app.connect('config-inited', validate_html_logo, priority=800)
1243     app.connect('config-inited', validate_html_favicon, priority=800)
1244     app.connect('builder-inited', validate_math_renderer)
1245     app.connect('html-page-context', setup_js_tag_helper)
1246 
1247     # load default math renderer
1248     app.setup_extension('sphinx.ext.mathjax')
1249 
1250     # load transforms for HTML builder
1251     app.setup_extension('sphinx.builders.html.transforms')
1252 
1253     return {
1254         'version': 'builtin',
1255         'parallel_read_safe': True,
1256         'parallel_write_safe': True,
1257     }

</code><intended_behavior>In this central file for HTML building, the target would be to ensure the logic that organizes index entries into sections recognizes and groups any entries starting with special characters like '@', '£', and '←' into one "Symbols" section to prevent duplication. This might require adding specific checks or logic to treat these characters uniformly when categorizing index entries.</intended_behavior>]
2025-10-16 00:49:25.942 | INFO     | Search completed. Bug locations: [<file>sphinx/writers/html.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.html
3     ~~~~~~~~~~~~~~~~~~~
4 
5     docutils writers handling Sphinx' custom nodes.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import copy
12 import os
13 import posixpath
14 import re
15 import warnings
16 from typing import Any, Iterable, Tuple
17 from typing import cast
18 
19 from docutils import nodes
20 from docutils.nodes import Element, Node, Text
21 from docutils.writers.html4css1 import Writer, HTMLTranslator as BaseTranslator
22 
23 from sphinx import addnodes
24 from sphinx.builders import Builder
25 from sphinx.deprecation import RemovedInSphinx40Warning
26 from sphinx.locale import admonitionlabels, _, __
27 from sphinx.util import logging
28 from sphinx.util.docutils import SphinxTranslator
29 from sphinx.util.images import get_image_size
30 
31 if False:
32     # For type annotation
33     from sphinx.builders.html import StandaloneHTMLBuilder
34 
35 
36 logger = logging.getLogger(__name__)
37 
38 # A good overview of the purpose behind these classes can be found here:
39 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html
40 
41 
42 def multiply_length(length: str, scale: int) -> str:
43     """Multiply *length* (width or height) by *scale*."""
44     matched = re.match(r'^(\d*\.?\d*)\s*(\S*)$', length)
45     if not matched:
46         return length
47     elif scale == 100:
48         return length
49     else:
50         amount, unit = matched.groups()
51         result = float(amount) * scale / 100
52         return "%s%s" % (int(result), unit)
53 
54 
55 class HTMLWriter(Writer):
56 
57     # override embed-stylesheet default value to 0.
58     settings_spec = copy.deepcopy(Writer.settings_spec)
59     for _setting in settings_spec[2]:
60         if '--embed-stylesheet' in _setting[1]:
61             _setting[2]['default'] = 0
62 
63     def __init__(self, builder: "StandaloneHTMLBuilder") -> None:
64         super().__init__()
65         self.builder = builder
66 
67     def translate(self) -> None:
68         # sadly, this is mostly copied from parent class
69         visitor = self.builder.create_translator(self.document, self.builder)
70         self.visitor = cast(HTMLTranslator, visitor)
71         self.document.walkabout(visitor)
72         self.output = self.visitor.astext()
73         for attr in ('head_prefix', 'stylesheet', 'head', 'body_prefix',
74                      'body_pre_docinfo', 'docinfo', 'body', 'fragment',
75                      'body_suffix', 'meta', 'title', 'subtitle', 'header',
76                      'footer', 'html_prolog', 'html_head', 'html_title',
77                      'html_subtitle', 'html_body', ):
78             setattr(self, attr, getattr(visitor, attr, None))
79         self.clean_meta = ''.join(self.visitor.meta[2:])
80 
81 
82 class HTMLTranslator(SphinxTranslator, BaseTranslator):
83     """
84     Our custom HTML translator.
85     """
86 
87     builder = None  # type: StandaloneHTMLBuilder
88 
89     def __init__(self, *args: Any) -> None:
90         if isinstance(args[0], nodes.document) and isinstance(args[1], Builder):
91             document, builder = args
92         else:
93             warnings.warn('The order of arguments for HTMLTranslator has been changed. '
94                           'Please give "document" as 1st and "builder" as 2nd.',
95                           RemovedInSphinx40Warning, stacklevel=2)
96             builder, document = args
97         super().__init__(document, builder)
98 
99         self.highlighter = self.builder.highlighter
100         self.docnames = [self.builder.current_docname]  # for singlehtml builder
101         self.manpages_url = self.config.manpages_url
102         self.protect_literal_text = 0
103         self.permalink_text = self.config.html_add_permalinks
104         # support backwards-compatible setting to a bool
105         if not isinstance(self.permalink_text, str):
106             self.permalink_text = '¶' if self.permalink_text else ''
107         self.permalink_text = self.encode(self.permalink_text)
108         self.secnumber_suffix = self.config.html_secnumber_suffix
109         self.param_separator = ''
110         self.optional_param_level = 0
111         self._table_row_index = 0
112         self._fieldlist_row_index = 0
113         self.required_params_left = 0
114 
115     def visit_start_of_file(self, node: Element) -> None:
116         # only occurs in the single-file builder
117         self.docnames.append(node['docname'])
118         self.body.append('<span id="document-%s"></span>' % node['docname'])
119 
120     def depart_start_of_file(self, node: Element) -> None:
121         self.docnames.pop()
122 
123     def visit_desc(self, node: Element) -> None:
124         self.body.append(self.starttag(node, 'dl', CLASS=node['objtype']))
125 
126     def depart_desc(self, node: Element) -> None:
127         self.body.append('</dl>\n\n')
128 
129     def visit_desc_signature(self, node: Element) -> None:
130         # the id is set automatically
131         self.body.append(self.starttag(node, 'dt'))
132 
133     def depart_desc_signature(self, node: Element) -> None:
134         if not node.get('is_multiline'):
135             self.add_permalink_ref(node, _('Permalink to this definition'))
136         self.body.append('</dt>\n')
137 
138     def visit_desc_signature_line(self, node: Element) -> None:
139         pass
140 
141     def depart_desc_signature_line(self, node: Element) -> None:
142         if node.get('add_permalink'):
143             # the permalink info is on the parent desc_signature node
144             self.add_permalink_ref(node.parent, _('Permalink to this definition'))
145         self.body.append('<br />')
146 
147     def visit_desc_addname(self, node: Element) -> None:
148         self.body.append(self.starttag(node, 'code', '', CLASS='descclassname'))
149 
150     def depart_desc_addname(self, node: Element) -> None:
151         self.body.append('</code>')
152 
153     def visit_desc_type(self, node: Element) -> None:
154         pass
155 
156     def depart_desc_type(self, node: Element) -> None:
157         pass
158 
159     def visit_desc_returns(self, node: Element) -> None:
160         self.body.append(' &#x2192; ')
161 
162     def depart_desc_returns(self, node: Element) -> None:
163         pass
164 
165     def visit_desc_name(self, node: Element) -> None:
166         self.body.append(self.starttag(node, 'code', '', CLASS='descname'))
167 
168     def depart_desc_name(self, node: Element) -> None:
169         self.body.append('</code>')
170 
171     def visit_desc_parameterlist(self, node: Element) -> None:
172         self.body.append('<span class="sig-paren">(</span>')
173         self.first_param = 1
174         self.optional_param_level = 0
175         # How many required parameters are left.
176         self.required_params_left = sum([isinstance(c, addnodes.desc_parameter)
177                                          for c in node.children])
178         self.param_separator = node.child_text_separator
179 
180     def depart_desc_parameterlist(self, node: Element) -> None:
181         self.body.append('<span class="sig-paren">)</span>')
182 
183     # If required parameters are still to come, then put the comma after
184     # the parameter.  Otherwise, put the comma before.  This ensures that
185     # signatures like the following render correctly (see issue #1001):
186     #
187     #     foo([a, ]b, c[, d])
188     #
189     def visit_desc_parameter(self, node: Element) -> None:
190         if self.first_param:
191             self.first_param = 0
192         elif not self.required_params_left:
193             self.body.append(self.param_separator)
194         if self.optional_param_level == 0:
195             self.required_params_left -= 1
196         if not node.hasattr('noemph'):
197             self.body.append('<em>')
198 
199     def depart_desc_parameter(self, node: Element) -> None:
200         if not node.hasattr('noemph'):
201             self.body.append('</em>')
202         if self.required_params_left:
203             self.body.append(self.param_separator)
204 
205     def visit_desc_optional(self, node: Element) -> None:
206         self.optional_param_level += 1
207         self.body.append('<span class="optional">[</span>')
208 
209     def depart_desc_optional(self, node: Element) -> None:
210         self.optional_param_level -= 1
211         self.body.append('<span class="optional">]</span>')
212 
213     def visit_desc_annotation(self, node: Element) -> None:
214         self.body.append(self.starttag(node, 'em', '', CLASS='property'))
215 
216     def depart_desc_annotation(self, node: Element) -> None:
217         self.body.append('</em>')
218 
219     def visit_desc_content(self, node: Element) -> None:
220         self.body.append(self.starttag(node, 'dd', ''))
221 
222     def depart_desc_content(self, node: Element) -> None:
223         self.body.append('</dd>')
224 
225     def visit_versionmodified(self, node: Element) -> None:
226         self.body.append(self.starttag(node, 'div', CLASS=node['type']))
227 
228     def depart_versionmodified(self, node: Element) -> None:
229         self.body.append('</div>\n')
230 
231     # overwritten
232     def visit_reference(self, node: Element) -> None:
233         atts = {'class': 'reference'}
234         if node.get('internal') or 'refuri' not in node:
235             atts['class'] += ' internal'
236         else:
237             atts['class'] += ' external'
238         if 'refuri' in node:
239             atts['href'] = node['refuri'] or '#'
240             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):
241                 atts['href'] = self.cloak_mailto(atts['href'])
242                 self.in_mailto = True
243         else:
244             assert 'refid' in node, \
245                    'References must have "refuri" or "refid" attribute.'
246             atts['href'] = '#' + node['refid']
247         if not isinstance(node.parent, nodes.TextElement):
248             assert len(node) == 1 and isinstance(node[0], nodes.image)
249             atts['class'] += ' image-reference'
250         if 'reftitle' in node:
251             atts['title'] = node['reftitle']
252         if 'target' in node:
253             atts['target'] = node['target']
254         self.body.append(self.starttag(node, 'a', '', **atts))
255 
256         if node.get('secnumber'):
257             self.body.append(('%s' + self.secnumber_suffix) %
258                              '.'.join(map(str, node['secnumber'])))
259 
260     def visit_number_reference(self, node: Element) -> None:
261         self.visit_reference(node)
262 
263     def depart_number_reference(self, node: Element) -> None:
264         self.depart_reference(node)
265 
266     # overwritten -- we don't want source comments to show up in the HTML
267     def visit_comment(self, node: Element) -> None:  # type: ignore
268         raise nodes.SkipNode
269 
270     # overwritten
271     def visit_admonition(self, node: Element, name: str = '') -> None:
272         self.body.append(self.starttag(
273             node, 'div', CLASS=('admonition ' + name)))
274         if name:
275             node.insert(0, nodes.title(name, admonitionlabels[name]))
276         self.set_first_last(node)
277 
278     def visit_seealso(self, node: Element) -> None:
279         self.visit_admonition(node, 'seealso')
280 
281     def depart_seealso(self, node: Element) -> None:
282         self.depart_admonition(node)
283 
284     def get_secnumber(self, node: Element) -> Tuple[int, ...]:
285         if node.get('secnumber'):
286             return node['secnumber']
287         elif isinstance(node.parent, nodes.section):
288             if self.builder.name == 'singlehtml':
289                 docname = self.docnames[-1]
290                 anchorname = "%s/#%s" % (docname, node.parent['ids'][0])
291                 if anchorname not in self.builder.secnumbers:
292                     anchorname = "%s/" % docname  # try first heading which has no anchor
293             else:
294                 anchorname = '#' + node.parent['ids'][0]
295                 if anchorname not in self.builder.secnumbers:
296                     anchorname = ''  # try first heading which has no anchor
297 
298             if self.builder.secnumbers.get(anchorname):
299                 return self.builder.secnumbers[anchorname]
300 
301         return None
302 
303     def add_secnumber(self, node: Element) -> None:
304         secnumber = self.get_secnumber(node)
305         if secnumber:
306             self.body.append('<span class="section-number">%s</span>' %
307                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))
308 
309     def add_fignumber(self, node: Element) -> None:
310         def append_fignumber(figtype: str, figure_id: str) -> None:
311             if self.builder.name == 'singlehtml':
312                 key = "%s/%s" % (self.docnames[-1], figtype)
313             else:
314                 key = figtype
315 
316             if figure_id in self.builder.fignumbers.get(key, {}):
317                 self.body.append('<span class="caption-number">')
318                 prefix = self.builder.config.numfig_format.get(figtype)
319                 if prefix is None:
320                     msg = __('numfig_format is not defined for %s') % figtype
321                     logger.warning(msg)
322                 else:
323                     numbers = self.builder.fignumbers[key][figure_id]
324                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')
325                     self.body.append('</span>')
326 
327         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)
328         if figtype:
329             if len(node['ids']) == 0:
330                 msg = __('Any IDs not assigned for %s node') % node.tagname
331                 logger.warning(msg, location=node)
332             else:
333                 append_fignumber(figtype, node['ids'][0])
334 
335     def add_permalink_ref(self, node: Element, title: str) -> None:
336         if node['ids'] and self.permalink_text and self.builder.add_permalinks:
337             format = '<a class="headerlink" href="#%s" title="%s">%s</a>'
338             self.body.append(format % (node['ids'][0], title, self.permalink_text))
339 
340     def generate_targets_for_listing(self, node: Element) -> None:
341         """Generate hyperlink targets for listings.
342 
343         Original visit_bullet_list(), visit_definition_list() and visit_enumerated_list()
344         generates hyperlink targets inside listing tags (<ul>, <ol> and <dl>) if multiple
345         IDs are assigned to listings.  That is invalid DOM structure.
346         (This is a bug of docutils <= 0.12)
347 
348         This exports hyperlink targets before listings to make valid DOM structure.
349         """
350         for id in node['ids'][1:]:
351             self.body.append('<span id="%s"></span>' % id)
352             node['ids'].remove(id)
353 
354     # overwritten
355     def visit_bullet_list(self, node: Element) -> None:
356         if len(node) == 1 and isinstance(node[0], addnodes.toctree):
357             # avoid emitting empty <ul></ul>
358             raise nodes.SkipNode
359         self.generate_targets_for_listing(node)
360         super().visit_bullet_list(node)
361 
362     # overwritten
363     def visit_enumerated_list(self, node: Element) -> None:
364         self.generate_targets_for_listing(node)
365         super().visit_enumerated_list(node)
366 
367     # overwritten
368     def visit_definition(self, node: Element) -> None:
369         # don't insert </dt> here.
370         self.body.append(self.starttag(node, 'dd', ''))
371 
372     # overwritten
373     def depart_definition(self, node: Element) -> None:
374         self.body.append('</dd>\n')
375 
376     # overwritten
377     def visit_classifier(self, node: Element) -> None:
378         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))
379 
380     # overwritten
381     def depart_classifier(self, node: Element) -> None:
382         self.body.append('</span>')
383 
384         next_node = node.next_node(descend=False, siblings=True)  # type: Node
385         if not isinstance(next_node, nodes.classifier):
386             # close `<dt>` tag at the tail of classifiers
387             self.body.append('</dt>')
388 
389     # overwritten
390     def visit_term(self, node: Element) -> None:
391         self.body.append(self.starttag(node, 'dt', ''))
392 
393     # overwritten
394     def depart_term(self, node: Element) -> None:
395         next_node = node.next_node(descend=False, siblings=True)  # type: Node
396         if isinstance(next_node, nodes.classifier):
397             # Leave the end tag to `self.depart_classifier()`, in case
398             # there's a classifier.
399             pass
400         else:
401             self.body.append('</dt>')
402 
403     # overwritten
404     def visit_title(self, node: Element) -> None:
405         super().visit_title(node)
406         self.add_secnumber(node)
407         self.add_fignumber(node.parent)
408         if isinstance(node.parent, nodes.table):
409             self.body.append('<span class="caption-text">')
410 
411     def depart_title(self, node: Element) -> None:
412         close_tag = self.context[-1]
413         if (self.permalink_text and self.builder.add_permalinks and
414            node.parent.hasattr('ids') and node.parent['ids']):
415             # add permalink anchor
416             if close_tag.startswith('</h'):
417                 self.add_permalink_ref(node.parent, _('Permalink to this headline'))
418             elif close_tag.startswith('</a></h'):
419                 self.body.append('</a><a class="headerlink" href="#%s" ' %
420                                  node.parent['ids'][0] +
421                                  'title="%s">%s' % (
422                                      _('Permalink to this headline'),
423                                      self.permalink_text))
424             elif isinstance(node.parent, nodes.table):
425                 self.body.append('</span>')
426                 self.add_permalink_ref(node.parent, _('Permalink to this table'))
427         elif isinstance(node.parent, nodes.table):
428             self.body.append('</span>')
429 
430         super().depart_title(node)
431 
432     # overwritten
433     def visit_literal_block(self, node: Element) -> None:
434         if node.rawsource != node.astext():
435             # most probably a parsed-literal block -- don't highlight
436             return super().visit_literal_block(node)
437 
438         lang = node.get('language', 'default')
439         linenos = node.get('linenos', False)
440         highlight_args = node.get('highlight_args', {})
441         highlight_args['force'] = node.get('force', False)
442         if lang is self.builder.config.highlight_language:
443             # only pass highlighter options for original language
444             opts = self.builder.config.highlight_options
445         else:
446             opts = {}
447 
448         if linenos and self.builder.config.html_codeblock_linenos_style:
449             linenos = self.builder.config.html_codeblock_linenos_style
450 
451         highlighted = self.highlighter.highlight_block(
452             node.rawsource, lang, opts=opts, linenos=linenos,
453             location=(self.builder.current_docname, node.line), **highlight_args
454         )
455         starttag = self.starttag(node, 'div', suffix='',
456                                  CLASS='highlight-%s notranslate' % lang)
457         self.body.append(starttag + highlighted + '</div>\n')
458         raise nodes.SkipNode
459 
460     def visit_caption(self, node: Element) -> None:
461         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
462             self.body.append('<div class="code-block-caption">')
463         else:
464             super().visit_caption(node)
465         self.add_fignumber(node.parent)
466         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))
467 
468     def depart_caption(self, node: Element) -> None:
469         self.body.append('</span>')
470 
471         # append permalink if available
472         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
473             self.add_permalink_ref(node.parent, _('Permalink to this code'))
474         elif isinstance(node.parent, nodes.figure):
475             self.add_permalink_ref(node.parent, _('Permalink to this image'))
476         elif node.parent.get('toctree'):
477             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))
478 
479         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
480             self.body.append('</div>\n')
481         else:
482             super().depart_caption(node)
483 
484     def visit_doctest_block(self, node: Element) -> None:
485         self.visit_literal_block(node)
486 
487     # overwritten to add the <div> (for XHTML compliance)
488     def visit_block_quote(self, node: Element) -> None:
489         self.body.append(self.starttag(node, 'blockquote') + '<div>')
490 
491     def depart_block_quote(self, node: Element) -> None:
492         self.body.append('</div></blockquote>\n')
493 
494     # overwritten
495     def visit_literal(self, node: Element) -> None:
496         if 'kbd' in node['classes']:
497             self.body.append(self.starttag(node, 'kbd', '',
498                                            CLASS='docutils literal notranslate'))
499         else:
500             self.body.append(self.starttag(node, 'code', '',
501                                            CLASS='docutils literal notranslate'))
502             self.protect_literal_text += 1
503 
504     def depart_literal(self, node: Element) -> None:
505         if 'kbd' in node['classes']:
506             self.body.append('</kbd>')
507         else:
508             self.protect_literal_text -= 1
509             self.body.append('</code>')
510 
511     def visit_productionlist(self, node: Element) -> None:
512         self.body.append(self.starttag(node, 'pre'))
513         names = []
514         productionlist = cast(Iterable[addnodes.production], node)
515         for production in productionlist:
516             names.append(production['tokenname'])
517         maxlen = max(len(name) for name in names)
518         lastname = None
519         for production in productionlist:
520             if production['tokenname']:
521                 lastname = production['tokenname'].ljust(maxlen)
522                 self.body.append(self.starttag(production, 'strong', ''))
523                 self.body.append(lastname + '</strong> ::= ')
524             elif lastname is not None:
525                 self.body.append('%s     ' % (' ' * len(lastname)))
526             production.walkabout(self)
527             self.body.append('\n')
528         self.body.append('</pre>\n')
529         raise nodes.SkipNode
530 
531     def depart_productionlist(self, node: Element) -> None:
532         pass
533 
534     def visit_production(self, node: Element) -> None:
535         pass
536 
537     def depart_production(self, node: Element) -> None:
538         pass
539 
540     def visit_centered(self, node: Element) -> None:
541         self.body.append(self.starttag(node, 'p', CLASS="centered") +
542                          '<strong>')
543 
544     def depart_centered(self, node: Element) -> None:
545         self.body.append('</strong></p>')
546 
547     # overwritten
548     def should_be_compact_paragraph(self, node: Node) -> bool:
549         """Determine if the <p> tags around paragraph can be omitted."""
550         if isinstance(node.parent, addnodes.desc_content):
551             # Never compact desc_content items.
552             return False
553         if isinstance(node.parent, addnodes.versionmodified):
554             # Never compact versionmodified nodes.
555             return False
556         return super().should_be_compact_paragraph(node)
557 
558     def visit_compact_paragraph(self, node: Element) -> None:
559         pass
560 
561     def depart_compact_paragraph(self, node: Element) -> None:
562         pass
563 
564     def visit_download_reference(self, node: Element) -> None:
565         atts = {'class': 'reference download',
566                 'download': ''}
567 
568         if not self.builder.download_support:
569             self.context.append('')
570         elif 'refuri' in node:
571             atts['class'] += ' external'
572             atts['href'] = node['refuri']
573             self.body.append(self.starttag(node, 'a', '', **atts))
574             self.context.append('</a>')
575         elif 'filename' in node:
576             atts['class'] += ' internal'
577             atts['href'] = posixpath.join(self.builder.dlpath, node['filename'])
578             self.body.append(self.starttag(node, 'a', '', **atts))
579             self.context.append('</a>')
580         else:
581             self.context.append('')
582 
583     def depart_download_reference(self, node: Element) -> None:
584         self.body.append(self.context.pop())
585 
586     # overwritten
587     def visit_image(self, node: Element) -> None:
588         olduri = node['uri']
589         # rewrite the URI if the environment knows about it
590         if olduri in self.builder.images:
591             node['uri'] = posixpath.join(self.builder.imgpath,
592                                          self.builder.images[olduri])
593 
594         if 'scale' in node:
595             # Try to figure out image height and width.  Docutils does that too,
596             # but it tries the final file name, which does not necessarily exist
597             # yet at the time the HTML file is written.
598             if not ('width' in node and 'height' in node):
599                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))
600                 if size is None:
601                     logger.warning(__('Could not obtain image size. :scale: option is ignored.'),  # NOQA
602                                    location=node)
603                 else:
604                     if 'width' not in node:
605                         node['width'] = str(size[0])
606                     if 'height' not in node:
607                         node['height'] = str(size[1])
608 
609         uri = node['uri']
610         if uri.lower().endswith(('svg', 'svgz')):
611             atts = {'src': uri}
612             if 'width' in node:
613                 atts['width'] = node['width']
614             if 'height' in node:
615                 atts['height'] = node['height']
616             if 'scale' in node:
617                 if 'width' in atts:
618                     atts['width'] = multiply_length(atts['width'], node['scale'])
619                 if 'height' in atts:
620                     atts['height'] = multiply_length(atts['height'], node['scale'])
621             atts['alt'] = node.get('alt', uri)
622             if 'align' in node:
623                 atts['class'] = 'align-%s' % node['align']
624             self.body.append(self.emptytag(node, 'img', '', **atts))
625             return
626 
627         super().visit_image(node)
628 
629     # overwritten
630     def depart_image(self, node: Element) -> None:
631         if node['uri'].lower().endswith(('svg', 'svgz')):
632             pass
633         else:
634             super().depart_image(node)
635 
636     def visit_toctree(self, node: Element) -> None:
637         # this only happens when formatting a toc from env.tocs -- in this
638         # case we don't want to include the subtree
639         raise nodes.SkipNode
640 
641     def visit_index(self, node: Element) -> None:
642         raise nodes.SkipNode
643 
644     def visit_tabular_col_spec(self, node: Element) -> None:
645         raise nodes.SkipNode
646 
647     def visit_glossary(self, node: Element) -> None:
648         pass
649 
650     def depart_glossary(self, node: Element) -> None:
651         pass
652 
653     def visit_acks(self, node: Element) -> None:
654         pass
655 
656     def depart_acks(self, node: Element) -> None:
657         pass
658 
659     def visit_hlist(self, node: Element) -> None:
660         self.body.append('<table class="hlist"><tr>')
661 
662     def depart_hlist(self, node: Element) -> None:
663         self.body.append('</tr></table>\n')
664 
665     def visit_hlistcol(self, node: Element) -> None:
666         self.body.append('<td>')
667 
668     def depart_hlistcol(self, node: Element) -> None:
669         self.body.append('</td>')
670 
671     def visit_option_group(self, node: Element) -> None:
672         super().visit_option_group(node)
673         self.context[-2] = self.context[-2].replace('&nbsp;', '&#160;')
674 
675     # overwritten
676     def visit_Text(self, node: Text) -> None:
677         text = node.astext()
678         encoded = self.encode(text)
679         if self.protect_literal_text:
680             # moved here from base class's visit_literal to support
681             # more formatting in literal nodes
682             for token in self.words_and_spaces.findall(encoded):
683                 if token.strip():
684                     # protect literal text from line wrapping
685                     self.body.append('<span class="pre">%s</span>' % token)
686                 elif token in ' \n':
687                     # allow breaks at whitespace
688                     self.body.append(token)
689                 else:
690                     # protect runs of multiple spaces; the last one can wrap
691                     self.body.append('&#160;' * (len(token) - 1) + ' ')
692         else:
693             if self.in_mailto and self.settings.cloak_email_addresses:
694                 encoded = self.cloak_email(encoded)
695             self.body.append(encoded)
696 
697     def visit_note(self, node: Element) -> None:
698         self.visit_admonition(node, 'note')
699 
700     def depart_note(self, node: Element) -> None:
701         self.depart_admonition(node)
702 
703     def visit_warning(self, node: Element) -> None:
704         self.visit_admonition(node, 'warning')
705 
706     def depart_warning(self, node: Element) -> None:
707         self.depart_admonition(node)
708 
709     def visit_attention(self, node: Element) -> None:
710         self.visit_admonition(node, 'attention')
711 
712     def depart_attention(self, node: Element) -> None:
713         self.depart_admonition(node)
714 
715     def visit_caution(self, node: Element) -> None:
716         self.visit_admonition(node, 'caution')
717 
718     def depart_caution(self, node: Element) -> None:
719         self.depart_admonition(node)
720 
721     def visit_danger(self, node: Element) -> None:
722         self.visit_admonition(node, 'danger')
723 
724     def depart_danger(self, node: Element) -> None:
725         self.depart_admonition(node)
726 
727     def visit_error(self, node: Element) -> None:
728         self.visit_admonition(node, 'error')
729 
730     def depart_error(self, node: Element) -> None:
731         self.depart_admonition(node)
732 
733     def visit_hint(self, node: Element) -> None:
734         self.visit_admonition(node, 'hint')
735 
736     def depart_hint(self, node: Element) -> None:
737         self.depart_admonition(node)
738 
739     def visit_important(self, node: Element) -> None:
740         self.visit_admonition(node, 'important')
741 
742     def depart_important(self, node: Element) -> None:
743         self.depart_admonition(node)
744 
745     def visit_tip(self, node: Element) -> None:
746         self.visit_admonition(node, 'tip')
747 
748     def depart_tip(self, node: Element) -> None:
749         self.depart_admonition(node)
750 
751     def visit_literal_emphasis(self, node: Element) -> None:
752         return self.visit_emphasis(node)
753 
754     def depart_literal_emphasis(self, node: Element) -> None:
755         return self.depart_emphasis(node)
756 
757     def visit_literal_strong(self, node: Element) -> None:
758         return self.visit_strong(node)
759 
760     def depart_literal_strong(self, node: Element) -> None:
761         return self.depart_strong(node)
762 
763     def visit_abbreviation(self, node: Element) -> None:
764         attrs = {}
765         if node.hasattr('explanation'):
766             attrs['title'] = node['explanation']
767         self.body.append(self.starttag(node, 'abbr', '', **attrs))
768 
769     def depart_abbreviation(self, node: Element) -> None:
770         self.body.append('</abbr>')
771 
772     def visit_manpage(self, node: Element) -> None:
773         self.visit_literal_emphasis(node)
774         if self.manpages_url:
775             node['refuri'] = self.manpages_url.format(**node.attributes)
776             self.visit_reference(node)
777 
778     def depart_manpage(self, node: Element) -> None:
779         if self.manpages_url:
780             self.depart_reference(node)
781         self.depart_literal_emphasis(node)
782 
783     # overwritten to add even/odd classes
784 
785     def visit_table(self, node: Element) -> None:
786         self._table_row_index = 0
787         return super().visit_table(node)
788 
789     def visit_row(self, node: Element) -> None:
790         self._table_row_index += 1
791         if self._table_row_index % 2 == 0:
792             node['classes'].append('row-even')
793         else:
794             node['classes'].append('row-odd')
795         self.body.append(self.starttag(node, 'tr', ''))
796         node.column = 0  # type: ignore
797 
798     def visit_entry(self, node: Element) -> None:
799         super().visit_entry(node)
800         if self.body[-1] == '&nbsp;':
801             self.body[-1] = '&#160;'
802 
803     def visit_field_list(self, node: Element) -> None:
804         self._fieldlist_row_index = 0
805         return super().visit_field_list(node)
806 
807     def visit_field(self, node: Element) -> None:
808         self._fieldlist_row_index += 1
809         if self._fieldlist_row_index % 2 == 0:
810             node['classes'].append('field-even')
811         else:
812             node['classes'].append('field-odd')
813         self.body.append(self.starttag(node, 'tr', '', CLASS='field'))
814 
815     def visit_field_name(self, node: Element) -> None:
816         context_count = len(self.context)
817         super().visit_field_name(node)
818         if context_count != len(self.context):
819             self.context[-1] = self.context[-1].replace('&nbsp;', '&#160;')
820 
821     def visit_math(self, node: Element, math_env: str = '') -> None:
822         name = self.builder.math_renderer_name
823         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]
824         visit(self, node)
825 
826     def depart_math(self, node: Element, math_env: str = '') -> None:
827         name = self.builder.math_renderer_name
828         _, depart = self.builder.app.registry.html_inline_math_renderers[name]
829         if depart:
830             depart(self, node)
831 
832     def visit_math_block(self, node: Element, math_env: str = '') -> None:
833         name = self.builder.math_renderer_name
834         visit, _ = self.builder.app.registry.html_block_math_renderers[name]
835         visit(self, node)
836 
837     def depart_math_block(self, node: Element, math_env: str = '') -> None:
838         name = self.builder.math_renderer_name
839         _, depart = self.builder.app.registry.html_block_math_renderers[name]
840         if depart:
841             depart(self, node)
842 
843     def unknown_visit(self, node: Node) -> None:
844         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)

</code><intended_behavior>This file should contain logic that generates the HTML output for index pages. The intended behavior would be to modify the method responsible for categorizing index entries to ensure that all entries starting with special characters are consolidated under a single "Symbols" section. This might involve adjusting how characters are compared or adding a unified category for all such special characters.</intended_behavior>, <file>sphinx/builders/html/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.builders.html
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Several HTML builders.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import html
12 import posixpath
13 import re
14 import sys
15 import warnings
16 from os import path
17 from typing import Any, Dict, IO, Iterable, Iterator, List, Set, Tuple
18 from urllib.parse import quote
19 
20 from docutils import nodes
21 from docutils.core import publish_parts
22 from docutils.frontend import OptionParser
23 from docutils.io import DocTreeInput, StringOutput
24 from docutils.nodes import Node
25 from docutils.utils import relative_path
26 
27 from sphinx import package_dir, __display_version__
28 from sphinx.application import Sphinx
29 from sphinx.builders import Builder
30 from sphinx.config import Config, ENUM
31 from sphinx.deprecation import RemovedInSphinx40Warning
32 from sphinx.domains import Domain, Index, IndexEntry
33 from sphinx.environment.adapters.asset import ImageAdapter
34 from sphinx.environment.adapters.indexentries import IndexEntries
35 from sphinx.environment.adapters.toctree import TocTree
36 from sphinx.errors import ConfigError, ThemeError
37 from sphinx.highlighting import PygmentsBridge
38 from sphinx.locale import _, __
39 from sphinx.search import js_index
40 from sphinx.theming import HTMLThemeFactory
41 from sphinx.util import logging, progress_message, status_iterator, md5
42 from sphinx.util.docutils import is_html5_writer_available, new_document
43 from sphinx.util.fileutil import copy_asset
44 from sphinx.util.i18n import format_date
45 from sphinx.util.inventory import InventoryFile
46 from sphinx.util.matching import patmatch, Matcher, DOTFILES
47 from sphinx.util.osutil import os_path, relative_uri, ensuredir, movefile, copyfile
48 from sphinx.util.tags import Tags
49 from sphinx.writers.html import HTMLWriter, HTMLTranslator
50 
51 if False:
52     # For type annotation
53     from typing import Type  # for python3.5.1
54 
55 
56 # HTML5 Writer is available or not
57 if is_html5_writer_available():
58     from sphinx.writers.html5 import HTML5Translator
59     html5_ready = True
60 else:
61     html5_ready = False
62 
63 #: the filename for the inventory of objects
64 INVENTORY_FILENAME = 'objects.inv'
65 
66 logger = logging.getLogger(__name__)
67 return_codes_re = re.compile('[\r\n]+')
68 
69 
70 def get_stable_hash(obj: Any) -> str:
71     """
72     Return a stable hash for a Python data structure.  We can't just use
73     the md5 of str(obj) since for example dictionary items are enumerated
74     in unpredictable order due to hash randomization in newer Pythons.
75     """
76     if isinstance(obj, dict):
77         return get_stable_hash(list(obj.items()))
78     elif isinstance(obj, (list, tuple)):
79         obj = sorted(get_stable_hash(o) for o in obj)
80     return md5(str(obj).encode()).hexdigest()
81 
82 
83 class Stylesheet(str):
84     """A metadata of stylesheet.
85 
86     To keep compatibility with old themes, an instance of stylesheet behaves as
87     its filename (str).
88     """
89 
90     attributes = None   # type: Dict[str, str]
91     filename = None     # type: str
92 
93     def __new__(cls, filename: str, *args: str, **attributes: str) -> "Stylesheet":
94         self = str.__new__(cls, filename)  # type: ignore
95         self.filename = filename
96         self.attributes = attributes
97         self.attributes.setdefault('rel', 'stylesheet')
98         self.attributes.setdefault('type', 'text/css')
99         if args:  # old style arguments (rel, title)
100             self.attributes['rel'] = args[0]
101             self.attributes['title'] = args[1]
102 
103         return self
104 
105 
106 class JavaScript(str):
107     """A metadata of javascript file.
108 
109     To keep compatibility with old themes, an instance of javascript behaves as
110     its filename (str).
111     """
112 
113     attributes = None   # type: Dict[str, str]
114     filename = None     # type: str
115 
116     def __new__(cls, filename: str, **attributes: str) -> "JavaScript":
117         self = str.__new__(cls, filename)  # type: ignore
118         self.filename = filename
119         self.attributes = attributes
120 
121         return self
122 
123 
124 class BuildInfo:
125     """buildinfo file manipulator.
126 
127     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.
128     This class is a manipulator for the file.
129     """
130 
131     @classmethod
132     def load(cls, f: IO) -> "BuildInfo":
133         try:
134             lines = f.readlines()
135             assert lines[0].rstrip() == '# Sphinx build info version 1'
136             assert lines[2].startswith('config: ')
137             assert lines[3].startswith('tags: ')
138 
139             build_info = BuildInfo()
140             build_info.config_hash = lines[2].split()[1].strip()
141             build_info.tags_hash = lines[3].split()[1].strip()
142             return build_info
143         except Exception as exc:
144             raise ValueError(__('build info file is broken: %r') % exc) from exc
145 
146     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA
147         self.config_hash = ''
148         self.tags_hash = ''
149 
150         if config:
151             values = {c.name: c.value for c in config.filter(config_categories)}
152             self.config_hash = get_stable_hash(values)
153 
154         if tags:
155             self.tags_hash = get_stable_hash(sorted(tags))
156 
157     def __eq__(self, other: "BuildInfo") -> bool:  # type: ignore
158         return (self.config_hash == other.config_hash and
159                 self.tags_hash == other.tags_hash)
160 
161     def dump(self, f: IO) -> None:
162         f.write('# Sphinx build info version 1\n'
163                 '# This file hashes the configuration used when building these files.'
164                 ' When it is not found, a full rebuild will be done.\n'
165                 'config: %s\n'
166                 'tags: %s\n' %
167                 (self.config_hash, self.tags_hash))
168 
169 
170 class StandaloneHTMLBuilder(Builder):
171     """
172     Builds standalone HTML docs.
173     """
174     name = 'html'
175     format = 'html'
176     epilog = __('The HTML pages are in %(outdir)s.')
177 
178     copysource = True
179     allow_parallel = True
180     out_suffix = '.html'
181     link_suffix = '.html'  # defaults to matching out_suffix
182     indexer_format = js_index  # type: Any
183     indexer_dumps_unicode = True
184     # create links to original images from images [True/False]
185     html_scaled_image_link = True
186     supported_image_types = ['image/svg+xml', 'image/png',
187                              'image/gif', 'image/jpeg']
188     supported_remote_images = True
189     supported_data_uri_images = True
190     searchindex_filename = 'searchindex.js'
191     add_permalinks = True
192     allow_sharp_as_current_path = True
193     embedded = False  # for things like HTML help or Qt help: suppresses sidebar
194     search = True  # for things like HTML help and Apple help: suppress search
195     use_index = False
196     download_support = True  # enable download role
197 
198     imgpath = None          # type: str
199     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA
200 
201     def __init__(self, app: Sphinx) -> None:
202         super().__init__(app)
203 
204         # CSS files
205         self.css_files = []  # type: List[Dict[str, str]]
206 
207         # JS files
208         self.script_files = []  # type: List[JavaScript]
209 
210     def init(self) -> None:
211         self.build_info = self.create_build_info()
212         # basename of images directory
213         self.imagedir = '_images'
214         # section numbers for headings in the currently visited document
215         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]
216         # currently written docname
217         self.current_docname = None  # type: str
218 
219         self.init_templates()
220         self.init_highlighter()
221         self.init_css_files()
222         self.init_js_files()
223 
224         html_file_suffix = self.get_builder_config('file_suffix', 'html')
225         if html_file_suffix is not None:
226             self.out_suffix = html_file_suffix
227 
228         html_link_suffix = self.get_builder_config('link_suffix', 'html')
229         if html_link_suffix is not None:
230             self.link_suffix = html_link_suffix
231         else:
232             self.link_suffix = self.out_suffix
233 
234         self.use_index = self.get_builder_config('use_index', 'html')
235 
236     def create_build_info(self) -> BuildInfo:
237         return BuildInfo(self.config, self.tags, ['html'])
238 
239     def _get_translations_js(self) -> str:
240         candidates = [path.join(dir, self.config.language,
241                                 'LC_MESSAGES', 'sphinx.js')
242                       for dir in self.config.locale_dirs] + \
243                      [path.join(package_dir, 'locale', self.config.language,
244                                 'LC_MESSAGES', 'sphinx.js'),
245                       path.join(sys.prefix, 'share/sphinx/locale',
246                                 self.config.language, 'sphinx.js')]
247 
248         for jsfile in candidates:
249             if path.isfile(jsfile):
250                 return jsfile
251         return None
252 
253     def get_theme_config(self) -> Tuple[str, Dict]:
254         return self.config.html_theme, self.config.html_theme_options
255 
256     def init_templates(self) -> None:
257         theme_factory = HTMLThemeFactory(self.app)
258         themename, themeoptions = self.get_theme_config()
259         self.theme = theme_factory.create(themename)
260         self.theme_options = themeoptions.copy()
261         self.create_template_bridge()
262         self.templates.init(self, self.theme)
263 
264     def init_highlighter(self) -> None:
265         # determine Pygments style and create the highlighter
266         if self.config.pygments_style is not None:
267             style = self.config.pygments_style
268         elif self.theme:
269             style = self.theme.get_config('theme', 'pygments_style', 'none')
270         else:
271             style = 'sphinx'
272         self.highlighter = PygmentsBridge('html', style)
273 
274         if self.theme:
275             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)
276         else:
277             dark_style = None
278 
279         if dark_style is not None:
280             self.dark_highlighter = PygmentsBridge('html', dark_style)
281             self.add_css_file('pygments_dark.css',
282                               media='(prefers-color-scheme: dark)',
283                               id='pygments_dark_css')
284         else:
285             self.dark_highlighter = None
286 
287     def init_css_files(self) -> None:
288         for filename, attrs in self.app.registry.css_files:
289             self.add_css_file(filename, **attrs)
290 
291         for filename, attrs in self.get_builder_config('css_files', 'html'):
292             self.add_css_file(filename, **attrs)
293 
294     def add_css_file(self, filename: str, **kwargs: str) -> None:
295         if '://' not in filename:
296             filename = posixpath.join('_static', filename)
297 
298         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore
299 
300     def init_js_files(self) -> None:
301         self.add_js_file('jquery.js')
302         self.add_js_file('underscore.js')
303         self.add_js_file('doctools.js')
304         self.add_js_file('language_data.js')
305 
306         for filename, attrs in self.app.registry.js_files:
307             self.add_js_file(filename, **attrs)
308 
309         for filename, attrs in self.get_builder_config('js_files', 'html'):
310             self.add_js_file(filename, **attrs)
311 
312         if self.config.language and self._get_translations_js():
313             self.add_js_file('translations.js')
314 
315     def add_js_file(self, filename: str, **kwargs: str) -> None:
316         if filename and '://' not in filename:
317             filename = posixpath.join('_static', filename)
318 
319         self.script_files.append(JavaScript(filename, **kwargs))
320 
321     @property
322     def default_translator_class(self) -> "Type[nodes.NodeVisitor]":  # type: ignore
323         if not html5_ready or self.config.html4_writer:
324             return HTMLTranslator
325         else:
326             return HTML5Translator
327 
328     @property
329     def math_renderer_name(self) -> str:
330         name = self.get_builder_config('math_renderer', 'html')
331         if name is not None:
332             # use given name
333             return name
334         else:
335             # not given: choose a math_renderer from registered ones as possible
336             renderers = list(self.app.registry.html_inline_math_renderers)
337             if len(renderers) == 1:
338                 # only default math_renderer (mathjax) is registered
339                 return renderers[0]
340             elif len(renderers) == 2:
341                 # default and another math_renderer are registered; prior the another
342                 renderers.remove('mathjax')
343                 return renderers[0]
344             else:
345                 # many math_renderers are registered. can't choose automatically!
346                 return None
347 
348     def get_outdated_docs(self) -> Iterator[str]:
349         try:
350             with open(path.join(self.outdir, '.buildinfo')) as fp:
351                 buildinfo = BuildInfo.load(fp)
352 
353             if self.build_info != buildinfo:
354                 yield from self.env.found_docs
355                 return
356         except ValueError as exc:
357             logger.warning(__('Failed to read build info file: %r'), exc)
358         except OSError:
359             # ignore errors on reading
360             pass
361 
362         if self.templates:
363             template_mtime = self.templates.newest_template_mtime()
364         else:
365             template_mtime = 0
366         for docname in self.env.found_docs:
367             if docname not in self.env.all_docs:
368                 yield docname
369                 continue
370             targetname = self.get_outfilename(docname)
371             try:
372                 targetmtime = path.getmtime(targetname)
373             except Exception:
374                 targetmtime = 0
375             try:
376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),
377                                template_mtime)
378                 if srcmtime > targetmtime:
379                     yield docname
380             except OSError:
381                 # source doesn't exist anymore
382                 pass
383 
384     def get_asset_paths(self) -> List[str]:
385         return self.config.html_extra_path + self.config.html_static_path
386 
387     def render_partial(self, node: Node) -> Dict[str, str]:
388         """Utility: Render a lone doctree node."""
389         if node is None:
390             return {'fragment': ''}
391         doc = new_document('<partial node>')
392         doc.append(node)
393 
394         writer = HTMLWriter(self)
395         return publish_parts(reader_name='doctree',
396                              writer=writer,
397                              source_class=DocTreeInput,
398                              settings_overrides={'output_encoding': 'unicode'},
399                              source=doc)
400 
401     def prepare_writing(self, docnames: Set[str]) -> None:
402         # create the search indexer
403         self.indexer = None
404         if self.search:
405             from sphinx.search import IndexBuilder
406             lang = self.config.html_search_language or self.config.language
407             if not lang:
408                 lang = 'en'
409             self.indexer = IndexBuilder(self.env, lang,
410                                         self.config.html_search_options,
411                                         self.config.html_search_scorer)
412             self.load_indexer(docnames)
413 
414         self.docwriter = HTMLWriter(self)
415         self.docsettings = OptionParser(
416             defaults=self.env.settings,
417             components=(self.docwriter,),
418             read_config_files=True).get_default_values()  # type: Any
419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)
420 
421         # determine the additional indices to include
422         self.domain_indices = []
423         # html_domain_indices can be False/True or a list of index names
424         indices_config = self.config.html_domain_indices
425         if indices_config:
426             for domain_name in sorted(self.env.domains):
427                 domain = None  # type: Domain
428                 domain = self.env.domains[domain_name]
429                 for indexcls in domain.indices:
430                     indexname = '%s-%s' % (domain.name, indexcls.name)
431                     if isinstance(indices_config, list):
432                         if indexname not in indices_config:
433                             continue
434                     content, collapse = indexcls(domain).generate()
435                     if content:
436                         self.domain_indices.append(
437                             (indexname, indexcls, content, collapse))
438 
439         # format the "last updated on" string, only once is enough since it
440         # typically doesn't include the time of day
441         lufmt = self.config.html_last_updated_fmt
442         if lufmt is not None:
443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),
444                                             language=self.config.language)
445         else:
446             self.last_updated = None
447 
448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''
449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''
450 
451         if not isinstance(self.config.html_use_opensearch, str):
452             logger.warning(__('html_use_opensearch config value must now be a string'))
453 
454         self.relations = self.env.collect_relations()
455 
456         rellinks = []  # type: List[Tuple[str, str, str, str]]
457         if self.use_index:
458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))
459         for indexname, indexcls, content, collapse in self.domain_indices:
460             # if it has a short name
461             if indexcls.shortname:
462                 rellinks.append((indexname, indexcls.localname,
463                                  '', indexcls.shortname))
464 
465         if self.config.html_style is not None:
466             stylename = self.config.html_style
467         elif self.theme:
468             stylename = self.theme.get_config('theme', 'stylesheet')
469         else:
470             stylename = 'default.css'
471 
472         self.globalcontext = {
473             'embedded': self.embedded,
474             'project': self.config.project,
475             'release': return_codes_re.sub('', self.config.release),
476             'version': self.config.version,
477             'last_updated': self.last_updated,
478             'copyright': self.config.copyright,
479             'master_doc': self.config.master_doc,
480             'use_opensearch': self.config.html_use_opensearch,
481             'docstitle': self.config.html_title,
482             'shorttitle': self.config.html_short_title,
483             'show_copyright': self.config.html_show_copyright,
484             'show_sphinx': self.config.html_show_sphinx,
485             'has_source': self.config.html_copy_source,
486             'show_source': self.config.html_show_sourcelink,
487             'sourcelink_suffix': self.config.html_sourcelink_suffix,
488             'file_suffix': self.out_suffix,
489             'link_suffix': self.link_suffix,
490             'script_files': self.script_files,
491             'language': self.config.language,
492             'css_files': self.css_files,
493             'sphinx_version': __display_version__,
494             'style': stylename,
495             'rellinks': rellinks,
496             'builder': self.name,
497             'parents': [],
498             'logo': logo,
499             'favicon': favicon,
500             'html5_doctype': html5_ready and not self.config.html4_writer,
501         }
502         if self.theme:
503             self.globalcontext.update(
504                 ('theme_' + key, val) for (key, val) in
505                 self.theme.get_options(self.theme_options).items())
506         self.globalcontext.update(self.config.html_context)
507 
508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:
509         """Collect items for the template context of a page."""
510         # find out relations
511         prev = next = None
512         parents = []
513         rellinks = self.globalcontext['rellinks'][:]
514         related = self.relations.get(docname)
515         titles = self.env.titles
516         if related and related[2]:
517             try:
518                 next = {
519                     'link': self.get_relative_uri(docname, related[2]),
520                     'title': self.render_partial(titles[related[2]])['title']
521                 }
522                 rellinks.append((related[2], next['title'], 'N', _('next')))
523             except KeyError:
524                 next = None
525         if related and related[1]:
526             try:
527                 prev = {
528                     'link': self.get_relative_uri(docname, related[1]),
529                     'title': self.render_partial(titles[related[1]])['title']
530                 }
531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))
532             except KeyError:
533                 # the relation is (somehow) not in the TOC tree, handle
534                 # that gracefully
535                 prev = None
536         while related and related[0]:
537             try:
538                 parents.append(
539                     {'link': self.get_relative_uri(docname, related[0]),
540                      'title': self.render_partial(titles[related[0]])['title']})
541             except KeyError:
542                 pass
543             related = self.relations.get(related[0])
544         if parents:
545             # remove link to the master file; we have a generic
546             # "back to index" link already
547             parents.pop()
548         parents.reverse()
549 
550         # title rendered as HTML
551         title_node = self.env.longtitles.get(docname)
552         title = self.render_partial(title_node)['title'] if title_node else ''
553 
554         # Suffix for the document
555         source_suffix = self.env.doc2path(docname, False)[len(docname):]
556 
557         # the name for the copied source
558         if self.config.html_copy_source:
559             sourcename = docname + source_suffix
560             if source_suffix != self.config.html_sourcelink_suffix:
561                 sourcename += self.config.html_sourcelink_suffix
562         else:
563             sourcename = ''
564 
565         # metadata for the document
566         meta = self.env.metadata.get(docname)
567 
568         # local TOC and global TOC tree
569         self_toc = TocTree(self.env).get_toc_for(docname, self)
570         toc = self.render_partial(self_toc)['fragment']
571 
572         return {
573             'parents': parents,
574             'prev': prev,
575             'next': next,
576             'title': title,
577             'meta': meta,
578             'body': body,
579             'metatags': metatags,
580             'rellinks': rellinks,
581             'sourcename': sourcename,
582             'toc': toc,
583             # only display a TOC if there's more than one item to show
584             'display_toc': (self.env.toc_num_entries[docname] > 1),
585             'page_source_suffix': source_suffix,
586         }
587 
588     def write_doc(self, docname: str, doctree: nodes.document) -> None:
589         destination = StringOutput(encoding='utf-8')
590         doctree.settings = self.docsettings
591 
592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})
593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})
594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')
595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')
596         self.current_docname = docname
597         self.docwriter.write(doctree, destination)
598         self.docwriter.assemble_parts()
599         body = self.docwriter.parts['fragment']
600         metatags = self.docwriter.clean_meta
601 
602         ctx = self.get_doc_context(docname, body, metatags)
603         self.handle_page(docname, ctx, event_arg=doctree)
604 
605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:
606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)
607         self.post_process_images(doctree)
608         title_node = self.env.longtitles.get(docname)
609         title = self.render_partial(title_node)['title'] if title_node else ''
610         self.index_page(docname, doctree, title)
611 
612     def finish(self) -> None:
613         self.finish_tasks.add_task(self.gen_indices)
614         self.finish_tasks.add_task(self.gen_pages_from_extensions)
615         self.finish_tasks.add_task(self.gen_additional_pages)
616         self.finish_tasks.add_task(self.copy_image_files)
617         self.finish_tasks.add_task(self.copy_download_files)
618         self.finish_tasks.add_task(self.copy_static_files)
619         self.finish_tasks.add_task(self.copy_extra_files)
620         self.finish_tasks.add_task(self.write_buildinfo)
621 
622         # dump the search index
623         self.handle_finish()
624 
625     @progress_message(__('generating indices'))
626     def gen_indices(self) -> None:
627         # the global general index
628         if self.use_index:
629             self.write_genindex()
630 
631         # the global domain-specific indices
632         self.write_domain_indices()
633 
634     def gen_pages_from_extensions(self) -> None:
635         # pages from extensions
636         for pagelist in self.events.emit('html-collect-pages'):
637             for pagename, context, template in pagelist:
638                 self.handle_page(pagename, context, template)
639 
640     @progress_message(__('writing additional pages'))
641     def gen_additional_pages(self) -> None:
642         # additional pages from conf.py
643         for pagename, template in self.config.html_additional_pages.items():
644             logger.info(' ' + pagename, nonl=True)
645             self.handle_page(pagename, {}, template)
646 
647         # the search page
648         if self.search:
649             logger.info(' search', nonl=True)
650             self.handle_page('search', {}, 'search.html')
651 
652         # the opensearch xml file
653         if self.config.html_use_opensearch and self.search:
654             logger.info(' opensearch', nonl=True)
655             fn = path.join(self.outdir, '_static', 'opensearch.xml')
656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)
657 
658     def write_genindex(self) -> None:
659         # the total count of lines for each index letter, used to distribute
660         # the entries into two columns
661         genindex = IndexEntries(self.env).create_index(self)
662         indexcounts = []
663         for _k, entries in genindex:
664             indexcounts.append(sum(1 + len(subitems)
665                                    for _, (_, subitems, _) in entries))
666 
667         genindexcontext = {
668             'genindexentries': genindex,
669             'genindexcounts': indexcounts,
670             'split_index': self.config.html_split_index,
671         }
672         logger.info(' genindex', nonl=True)
673 
674         if self.config.html_split_index:
675             self.handle_page('genindex', genindexcontext,
676                              'genindex-split.html')
677             self.handle_page('genindex-all', genindexcontext,
678                              'genindex.html')
679             for (key, entries), count in zip(genindex, indexcounts):
680                 ctx = {'key': key, 'entries': entries, 'count': count,
681                        'genindexentries': genindex}
682                 self.handle_page('genindex-' + key, ctx,
683                                  'genindex-single.html')
684         else:
685             self.handle_page('genindex', genindexcontext, 'genindex.html')
686 
687     def write_domain_indices(self) -> None:
688         for indexname, indexcls, content, collapse in self.domain_indices:
689             indexcontext = {
690                 'indextitle': indexcls.localname,
691                 'content': content,
692                 'collapse_index': collapse,
693             }
694             logger.info(' ' + indexname, nonl=True)
695             self.handle_page(indexname, indexcontext, 'domainindex.html')
696 
697     def copy_image_files(self) -> None:
698         if self.images:
699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
700             ensuredir(path.join(self.outdir, self.imagedir))
701             for src in status_iterator(self.images, __('copying images... '), "brown",
702                                        len(self.images), self.app.verbosity,
703                                        stringify_func=stringify_func):
704                 dest = self.images[src]
705                 try:
706                     copyfile(path.join(self.srcdir, src),
707                              path.join(self.outdir, self.imagedir, dest))
708                 except Exception as err:
709                     logger.warning(__('cannot copy image file %r: %s'),
710                                    path.join(self.srcdir, src), err)
711 
712     def copy_download_files(self) -> None:
713         def to_relpath(f: str) -> str:
714             return relative_path(self.srcdir, f)
715 
716         # copy downloadable files
717         if self.env.dlfiles:
718             ensuredir(path.join(self.outdir, '_downloads'))
719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),
720                                        "brown", len(self.env.dlfiles), self.app.verbosity,
721                                        stringify_func=to_relpath):
722                 try:
723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])
724                     ensuredir(path.dirname(dest))
725                     copyfile(path.join(self.srcdir, src), dest)
726                 except OSError as err:
727                     logger.warning(__('cannot copy downloadable file %r: %s'),
728                                    path.join(self.srcdir, src), err)
729 
730     def create_pygments_style_file(self) -> None:
731         """create a style file for pygments."""
732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:
733             f.write(self.highlighter.get_stylesheet())
734 
735         if self.dark_highlighter:
736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:
737                 f.write(self.dark_highlighter.get_stylesheet())
738 
739     def copy_translation_js(self) -> None:
740         """Copy a JavaScript file for translations."""
741         if self.config.language is not None:
742             jsfile = self._get_translations_js()
743             if jsfile:
744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))
745 
746     def copy_stemmer_js(self) -> None:
747         """Copy a JavaScript file for stemmer."""
748         if self.indexer is not None:
749             jsfile = self.indexer.get_js_stemmer_rawcode()
750             if jsfile:
751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))
752 
753     def copy_theme_static_files(self, context: Dict) -> None:
754         if self.theme:
755             for entry in self.theme.get_theme_dirs()[::-1]:
756                 copy_asset(path.join(entry, 'static'),
757                            path.join(self.outdir, '_static'),
758                            excluded=DOTFILES, context=context, renderer=self.templates)
759 
760     def copy_html_static_files(self, context: Dict) -> None:
761         excluded = Matcher(self.config.exclude_patterns + ["**/.*"])
762         for entry in self.config.html_static_path:
763             copy_asset(path.join(self.confdir, entry),
764                        path.join(self.outdir, '_static'),
765                        excluded, context=context, renderer=self.templates)
766 
767     def copy_html_logo(self) -> None:
768         if self.config.html_logo:
769             copy_asset(path.join(self.confdir, self.config.html_logo),
770                        path.join(self.outdir, '_static'))
771 
772     def copy_html_favicon(self) -> None:
773         if self.config.html_favicon:
774             copy_asset(path.join(self.confdir, self.config.html_favicon),
775                        path.join(self.outdir, '_static'))
776 
777     def copy_static_files(self) -> None:
778         try:
779             with progress_message(__('copying static files... ')):
780                 ensuredir(path.join(self.outdir, '_static'))
781 
782                 # prepare context for templates
783                 context = self.globalcontext.copy()
784                 if self.indexer is not None:
785                     context.update(self.indexer.context_for_searchtool())
786 
787                 self.create_pygments_style_file()
788                 self.copy_translation_js()
789                 self.copy_stemmer_js()
790                 self.copy_theme_static_files(context)
791                 self.copy_html_static_files(context)
792                 self.copy_html_logo()
793                 self.copy_html_favicon()
794         except OSError as err:
795             logger.warning(__('cannot copy static file %r'), err)
796 
797     def copy_extra_files(self) -> None:
798         """copy html_extra_path files."""
799         try:
800             with progress_message(__('copying extra files')):
801                 excluded = Matcher(self.config.exclude_patterns)
802                 for extra_path in self.config.html_extra_path:
803                     entry = path.join(self.confdir, extra_path)
804                     copy_asset(entry, self.outdir, excluded)
805         except OSError as err:
806             logger.warning(__('cannot copy extra file %r'), err)
807 
808     def write_buildinfo(self) -> None:
809         try:
810             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:
811                 self.build_info.dump(fp)
812         except OSError as exc:
813             logger.warning(__('Failed to write build info file: %r'), exc)
814 
815     def cleanup(self) -> None:
816         # clean up theme stuff
817         if self.theme:
818             self.theme.cleanup()
819 
820     def post_process_images(self, doctree: Node) -> None:
821         """Pick the best candidate for an image and link down-scaled images to
822         their high res version.
823         """
824         Builder.post_process_images(self, doctree)
825 
826         if self.config.html_scaled_image_link and self.html_scaled_image_link:
827             for node in doctree.traverse(nodes.image):
828                 if not any((key in node) for key in ['scale', 'width', 'height']):
829                     # resizing options are not given. scaled image link is available
830                     # only for resized images.
831                     continue
832                 elif isinstance(node.parent, nodes.reference):
833                     # A image having hyperlink target
834                     continue
835                 elif 'no-scaled-link' in node['classes']:
836                     # scaled image link is disabled for this node
837                     continue
838 
839                 uri = node['uri']
840                 reference = nodes.reference('', '', internal=True)
841                 if uri in self.images:
842                     reference['refuri'] = posixpath.join(self.imgpath,
843                                                          self.images[uri])
844                 else:
845                     reference['refuri'] = uri
846                 node.replace_self(reference)
847                 reference.append(node)
848 
849     def load_indexer(self, docnames: Iterable[str]) -> None:
850         keep = set(self.env.all_docs) - set(docnames)
851         try:
852             searchindexfn = path.join(self.outdir, self.searchindex_filename)
853             if self.indexer_dumps_unicode:
854                 with open(searchindexfn, encoding='utf-8') as ft:
855                     self.indexer.load(ft, self.indexer_format)
856             else:
857                 with open(searchindexfn, 'rb') as fb:
858                     self.indexer.load(fb, self.indexer_format)
859         except (OSError, ValueError):
860             if keep:
861                 logger.warning(__('search index couldn\'t be loaded, but not all '
862                                   'documents will be built: the index will be '
863                                   'incomplete.'))
864         # delete all entries for files that will be rebuilt
865         self.indexer.prune(keep)
866 
867     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:
868         # only index pages with title
869         if self.indexer is not None and title:
870             filename = self.env.doc2path(pagename, base=None)
871             try:
872                 metadata = self.env.metadata.get(pagename, {})
873                 if 'nosearch' in metadata:
874                     self.indexer.feed(pagename, filename, '', new_document(''))
875                 else:
876                     self.indexer.feed(pagename, filename, title, doctree)
877             except TypeError:
878                 # fallback for old search-adapters
879                 self.indexer.feed(pagename, title, doctree)  # type: ignore
880                 indexer_name = self.indexer.__class__.__name__
881                 warnings.warn(
882                     'The %s.feed() method signature is deprecated. Update to '
883                     '%s.feed(docname, filename, title, doctree).' % (
884                         indexer_name, indexer_name),
885                     RemovedInSphinx40Warning, stacklevel=2)
886 
887     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:
888         if 'includehidden' not in kwargs:
889             kwargs['includehidden'] = False
890         if kwargs.get('maxdepth') == '':
891             kwargs.pop('maxdepth')
892         return self.render_partial(TocTree(self.env).get_toctree_for(
893             docname, self, collapse, **kwargs))['fragment']
894 
895     def get_outfilename(self, pagename: str) -> str:
896         return path.join(self.outdir, os_path(pagename) + self.out_suffix)
897 
898     def add_sidebars(self, pagename: str, ctx: Dict) -> None:
899         def has_wildcard(pattern: str) -> bool:
900             return any(char in pattern for char in '*?[')
901 
902         sidebars = None
903         matched = None
904         customsidebar = None
905 
906         # default sidebars settings for selected theme
907         if self.theme.name == 'alabaster':
908             # provide default settings for alabaster (for compatibility)
909             # Note: this will be removed before Sphinx-2.0
910             try:
911                 # get default sidebars settings from alabaster (if defined)
912                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')
913                 if theme_default_sidebars:
914                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
915             except Exception:
916                 # fallback to better default settings
917                 sidebars = ['about.html', 'navigation.html', 'relations.html',
918                             'searchbox.html', 'donate.html']
919         else:
920             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)
921             if theme_default_sidebars:
922                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]
923 
924         # user sidebar settings
925         html_sidebars = self.get_builder_config('sidebars', 'html')
926         for pattern, patsidebars in html_sidebars.items():
927             if patmatch(pagename, pattern):
928                 if matched:
929                     if has_wildcard(pattern):
930                         # warn if both patterns contain wildcards
931                         if has_wildcard(matched):
932                             logger.warning(__('page %s matches two patterns in '
933                                               'html_sidebars: %r and %r'),
934                                            pagename, matched, pattern)
935                         # else the already matched pattern is more specific
936                         # than the present one, because it contains no wildcard
937                         continue
938                 matched = pattern
939                 sidebars = patsidebars
940 
941         if sidebars is None:
942             # keep defaults
943             pass
944 
945         ctx['sidebars'] = sidebars
946         ctx['customsidebar'] = customsidebar
947 
948     # --------- these are overwritten by the serialization builder
949 
950     def get_target_uri(self, docname: str, typ: str = None) -> str:
951         return quote(docname) + self.link_suffix
952 
953     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',
954                     outfilename: str = None, event_arg: Any = None) -> None:
955         ctx = self.globalcontext.copy()
956         # current_page_name is backwards compatibility
957         ctx['pagename'] = ctx['current_page_name'] = pagename
958         ctx['encoding'] = self.config.html_output_encoding
959         default_baseuri = self.get_target_uri(pagename)
960         # in the singlehtml builder, default_baseuri still contains an #anchor
961         # part, which relative_uri doesn't really like...
962         default_baseuri = default_baseuri.rsplit('#', 1)[0]
963 
964         if self.config.html_baseurl:
965             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,
966                                             pagename + self.out_suffix)
967         else:
968             ctx['pageurl'] = None
969 
970         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA
971             if resource and '://' in otheruri:
972                 # allow non-local resources given by scheme
973                 return otheruri
974             elif not resource:
975                 otheruri = self.get_target_uri(otheruri)
976             uri = relative_uri(baseuri, otheruri) or '#'
977             if uri == '#' and not self.allow_sharp_as_current_path:
978                 uri = baseuri
979             return uri
980         ctx['pathto'] = pathto
981 
982         def css_tag(css: Stylesheet) -> str:
983             attrs = []
984             for key in sorted(css.attributes):
985                 value = css.attributes[key]
986                 if value is not None:
987                     attrs.append('%s="%s"' % (key, html.escape(value, True)))
988             attrs.append('href="%s"' % pathto(css.filename, resource=True))
989             return '<link %s />' % ' '.join(attrs)
990         ctx['css_tag'] = css_tag
991 
992         def hasdoc(name: str) -> bool:
993             if name in self.env.all_docs:
994                 return True
995             elif name == 'search' and self.search:
996                 return True
997             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):
998                 return True
999             return False
1000         ctx['hasdoc'] = hasdoc
1001 
1002         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)
1003         self.add_sidebars(pagename, ctx)
1004         ctx.update(addctx)
1005 
1006         self.update_page_context(pagename, templatename, ctx, event_arg)
1007         newtmpl = self.app.emit_firstresult('html-page-context', pagename,
1008                                             templatename, ctx, event_arg)
1009         if newtmpl:
1010             templatename = newtmpl
1011 
1012         try:
1013             output = self.templates.render(templatename, ctx)
1014         except UnicodeError:
1015             logger.warning(__("a Unicode error occurred when rendering the page %s. "
1016                               "Please make sure all config values that contain "
1017                               "non-ASCII content are Unicode strings."), pagename)
1018             return
1019         except Exception as exc:
1020             raise ThemeError(__("An error happened in rendering the page %s.\nReason: %r") %
1021                              (pagename, exc)) from exc
1022 
1023         if not outfilename:
1024             outfilename = self.get_outfilename(pagename)
1025         # outfilename's path is in general different from self.outdir
1026         ensuredir(path.dirname(outfilename))
1027         try:
1028             with open(outfilename, 'w', encoding=ctx['encoding'],
1029                       errors='xmlcharrefreplace') as f:
1030                 f.write(output)
1031         except OSError as err:
1032             logger.warning(__("error writing file %s: %s"), outfilename, err)
1033         if self.copysource and ctx.get('sourcename'):
1034             # copy the source file for the "show source" link
1035             source_name = path.join(self.outdir, '_sources',
1036                                     os_path(ctx['sourcename']))
1037             ensuredir(path.dirname(source_name))
1038             copyfile(self.env.doc2path(pagename), source_name)
1039 
1040     def update_page_context(self, pagename: str, templatename: str,
1041                             ctx: Dict, event_arg: Any) -> None:
1042         pass
1043 
1044     def handle_finish(self) -> None:
1045         if self.indexer:
1046             self.finish_tasks.add_task(self.dump_search_index)
1047         self.finish_tasks.add_task(self.dump_inventory)
1048 
1049     @progress_message(__('dumping object inventory'))
1050     def dump_inventory(self) -> None:
1051         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)
1052 
1053     def dump_search_index(self) -> None:
1054         with progress_message(__('dumping search index in %s') % self.indexer.label()):
1055             self.indexer.prune(self.env.all_docs)
1056             searchindexfn = path.join(self.outdir, self.searchindex_filename)
1057             # first write to a temporary file, so that if dumping fails,
1058             # the existing index won't be overwritten
1059             if self.indexer_dumps_unicode:
1060                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:
1061                     self.indexer.dump(ft, self.indexer_format)
1062             else:
1063                 with open(searchindexfn + '.tmp', 'wb') as fb:
1064                     self.indexer.dump(fb, self.indexer_format)
1065             movefile(searchindexfn + '.tmp', searchindexfn)
1066 
1067 
1068 def convert_html_css_files(app: Sphinx, config: Config) -> None:
1069     """This converts string styled html_css_files to tuple styled one."""
1070     html_css_files = []  # type: List[Tuple[str, Dict]]
1071     for entry in config.html_css_files:
1072         if isinstance(entry, str):
1073             html_css_files.append((entry, {}))
1074         else:
1075             try:
1076                 filename, attrs = entry
1077                 html_css_files.append((filename, attrs))
1078             except Exception:
1079                 logger.warning(__('invalid css_file: %r, ignored'), entry)
1080                 continue
1081 
1082     config.html_css_files = html_css_files  # type: ignore
1083 
1084 
1085 def convert_html_js_files(app: Sphinx, config: Config) -> None:
1086     """This converts string styled html_js_files to tuple styled one."""
1087     html_js_files = []  # type: List[Tuple[str, Dict]]
1088     for entry in config.html_js_files:
1089         if isinstance(entry, str):
1090             html_js_files.append((entry, {}))
1091         else:
1092             try:
1093                 filename, attrs = entry
1094                 html_js_files.append((filename, attrs))
1095             except Exception:
1096                 logger.warning(__('invalid js_file: %r, ignored'), entry)
1097                 continue
1098 
1099     config.html_js_files = html_js_files  # type: ignore
1100 
1101 
1102 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,
1103                         context: Dict, doctree: Node) -> None:
1104     """Set up js_tag() template helper.
1105 
1106     .. note:: This set up function is added to keep compatibility with webhelper.
1107     """
1108     pathto = context.get('pathto')
1109 
1110     def js_tag(js: JavaScript) -> str:
1111         attrs = []
1112         body = ''
1113         if isinstance(js, JavaScript):
1114             for key in sorted(js.attributes):
1115                 value = js.attributes[key]
1116                 if value is not None:
1117                     if key == 'body':
1118                         body = value
1119                     else:
1120                         attrs.append('%s="%s"' % (key, html.escape(value, True)))
1121             if js.filename:
1122                 attrs.append('src="%s"' % pathto(js.filename, resource=True))
1123         else:
1124             # str value (old styled)
1125             attrs.append('src="%s"' % pathto(js, resource=True))
1126         return '<script %s>%s</script>' % (' '.join(attrs), body)
1127 
1128     context['js_tag'] = js_tag
1129 
1130 
1131 def validate_math_renderer(app: Sphinx) -> None:
1132     if app.builder.format != 'html':
1133         return
1134 
1135     name = app.builder.math_renderer_name  # type: ignore
1136     if name is None:
1137         raise ConfigError(__('Many math_renderers are registered. '
1138                              'But no math_renderer is selected.'))
1139     elif name not in app.registry.html_inline_math_renderers:
1140         raise ConfigError(__('Unknown math_renderer %r is given.') % name)
1141 
1142 
1143 def validate_html_extra_path(app: Sphinx, config: Config) -> None:
1144     """Check html_extra_paths setting."""
1145     for entry in config.html_extra_path[:]:
1146         extra_path = path.normpath(path.join(app.confdir, entry))
1147         if not path.exists(extra_path):
1148             logger.warning(__('html_extra_path entry %r does not exist'), entry)
1149             config.html_extra_path.remove(entry)
1150         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and
1151               path.commonpath([app.outdir, extra_path]) == app.outdir):
1152             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)
1153             config.html_extra_path.remove(entry)
1154 
1155 
1156 def validate_html_static_path(app: Sphinx, config: Config) -> None:
1157     """Check html_static_paths setting."""
1158     for entry in config.html_static_path[:]:
1159         static_path = path.normpath(path.join(app.confdir, entry))
1160         if not path.exists(static_path):
1161             logger.warning(__('html_static_path entry %r does not exist'), entry)
1162             config.html_static_path.remove(entry)
1163         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and
1164               path.commonpath([app.outdir, static_path]) == app.outdir):
1165             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)
1166             config.html_static_path.remove(entry)
1167 
1168 
1169 def validate_html_logo(app: Sphinx, config: Config) -> None:
1170     """Check html_logo setting."""
1171     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):
1172         logger.warning(__('logo file %r does not exist'), config.html_logo)
1173         config.html_logo = None  # type: ignore
1174 
1175 
1176 def validate_html_favicon(app: Sphinx, config: Config) -> None:
1177     """Check html_favicon setting."""
1178     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):
1179         logger.warning(__('favicon file %r does not exist'), config.html_favicon)
1180         config.html_favicon = None  # type: ignore
1181 
1182 
1183 # for compatibility
1184 import sphinx.builders.dirhtml  # NOQA
1185 import sphinx.builders.singlehtml  # NOQA
1186 import sphinxcontrib.serializinghtml  # NOQA
1187 
1188 
1189 def setup(app: Sphinx) -> Dict[str, Any]:
1190     # builders
1191     app.add_builder(StandaloneHTMLBuilder)
1192 
1193     # config values
1194     app.add_config_value('html_theme', 'alabaster', 'html')
1195     app.add_config_value('html_theme_path', [], 'html')
1196     app.add_config_value('html_theme_options', {}, 'html')
1197     app.add_config_value('html_title',
1198                          lambda self: _('%s %s documentation') % (self.project, self.release),
1199                          'html', [str])
1200     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')
1201     app.add_config_value('html_style', None, 'html', [str])
1202     app.add_config_value('html_logo', None, 'html', [str])
1203     app.add_config_value('html_favicon', None, 'html', [str])
1204     app.add_config_value('html_css_files', [], 'html')
1205     app.add_config_value('html_js_files', [], 'html')
1206     app.add_config_value('html_static_path', [], 'html')
1207     app.add_config_value('html_extra_path', [], 'html')
1208     app.add_config_value('html_last_updated_fmt', None, 'html', [str])
1209     app.add_config_value('html_sidebars', {}, 'html')
1210     app.add_config_value('html_additional_pages', {}, 'html')
1211     app.add_config_value('html_domain_indices', True, 'html', [list])
1212     app.add_config_value('html_add_permalinks', '¶', 'html')
1213     app.add_config_value('html_use_index', True, 'html')
1214     app.add_config_value('html_split_index', False, 'html')
1215     app.add_config_value('html_copy_source', True, 'html')
1216     app.add_config_value('html_show_sourcelink', True, 'html')
1217     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')
1218     app.add_config_value('html_use_opensearch', '', 'html')
1219     app.add_config_value('html_file_suffix', None, 'html', [str])
1220     app.add_config_value('html_link_suffix', None, 'html', [str])
1221     app.add_config_value('html_show_copyright', True, 'html')
1222     app.add_config_value('html_show_sphinx', True, 'html')
1223     app.add_config_value('html_context', {}, 'html')
1224     app.add_config_value('html_output_encoding', 'utf-8', 'html')
1225     app.add_config_value('html_compact_lists', True, 'html')
1226     app.add_config_value('html_secnumber_suffix', '. ', 'html')
1227     app.add_config_value('html_search_language', None, 'html', [str])
1228     app.add_config_value('html_search_options', {}, 'html')
1229     app.add_config_value('html_search_scorer', '', None)
1230     app.add_config_value('html_scaled_image_link', True, 'html')
1231     app.add_config_value('html_baseurl', '', 'html')
1232     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',
1233                          ENUM('table', 'inline'))
1234     app.add_config_value('html_math_renderer', None, 'env')
1235     app.add_config_value('html4_writer', False, 'html')
1236 
1237     # event handlers
1238     app.connect('config-inited', convert_html_css_files, priority=800)
1239     app.connect('config-inited', convert_html_js_files, priority=800)
1240     app.connect('config-inited', validate_html_extra_path, priority=800)
1241     app.connect('config-inited', validate_html_static_path, priority=800)
1242     app.connect('config-inited', validate_html_logo, priority=800)
1243     app.connect('config-inited', validate_html_favicon, priority=800)
1244     app.connect('builder-inited', validate_math_renderer)
1245     app.connect('html-page-context', setup_js_tag_helper)
1246 
1247     # load default math renderer
1248     app.setup_extension('sphinx.ext.mathjax')
1249 
1250     # load transforms for HTML builder
1251     app.setup_extension('sphinx.builders.html.transforms')
1252 
1253     return {
1254         'version': 'builtin',
1255         'parallel_read_safe': True,
1256         'parallel_write_safe': True,
1257     }

</code><intended_behavior>In this central file for HTML building, the target would be to ensure the logic that organizes index entries into sections recognizes and groups any entries starting with special characters like '@', '£', and '←' into one "Symbols" section to prevent duplication. This might require adding specific checks or logic to treat these characters uniformly when categorizing index entries.</intended_behavior>]
2025-10-16 00:49:25.942 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:49:25.942 | INFO     | Search-only: skipping patch selection
2025-10-16 00:49:26.029 | INFO     | Task sphinx-doc__sphinx-7975 completed successfully.
2025-10-16 00:49:26.030 | INFO     | No patch generated. You can try running ACR again.
