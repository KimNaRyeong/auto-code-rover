[
    {
        "rel_file_path": "sphinx/writers/html.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/writers/html.py",
        "start": 1,
        "end": 844,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.writers.html\n3     ~~~~~~~~~~~~~~~~~~~\n4 \n5     docutils writers handling Sphinx' custom nodes.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import copy\n12 import os\n13 import posixpath\n14 import re\n15 import warnings\n16 from typing import Any, Iterable, Tuple\n17 from typing import cast\n18 \n19 from docutils import nodes\n20 from docutils.nodes import Element, Node, Text\n21 from docutils.writers.html4css1 import Writer, HTMLTranslator as BaseTranslator\n22 \n23 from sphinx import addnodes\n24 from sphinx.builders import Builder\n25 from sphinx.deprecation import RemovedInSphinx40Warning\n26 from sphinx.locale import admonitionlabels, _, __\n27 from sphinx.util import logging\n28 from sphinx.util.docutils import SphinxTranslator\n29 from sphinx.util.images import get_image_size\n30 \n31 if False:\n32     # For type annotation\n33     from sphinx.builders.html import StandaloneHTMLBuilder\n34 \n35 \n36 logger = logging.getLogger(__name__)\n37 \n38 # A good overview of the purpose behind these classes can be found here:\n39 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html\n40 \n41 \n42 def multiply_length(length: str, scale: int) -> str:\n43     \"\"\"Multiply *length* (width or height) by *scale*.\"\"\"\n44     matched = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', length)\n45     if not matched:\n46         return length\n47     elif scale == 100:\n48         return length\n49     else:\n50         amount, unit = matched.groups()\n51         result = float(amount) * scale / 100\n52         return \"%s%s\" % (int(result), unit)\n53 \n54 \n55 class HTMLWriter(Writer):\n56 \n57     # override embed-stylesheet default value to 0.\n58     settings_spec = copy.deepcopy(Writer.settings_spec)\n59     for _setting in settings_spec[2]:\n60         if '--embed-stylesheet' in _setting[1]:\n61             _setting[2]['default'] = 0\n62 \n63     def __init__(self, builder: \"StandaloneHTMLBuilder\") -> None:\n64         super().__init__()\n65         self.builder = builder\n66 \n67     def translate(self) -> None:\n68         # sadly, this is mostly copied from parent class\n69         visitor = self.builder.create_translator(self.document, self.builder)\n70         self.visitor = cast(HTMLTranslator, visitor)\n71         self.document.walkabout(visitor)\n72         self.output = self.visitor.astext()\n73         for attr in ('head_prefix', 'stylesheet', 'head', 'body_prefix',\n74                      'body_pre_docinfo', 'docinfo', 'body', 'fragment',\n75                      'body_suffix', 'meta', 'title', 'subtitle', 'header',\n76                      'footer', 'html_prolog', 'html_head', 'html_title',\n77                      'html_subtitle', 'html_body', ):\n78             setattr(self, attr, getattr(visitor, attr, None))\n79         self.clean_meta = ''.join(self.visitor.meta[2:])\n80 \n81 \n82 class HTMLTranslator(SphinxTranslator, BaseTranslator):\n83     \"\"\"\n84     Our custom HTML translator.\n85     \"\"\"\n86 \n87     builder = None  # type: StandaloneHTMLBuilder\n88 \n89     def __init__(self, *args: Any) -> None:\n90         if isinstance(args[0], nodes.document) and isinstance(args[1], Builder):\n91             document, builder = args\n92         else:\n93             warnings.warn('The order of arguments for HTMLTranslator has been changed. '\n94                           'Please give \"document\" as 1st and \"builder\" as 2nd.',\n95                           RemovedInSphinx40Warning, stacklevel=2)\n96             builder, document = args\n97         super().__init__(document, builder)\n98 \n99         self.highlighter = self.builder.highlighter\n100         self.docnames = [self.builder.current_docname]  # for singlehtml builder\n101         self.manpages_url = self.config.manpages_url\n102         self.protect_literal_text = 0\n103         self.permalink_text = self.config.html_add_permalinks\n104         # support backwards-compatible setting to a bool\n105         if not isinstance(self.permalink_text, str):\n106             self.permalink_text = '\u00b6' if self.permalink_text else ''\n107         self.permalink_text = self.encode(self.permalink_text)\n108         self.secnumber_suffix = self.config.html_secnumber_suffix\n109         self.param_separator = ''\n110         self.optional_param_level = 0\n111         self._table_row_index = 0\n112         self._fieldlist_row_index = 0\n113         self.required_params_left = 0\n114 \n115     def visit_start_of_file(self, node: Element) -> None:\n116         # only occurs in the single-file builder\n117         self.docnames.append(node['docname'])\n118         self.body.append('<span id=\"document-%s\"></span>' % node['docname'])\n119 \n120     def depart_start_of_file(self, node: Element) -> None:\n121         self.docnames.pop()\n122 \n123     def visit_desc(self, node: Element) -> None:\n124         self.body.append(self.starttag(node, 'dl', CLASS=node['objtype']))\n125 \n126     def depart_desc(self, node: Element) -> None:\n127         self.body.append('</dl>\\n\\n')\n128 \n129     def visit_desc_signature(self, node: Element) -> None:\n130         # the id is set automatically\n131         self.body.append(self.starttag(node, 'dt'))\n132 \n133     def depart_desc_signature(self, node: Element) -> None:\n134         if not node.get('is_multiline'):\n135             self.add_permalink_ref(node, _('Permalink to this definition'))\n136         self.body.append('</dt>\\n')\n137 \n138     def visit_desc_signature_line(self, node: Element) -> None:\n139         pass\n140 \n141     def depart_desc_signature_line(self, node: Element) -> None:\n142         if node.get('add_permalink'):\n143             # the permalink info is on the parent desc_signature node\n144             self.add_permalink_ref(node.parent, _('Permalink to this definition'))\n145         self.body.append('<br />')\n146 \n147     def visit_desc_addname(self, node: Element) -> None:\n148         self.body.append(self.starttag(node, 'code', '', CLASS='descclassname'))\n149 \n150     def depart_desc_addname(self, node: Element) -> None:\n151         self.body.append('</code>')\n152 \n153     def visit_desc_type(self, node: Element) -> None:\n154         pass\n155 \n156     def depart_desc_type(self, node: Element) -> None:\n157         pass\n158 \n159     def visit_desc_returns(self, node: Element) -> None:\n160         self.body.append(' &#x2192; ')\n161 \n162     def depart_desc_returns(self, node: Element) -> None:\n163         pass\n164 \n165     def visit_desc_name(self, node: Element) -> None:\n166         self.body.append(self.starttag(node, 'code', '', CLASS='descname'))\n167 \n168     def depart_desc_name(self, node: Element) -> None:\n169         self.body.append('</code>')\n170 \n171     def visit_desc_parameterlist(self, node: Element) -> None:\n172         self.body.append('<span class=\"sig-paren\">(</span>')\n173         self.first_param = 1\n174         self.optional_param_level = 0\n175         # How many required parameters are left.\n176         self.required_params_left = sum([isinstance(c, addnodes.desc_parameter)\n177                                          for c in node.children])\n178         self.param_separator = node.child_text_separator\n179 \n180     def depart_desc_parameterlist(self, node: Element) -> None:\n181         self.body.append('<span class=\"sig-paren\">)</span>')\n182 \n183     # If required parameters are still to come, then put the comma after\n184     # the parameter.  Otherwise, put the comma before.  This ensures that\n185     # signatures like the following render correctly (see issue #1001):\n186     #\n187     #     foo([a, ]b, c[, d])\n188     #\n189     def visit_desc_parameter(self, node: Element) -> None:\n190         if self.first_param:\n191             self.first_param = 0\n192         elif not self.required_params_left:\n193             self.body.append(self.param_separator)\n194         if self.optional_param_level == 0:\n195             self.required_params_left -= 1\n196         if not node.hasattr('noemph'):\n197             self.body.append('<em>')\n198 \n199     def depart_desc_parameter(self, node: Element) -> None:\n200         if not node.hasattr('noemph'):\n201             self.body.append('</em>')\n202         if self.required_params_left:\n203             self.body.append(self.param_separator)\n204 \n205     def visit_desc_optional(self, node: Element) -> None:\n206         self.optional_param_level += 1\n207         self.body.append('<span class=\"optional\">[</span>')\n208 \n209     def depart_desc_optional(self, node: Element) -> None:\n210         self.optional_param_level -= 1\n211         self.body.append('<span class=\"optional\">]</span>')\n212 \n213     def visit_desc_annotation(self, node: Element) -> None:\n214         self.body.append(self.starttag(node, 'em', '', CLASS='property'))\n215 \n216     def depart_desc_annotation(self, node: Element) -> None:\n217         self.body.append('</em>')\n218 \n219     def visit_desc_content(self, node: Element) -> None:\n220         self.body.append(self.starttag(node, 'dd', ''))\n221 \n222     def depart_desc_content(self, node: Element) -> None:\n223         self.body.append('</dd>')\n224 \n225     def visit_versionmodified(self, node: Element) -> None:\n226         self.body.append(self.starttag(node, 'div', CLASS=node['type']))\n227 \n228     def depart_versionmodified(self, node: Element) -> None:\n229         self.body.append('</div>\\n')\n230 \n231     # overwritten\n232     def visit_reference(self, node: Element) -> None:\n233         atts = {'class': 'reference'}\n234         if node.get('internal') or 'refuri' not in node:\n235             atts['class'] += ' internal'\n236         else:\n237             atts['class'] += ' external'\n238         if 'refuri' in node:\n239             atts['href'] = node['refuri'] or '#'\n240             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):\n241                 atts['href'] = self.cloak_mailto(atts['href'])\n242                 self.in_mailto = True\n243         else:\n244             assert 'refid' in node, \\\n245                    'References must have \"refuri\" or \"refid\" attribute.'\n246             atts['href'] = '#' + node['refid']\n247         if not isinstance(node.parent, nodes.TextElement):\n248             assert len(node) == 1 and isinstance(node[0], nodes.image)\n249             atts['class'] += ' image-reference'\n250         if 'reftitle' in node:\n251             atts['title'] = node['reftitle']\n252         if 'target' in node:\n253             atts['target'] = node['target']\n254         self.body.append(self.starttag(node, 'a', '', **atts))\n255 \n256         if node.get('secnumber'):\n257             self.body.append(('%s' + self.secnumber_suffix) %\n258                              '.'.join(map(str, node['secnumber'])))\n259 \n260     def visit_number_reference(self, node: Element) -> None:\n261         self.visit_reference(node)\n262 \n263     def depart_number_reference(self, node: Element) -> None:\n264         self.depart_reference(node)\n265 \n266     # overwritten -- we don't want source comments to show up in the HTML\n267     def visit_comment(self, node: Element) -> None:  # type: ignore\n268         raise nodes.SkipNode\n269 \n270     # overwritten\n271     def visit_admonition(self, node: Element, name: str = '') -> None:\n272         self.body.append(self.starttag(\n273             node, 'div', CLASS=('admonition ' + name)))\n274         if name:\n275             node.insert(0, nodes.title(name, admonitionlabels[name]))\n276         self.set_first_last(node)\n277 \n278     def visit_seealso(self, node: Element) -> None:\n279         self.visit_admonition(node, 'seealso')\n280 \n281     def depart_seealso(self, node: Element) -> None:\n282         self.depart_admonition(node)\n283 \n284     def get_secnumber(self, node: Element) -> Tuple[int, ...]:\n285         if node.get('secnumber'):\n286             return node['secnumber']\n287         elif isinstance(node.parent, nodes.section):\n288             if self.builder.name == 'singlehtml':\n289                 docname = self.docnames[-1]\n290                 anchorname = \"%s/#%s\" % (docname, node.parent['ids'][0])\n291                 if anchorname not in self.builder.secnumbers:\n292                     anchorname = \"%s/\" % docname  # try first heading which has no anchor\n293             else:\n294                 anchorname = '#' + node.parent['ids'][0]\n295                 if anchorname not in self.builder.secnumbers:\n296                     anchorname = ''  # try first heading which has no anchor\n297 \n298             if self.builder.secnumbers.get(anchorname):\n299                 return self.builder.secnumbers[anchorname]\n300 \n301         return None\n302 \n303     def add_secnumber(self, node: Element) -> None:\n304         secnumber = self.get_secnumber(node)\n305         if secnumber:\n306             self.body.append('<span class=\"section-number\">%s</span>' %\n307                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))\n308 \n309     def add_fignumber(self, node: Element) -> None:\n310         def append_fignumber(figtype: str, figure_id: str) -> None:\n311             if self.builder.name == 'singlehtml':\n312                 key = \"%s/%s\" % (self.docnames[-1], figtype)\n313             else:\n314                 key = figtype\n315 \n316             if figure_id in self.builder.fignumbers.get(key, {}):\n317                 self.body.append('<span class=\"caption-number\">')\n318                 prefix = self.builder.config.numfig_format.get(figtype)\n319                 if prefix is None:\n320                     msg = __('numfig_format is not defined for %s') % figtype\n321                     logger.warning(msg)\n322                 else:\n323                     numbers = self.builder.fignumbers[key][figure_id]\n324                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')\n325                     self.body.append('</span>')\n326 \n327         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)\n328         if figtype:\n329             if len(node['ids']) == 0:\n330                 msg = __('Any IDs not assigned for %s node') % node.tagname\n331                 logger.warning(msg, location=node)\n332             else:\n333                 append_fignumber(figtype, node['ids'][0])\n334 \n335     def add_permalink_ref(self, node: Element, title: str) -> None:\n336         if node['ids'] and self.permalink_text and self.builder.add_permalinks:\n337             format = '<a class=\"headerlink\" href=\"#%s\" title=\"%s\">%s</a>'\n338             self.body.append(format % (node['ids'][0], title, self.permalink_text))\n339 \n340     def generate_targets_for_listing(self, node: Element) -> None:\n341         \"\"\"Generate hyperlink targets for listings.\n342 \n343         Original visit_bullet_list(), visit_definition_list() and visit_enumerated_list()\n344         generates hyperlink targets inside listing tags (<ul>, <ol> and <dl>) if multiple\n345         IDs are assigned to listings.  That is invalid DOM structure.\n346         (This is a bug of docutils <= 0.12)\n347 \n348         This exports hyperlink targets before listings to make valid DOM structure.\n349         \"\"\"\n350         for id in node['ids'][1:]:\n351             self.body.append('<span id=\"%s\"></span>' % id)\n352             node['ids'].remove(id)\n353 \n354     # overwritten\n355     def visit_bullet_list(self, node: Element) -> None:\n356         if len(node) == 1 and isinstance(node[0], addnodes.toctree):\n357             # avoid emitting empty <ul></ul>\n358             raise nodes.SkipNode\n359         self.generate_targets_for_listing(node)\n360         super().visit_bullet_list(node)\n361 \n362     # overwritten\n363     def visit_enumerated_list(self, node: Element) -> None:\n364         self.generate_targets_for_listing(node)\n365         super().visit_enumerated_list(node)\n366 \n367     # overwritten\n368     def visit_definition(self, node: Element) -> None:\n369         # don't insert </dt> here.\n370         self.body.append(self.starttag(node, 'dd', ''))\n371 \n372     # overwritten\n373     def depart_definition(self, node: Element) -> None:\n374         self.body.append('</dd>\\n')\n375 \n376     # overwritten\n377     def visit_classifier(self, node: Element) -> None:\n378         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))\n379 \n380     # overwritten\n381     def depart_classifier(self, node: Element) -> None:\n382         self.body.append('</span>')\n383 \n384         next_node = node.next_node(descend=False, siblings=True)  # type: Node\n385         if not isinstance(next_node, nodes.classifier):\n386             # close `<dt>` tag at the tail of classifiers\n387             self.body.append('</dt>')\n388 \n389     # overwritten\n390     def visit_term(self, node: Element) -> None:\n391         self.body.append(self.starttag(node, 'dt', ''))\n392 \n393     # overwritten\n394     def depart_term(self, node: Element) -> None:\n395         next_node = node.next_node(descend=False, siblings=True)  # type: Node\n396         if isinstance(next_node, nodes.classifier):\n397             # Leave the end tag to `self.depart_classifier()`, in case\n398             # there's a classifier.\n399             pass\n400         else:\n401             self.body.append('</dt>')\n402 \n403     # overwritten\n404     def visit_title(self, node: Element) -> None:\n405         super().visit_title(node)\n406         self.add_secnumber(node)\n407         self.add_fignumber(node.parent)\n408         if isinstance(node.parent, nodes.table):\n409             self.body.append('<span class=\"caption-text\">')\n410 \n411     def depart_title(self, node: Element) -> None:\n412         close_tag = self.context[-1]\n413         if (self.permalink_text and self.builder.add_permalinks and\n414            node.parent.hasattr('ids') and node.parent['ids']):\n415             # add permalink anchor\n416             if close_tag.startswith('</h'):\n417                 self.add_permalink_ref(node.parent, _('Permalink to this headline'))\n418             elif close_tag.startswith('</a></h'):\n419                 self.body.append('</a><a class=\"headerlink\" href=\"#%s\" ' %\n420                                  node.parent['ids'][0] +\n421                                  'title=\"%s\">%s' % (\n422                                      _('Permalink to this headline'),\n423                                      self.permalink_text))\n424             elif isinstance(node.parent, nodes.table):\n425                 self.body.append('</span>')\n426                 self.add_permalink_ref(node.parent, _('Permalink to this table'))\n427         elif isinstance(node.parent, nodes.table):\n428             self.body.append('</span>')\n429 \n430         super().depart_title(node)\n431 \n432     # overwritten\n433     def visit_literal_block(self, node: Element) -> None:\n434         if node.rawsource != node.astext():\n435             # most probably a parsed-literal block -- don't highlight\n436             return super().visit_literal_block(node)\n437 \n438         lang = node.get('language', 'default')\n439         linenos = node.get('linenos', False)\n440         highlight_args = node.get('highlight_args', {})\n441         highlight_args['force'] = node.get('force', False)\n442         if lang is self.builder.config.highlight_language:\n443             # only pass highlighter options for original language\n444             opts = self.builder.config.highlight_options\n445         else:\n446             opts = {}\n447 \n448         if linenos and self.builder.config.html_codeblock_linenos_style:\n449             linenos = self.builder.config.html_codeblock_linenos_style\n450 \n451         highlighted = self.highlighter.highlight_block(\n452             node.rawsource, lang, opts=opts, linenos=linenos,\n453             location=(self.builder.current_docname, node.line), **highlight_args\n454         )\n455         starttag = self.starttag(node, 'div', suffix='',\n456                                  CLASS='highlight-%s notranslate' % lang)\n457         self.body.append(starttag + highlighted + '</div>\\n')\n458         raise nodes.SkipNode\n459 \n460     def visit_caption(self, node: Element) -> None:\n461         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n462             self.body.append('<div class=\"code-block-caption\">')\n463         else:\n464             super().visit_caption(node)\n465         self.add_fignumber(node.parent)\n466         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))\n467 \n468     def depart_caption(self, node: Element) -> None:\n469         self.body.append('</span>')\n470 \n471         # append permalink if available\n472         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n473             self.add_permalink_ref(node.parent, _('Permalink to this code'))\n474         elif isinstance(node.parent, nodes.figure):\n475             self.add_permalink_ref(node.parent, _('Permalink to this image'))\n476         elif node.parent.get('toctree'):\n477             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))\n478 \n479         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n480             self.body.append('</div>\\n')\n481         else:\n482             super().depart_caption(node)\n483 \n484     def visit_doctest_block(self, node: Element) -> None:\n485         self.visit_literal_block(node)\n486 \n487     # overwritten to add the <div> (for XHTML compliance)\n488     def visit_block_quote(self, node: Element) -> None:\n489         self.body.append(self.starttag(node, 'blockquote') + '<div>')\n490 \n491     def depart_block_quote(self, node: Element) -> None:\n492         self.body.append('</div></blockquote>\\n')\n493 \n494     # overwritten\n495     def visit_literal(self, node: Element) -> None:\n496         if 'kbd' in node['classes']:\n497             self.body.append(self.starttag(node, 'kbd', '',\n498                                            CLASS='docutils literal notranslate'))\n499         else:\n500             self.body.append(self.starttag(node, 'code', '',\n501                                            CLASS='docutils literal notranslate'))\n502             self.protect_literal_text += 1\n503 \n504     def depart_literal(self, node: Element) -> None:\n505         if 'kbd' in node['classes']:\n506             self.body.append('</kbd>')\n507         else:\n508             self.protect_literal_text -= 1\n509             self.body.append('</code>')\n510 \n511     def visit_productionlist(self, node: Element) -> None:\n512         self.body.append(self.starttag(node, 'pre'))\n513         names = []\n514         productionlist = cast(Iterable[addnodes.production], node)\n515         for production in productionlist:\n516             names.append(production['tokenname'])\n517         maxlen = max(len(name) for name in names)\n518         lastname = None\n519         for production in productionlist:\n520             if production['tokenname']:\n521                 lastname = production['tokenname'].ljust(maxlen)\n522                 self.body.append(self.starttag(production, 'strong', ''))\n523                 self.body.append(lastname + '</strong> ::= ')\n524             elif lastname is not None:\n525                 self.body.append('%s     ' % (' ' * len(lastname)))\n526             production.walkabout(self)\n527             self.body.append('\\n')\n528         self.body.append('</pre>\\n')\n529         raise nodes.SkipNode\n530 \n531     def depart_productionlist(self, node: Element) -> None:\n532         pass\n533 \n534     def visit_production(self, node: Element) -> None:\n535         pass\n536 \n537     def depart_production(self, node: Element) -> None:\n538         pass\n539 \n540     def visit_centered(self, node: Element) -> None:\n541         self.body.append(self.starttag(node, 'p', CLASS=\"centered\") +\n542                          '<strong>')\n543 \n544     def depart_centered(self, node: Element) -> None:\n545         self.body.append('</strong></p>')\n546 \n547     # overwritten\n548     def should_be_compact_paragraph(self, node: Node) -> bool:\n549         \"\"\"Determine if the <p> tags around paragraph can be omitted.\"\"\"\n550         if isinstance(node.parent, addnodes.desc_content):\n551             # Never compact desc_content items.\n552             return False\n553         if isinstance(node.parent, addnodes.versionmodified):\n554             # Never compact versionmodified nodes.\n555             return False\n556         return super().should_be_compact_paragraph(node)\n557 \n558     def visit_compact_paragraph(self, node: Element) -> None:\n559         pass\n560 \n561     def depart_compact_paragraph(self, node: Element) -> None:\n562         pass\n563 \n564     def visit_download_reference(self, node: Element) -> None:\n565         atts = {'class': 'reference download',\n566                 'download': ''}\n567 \n568         if not self.builder.download_support:\n569             self.context.append('')\n570         elif 'refuri' in node:\n571             atts['class'] += ' external'\n572             atts['href'] = node['refuri']\n573             self.body.append(self.starttag(node, 'a', '', **atts))\n574             self.context.append('</a>')\n575         elif 'filename' in node:\n576             atts['class'] += ' internal'\n577             atts['href'] = posixpath.join(self.builder.dlpath, node['filename'])\n578             self.body.append(self.starttag(node, 'a', '', **atts))\n579             self.context.append('</a>')\n580         else:\n581             self.context.append('')\n582 \n583     def depart_download_reference(self, node: Element) -> None:\n584         self.body.append(self.context.pop())\n585 \n586     # overwritten\n587     def visit_image(self, node: Element) -> None:\n588         olduri = node['uri']\n589         # rewrite the URI if the environment knows about it\n590         if olduri in self.builder.images:\n591             node['uri'] = posixpath.join(self.builder.imgpath,\n592                                          self.builder.images[olduri])\n593 \n594         if 'scale' in node:\n595             # Try to figure out image height and width.  Docutils does that too,\n596             # but it tries the final file name, which does not necessarily exist\n597             # yet at the time the HTML file is written.\n598             if not ('width' in node and 'height' in node):\n599                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))\n600                 if size is None:\n601                     logger.warning(__('Could not obtain image size. :scale: option is ignored.'),  # NOQA\n602                                    location=node)\n603                 else:\n604                     if 'width' not in node:\n605                         node['width'] = str(size[0])\n606                     if 'height' not in node:\n607                         node['height'] = str(size[1])\n608 \n609         uri = node['uri']\n610         if uri.lower().endswith(('svg', 'svgz')):\n611             atts = {'src': uri}\n612             if 'width' in node:\n613                 atts['width'] = node['width']\n614             if 'height' in node:\n615                 atts['height'] = node['height']\n616             if 'scale' in node:\n617                 if 'width' in atts:\n618                     atts['width'] = multiply_length(atts['width'], node['scale'])\n619                 if 'height' in atts:\n620                     atts['height'] = multiply_length(atts['height'], node['scale'])\n621             atts['alt'] = node.get('alt', uri)\n622             if 'align' in node:\n623                 atts['class'] = 'align-%s' % node['align']\n624             self.body.append(self.emptytag(node, 'img', '', **atts))\n625             return\n626 \n627         super().visit_image(node)\n628 \n629     # overwritten\n630     def depart_image(self, node: Element) -> None:\n631         if node['uri'].lower().endswith(('svg', 'svgz')):\n632             pass\n633         else:\n634             super().depart_image(node)\n635 \n636     def visit_toctree(self, node: Element) -> None:\n637         # this only happens when formatting a toc from env.tocs -- in this\n638         # case we don't want to include the subtree\n639         raise nodes.SkipNode\n640 \n641     def visit_index(self, node: Element) -> None:\n642         raise nodes.SkipNode\n643 \n644     def visit_tabular_col_spec(self, node: Element) -> None:\n645         raise nodes.SkipNode\n646 \n647     def visit_glossary(self, node: Element) -> None:\n648         pass\n649 \n650     def depart_glossary(self, node: Element) -> None:\n651         pass\n652 \n653     def visit_acks(self, node: Element) -> None:\n654         pass\n655 \n656     def depart_acks(self, node: Element) -> None:\n657         pass\n658 \n659     def visit_hlist(self, node: Element) -> None:\n660         self.body.append('<table class=\"hlist\"><tr>')\n661 \n662     def depart_hlist(self, node: Element) -> None:\n663         self.body.append('</tr></table>\\n')\n664 \n665     def visit_hlistcol(self, node: Element) -> None:\n666         self.body.append('<td>')\n667 \n668     def depart_hlistcol(self, node: Element) -> None:\n669         self.body.append('</td>')\n670 \n671     def visit_option_group(self, node: Element) -> None:\n672         super().visit_option_group(node)\n673         self.context[-2] = self.context[-2].replace('&nbsp;', '&#160;')\n674 \n675     # overwritten\n676     def visit_Text(self, node: Text) -> None:\n677         text = node.astext()\n678         encoded = self.encode(text)\n679         if self.protect_literal_text:\n680             # moved here from base class's visit_literal to support\n681             # more formatting in literal nodes\n682             for token in self.words_and_spaces.findall(encoded):\n683                 if token.strip():\n684                     # protect literal text from line wrapping\n685                     self.body.append('<span class=\"pre\">%s</span>' % token)\n686                 elif token in ' \\n':\n687                     # allow breaks at whitespace\n688                     self.body.append(token)\n689                 else:\n690                     # protect runs of multiple spaces; the last one can wrap\n691                     self.body.append('&#160;' * (len(token) - 1) + ' ')\n692         else:\n693             if self.in_mailto and self.settings.cloak_email_addresses:\n694                 encoded = self.cloak_email(encoded)\n695             self.body.append(encoded)\n696 \n697     def visit_note(self, node: Element) -> None:\n698         self.visit_admonition(node, 'note')\n699 \n700     def depart_note(self, node: Element) -> None:\n701         self.depart_admonition(node)\n702 \n703     def visit_warning(self, node: Element) -> None:\n704         self.visit_admonition(node, 'warning')\n705 \n706     def depart_warning(self, node: Element) -> None:\n707         self.depart_admonition(node)\n708 \n709     def visit_attention(self, node: Element) -> None:\n710         self.visit_admonition(node, 'attention')\n711 \n712     def depart_attention(self, node: Element) -> None:\n713         self.depart_admonition(node)\n714 \n715     def visit_caution(self, node: Element) -> None:\n716         self.visit_admonition(node, 'caution')\n717 \n718     def depart_caution(self, node: Element) -> None:\n719         self.depart_admonition(node)\n720 \n721     def visit_danger(self, node: Element) -> None:\n722         self.visit_admonition(node, 'danger')\n723 \n724     def depart_danger(self, node: Element) -> None:\n725         self.depart_admonition(node)\n726 \n727     def visit_error(self, node: Element) -> None:\n728         self.visit_admonition(node, 'error')\n729 \n730     def depart_error(self, node: Element) -> None:\n731         self.depart_admonition(node)\n732 \n733     def visit_hint(self, node: Element) -> None:\n734         self.visit_admonition(node, 'hint')\n735 \n736     def depart_hint(self, node: Element) -> None:\n737         self.depart_admonition(node)\n738 \n739     def visit_important(self, node: Element) -> None:\n740         self.visit_admonition(node, 'important')\n741 \n742     def depart_important(self, node: Element) -> None:\n743         self.depart_admonition(node)\n744 \n745     def visit_tip(self, node: Element) -> None:\n746         self.visit_admonition(node, 'tip')\n747 \n748     def depart_tip(self, node: Element) -> None:\n749         self.depart_admonition(node)\n750 \n751     def visit_literal_emphasis(self, node: Element) -> None:\n752         return self.visit_emphasis(node)\n753 \n754     def depart_literal_emphasis(self, node: Element) -> None:\n755         return self.depart_emphasis(node)\n756 \n757     def visit_literal_strong(self, node: Element) -> None:\n758         return self.visit_strong(node)\n759 \n760     def depart_literal_strong(self, node: Element) -> None:\n761         return self.depart_strong(node)\n762 \n763     def visit_abbreviation(self, node: Element) -> None:\n764         attrs = {}\n765         if node.hasattr('explanation'):\n766             attrs['title'] = node['explanation']\n767         self.body.append(self.starttag(node, 'abbr', '', **attrs))\n768 \n769     def depart_abbreviation(self, node: Element) -> None:\n770         self.body.append('</abbr>')\n771 \n772     def visit_manpage(self, node: Element) -> None:\n773         self.visit_literal_emphasis(node)\n774         if self.manpages_url:\n775             node['refuri'] = self.manpages_url.format(**node.attributes)\n776             self.visit_reference(node)\n777 \n778     def depart_manpage(self, node: Element) -> None:\n779         if self.manpages_url:\n780             self.depart_reference(node)\n781         self.depart_literal_emphasis(node)\n782 \n783     # overwritten to add even/odd classes\n784 \n785     def visit_table(self, node: Element) -> None:\n786         self._table_row_index = 0\n787         return super().visit_table(node)\n788 \n789     def visit_row(self, node: Element) -> None:\n790         self._table_row_index += 1\n791         if self._table_row_index % 2 == 0:\n792             node['classes'].append('row-even')\n793         else:\n794             node['classes'].append('row-odd')\n795         self.body.append(self.starttag(node, 'tr', ''))\n796         node.column = 0  # type: ignore\n797 \n798     def visit_entry(self, node: Element) -> None:\n799         super().visit_entry(node)\n800         if self.body[-1] == '&nbsp;':\n801             self.body[-1] = '&#160;'\n802 \n803     def visit_field_list(self, node: Element) -> None:\n804         self._fieldlist_row_index = 0\n805         return super().visit_field_list(node)\n806 \n807     def visit_field(self, node: Element) -> None:\n808         self._fieldlist_row_index += 1\n809         if self._fieldlist_row_index % 2 == 0:\n810             node['classes'].append('field-even')\n811         else:\n812             node['classes'].append('field-odd')\n813         self.body.append(self.starttag(node, 'tr', '', CLASS='field'))\n814 \n815     def visit_field_name(self, node: Element) -> None:\n816         context_count = len(self.context)\n817         super().visit_field_name(node)\n818         if context_count != len(self.context):\n819             self.context[-1] = self.context[-1].replace('&nbsp;', '&#160;')\n820 \n821     def visit_math(self, node: Element, math_env: str = '') -> None:\n822         name = self.builder.math_renderer_name\n823         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]\n824         visit(self, node)\n825 \n826     def depart_math(self, node: Element, math_env: str = '') -> None:\n827         name = self.builder.math_renderer_name\n828         _, depart = self.builder.app.registry.html_inline_math_renderers[name]\n829         if depart:\n830             depart(self, node)\n831 \n832     def visit_math_block(self, node: Element, math_env: str = '') -> None:\n833         name = self.builder.math_renderer_name\n834         visit, _ = self.builder.app.registry.html_block_math_renderers[name]\n835         visit(self, node)\n836 \n837     def depart_math_block(self, node: Element, math_env: str = '') -> None:\n838         name = self.builder.math_renderer_name\n839         _, depart = self.builder.app.registry.html_block_math_renderers[name]\n840         if depart:\n841             depart(self, node)\n842 \n843     def unknown_visit(self, node: Node) -> None:\n844         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)\n",
        "intended_behavior": "This file should contain logic that generates the HTML output for index pages. The intended behavior would be to modify the method responsible for categorizing index entries to ensure that all entries starting with special characters are consolidated under a single \"Symbols\" section. This might involve adjusting how characters are compared or adding a unified category for all such special characters."
    },
    {
        "rel_file_path": "sphinx/builders/html/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/builders/html/__init__.py",
        "start": 1,
        "end": 1257,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.builders.html\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Several HTML builders.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import html\n12 import posixpath\n13 import re\n14 import sys\n15 import warnings\n16 from os import path\n17 from typing import Any, Dict, IO, Iterable, Iterator, List, Set, Tuple\n18 from urllib.parse import quote\n19 \n20 from docutils import nodes\n21 from docutils.core import publish_parts\n22 from docutils.frontend import OptionParser\n23 from docutils.io import DocTreeInput, StringOutput\n24 from docutils.nodes import Node\n25 from docutils.utils import relative_path\n26 \n27 from sphinx import package_dir, __display_version__\n28 from sphinx.application import Sphinx\n29 from sphinx.builders import Builder\n30 from sphinx.config import Config, ENUM\n31 from sphinx.deprecation import RemovedInSphinx40Warning\n32 from sphinx.domains import Domain, Index, IndexEntry\n33 from sphinx.environment.adapters.asset import ImageAdapter\n34 from sphinx.environment.adapters.indexentries import IndexEntries\n35 from sphinx.environment.adapters.toctree import TocTree\n36 from sphinx.errors import ConfigError, ThemeError\n37 from sphinx.highlighting import PygmentsBridge\n38 from sphinx.locale import _, __\n39 from sphinx.search import js_index\n40 from sphinx.theming import HTMLThemeFactory\n41 from sphinx.util import logging, progress_message, status_iterator, md5\n42 from sphinx.util.docutils import is_html5_writer_available, new_document\n43 from sphinx.util.fileutil import copy_asset\n44 from sphinx.util.i18n import format_date\n45 from sphinx.util.inventory import InventoryFile\n46 from sphinx.util.matching import patmatch, Matcher, DOTFILES\n47 from sphinx.util.osutil import os_path, relative_uri, ensuredir, movefile, copyfile\n48 from sphinx.util.tags import Tags\n49 from sphinx.writers.html import HTMLWriter, HTMLTranslator\n50 \n51 if False:\n52     # For type annotation\n53     from typing import Type  # for python3.5.1\n54 \n55 \n56 # HTML5 Writer is available or not\n57 if is_html5_writer_available():\n58     from sphinx.writers.html5 import HTML5Translator\n59     html5_ready = True\n60 else:\n61     html5_ready = False\n62 \n63 #: the filename for the inventory of objects\n64 INVENTORY_FILENAME = 'objects.inv'\n65 \n66 logger = logging.getLogger(__name__)\n67 return_codes_re = re.compile('[\\r\\n]+')\n68 \n69 \n70 def get_stable_hash(obj: Any) -> str:\n71     \"\"\"\n72     Return a stable hash for a Python data structure.  We can't just use\n73     the md5 of str(obj) since for example dictionary items are enumerated\n74     in unpredictable order due to hash randomization in newer Pythons.\n75     \"\"\"\n76     if isinstance(obj, dict):\n77         return get_stable_hash(list(obj.items()))\n78     elif isinstance(obj, (list, tuple)):\n79         obj = sorted(get_stable_hash(o) for o in obj)\n80     return md5(str(obj).encode()).hexdigest()\n81 \n82 \n83 class Stylesheet(str):\n84     \"\"\"A metadata of stylesheet.\n85 \n86     To keep compatibility with old themes, an instance of stylesheet behaves as\n87     its filename (str).\n88     \"\"\"\n89 \n90     attributes = None   # type: Dict[str, str]\n91     filename = None     # type: str\n92 \n93     def __new__(cls, filename: str, *args: str, **attributes: str) -> \"Stylesheet\":\n94         self = str.__new__(cls, filename)  # type: ignore\n95         self.filename = filename\n96         self.attributes = attributes\n97         self.attributes.setdefault('rel', 'stylesheet')\n98         self.attributes.setdefault('type', 'text/css')\n99         if args:  # old style arguments (rel, title)\n100             self.attributes['rel'] = args[0]\n101             self.attributes['title'] = args[1]\n102 \n103         return self\n104 \n105 \n106 class JavaScript(str):\n107     \"\"\"A metadata of javascript file.\n108 \n109     To keep compatibility with old themes, an instance of javascript behaves as\n110     its filename (str).\n111     \"\"\"\n112 \n113     attributes = None   # type: Dict[str, str]\n114     filename = None     # type: str\n115 \n116     def __new__(cls, filename: str, **attributes: str) -> \"JavaScript\":\n117         self = str.__new__(cls, filename)  # type: ignore\n118         self.filename = filename\n119         self.attributes = attributes\n120 \n121         return self\n122 \n123 \n124 class BuildInfo:\n125     \"\"\"buildinfo file manipulator.\n126 \n127     HTMLBuilder and its family are storing their own envdata to ``.buildinfo``.\n128     This class is a manipulator for the file.\n129     \"\"\"\n130 \n131     @classmethod\n132     def load(cls, f: IO) -> \"BuildInfo\":\n133         try:\n134             lines = f.readlines()\n135             assert lines[0].rstrip() == '# Sphinx build info version 1'\n136             assert lines[2].startswith('config: ')\n137             assert lines[3].startswith('tags: ')\n138 \n139             build_info = BuildInfo()\n140             build_info.config_hash = lines[2].split()[1].strip()\n141             build_info.tags_hash = lines[3].split()[1].strip()\n142             return build_info\n143         except Exception as exc:\n144             raise ValueError(__('build info file is broken: %r') % exc) from exc\n145 \n146     def __init__(self, config: Config = None, tags: Tags = None, config_categories: List[str] = []) -> None:  # NOQA\n147         self.config_hash = ''\n148         self.tags_hash = ''\n149 \n150         if config:\n151             values = {c.name: c.value for c in config.filter(config_categories)}\n152             self.config_hash = get_stable_hash(values)\n153 \n154         if tags:\n155             self.tags_hash = get_stable_hash(sorted(tags))\n156 \n157     def __eq__(self, other: \"BuildInfo\") -> bool:  # type: ignore\n158         return (self.config_hash == other.config_hash and\n159                 self.tags_hash == other.tags_hash)\n160 \n161     def dump(self, f: IO) -> None:\n162         f.write('# Sphinx build info version 1\\n'\n163                 '# This file hashes the configuration used when building these files.'\n164                 ' When it is not found, a full rebuild will be done.\\n'\n165                 'config: %s\\n'\n166                 'tags: %s\\n' %\n167                 (self.config_hash, self.tags_hash))\n168 \n169 \n170 class StandaloneHTMLBuilder(Builder):\n171     \"\"\"\n172     Builds standalone HTML docs.\n173     \"\"\"\n174     name = 'html'\n175     format = 'html'\n176     epilog = __('The HTML pages are in %(outdir)s.')\n177 \n178     copysource = True\n179     allow_parallel = True\n180     out_suffix = '.html'\n181     link_suffix = '.html'  # defaults to matching out_suffix\n182     indexer_format = js_index  # type: Any\n183     indexer_dumps_unicode = True\n184     # create links to original images from images [True/False]\n185     html_scaled_image_link = True\n186     supported_image_types = ['image/svg+xml', 'image/png',\n187                              'image/gif', 'image/jpeg']\n188     supported_remote_images = True\n189     supported_data_uri_images = True\n190     searchindex_filename = 'searchindex.js'\n191     add_permalinks = True\n192     allow_sharp_as_current_path = True\n193     embedded = False  # for things like HTML help or Qt help: suppresses sidebar\n194     search = True  # for things like HTML help and Apple help: suppress search\n195     use_index = False\n196     download_support = True  # enable download role\n197 \n198     imgpath = None          # type: str\n199     domain_indices = []     # type: List[Tuple[str, Type[Index], List[Tuple[str, List[IndexEntry]]], bool]]  # NOQA\n200 \n201     def __init__(self, app: Sphinx) -> None:\n202         super().__init__(app)\n203 \n204         # CSS files\n205         self.css_files = []  # type: List[Dict[str, str]]\n206 \n207         # JS files\n208         self.script_files = []  # type: List[JavaScript]\n209 \n210     def init(self) -> None:\n211         self.build_info = self.create_build_info()\n212         # basename of images directory\n213         self.imagedir = '_images'\n214         # section numbers for headings in the currently visited document\n215         self.secnumbers = {}  # type: Dict[str, Tuple[int, ...]]\n216         # currently written docname\n217         self.current_docname = None  # type: str\n218 \n219         self.init_templates()\n220         self.init_highlighter()\n221         self.init_css_files()\n222         self.init_js_files()\n223 \n224         html_file_suffix = self.get_builder_config('file_suffix', 'html')\n225         if html_file_suffix is not None:\n226             self.out_suffix = html_file_suffix\n227 \n228         html_link_suffix = self.get_builder_config('link_suffix', 'html')\n229         if html_link_suffix is not None:\n230             self.link_suffix = html_link_suffix\n231         else:\n232             self.link_suffix = self.out_suffix\n233 \n234         self.use_index = self.get_builder_config('use_index', 'html')\n235 \n236     def create_build_info(self) -> BuildInfo:\n237         return BuildInfo(self.config, self.tags, ['html'])\n238 \n239     def _get_translations_js(self) -> str:\n240         candidates = [path.join(dir, self.config.language,\n241                                 'LC_MESSAGES', 'sphinx.js')\n242                       for dir in self.config.locale_dirs] + \\\n243                      [path.join(package_dir, 'locale', self.config.language,\n244                                 'LC_MESSAGES', 'sphinx.js'),\n245                       path.join(sys.prefix, 'share/sphinx/locale',\n246                                 self.config.language, 'sphinx.js')]\n247 \n248         for jsfile in candidates:\n249             if path.isfile(jsfile):\n250                 return jsfile\n251         return None\n252 \n253     def get_theme_config(self) -> Tuple[str, Dict]:\n254         return self.config.html_theme, self.config.html_theme_options\n255 \n256     def init_templates(self) -> None:\n257         theme_factory = HTMLThemeFactory(self.app)\n258         themename, themeoptions = self.get_theme_config()\n259         self.theme = theme_factory.create(themename)\n260         self.theme_options = themeoptions.copy()\n261         self.create_template_bridge()\n262         self.templates.init(self, self.theme)\n263 \n264     def init_highlighter(self) -> None:\n265         # determine Pygments style and create the highlighter\n266         if self.config.pygments_style is not None:\n267             style = self.config.pygments_style\n268         elif self.theme:\n269             style = self.theme.get_config('theme', 'pygments_style', 'none')\n270         else:\n271             style = 'sphinx'\n272         self.highlighter = PygmentsBridge('html', style)\n273 \n274         if self.theme:\n275             dark_style = self.theme.get_config('theme', 'pygments_dark_style', None)\n276         else:\n277             dark_style = None\n278 \n279         if dark_style is not None:\n280             self.dark_highlighter = PygmentsBridge('html', dark_style)\n281             self.add_css_file('pygments_dark.css',\n282                               media='(prefers-color-scheme: dark)',\n283                               id='pygments_dark_css')\n284         else:\n285             self.dark_highlighter = None\n286 \n287     def init_css_files(self) -> None:\n288         for filename, attrs in self.app.registry.css_files:\n289             self.add_css_file(filename, **attrs)\n290 \n291         for filename, attrs in self.get_builder_config('css_files', 'html'):\n292             self.add_css_file(filename, **attrs)\n293 \n294     def add_css_file(self, filename: str, **kwargs: str) -> None:\n295         if '://' not in filename:\n296             filename = posixpath.join('_static', filename)\n297 \n298         self.css_files.append(Stylesheet(filename, **kwargs))  # type: ignore\n299 \n300     def init_js_files(self) -> None:\n301         self.add_js_file('jquery.js')\n302         self.add_js_file('underscore.js')\n303         self.add_js_file('doctools.js')\n304         self.add_js_file('language_data.js')\n305 \n306         for filename, attrs in self.app.registry.js_files:\n307             self.add_js_file(filename, **attrs)\n308 \n309         for filename, attrs in self.get_builder_config('js_files', 'html'):\n310             self.add_js_file(filename, **attrs)\n311 \n312         if self.config.language and self._get_translations_js():\n313             self.add_js_file('translations.js')\n314 \n315     def add_js_file(self, filename: str, **kwargs: str) -> None:\n316         if filename and '://' not in filename:\n317             filename = posixpath.join('_static', filename)\n318 \n319         self.script_files.append(JavaScript(filename, **kwargs))\n320 \n321     @property\n322     def default_translator_class(self) -> \"Type[nodes.NodeVisitor]\":  # type: ignore\n323         if not html5_ready or self.config.html4_writer:\n324             return HTMLTranslator\n325         else:\n326             return HTML5Translator\n327 \n328     @property\n329     def math_renderer_name(self) -> str:\n330         name = self.get_builder_config('math_renderer', 'html')\n331         if name is not None:\n332             # use given name\n333             return name\n334         else:\n335             # not given: choose a math_renderer from registered ones as possible\n336             renderers = list(self.app.registry.html_inline_math_renderers)\n337             if len(renderers) == 1:\n338                 # only default math_renderer (mathjax) is registered\n339                 return renderers[0]\n340             elif len(renderers) == 2:\n341                 # default and another math_renderer are registered; prior the another\n342                 renderers.remove('mathjax')\n343                 return renderers[0]\n344             else:\n345                 # many math_renderers are registered. can't choose automatically!\n346                 return None\n347 \n348     def get_outdated_docs(self) -> Iterator[str]:\n349         try:\n350             with open(path.join(self.outdir, '.buildinfo')) as fp:\n351                 buildinfo = BuildInfo.load(fp)\n352 \n353             if self.build_info != buildinfo:\n354                 yield from self.env.found_docs\n355                 return\n356         except ValueError as exc:\n357             logger.warning(__('Failed to read build info file: %r'), exc)\n358         except OSError:\n359             # ignore errors on reading\n360             pass\n361 \n362         if self.templates:\n363             template_mtime = self.templates.newest_template_mtime()\n364         else:\n365             template_mtime = 0\n366         for docname in self.env.found_docs:\n367             if docname not in self.env.all_docs:\n368                 yield docname\n369                 continue\n370             targetname = self.get_outfilename(docname)\n371             try:\n372                 targetmtime = path.getmtime(targetname)\n373             except Exception:\n374                 targetmtime = 0\n375             try:\n376                 srcmtime = max(path.getmtime(self.env.doc2path(docname)),\n377                                template_mtime)\n378                 if srcmtime > targetmtime:\n379                     yield docname\n380             except OSError:\n381                 # source doesn't exist anymore\n382                 pass\n383 \n384     def get_asset_paths(self) -> List[str]:\n385         return self.config.html_extra_path + self.config.html_static_path\n386 \n387     def render_partial(self, node: Node) -> Dict[str, str]:\n388         \"\"\"Utility: Render a lone doctree node.\"\"\"\n389         if node is None:\n390             return {'fragment': ''}\n391         doc = new_document('<partial node>')\n392         doc.append(node)\n393 \n394         writer = HTMLWriter(self)\n395         return publish_parts(reader_name='doctree',\n396                              writer=writer,\n397                              source_class=DocTreeInput,\n398                              settings_overrides={'output_encoding': 'unicode'},\n399                              source=doc)\n400 \n401     def prepare_writing(self, docnames: Set[str]) -> None:\n402         # create the search indexer\n403         self.indexer = None\n404         if self.search:\n405             from sphinx.search import IndexBuilder\n406             lang = self.config.html_search_language or self.config.language\n407             if not lang:\n408                 lang = 'en'\n409             self.indexer = IndexBuilder(self.env, lang,\n410                                         self.config.html_search_options,\n411                                         self.config.html_search_scorer)\n412             self.load_indexer(docnames)\n413 \n414         self.docwriter = HTMLWriter(self)\n415         self.docsettings = OptionParser(\n416             defaults=self.env.settings,\n417             components=(self.docwriter,),\n418             read_config_files=True).get_default_values()  # type: Any\n419         self.docsettings.compact_lists = bool(self.config.html_compact_lists)\n420 \n421         # determine the additional indices to include\n422         self.domain_indices = []\n423         # html_domain_indices can be False/True or a list of index names\n424         indices_config = self.config.html_domain_indices\n425         if indices_config:\n426             for domain_name in sorted(self.env.domains):\n427                 domain = None  # type: Domain\n428                 domain = self.env.domains[domain_name]\n429                 for indexcls in domain.indices:\n430                     indexname = '%s-%s' % (domain.name, indexcls.name)\n431                     if isinstance(indices_config, list):\n432                         if indexname not in indices_config:\n433                             continue\n434                     content, collapse = indexcls(domain).generate()\n435                     if content:\n436                         self.domain_indices.append(\n437                             (indexname, indexcls, content, collapse))\n438 \n439         # format the \"last updated on\" string, only once is enough since it\n440         # typically doesn't include the time of day\n441         lufmt = self.config.html_last_updated_fmt\n442         if lufmt is not None:\n443             self.last_updated = format_date(lufmt or _('%b %d, %Y'),\n444                                             language=self.config.language)\n445         else:\n446             self.last_updated = None\n447 \n448         logo = path.basename(self.config.html_logo) if self.config.html_logo else ''\n449         favicon = path.basename(self.config.html_favicon) if self.config.html_favicon else ''\n450 \n451         if not isinstance(self.config.html_use_opensearch, str):\n452             logger.warning(__('html_use_opensearch config value must now be a string'))\n453 \n454         self.relations = self.env.collect_relations()\n455 \n456         rellinks = []  # type: List[Tuple[str, str, str, str]]\n457         if self.use_index:\n458             rellinks.append(('genindex', _('General Index'), 'I', _('index')))\n459         for indexname, indexcls, content, collapse in self.domain_indices:\n460             # if it has a short name\n461             if indexcls.shortname:\n462                 rellinks.append((indexname, indexcls.localname,\n463                                  '', indexcls.shortname))\n464 \n465         if self.config.html_style is not None:\n466             stylename = self.config.html_style\n467         elif self.theme:\n468             stylename = self.theme.get_config('theme', 'stylesheet')\n469         else:\n470             stylename = 'default.css'\n471 \n472         self.globalcontext = {\n473             'embedded': self.embedded,\n474             'project': self.config.project,\n475             'release': return_codes_re.sub('', self.config.release),\n476             'version': self.config.version,\n477             'last_updated': self.last_updated,\n478             'copyright': self.config.copyright,\n479             'master_doc': self.config.master_doc,\n480             'use_opensearch': self.config.html_use_opensearch,\n481             'docstitle': self.config.html_title,\n482             'shorttitle': self.config.html_short_title,\n483             'show_copyright': self.config.html_show_copyright,\n484             'show_sphinx': self.config.html_show_sphinx,\n485             'has_source': self.config.html_copy_source,\n486             'show_source': self.config.html_show_sourcelink,\n487             'sourcelink_suffix': self.config.html_sourcelink_suffix,\n488             'file_suffix': self.out_suffix,\n489             'link_suffix': self.link_suffix,\n490             'script_files': self.script_files,\n491             'language': self.config.language,\n492             'css_files': self.css_files,\n493             'sphinx_version': __display_version__,\n494             'style': stylename,\n495             'rellinks': rellinks,\n496             'builder': self.name,\n497             'parents': [],\n498             'logo': logo,\n499             'favicon': favicon,\n500             'html5_doctype': html5_ready and not self.config.html4_writer,\n501         }\n502         if self.theme:\n503             self.globalcontext.update(\n504                 ('theme_' + key, val) for (key, val) in\n505                 self.theme.get_options(self.theme_options).items())\n506         self.globalcontext.update(self.config.html_context)\n507 \n508     def get_doc_context(self, docname: str, body: str, metatags: str) -> Dict[str, Any]:\n509         \"\"\"Collect items for the template context of a page.\"\"\"\n510         # find out relations\n511         prev = next = None\n512         parents = []\n513         rellinks = self.globalcontext['rellinks'][:]\n514         related = self.relations.get(docname)\n515         titles = self.env.titles\n516         if related and related[2]:\n517             try:\n518                 next = {\n519                     'link': self.get_relative_uri(docname, related[2]),\n520                     'title': self.render_partial(titles[related[2]])['title']\n521                 }\n522                 rellinks.append((related[2], next['title'], 'N', _('next')))\n523             except KeyError:\n524                 next = None\n525         if related and related[1]:\n526             try:\n527                 prev = {\n528                     'link': self.get_relative_uri(docname, related[1]),\n529                     'title': self.render_partial(titles[related[1]])['title']\n530                 }\n531                 rellinks.append((related[1], prev['title'], 'P', _('previous')))\n532             except KeyError:\n533                 # the relation is (somehow) not in the TOC tree, handle\n534                 # that gracefully\n535                 prev = None\n536         while related and related[0]:\n537             try:\n538                 parents.append(\n539                     {'link': self.get_relative_uri(docname, related[0]),\n540                      'title': self.render_partial(titles[related[0]])['title']})\n541             except KeyError:\n542                 pass\n543             related = self.relations.get(related[0])\n544         if parents:\n545             # remove link to the master file; we have a generic\n546             # \"back to index\" link already\n547             parents.pop()\n548         parents.reverse()\n549 \n550         # title rendered as HTML\n551         title_node = self.env.longtitles.get(docname)\n552         title = self.render_partial(title_node)['title'] if title_node else ''\n553 \n554         # Suffix for the document\n555         source_suffix = self.env.doc2path(docname, False)[len(docname):]\n556 \n557         # the name for the copied source\n558         if self.config.html_copy_source:\n559             sourcename = docname + source_suffix\n560             if source_suffix != self.config.html_sourcelink_suffix:\n561                 sourcename += self.config.html_sourcelink_suffix\n562         else:\n563             sourcename = ''\n564 \n565         # metadata for the document\n566         meta = self.env.metadata.get(docname)\n567 \n568         # local TOC and global TOC tree\n569         self_toc = TocTree(self.env).get_toc_for(docname, self)\n570         toc = self.render_partial(self_toc)['fragment']\n571 \n572         return {\n573             'parents': parents,\n574             'prev': prev,\n575             'next': next,\n576             'title': title,\n577             'meta': meta,\n578             'body': body,\n579             'metatags': metatags,\n580             'rellinks': rellinks,\n581             'sourcename': sourcename,\n582             'toc': toc,\n583             # only display a TOC if there's more than one item to show\n584             'display_toc': (self.env.toc_num_entries[docname] > 1),\n585             'page_source_suffix': source_suffix,\n586         }\n587 \n588     def write_doc(self, docname: str, doctree: nodes.document) -> None:\n589         destination = StringOutput(encoding='utf-8')\n590         doctree.settings = self.docsettings\n591 \n592         self.secnumbers = self.env.toc_secnumbers.get(docname, {})\n593         self.fignumbers = self.env.toc_fignumbers.get(docname, {})\n594         self.imgpath = relative_uri(self.get_target_uri(docname), '_images')\n595         self.dlpath = relative_uri(self.get_target_uri(docname), '_downloads')\n596         self.current_docname = docname\n597         self.docwriter.write(doctree, destination)\n598         self.docwriter.assemble_parts()\n599         body = self.docwriter.parts['fragment']\n600         metatags = self.docwriter.clean_meta\n601 \n602         ctx = self.get_doc_context(docname, body, metatags)\n603         self.handle_page(docname, ctx, event_arg=doctree)\n604 \n605     def write_doc_serialized(self, docname: str, doctree: nodes.document) -> None:\n606         self.imgpath = relative_uri(self.get_target_uri(docname), self.imagedir)\n607         self.post_process_images(doctree)\n608         title_node = self.env.longtitles.get(docname)\n609         title = self.render_partial(title_node)['title'] if title_node else ''\n610         self.index_page(docname, doctree, title)\n611 \n612     def finish(self) -> None:\n613         self.finish_tasks.add_task(self.gen_indices)\n614         self.finish_tasks.add_task(self.gen_pages_from_extensions)\n615         self.finish_tasks.add_task(self.gen_additional_pages)\n616         self.finish_tasks.add_task(self.copy_image_files)\n617         self.finish_tasks.add_task(self.copy_download_files)\n618         self.finish_tasks.add_task(self.copy_static_files)\n619         self.finish_tasks.add_task(self.copy_extra_files)\n620         self.finish_tasks.add_task(self.write_buildinfo)\n621 \n622         # dump the search index\n623         self.handle_finish()\n624 \n625     @progress_message(__('generating indices'))\n626     def gen_indices(self) -> None:\n627         # the global general index\n628         if self.use_index:\n629             self.write_genindex()\n630 \n631         # the global domain-specific indices\n632         self.write_domain_indices()\n633 \n634     def gen_pages_from_extensions(self) -> None:\n635         # pages from extensions\n636         for pagelist in self.events.emit('html-collect-pages'):\n637             for pagename, context, template in pagelist:\n638                 self.handle_page(pagename, context, template)\n639 \n640     @progress_message(__('writing additional pages'))\n641     def gen_additional_pages(self) -> None:\n642         # additional pages from conf.py\n643         for pagename, template in self.config.html_additional_pages.items():\n644             logger.info(' ' + pagename, nonl=True)\n645             self.handle_page(pagename, {}, template)\n646 \n647         # the search page\n648         if self.search:\n649             logger.info(' search', nonl=True)\n650             self.handle_page('search', {}, 'search.html')\n651 \n652         # the opensearch xml file\n653         if self.config.html_use_opensearch and self.search:\n654             logger.info(' opensearch', nonl=True)\n655             fn = path.join(self.outdir, '_static', 'opensearch.xml')\n656             self.handle_page('opensearch', {}, 'opensearch.xml', outfilename=fn)\n657 \n658     def write_genindex(self) -> None:\n659         # the total count of lines for each index letter, used to distribute\n660         # the entries into two columns\n661         genindex = IndexEntries(self.env).create_index(self)\n662         indexcounts = []\n663         for _k, entries in genindex:\n664             indexcounts.append(sum(1 + len(subitems)\n665                                    for _, (_, subitems, _) in entries))\n666 \n667         genindexcontext = {\n668             'genindexentries': genindex,\n669             'genindexcounts': indexcounts,\n670             'split_index': self.config.html_split_index,\n671         }\n672         logger.info(' genindex', nonl=True)\n673 \n674         if self.config.html_split_index:\n675             self.handle_page('genindex', genindexcontext,\n676                              'genindex-split.html')\n677             self.handle_page('genindex-all', genindexcontext,\n678                              'genindex.html')\n679             for (key, entries), count in zip(genindex, indexcounts):\n680                 ctx = {'key': key, 'entries': entries, 'count': count,\n681                        'genindexentries': genindex}\n682                 self.handle_page('genindex-' + key, ctx,\n683                                  'genindex-single.html')\n684         else:\n685             self.handle_page('genindex', genindexcontext, 'genindex.html')\n686 \n687     def write_domain_indices(self) -> None:\n688         for indexname, indexcls, content, collapse in self.domain_indices:\n689             indexcontext = {\n690                 'indextitle': indexcls.localname,\n691                 'content': content,\n692                 'collapse_index': collapse,\n693             }\n694             logger.info(' ' + indexname, nonl=True)\n695             self.handle_page(indexname, indexcontext, 'domainindex.html')\n696 \n697     def copy_image_files(self) -> None:\n698         if self.images:\n699             stringify_func = ImageAdapter(self.app.env).get_original_image_uri\n700             ensuredir(path.join(self.outdir, self.imagedir))\n701             for src in status_iterator(self.images, __('copying images... '), \"brown\",\n702                                        len(self.images), self.app.verbosity,\n703                                        stringify_func=stringify_func):\n704                 dest = self.images[src]\n705                 try:\n706                     copyfile(path.join(self.srcdir, src),\n707                              path.join(self.outdir, self.imagedir, dest))\n708                 except Exception as err:\n709                     logger.warning(__('cannot copy image file %r: %s'),\n710                                    path.join(self.srcdir, src), err)\n711 \n712     def copy_download_files(self) -> None:\n713         def to_relpath(f: str) -> str:\n714             return relative_path(self.srcdir, f)\n715 \n716         # copy downloadable files\n717         if self.env.dlfiles:\n718             ensuredir(path.join(self.outdir, '_downloads'))\n719             for src in status_iterator(self.env.dlfiles, __('copying downloadable files... '),\n720                                        \"brown\", len(self.env.dlfiles), self.app.verbosity,\n721                                        stringify_func=to_relpath):\n722                 try:\n723                     dest = path.join(self.outdir, '_downloads', self.env.dlfiles[src][1])\n724                     ensuredir(path.dirname(dest))\n725                     copyfile(path.join(self.srcdir, src), dest)\n726                 except OSError as err:\n727                     logger.warning(__('cannot copy downloadable file %r: %s'),\n728                                    path.join(self.srcdir, src), err)\n729 \n730     def create_pygments_style_file(self) -> None:\n731         \"\"\"create a style file for pygments.\"\"\"\n732         with open(path.join(self.outdir, '_static', 'pygments.css'), 'w') as f:\n733             f.write(self.highlighter.get_stylesheet())\n734 \n735         if self.dark_highlighter:\n736             with open(path.join(self.outdir, '_static', 'pygments_dark.css'), 'w') as f:\n737                 f.write(self.dark_highlighter.get_stylesheet())\n738 \n739     def copy_translation_js(self) -> None:\n740         \"\"\"Copy a JavaScript file for translations.\"\"\"\n741         if self.config.language is not None:\n742             jsfile = self._get_translations_js()\n743             if jsfile:\n744                 copyfile(jsfile, path.join(self.outdir, '_static', 'translations.js'))\n745 \n746     def copy_stemmer_js(self) -> None:\n747         \"\"\"Copy a JavaScript file for stemmer.\"\"\"\n748         if self.indexer is not None:\n749             jsfile = self.indexer.get_js_stemmer_rawcode()\n750             if jsfile:\n751                 copyfile(jsfile, path.join(self.outdir, '_static', '_stemmer.js'))\n752 \n753     def copy_theme_static_files(self, context: Dict) -> None:\n754         if self.theme:\n755             for entry in self.theme.get_theme_dirs()[::-1]:\n756                 copy_asset(path.join(entry, 'static'),\n757                            path.join(self.outdir, '_static'),\n758                            excluded=DOTFILES, context=context, renderer=self.templates)\n759 \n760     def copy_html_static_files(self, context: Dict) -> None:\n761         excluded = Matcher(self.config.exclude_patterns + [\"**/.*\"])\n762         for entry in self.config.html_static_path:\n763             copy_asset(path.join(self.confdir, entry),\n764                        path.join(self.outdir, '_static'),\n765                        excluded, context=context, renderer=self.templates)\n766 \n767     def copy_html_logo(self) -> None:\n768         if self.config.html_logo:\n769             copy_asset(path.join(self.confdir, self.config.html_logo),\n770                        path.join(self.outdir, '_static'))\n771 \n772     def copy_html_favicon(self) -> None:\n773         if self.config.html_favicon:\n774             copy_asset(path.join(self.confdir, self.config.html_favicon),\n775                        path.join(self.outdir, '_static'))\n776 \n777     def copy_static_files(self) -> None:\n778         try:\n779             with progress_message(__('copying static files... ')):\n780                 ensuredir(path.join(self.outdir, '_static'))\n781 \n782                 # prepare context for templates\n783                 context = self.globalcontext.copy()\n784                 if self.indexer is not None:\n785                     context.update(self.indexer.context_for_searchtool())\n786 \n787                 self.create_pygments_style_file()\n788                 self.copy_translation_js()\n789                 self.copy_stemmer_js()\n790                 self.copy_theme_static_files(context)\n791                 self.copy_html_static_files(context)\n792                 self.copy_html_logo()\n793                 self.copy_html_favicon()\n794         except OSError as err:\n795             logger.warning(__('cannot copy static file %r'), err)\n796 \n797     def copy_extra_files(self) -> None:\n798         \"\"\"copy html_extra_path files.\"\"\"\n799         try:\n800             with progress_message(__('copying extra files')):\n801                 excluded = Matcher(self.config.exclude_patterns)\n802                 for extra_path in self.config.html_extra_path:\n803                     entry = path.join(self.confdir, extra_path)\n804                     copy_asset(entry, self.outdir, excluded)\n805         except OSError as err:\n806             logger.warning(__('cannot copy extra file %r'), err)\n807 \n808     def write_buildinfo(self) -> None:\n809         try:\n810             with open(path.join(self.outdir, '.buildinfo'), 'w') as fp:\n811                 self.build_info.dump(fp)\n812         except OSError as exc:\n813             logger.warning(__('Failed to write build info file: %r'), exc)\n814 \n815     def cleanup(self) -> None:\n816         # clean up theme stuff\n817         if self.theme:\n818             self.theme.cleanup()\n819 \n820     def post_process_images(self, doctree: Node) -> None:\n821         \"\"\"Pick the best candidate for an image and link down-scaled images to\n822         their high res version.\n823         \"\"\"\n824         Builder.post_process_images(self, doctree)\n825 \n826         if self.config.html_scaled_image_link and self.html_scaled_image_link:\n827             for node in doctree.traverse(nodes.image):\n828                 if not any((key in node) for key in ['scale', 'width', 'height']):\n829                     # resizing options are not given. scaled image link is available\n830                     # only for resized images.\n831                     continue\n832                 elif isinstance(node.parent, nodes.reference):\n833                     # A image having hyperlink target\n834                     continue\n835                 elif 'no-scaled-link' in node['classes']:\n836                     # scaled image link is disabled for this node\n837                     continue\n838 \n839                 uri = node['uri']\n840                 reference = nodes.reference('', '', internal=True)\n841                 if uri in self.images:\n842                     reference['refuri'] = posixpath.join(self.imgpath,\n843                                                          self.images[uri])\n844                 else:\n845                     reference['refuri'] = uri\n846                 node.replace_self(reference)\n847                 reference.append(node)\n848 \n849     def load_indexer(self, docnames: Iterable[str]) -> None:\n850         keep = set(self.env.all_docs) - set(docnames)\n851         try:\n852             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n853             if self.indexer_dumps_unicode:\n854                 with open(searchindexfn, encoding='utf-8') as ft:\n855                     self.indexer.load(ft, self.indexer_format)\n856             else:\n857                 with open(searchindexfn, 'rb') as fb:\n858                     self.indexer.load(fb, self.indexer_format)\n859         except (OSError, ValueError):\n860             if keep:\n861                 logger.warning(__('search index couldn\\'t be loaded, but not all '\n862                                   'documents will be built: the index will be '\n863                                   'incomplete.'))\n864         # delete all entries for files that will be rebuilt\n865         self.indexer.prune(keep)\n866 \n867     def index_page(self, pagename: str, doctree: nodes.document, title: str) -> None:\n868         # only index pages with title\n869         if self.indexer is not None and title:\n870             filename = self.env.doc2path(pagename, base=None)\n871             try:\n872                 metadata = self.env.metadata.get(pagename, {})\n873                 if 'nosearch' in metadata:\n874                     self.indexer.feed(pagename, filename, '', new_document(''))\n875                 else:\n876                     self.indexer.feed(pagename, filename, title, doctree)\n877             except TypeError:\n878                 # fallback for old search-adapters\n879                 self.indexer.feed(pagename, title, doctree)  # type: ignore\n880                 indexer_name = self.indexer.__class__.__name__\n881                 warnings.warn(\n882                     'The %s.feed() method signature is deprecated. Update to '\n883                     '%s.feed(docname, filename, title, doctree).' % (\n884                         indexer_name, indexer_name),\n885                     RemovedInSphinx40Warning, stacklevel=2)\n886 \n887     def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -> str:\n888         if 'includehidden' not in kwargs:\n889             kwargs['includehidden'] = False\n890         if kwargs.get('maxdepth') == '':\n891             kwargs.pop('maxdepth')\n892         return self.render_partial(TocTree(self.env).get_toctree_for(\n893             docname, self, collapse, **kwargs))['fragment']\n894 \n895     def get_outfilename(self, pagename: str) -> str:\n896         return path.join(self.outdir, os_path(pagename) + self.out_suffix)\n897 \n898     def add_sidebars(self, pagename: str, ctx: Dict) -> None:\n899         def has_wildcard(pattern: str) -> bool:\n900             return any(char in pattern for char in '*?[')\n901 \n902         sidebars = None\n903         matched = None\n904         customsidebar = None\n905 \n906         # default sidebars settings for selected theme\n907         if self.theme.name == 'alabaster':\n908             # provide default settings for alabaster (for compatibility)\n909             # Note: this will be removed before Sphinx-2.0\n910             try:\n911                 # get default sidebars settings from alabaster (if defined)\n912                 theme_default_sidebars = self.theme.config.get('theme', 'sidebars')\n913                 if theme_default_sidebars:\n914                     sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n915             except Exception:\n916                 # fallback to better default settings\n917                 sidebars = ['about.html', 'navigation.html', 'relations.html',\n918                             'searchbox.html', 'donate.html']\n919         else:\n920             theme_default_sidebars = self.theme.get_config('theme', 'sidebars', None)\n921             if theme_default_sidebars:\n922                 sidebars = [name.strip() for name in theme_default_sidebars.split(',')]\n923 \n924         # user sidebar settings\n925         html_sidebars = self.get_builder_config('sidebars', 'html')\n926         for pattern, patsidebars in html_sidebars.items():\n927             if patmatch(pagename, pattern):\n928                 if matched:\n929                     if has_wildcard(pattern):\n930                         # warn if both patterns contain wildcards\n931                         if has_wildcard(matched):\n932                             logger.warning(__('page %s matches two patterns in '\n933                                               'html_sidebars: %r and %r'),\n934                                            pagename, matched, pattern)\n935                         # else the already matched pattern is more specific\n936                         # than the present one, because it contains no wildcard\n937                         continue\n938                 matched = pattern\n939                 sidebars = patsidebars\n940 \n941         if sidebars is None:\n942             # keep defaults\n943             pass\n944 \n945         ctx['sidebars'] = sidebars\n946         ctx['customsidebar'] = customsidebar\n947 \n948     # --------- these are overwritten by the serialization builder\n949 \n950     def get_target_uri(self, docname: str, typ: str = None) -> str:\n951         return quote(docname) + self.link_suffix\n952 \n953     def handle_page(self, pagename: str, addctx: Dict, templatename: str = 'page.html',\n954                     outfilename: str = None, event_arg: Any = None) -> None:\n955         ctx = self.globalcontext.copy()\n956         # current_page_name is backwards compatibility\n957         ctx['pagename'] = ctx['current_page_name'] = pagename\n958         ctx['encoding'] = self.config.html_output_encoding\n959         default_baseuri = self.get_target_uri(pagename)\n960         # in the singlehtml builder, default_baseuri still contains an #anchor\n961         # part, which relative_uri doesn't really like...\n962         default_baseuri = default_baseuri.rsplit('#', 1)[0]\n963 \n964         if self.config.html_baseurl:\n965             ctx['pageurl'] = posixpath.join(self.config.html_baseurl,\n966                                             pagename + self.out_suffix)\n967         else:\n968             ctx['pageurl'] = None\n969 \n970         def pathto(otheruri: str, resource: bool = False, baseuri: str = default_baseuri) -> str:  # NOQA\n971             if resource and '://' in otheruri:\n972                 # allow non-local resources given by scheme\n973                 return otheruri\n974             elif not resource:\n975                 otheruri = self.get_target_uri(otheruri)\n976             uri = relative_uri(baseuri, otheruri) or '#'\n977             if uri == '#' and not self.allow_sharp_as_current_path:\n978                 uri = baseuri\n979             return uri\n980         ctx['pathto'] = pathto\n981 \n982         def css_tag(css: Stylesheet) -> str:\n983             attrs = []\n984             for key in sorted(css.attributes):\n985                 value = css.attributes[key]\n986                 if value is not None:\n987                     attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n988             attrs.append('href=\"%s\"' % pathto(css.filename, resource=True))\n989             return '<link %s />' % ' '.join(attrs)\n990         ctx['css_tag'] = css_tag\n991 \n992         def hasdoc(name: str) -> bool:\n993             if name in self.env.all_docs:\n994                 return True\n995             elif name == 'search' and self.search:\n996                 return True\n997             elif name == 'genindex' and self.get_builder_config('use_index', 'html'):\n998                 return True\n999             return False\n1000         ctx['hasdoc'] = hasdoc\n1001 \n1002         ctx['toctree'] = lambda **kwargs: self._get_local_toctree(pagename, **kwargs)\n1003         self.add_sidebars(pagename, ctx)\n1004         ctx.update(addctx)\n1005 \n1006         self.update_page_context(pagename, templatename, ctx, event_arg)\n1007         newtmpl = self.app.emit_firstresult('html-page-context', pagename,\n1008                                             templatename, ctx, event_arg)\n1009         if newtmpl:\n1010             templatename = newtmpl\n1011 \n1012         try:\n1013             output = self.templates.render(templatename, ctx)\n1014         except UnicodeError:\n1015             logger.warning(__(\"a Unicode error occurred when rendering the page %s. \"\n1016                               \"Please make sure all config values that contain \"\n1017                               \"non-ASCII content are Unicode strings.\"), pagename)\n1018             return\n1019         except Exception as exc:\n1020             raise ThemeError(__(\"An error happened in rendering the page %s.\\nReason: %r\") %\n1021                              (pagename, exc)) from exc\n1022 \n1023         if not outfilename:\n1024             outfilename = self.get_outfilename(pagename)\n1025         # outfilename's path is in general different from self.outdir\n1026         ensuredir(path.dirname(outfilename))\n1027         try:\n1028             with open(outfilename, 'w', encoding=ctx['encoding'],\n1029                       errors='xmlcharrefreplace') as f:\n1030                 f.write(output)\n1031         except OSError as err:\n1032             logger.warning(__(\"error writing file %s: %s\"), outfilename, err)\n1033         if self.copysource and ctx.get('sourcename'):\n1034             # copy the source file for the \"show source\" link\n1035             source_name = path.join(self.outdir, '_sources',\n1036                                     os_path(ctx['sourcename']))\n1037             ensuredir(path.dirname(source_name))\n1038             copyfile(self.env.doc2path(pagename), source_name)\n1039 \n1040     def update_page_context(self, pagename: str, templatename: str,\n1041                             ctx: Dict, event_arg: Any) -> None:\n1042         pass\n1043 \n1044     def handle_finish(self) -> None:\n1045         if self.indexer:\n1046             self.finish_tasks.add_task(self.dump_search_index)\n1047         self.finish_tasks.add_task(self.dump_inventory)\n1048 \n1049     @progress_message(__('dumping object inventory'))\n1050     def dump_inventory(self) -> None:\n1051         InventoryFile.dump(path.join(self.outdir, INVENTORY_FILENAME), self.env, self)\n1052 \n1053     def dump_search_index(self) -> None:\n1054         with progress_message(__('dumping search index in %s') % self.indexer.label()):\n1055             self.indexer.prune(self.env.all_docs)\n1056             searchindexfn = path.join(self.outdir, self.searchindex_filename)\n1057             # first write to a temporary file, so that if dumping fails,\n1058             # the existing index won't be overwritten\n1059             if self.indexer_dumps_unicode:\n1060                 with open(searchindexfn + '.tmp', 'w', encoding='utf-8') as ft:\n1061                     self.indexer.dump(ft, self.indexer_format)\n1062             else:\n1063                 with open(searchindexfn + '.tmp', 'wb') as fb:\n1064                     self.indexer.dump(fb, self.indexer_format)\n1065             movefile(searchindexfn + '.tmp', searchindexfn)\n1066 \n1067 \n1068 def convert_html_css_files(app: Sphinx, config: Config) -> None:\n1069     \"\"\"This converts string styled html_css_files to tuple styled one.\"\"\"\n1070     html_css_files = []  # type: List[Tuple[str, Dict]]\n1071     for entry in config.html_css_files:\n1072         if isinstance(entry, str):\n1073             html_css_files.append((entry, {}))\n1074         else:\n1075             try:\n1076                 filename, attrs = entry\n1077                 html_css_files.append((filename, attrs))\n1078             except Exception:\n1079                 logger.warning(__('invalid css_file: %r, ignored'), entry)\n1080                 continue\n1081 \n1082     config.html_css_files = html_css_files  # type: ignore\n1083 \n1084 \n1085 def convert_html_js_files(app: Sphinx, config: Config) -> None:\n1086     \"\"\"This converts string styled html_js_files to tuple styled one.\"\"\"\n1087     html_js_files = []  # type: List[Tuple[str, Dict]]\n1088     for entry in config.html_js_files:\n1089         if isinstance(entry, str):\n1090             html_js_files.append((entry, {}))\n1091         else:\n1092             try:\n1093                 filename, attrs = entry\n1094                 html_js_files.append((filename, attrs))\n1095             except Exception:\n1096                 logger.warning(__('invalid js_file: %r, ignored'), entry)\n1097                 continue\n1098 \n1099     config.html_js_files = html_js_files  # type: ignore\n1100 \n1101 \n1102 def setup_js_tag_helper(app: Sphinx, pagename: str, templatexname: str,\n1103                         context: Dict, doctree: Node) -> None:\n1104     \"\"\"Set up js_tag() template helper.\n1105 \n1106     .. note:: This set up function is added to keep compatibility with webhelper.\n1107     \"\"\"\n1108     pathto = context.get('pathto')\n1109 \n1110     def js_tag(js: JavaScript) -> str:\n1111         attrs = []\n1112         body = ''\n1113         if isinstance(js, JavaScript):\n1114             for key in sorted(js.attributes):\n1115                 value = js.attributes[key]\n1116                 if value is not None:\n1117                     if key == 'body':\n1118                         body = value\n1119                     else:\n1120                         attrs.append('%s=\"%s\"' % (key, html.escape(value, True)))\n1121             if js.filename:\n1122                 attrs.append('src=\"%s\"' % pathto(js.filename, resource=True))\n1123         else:\n1124             # str value (old styled)\n1125             attrs.append('src=\"%s\"' % pathto(js, resource=True))\n1126         return '<script %s>%s</script>' % (' '.join(attrs), body)\n1127 \n1128     context['js_tag'] = js_tag\n1129 \n1130 \n1131 def validate_math_renderer(app: Sphinx) -> None:\n1132     if app.builder.format != 'html':\n1133         return\n1134 \n1135     name = app.builder.math_renderer_name  # type: ignore\n1136     if name is None:\n1137         raise ConfigError(__('Many math_renderers are registered. '\n1138                              'But no math_renderer is selected.'))\n1139     elif name not in app.registry.html_inline_math_renderers:\n1140         raise ConfigError(__('Unknown math_renderer %r is given.') % name)\n1141 \n1142 \n1143 def validate_html_extra_path(app: Sphinx, config: Config) -> None:\n1144     \"\"\"Check html_extra_paths setting.\"\"\"\n1145     for entry in config.html_extra_path[:]:\n1146         extra_path = path.normpath(path.join(app.confdir, entry))\n1147         if not path.exists(extra_path):\n1148             logger.warning(__('html_extra_path entry %r does not exist'), entry)\n1149             config.html_extra_path.remove(entry)\n1150         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(extra_path)[0] and\n1151               path.commonpath([app.outdir, extra_path]) == app.outdir):\n1152             logger.warning(__('html_extra_path entry %r is placed inside outdir'), entry)\n1153             config.html_extra_path.remove(entry)\n1154 \n1155 \n1156 def validate_html_static_path(app: Sphinx, config: Config) -> None:\n1157     \"\"\"Check html_static_paths setting.\"\"\"\n1158     for entry in config.html_static_path[:]:\n1159         static_path = path.normpath(path.join(app.confdir, entry))\n1160         if not path.exists(static_path):\n1161             logger.warning(__('html_static_path entry %r does not exist'), entry)\n1162             config.html_static_path.remove(entry)\n1163         elif (path.splitdrive(app.outdir)[0] == path.splitdrive(static_path)[0] and\n1164               path.commonpath([app.outdir, static_path]) == app.outdir):\n1165             logger.warning(__('html_static_path entry %r is placed inside outdir'), entry)\n1166             config.html_static_path.remove(entry)\n1167 \n1168 \n1169 def validate_html_logo(app: Sphinx, config: Config) -> None:\n1170     \"\"\"Check html_logo setting.\"\"\"\n1171     if config.html_logo and not path.isfile(path.join(app.confdir, config.html_logo)):\n1172         logger.warning(__('logo file %r does not exist'), config.html_logo)\n1173         config.html_logo = None  # type: ignore\n1174 \n1175 \n1176 def validate_html_favicon(app: Sphinx, config: Config) -> None:\n1177     \"\"\"Check html_favicon setting.\"\"\"\n1178     if config.html_favicon and not path.isfile(path.join(app.confdir, config.html_favicon)):\n1179         logger.warning(__('favicon file %r does not exist'), config.html_favicon)\n1180         config.html_favicon = None  # type: ignore\n1181 \n1182 \n1183 # for compatibility\n1184 import sphinx.builders.dirhtml  # NOQA\n1185 import sphinx.builders.singlehtml  # NOQA\n1186 import sphinxcontrib.serializinghtml  # NOQA\n1187 \n1188 \n1189 def setup(app: Sphinx) -> Dict[str, Any]:\n1190     # builders\n1191     app.add_builder(StandaloneHTMLBuilder)\n1192 \n1193     # config values\n1194     app.add_config_value('html_theme', 'alabaster', 'html')\n1195     app.add_config_value('html_theme_path', [], 'html')\n1196     app.add_config_value('html_theme_options', {}, 'html')\n1197     app.add_config_value('html_title',\n1198                          lambda self: _('%s %s documentation') % (self.project, self.release),\n1199                          'html', [str])\n1200     app.add_config_value('html_short_title', lambda self: self.html_title, 'html')\n1201     app.add_config_value('html_style', None, 'html', [str])\n1202     app.add_config_value('html_logo', None, 'html', [str])\n1203     app.add_config_value('html_favicon', None, 'html', [str])\n1204     app.add_config_value('html_css_files', [], 'html')\n1205     app.add_config_value('html_js_files', [], 'html')\n1206     app.add_config_value('html_static_path', [], 'html')\n1207     app.add_config_value('html_extra_path', [], 'html')\n1208     app.add_config_value('html_last_updated_fmt', None, 'html', [str])\n1209     app.add_config_value('html_sidebars', {}, 'html')\n1210     app.add_config_value('html_additional_pages', {}, 'html')\n1211     app.add_config_value('html_domain_indices', True, 'html', [list])\n1212     app.add_config_value('html_add_permalinks', '\u00b6', 'html')\n1213     app.add_config_value('html_use_index', True, 'html')\n1214     app.add_config_value('html_split_index', False, 'html')\n1215     app.add_config_value('html_copy_source', True, 'html')\n1216     app.add_config_value('html_show_sourcelink', True, 'html')\n1217     app.add_config_value('html_sourcelink_suffix', '.txt', 'html')\n1218     app.add_config_value('html_use_opensearch', '', 'html')\n1219     app.add_config_value('html_file_suffix', None, 'html', [str])\n1220     app.add_config_value('html_link_suffix', None, 'html', [str])\n1221     app.add_config_value('html_show_copyright', True, 'html')\n1222     app.add_config_value('html_show_sphinx', True, 'html')\n1223     app.add_config_value('html_context', {}, 'html')\n1224     app.add_config_value('html_output_encoding', 'utf-8', 'html')\n1225     app.add_config_value('html_compact_lists', True, 'html')\n1226     app.add_config_value('html_secnumber_suffix', '. ', 'html')\n1227     app.add_config_value('html_search_language', None, 'html', [str])\n1228     app.add_config_value('html_search_options', {}, 'html')\n1229     app.add_config_value('html_search_scorer', '', None)\n1230     app.add_config_value('html_scaled_image_link', True, 'html')\n1231     app.add_config_value('html_baseurl', '', 'html')\n1232     app.add_config_value('html_codeblock_linenos_style', 'table', 'html',\n1233                          ENUM('table', 'inline'))\n1234     app.add_config_value('html_math_renderer', None, 'env')\n1235     app.add_config_value('html4_writer', False, 'html')\n1236 \n1237     # event handlers\n1238     app.connect('config-inited', convert_html_css_files, priority=800)\n1239     app.connect('config-inited', convert_html_js_files, priority=800)\n1240     app.connect('config-inited', validate_html_extra_path, priority=800)\n1241     app.connect('config-inited', validate_html_static_path, priority=800)\n1242     app.connect('config-inited', validate_html_logo, priority=800)\n1243     app.connect('config-inited', validate_html_favicon, priority=800)\n1244     app.connect('builder-inited', validate_math_renderer)\n1245     app.connect('html-page-context', setup_js_tag_helper)\n1246 \n1247     # load default math renderer\n1248     app.setup_extension('sphinx.ext.mathjax')\n1249 \n1250     # load transforms for HTML builder\n1251     app.setup_extension('sphinx.builders.html.transforms')\n1252 \n1253     return {\n1254         'version': 'builtin',\n1255         'parallel_read_safe': True,\n1256         'parallel_write_safe': True,\n1257     }\n",
        "intended_behavior": "In this central file for HTML building, the target would be to ensure the logic that organizes index entries into sections recognizes and groups any entries starting with special characters like '@', '\u00a3', and '\u2190' into one \"Symbols\" section to prevent duplication. This might require adding specific checks or logic to treat these characters uniformly when categorizing index entries."
    }
]