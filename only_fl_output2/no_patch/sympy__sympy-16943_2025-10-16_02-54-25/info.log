2025-10-16 02:54:25.990 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 02:54:34.975 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=274, output_tokens=12, cost=0.003100
2025-10-16 02:54:44.323 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=454, output_tokens=324, cost=0.014260
2025-10-16 02:54:45.881 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:54:55.968 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=582, output_tokens=403, cost=0.017910
2025-10-16 02:54:55.972 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:54:57.520 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=757, output_tokens=41, cost=0.008800
2025-10-16 02:54:57.521 | DEBUG    | Extracted a valid json.
2025-10-16 02:54:57.521 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"fps\")",
        "search_class(\"Pow\")",
        "search_code(\"if isinstance\")"
    ],
    "bug_locations": []
}
2025-10-16 02:55:05.114 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:55:05.115 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:55:23.609 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9369, output_tokens=731, cost=0.115620
2025-10-16 02:55:23.616 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:55:33.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10316, output_tokens=351, cost=0.113690
2025-10-16 02:55:33.412 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:55:40.493 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=705, output_tokens=308, cost=0.016290
2025-10-16 02:55:40.494 | DEBUG    | Extracted a valid json.
2025-10-16 02:55:40.494 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/series/formal.py",
            "class": "",
            "method": "fps",
            "intended_behavior": "The `fps` method should uniformly return a `FormalPowerSeries` object or a compatible type that supports indexing and other series operations, even when the input is a simple polynomial that does not need formal expansion. This requires modifying the method to encapsulate outputs like `x**2` within a formal series wrapper that mimics the behavior of a more complex series expansion, without altering the mathematical output. Essentially, even if the function decides to return the input in cases where expansion is deemed unnecessary, it should still ensure that the return value adheres to the interface expected by callers of `fps`."
        },
        {
            "file": "sympy/core/expr.py",
            "class": "Expr",
            "method": "fps",
            "intended_behavior": "Similar to the `fps` function in `sympy/series/formal.py`, this wrapper method in the `Expr` class should ensure that for all expressions, calling `fps` yields an object that supports the full interface expected of a formal power series. This might mean implementing additional logic within this method to check the return type from the core `fps` function and adjust it accordingly, ensuring uniformity and predictability in the behavior of `fps` across the library."
        }
    ]
}
2025-10-16 02:55:40.510 | DEBUG    | Bug location extracted successfully: [<file>sympy/series/formal.py</file>
<class>None</class>
<method>fps</method>
<code>
1183 def fps(f, x=None, x0=0, dir=1, hyper=True, order=4, rational=True, full=False):
1184     """Generates Formal Power Series of f.
1185 
1186     Returns the formal series expansion of ``f`` around ``x = x0``
1187     with respect to ``x`` in the form of a ``FormalPowerSeries`` object.
1188 
1189     Formal Power Series is represented using an explicit formula
1190     computed using different algorithms.
1191 
1192     See :func:`compute_fps` for the more details regarding the computation
1193     of formula.
1194 
1195     Parameters
1196     ==========
1197 
1198     x : Symbol, optional
1199         If x is None and ``f`` is univariate, the univariate symbols will be
1200         supplied, otherwise an error will be raised.
1201     x0 : number, optional
1202         Point to perform series expansion about. Default is 0.
1203     dir : {1, -1, '+', '-'}, optional
1204         If dir is 1 or '+' the series is calculated from the right and
1205         for -1 or '-' the series is calculated from the left. For smooth
1206         functions this flag will not alter the results. Default is 1.
1207     hyper : {True, False}, optional
1208         Set hyper to False to skip the hypergeometric algorithm.
1209         By default it is set to False.
1210     order : int, optional
1211         Order of the derivative of ``f``, Default is 4.
1212     rational : {True, False}, optional
1213         Set rational to False to skip rational algorithm. By default it is set
1214         to True.
1215     full : {True, False}, optional
1216         Set full to True to increase the range of rational algorithm.
1217         See :func:`rational_algorithm` for details. By default it is set to
1218         False.
1219 
1220     Examples
1221     ========
1222 
1223     >>> from sympy import fps, O, ln, atan
1224     >>> from sympy.abc import x
1225 
1226     Rational Functions
1227 
1228     >>> fps(ln(1 + x)).truncate()
1229     x - x**2/2 + x**3/3 - x**4/4 + x**5/5 + O(x**6)
1230 
1231     >>> fps(atan(x), full=True).truncate()
1232     x - x**3/3 + x**5/5 + O(x**6)
1233 
1234     See Also
1235     ========
1236 
1237     sympy.series.formal.FormalPowerSeries
1238     sympy.series.formal.compute_fps
1239     """
1240     f = sympify(f)
1241 
1242     if x is None:
1243         free = f.free_symbols
1244         if len(free) == 1:
1245             x = free.pop()
1246         elif not free:
1247             return f
1248         else:
1249             raise NotImplementedError("multivariate formal power series")
1250 
1251     result = compute_fps(f, x, x0, dir, hyper, order, rational, full)
1252 
1253     if result is None:
1254         return f
1255 
1256     return FormalPowerSeries(f, x, x0, dir, result)

</code><intended_behavior>The `fps` method should uniformly return a `FormalPowerSeries` object or a compatible type that supports indexing and other series operations, even when the input is a simple polynomial that does not need formal expansion. This requires modifying the method to encapsulate outputs like `x**2` within a formal series wrapper that mimics the behavior of a more complex series expansion, without altering the mathematical output. Essentially, even if the function decides to return the input in cases where expansion is deemed unnecessary, it should still ensure that the return value adheres to the interface expected by callers of `fps`.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>fps</method>
<code>
3113     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3114             full=False):
3115         """
3116         Compute formal power power series of self.
3117 
3118         See the docstring of the :func:`fps` function in sympy.series.formal for
3119         more information.
3120         """
3121         from sympy.series.formal import fps
3122 
3123         return fps(self, x, x0, dir, hyper, order, rational, full)

</code><intended_behavior>Similar to the `fps` function in `sympy/series/formal.py`, this wrapper method in the `Expr` class should ensure that for all expressions, calling `fps` yields an object that supports the full interface expected of a formal power series. This might mean implementing additional logic within this method to check the return type from the core `fps` function and adjust it accordingly, ensuring uniformity and predictability in the behavior of `fps` across the library.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     # ***************
105     # * Arithmetics *
106     # ***************
107     # Expr and its sublcasses use _op_priority to determine which object
108     # passed to a binary special method (__mul__, etc.) will handle the
109     # operation. In general, the 'call_highest_priority' decorator will choose
110     # the object with the highest _op_priority to handle the call.
111     # Custom subclasses that want to define their own binary special methods
112     # should set an _op_priority value that is higher than the default.
113     #
114     # **NOTE**:
115     # This is a temporary fix, and will eventually be replaced with
116     # something better and more powerful.  See issue 5510.
117     _op_priority = 10.0
118 
119     def __pos__(self):
120         return self
121 
122     def __neg__(self):
123         return Mul(S.NegativeOne, self)
124 
125     def __abs__(self):
126         from sympy import Abs
127         return Abs(self)
128 
129     @_sympifyit('other', NotImplemented)
130     @call_highest_priority('__radd__')
131     def __add__(self, other):
132         return Add(self, other)
133 
134     @_sympifyit('other', NotImplemented)
135     @call_highest_priority('__add__')
136     def __radd__(self, other):
137         return Add(other, self)
138 
139     @_sympifyit('other', NotImplemented)
140     @call_highest_priority('__rsub__')
141     def __sub__(self, other):
142         return Add(self, -other)
143 
144     @_sympifyit('other', NotImplemented)
145     @call_highest_priority('__sub__')
146     def __rsub__(self, other):
147         return Add(other, -self)
148 
149     @_sympifyit('other', NotImplemented)
150     @call_highest_priority('__rmul__')
151     def __mul__(self, other):
152         return Mul(self, other)
153 
154     @_sympifyit('other', NotImplemented)
155     @call_highest_priority('__mul__')
156     def __rmul__(self, other):
157         return Mul(other, self)
158 
159     @_sympifyit('other', NotImplemented)
160     @call_highest_priority('__rpow__')
161     def _pow(self, other):
162         return Pow(self, other)
163 
164     def __pow__(self, other, mod=None):
165         if mod is None:
166             return self._pow(other)
167         try:
168             _self, other, mod = as_int(self), as_int(other), as_int(mod)
169             if other >= 0:
170                 return pow(_self, other, mod)
171             else:
172                 from sympy.core.numbers import mod_inverse
173                 return mod_inverse(pow(_self, -other, mod), mod)
174         except ValueError:
175             power = self._pow(other)
176             try:
177                 return power%mod
178             except TypeError:
179                 return NotImplemented
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__pow__')
183     def __rpow__(self, other):
184         return Pow(other, self)
185 
186     @_sympifyit('other', NotImplemented)
187     @call_highest_priority('__rdiv__')
188     def __div__(self, other):
189         return Mul(self, Pow(other, S.NegativeOne))
190 
191     @_sympifyit('other', NotImplemented)
192     @call_highest_priority('__div__')
193     def __rdiv__(self, other):
194         return Mul(other, Pow(self, S.NegativeOne))
195 
196     __truediv__ = __div__
197     __rtruediv__ = __rdiv__
198 
199     @_sympifyit('other', NotImplemented)
200     @call_highest_priority('__rmod__')
201     def __mod__(self, other):
202         return Mod(self, other)
203 
204     @_sympifyit('other', NotImplemented)
205     @call_highest_priority('__mod__')
206     def __rmod__(self, other):
207         return Mod(other, self)
208 
209     @_sympifyit('other', NotImplemented)
210     @call_highest_priority('__rfloordiv__')
211     def __floordiv__(self, other):
212         from sympy.functions.elementary.integers import floor
213         return floor(self / other)
214 
215     @_sympifyit('other', NotImplemented)
216     @call_highest_priority('__floordiv__')
217     def __rfloordiv__(self, other):
218         from sympy.functions.elementary.integers import floor
219         return floor(other / self)
220 
221 
222     @_sympifyit('other', NotImplemented)
223     @call_highest_priority('__rdivmod__')
224     def __divmod__(self, other):
225         from sympy.functions.elementary.integers import floor
226         return floor(self / other), Mod(self, other)
227 
228     @_sympifyit('other', NotImplemented)
229     @call_highest_priority('__divmod__')
230     def __rdivmod__(self, other):
231         from sympy.functions.elementary.integers import floor
232         return floor(other / self), Mod(other, self)
233 
234     def __int__(self):
235         # Although we only need to round to the units position, we'll
236         # get one more digit so the extra testing below can be avoided
237         # unless the rounded value rounded to an integer, e.g. if an
238         # expression were equal to 1.9 and we rounded to the unit position
239         # we would get a 2 and would not know if this rounded up or not
240         # without doing a test (as done below). But if we keep an extra
241         # digit we know that 1.9 is not the same as 1 and there is no
242         # need for further testing: our int value is correct. If the value
243         # were 1.99, however, this would round to 2.0 and our int value is
244         # off by one. So...if our round value is the same as the int value
245         # (regardless of how much extra work we do to calculate extra decimal
246         # places) we need to test whether we are off by one.
247         from sympy import Dummy
248         if not self.is_number:
249             raise TypeError("can't convert symbols to int")
250         r = self.round(2)
251         if not r.is_Number:
252             raise TypeError("can't convert complex to int")
253         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
254             raise TypeError("can't convert %s to int" % r)
255         i = int(r)
256         if not i:
257             return 0
258         # off-by-one check
259         if i == r and not (self - i).equals(0):
260             isign = 1 if i > 0 else -1
261             x = Dummy()
262             # in the following (self - i).evalf(2) will not always work while
263             # (self - r).evalf(2) and the use of subs does; if the test that
264             # was added when this comment was added passes, it might be safe
265             # to simply use sign to compute this rather than doing this by hand:
266             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
267             if diff_sign != isign:
268                 i -= isign
269         return i
270     __long__ = __int__
271 
272     def __float__(self):
273         # Don't bother testing if it's a number; if it's not this is going
274         # to fail, and if it is we still need to check that it evalf'ed to
275         # a number.
276         result = self.evalf()
277         if result.is_Number:
278             return float(result)
279         if result.is_number and result.as_real_imag()[1]:
280             raise TypeError("can't convert complex to float")
281         raise TypeError("can't convert expression to float")
282 
283     def __complex__(self):
284         result = self.evalf()
285         re, im = result.as_real_imag()
286         return complex(float(re), float(im))
287 
288     def __ge__(self, other):
289         from sympy import GreaterThan
290         try:
291             other = _sympify(other)
292         except SympifyError:
293             raise TypeError("Invalid comparison %s >= %s" % (self, other))
294         for me in (self, other):
295             if me.is_complex and me.is_extended_real is False:
296                 raise TypeError("Invalid comparison of complex %s" % me)
297             if me is S.NaN:
298                 raise TypeError("Invalid NaN comparison")
299         n2 = _n2(self, other)
300         if n2 is not None:
301             return _sympify(n2 >= 0)
302         if self.is_extended_real or other.is_extended_real:
303             dif = self - other
304             if dif.is_extended_nonnegative is not None and \
305                     dif.is_extended_nonnegative is not dif.is_extended_negative:
306                 return sympify(dif.is_extended_nonnegative)
307         return GreaterThan(self, other, evaluate=False)
308 
309     def __le__(self, other):
310         from sympy import LessThan
311         try:
312             other = _sympify(other)
313         except SympifyError:
314             raise TypeError("Invalid comparison %s <= %s" % (self, other))
315         for me in (self, other):
316             if me.is_complex and me.is_extended_real is False:
317                 raise TypeError("Invalid comparison of complex %s" % me)
318             if me is S.NaN:
319                 raise TypeError("Invalid NaN comparison")
320         n2 = _n2(self, other)
321         if n2 is not None:
322             return _sympify(n2 <= 0)
323         if self.is_extended_real or other.is_extended_real:
324             dif = self - other
325             if dif.is_extended_nonpositive is not None and \
326                     dif.is_extended_nonpositive is not dif.is_extended_positive:
327                 return sympify(dif.is_extended_nonpositive)
328         return LessThan(self, other, evaluate=False)
329 
330     def __gt__(self, other):
331         from sympy import StrictGreaterThan
332         try:
333             other = _sympify(other)
334         except SympifyError:
335             raise TypeError("Invalid comparison %s > %s" % (self, other))
336         for me in (self, other):
337             if me.is_complex and me.is_extended_real is False:
338                 raise TypeError("Invalid comparison of complex %s" % me)
339             if me is S.NaN:
340                 raise TypeError("Invalid NaN comparison")
341         n2 = _n2(self, other)
342         if n2 is not None:
343             return _sympify(n2 > 0)
344         if self.is_extended_real or other.is_extended_real:
345             dif = self - other
346             if dif.is_extended_positive is not None and \
347                     dif.is_extended_positive is not dif.is_extended_nonpositive:
348                 return sympify(dif.is_extended_positive)
349         return StrictGreaterThan(self, other, evaluate=False)
350 
351     def __lt__(self, other):
352         from sympy import StrictLessThan
353         try:
354             other = _sympify(other)
355         except SympifyError:
356             raise TypeError("Invalid comparison %s < %s" % (self, other))
357         for me in (self, other):
358             if me.is_complex and me.is_extended_real is False:
359                 raise TypeError("Invalid comparison of complex %s" % me)
360             if me is S.NaN:
361                 raise TypeError("Invalid NaN comparison")
362         n2 = _n2(self, other)
363         if n2 is not None:
364             return _sympify(n2 < 0)
365         if self.is_extended_real or other.is_extended_real:
366             dif = self - other
367             if dif.is_extended_negative is not None and \
368                     dif.is_extended_negative is not dif.is_extended_nonnegative:
369                 return sympify(dif.is_extended_negative)
370         return StrictLessThan(self, other, evaluate=False)
371 
372     def __trunc__(self):
373         if not self.is_number:
374             raise TypeError("can't truncate symbols and expressions")
375         else:
376             return Integer(self)
377 
378     @staticmethod
379     def _from_mpmath(x, prec):
380         from sympy import Float
381         if hasattr(x, "_mpf_"):
382             return Float._new(x._mpf_, prec)
383         elif hasattr(x, "_mpc_"):
384             re, im = x._mpc_
385             re = Float._new(re, prec)
386             im = Float._new(im, prec)*S.ImaginaryUnit
387             return re + im
388         else:
389             raise TypeError("expected mpmath number (mpf or mpc)")
390 
391     @property
392     def is_number(self):
393         """Returns True if ``self`` has no free symbols and no
394         undefined functions (AppliedUndef, to be precise). It will be
395         faster than ``if not self.free_symbols``, however, since
396         ``is_number`` will fail as soon as it hits a free symbol
397         or undefined function.
398 
399         Examples
400         ========
401 
402         >>> from sympy import log, Integral, cos, sin, pi
403         >>> from sympy.core.function import Function
404         >>> from sympy.abc import x
405         >>> f = Function('f')
406 
407         >>> x.is_number
408         False
409         >>> f(1).is_number
410         False
411         >>> (2*x).is_number
412         False
413         >>> (2 + Integral(2, x)).is_number
414         False
415         >>> (2 + Integral(2, (x, 1, 2))).is_number
416         True
417 
418         Not all numbers are Numbers in the SymPy sense:
419 
420         >>> pi.is_number, pi.is_Number
421         (True, False)
422 
423         If something is a number it should evaluate to a number with
424         real and imaginary parts that are Numbers; the result may not
425         be comparable, however, since the real and/or imaginary part
426         of the result may not have precision.
427 
428         >>> cos(1).is_number and cos(1).is_comparable
429         True
430 
431         >>> z = cos(1)**2 + sin(1)**2 - 1
432         >>> z.is_number
433         True
434         >>> z.is_comparable
435         False
436 
437         See Also
438         ========
439         sympy.core.basic.is_comparable
440         """
441         return all(obj.is_number for obj in self.args)
442 
443     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
444         """Return self evaluated, if possible, replacing free symbols with
445         random complex values, if necessary.
446 
447         The random complex value for each free symbol is generated
448         by the random_complex_number routine giving real and imaginary
449         parts in the range given by the re_min, re_max, im_min, and im_max
450         values. The returned value is evaluated to a precision of n
451         (if given) else the maximum of 15 and the precision needed
452         to get more than 1 digit of precision. If the expression
453         could not be evaluated to a number, or could not be evaluated
454         to more than 1 digit of precision, then None is returned.
455 
456         Examples
457         ========
458 
459         >>> from sympy import sqrt
460         >>> from sympy.abc import x, y
461         >>> x._random()                         # doctest: +SKIP
462         0.0392918155679172 + 0.916050214307199*I
463         >>> x._random(2)                        # doctest: +SKIP
464         -0.77 - 0.87*I
465         >>> (x + y/2)._random(2)                # doctest: +SKIP
466         -0.57 + 0.16*I
467         >>> sqrt(2)._random(2)
468         1.4
469 
470         See Also
471         ========
472 
473         sympy.utilities.randtest.random_complex_number
474         """
475 
476         free = self.free_symbols
477         prec = 1
478         if free:
479             from sympy.utilities.randtest import random_complex_number
480             a, c, b, d = re_min, re_max, im_min, im_max
481             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
482                            for zi in free])))
483             try:
484                 nmag = abs(self.evalf(2, subs=reps))
485             except (ValueError, TypeError):
486                 # if an out of range value resulted in evalf problems
487                 # then return None -- XXX is there a way to know how to
488                 # select a good random number for a given expression?
489                 # e.g. when calculating n! negative values for n should not
490                 # be used
491                 return None
492         else:
493             reps = {}
494             nmag = abs(self.evalf(2))
495 
496         if not hasattr(nmag, '_prec'):
497             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
498             return None
499 
500         if nmag._prec == 1:
501             # increase the precision up to the default maximum
502             # precision to see if we can get any significance
503 
504             from mpmath.libmp.libintmath import giant_steps
505             from sympy.core.evalf import DEFAULT_MAXPREC as target
506 
507             # evaluate
508             for prec in giant_steps(2, target):
509                 nmag = abs(self.evalf(prec, subs=reps))
510                 if nmag._prec != 1:
511                     break
512 
513         if nmag._prec != 1:
514             if n is None:
515                 n = max(prec, 15)
516             return self.evalf(n, subs=reps)
517 
518         # never got any significance
519         return None
520 
521     def is_constant(self, *wrt, **flags):
522         """Return True if self is constant, False if not, or None if
523         the constancy could not be determined conclusively.
524 
525         If an expression has no free symbols then it is a constant. If
526         there are free symbols it is possible that the expression is a
527         constant, perhaps (but not necessarily) zero. To test such
528         expressions, two strategies are tried:
529 
530         1) numerical evaluation at two random points. If two such evaluations
531         give two different values and the values have a precision greater than
532         1 then self is not constant. If the evaluations agree or could not be
533         obtained with any precision, no decision is made. The numerical testing
534         is done only if ``wrt`` is different than the free symbols.
535 
536         2) differentiation with respect to variables in 'wrt' (or all free
537         symbols if omitted) to see if the expression is constant or not. This
538         will not always lead to an expression that is zero even though an
539         expression is constant (see added test in test_expr.py). If
540         all derivatives are zero then self is constant with respect to the
541         given symbols.
542 
543         If neither evaluation nor differentiation can prove the expression is
544         constant, None is returned unless two numerical values happened to be
545         the same and the flag ``failing_number`` is True -- in that case the
546         numerical value will be returned.
547 
548         If flag simplify=False is passed, self will not be simplified;
549         the default is True since self should be simplified before testing.
550 
551         Examples
552         ========
553 
554         >>> from sympy import cos, sin, Sum, S, pi
555         >>> from sympy.abc import a, n, x, y
556         >>> x.is_constant()
557         False
558         >>> S(2).is_constant()
559         True
560         >>> Sum(x, (x, 1, 10)).is_constant()
561         True
562         >>> Sum(x, (x, 1, n)).is_constant()
563         False
564         >>> Sum(x, (x, 1, n)).is_constant(y)
565         True
566         >>> Sum(x, (x, 1, n)).is_constant(n)
567         False
568         >>> Sum(x, (x, 1, n)).is_constant(x)
569         True
570         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
571         >>> eq.is_constant()
572         True
573         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
574         True
575 
576         >>> (0**x).is_constant()
577         False
578         >>> x.is_constant()
579         False
580         >>> (x**x).is_constant()
581         False
582         >>> one = cos(x)**2 + sin(x)**2
583         >>> one.is_constant()
584         True
585         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
586         True
587         """
588 
589         simplify = flags.get('simplify', True)
590 
591         if self.is_number:
592             return True
593         free = self.free_symbols
594         if not free:
595             return True  # assume f(1) is some constant
596 
597         # if we are only interested in some symbols and they are not in the
598         # free symbols then this expression is constant wrt those symbols
599         wrt = set(wrt)
600         if wrt and not wrt & free:
601             return True
602         wrt = wrt or free
603 
604         # simplify unless this has already been done
605         expr = self
606         if simplify:
607             expr = expr.simplify()
608 
609         # is_zero should be a quick assumptions check; it can be wrong for
610         # numbers (see test_is_not_constant test), giving False when it
611         # shouldn't, but hopefully it will never give True unless it is sure.
612         if expr.is_zero:
613             return True
614 
615         # try numerical evaluation to see if we get two different values
616         failing_number = None
617         if wrt == free:
618             # try 0 (for a) and 1 (for b)
619             try:
620                 a = expr.subs(list(zip(free, [0]*len(free))),
621                     simultaneous=True)
622                 if a is S.NaN:
623                     # evaluation may succeed when substitution fails
624                     a = expr._random(None, 0, 0, 0, 0)
625             except ZeroDivisionError:
626                 a = None
627             if a is not None and a is not S.NaN:
628                 try:
629                     b = expr.subs(list(zip(free, [1]*len(free))),
630                         simultaneous=True)
631                     if b is S.NaN:
632                         # evaluation may succeed when substitution fails
633                         b = expr._random(None, 1, 0, 1, 0)
634                 except ZeroDivisionError:
635                     b = None
636                 if b is not None and b is not S.NaN and b.equals(a) is False:
637                     return False
638                 # try random real
639                 b = expr._random(None, -1, 0, 1, 0)
640                 if b is not None and b is not S.NaN and b.equals(a) is False:
641                     return False
642                 # try random complex
643                 b = expr._random()
644                 if b is not None and b is not S.NaN:
645                     if b.equals(a) is False:
646                         return False
647                     failing_number = a if a.is_number else b
648 
649         # now we will test each wrt symbol (or all free symbols) to see if the
650         # expression depends on them or not using differentiation. This is
651         # not sufficient for all expressions, however, so we don't return
652         # False if we get a derivative other than 0 with free symbols.
653         for w in wrt:
654             deriv = expr.diff(w)
655             if simplify:
656                 deriv = deriv.simplify()
657             if deriv != 0:
658                 if not (pure_complex(deriv, or_real=True)):
659                     if flags.get('failing_number', False):
660                         return failing_number
661                     elif deriv.free_symbols:
662                         # dead line provided _random returns None in such cases
663                         return None
664                 return False
665         return True
666 
667     def equals(self, other, failing_expression=False):
668         """Return True if self == other, False if it doesn't, or None. If
669         failing_expression is True then the expression which did not simplify
670         to a 0 will be returned instead of None.
671 
672         If ``self`` is a Number (or complex number) that is not zero, then
673         the result is False.
674 
675         If ``self`` is a number and has not evaluated to zero, evalf will be
676         used to test whether the expression evaluates to zero. If it does so
677         and the result has significance (i.e. the precision is either -1, for
678         a Rational result, or is greater than 1) then the evalf value will be
679         used to return True or False.
680 
681         """
682         from sympy.simplify.simplify import nsimplify, simplify
683         from sympy.solvers.solveset import solveset
684         from sympy.solvers.solvers import solve
685         from sympy.polys.polyerrors import NotAlgebraic
686         from sympy.polys.numberfields import minimal_polynomial
687 
688         other = sympify(other)
689         if self == other:
690             return True
691 
692         # they aren't the same so see if we can make the difference 0;
693         # don't worry about doing simplification steps one at a time
694         # because if the expression ever goes to 0 then the subsequent
695         # simplification steps that are done will be very fast.
696         diff = factor_terms(simplify(self - other), radical=True)
697 
698         if not diff:
699             return True
700 
701         if not diff.has(Add, Mod):
702             # if there is no expanding to be done after simplifying
703             # then this can't be a zero
704             return False
705 
706         constant = diff.is_constant(simplify=False, failing_number=True)
707 
708         if constant is False:
709             return False
710 
711         if not diff.is_number:
712             if constant is None:
713                 # e.g. unless the right simplification is done, a symbolic
714                 # zero is possible (see expression of issue 6829: without
715                 # simplification constant will be None).
716                 return
717 
718         if constant is True:
719             # this gives a number whether there are free symbols or not
720             ndiff = diff._random()
721             # is_comparable will work whether the result is real
722             # or complex; it could be None, however.
723             if ndiff and ndiff.is_comparable:
724                 return False
725 
726         # sometimes we can use a simplified result to give a clue as to
727         # what the expression should be; if the expression is *not* zero
728         # then we should have been able to compute that and so now
729         # we can just consider the cases where the approximation appears
730         # to be zero -- we try to prove it via minimal_polynomial.
731         #
732         # removed
733         # ns = nsimplify(diff)
734         # if diff.is_number and (not ns or ns == diff):
735         #
736         # The thought was that if it nsimplifies to 0 that's a sure sign
737         # to try the following to prove it; or if it changed but wasn't
738         # zero that might be a sign that it's not going to be easy to
739         # prove. But tests seem to be working without that logic.
740         #
741         if diff.is_number:
742             # try to prove via self-consistency
743             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
744             # it seems to work better to try big ones first
745             surds.sort(key=lambda x: -x.args[0])
746             for s in surds:
747                 try:
748                     # simplify is False here -- this expression has already
749                     # been identified as being hard to identify as zero;
750                     # we will handle the checking ourselves using nsimplify
751                     # to see if we are in the right ballpark or not and if so
752                     # *then* the simplification will be attempted.
753                     sol = solve(diff, s, simplify=False)
754                     if sol:
755                         if s in sol:
756                             # the self-consistent result is present
757                             return True
758                         if all(si.is_Integer for si in sol):
759                             # perfect powers are removed at instantiation
760                             # so surd s cannot be an integer
761                             return False
762                         if all(i.is_algebraic is False for i in sol):
763                             # a surd is algebraic
764                             return False
765                         if any(si in surds for si in sol):
766                             # it wasn't equal to s but it is in surds
767                             # and different surds are not equal
768                             return False
769                         if any(nsimplify(s - si) == 0 and
770                                 simplify(s - si) == 0 for si in sol):
771                             return True
772                         if s.is_real:
773                             if any(nsimplify(si, [s]) == s and simplify(si) == s
774                                     for si in sol):
775                                 return True
776                 except NotImplementedError:
777                     pass
778 
779             # try to prove with minimal_polynomial but know when
780             # *not* to use this or else it can take a long time. e.g. issue 8354
781             if True:  # change True to condition that assures non-hang
782                 try:
783                     mp = minimal_polynomial(diff)
784                     if mp.is_Symbol:
785                         return True
786                     return False
787                 except (NotAlgebraic, NotImplementedError):
788                     pass
789 
790         # diff has not simplified to zero; constant is either None, True
791         # or the number with significance (is_comparable) that was randomly
792         # calculated twice as the same value.
793         if constant not in (True, None) and constant != 0:
794             return False
795 
796         if failing_expression:
797             return diff
798         return None
799 
800     def _eval_is_positive(self):
801         finite = self.is_finite
802         if finite is False:
803             return False
804         extended_positive = self.is_extended_positive
805         if finite is True:
806             return extended_positive
807         if extended_positive is False:
808             return False
809 
810     def _eval_is_negative(self):
811         finite = self.is_finite
812         if finite is False:
813             return False
814         extended_negative = self.is_extended_negative
815         if finite is True:
816             return extended_negative
817         if extended_negative is False:
818             return False
819 
820     def _eval_is_extended_positive(self):
821         from sympy.polys.numberfields import minimal_polynomial
822         from sympy.polys.polyerrors import NotAlgebraic
823         if self.is_number:
824             if self.is_extended_real is False:
825                 return False
826 
827             # check to see that we can get a value
828             try:
829                 n2 = self._eval_evalf(2)
830             # XXX: This shouldn't be caught here
831             # Catches ValueError: hypsum() failed to converge to the requested
832             # 34 bits of accuracy
833             except ValueError:
834                 return None
835             if n2 is None:
836                 return None
837             if getattr(n2, '_prec', 1) == 1:  # no significance
838                 return None
839             if n2 == S.NaN:
840                 return None
841 
842             r, i = self.evalf(2).as_real_imag()
843             if not i.is_Number or not r.is_Number:
844                 return False
845             if r._prec != 1 and i._prec != 1:
846                 return bool(not i and r > 0)
847             elif r._prec == 1 and (not i or i._prec == 1) and \
848                     self.is_algebraic and not self.has(Function):
849                 try:
850                     if minimal_polynomial(self).is_Symbol:
851                         return False
852                 except (NotAlgebraic, NotImplementedError):
853                     pass
854 
855     def _eval_is_extended_negative(self):
856         from sympy.polys.numberfields import minimal_polynomial
857         from sympy.polys.polyerrors import NotAlgebraic
858         if self.is_number:
859             if self.is_extended_real is False:
860                 return False
861 
862             # check to see that we can get a value
863             try:
864                 n2 = self._eval_evalf(2)
865             # XXX: This shouldn't be caught here
866             # Catches ValueError: hypsum() failed to converge to the requested
867             # 34 bits of accuracy
868             except ValueError:
869                 return None
870             if n2 is None:
871                 return None
872             if getattr(n2, '_prec', 1) == 1:  # no significance
873                 return None
874             if n2 == S.NaN:
875                 return None
876 
877             r, i = self.evalf(2).as_real_imag()
878             if not i.is_Number or not r.is_Number:
879                 return False
880             if r._prec != 1 and i._prec != 1:
881                 return bool(not i and r < 0)
882             elif r._prec == 1 and (not i or i._prec == 1) and \
883                     self.is_algebraic and not self.has(Function):
884                 try:
885                     if minimal_polynomial(self).is_Symbol:
886                         return False
887                 except (NotAlgebraic, NotImplementedError):
888                     pass
889 
890     def _eval_interval(self, x, a, b):
891         """
892         Returns evaluation over an interval.  For most functions this is:
893 
894         self.subs(x, b) - self.subs(x, a),
895 
896         possibly using limit() if NaN is returned from subs, or if
897         singularities are found between a and b.
898 
899         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
900         respectively.
901 
902         """
903         from sympy.series import limit, Limit
904         from sympy.solvers.solveset import solveset
905         from sympy.sets.sets import Interval
906         from sympy.functions.elementary.exponential import log
907         from sympy.calculus.util import AccumBounds
908 
909         if (a is None and b is None):
910             raise ValueError('Both interval ends cannot be None.')
911 
912         if a == b:
913             return 0
914 
915         if a is None:
916             A = 0
917         else:
918             A = self.subs(x, a)
919             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
920                 if (a < b) != False:
921                     A = limit(self, x, a,"+")
922                 else:
923                     A = limit(self, x, a,"-")
924 
925                 if A is S.NaN:
926                     return A
927                 if isinstance(A, Limit):
928                     raise NotImplementedError("Could not compute limit")
929 
930         if b is None:
931             B = 0
932         else:
933             B = self.subs(x, b)
934             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
935                 if (a < b) != False:
936                     B = limit(self, x, b,"-")
937                 else:
938                     B = limit(self, x, b,"+")
939 
940                 if isinstance(B, Limit):
941                     raise NotImplementedError("Could not compute limit")
942 
943         if (a and b) is None:
944             return B - A
945 
946         value = B - A
947 
948         if a.is_comparable and b.is_comparable:
949             if a < b:
950                 domain = Interval(a, b)
951             else:
952                 domain = Interval(b, a)
953             # check the singularities of self within the interval
954             # if singularities is a ConditionSet (not iterable), catch the exception and pass
955             singularities = solveset(self.cancel().as_numer_denom()[1], x,
956                 domain=domain)
957             for logterm in self.atoms(log):
958                 singularities = singularities | solveset(logterm.args[0], x,
959                     domain=domain)
960             try:
961                 for s in singularities:
962                     if value is S.NaN:
963                         # no need to keep adding, it will stay NaN
964                         break
965                     if not s.is_comparable:
966                         continue
967                     if (a < s) == (s < b) == True:
968                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
969                     elif (b < s) == (s < a) == True:
970                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
971             except TypeError:
972                 pass
973 
974         return value
975 
976     def _eval_power(self, other):
977         # subclass to compute self**other for cases when
978         # other is not NaN, 0, or 1
979         return None
980 
981     def _eval_conjugate(self):
982         if self.is_extended_real:
983             return self
984         elif self.is_imaginary:
985             return -self
986 
987     def conjugate(self):
988         from sympy.functions.elementary.complexes import conjugate as c
989         return c(self)
990 
991     def _eval_transpose(self):
992         from sympy.functions.elementary.complexes import conjugate
993         if self.is_complex:
994             return self
995         elif self.is_hermitian:
996             return conjugate(self)
997         elif self.is_antihermitian:
998             return -conjugate(self)
999 
1000     def transpose(self):
1001         from sympy.functions.elementary.complexes import transpose
1002         return transpose(self)
1003 
1004     def _eval_adjoint(self):
1005         from sympy.functions.elementary.complexes import conjugate, transpose
1006         if self.is_hermitian:
1007             return self
1008         elif self.is_antihermitian:
1009             return -self
1010         obj = self._eval_conjugate()
1011         if obj is not None:
1012             return transpose(obj)
1013         obj = self._eval_transpose()
1014         if obj is not None:
1015             return conjugate(obj)
1016 
1017     def adjoint(self):
1018         from sympy.functions.elementary.complexes import adjoint
1019         return adjoint(self)
1020 
1021     @classmethod
1022     def _parse_order(cls, order):
1023         """Parse and configure the ordering of terms. """
1024         from sympy.polys.orderings import monomial_key
1025 
1026         startswith = getattr(order, "startswith", None)
1027         if startswith is None:
1028             reverse = False
1029         else:
1030             reverse = startswith('rev-')
1031             if reverse:
1032                 order = order[4:]
1033 
1034         monom_key = monomial_key(order)
1035 
1036         def neg(monom):
1037             result = []
1038 
1039             for m in monom:
1040                 if isinstance(m, tuple):
1041                     result.append(neg(m))
1042                 else:
1043                     result.append(-m)
1044 
1045             return tuple(result)
1046 
1047         def key(term):
1048             _, ((re, im), monom, ncpart) = term
1049 
1050             monom = neg(monom_key(monom))
1051             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1052             coeff = ((bool(im), im), (re, im))
1053 
1054             return monom, ncpart, coeff
1055 
1056         return key, reverse
1057 
1058     def as_ordered_factors(self, order=None):
1059         """Return list of ordered factors (if Mul) else [self]."""
1060         return [self]
1061 
1062     def as_ordered_terms(self, order=None, data=False):
1063         """
1064         Transform an expression to an ordered list of terms.
1065 
1066         Examples
1067         ========
1068 
1069         >>> from sympy import sin, cos
1070         >>> from sympy.abc import x
1071 
1072         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1073         [sin(x)**2*cos(x), sin(x)**2, 1]
1074 
1075         """
1076 
1077         from .numbers import Number, NumberSymbol
1078 
1079         if order is None and self.is_Add:
1080             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1081             # first number positive and thhe second number nagative
1082             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1083             add_args = sorted(Add.make_args(self), key=key)
1084             if (len(add_args) == 2
1085                 and isinstance(add_args[0], (Number, NumberSymbol))
1086                 and isinstance(add_args[1], Mul)):
1087                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1088                 if (len(mul_args) == 2
1089                     and isinstance(mul_args[0], Number)
1090                     and add_args[0].is_positive
1091                     and mul_args[0].is_negative):
1092                     return add_args
1093 
1094         key, reverse = self._parse_order(order)
1095         terms, gens = self.as_terms()
1096 
1097         if not any(term.is_Order for term, _ in terms):
1098             ordered = sorted(terms, key=key, reverse=reverse)
1099         else:
1100             _terms, _order = [], []
1101 
1102             for term, repr in terms:
1103                 if not term.is_Order:
1104                     _terms.append((term, repr))
1105                 else:
1106                     _order.append((term, repr))
1107 
1108             ordered = sorted(_terms, key=key, reverse=True) \
1109                 + sorted(_order, key=key, reverse=True)
1110 
1111         if data:
1112             return ordered, gens
1113         else:
1114             return [term for term, _ in ordered]
1115 
1116     def as_terms(self):
1117         """Transform an expression to a list of terms. """
1118         from .add import Add
1119         from .mul import Mul
1120         from .exprtools import decompose_power
1121 
1122         gens, terms = set([]), []
1123 
1124         for term in Add.make_args(self):
1125             coeff, _term = term.as_coeff_Mul()
1126 
1127             coeff = complex(coeff)
1128             cpart, ncpart = {}, []
1129 
1130             if _term is not S.One:
1131                 for factor in Mul.make_args(_term):
1132                     if factor.is_number:
1133                         try:
1134                             coeff *= complex(factor)
1135                         except (TypeError, ValueError):
1136                             pass
1137                         else:
1138                             continue
1139 
1140                     if factor.is_commutative:
1141                         base, exp = decompose_power(factor)
1142 
1143                         cpart[base] = exp
1144                         gens.add(base)
1145                     else:
1146                         ncpart.append(factor)
1147 
1148             coeff = coeff.real, coeff.imag
1149             ncpart = tuple(ncpart)
1150 
1151             terms.append((term, (coeff, cpart, ncpart)))
1152 
1153         gens = sorted(gens, key=default_sort_key)
1154 
1155         k, indices = len(gens), {}
1156 
1157         for i, g in enumerate(gens):
1158             indices[g] = i
1159 
1160         result = []
1161 
1162         for term, (coeff, cpart, ncpart) in terms:
1163             monom = [0]*k
1164 
1165             for base, exp in cpart.items():
1166                 monom[indices[base]] = exp
1167 
1168             result.append((term, (coeff, tuple(monom), ncpart)))
1169 
1170         return result, gens
1171 
1172     def removeO(self):
1173         """Removes the additive O(..) symbol if there is one"""
1174         return self
1175 
1176     def getO(self):
1177         """Returns the additive O(..) symbol if there is one, else None."""
1178         return None
1179 
1180     def getn(self):
1181         """
1182         Returns the order of the expression.
1183 
1184         The order is determined either from the O(...) term. If there
1185         is no O(...) term, it returns None.
1186 
1187         Examples
1188         ========
1189 
1190         >>> from sympy import O
1191         >>> from sympy.abc import x
1192         >>> (1 + x + O(x**2)).getn()
1193         2
1194         >>> (1 + x).getn()
1195 
1196         """
1197         from sympy import Dummy, Symbol
1198         o = self.getO()
1199         if o is None:
1200             return None
1201         elif o.is_Order:
1202             o = o.expr
1203             if o is S.One:
1204                 return S.Zero
1205             if o.is_Symbol:
1206                 return S.One
1207             if o.is_Pow:
1208                 return o.args[1]
1209             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1210                 for oi in o.args:
1211                     if oi.is_Symbol:
1212                         return S.One
1213                     if oi.is_Pow:
1214                         syms = oi.atoms(Symbol)
1215                         if len(syms) == 1:
1216                             x = syms.pop()
1217                             oi = oi.subs(x, Dummy('x', positive=True))
1218                             if oi.base.is_Symbol and oi.exp.is_Rational:
1219                                 return abs(oi.exp)
1220 
1221         raise NotImplementedError('not sure of order of %s' % o)
1222 
1223     def count_ops(self, visual=None):
1224         """wrapper for count_ops that returns the operation count."""
1225         from .function import count_ops
1226         return count_ops(self, visual)
1227 
1228     def args_cnc(self, cset=False, warn=True, split_1=True):
1229         """Return [commutative factors, non-commutative factors] of self.
1230 
1231         self is treated as a Mul and the ordering of the factors is maintained.
1232         If ``cset`` is True the commutative factors will be returned in a set.
1233         If there were repeated factors (as may happen with an unevaluated Mul)
1234         then an error will be raised unless it is explicitly suppressed by
1235         setting ``warn`` to False.
1236 
1237         Note: -1 is always separated from a Number unless split_1 is False.
1238 
1239         >>> from sympy import symbols, oo
1240         >>> A, B = symbols('A B', commutative=0)
1241         >>> x, y = symbols('x y')
1242         >>> (-2*x*y).args_cnc()
1243         [[-1, 2, x, y], []]
1244         >>> (-2.5*x).args_cnc()
1245         [[-1, 2.5, x], []]
1246         >>> (-2*x*A*B*y).args_cnc()
1247         [[-1, 2, x, y], [A, B]]
1248         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1249         [[-2, x, y], [A, B]]
1250         >>> (-2*x*y).args_cnc(cset=True)
1251         [{-1, 2, x, y}, []]
1252 
1253         The arg is always treated as a Mul:
1254 
1255         >>> (-2 + x + A).args_cnc()
1256         [[], [x - 2 + A]]
1257         >>> (-oo).args_cnc() # -oo is a singleton
1258         [[-1, oo], []]
1259         """
1260 
1261         if self.is_Mul:
1262             args = list(self.args)
1263         else:
1264             args = [self]
1265         for i, mi in enumerate(args):
1266             if not mi.is_commutative:
1267                 c = args[:i]
1268                 nc = args[i:]
1269                 break
1270         else:
1271             c = args
1272             nc = []
1273 
1274         if c and split_1 and (
1275             c[0].is_Number and
1276             c[0].is_extended_negative and
1277                 c[0] is not S.NegativeOne):
1278             c[:1] = [S.NegativeOne, -c[0]]
1279 
1280         if cset:
1281             clen = len(c)
1282             c = set(c)
1283             if clen and warn and len(c) != clen:
1284                 raise ValueError('repeated commutative arguments: %s' %
1285                                  [ci for ci in c if list(self.args).count(ci) > 1])
1286         return [c, nc]
1287 
1288     def coeff(self, x, n=1, right=False):
1289         """
1290         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1291         is zero then all terms independent of ``x`` will be returned.
1292 
1293         When ``x`` is noncommutative, the coefficient to the left (default) or
1294         right of ``x`` can be returned. The keyword 'right' is ignored when
1295         ``x`` is commutative.
1296 
1297         See Also
1298         ========
1299 
1300         as_coefficient: separate the expression into a coefficient and factor
1301         as_coeff_Add: separate the additive constant from an expression
1302         as_coeff_Mul: separate the multiplicative constant from an expression
1303         as_independent: separate x-dependent terms/factors from others
1304         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1305         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1306 
1307         Examples
1308         ========
1309 
1310         >>> from sympy import symbols
1311         >>> from sympy.abc import x, y, z
1312 
1313         You can select terms that have an explicit negative in front of them:
1314 
1315         >>> (-x + 2*y).coeff(-1)
1316         x
1317         >>> (x - 2*y).coeff(-1)
1318         2*y
1319 
1320         You can select terms with no Rational coefficient:
1321 
1322         >>> (x + 2*y).coeff(1)
1323         x
1324         >>> (3 + 2*x + 4*x**2).coeff(1)
1325         0
1326 
1327         You can select terms independent of x by making n=0; in this case
1328         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1329         of None):
1330 
1331         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1332         3
1333         >>> eq = ((x + 1)**3).expand() + 1
1334         >>> eq
1335         x**3 + 3*x**2 + 3*x + 2
1336         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1337         [1, 3, 3, 2]
1338         >>> eq -= 2
1339         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1340         [1, 3, 3, 0]
1341 
1342         You can select terms that have a numerical term in front of them:
1343 
1344         >>> (-x - 2*y).coeff(2)
1345         -y
1346         >>> from sympy import sqrt
1347         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1348         x
1349 
1350         The matching is exact:
1351 
1352         >>> (3 + 2*x + 4*x**2).coeff(x)
1353         2
1354         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1355         4
1356         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1357         0
1358         >>> (z*(x + y)**2).coeff((x + y)**2)
1359         z
1360         >>> (z*(x + y)**2).coeff(x + y)
1361         0
1362 
1363         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1364         from the following:
1365 
1366         >>> (x + z*(x + x*y)).coeff(x)
1367         1
1368 
1369         If such factoring is desired, factor_terms can be used first:
1370 
1371         >>> from sympy import factor_terms
1372         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1373         z*(y + 1) + 1
1374 
1375         >>> n, m, o = symbols('n m o', commutative=False)
1376         >>> n.coeff(n)
1377         1
1378         >>> (3*n).coeff(n)
1379         3
1380         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1381         1 + m
1382         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1383         m
1384 
1385         If there is more than one possible coefficient 0 is returned:
1386 
1387         >>> (n*m + m*n).coeff(n)
1388         0
1389 
1390         If there is only one possible coefficient, it is returned:
1391 
1392         >>> (n*m + x*m*n).coeff(m*n)
1393         x
1394         >>> (n*m + x*m*n).coeff(m*n, right=1)
1395         1
1396 
1397         """
1398         x = sympify(x)
1399         if not isinstance(x, Basic):
1400             return S.Zero
1401 
1402         n = as_int(n)
1403 
1404         if not x:
1405             return S.Zero
1406 
1407         if x == self:
1408             if n == 1:
1409                 return S.One
1410             return S.Zero
1411 
1412         if x is S.One:
1413             co = [a for a in Add.make_args(self)
1414                   if a.as_coeff_Mul()[0] is S.One]
1415             if not co:
1416                 return S.Zero
1417             return Add(*co)
1418 
1419         if n == 0:
1420             if x.is_Add and self.is_Add:
1421                 c = self.coeff(x, right=right)
1422                 if not c:
1423                     return S.Zero
1424                 if not right:
1425                     return self - Add(*[a*x for a in Add.make_args(c)])
1426                 return self - Add(*[x*a for a in Add.make_args(c)])
1427             return self.as_independent(x, as_Add=True)[0]
1428 
1429         # continue with the full method, looking for this power of x:
1430         x = x**n
1431 
1432         def incommon(l1, l2):
1433             if not l1 or not l2:
1434                 return []
1435             n = min(len(l1), len(l2))
1436             for i in range(n):
1437                 if l1[i] != l2[i]:
1438                     return l1[:i]
1439             return l1[:]
1440 
1441         def find(l, sub, first=True):
1442             """ Find where list sub appears in list l. When ``first`` is True
1443             the first occurrence from the left is returned, else the last
1444             occurrence is returned. Return None if sub is not in l.
1445 
1446             >> l = range(5)*2
1447             >> find(l, [2, 3])
1448             2
1449             >> find(l, [2, 3], first=0)
1450             7
1451             >> find(l, [2, 4])
1452             None
1453 
1454             """
1455             if not sub or not l or len(sub) > len(l):
1456                 return None
1457             n = len(sub)
1458             if not first:
1459                 l.reverse()
1460                 sub.reverse()
1461             for i in range(0, len(l) - n + 1):
1462                 if all(l[i + j] == sub[j] for j in range(n)):
1463                     break
1464             else:
1465                 i = None
1466             if not first:
1467                 l.reverse()
1468                 sub.reverse()
1469             if i is not None and not first:
1470                 i = len(l) - (i + n)
1471             return i
1472 
1473         co = []
1474         args = Add.make_args(self)
1475         self_c = self.is_commutative
1476         x_c = x.is_commutative
1477         if self_c and not x_c:
1478             return S.Zero
1479 
1480         if self_c:
1481             xargs = x.args_cnc(cset=True, warn=False)[0]
1482             for a in args:
1483                 margs = a.args_cnc(cset=True, warn=False)[0]
1484                 if len(xargs) > len(margs):
1485                     continue
1486                 resid = margs.difference(xargs)
1487                 if len(resid) + len(xargs) == len(margs):
1488                     co.append(Mul(*resid))
1489             if co == []:
1490                 return S.Zero
1491             elif co:
1492                 return Add(*co)
1493         elif x_c:
1494             xargs = x.args_cnc(cset=True, warn=False)[0]
1495             for a in args:
1496                 margs, nc = a.args_cnc(cset=True)
1497                 if len(xargs) > len(margs):
1498                     continue
1499                 resid = margs.difference(xargs)
1500                 if len(resid) + len(xargs) == len(margs):
1501                     co.append(Mul(*(list(resid) + nc)))
1502             if co == []:
1503                 return S.Zero
1504             elif co:
1505                 return Add(*co)
1506         else:  # both nc
1507             xargs, nx = x.args_cnc(cset=True)
1508             # find the parts that pass the commutative terms
1509             for a in args:
1510                 margs, nc = a.args_cnc(cset=True)
1511                 if len(xargs) > len(margs):
1512                     continue
1513                 resid = margs.difference(xargs)
1514                 if len(resid) + len(xargs) == len(margs):
1515                     co.append((resid, nc))
1516             # now check the non-comm parts
1517             if not co:
1518                 return S.Zero
1519             if all(n == co[0][1] for r, n in co):
1520                 ii = find(co[0][1], nx, right)
1521                 if ii is not None:
1522                     if not right:
1523                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1524                     else:
1525                         return Mul(*co[0][1][ii + len(nx):])
1526             beg = reduce(incommon, (n[1] for n in co))
1527             if beg:
1528                 ii = find(beg, nx, right)
1529                 if ii is not None:
1530                     if not right:
1531                         gcdc = co[0][0]
1532                         for i in range(1, len(co)):
1533                             gcdc = gcdc.intersection(co[i][0])
1534                             if not gcdc:
1535                                 break
1536                         return Mul(*(list(gcdc) + beg[:ii]))
1537                     else:
1538                         m = ii + len(nx)
1539                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1540             end = list(reversed(
1541                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1542             if end:
1543                 ii = find(end, nx, right)
1544                 if ii is not None:
1545                     if not right:
1546                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1547                     else:
1548                         return Mul(*end[ii + len(nx):])
1549             # look for single match
1550             hit = None
1551             for i, (r, n) in enumerate(co):
1552                 ii = find(n, nx, right)
1553                 if ii is not None:
1554                     if not hit:
1555                         hit = ii, r, n
1556                     else:
1557                         break
1558             else:
1559                 if hit:
1560                     ii, r, n = hit
1561                     if not right:
1562                         return Mul(*(list(r) + n[:ii]))
1563                     else:
1564                         return Mul(*n[ii + len(nx):])
1565 
1566             return S.Zero
1567 
1568     def as_expr(self, *gens):
1569         """
1570         Convert a polynomial to a SymPy expression.
1571 
1572         Examples
1573         ========
1574 
1575         >>> from sympy import sin
1576         >>> from sympy.abc import x, y
1577 
1578         >>> f = (x**2 + x*y).as_poly(x, y)
1579         >>> f.as_expr()
1580         x**2 + x*y
1581 
1582         >>> sin(x).as_expr()
1583         sin(x)
1584 
1585         """
1586         return self
1587 
1588     def as_coefficient(self, expr):
1589         """
1590         Extracts symbolic coefficient at the given expression. In
1591         other words, this functions separates 'self' into the product
1592         of 'expr' and 'expr'-free coefficient. If such separation
1593         is not possible it will return None.
1594 
1595         Examples
1596         ========
1597 
1598         >>> from sympy import E, pi, sin, I, Poly
1599         >>> from sympy.abc import x
1600 
1601         >>> E.as_coefficient(E)
1602         1
1603         >>> (2*E).as_coefficient(E)
1604         2
1605         >>> (2*sin(E)*E).as_coefficient(E)
1606 
1607         Two terms have E in them so a sum is returned. (If one were
1608         desiring the coefficient of the term exactly matching E then
1609         the constant from the returned expression could be selected.
1610         Or, for greater precision, a method of Poly can be used to
1611         indicate the desired term from which the coefficient is
1612         desired.)
1613 
1614         >>> (2*E + x*E).as_coefficient(E)
1615         x + 2
1616         >>> _.args[0]  # just want the exact match
1617         2
1618         >>> p = Poly(2*E + x*E); p
1619         Poly(x*E + 2*E, x, E, domain='ZZ')
1620         >>> p.coeff_monomial(E)
1621         2
1622         >>> p.nth(0, 1)
1623         2
1624 
1625         Since the following cannot be written as a product containing
1626         E as a factor, None is returned. (If the coefficient ``2*x`` is
1627         desired then the ``coeff`` method should be used.)
1628 
1629         >>> (2*E*x + x).as_coefficient(E)
1630         >>> (2*E*x + x).coeff(E)
1631         2*x
1632 
1633         >>> (E*(x + 1) + x).as_coefficient(E)
1634 
1635         >>> (2*pi*I).as_coefficient(pi*I)
1636         2
1637         >>> (2*I).as_coefficient(pi*I)
1638 
1639         See Also
1640         ========
1641 
1642         coeff: return sum of terms have a given factor
1643         as_coeff_Add: separate the additive constant from an expression
1644         as_coeff_Mul: separate the multiplicative constant from an expression
1645         as_independent: separate x-dependent terms/factors from others
1646         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1647         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1648 
1649 
1650         """
1651 
1652         r = self.extract_multiplicatively(expr)
1653         if r and not r.has(expr):
1654             return r
1655 
1656     def as_independent(self, *deps, **hint):
1657         """
1658         A mostly naive separation of a Mul or Add into arguments that are not
1659         are dependent on deps. To obtain as complete a separation of variables
1660         as possible, use a separation method first, e.g.:
1661 
1662         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1663         * .expand(mul=True) to change Add or Mul into Add
1664         * .expand(log=True) to change log expr into an Add
1665 
1666         The only non-naive thing that is done here is to respect noncommutative
1667         ordering of variables and to always return (0, 0) for `self` of zero
1668         regardless of hints.
1669 
1670         For nonzero `self`, the returned tuple (i, d) has the
1671         following interpretation:
1672 
1673         * i will has no variable that appears in deps
1674         * d will either have terms that contain variables that are in deps, or
1675           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1676         * if self is an Add then self = i + d
1677         * if self is a Mul then self = i*d
1678         * otherwise (self, S.One) or (S.One, self) is returned.
1679 
1680         To force the expression to be treated as an Add, use the hint as_Add=True
1681 
1682         Examples
1683         ========
1684 
1685         -- self is an Add
1686 
1687         >>> from sympy import sin, cos, exp
1688         >>> from sympy.abc import x, y, z
1689 
1690         >>> (x + x*y).as_independent(x)
1691         (0, x*y + x)
1692         >>> (x + x*y).as_independent(y)
1693         (x, x*y)
1694         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1695         (y + z, 2*x*sin(x) + x)
1696         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1697         (z, 2*x*sin(x) + x + y)
1698 
1699         -- self is a Mul
1700 
1701         >>> (x*sin(x)*cos(y)).as_independent(x)
1702         (cos(y), x*sin(x))
1703 
1704         non-commutative terms cannot always be separated out when self is a Mul
1705 
1706         >>> from sympy import symbols
1707         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1708         >>> (n1 + n1*n2).as_independent(n2)
1709         (n1, n1*n2)
1710         >>> (n2*n1 + n1*n2).as_independent(n2)
1711         (0, n1*n2 + n2*n1)
1712         >>> (n1*n2*n3).as_independent(n1)
1713         (1, n1*n2*n3)
1714         >>> (n1*n2*n3).as_independent(n2)
1715         (n1, n2*n3)
1716         >>> ((x-n1)*(x-y)).as_independent(x)
1717         (1, (x - y)*(x - n1))
1718 
1719         -- self is anything else:
1720 
1721         >>> (sin(x)).as_independent(x)
1722         (1, sin(x))
1723         >>> (sin(x)).as_independent(y)
1724         (sin(x), 1)
1725         >>> exp(x+y).as_independent(x)
1726         (1, exp(x + y))
1727 
1728         -- force self to be treated as an Add:
1729 
1730         >>> (3*x).as_independent(x, as_Add=True)
1731         (0, 3*x)
1732 
1733         -- force self to be treated as a Mul:
1734 
1735         >>> (3+x).as_independent(x, as_Add=False)
1736         (1, x + 3)
1737         >>> (-3+x).as_independent(x, as_Add=False)
1738         (1, x - 3)
1739 
1740         Note how the below differs from the above in making the
1741         constant on the dep term positive.
1742 
1743         >>> (y*(-3+x)).as_independent(x)
1744         (y, x - 3)
1745 
1746         -- use .as_independent() for true independence testing instead
1747            of .has(). The former considers only symbols in the free
1748            symbols while the latter considers all symbols
1749 
1750         >>> from sympy import Integral
1751         >>> I = Integral(x, (x, 1, 2))
1752         >>> I.has(x)
1753         True
1754         >>> x in I.free_symbols
1755         False
1756         >>> I.as_independent(x) == (I, 1)
1757         True
1758         >>> (I + x).as_independent(x) == (I, x)
1759         True
1760 
1761         Note: when trying to get independent terms, a separation method
1762         might need to be used first. In this case, it is important to keep
1763         track of what you send to this routine so you know how to interpret
1764         the returned values
1765 
1766         >>> from sympy import separatevars, log
1767         >>> separatevars(exp(x+y)).as_independent(x)
1768         (exp(y), exp(x))
1769         >>> (x + x*y).as_independent(y)
1770         (x, x*y)
1771         >>> separatevars(x + x*y).as_independent(y)
1772         (x, y + 1)
1773         >>> (x*(1 + y)).as_independent(y)
1774         (x, y + 1)
1775         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1776         (x, x*y)
1777         >>> a, b=symbols('a b', positive=True)
1778         >>> (log(a*b).expand(log=True)).as_independent(b)
1779         (log(a), log(b))
1780 
1781         See Also
1782         ========
1783         .separatevars(), .expand(log=True), Add.as_two_terms(),
1784         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1785         """
1786         from .symbol import Symbol
1787         from .add import _unevaluated_Add
1788         from .mul import _unevaluated_Mul
1789         from sympy.utilities.iterables import sift
1790 
1791         if self.is_zero:
1792             return S.Zero, S.Zero
1793 
1794         func = self.func
1795         if hint.get('as_Add', isinstance(self, Add) ):
1796             want = Add
1797         else:
1798             want = Mul
1799 
1800         # sift out deps into symbolic and other and ignore
1801         # all symbols but those that are in the free symbols
1802         sym = set()
1803         other = []
1804         for d in deps:
1805             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1806                 sym.add(d)
1807             else:
1808                 other.append(d)
1809 
1810         def has(e):
1811             """return the standard has() if there are no literal symbols, else
1812             check to see that symbol-deps are in the free symbols."""
1813             has_other = e.has(*other)
1814             if not sym:
1815                 return has_other
1816             return has_other or e.has(*(e.free_symbols & sym))
1817 
1818         if (want is not func or
1819                 func is not Add and func is not Mul):
1820             if has(self):
1821                 return (want.identity, self)
1822             else:
1823                 return (self, want.identity)
1824         else:
1825             if func is Add:
1826                 args = list(self.args)
1827             else:
1828                 args, nc = self.args_cnc()
1829 
1830         d = sift(args, lambda x: has(x))
1831         depend = d[True]
1832         indep = d[False]
1833         if func is Add:  # all terms were treated as commutative
1834             return (Add(*indep), _unevaluated_Add(*depend))
1835         else:  # handle noncommutative by stopping at first dependent term
1836             for i, n in enumerate(nc):
1837                 if has(n):
1838                     depend.extend(nc[i:])
1839                     break
1840                 indep.append(n)
1841             return Mul(*indep), (
1842                 Mul(*depend, evaluate=False) if nc else
1843                 _unevaluated_Mul(*depend))
1844 
1845     def as_real_imag(self, deep=True, **hints):
1846         """Performs complex expansion on 'self' and returns a tuple
1847            containing collected both real and imaginary parts. This
1848            method can't be confused with re() and im() functions,
1849            which does not perform complex expansion at evaluation.
1850 
1851            However it is possible to expand both re() and im()
1852            functions and get exactly the same results as with
1853            a single call to this function.
1854 
1855            >>> from sympy import symbols, I
1856 
1857            >>> x, y = symbols('x,y', real=True)
1858 
1859            >>> (x + y*I).as_real_imag()
1860            (x, y)
1861 
1862            >>> from sympy.abc import z, w
1863 
1864            >>> (z + w*I).as_real_imag()
1865            (re(z) - im(w), re(w) + im(z))
1866 
1867         """
1868         from sympy import im, re
1869         if hints.get('ignore') == self:
1870             return None
1871         else:
1872             return (re(self), im(self))
1873 
1874     def as_powers_dict(self):
1875         """Return self as a dictionary of factors with each factor being
1876         treated as a power. The keys are the bases of the factors and the
1877         values, the corresponding exponents. The resulting dictionary should
1878         be used with caution if the expression is a Mul and contains non-
1879         commutative factors since the order that they appeared will be lost in
1880         the dictionary.
1881 
1882         See Also
1883         ========
1884         as_ordered_factors: An alternative for noncommutative applications,
1885                             returning an ordered list of factors.
1886         args_cnc: Similar to as_ordered_factors, but guarantees separation
1887                   of commutative and noncommutative factors.
1888         """
1889         d = defaultdict(int)
1890         d.update(dict([self.as_base_exp()]))
1891         return d
1892 
1893     def as_coefficients_dict(self):
1894         """Return a dictionary mapping terms to their Rational coefficient.
1895         Since the dictionary is a defaultdict, inquiries about terms which
1896         were not present will return a coefficient of 0. If an expression is
1897         not an Add it is considered to have a single term.
1898 
1899         Examples
1900         ========
1901 
1902         >>> from sympy.abc import a, x
1903         >>> (3*x + a*x + 4).as_coefficients_dict()
1904         {1: 4, x: 3, a*x: 1}
1905         >>> _[a]
1906         0
1907         >>> (3*a*x).as_coefficients_dict()
1908         {a*x: 3}
1909 
1910         """
1911         c, m = self.as_coeff_Mul()
1912         if not c.is_Rational:
1913             c = S.One
1914             m = self
1915         d = defaultdict(int)
1916         d.update({m: c})
1917         return d
1918 
1919     def as_base_exp(self):
1920         # a -> b ** e
1921         return self, S.One
1922 
1923     def as_coeff_mul(self, *deps, **kwargs):
1924         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1925 
1926         c should be a Rational multiplied by any factors of the Mul that are
1927         independent of deps.
1928 
1929         args should be a tuple of all other factors of m; args is empty
1930         if self is a Number or if self is independent of deps (when given).
1931 
1932         This should be used when you don't know if self is a Mul or not but
1933         you want to treat self as a Mul or if you want to process the
1934         individual arguments of the tail of self as a Mul.
1935 
1936         - if you know self is a Mul and want only the head, use self.args[0];
1937         - if you don't want to process the arguments of the tail but need the
1938           tail then use self.as_two_terms() which gives the head and tail;
1939         - if you want to split self into an independent and dependent parts
1940           use ``self.as_independent(*deps)``
1941 
1942         >>> from sympy import S
1943         >>> from sympy.abc import x, y
1944         >>> (S(3)).as_coeff_mul()
1945         (3, ())
1946         >>> (3*x*y).as_coeff_mul()
1947         (3, (x, y))
1948         >>> (3*x*y).as_coeff_mul(x)
1949         (3*y, (x,))
1950         >>> (3*y).as_coeff_mul(x)
1951         (3*y, ())
1952         """
1953         if deps:
1954             if not self.has(*deps):
1955                 return self, tuple()
1956         return S.One, (self,)
1957 
1958     def as_coeff_add(self, *deps):
1959         """Return the tuple (c, args) where self is written as an Add, ``a``.
1960 
1961         c should be a Rational added to any terms of the Add that are
1962         independent of deps.
1963 
1964         args should be a tuple of all other terms of ``a``; args is empty
1965         if self is a Number or if self is independent of deps (when given).
1966 
1967         This should be used when you don't know if self is an Add or not but
1968         you want to treat self as an Add or if you want to process the
1969         individual arguments of the tail of self as an Add.
1970 
1971         - if you know self is an Add and want only the head, use self.args[0];
1972         - if you don't want to process the arguments of the tail but need the
1973           tail then use self.as_two_terms() which gives the head and tail.
1974         - if you want to split self into an independent and dependent parts
1975           use ``self.as_independent(*deps)``
1976 
1977         >>> from sympy import S
1978         >>> from sympy.abc import x, y
1979         >>> (S(3)).as_coeff_add()
1980         (3, ())
1981         >>> (3 + x).as_coeff_add()
1982         (3, (x,))
1983         >>> (3 + x + y).as_coeff_add(x)
1984         (y + 3, (x,))
1985         >>> (3 + y).as_coeff_add(x)
1986         (y + 3, ())
1987 
1988         """
1989         if deps:
1990             if not self.has(*deps):
1991                 return self, tuple()
1992         return S.Zero, (self,)
1993 
1994     def primitive(self):
1995         """Return the positive Rational that can be extracted non-recursively
1996         from every term of self (i.e., self is treated like an Add). This is
1997         like the as_coeff_Mul() method but primitive always extracts a positive
1998         Rational (never a negative or a Float).
1999 
2000         Examples
2001         ========
2002 
2003         >>> from sympy.abc import x
2004         >>> (3*(x + 1)**2).primitive()
2005         (3, (x + 1)**2)
2006         >>> a = (6*x + 2); a.primitive()
2007         (2, 3*x + 1)
2008         >>> b = (x/2 + 3); b.primitive()
2009         (1/2, x + 6)
2010         >>> (a*b).primitive() == (1, a*b)
2011         True
2012         """
2013         if not self:
2014             return S.One, S.Zero
2015         c, r = self.as_coeff_Mul(rational=True)
2016         if c.is_negative:
2017             c, r = -c, -r
2018         return c, r
2019 
2020     def as_content_primitive(self, radical=False, clear=True):
2021         """This method should recursively remove a Rational from all arguments
2022         and return that (content) and the new self (primitive). The content
2023         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2024         The primitive need not be in canonical form and should try to preserve
2025         the underlying structure if possible (i.e. expand_mul should not be
2026         applied to self).
2027 
2028         Examples
2029         ========
2030 
2031         >>> from sympy import sqrt
2032         >>> from sympy.abc import x, y, z
2033 
2034         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2035 
2036         The as_content_primitive function is recursive and retains structure:
2037 
2038         >>> eq.as_content_primitive()
2039         (2, x + 3*y*(y + 1) + 1)
2040 
2041         Integer powers will have Rationals extracted from the base:
2042 
2043         >>> ((2 + 6*x)**2).as_content_primitive()
2044         (4, (3*x + 1)**2)
2045         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2046         (1, (2*(3*x + 1))**(2*y))
2047 
2048         Terms may end up joining once their as_content_primitives are added:
2049 
2050         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2051         (11, x*(y + 1))
2052         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2053         (9, x*(y + 1))
2054         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2055         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2056         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2057         (121, x**2*(y + 1)**2)
2058         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
2059         (1, 121.0*x**2*(y + 1)**2)
2060 
2061         Radical content can also be factored out of the primitive:
2062 
2063         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2064         (2, sqrt(2)*(1 + 2*sqrt(5)))
2065 
2066         If clear=False (default is True) then content will not be removed
2067         from an Add if it can be distributed to leave one or more
2068         terms with integer coefficients.
2069 
2070         >>> (x/2 + y).as_content_primitive()
2071         (1/2, x + 2*y)
2072         >>> (x/2 + y).as_content_primitive(clear=False)
2073         (1, x/2 + y)
2074         """
2075         return S.One, self
2076 
2077     def as_numer_denom(self):
2078         """ expression -> a/b -> a, b
2079 
2080         This is just a stub that should be defined by
2081         an object's class methods to get anything else.
2082 
2083         See Also
2084         ========
2085         normal: return a/b instead of a, b
2086         """
2087 
2088         return self, S.One
2089 
2090     def normal(self):
2091         from .mul import _unevaluated_Mul
2092         n, d = self.as_numer_denom()
2093         if d is S.One:
2094             return n
2095         if d.is_Number:
2096             return _unevaluated_Mul(n, 1/d)
2097         else:
2098             return n/d
2099 
2100     def extract_multiplicatively(self, c):
2101         """Return None if it's not possible to make self in the form
2102            c * something in a nice way, i.e. preserving the properties
2103            of arguments of self.
2104 
2105            Examples
2106            ========
2107 
2108            >>> from sympy import symbols, Rational
2109 
2110            >>> x, y = symbols('x,y', real=True)
2111 
2112            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2113            x*y**2
2114 
2115            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2116 
2117            >>> (2*x).extract_multiplicatively(2)
2118            x
2119 
2120            >>> (2*x).extract_multiplicatively(3)
2121 
2122            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2123            x/6
2124 
2125         """
2126         c = sympify(c)
2127         if self is S.NaN:
2128             return None
2129         if c is S.One:
2130             return self
2131         elif c == self:
2132             return S.One
2133 
2134         if c.is_Add:
2135             cc, pc = c.primitive()
2136             if cc is not S.One:
2137                 c = Mul(cc, pc, evaluate=False)
2138 
2139         if c.is_Mul:
2140             a, b = c.as_two_terms()
2141             x = self.extract_multiplicatively(a)
2142             if x is not None:
2143                 return x.extract_multiplicatively(b)
2144 
2145         quotient = self / c
2146         if self.is_Number:
2147             if self is S.Infinity:
2148                 if c.is_positive:
2149                     return S.Infinity
2150             elif self is S.NegativeInfinity:
2151                 if c.is_negative:
2152                     return S.Infinity
2153                 elif c.is_positive:
2154                     return S.NegativeInfinity
2155             elif self is S.ComplexInfinity:
2156                 if not c.is_zero:
2157                     return S.ComplexInfinity
2158             elif self.is_Integer:
2159                 if not quotient.is_Integer:
2160                     return None
2161                 elif self.is_positive and quotient.is_negative:
2162                     return None
2163                 else:
2164                     return quotient
2165             elif self.is_Rational:
2166                 if not quotient.is_Rational:
2167                     return None
2168                 elif self.is_positive and quotient.is_negative:
2169                     return None
2170                 else:
2171                     return quotient
2172             elif self.is_Float:
2173                 if not quotient.is_Float:
2174                     return None
2175                 elif self.is_positive and quotient.is_negative:
2176                     return None
2177                 else:
2178                     return quotient
2179         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2180             if quotient.is_Mul and len(quotient.args) == 2:
2181                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2182                     return quotient
2183             elif quotient.is_Integer and c.is_Number:
2184                 return quotient
2185         elif self.is_Add:
2186             cs, ps = self.primitive()
2187             # assert cs >= 1
2188             if c.is_Number and c is not S.NegativeOne:
2189                 # assert c != 1 (handled at top)
2190                 if cs is not S.One:
2191                     if c.is_negative:
2192                         xc = -(cs.extract_multiplicatively(-c))
2193                     else:
2194                         xc = cs.extract_multiplicatively(c)
2195                     if xc is not None:
2196                         return xc*ps  # rely on 2-arg Mul to restore Add
2197                 return  # |c| != 1 can only be extracted from cs
2198             if c == ps:
2199                 return cs
2200             # check args of ps
2201             newargs = []
2202             for arg in ps.args:
2203                 newarg = arg.extract_multiplicatively(c)
2204                 if newarg is None:
2205                     return  # all or nothing
2206                 newargs.append(newarg)
2207             # args should be in same order so use unevaluated return
2208             if cs is not S.One:
2209                 return Add._from_args([cs*t for t in newargs])
2210             else:
2211                 return Add._from_args(newargs)
2212         elif self.is_Mul:
2213             args = list(self.args)
2214             for i, arg in enumerate(args):
2215                 newarg = arg.extract_multiplicatively(c)
2216                 if newarg is not None:
2217                     args[i] = newarg
2218                     return Mul(*args)
2219         elif self.is_Pow:
2220             if c.is_Pow and c.base == self.base:
2221                 new_exp = self.exp.extract_additively(c.exp)
2222                 if new_exp is not None:
2223                     return self.base ** (new_exp)
2224             elif c == self.base:
2225                 new_exp = self.exp.extract_additively(1)
2226                 if new_exp is not None:
2227                     return self.base ** (new_exp)
2228 
2229     def extract_additively(self, c):
2230         """Return self - c if it's possible to subtract c from self and
2231         make all matching coefficients move towards zero, else return None.
2232 
2233         Examples
2234         ========
2235 
2236         >>> from sympy.abc import x, y
2237         >>> e = 2*x + 3
2238         >>> e.extract_additively(x + 1)
2239         x + 2
2240         >>> e.extract_additively(3*x)
2241         >>> e.extract_additively(4)
2242         >>> (y*(x + 1)).extract_additively(x + 1)
2243         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2244         (x + 1)*(x + 2*y) + 3
2245 
2246         Sometimes auto-expansion will return a less simplified result
2247         than desired; gcd_terms might be used in such cases:
2248 
2249         >>> from sympy import gcd_terms
2250         >>> (4*x*(y + 1) + y).extract_additively(x)
2251         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2252         >>> gcd_terms(_)
2253         x*(4*y + 3) + y
2254 
2255         See Also
2256         ========
2257         extract_multiplicatively
2258         coeff
2259         as_coefficient
2260 
2261         """
2262 
2263         c = sympify(c)
2264         if self is S.NaN:
2265             return None
2266         if c is S.Zero:
2267             return self
2268         elif c == self:
2269             return S.Zero
2270         elif self is S.Zero:
2271             return None
2272 
2273         if self.is_Number:
2274             if not c.is_Number:
2275                 return None
2276             co = self
2277             diff = co - c
2278             # XXX should we match types? i.e should 3 - .1 succeed?
2279             if (co > 0 and diff > 0 and diff < co or
2280                     co < 0 and diff < 0 and diff > co):
2281                 return diff
2282             return None
2283 
2284         if c.is_Number:
2285             co, t = self.as_coeff_Add()
2286             xa = co.extract_additively(c)
2287             if xa is None:
2288                 return None
2289             return xa + t
2290 
2291         # handle the args[0].is_Number case separately
2292         # since we will have trouble looking for the coeff of
2293         # a number.
2294         if c.is_Add and c.args[0].is_Number:
2295             # whole term as a term factor
2296             co = self.coeff(c)
2297             xa0 = (co.extract_additively(1) or 0)*c
2298             if xa0:
2299                 diff = self - co*c
2300                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2301             # term-wise
2302             h, t = c.as_coeff_Add()
2303             sh, st = self.as_coeff_Add()
2304             xa = sh.extract_additively(h)
2305             if xa is None:
2306                 return None
2307             xa2 = st.extract_additively(t)
2308             if xa2 is None:
2309                 return None
2310             return xa + xa2
2311 
2312         # whole term as a term factor
2313         co = self.coeff(c)
2314         xa0 = (co.extract_additively(1) or 0)*c
2315         if xa0:
2316             diff = self - co*c
2317             return (xa0 + (diff.extract_additively(c) or diff)) or None
2318         # term-wise
2319         coeffs = []
2320         for a in Add.make_args(c):
2321             ac, at = a.as_coeff_Mul()
2322             co = self.coeff(at)
2323             if not co:
2324                 return None
2325             coc, cot = co.as_coeff_Add()
2326             xa = coc.extract_additively(ac)
2327             if xa is None:
2328                 return None
2329             self -= co*at
2330             coeffs.append((cot + xa)*at)
2331         coeffs.append(self)
2332         return Add(*coeffs)
2333 
2334     @property
2335     def expr_free_symbols(self):
2336         """
2337         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2338 
2339         Examples
2340         ========
2341 
2342         >>> from sympy.abc import x, y
2343         >>> (x + y).expr_free_symbols
2344         {x, y}
2345 
2346         If the expression is contained in a non-expression object, don't return
2347         the free symbols. Compare:
2348 
2349         >>> from sympy import Tuple
2350         >>> t = Tuple(x + y)
2351         >>> t.expr_free_symbols
2352         set()
2353         >>> t.free_symbols
2354         {x, y}
2355         """
2356         return {j for i in self.args for j in i.expr_free_symbols}
2357 
2358     def could_extract_minus_sign(self):
2359         """Return True if self is not in a canonical form with respect
2360         to its sign.
2361 
2362         For most expressions, e, there will be a difference in e and -e.
2363         When there is, True will be returned for one and False for the
2364         other; False will be returned if there is no difference.
2365 
2366         Examples
2367         ========
2368 
2369         >>> from sympy.abc import x, y
2370         >>> e = x - y
2371         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2372         {False, True}
2373 
2374         """
2375         negative_self = -self
2376         if self == negative_self:
2377             return False  # e.g. zoo*x == -zoo*x
2378         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2379         negative_self_has_minus = (
2380             (negative_self).extract_multiplicatively(-1) is not None)
2381         if self_has_minus != negative_self_has_minus:
2382             return self_has_minus
2383         else:
2384             if self.is_Add:
2385                 # We choose the one with less arguments with minus signs
2386                 all_args = len(self.args)
2387                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2388                 positive_args = all_args - negative_args
2389                 if positive_args > negative_args:
2390                     return False
2391                 elif positive_args < negative_args:
2392                     return True
2393             elif self.is_Mul:
2394                 # We choose the one with an odd number of minus signs
2395                 num, den = self.as_numer_denom()
2396                 args = Mul.make_args(num) + Mul.make_args(den)
2397                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2398                 negative_args = list(filter(None, arg_signs))
2399                 return len(negative_args) % 2 == 1
2400 
2401             # As a last resort, we choose the one with greater value of .sort_key()
2402             return bool(self.sort_key() < negative_self.sort_key())
2403 
2404     def extract_branch_factor(self, allow_half=False):
2405         """
2406         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2407         Return (z, n).
2408 
2409         >>> from sympy import exp_polar, I, pi
2410         >>> from sympy.abc import x, y
2411         >>> exp_polar(I*pi).extract_branch_factor()
2412         (exp_polar(I*pi), 0)
2413         >>> exp_polar(2*I*pi).extract_branch_factor()
2414         (1, 1)
2415         >>> exp_polar(-pi*I).extract_branch_factor()
2416         (exp_polar(I*pi), -1)
2417         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2418         (exp_polar(x + I*pi), 1)
2419         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2420         (y*exp_polar(2*pi*x), -1)
2421         >>> exp_polar(-I*pi/2).extract_branch_factor()
2422         (exp_polar(-I*pi/2), 0)
2423 
2424         If allow_half is True, also extract exp_polar(I*pi):
2425 
2426         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2427         (1, 1/2)
2428         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2429         (1, 1)
2430         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2431         (1, 3/2)
2432         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2433         (1, -1/2)
2434         """
2435         from sympy import exp_polar, pi, I, ceiling, Add
2436         n = S(0)
2437         res = S(1)
2438         args = Mul.make_args(self)
2439         exps = []
2440         for arg in args:
2441             if isinstance(arg, exp_polar):
2442                 exps += [arg.exp]
2443             else:
2444                 res *= arg
2445         piimult = S(0)
2446         extras = []
2447         while exps:
2448             exp = exps.pop()
2449             if exp.is_Add:
2450                 exps += exp.args
2451                 continue
2452             if exp.is_Mul:
2453                 coeff = exp.as_coefficient(pi*I)
2454                 if coeff is not None:
2455                     piimult += coeff
2456                     continue
2457             extras += [exp]
2458         if piimult.is_number:
2459             coeff = piimult
2460             tail = ()
2461         else:
2462             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2463         # round down to nearest multiple of 2
2464         branchfact = ceiling(coeff/2 - S(1)/2)*2
2465         n += branchfact/2
2466         c = coeff - branchfact
2467         if allow_half:
2468             nc = c.extract_additively(1)
2469             if nc is not None:
2470                 n += S(1)/2
2471                 c = nc
2472         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2473         if newexp != 0:
2474             res *= exp_polar(newexp)
2475         return res, n
2476 
2477     def _eval_is_polynomial(self, syms):
2478         if self.free_symbols.intersection(syms) == set([]):
2479             return True
2480         return False
2481 
2482     def is_polynomial(self, *syms):
2483         r"""
2484         Return True if self is a polynomial in syms and False otherwise.
2485 
2486         This checks if self is an exact polynomial in syms.  This function
2487         returns False for expressions that are "polynomials" with symbolic
2488         exponents.  Thus, you should be able to apply polynomial algorithms to
2489         expressions for which this returns True, and Poly(expr, \*syms) should
2490         work if and only if expr.is_polynomial(\*syms) returns True. The
2491         polynomial does not have to be in expanded form.  If no symbols are
2492         given, all free symbols in the expression will be used.
2493 
2494         This is not part of the assumptions system.  You cannot do
2495         Symbol('z', polynomial=True).
2496 
2497         Examples
2498         ========
2499 
2500         >>> from sympy import Symbol
2501         >>> x = Symbol('x')
2502         >>> ((x**2 + 1)**4).is_polynomial(x)
2503         True
2504         >>> ((x**2 + 1)**4).is_polynomial()
2505         True
2506         >>> (2**x + 1).is_polynomial(x)
2507         False
2508 
2509 
2510         >>> n = Symbol('n', nonnegative=True, integer=True)
2511         >>> (x**n + 1).is_polynomial(x)
2512         False
2513 
2514         This function does not attempt any nontrivial simplifications that may
2515         result in an expression that does not appear to be a polynomial to
2516         become one.
2517 
2518         >>> from sympy import sqrt, factor, cancel
2519         >>> y = Symbol('y', positive=True)
2520         >>> a = sqrt(y**2 + 2*y + 1)
2521         >>> a.is_polynomial(y)
2522         False
2523         >>> factor(a)
2524         y + 1
2525         >>> factor(a).is_polynomial(y)
2526         True
2527 
2528         >>> b = (y**2 + 2*y + 1)/(y + 1)
2529         >>> b.is_polynomial(y)
2530         False
2531         >>> cancel(b)
2532         y + 1
2533         >>> cancel(b).is_polynomial(y)
2534         True
2535 
2536         See also .is_rational_function()
2537 
2538         """
2539         if syms:
2540             syms = set(map(sympify, syms))
2541         else:
2542             syms = self.free_symbols
2543 
2544         if syms.intersection(self.free_symbols) == set([]):
2545             # constant polynomial
2546             return True
2547         else:
2548             return self._eval_is_polynomial(syms)
2549 
2550     def _eval_is_rational_function(self, syms):
2551         if self.free_symbols.intersection(syms) == set([]):
2552             return True
2553         return False
2554 
2555     def is_rational_function(self, *syms):
2556         """
2557         Test whether function is a ratio of two polynomials in the given
2558         symbols, syms. When syms is not given, all free symbols will be used.
2559         The rational function does not have to be in expanded or in any kind of
2560         canonical form.
2561 
2562         This function returns False for expressions that are "rational
2563         functions" with symbolic exponents.  Thus, you should be able to call
2564         .as_numer_denom() and apply polynomial algorithms to the result for
2565         expressions for which this returns True.
2566 
2567         This is not part of the assumptions system.  You cannot do
2568         Symbol('z', rational_function=True).
2569 
2570         Examples
2571         ========
2572 
2573         >>> from sympy import Symbol, sin
2574         >>> from sympy.abc import x, y
2575 
2576         >>> (x/y).is_rational_function()
2577         True
2578 
2579         >>> (x**2).is_rational_function()
2580         True
2581 
2582         >>> (x/sin(y)).is_rational_function(y)
2583         False
2584 
2585         >>> n = Symbol('n', integer=True)
2586         >>> (x**n + 1).is_rational_function(x)
2587         False
2588 
2589         This function does not attempt any nontrivial simplifications that may
2590         result in an expression that does not appear to be a rational function
2591         to become one.
2592 
2593         >>> from sympy import sqrt, factor
2594         >>> y = Symbol('y', positive=True)
2595         >>> a = sqrt(y**2 + 2*y + 1)/y
2596         >>> a.is_rational_function(y)
2597         False
2598         >>> factor(a)
2599         (y + 1)/y
2600         >>> factor(a).is_rational_function(y)
2601         True
2602 
2603         See also is_algebraic_expr().
2604 
2605         """
2606         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2607             return False
2608 
2609         if syms:
2610             syms = set(map(sympify, syms))
2611         else:
2612             syms = self.free_symbols
2613 
2614         if syms.intersection(self.free_symbols) == set([]):
2615             # constant rational function
2616             return True
2617         else:
2618             return self._eval_is_rational_function(syms)
2619 
2620     def _eval_is_algebraic_expr(self, syms):
2621         if self.free_symbols.intersection(syms) == set([]):
2622             return True
2623         return False
2624 
2625     def is_algebraic_expr(self, *syms):
2626         """
2627         This tests whether a given expression is algebraic or not, in the
2628         given symbols, syms. When syms is not given, all free symbols
2629         will be used. The rational function does not have to be in expanded
2630         or in any kind of canonical form.
2631 
2632         This function returns False for expressions that are "algebraic
2633         expressions" with symbolic exponents. This is a simple extension to the
2634         is_rational_function, including rational exponentiation.
2635 
2636         Examples
2637         ========
2638 
2639         >>> from sympy import Symbol, sqrt
2640         >>> x = Symbol('x', real=True)
2641         >>> sqrt(1 + x).is_rational_function()
2642         False
2643         >>> sqrt(1 + x).is_algebraic_expr()
2644         True
2645 
2646         This function does not attempt any nontrivial simplifications that may
2647         result in an expression that does not appear to be an algebraic
2648         expression to become one.
2649 
2650         >>> from sympy import exp, factor
2651         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2652         >>> a.is_algebraic_expr(x)
2653         False
2654         >>> factor(a).is_algebraic_expr()
2655         True
2656 
2657         See Also
2658         ========
2659         is_rational_function()
2660 
2661         References
2662         ==========
2663 
2664         - https://en.wikipedia.org/wiki/Algebraic_expression
2665 
2666         """
2667         if syms:
2668             syms = set(map(sympify, syms))
2669         else:
2670             syms = self.free_symbols
2671 
2672         if syms.intersection(self.free_symbols) == set([]):
2673             # constant algebraic expression
2674             return True
2675         else:
2676             return self._eval_is_algebraic_expr(syms)
2677 
2678     ###################################################################################
2679     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2680     ###################################################################################
2681 
2682     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2683         """
2684         Series expansion of "self" around ``x = x0`` yielding either terms of
2685         the series one by one (the lazy series given when n=None), else
2686         all the terms at once when n != None.
2687 
2688         Returns the series expansion of "self" around the point ``x = x0``
2689         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2690 
2691         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2692         be supplied, otherwise an error will be raised.
2693 
2694         >>> from sympy import cos, exp
2695         >>> from sympy.abc import x, y
2696         >>> cos(x).series()
2697         1 - x**2/2 + x**4/24 + O(x**6)
2698         >>> cos(x).series(n=4)
2699         1 - x**2/2 + O(x**4)
2700         >>> cos(x).series(x, x0=1, n=2)
2701         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2702         >>> e = cos(x + exp(y))
2703         >>> e.series(y, n=2)
2704         cos(x + 1) - y*sin(x + 1) + O(y**2)
2705         >>> e.series(x, n=2)
2706         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2707 
2708         If ``n=None`` then a generator of the series terms will be returned.
2709 
2710         >>> term=cos(x).series(n=None)
2711         >>> [next(term) for i in range(2)]
2712         [1, -x**2/2]
2713 
2714         For ``dir=+`` (default) the series is calculated from the right and
2715         for ``dir=-`` the series from the left. For smooth functions this
2716         flag will not alter the results.
2717 
2718         >>> abs(x).series(dir="+")
2719         x
2720         >>> abs(x).series(dir="-")
2721         -x
2722 
2723         """
2724         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2725         if x is None:
2726             syms = self.free_symbols
2727             if not syms:
2728                 return self
2729             elif len(syms) > 1:
2730                 raise ValueError('x must be given for multivariate functions.')
2731             x = syms.pop()
2732 
2733         if isinstance(x, Symbol):
2734             dep = x in self.free_symbols
2735         else:
2736             d = Dummy()
2737             dep = d in self.xreplace({x: d}).free_symbols
2738         if not dep:
2739             if n is None:
2740                 return (s for s in [self])
2741             else:
2742                 return self
2743 
2744         if len(dir) != 1 or dir not in '+-':
2745             raise ValueError("Dir must be '+' or '-'")
2746 
2747         if x0 in [S.Infinity, S.NegativeInfinity]:
2748             sgn = 1 if x0 is S.Infinity else -1
2749             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2750             if n is None:
2751                 return (si.subs(x, sgn/x) for si in s)
2752             return s.subs(x, sgn/x)
2753 
2754 
2755         # use rep to shift origin to x0 and change sign (if dir is negative)
2756         # and undo the process with rep2
2757         if x0 or dir == '-':
2758             if dir == '-':
2759                 rep = -x + x0
2760                 rep2 = -x
2761                 rep2b = x0
2762             else:
2763                 rep = x + x0
2764                 rep2 = x
2765                 rep2b = -x0
2766             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2767             if n is None:  # lseries...
2768                 return (si.subs(x, rep2 + rep2b) for si in s)
2769             return s.subs(x, rep2 + rep2b)
2770 
2771         # from here on it's x0=0 and dir='+' handling
2772 
2773         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2774             # replace x with an x that has a positive assumption
2775             xpos = Dummy('x', positive=True, finite=True)
2776             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2777             if n is None:
2778                 return (s.subs(xpos, x) for s in rv)
2779             else:
2780                 return rv.subs(xpos, x)
2781 
2782         if n is not None:  # nseries handling
2783             s1 = self._eval_nseries(x, n=n, logx=logx)
2784             o = s1.getO() or S.Zero
2785             if o:
2786                 # make sure the requested order is returned
2787                 ngot = o.getn()
2788                 if ngot > n:
2789                     # leave o in its current form (e.g. with x*log(x)) so
2790                     # it eats terms properly, then replace it below
2791                     if n != 0:
2792                         s1 += o.subs(x, x**Rational(n, ngot))
2793                     else:
2794                         s1 += Order(1, x)
2795                 elif ngot < n:
2796                     # increase the requested number of terms to get the desired
2797                     # number keep increasing (up to 9) until the received order
2798                     # is different than the original order and then predict how
2799                     # many additional terms are needed
2800                     for more in range(1, 9):
2801                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2802                         newn = s1.getn()
2803                         if newn != ngot:
2804                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2805                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2806                             while s1.getn() < n:
2807                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2808                                 ndo += 1
2809                             break
2810                     else:
2811                         raise ValueError('Could not calculate %s terms for %s'
2812                                          % (str(n), self))
2813                     s1 += Order(x**n, x)
2814                 o = s1.getO()
2815                 s1 = s1.removeO()
2816             else:
2817                 o = Order(x**n, x)
2818                 s1done = s1.doit()
2819                 if (s1done + o).removeO() == s1done:
2820                     o = S.Zero
2821 
2822             try:
2823                 return collect(s1, x) + o
2824             except NotImplementedError:
2825                 return s1 + o
2826 
2827         else:  # lseries handling
2828             def yield_lseries(s):
2829                 """Return terms of lseries one at a time."""
2830                 for si in s:
2831                     if not si.is_Add:
2832                         yield si
2833                         continue
2834                     # yield terms 1 at a time if possible
2835                     # by increasing order until all the
2836                     # terms have been returned
2837                     yielded = 0
2838                     o = Order(si, x)*x
2839                     ndid = 0
2840                     ndo = len(si.args)
2841                     while 1:
2842                         do = (si - yielded + o).removeO()
2843                         o *= x
2844                         if not do or do.is_Order:
2845                             continue
2846                         if do.is_Add:
2847                             ndid += len(do.args)
2848                         else:
2849                             ndid += 1
2850                         yield do
2851                         if ndid == ndo:
2852                             break
2853                         yielded += do
2854 
2855             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2856 
2857     def taylor_term(self, n, x, *previous_terms):
2858         """General method for the taylor term.
2859 
2860         This method is slow, because it differentiates n-times. Subclasses can
2861         redefine it to make it faster by using the "previous_terms".
2862         """
2863         from sympy import Dummy, factorial
2864         x = sympify(x)
2865         _x = Dummy('x')
2866         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2867 
2868     def lseries(self, x=None, x0=0, dir='+', logx=None):
2869         """
2870         Wrapper for series yielding an iterator of the terms of the series.
2871 
2872         Note: an infinite series will yield an infinite iterator. The following,
2873         for exaxmple, will never terminate. It will just keep printing terms
2874         of the sin(x) series::
2875 
2876           for term in sin(x).lseries(x):
2877               print term
2878 
2879         The advantage of lseries() over nseries() is that many times you are
2880         just interested in the next term in the series (i.e. the first term for
2881         example), but you don't know how many you should ask for in nseries()
2882         using the "n" parameter.
2883 
2884         See also nseries().
2885         """
2886         return self.series(x, x0, n=None, dir=dir, logx=logx)
2887 
2888     def _eval_lseries(self, x, logx=None):
2889         # default implementation of lseries is using nseries(), and adaptively
2890         # increasing the "n". As you can see, it is not very efficient, because
2891         # we are calculating the series over and over again. Subclasses should
2892         # override this method and implement much more efficient yielding of
2893         # terms.
2894         n = 0
2895         series = self._eval_nseries(x, n=n, logx=logx)
2896         if not series.is_Order:
2897             if series.is_Add:
2898                 yield series.removeO()
2899             else:
2900                 yield series
2901             return
2902 
2903         while series.is_Order:
2904             n += 1
2905             series = self._eval_nseries(x, n=n, logx=logx)
2906         e = series.removeO()
2907         yield e
2908         while 1:
2909             while 1:
2910                 n += 1
2911                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2912                 if e != series:
2913                     break
2914             yield series - e
2915             e = series
2916 
2917     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2918         """
2919         Wrapper to _eval_nseries if assumptions allow, else to series.
2920 
2921         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2922         called. This calculates "n" terms in the innermost expressions and
2923         then builds up the final series just by "cross-multiplying" everything
2924         out.
2925 
2926         The optional ``logx`` parameter can be used to replace any log(x) in the
2927         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2928         symbol to use in place of log(x) should be provided.
2929 
2930         Advantage -- it's fast, because we don't have to determine how many
2931         terms we need to calculate in advance.
2932 
2933         Disadvantage -- you may end up with less terms than you may have
2934         expected, but the O(x**n) term appended will always be correct and
2935         so the result, though perhaps shorter, will also be correct.
2936 
2937         If any of those assumptions is not met, this is treated like a
2938         wrapper to series which will try harder to return the correct
2939         number of terms.
2940 
2941         See also lseries().
2942 
2943         Examples
2944         ========
2945 
2946         >>> from sympy import sin, log, Symbol
2947         >>> from sympy.abc import x, y
2948         >>> sin(x).nseries(x, 0, 6)
2949         x - x**3/6 + x**5/120 + O(x**6)
2950         >>> log(x+1).nseries(x, 0, 5)
2951         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2952 
2953         Handling of the ``logx`` parameter --- in the following example the
2954         expansion fails since ``sin`` does not have an asymptotic expansion
2955         at -oo (the limit of log(x) as x approaches 0):
2956 
2957         >>> e = sin(log(x))
2958         >>> e.nseries(x, 0, 6)
2959         Traceback (most recent call last):
2960         ...
2961         PoleError: ...
2962         ...
2963         >>> logx = Symbol('logx')
2964         >>> e.nseries(x, 0, 6, logx=logx)
2965         sin(logx)
2966 
2967         In the following example, the expansion works but gives only an Order term
2968         unless the ``logx`` parameter is used:
2969 
2970         >>> e = x**y
2971         >>> e.nseries(x, 0, 2)
2972         O(log(x)**2)
2973         >>> e.nseries(x, 0, 2, logx=logx)
2974         exp(logx*y)
2975 
2976         """
2977         if x and not x in self.free_symbols:
2978             return self
2979         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2980             return self.series(x, x0, n, dir)
2981         else:
2982             return self._eval_nseries(x, n=n, logx=logx)
2983 
2984     def _eval_nseries(self, x, n, logx):
2985         """
2986         Return terms of series for self up to O(x**n) at x=0
2987         from the positive direction.
2988 
2989         This is a method that should be overridden in subclasses. Users should
2990         never call this method directly (use .nseries() instead), so you don't
2991         have to write docstrings for _eval_nseries().
2992         """
2993         from sympy.utilities.misc import filldedent
2994         raise NotImplementedError(filldedent("""
2995                      The _eval_nseries method should be added to
2996                      %s to give terms up to O(x**n) at x=0
2997                      from the positive direction so it is available when
2998                      nseries calls it.""" % self.func)
2999                      )
3000 
3001     def limit(self, x, xlim, dir='+'):
3002         """ Compute limit x->xlim.
3003         """
3004         from sympy.series.limits import limit
3005         return limit(self, x, xlim, dir)
3006 
3007     def compute_leading_term(self, x, logx=None):
3008         """
3009         as_leading_term is only allowed for results of .series()
3010         This is a wrapper to compute a series first.
3011         """
3012         from sympy import Dummy, log
3013         from sympy.series.gruntz import calculate_series
3014 
3015         if self.removeO() == 0:
3016             return self
3017 
3018         if logx is None:
3019             d = Dummy('logx')
3020             s = calculate_series(self, x, d).subs(d, log(x))
3021         else:
3022             s = calculate_series(self, x, logx)
3023 
3024         return s.as_leading_term(x)
3025 
3026     @cacheit
3027     def as_leading_term(self, *symbols):
3028         """
3029         Returns the leading (nonzero) term of the series expansion of self.
3030 
3031         The _eval_as_leading_term routines are used to do this, and they must
3032         always return a non-zero value.
3033 
3034         Examples
3035         ========
3036 
3037         >>> from sympy.abc import x
3038         >>> (1 + x + x**2).as_leading_term(x)
3039         1
3040         >>> (1/x**2 + x + x**2).as_leading_term(x)
3041         x**(-2)
3042 
3043         """
3044         from sympy import powsimp
3045         if len(symbols) > 1:
3046             c = self
3047             for x in symbols:
3048                 c = c.as_leading_term(x)
3049             return c
3050         elif not symbols:
3051             return self
3052         x = sympify(symbols[0])
3053         if not x.is_symbol:
3054             raise ValueError('expecting a Symbol but got %s' % x)
3055         if x not in self.free_symbols:
3056             return self
3057         obj = self._eval_as_leading_term(x)
3058         if obj is not None:
3059             return powsimp(obj, deep=True, combine='exp')
3060         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3061 
3062     def _eval_as_leading_term(self, x):
3063         return self
3064 
3065     def as_coeff_exponent(self, x):
3066         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3067         """
3068         from sympy import collect
3069         s = collect(self, x)
3070         c, p = s.as_coeff_mul(x)
3071         if len(p) == 1:
3072             b, e = p[0].as_base_exp()
3073             if b == x:
3074                 return c, e
3075         return s, S.Zero
3076 
3077     def leadterm(self, x):
3078         """
3079         Returns the leading term a*x**b as a tuple (a, b).
3080 
3081         Examples
3082         ========
3083 
3084         >>> from sympy.abc import x
3085         >>> (1+x+x**2).leadterm(x)
3086         (1, 0)
3087         >>> (1/x**2+x+x**2).leadterm(x)
3088         (1, -2)
3089 
3090         """
3091         from sympy import Dummy, log
3092         l = self.as_leading_term(x)
3093         d = Dummy('logx')
3094         if l.has(log(x)):
3095             l = l.subs(log(x), d)
3096         c, e = l.as_coeff_exponent(x)
3097         if x in c.free_symbols:
3098             from sympy.utilities.misc import filldedent
3099             raise ValueError(filldedent("""
3100                 cannot compute leadterm(%s, %s). The coefficient
3101                 should have been free of x but got %s""" % (self, x, c)))
3102         c = c.subs(d, log(x))
3103         return c, e
3104 
3105     def as_coeff_Mul(self, rational=False):
3106         """Efficiently extract the coefficient of a product. """
3107         return S.One, self
3108 
3109     def as_coeff_Add(self, rational=False):
3110         """Efficiently extract the coefficient of a summation. """
3111         return S.Zero, self
3112 
3113     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3114             full=False):
3115         """
3116         Compute formal power power series of self.
3117 
3118         See the docstring of the :func:`fps` function in sympy.series.formal for
3119         more information.
3120         """
3121         from sympy.series.formal import fps
3122 
3123         return fps(self, x, x0, dir, hyper, order, rational, full)
3124 
3125     def fourier_series(self, limits=None):
3126         """Compute fourier sine/cosine series of self.
3127 
3128         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3129         for more information.
3130         """
3131         from sympy.series.fourier import fourier_series
3132 
3133         return fourier_series(self, limits)
3134 
3135     ###################################################################################
3136     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3137     ###################################################################################
3138 
3139     def diff(self, *symbols, **assumptions):
3140         assumptions.setdefault("evaluate", True)
3141         return Derivative(self, *symbols, **assumptions)
3142 
3143     ###########################################################################
3144     ###################### EXPRESSION EXPANSION METHODS #######################
3145     ###########################################################################
3146 
3147     # Relevant subclasses should override _eval_expand_hint() methods.  See
3148     # the docstring of expand() for more info.
3149 
3150     def _eval_expand_complex(self, **hints):
3151         real, imag = self.as_real_imag(**hints)
3152         return real + S.ImaginaryUnit*imag
3153 
3154     @staticmethod
3155     def _expand_hint(expr, hint, deep=True, **hints):
3156         """
3157         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3158 
3159         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3160         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3161         ``False`` otherwise.
3162         """
3163         hit = False
3164         # XXX: Hack to support non-Basic args
3165         #              |
3166         #              V
3167         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3168             sargs = []
3169             for arg in expr.args:
3170                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3171                 hit |= arghit
3172                 sargs.append(arg)
3173 
3174             if hit:
3175                 expr = expr.func(*sargs)
3176 
3177         if hasattr(expr, hint):
3178             newexpr = getattr(expr, hint)(**hints)
3179             if newexpr != expr:
3180                 return (newexpr, True)
3181 
3182         return (expr, hit)
3183 
3184     @cacheit
3185     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3186             mul=True, log=True, multinomial=True, basic=True, **hints):
3187         """
3188         Expand an expression using hints.
3189 
3190         See the docstring of the expand() function in sympy.core.function for
3191         more information.
3192 
3193         """
3194         from sympy.simplify.radsimp import fraction
3195 
3196         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3197            log=log, multinomial=multinomial, basic=basic)
3198 
3199         expr = self
3200         if hints.pop('frac', False):
3201             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3202                     for a in fraction(self)]
3203             return n/d
3204         elif hints.pop('denom', False):
3205             n, d = fraction(self)
3206             return n/d.expand(deep=deep, modulus=modulus, **hints)
3207         elif hints.pop('numer', False):
3208             n, d = fraction(self)
3209             return n.expand(deep=deep, modulus=modulus, **hints)/d
3210 
3211         # Although the hints are sorted here, an earlier hint may get applied
3212         # at a given node in the expression tree before another because of how
3213         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3214         # x*z) because while applying log at the top level, log and mul are
3215         # applied at the deeper level in the tree so that when the log at the
3216         # upper level gets applied, the mul has already been applied at the
3217         # lower level.
3218 
3219         # Additionally, because hints are only applied once, the expression
3220         # may not be expanded all the way.   For example, if mul is applied
3221         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3222         # now, we just use a special case to make multinomial run before mul,
3223         # so that at least polynomials will be expanded all the way.  In the
3224         # future, smarter heuristics should be applied.
3225         # TODO: Smarter heuristics
3226 
3227         def _expand_hint_key(hint):
3228             """Make multinomial come before mul"""
3229             if hint == 'mul':
3230                 return 'mulz'
3231             return hint
3232 
3233         for hint in sorted(hints.keys(), key=_expand_hint_key):
3234             use_hint = hints[hint]
3235             if use_hint:
3236                 hint = '_eval_expand_' + hint
3237                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3238 
3239         while True:
3240             was = expr
3241             if hints.get('multinomial', False):
3242                 expr, _ = Expr._expand_hint(
3243                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3244             if hints.get('mul', False):
3245                 expr, _ = Expr._expand_hint(
3246                     expr, '_eval_expand_mul', deep=deep, **hints)
3247             if hints.get('log', False):
3248                 expr, _ = Expr._expand_hint(
3249                     expr, '_eval_expand_log', deep=deep, **hints)
3250             if expr == was:
3251                 break
3252 
3253         if modulus is not None:
3254             modulus = sympify(modulus)
3255 
3256             if not modulus.is_Integer or modulus <= 0:
3257                 raise ValueError(
3258                     "modulus must be a positive integer, got %s" % modulus)
3259 
3260             terms = []
3261 
3262             for term in Add.make_args(expr):
3263                 coeff, tail = term.as_coeff_Mul(rational=True)
3264 
3265                 coeff %= modulus
3266 
3267                 if coeff:
3268                     terms.append(coeff*tail)
3269 
3270             expr = Add(*terms)
3271 
3272         return expr
3273 
3274     ###########################################################################
3275     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3276     ###########################################################################
3277 
3278     def integrate(self, *args, **kwargs):
3279         """See the integrate function in sympy.integrals"""
3280         from sympy.integrals import integrate
3281         return integrate(self, *args, **kwargs)
3282 
3283     def simplify(self, ratio=1.7, measure=None, rational=False, inverse=False):
3284         """See the simplify function in sympy.simplify"""
3285         from sympy.simplify import simplify
3286         from sympy.core.function import count_ops
3287         measure = measure or count_ops
3288         return simplify(self, ratio, measure)
3289 
3290     def nsimplify(self, constants=[], tolerance=None, full=False):
3291         """See the nsimplify function in sympy.simplify"""
3292         from sympy.simplify import nsimplify
3293         return nsimplify(self, constants, tolerance, full)
3294 
3295     def separate(self, deep=False, force=False):
3296         """See the separate function in sympy.simplify"""
3297         from sympy.core.function import expand_power_base
3298         return expand_power_base(self, deep=deep, force=force)
3299 
3300     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3301         """See the collect function in sympy.simplify"""
3302         from sympy.simplify import collect
3303         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3304 
3305     def together(self, *args, **kwargs):
3306         """See the together function in sympy.polys"""
3307         from sympy.polys import together
3308         return together(self, *args, **kwargs)
3309 
3310     def apart(self, x=None, **args):
3311         """See the apart function in sympy.polys"""
3312         from sympy.polys import apart
3313         return apart(self, x, **args)
3314 
3315     def ratsimp(self):
3316         """See the ratsimp function in sympy.simplify"""
3317         from sympy.simplify import ratsimp
3318         return ratsimp(self)
3319 
3320     def trigsimp(self, **args):
3321         """See the trigsimp function in sympy.simplify"""
3322         from sympy.simplify import trigsimp
3323         return trigsimp(self, **args)
3324 
3325     def radsimp(self, **kwargs):
3326         """See the radsimp function in sympy.simplify"""
3327         from sympy.simplify import radsimp
3328         return radsimp(self, **kwargs)
3329 
3330     def powsimp(self, *args, **kwargs):
3331         """See the powsimp function in sympy.simplify"""
3332         from sympy.simplify import powsimp
3333         return powsimp(self, *args, **kwargs)
3334 
3335     def combsimp(self):
3336         """See the combsimp function in sympy.simplify"""
3337         from sympy.simplify import combsimp
3338         return combsimp(self)
3339 
3340     def gammasimp(self):
3341         """See the gammasimp function in sympy.simplify"""
3342         from sympy.simplify import gammasimp
3343         return gammasimp(self)
3344 
3345     def factor(self, *gens, **args):
3346         """See the factor() function in sympy.polys.polytools"""
3347         from sympy.polys import factor
3348         return factor(self, *gens, **args)
3349 
3350     def refine(self, assumption=True):
3351         """See the refine function in sympy.assumptions"""
3352         from sympy.assumptions import refine
3353         return refine(self, assumption)
3354 
3355     def cancel(self, *gens, **args):
3356         """See the cancel function in sympy.polys"""
3357         from sympy.polys import cancel
3358         return cancel(self, *gens, **args)
3359 
3360     def invert(self, g, *gens, **args):
3361         """Return the multiplicative inverse of ``self`` mod ``g``
3362         where ``self`` (and ``g``) may be symbolic expressions).
3363 
3364         See Also
3365         ========
3366         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3367         """
3368         from sympy.polys.polytools import invert
3369         from sympy.core.numbers import mod_inverse
3370         if self.is_number and getattr(g, 'is_number', True):
3371             return mod_inverse(self, g)
3372         return invert(self, g, *gens, **args)
3373 
3374     def round(self, n=None):
3375         """Return x rounded to the given decimal place.
3376 
3377         If a complex number would results, apply round to the real
3378         and imaginary components of the number.
3379 
3380         Examples
3381         ========
3382 
3383         >>> from sympy import pi, E, I, S, Add, Mul, Number
3384         >>> pi.round()
3385         3
3386         >>> pi.round(2)
3387         3.14
3388         >>> (2*pi + E*I).round()
3389         6 + 3*I
3390 
3391         The round method has a chopping effect:
3392 
3393         >>> (2*pi + I/10).round()
3394         6
3395         >>> (pi/10 + 2*I).round()
3396         2*I
3397         >>> (pi/10 + E*I).round(2)
3398         0.31 + 2.72*I
3399 
3400         Notes
3401         =====
3402 
3403         The Python builtin function, round, always returns a
3404         float in Python 2 while the SymPy round method (and
3405         round with a Number argument in Python 3) returns a
3406         Number.
3407 
3408         >>> from sympy.core.compatibility import PY3
3409         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3410         True
3411 
3412         For a consistent behavior, and Python 3 rounding
3413         rules, import `round` from sympy.core.compatibility.
3414 
3415         >>> from sympy.core.compatibility import round
3416         >>> isinstance(round(S(123), -2), Number)
3417         True
3418         """
3419         from sympy.core.power import integer_log
3420         from sympy.core.numbers import Float
3421 
3422         x = self
3423 
3424         if not x.is_number:
3425             raise TypeError("can't round symbolic expression")
3426         if not x.is_Atom:
3427             if not pure_complex(x.n(2), or_real=True):
3428                 raise TypeError(
3429                     'Expected a number but got %s:' % func_name(x))
3430         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3431             return x
3432         if not x.is_extended_real:
3433             i, r = x.as_real_imag()
3434             return i.round(n) + S.ImaginaryUnit*r.round(n)
3435         if not x:
3436             return S.Zero if n is None else x
3437 
3438 
3439         p = as_int(n or 0)
3440 
3441         if x.is_Integer:
3442             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3443             if p >= 0:
3444                 return x
3445             m = 10**-p
3446             i, r = divmod(abs(x), m)
3447             if i%2 and 2*r == m:
3448               i += 1
3449             elif 2*r > m:
3450                 i += 1
3451             if x < 0:
3452                 i *= -1
3453             return i*m
3454 
3455         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3456         allow = digits_needed = digits_to_decimal + p
3457         precs = [f._prec for f in x.atoms(Float)]
3458         dps = prec_to_dps(max(precs)) if precs else None
3459         if dps is None:
3460             # assume everything is exact so use the Python
3461             # float default or whatever was requested
3462             dps = max(15, allow)
3463         else:
3464             allow = min(allow, dps)
3465         # this will shift all digits to right of decimal
3466         # and give us dps to work with as an int
3467         shift = -digits_to_decimal + dps
3468         extra = 1  # how far we look past known digits
3469         # NOTE
3470         # mpmath will calculate the binary representation to
3471         # an arbitrary number of digits but we must base our
3472         # answer on a finite number of those digits, e.g.
3473         # .575 2589569785738035/2**52 in binary.
3474         # mpmath shows us that the first 18 digits are
3475         #     >>> Float(.575).n(18)
3476         #     0.574999999999999956
3477         # The default precision is 15 digits and if we ask
3478         # for 15 we get
3479         #     >>> Float(.575).n(15)
3480         #     0.575000000000000
3481         # mpmath handles rounding at the 15th digit. But we
3482         # need to be careful since the user might be asking
3483         # for rounding at the last digit and our semantics
3484         # are to round toward the even final digit when there
3485         # is a tie. So the extra digit will be used to make
3486         # that decision. In this case, the value is the same
3487         # to 15 digits:
3488         #     >>> Float(.575).n(16)
3489         #     0.5750000000000000
3490         # Now converting this to the 15 known digits gives
3491         #     575000000000000.0
3492         # which rounds to integer
3493         #    5750000000000000
3494         # And now we can round to the desired digt, e.g. at
3495         # the second from the left and we get
3496         #    5800000000000000
3497         # and rescaling that gives
3498         #    0.58
3499         # as the final result.
3500         # If the value is made slightly less than 0.575 we might
3501         # still obtain the same value:
3502         #    >>> Float(.575-1e-16).n(16)*10**15
3503         #    574999999999999.8
3504         # What 15 digits best represents the known digits (which are
3505         # to the left of the decimal? 5750000000000000, the same as
3506         # before. The only way we will round down (in this case) is
3507         # if we declared that we had more than 15 digits of precision.
3508         # For example, if we use 16 digits of precision, the integer
3509         # we deal with is
3510         #    >>> Float(.575-1e-16).n(17)*10**16
3511         #    5749999999999998.4
3512         # and this now rounds to 5749999999999998 and (if we round to
3513         # the 2nd digit from the left) we get 5700000000000000.
3514         #
3515         xf = x.n(dps + extra)*Pow(10, shift)
3516         xi = Integer(xf)
3517         # use the last digit to select the value of xi
3518         # nearest to x before rounding at the desired digit
3519         sign = 1 if x > 0 else -1
3520         dif2 = sign*(xf - xi).n(extra)
3521         if dif2 < 0:
3522             raise NotImplementedError(
3523                 'not expecting int(x) to round away from 0')
3524         if dif2 > .5:
3525             xi += sign  # round away from 0
3526         elif dif2 == .5:
3527             xi += sign if xi%2 else -sign  # round toward even
3528         # shift p to the new position
3529         ip = p - shift
3530         # let Python handle the int rounding then rescale
3531         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3532         # restore scale
3533         rv = Rational(xr, Pow(10, shift))
3534         # return Float or Integer
3535         if rv.is_Integer:
3536             if n is None:  # the single-arg case
3537                 return rv
3538             # use str or else it won't be a float
3539             return Float(str(rv), dps)  # keep same precision
3540         else:
3541             if not allow and rv > self:
3542                 allow += 1
3543             return Float(rv, allow)
3544 
3545     __round__ = round
3546 
3547     def _eval_derivative_matrix_lines(self, x):
3548         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3549         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-16 02:55:40.511 | INFO     | Search completed. Bug locations: [<file>sympy/series/formal.py</file>
<class>None</class>
<method>fps</method>
<code>
1183 def fps(f, x=None, x0=0, dir=1, hyper=True, order=4, rational=True, full=False):
1184     """Generates Formal Power Series of f.
1185 
1186     Returns the formal series expansion of ``f`` around ``x = x0``
1187     with respect to ``x`` in the form of a ``FormalPowerSeries`` object.
1188 
1189     Formal Power Series is represented using an explicit formula
1190     computed using different algorithms.
1191 
1192     See :func:`compute_fps` for the more details regarding the computation
1193     of formula.
1194 
1195     Parameters
1196     ==========
1197 
1198     x : Symbol, optional
1199         If x is None and ``f`` is univariate, the univariate symbols will be
1200         supplied, otherwise an error will be raised.
1201     x0 : number, optional
1202         Point to perform series expansion about. Default is 0.
1203     dir : {1, -1, '+', '-'}, optional
1204         If dir is 1 or '+' the series is calculated from the right and
1205         for -1 or '-' the series is calculated from the left. For smooth
1206         functions this flag will not alter the results. Default is 1.
1207     hyper : {True, False}, optional
1208         Set hyper to False to skip the hypergeometric algorithm.
1209         By default it is set to False.
1210     order : int, optional
1211         Order of the derivative of ``f``, Default is 4.
1212     rational : {True, False}, optional
1213         Set rational to False to skip rational algorithm. By default it is set
1214         to True.
1215     full : {True, False}, optional
1216         Set full to True to increase the range of rational algorithm.
1217         See :func:`rational_algorithm` for details. By default it is set to
1218         False.
1219 
1220     Examples
1221     ========
1222 
1223     >>> from sympy import fps, O, ln, atan
1224     >>> from sympy.abc import x
1225 
1226     Rational Functions
1227 
1228     >>> fps(ln(1 + x)).truncate()
1229     x - x**2/2 + x**3/3 - x**4/4 + x**5/5 + O(x**6)
1230 
1231     >>> fps(atan(x), full=True).truncate()
1232     x - x**3/3 + x**5/5 + O(x**6)
1233 
1234     See Also
1235     ========
1236 
1237     sympy.series.formal.FormalPowerSeries
1238     sympy.series.formal.compute_fps
1239     """
1240     f = sympify(f)
1241 
1242     if x is None:
1243         free = f.free_symbols
1244         if len(free) == 1:
1245             x = free.pop()
1246         elif not free:
1247             return f
1248         else:
1249             raise NotImplementedError("multivariate formal power series")
1250 
1251     result = compute_fps(f, x, x0, dir, hyper, order, rational, full)
1252 
1253     if result is None:
1254         return f
1255 
1256     return FormalPowerSeries(f, x, x0, dir, result)

</code><intended_behavior>The `fps` method should uniformly return a `FormalPowerSeries` object or a compatible type that supports indexing and other series operations, even when the input is a simple polynomial that does not need formal expansion. This requires modifying the method to encapsulate outputs like `x**2` within a formal series wrapper that mimics the behavior of a more complex series expansion, without altering the mathematical output. Essentially, even if the function decides to return the input in cases where expansion is deemed unnecessary, it should still ensure that the return value adheres to the interface expected by callers of `fps`.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>fps</method>
<code>
3113     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3114             full=False):
3115         """
3116         Compute formal power power series of self.
3117 
3118         See the docstring of the :func:`fps` function in sympy.series.formal for
3119         more information.
3120         """
3121         from sympy.series.formal import fps
3122 
3123         return fps(self, x, x0, dir, hyper, order, rational, full)

</code><intended_behavior>Similar to the `fps` function in `sympy/series/formal.py`, this wrapper method in the `Expr` class should ensure that for all expressions, calling `fps` yields an object that supports the full interface expected of a formal power series. This might mean implementing additional logic within this method to check the return type from the core `fps` function and adjust it accordingly, ensuring uniformity and predictability in the behavior of `fps` across the library.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     # ***************
105     # * Arithmetics *
106     # ***************
107     # Expr and its sublcasses use _op_priority to determine which object
108     # passed to a binary special method (__mul__, etc.) will handle the
109     # operation. In general, the 'call_highest_priority' decorator will choose
110     # the object with the highest _op_priority to handle the call.
111     # Custom subclasses that want to define their own binary special methods
112     # should set an _op_priority value that is higher than the default.
113     #
114     # **NOTE**:
115     # This is a temporary fix, and will eventually be replaced with
116     # something better and more powerful.  See issue 5510.
117     _op_priority = 10.0
118 
119     def __pos__(self):
120         return self
121 
122     def __neg__(self):
123         return Mul(S.NegativeOne, self)
124 
125     def __abs__(self):
126         from sympy import Abs
127         return Abs(self)
128 
129     @_sympifyit('other', NotImplemented)
130     @call_highest_priority('__radd__')
131     def __add__(self, other):
132         return Add(self, other)
133 
134     @_sympifyit('other', NotImplemented)
135     @call_highest_priority('__add__')
136     def __radd__(self, other):
137         return Add(other, self)
138 
139     @_sympifyit('other', NotImplemented)
140     @call_highest_priority('__rsub__')
141     def __sub__(self, other):
142         return Add(self, -other)
143 
144     @_sympifyit('other', NotImplemented)
145     @call_highest_priority('__sub__')
146     def __rsub__(self, other):
147         return Add(other, -self)
148 
149     @_sympifyit('other', NotImplemented)
150     @call_highest_priority('__rmul__')
151     def __mul__(self, other):
152         return Mul(self, other)
153 
154     @_sympifyit('other', NotImplemented)
155     @call_highest_priority('__mul__')
156     def __rmul__(self, other):
157         return Mul(other, self)
158 
159     @_sympifyit('other', NotImplemented)
160     @call_highest_priority('__rpow__')
161     def _pow(self, other):
162         return Pow(self, other)
163 
164     def __pow__(self, other, mod=None):
165         if mod is None:
166             return self._pow(other)
167         try:
168             _self, other, mod = as_int(self), as_int(other), as_int(mod)
169             if other >= 0:
170                 return pow(_self, other, mod)
171             else:
172                 from sympy.core.numbers import mod_inverse
173                 return mod_inverse(pow(_self, -other, mod), mod)
174         except ValueError:
175             power = self._pow(other)
176             try:
177                 return power%mod
178             except TypeError:
179                 return NotImplemented
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__pow__')
183     def __rpow__(self, other):
184         return Pow(other, self)
185 
186     @_sympifyit('other', NotImplemented)
187     @call_highest_priority('__rdiv__')
188     def __div__(self, other):
189         return Mul(self, Pow(other, S.NegativeOne))
190 
191     @_sympifyit('other', NotImplemented)
192     @call_highest_priority('__div__')
193     def __rdiv__(self, other):
194         return Mul(other, Pow(self, S.NegativeOne))
195 
196     __truediv__ = __div__
197     __rtruediv__ = __rdiv__
198 
199     @_sympifyit('other', NotImplemented)
200     @call_highest_priority('__rmod__')
201     def __mod__(self, other):
202         return Mod(self, other)
203 
204     @_sympifyit('other', NotImplemented)
205     @call_highest_priority('__mod__')
206     def __rmod__(self, other):
207         return Mod(other, self)
208 
209     @_sympifyit('other', NotImplemented)
210     @call_highest_priority('__rfloordiv__')
211     def __floordiv__(self, other):
212         from sympy.functions.elementary.integers import floor
213         return floor(self / other)
214 
215     @_sympifyit('other', NotImplemented)
216     @call_highest_priority('__floordiv__')
217     def __rfloordiv__(self, other):
218         from sympy.functions.elementary.integers import floor
219         return floor(other / self)
220 
221 
222     @_sympifyit('other', NotImplemented)
223     @call_highest_priority('__rdivmod__')
224     def __divmod__(self, other):
225         from sympy.functions.elementary.integers import floor
226         return floor(self / other), Mod(self, other)
227 
228     @_sympifyit('other', NotImplemented)
229     @call_highest_priority('__divmod__')
230     def __rdivmod__(self, other):
231         from sympy.functions.elementary.integers import floor
232         return floor(other / self), Mod(other, self)
233 
234     def __int__(self):
235         # Although we only need to round to the units position, we'll
236         # get one more digit so the extra testing below can be avoided
237         # unless the rounded value rounded to an integer, e.g. if an
238         # expression were equal to 1.9 and we rounded to the unit position
239         # we would get a 2 and would not know if this rounded up or not
240         # without doing a test (as done below). But if we keep an extra
241         # digit we know that 1.9 is not the same as 1 and there is no
242         # need for further testing: our int value is correct. If the value
243         # were 1.99, however, this would round to 2.0 and our int value is
244         # off by one. So...if our round value is the same as the int value
245         # (regardless of how much extra work we do to calculate extra decimal
246         # places) we need to test whether we are off by one.
247         from sympy import Dummy
248         if not self.is_number:
249             raise TypeError("can't convert symbols to int")
250         r = self.round(2)
251         if not r.is_Number:
252             raise TypeError("can't convert complex to int")
253         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
254             raise TypeError("can't convert %s to int" % r)
255         i = int(r)
256         if not i:
257             return 0
258         # off-by-one check
259         if i == r and not (self - i).equals(0):
260             isign = 1 if i > 0 else -1
261             x = Dummy()
262             # in the following (self - i).evalf(2) will not always work while
263             # (self - r).evalf(2) and the use of subs does; if the test that
264             # was added when this comment was added passes, it might be safe
265             # to simply use sign to compute this rather than doing this by hand:
266             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
267             if diff_sign != isign:
268                 i -= isign
269         return i
270     __long__ = __int__
271 
272     def __float__(self):
273         # Don't bother testing if it's a number; if it's not this is going
274         # to fail, and if it is we still need to check that it evalf'ed to
275         # a number.
276         result = self.evalf()
277         if result.is_Number:
278             return float(result)
279         if result.is_number and result.as_real_imag()[1]:
280             raise TypeError("can't convert complex to float")
281         raise TypeError("can't convert expression to float")
282 
283     def __complex__(self):
284         result = self.evalf()
285         re, im = result.as_real_imag()
286         return complex(float(re), float(im))
287 
288     def __ge__(self, other):
289         from sympy import GreaterThan
290         try:
291             other = _sympify(other)
292         except SympifyError:
293             raise TypeError("Invalid comparison %s >= %s" % (self, other))
294         for me in (self, other):
295             if me.is_complex and me.is_extended_real is False:
296                 raise TypeError("Invalid comparison of complex %s" % me)
297             if me is S.NaN:
298                 raise TypeError("Invalid NaN comparison")
299         n2 = _n2(self, other)
300         if n2 is not None:
301             return _sympify(n2 >= 0)
302         if self.is_extended_real or other.is_extended_real:
303             dif = self - other
304             if dif.is_extended_nonnegative is not None and \
305                     dif.is_extended_nonnegative is not dif.is_extended_negative:
306                 return sympify(dif.is_extended_nonnegative)
307         return GreaterThan(self, other, evaluate=False)
308 
309     def __le__(self, other):
310         from sympy import LessThan
311         try:
312             other = _sympify(other)
313         except SympifyError:
314             raise TypeError("Invalid comparison %s <= %s" % (self, other))
315         for me in (self, other):
316             if me.is_complex and me.is_extended_real is False:
317                 raise TypeError("Invalid comparison of complex %s" % me)
318             if me is S.NaN:
319                 raise TypeError("Invalid NaN comparison")
320         n2 = _n2(self, other)
321         if n2 is not None:
322             return _sympify(n2 <= 0)
323         if self.is_extended_real or other.is_extended_real:
324             dif = self - other
325             if dif.is_extended_nonpositive is not None and \
326                     dif.is_extended_nonpositive is not dif.is_extended_positive:
327                 return sympify(dif.is_extended_nonpositive)
328         return LessThan(self, other, evaluate=False)
329 
330     def __gt__(self, other):
331         from sympy import StrictGreaterThan
332         try:
333             other = _sympify(other)
334         except SympifyError:
335             raise TypeError("Invalid comparison %s > %s" % (self, other))
336         for me in (self, other):
337             if me.is_complex and me.is_extended_real is False:
338                 raise TypeError("Invalid comparison of complex %s" % me)
339             if me is S.NaN:
340                 raise TypeError("Invalid NaN comparison")
341         n2 = _n2(self, other)
342         if n2 is not None:
343             return _sympify(n2 > 0)
344         if self.is_extended_real or other.is_extended_real:
345             dif = self - other
346             if dif.is_extended_positive is not None and \
347                     dif.is_extended_positive is not dif.is_extended_nonpositive:
348                 return sympify(dif.is_extended_positive)
349         return StrictGreaterThan(self, other, evaluate=False)
350 
351     def __lt__(self, other):
352         from sympy import StrictLessThan
353         try:
354             other = _sympify(other)
355         except SympifyError:
356             raise TypeError("Invalid comparison %s < %s" % (self, other))
357         for me in (self, other):
358             if me.is_complex and me.is_extended_real is False:
359                 raise TypeError("Invalid comparison of complex %s" % me)
360             if me is S.NaN:
361                 raise TypeError("Invalid NaN comparison")
362         n2 = _n2(self, other)
363         if n2 is not None:
364             return _sympify(n2 < 0)
365         if self.is_extended_real or other.is_extended_real:
366             dif = self - other
367             if dif.is_extended_negative is not None and \
368                     dif.is_extended_negative is not dif.is_extended_nonnegative:
369                 return sympify(dif.is_extended_negative)
370         return StrictLessThan(self, other, evaluate=False)
371 
372     def __trunc__(self):
373         if not self.is_number:
374             raise TypeError("can't truncate symbols and expressions")
375         else:
376             return Integer(self)
377 
378     @staticmethod
379     def _from_mpmath(x, prec):
380         from sympy import Float
381         if hasattr(x, "_mpf_"):
382             return Float._new(x._mpf_, prec)
383         elif hasattr(x, "_mpc_"):
384             re, im = x._mpc_
385             re = Float._new(re, prec)
386             im = Float._new(im, prec)*S.ImaginaryUnit
387             return re + im
388         else:
389             raise TypeError("expected mpmath number (mpf or mpc)")
390 
391     @property
392     def is_number(self):
393         """Returns True if ``self`` has no free symbols and no
394         undefined functions (AppliedUndef, to be precise). It will be
395         faster than ``if not self.free_symbols``, however, since
396         ``is_number`` will fail as soon as it hits a free symbol
397         or undefined function.
398 
399         Examples
400         ========
401 
402         >>> from sympy import log, Integral, cos, sin, pi
403         >>> from sympy.core.function import Function
404         >>> from sympy.abc import x
405         >>> f = Function('f')
406 
407         >>> x.is_number
408         False
409         >>> f(1).is_number
410         False
411         >>> (2*x).is_number
412         False
413         >>> (2 + Integral(2, x)).is_number
414         False
415         >>> (2 + Integral(2, (x, 1, 2))).is_number
416         True
417 
418         Not all numbers are Numbers in the SymPy sense:
419 
420         >>> pi.is_number, pi.is_Number
421         (True, False)
422 
423         If something is a number it should evaluate to a number with
424         real and imaginary parts that are Numbers; the result may not
425         be comparable, however, since the real and/or imaginary part
426         of the result may not have precision.
427 
428         >>> cos(1).is_number and cos(1).is_comparable
429         True
430 
431         >>> z = cos(1)**2 + sin(1)**2 - 1
432         >>> z.is_number
433         True
434         >>> z.is_comparable
435         False
436 
437         See Also
438         ========
439         sympy.core.basic.is_comparable
440         """
441         return all(obj.is_number for obj in self.args)
442 
443     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
444         """Return self evaluated, if possible, replacing free symbols with
445         random complex values, if necessary.
446 
447         The random complex value for each free symbol is generated
448         by the random_complex_number routine giving real and imaginary
449         parts in the range given by the re_min, re_max, im_min, and im_max
450         values. The returned value is evaluated to a precision of n
451         (if given) else the maximum of 15 and the precision needed
452         to get more than 1 digit of precision. If the expression
453         could not be evaluated to a number, or could not be evaluated
454         to more than 1 digit of precision, then None is returned.
455 
456         Examples
457         ========
458 
459         >>> from sympy import sqrt
460         >>> from sympy.abc import x, y
461         >>> x._random()                         # doctest: +SKIP
462         0.0392918155679172 + 0.916050214307199*I
463         >>> x._random(2)                        # doctest: +SKIP
464         -0.77 - 0.87*I
465         >>> (x + y/2)._random(2)                # doctest: +SKIP
466         -0.57 + 0.16*I
467         >>> sqrt(2)._random(2)
468         1.4
469 
470         See Also
471         ========
472 
473         sympy.utilities.randtest.random_complex_number
474         """
475 
476         free = self.free_symbols
477         prec = 1
478         if free:
479             from sympy.utilities.randtest import random_complex_number
480             a, c, b, d = re_min, re_max, im_min, im_max
481             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
482                            for zi in free])))
483             try:
484                 nmag = abs(self.evalf(2, subs=reps))
485             except (ValueError, TypeError):
486                 # if an out of range value resulted in evalf problems
487                 # then return None -- XXX is there a way to know how to
488                 # select a good random number for a given expression?
489                 # e.g. when calculating n! negative values for n should not
490                 # be used
491                 return None
492         else:
493             reps = {}
494             nmag = abs(self.evalf(2))
495 
496         if not hasattr(nmag, '_prec'):
497             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
498             return None
499 
500         if nmag._prec == 1:
501             # increase the precision up to the default maximum
502             # precision to see if we can get any significance
503 
504             from mpmath.libmp.libintmath import giant_steps
505             from sympy.core.evalf import DEFAULT_MAXPREC as target
506 
507             # evaluate
508             for prec in giant_steps(2, target):
509                 nmag = abs(self.evalf(prec, subs=reps))
510                 if nmag._prec != 1:
511                     break
512 
513         if nmag._prec != 1:
514             if n is None:
515                 n = max(prec, 15)
516             return self.evalf(n, subs=reps)
517 
518         # never got any significance
519         return None
520 
521     def is_constant(self, *wrt, **flags):
522         """Return True if self is constant, False if not, or None if
523         the constancy could not be determined conclusively.
524 
525         If an expression has no free symbols then it is a constant. If
526         there are free symbols it is possible that the expression is a
527         constant, perhaps (but not necessarily) zero. To test such
528         expressions, two strategies are tried:
529 
530         1) numerical evaluation at two random points. If two such evaluations
531         give two different values and the values have a precision greater than
532         1 then self is not constant. If the evaluations agree or could not be
533         obtained with any precision, no decision is made. The numerical testing
534         is done only if ``wrt`` is different than the free symbols.
535 
536         2) differentiation with respect to variables in 'wrt' (or all free
537         symbols if omitted) to see if the expression is constant or not. This
538         will not always lead to an expression that is zero even though an
539         expression is constant (see added test in test_expr.py). If
540         all derivatives are zero then self is constant with respect to the
541         given symbols.
542 
543         If neither evaluation nor differentiation can prove the expression is
544         constant, None is returned unless two numerical values happened to be
545         the same and the flag ``failing_number`` is True -- in that case the
546         numerical value will be returned.
547 
548         If flag simplify=False is passed, self will not be simplified;
549         the default is True since self should be simplified before testing.
550 
551         Examples
552         ========
553 
554         >>> from sympy import cos, sin, Sum, S, pi
555         >>> from sympy.abc import a, n, x, y
556         >>> x.is_constant()
557         False
558         >>> S(2).is_constant()
559         True
560         >>> Sum(x, (x, 1, 10)).is_constant()
561         True
562         >>> Sum(x, (x, 1, n)).is_constant()
563         False
564         >>> Sum(x, (x, 1, n)).is_constant(y)
565         True
566         >>> Sum(x, (x, 1, n)).is_constant(n)
567         False
568         >>> Sum(x, (x, 1, n)).is_constant(x)
569         True
570         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
571         >>> eq.is_constant()
572         True
573         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
574         True
575 
576         >>> (0**x).is_constant()
577         False
578         >>> x.is_constant()
579         False
580         >>> (x**x).is_constant()
581         False
582         >>> one = cos(x)**2 + sin(x)**2
583         >>> one.is_constant()
584         True
585         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
586         True
587         """
588 
589         simplify = flags.get('simplify', True)
590 
591         if self.is_number:
592             return True
593         free = self.free_symbols
594         if not free:
595             return True  # assume f(1) is some constant
596 
597         # if we are only interested in some symbols and they are not in the
598         # free symbols then this expression is constant wrt those symbols
599         wrt = set(wrt)
600         if wrt and not wrt & free:
601             return True
602         wrt = wrt or free
603 
604         # simplify unless this has already been done
605         expr = self
606         if simplify:
607             expr = expr.simplify()
608 
609         # is_zero should be a quick assumptions check; it can be wrong for
610         # numbers (see test_is_not_constant test), giving False when it
611         # shouldn't, but hopefully it will never give True unless it is sure.
612         if expr.is_zero:
613             return True
614 
615         # try numerical evaluation to see if we get two different values
616         failing_number = None
617         if wrt == free:
618             # try 0 (for a) and 1 (for b)
619             try:
620                 a = expr.subs(list(zip(free, [0]*len(free))),
621                     simultaneous=True)
622                 if a is S.NaN:
623                     # evaluation may succeed when substitution fails
624                     a = expr._random(None, 0, 0, 0, 0)
625             except ZeroDivisionError:
626                 a = None
627             if a is not None and a is not S.NaN:
628                 try:
629                     b = expr.subs(list(zip(free, [1]*len(free))),
630                         simultaneous=True)
631                     if b is S.NaN:
632                         # evaluation may succeed when substitution fails
633                         b = expr._random(None, 1, 0, 1, 0)
634                 except ZeroDivisionError:
635                     b = None
636                 if b is not None and b is not S.NaN and b.equals(a) is False:
637                     return False
638                 # try random real
639                 b = expr._random(None, -1, 0, 1, 0)
640                 if b is not None and b is not S.NaN and b.equals(a) is False:
641                     return False
642                 # try random complex
643                 b = expr._random()
644                 if b is not None and b is not S.NaN:
645                     if b.equals(a) is False:
646                         return False
647                     failing_number = a if a.is_number else b
648 
649         # now we will test each wrt symbol (or all free symbols) to see if the
650         # expression depends on them or not using differentiation. This is
651         # not sufficient for all expressions, however, so we don't return
652         # False if we get a derivative other than 0 with free symbols.
653         for w in wrt:
654             deriv = expr.diff(w)
655             if simplify:
656                 deriv = deriv.simplify()
657             if deriv != 0:
658                 if not (pure_complex(deriv, or_real=True)):
659                     if flags.get('failing_number', False):
660                         return failing_number
661                     elif deriv.free_symbols:
662                         # dead line provided _random returns None in such cases
663                         return None
664                 return False
665         return True
666 
667     def equals(self, other, failing_expression=False):
668         """Return True if self == other, False if it doesn't, or None. If
669         failing_expression is True then the expression which did not simplify
670         to a 0 will be returned instead of None.
671 
672         If ``self`` is a Number (or complex number) that is not zero, then
673         the result is False.
674 
675         If ``self`` is a number and has not evaluated to zero, evalf will be
676         used to test whether the expression evaluates to zero. If it does so
677         and the result has significance (i.e. the precision is either -1, for
678         a Rational result, or is greater than 1) then the evalf value will be
679         used to return True or False.
680 
681         """
682         from sympy.simplify.simplify import nsimplify, simplify
683         from sympy.solvers.solveset import solveset
684         from sympy.solvers.solvers import solve
685         from sympy.polys.polyerrors import NotAlgebraic
686         from sympy.polys.numberfields import minimal_polynomial
687 
688         other = sympify(other)
689         if self == other:
690             return True
691 
692         # they aren't the same so see if we can make the difference 0;
693         # don't worry about doing simplification steps one at a time
694         # because if the expression ever goes to 0 then the subsequent
695         # simplification steps that are done will be very fast.
696         diff = factor_terms(simplify(self - other), radical=True)
697 
698         if not diff:
699             return True
700 
701         if not diff.has(Add, Mod):
702             # if there is no expanding to be done after simplifying
703             # then this can't be a zero
704             return False
705 
706         constant = diff.is_constant(simplify=False, failing_number=True)
707 
708         if constant is False:
709             return False
710 
711         if not diff.is_number:
712             if constant is None:
713                 # e.g. unless the right simplification is done, a symbolic
714                 # zero is possible (see expression of issue 6829: without
715                 # simplification constant will be None).
716                 return
717 
718         if constant is True:
719             # this gives a number whether there are free symbols or not
720             ndiff = diff._random()
721             # is_comparable will work whether the result is real
722             # or complex; it could be None, however.
723             if ndiff and ndiff.is_comparable:
724                 return False
725 
726         # sometimes we can use a simplified result to give a clue as to
727         # what the expression should be; if the expression is *not* zero
728         # then we should have been able to compute that and so now
729         # we can just consider the cases where the approximation appears
730         # to be zero -- we try to prove it via minimal_polynomial.
731         #
732         # removed
733         # ns = nsimplify(diff)
734         # if diff.is_number and (not ns or ns == diff):
735         #
736         # The thought was that if it nsimplifies to 0 that's a sure sign
737         # to try the following to prove it; or if it changed but wasn't
738         # zero that might be a sign that it's not going to be easy to
739         # prove. But tests seem to be working without that logic.
740         #
741         if diff.is_number:
742             # try to prove via self-consistency
743             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
744             # it seems to work better to try big ones first
745             surds.sort(key=lambda x: -x.args[0])
746             for s in surds:
747                 try:
748                     # simplify is False here -- this expression has already
749                     # been identified as being hard to identify as zero;
750                     # we will handle the checking ourselves using nsimplify
751                     # to see if we are in the right ballpark or not and if so
752                     # *then* the simplification will be attempted.
753                     sol = solve(diff, s, simplify=False)
754                     if sol:
755                         if s in sol:
756                             # the self-consistent result is present
757                             return True
758                         if all(si.is_Integer for si in sol):
759                             # perfect powers are removed at instantiation
760                             # so surd s cannot be an integer
761                             return False
762                         if all(i.is_algebraic is False for i in sol):
763                             # a surd is algebraic
764                             return False
765                         if any(si in surds for si in sol):
766                             # it wasn't equal to s but it is in surds
767                             # and different surds are not equal
768                             return False
769                         if any(nsimplify(s - si) == 0 and
770                                 simplify(s - si) == 0 for si in sol):
771                             return True
772                         if s.is_real:
773                             if any(nsimplify(si, [s]) == s and simplify(si) == s
774                                     for si in sol):
775                                 return True
776                 except NotImplementedError:
777                     pass
778 
779             # try to prove with minimal_polynomial but know when
780             # *not* to use this or else it can take a long time. e.g. issue 8354
781             if True:  # change True to condition that assures non-hang
782                 try:
783                     mp = minimal_polynomial(diff)
784                     if mp.is_Symbol:
785                         return True
786                     return False
787                 except (NotAlgebraic, NotImplementedError):
788                     pass
789 
790         # diff has not simplified to zero; constant is either None, True
791         # or the number with significance (is_comparable) that was randomly
792         # calculated twice as the same value.
793         if constant not in (True, None) and constant != 0:
794             return False
795 
796         if failing_expression:
797             return diff
798         return None
799 
800     def _eval_is_positive(self):
801         finite = self.is_finite
802         if finite is False:
803             return False
804         extended_positive = self.is_extended_positive
805         if finite is True:
806             return extended_positive
807         if extended_positive is False:
808             return False
809 
810     def _eval_is_negative(self):
811         finite = self.is_finite
812         if finite is False:
813             return False
814         extended_negative = self.is_extended_negative
815         if finite is True:
816             return extended_negative
817         if extended_negative is False:
818             return False
819 
820     def _eval_is_extended_positive(self):
821         from sympy.polys.numberfields import minimal_polynomial
822         from sympy.polys.polyerrors import NotAlgebraic
823         if self.is_number:
824             if self.is_extended_real is False:
825                 return False
826 
827             # check to see that we can get a value
828             try:
829                 n2 = self._eval_evalf(2)
830             # XXX: This shouldn't be caught here
831             # Catches ValueError: hypsum() failed to converge to the requested
832             # 34 bits of accuracy
833             except ValueError:
834                 return None
835             if n2 is None:
836                 return None
837             if getattr(n2, '_prec', 1) == 1:  # no significance
838                 return None
839             if n2 == S.NaN:
840                 return None
841 
842             r, i = self.evalf(2).as_real_imag()
843             if not i.is_Number or not r.is_Number:
844                 return False
845             if r._prec != 1 and i._prec != 1:
846                 return bool(not i and r > 0)
847             elif r._prec == 1 and (not i or i._prec == 1) and \
848                     self.is_algebraic and not self.has(Function):
849                 try:
850                     if minimal_polynomial(self).is_Symbol:
851                         return False
852                 except (NotAlgebraic, NotImplementedError):
853                     pass
854 
855     def _eval_is_extended_negative(self):
856         from sympy.polys.numberfields import minimal_polynomial
857         from sympy.polys.polyerrors import NotAlgebraic
858         if self.is_number:
859             if self.is_extended_real is False:
860                 return False
861 
862             # check to see that we can get a value
863             try:
864                 n2 = self._eval_evalf(2)
865             # XXX: This shouldn't be caught here
866             # Catches ValueError: hypsum() failed to converge to the requested
867             # 34 bits of accuracy
868             except ValueError:
869                 return None
870             if n2 is None:
871                 return None
872             if getattr(n2, '_prec', 1) == 1:  # no significance
873                 return None
874             if n2 == S.NaN:
875                 return None
876 
877             r, i = self.evalf(2).as_real_imag()
878             if not i.is_Number or not r.is_Number:
879                 return False
880             if r._prec != 1 and i._prec != 1:
881                 return bool(not i and r < 0)
882             elif r._prec == 1 and (not i or i._prec == 1) and \
883                     self.is_algebraic and not self.has(Function):
884                 try:
885                     if minimal_polynomial(self).is_Symbol:
886                         return False
887                 except (NotAlgebraic, NotImplementedError):
888                     pass
889 
890     def _eval_interval(self, x, a, b):
891         """
892         Returns evaluation over an interval.  For most functions this is:
893 
894         self.subs(x, b) - self.subs(x, a),
895 
896         possibly using limit() if NaN is returned from subs, or if
897         singularities are found between a and b.
898 
899         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
900         respectively.
901 
902         """
903         from sympy.series import limit, Limit
904         from sympy.solvers.solveset import solveset
905         from sympy.sets.sets import Interval
906         from sympy.functions.elementary.exponential import log
907         from sympy.calculus.util import AccumBounds
908 
909         if (a is None and b is None):
910             raise ValueError('Both interval ends cannot be None.')
911 
912         if a == b:
913             return 0
914 
915         if a is None:
916             A = 0
917         else:
918             A = self.subs(x, a)
919             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
920                 if (a < b) != False:
921                     A = limit(self, x, a,"+")
922                 else:
923                     A = limit(self, x, a,"-")
924 
925                 if A is S.NaN:
926                     return A
927                 if isinstance(A, Limit):
928                     raise NotImplementedError("Could not compute limit")
929 
930         if b is None:
931             B = 0
932         else:
933             B = self.subs(x, b)
934             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
935                 if (a < b) != False:
936                     B = limit(self, x, b,"-")
937                 else:
938                     B = limit(self, x, b,"+")
939 
940                 if isinstance(B, Limit):
941                     raise NotImplementedError("Could not compute limit")
942 
943         if (a and b) is None:
944             return B - A
945 
946         value = B - A
947 
948         if a.is_comparable and b.is_comparable:
949             if a < b:
950                 domain = Interval(a, b)
951             else:
952                 domain = Interval(b, a)
953             # check the singularities of self within the interval
954             # if singularities is a ConditionSet (not iterable), catch the exception and pass
955             singularities = solveset(self.cancel().as_numer_denom()[1], x,
956                 domain=domain)
957             for logterm in self.atoms(log):
958                 singularities = singularities | solveset(logterm.args[0], x,
959                     domain=domain)
960             try:
961                 for s in singularities:
962                     if value is S.NaN:
963                         # no need to keep adding, it will stay NaN
964                         break
965                     if not s.is_comparable:
966                         continue
967                     if (a < s) == (s < b) == True:
968                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
969                     elif (b < s) == (s < a) == True:
970                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
971             except TypeError:
972                 pass
973 
974         return value
975 
976     def _eval_power(self, other):
977         # subclass to compute self**other for cases when
978         # other is not NaN, 0, or 1
979         return None
980 
981     def _eval_conjugate(self):
982         if self.is_extended_real:
983             return self
984         elif self.is_imaginary:
985             return -self
986 
987     def conjugate(self):
988         from sympy.functions.elementary.complexes import conjugate as c
989         return c(self)
990 
991     def _eval_transpose(self):
992         from sympy.functions.elementary.complexes import conjugate
993         if self.is_complex:
994             return self
995         elif self.is_hermitian:
996             return conjugate(self)
997         elif self.is_antihermitian:
998             return -conjugate(self)
999 
1000     def transpose(self):
1001         from sympy.functions.elementary.complexes import transpose
1002         return transpose(self)
1003 
1004     def _eval_adjoint(self):
1005         from sympy.functions.elementary.complexes import conjugate, transpose
1006         if self.is_hermitian:
1007             return self
1008         elif self.is_antihermitian:
1009             return -self
1010         obj = self._eval_conjugate()
1011         if obj is not None:
1012             return transpose(obj)
1013         obj = self._eval_transpose()
1014         if obj is not None:
1015             return conjugate(obj)
1016 
1017     def adjoint(self):
1018         from sympy.functions.elementary.complexes import adjoint
1019         return adjoint(self)
1020 
1021     @classmethod
1022     def _parse_order(cls, order):
1023         """Parse and configure the ordering of terms. """
1024         from sympy.polys.orderings import monomial_key
1025 
1026         startswith = getattr(order, "startswith", None)
1027         if startswith is None:
1028             reverse = False
1029         else:
1030             reverse = startswith('rev-')
1031             if reverse:
1032                 order = order[4:]
1033 
1034         monom_key = monomial_key(order)
1035 
1036         def neg(monom):
1037             result = []
1038 
1039             for m in monom:
1040                 if isinstance(m, tuple):
1041                     result.append(neg(m))
1042                 else:
1043                     result.append(-m)
1044 
1045             return tuple(result)
1046 
1047         def key(term):
1048             _, ((re, im), monom, ncpart) = term
1049 
1050             monom = neg(monom_key(monom))
1051             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1052             coeff = ((bool(im), im), (re, im))
1053 
1054             return monom, ncpart, coeff
1055 
1056         return key, reverse
1057 
1058     def as_ordered_factors(self, order=None):
1059         """Return list of ordered factors (if Mul) else [self]."""
1060         return [self]
1061 
1062     def as_ordered_terms(self, order=None, data=False):
1063         """
1064         Transform an expression to an ordered list of terms.
1065 
1066         Examples
1067         ========
1068 
1069         >>> from sympy import sin, cos
1070         >>> from sympy.abc import x
1071 
1072         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1073         [sin(x)**2*cos(x), sin(x)**2, 1]
1074 
1075         """
1076 
1077         from .numbers import Number, NumberSymbol
1078 
1079         if order is None and self.is_Add:
1080             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1081             # first number positive and thhe second number nagative
1082             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1083             add_args = sorted(Add.make_args(self), key=key)
1084             if (len(add_args) == 2
1085                 and isinstance(add_args[0], (Number, NumberSymbol))
1086                 and isinstance(add_args[1], Mul)):
1087                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1088                 if (len(mul_args) == 2
1089                     and isinstance(mul_args[0], Number)
1090                     and add_args[0].is_positive
1091                     and mul_args[0].is_negative):
1092                     return add_args
1093 
1094         key, reverse = self._parse_order(order)
1095         terms, gens = self.as_terms()
1096 
1097         if not any(term.is_Order for term, _ in terms):
1098             ordered = sorted(terms, key=key, reverse=reverse)
1099         else:
1100             _terms, _order = [], []
1101 
1102             for term, repr in terms:
1103                 if not term.is_Order:
1104                     _terms.append((term, repr))
1105                 else:
1106                     _order.append((term, repr))
1107 
1108             ordered = sorted(_terms, key=key, reverse=True) \
1109                 + sorted(_order, key=key, reverse=True)
1110 
1111         if data:
1112             return ordered, gens
1113         else:
1114             return [term for term, _ in ordered]
1115 
1116     def as_terms(self):
1117         """Transform an expression to a list of terms. """
1118         from .add import Add
1119         from .mul import Mul
1120         from .exprtools import decompose_power
1121 
1122         gens, terms = set([]), []
1123 
1124         for term in Add.make_args(self):
1125             coeff, _term = term.as_coeff_Mul()
1126 
1127             coeff = complex(coeff)
1128             cpart, ncpart = {}, []
1129 
1130             if _term is not S.One:
1131                 for factor in Mul.make_args(_term):
1132                     if factor.is_number:
1133                         try:
1134                             coeff *= complex(factor)
1135                         except (TypeError, ValueError):
1136                             pass
1137                         else:
1138                             continue
1139 
1140                     if factor.is_commutative:
1141                         base, exp = decompose_power(factor)
1142 
1143                         cpart[base] = exp
1144                         gens.add(base)
1145                     else:
1146                         ncpart.append(factor)
1147 
1148             coeff = coeff.real, coeff.imag
1149             ncpart = tuple(ncpart)
1150 
1151             terms.append((term, (coeff, cpart, ncpart)))
1152 
1153         gens = sorted(gens, key=default_sort_key)
1154 
1155         k, indices = len(gens), {}
1156 
1157         for i, g in enumerate(gens):
1158             indices[g] = i
1159 
1160         result = []
1161 
1162         for term, (coeff, cpart, ncpart) in terms:
1163             monom = [0]*k
1164 
1165             for base, exp in cpart.items():
1166                 monom[indices[base]] = exp
1167 
1168             result.append((term, (coeff, tuple(monom), ncpart)))
1169 
1170         return result, gens
1171 
1172     def removeO(self):
1173         """Removes the additive O(..) symbol if there is one"""
1174         return self
1175 
1176     def getO(self):
1177         """Returns the additive O(..) symbol if there is one, else None."""
1178         return None
1179 
1180     def getn(self):
1181         """
1182         Returns the order of the expression.
1183 
1184         The order is determined either from the O(...) term. If there
1185         is no O(...) term, it returns None.
1186 
1187         Examples
1188         ========
1189 
1190         >>> from sympy import O
1191         >>> from sympy.abc import x
1192         >>> (1 + x + O(x**2)).getn()
1193         2
1194         >>> (1 + x).getn()
1195 
1196         """
1197         from sympy import Dummy, Symbol
1198         o = self.getO()
1199         if o is None:
1200             return None
1201         elif o.is_Order:
1202             o = o.expr
1203             if o is S.One:
1204                 return S.Zero
1205             if o.is_Symbol:
1206                 return S.One
1207             if o.is_Pow:
1208                 return o.args[1]
1209             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1210                 for oi in o.args:
1211                     if oi.is_Symbol:
1212                         return S.One
1213                     if oi.is_Pow:
1214                         syms = oi.atoms(Symbol)
1215                         if len(syms) == 1:
1216                             x = syms.pop()
1217                             oi = oi.subs(x, Dummy('x', positive=True))
1218                             if oi.base.is_Symbol and oi.exp.is_Rational:
1219                                 return abs(oi.exp)
1220 
1221         raise NotImplementedError('not sure of order of %s' % o)
1222 
1223     def count_ops(self, visual=None):
1224         """wrapper for count_ops that returns the operation count."""
1225         from .function import count_ops
1226         return count_ops(self, visual)
1227 
1228     def args_cnc(self, cset=False, warn=True, split_1=True):
1229         """Return [commutative factors, non-commutative factors] of self.
1230 
1231         self is treated as a Mul and the ordering of the factors is maintained.
1232         If ``cset`` is True the commutative factors will be returned in a set.
1233         If there were repeated factors (as may happen with an unevaluated Mul)
1234         then an error will be raised unless it is explicitly suppressed by
1235         setting ``warn`` to False.
1236 
1237         Note: -1 is always separated from a Number unless split_1 is False.
1238 
1239         >>> from sympy import symbols, oo
1240         >>> A, B = symbols('A B', commutative=0)
1241         >>> x, y = symbols('x y')
1242         >>> (-2*x*y).args_cnc()
1243         [[-1, 2, x, y], []]
1244         >>> (-2.5*x).args_cnc()
1245         [[-1, 2.5, x], []]
1246         >>> (-2*x*A*B*y).args_cnc()
1247         [[-1, 2, x, y], [A, B]]
1248         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1249         [[-2, x, y], [A, B]]
1250         >>> (-2*x*y).args_cnc(cset=True)
1251         [{-1, 2, x, y}, []]
1252 
1253         The arg is always treated as a Mul:
1254 
1255         >>> (-2 + x + A).args_cnc()
1256         [[], [x - 2 + A]]
1257         >>> (-oo).args_cnc() # -oo is a singleton
1258         [[-1, oo], []]
1259         """
1260 
1261         if self.is_Mul:
1262             args = list(self.args)
1263         else:
1264             args = [self]
1265         for i, mi in enumerate(args):
1266             if not mi.is_commutative:
1267                 c = args[:i]
1268                 nc = args[i:]
1269                 break
1270         else:
1271             c = args
1272             nc = []
1273 
1274         if c and split_1 and (
1275             c[0].is_Number and
1276             c[0].is_extended_negative and
1277                 c[0] is not S.NegativeOne):
1278             c[:1] = [S.NegativeOne, -c[0]]
1279 
1280         if cset:
1281             clen = len(c)
1282             c = set(c)
1283             if clen and warn and len(c) != clen:
1284                 raise ValueError('repeated commutative arguments: %s' %
1285                                  [ci for ci in c if list(self.args).count(ci) > 1])
1286         return [c, nc]
1287 
1288     def coeff(self, x, n=1, right=False):
1289         """
1290         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1291         is zero then all terms independent of ``x`` will be returned.
1292 
1293         When ``x`` is noncommutative, the coefficient to the left (default) or
1294         right of ``x`` can be returned. The keyword 'right' is ignored when
1295         ``x`` is commutative.
1296 
1297         See Also
1298         ========
1299 
1300         as_coefficient: separate the expression into a coefficient and factor
1301         as_coeff_Add: separate the additive constant from an expression
1302         as_coeff_Mul: separate the multiplicative constant from an expression
1303         as_independent: separate x-dependent terms/factors from others
1304         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1305         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1306 
1307         Examples
1308         ========
1309 
1310         >>> from sympy import symbols
1311         >>> from sympy.abc import x, y, z
1312 
1313         You can select terms that have an explicit negative in front of them:
1314 
1315         >>> (-x + 2*y).coeff(-1)
1316         x
1317         >>> (x - 2*y).coeff(-1)
1318         2*y
1319 
1320         You can select terms with no Rational coefficient:
1321 
1322         >>> (x + 2*y).coeff(1)
1323         x
1324         >>> (3 + 2*x + 4*x**2).coeff(1)
1325         0
1326 
1327         You can select terms independent of x by making n=0; in this case
1328         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1329         of None):
1330 
1331         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1332         3
1333         >>> eq = ((x + 1)**3).expand() + 1
1334         >>> eq
1335         x**3 + 3*x**2 + 3*x + 2
1336         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1337         [1, 3, 3, 2]
1338         >>> eq -= 2
1339         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1340         [1, 3, 3, 0]
1341 
1342         You can select terms that have a numerical term in front of them:
1343 
1344         >>> (-x - 2*y).coeff(2)
1345         -y
1346         >>> from sympy import sqrt
1347         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1348         x
1349 
1350         The matching is exact:
1351 
1352         >>> (3 + 2*x + 4*x**2).coeff(x)
1353         2
1354         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1355         4
1356         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1357         0
1358         >>> (z*(x + y)**2).coeff((x + y)**2)
1359         z
1360         >>> (z*(x + y)**2).coeff(x + y)
1361         0
1362 
1363         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1364         from the following:
1365 
1366         >>> (x + z*(x + x*y)).coeff(x)
1367         1
1368 
1369         If such factoring is desired, factor_terms can be used first:
1370 
1371         >>> from sympy import factor_terms
1372         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1373         z*(y + 1) + 1
1374 
1375         >>> n, m, o = symbols('n m o', commutative=False)
1376         >>> n.coeff(n)
1377         1
1378         >>> (3*n).coeff(n)
1379         3
1380         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1381         1 + m
1382         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1383         m
1384 
1385         If there is more than one possible coefficient 0 is returned:
1386 
1387         >>> (n*m + m*n).coeff(n)
1388         0
1389 
1390         If there is only one possible coefficient, it is returned:
1391 
1392         >>> (n*m + x*m*n).coeff(m*n)
1393         x
1394         >>> (n*m + x*m*n).coeff(m*n, right=1)
1395         1
1396 
1397         """
1398         x = sympify(x)
1399         if not isinstance(x, Basic):
1400             return S.Zero
1401 
1402         n = as_int(n)
1403 
1404         if not x:
1405             return S.Zero
1406 
1407         if x == self:
1408             if n == 1:
1409                 return S.One
1410             return S.Zero
1411 
1412         if x is S.One:
1413             co = [a for a in Add.make_args(self)
1414                   if a.as_coeff_Mul()[0] is S.One]
1415             if not co:
1416                 return S.Zero
1417             return Add(*co)
1418 
1419         if n == 0:
1420             if x.is_Add and self.is_Add:
1421                 c = self.coeff(x, right=right)
1422                 if not c:
1423                     return S.Zero
1424                 if not right:
1425                     return self - Add(*[a*x for a in Add.make_args(c)])
1426                 return self - Add(*[x*a for a in Add.make_args(c)])
1427             return self.as_independent(x, as_Add=True)[0]
1428 
1429         # continue with the full method, looking for this power of x:
1430         x = x**n
1431 
1432         def incommon(l1, l2):
1433             if not l1 or not l2:
1434                 return []
1435             n = min(len(l1), len(l2))
1436             for i in range(n):
1437                 if l1[i] != l2[i]:
1438                     return l1[:i]
1439             return l1[:]
1440 
1441         def find(l, sub, first=True):
1442             """ Find where list sub appears in list l. When ``first`` is True
1443             the first occurrence from the left is returned, else the last
1444             occurrence is returned. Return None if sub is not in l.
1445 
1446             >> l = range(5)*2
1447             >> find(l, [2, 3])
1448             2
1449             >> find(l, [2, 3], first=0)
1450             7
1451             >> find(l, [2, 4])
1452             None
1453 
1454             """
1455             if not sub or not l or len(sub) > len(l):
1456                 return None
1457             n = len(sub)
1458             if not first:
1459                 l.reverse()
1460                 sub.reverse()
1461             for i in range(0, len(l) - n + 1):
1462                 if all(l[i + j] == sub[j] for j in range(n)):
1463                     break
1464             else:
1465                 i = None
1466             if not first:
1467                 l.reverse()
1468                 sub.reverse()
1469             if i is not None and not first:
1470                 i = len(l) - (i + n)
1471             return i
1472 
1473         co = []
1474         args = Add.make_args(self)
1475         self_c = self.is_commutative
1476         x_c = x.is_commutative
1477         if self_c and not x_c:
1478             return S.Zero
1479 
1480         if self_c:
1481             xargs = x.args_cnc(cset=True, warn=False)[0]
1482             for a in args:
1483                 margs = a.args_cnc(cset=True, warn=False)[0]
1484                 if len(xargs) > len(margs):
1485                     continue
1486                 resid = margs.difference(xargs)
1487                 if len(resid) + len(xargs) == len(margs):
1488                     co.append(Mul(*resid))
1489             if co == []:
1490                 return S.Zero
1491             elif co:
1492                 return Add(*co)
1493         elif x_c:
1494             xargs = x.args_cnc(cset=True, warn=False)[0]
1495             for a in args:
1496                 margs, nc = a.args_cnc(cset=True)
1497                 if len(xargs) > len(margs):
1498                     continue
1499                 resid = margs.difference(xargs)
1500                 if len(resid) + len(xargs) == len(margs):
1501                     co.append(Mul(*(list(resid) + nc)))
1502             if co == []:
1503                 return S.Zero
1504             elif co:
1505                 return Add(*co)
1506         else:  # both nc
1507             xargs, nx = x.args_cnc(cset=True)
1508             # find the parts that pass the commutative terms
1509             for a in args:
1510                 margs, nc = a.args_cnc(cset=True)
1511                 if len(xargs) > len(margs):
1512                     continue
1513                 resid = margs.difference(xargs)
1514                 if len(resid) + len(xargs) == len(margs):
1515                     co.append((resid, nc))
1516             # now check the non-comm parts
1517             if not co:
1518                 return S.Zero
1519             if all(n == co[0][1] for r, n in co):
1520                 ii = find(co[0][1], nx, right)
1521                 if ii is not None:
1522                     if not right:
1523                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1524                     else:
1525                         return Mul(*co[0][1][ii + len(nx):])
1526             beg = reduce(incommon, (n[1] for n in co))
1527             if beg:
1528                 ii = find(beg, nx, right)
1529                 if ii is not None:
1530                     if not right:
1531                         gcdc = co[0][0]
1532                         for i in range(1, len(co)):
1533                             gcdc = gcdc.intersection(co[i][0])
1534                             if not gcdc:
1535                                 break
1536                         return Mul(*(list(gcdc) + beg[:ii]))
1537                     else:
1538                         m = ii + len(nx)
1539                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1540             end = list(reversed(
1541                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1542             if end:
1543                 ii = find(end, nx, right)
1544                 if ii is not None:
1545                     if not right:
1546                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1547                     else:
1548                         return Mul(*end[ii + len(nx):])
1549             # look for single match
1550             hit = None
1551             for i, (r, n) in enumerate(co):
1552                 ii = find(n, nx, right)
1553                 if ii is not None:
1554                     if not hit:
1555                         hit = ii, r, n
1556                     else:
1557                         break
1558             else:
1559                 if hit:
1560                     ii, r, n = hit
1561                     if not right:
1562                         return Mul(*(list(r) + n[:ii]))
1563                     else:
1564                         return Mul(*n[ii + len(nx):])
1565 
1566             return S.Zero
1567 
1568     def as_expr(self, *gens):
1569         """
1570         Convert a polynomial to a SymPy expression.
1571 
1572         Examples
1573         ========
1574 
1575         >>> from sympy import sin
1576         >>> from sympy.abc import x, y
1577 
1578         >>> f = (x**2 + x*y).as_poly(x, y)
1579         >>> f.as_expr()
1580         x**2 + x*y
1581 
1582         >>> sin(x).as_expr()
1583         sin(x)
1584 
1585         """
1586         return self
1587 
1588     def as_coefficient(self, expr):
1589         """
1590         Extracts symbolic coefficient at the given expression. In
1591         other words, this functions separates 'self' into the product
1592         of 'expr' and 'expr'-free coefficient. If such separation
1593         is not possible it will return None.
1594 
1595         Examples
1596         ========
1597 
1598         >>> from sympy import E, pi, sin, I, Poly
1599         >>> from sympy.abc import x
1600 
1601         >>> E.as_coefficient(E)
1602         1
1603         >>> (2*E).as_coefficient(E)
1604         2
1605         >>> (2*sin(E)*E).as_coefficient(E)
1606 
1607         Two terms have E in them so a sum is returned. (If one were
1608         desiring the coefficient of the term exactly matching E then
1609         the constant from the returned expression could be selected.
1610         Or, for greater precision, a method of Poly can be used to
1611         indicate the desired term from which the coefficient is
1612         desired.)
1613 
1614         >>> (2*E + x*E).as_coefficient(E)
1615         x + 2
1616         >>> _.args[0]  # just want the exact match
1617         2
1618         >>> p = Poly(2*E + x*E); p
1619         Poly(x*E + 2*E, x, E, domain='ZZ')
1620         >>> p.coeff_monomial(E)
1621         2
1622         >>> p.nth(0, 1)
1623         2
1624 
1625         Since the following cannot be written as a product containing
1626         E as a factor, None is returned. (If the coefficient ``2*x`` is
1627         desired then the ``coeff`` method should be used.)
1628 
1629         >>> (2*E*x + x).as_coefficient(E)
1630         >>> (2*E*x + x).coeff(E)
1631         2*x
1632 
1633         >>> (E*(x + 1) + x).as_coefficient(E)
1634 
1635         >>> (2*pi*I).as_coefficient(pi*I)
1636         2
1637         >>> (2*I).as_coefficient(pi*I)
1638 
1639         See Also
1640         ========
1641 
1642         coeff: return sum of terms have a given factor
1643         as_coeff_Add: separate the additive constant from an expression
1644         as_coeff_Mul: separate the multiplicative constant from an expression
1645         as_independent: separate x-dependent terms/factors from others
1646         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1647         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1648 
1649 
1650         """
1651 
1652         r = self.extract_multiplicatively(expr)
1653         if r and not r.has(expr):
1654             return r
1655 
1656     def as_independent(self, *deps, **hint):
1657         """
1658         A mostly naive separation of a Mul or Add into arguments that are not
1659         are dependent on deps. To obtain as complete a separation of variables
1660         as possible, use a separation method first, e.g.:
1661 
1662         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1663         * .expand(mul=True) to change Add or Mul into Add
1664         * .expand(log=True) to change log expr into an Add
1665 
1666         The only non-naive thing that is done here is to respect noncommutative
1667         ordering of variables and to always return (0, 0) for `self` of zero
1668         regardless of hints.
1669 
1670         For nonzero `self`, the returned tuple (i, d) has the
1671         following interpretation:
1672 
1673         * i will has no variable that appears in deps
1674         * d will either have terms that contain variables that are in deps, or
1675           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1676         * if self is an Add then self = i + d
1677         * if self is a Mul then self = i*d
1678         * otherwise (self, S.One) or (S.One, self) is returned.
1679 
1680         To force the expression to be treated as an Add, use the hint as_Add=True
1681 
1682         Examples
1683         ========
1684 
1685         -- self is an Add
1686 
1687         >>> from sympy import sin, cos, exp
1688         >>> from sympy.abc import x, y, z
1689 
1690         >>> (x + x*y).as_independent(x)
1691         (0, x*y + x)
1692         >>> (x + x*y).as_independent(y)
1693         (x, x*y)
1694         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1695         (y + z, 2*x*sin(x) + x)
1696         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1697         (z, 2*x*sin(x) + x + y)
1698 
1699         -- self is a Mul
1700 
1701         >>> (x*sin(x)*cos(y)).as_independent(x)
1702         (cos(y), x*sin(x))
1703 
1704         non-commutative terms cannot always be separated out when self is a Mul
1705 
1706         >>> from sympy import symbols
1707         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1708         >>> (n1 + n1*n2).as_independent(n2)
1709         (n1, n1*n2)
1710         >>> (n2*n1 + n1*n2).as_independent(n2)
1711         (0, n1*n2 + n2*n1)
1712         >>> (n1*n2*n3).as_independent(n1)
1713         (1, n1*n2*n3)
1714         >>> (n1*n2*n3).as_independent(n2)
1715         (n1, n2*n3)
1716         >>> ((x-n1)*(x-y)).as_independent(x)
1717         (1, (x - y)*(x - n1))
1718 
1719         -- self is anything else:
1720 
1721         >>> (sin(x)).as_independent(x)
1722         (1, sin(x))
1723         >>> (sin(x)).as_independent(y)
1724         (sin(x), 1)
1725         >>> exp(x+y).as_independent(x)
1726         (1, exp(x + y))
1727 
1728         -- force self to be treated as an Add:
1729 
1730         >>> (3*x).as_independent(x, as_Add=True)
1731         (0, 3*x)
1732 
1733         -- force self to be treated as a Mul:
1734 
1735         >>> (3+x).as_independent(x, as_Add=False)
1736         (1, x + 3)
1737         >>> (-3+x).as_independent(x, as_Add=False)
1738         (1, x - 3)
1739 
1740         Note how the below differs from the above in making the
1741         constant on the dep term positive.
1742 
1743         >>> (y*(-3+x)).as_independent(x)
1744         (y, x - 3)
1745 
1746         -- use .as_independent() for true independence testing instead
1747            of .has(). The former considers only symbols in the free
1748            symbols while the latter considers all symbols
1749 
1750         >>> from sympy import Integral
1751         >>> I = Integral(x, (x, 1, 2))
1752         >>> I.has(x)
1753         True
1754         >>> x in I.free_symbols
1755         False
1756         >>> I.as_independent(x) == (I, 1)
1757         True
1758         >>> (I + x).as_independent(x) == (I, x)
1759         True
1760 
1761         Note: when trying to get independent terms, a separation method
1762         might need to be used first. In this case, it is important to keep
1763         track of what you send to this routine so you know how to interpret
1764         the returned values
1765 
1766         >>> from sympy import separatevars, log
1767         >>> separatevars(exp(x+y)).as_independent(x)
1768         (exp(y), exp(x))
1769         >>> (x + x*y).as_independent(y)
1770         (x, x*y)
1771         >>> separatevars(x + x*y).as_independent(y)
1772         (x, y + 1)
1773         >>> (x*(1 + y)).as_independent(y)
1774         (x, y + 1)
1775         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1776         (x, x*y)
1777         >>> a, b=symbols('a b', positive=True)
1778         >>> (log(a*b).expand(log=True)).as_independent(b)
1779         (log(a), log(b))
1780 
1781         See Also
1782         ========
1783         .separatevars(), .expand(log=True), Add.as_two_terms(),
1784         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1785         """
1786         from .symbol import Symbol
1787         from .add import _unevaluated_Add
1788         from .mul import _unevaluated_Mul
1789         from sympy.utilities.iterables import sift
1790 
1791         if self.is_zero:
1792             return S.Zero, S.Zero
1793 
1794         func = self.func
1795         if hint.get('as_Add', isinstance(self, Add) ):
1796             want = Add
1797         else:
1798             want = Mul
1799 
1800         # sift out deps into symbolic and other and ignore
1801         # all symbols but those that are in the free symbols
1802         sym = set()
1803         other = []
1804         for d in deps:
1805             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1806                 sym.add(d)
1807             else:
1808                 other.append(d)
1809 
1810         def has(e):
1811             """return the standard has() if there are no literal symbols, else
1812             check to see that symbol-deps are in the free symbols."""
1813             has_other = e.has(*other)
1814             if not sym:
1815                 return has_other
1816             return has_other or e.has(*(e.free_symbols & sym))
1817 
1818         if (want is not func or
1819                 func is not Add and func is not Mul):
1820             if has(self):
1821                 return (want.identity, self)
1822             else:
1823                 return (self, want.identity)
1824         else:
1825             if func is Add:
1826                 args = list(self.args)
1827             else:
1828                 args, nc = self.args_cnc()
1829 
1830         d = sift(args, lambda x: has(x))
1831         depend = d[True]
1832         indep = d[False]
1833         if func is Add:  # all terms were treated as commutative
1834             return (Add(*indep), _unevaluated_Add(*depend))
1835         else:  # handle noncommutative by stopping at first dependent term
1836             for i, n in enumerate(nc):
1837                 if has(n):
1838                     depend.extend(nc[i:])
1839                     break
1840                 indep.append(n)
1841             return Mul(*indep), (
1842                 Mul(*depend, evaluate=False) if nc else
1843                 _unevaluated_Mul(*depend))
1844 
1845     def as_real_imag(self, deep=True, **hints):
1846         """Performs complex expansion on 'self' and returns a tuple
1847            containing collected both real and imaginary parts. This
1848            method can't be confused with re() and im() functions,
1849            which does not perform complex expansion at evaluation.
1850 
1851            However it is possible to expand both re() and im()
1852            functions and get exactly the same results as with
1853            a single call to this function.
1854 
1855            >>> from sympy import symbols, I
1856 
1857            >>> x, y = symbols('x,y', real=True)
1858 
1859            >>> (x + y*I).as_real_imag()
1860            (x, y)
1861 
1862            >>> from sympy.abc import z, w
1863 
1864            >>> (z + w*I).as_real_imag()
1865            (re(z) - im(w), re(w) + im(z))
1866 
1867         """
1868         from sympy import im, re
1869         if hints.get('ignore') == self:
1870             return None
1871         else:
1872             return (re(self), im(self))
1873 
1874     def as_powers_dict(self):
1875         """Return self as a dictionary of factors with each factor being
1876         treated as a power. The keys are the bases of the factors and the
1877         values, the corresponding exponents. The resulting dictionary should
1878         be used with caution if the expression is a Mul and contains non-
1879         commutative factors since the order that they appeared will be lost in
1880         the dictionary.
1881 
1882         See Also
1883         ========
1884         as_ordered_factors: An alternative for noncommutative applications,
1885                             returning an ordered list of factors.
1886         args_cnc: Similar to as_ordered_factors, but guarantees separation
1887                   of commutative and noncommutative factors.
1888         """
1889         d = defaultdict(int)
1890         d.update(dict([self.as_base_exp()]))
1891         return d
1892 
1893     def as_coefficients_dict(self):
1894         """Return a dictionary mapping terms to their Rational coefficient.
1895         Since the dictionary is a defaultdict, inquiries about terms which
1896         were not present will return a coefficient of 0. If an expression is
1897         not an Add it is considered to have a single term.
1898 
1899         Examples
1900         ========
1901 
1902         >>> from sympy.abc import a, x
1903         >>> (3*x + a*x + 4).as_coefficients_dict()
1904         {1: 4, x: 3, a*x: 1}
1905         >>> _[a]
1906         0
1907         >>> (3*a*x).as_coefficients_dict()
1908         {a*x: 3}
1909 
1910         """
1911         c, m = self.as_coeff_Mul()
1912         if not c.is_Rational:
1913             c = S.One
1914             m = self
1915         d = defaultdict(int)
1916         d.update({m: c})
1917         return d
1918 
1919     def as_base_exp(self):
1920         # a -> b ** e
1921         return self, S.One
1922 
1923     def as_coeff_mul(self, *deps, **kwargs):
1924         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1925 
1926         c should be a Rational multiplied by any factors of the Mul that are
1927         independent of deps.
1928 
1929         args should be a tuple of all other factors of m; args is empty
1930         if self is a Number or if self is independent of deps (when given).
1931 
1932         This should be used when you don't know if self is a Mul or not but
1933         you want to treat self as a Mul or if you want to process the
1934         individual arguments of the tail of self as a Mul.
1935 
1936         - if you know self is a Mul and want only the head, use self.args[0];
1937         - if you don't want to process the arguments of the tail but need the
1938           tail then use self.as_two_terms() which gives the head and tail;
1939         - if you want to split self into an independent and dependent parts
1940           use ``self.as_independent(*deps)``
1941 
1942         >>> from sympy import S
1943         >>> from sympy.abc import x, y
1944         >>> (S(3)).as_coeff_mul()
1945         (3, ())
1946         >>> (3*x*y).as_coeff_mul()
1947         (3, (x, y))
1948         >>> (3*x*y).as_coeff_mul(x)
1949         (3*y, (x,))
1950         >>> (3*y).as_coeff_mul(x)
1951         (3*y, ())
1952         """
1953         if deps:
1954             if not self.has(*deps):
1955                 return self, tuple()
1956         return S.One, (self,)
1957 
1958     def as_coeff_add(self, *deps):
1959         """Return the tuple (c, args) where self is written as an Add, ``a``.
1960 
1961         c should be a Rational added to any terms of the Add that are
1962         independent of deps.
1963 
1964         args should be a tuple of all other terms of ``a``; args is empty
1965         if self is a Number or if self is independent of deps (when given).
1966 
1967         This should be used when you don't know if self is an Add or not but
1968         you want to treat self as an Add or if you want to process the
1969         individual arguments of the tail of self as an Add.
1970 
1971         - if you know self is an Add and want only the head, use self.args[0];
1972         - if you don't want to process the arguments of the tail but need the
1973           tail then use self.as_two_terms() which gives the head and tail.
1974         - if you want to split self into an independent and dependent parts
1975           use ``self.as_independent(*deps)``
1976 
1977         >>> from sympy import S
1978         >>> from sympy.abc import x, y
1979         >>> (S(3)).as_coeff_add()
1980         (3, ())
1981         >>> (3 + x).as_coeff_add()
1982         (3, (x,))
1983         >>> (3 + x + y).as_coeff_add(x)
1984         (y + 3, (x,))
1985         >>> (3 + y).as_coeff_add(x)
1986         (y + 3, ())
1987 
1988         """
1989         if deps:
1990             if not self.has(*deps):
1991                 return self, tuple()
1992         return S.Zero, (self,)
1993 
1994     def primitive(self):
1995         """Return the positive Rational that can be extracted non-recursively
1996         from every term of self (i.e., self is treated like an Add). This is
1997         like the as_coeff_Mul() method but primitive always extracts a positive
1998         Rational (never a negative or a Float).
1999 
2000         Examples
2001         ========
2002 
2003         >>> from sympy.abc import x
2004         >>> (3*(x + 1)**2).primitive()
2005         (3, (x + 1)**2)
2006         >>> a = (6*x + 2); a.primitive()
2007         (2, 3*x + 1)
2008         >>> b = (x/2 + 3); b.primitive()
2009         (1/2, x + 6)
2010         >>> (a*b).primitive() == (1, a*b)
2011         True
2012         """
2013         if not self:
2014             return S.One, S.Zero
2015         c, r = self.as_coeff_Mul(rational=True)
2016         if c.is_negative:
2017             c, r = -c, -r
2018         return c, r
2019 
2020     def as_content_primitive(self, radical=False, clear=True):
2021         """This method should recursively remove a Rational from all arguments
2022         and return that (content) and the new self (primitive). The content
2023         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2024         The primitive need not be in canonical form and should try to preserve
2025         the underlying structure if possible (i.e. expand_mul should not be
2026         applied to self).
2027 
2028         Examples
2029         ========
2030 
2031         >>> from sympy import sqrt
2032         >>> from sympy.abc import x, y, z
2033 
2034         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2035 
2036         The as_content_primitive function is recursive and retains structure:
2037 
2038         >>> eq.as_content_primitive()
2039         (2, x + 3*y*(y + 1) + 1)
2040 
2041         Integer powers will have Rationals extracted from the base:
2042 
2043         >>> ((2 + 6*x)**2).as_content_primitive()
2044         (4, (3*x + 1)**2)
2045         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2046         (1, (2*(3*x + 1))**(2*y))
2047 
2048         Terms may end up joining once their as_content_primitives are added:
2049 
2050         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2051         (11, x*(y + 1))
2052         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2053         (9, x*(y + 1))
2054         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2055         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2056         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2057         (121, x**2*(y + 1)**2)
2058         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
2059         (1, 121.0*x**2*(y + 1)**2)
2060 
2061         Radical content can also be factored out of the primitive:
2062 
2063         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2064         (2, sqrt(2)*(1 + 2*sqrt(5)))
2065 
2066         If clear=False (default is True) then content will not be removed
2067         from an Add if it can be distributed to leave one or more
2068         terms with integer coefficients.
2069 
2070         >>> (x/2 + y).as_content_primitive()
2071         (1/2, x + 2*y)
2072         >>> (x/2 + y).as_content_primitive(clear=False)
2073         (1, x/2 + y)
2074         """
2075         return S.One, self
2076 
2077     def as_numer_denom(self):
2078         """ expression -> a/b -> a, b
2079 
2080         This is just a stub that should be defined by
2081         an object's class methods to get anything else.
2082 
2083         See Also
2084         ========
2085         normal: return a/b instead of a, b
2086         """
2087 
2088         return self, S.One
2089 
2090     def normal(self):
2091         from .mul import _unevaluated_Mul
2092         n, d = self.as_numer_denom()
2093         if d is S.One:
2094             return n
2095         if d.is_Number:
2096             return _unevaluated_Mul(n, 1/d)
2097         else:
2098             return n/d
2099 
2100     def extract_multiplicatively(self, c):
2101         """Return None if it's not possible to make self in the form
2102            c * something in a nice way, i.e. preserving the properties
2103            of arguments of self.
2104 
2105            Examples
2106            ========
2107 
2108            >>> from sympy import symbols, Rational
2109 
2110            >>> x, y = symbols('x,y', real=True)
2111 
2112            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2113            x*y**2
2114 
2115            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2116 
2117            >>> (2*x).extract_multiplicatively(2)
2118            x
2119 
2120            >>> (2*x).extract_multiplicatively(3)
2121 
2122            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2123            x/6
2124 
2125         """
2126         c = sympify(c)
2127         if self is S.NaN:
2128             return None
2129         if c is S.One:
2130             return self
2131         elif c == self:
2132             return S.One
2133 
2134         if c.is_Add:
2135             cc, pc = c.primitive()
2136             if cc is not S.One:
2137                 c = Mul(cc, pc, evaluate=False)
2138 
2139         if c.is_Mul:
2140             a, b = c.as_two_terms()
2141             x = self.extract_multiplicatively(a)
2142             if x is not None:
2143                 return x.extract_multiplicatively(b)
2144 
2145         quotient = self / c
2146         if self.is_Number:
2147             if self is S.Infinity:
2148                 if c.is_positive:
2149                     return S.Infinity
2150             elif self is S.NegativeInfinity:
2151                 if c.is_negative:
2152                     return S.Infinity
2153                 elif c.is_positive:
2154                     return S.NegativeInfinity
2155             elif self is S.ComplexInfinity:
2156                 if not c.is_zero:
2157                     return S.ComplexInfinity
2158             elif self.is_Integer:
2159                 if not quotient.is_Integer:
2160                     return None
2161                 elif self.is_positive and quotient.is_negative:
2162                     return None
2163                 else:
2164                     return quotient
2165             elif self.is_Rational:
2166                 if not quotient.is_Rational:
2167                     return None
2168                 elif self.is_positive and quotient.is_negative:
2169                     return None
2170                 else:
2171                     return quotient
2172             elif self.is_Float:
2173                 if not quotient.is_Float:
2174                     return None
2175                 elif self.is_positive and quotient.is_negative:
2176                     return None
2177                 else:
2178                     return quotient
2179         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2180             if quotient.is_Mul and len(quotient.args) == 2:
2181                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2182                     return quotient
2183             elif quotient.is_Integer and c.is_Number:
2184                 return quotient
2185         elif self.is_Add:
2186             cs, ps = self.primitive()
2187             # assert cs >= 1
2188             if c.is_Number and c is not S.NegativeOne:
2189                 # assert c != 1 (handled at top)
2190                 if cs is not S.One:
2191                     if c.is_negative:
2192                         xc = -(cs.extract_multiplicatively(-c))
2193                     else:
2194                         xc = cs.extract_multiplicatively(c)
2195                     if xc is not None:
2196                         return xc*ps  # rely on 2-arg Mul to restore Add
2197                 return  # |c| != 1 can only be extracted from cs
2198             if c == ps:
2199                 return cs
2200             # check args of ps
2201             newargs = []
2202             for arg in ps.args:
2203                 newarg = arg.extract_multiplicatively(c)
2204                 if newarg is None:
2205                     return  # all or nothing
2206                 newargs.append(newarg)
2207             # args should be in same order so use unevaluated return
2208             if cs is not S.One:
2209                 return Add._from_args([cs*t for t in newargs])
2210             else:
2211                 return Add._from_args(newargs)
2212         elif self.is_Mul:
2213             args = list(self.args)
2214             for i, arg in enumerate(args):
2215                 newarg = arg.extract_multiplicatively(c)
2216                 if newarg is not None:
2217                     args[i] = newarg
2218                     return Mul(*args)
2219         elif self.is_Pow:
2220             if c.is_Pow and c.base == self.base:
2221                 new_exp = self.exp.extract_additively(c.exp)
2222                 if new_exp is not None:
2223                     return self.base ** (new_exp)
2224             elif c == self.base:
2225                 new_exp = self.exp.extract_additively(1)
2226                 if new_exp is not None:
2227                     return self.base ** (new_exp)
2228 
2229     def extract_additively(self, c):
2230         """Return self - c if it's possible to subtract c from self and
2231         make all matching coefficients move towards zero, else return None.
2232 
2233         Examples
2234         ========
2235 
2236         >>> from sympy.abc import x, y
2237         >>> e = 2*x + 3
2238         >>> e.extract_additively(x + 1)
2239         x + 2
2240         >>> e.extract_additively(3*x)
2241         >>> e.extract_additively(4)
2242         >>> (y*(x + 1)).extract_additively(x + 1)
2243         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2244         (x + 1)*(x + 2*y) + 3
2245 
2246         Sometimes auto-expansion will return a less simplified result
2247         than desired; gcd_terms might be used in such cases:
2248 
2249         >>> from sympy import gcd_terms
2250         >>> (4*x*(y + 1) + y).extract_additively(x)
2251         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2252         >>> gcd_terms(_)
2253         x*(4*y + 3) + y
2254 
2255         See Also
2256         ========
2257         extract_multiplicatively
2258         coeff
2259         as_coefficient
2260 
2261         """
2262 
2263         c = sympify(c)
2264         if self is S.NaN:
2265             return None
2266         if c is S.Zero:
2267             return self
2268         elif c == self:
2269             return S.Zero
2270         elif self is S.Zero:
2271             return None
2272 
2273         if self.is_Number:
2274             if not c.is_Number:
2275                 return None
2276             co = self
2277             diff = co - c
2278             # XXX should we match types? i.e should 3 - .1 succeed?
2279             if (co > 0 and diff > 0 and diff < co or
2280                     co < 0 and diff < 0 and diff > co):
2281                 return diff
2282             return None
2283 
2284         if c.is_Number:
2285             co, t = self.as_coeff_Add()
2286             xa = co.extract_additively(c)
2287             if xa is None:
2288                 return None
2289             return xa + t
2290 
2291         # handle the args[0].is_Number case separately
2292         # since we will have trouble looking for the coeff of
2293         # a number.
2294         if c.is_Add and c.args[0].is_Number:
2295             # whole term as a term factor
2296             co = self.coeff(c)
2297             xa0 = (co.extract_additively(1) or 0)*c
2298             if xa0:
2299                 diff = self - co*c
2300                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2301             # term-wise
2302             h, t = c.as_coeff_Add()
2303             sh, st = self.as_coeff_Add()
2304             xa = sh.extract_additively(h)
2305             if xa is None:
2306                 return None
2307             xa2 = st.extract_additively(t)
2308             if xa2 is None:
2309                 return None
2310             return xa + xa2
2311 
2312         # whole term as a term factor
2313         co = self.coeff(c)
2314         xa0 = (co.extract_additively(1) or 0)*c
2315         if xa0:
2316             diff = self - co*c
2317             return (xa0 + (diff.extract_additively(c) or diff)) or None
2318         # term-wise
2319         coeffs = []
2320         for a in Add.make_args(c):
2321             ac, at = a.as_coeff_Mul()
2322             co = self.coeff(at)
2323             if not co:
2324                 return None
2325             coc, cot = co.as_coeff_Add()
2326             xa = coc.extract_additively(ac)
2327             if xa is None:
2328                 return None
2329             self -= co*at
2330             coeffs.append((cot + xa)*at)
2331         coeffs.append(self)
2332         return Add(*coeffs)
2333 
2334     @property
2335     def expr_free_symbols(self):
2336         """
2337         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2338 
2339         Examples
2340         ========
2341 
2342         >>> from sympy.abc import x, y
2343         >>> (x + y).expr_free_symbols
2344         {x, y}
2345 
2346         If the expression is contained in a non-expression object, don't return
2347         the free symbols. Compare:
2348 
2349         >>> from sympy import Tuple
2350         >>> t = Tuple(x + y)
2351         >>> t.expr_free_symbols
2352         set()
2353         >>> t.free_symbols
2354         {x, y}
2355         """
2356         return {j for i in self.args for j in i.expr_free_symbols}
2357 
2358     def could_extract_minus_sign(self):
2359         """Return True if self is not in a canonical form with respect
2360         to its sign.
2361 
2362         For most expressions, e, there will be a difference in e and -e.
2363         When there is, True will be returned for one and False for the
2364         other; False will be returned if there is no difference.
2365 
2366         Examples
2367         ========
2368 
2369         >>> from sympy.abc import x, y
2370         >>> e = x - y
2371         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2372         {False, True}
2373 
2374         """
2375         negative_self = -self
2376         if self == negative_self:
2377             return False  # e.g. zoo*x == -zoo*x
2378         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2379         negative_self_has_minus = (
2380             (negative_self).extract_multiplicatively(-1) is not None)
2381         if self_has_minus != negative_self_has_minus:
2382             return self_has_minus
2383         else:
2384             if self.is_Add:
2385                 # We choose the one with less arguments with minus signs
2386                 all_args = len(self.args)
2387                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2388                 positive_args = all_args - negative_args
2389                 if positive_args > negative_args:
2390                     return False
2391                 elif positive_args < negative_args:
2392                     return True
2393             elif self.is_Mul:
2394                 # We choose the one with an odd number of minus signs
2395                 num, den = self.as_numer_denom()
2396                 args = Mul.make_args(num) + Mul.make_args(den)
2397                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2398                 negative_args = list(filter(None, arg_signs))
2399                 return len(negative_args) % 2 == 1
2400 
2401             # As a last resort, we choose the one with greater value of .sort_key()
2402             return bool(self.sort_key() < negative_self.sort_key())
2403 
2404     def extract_branch_factor(self, allow_half=False):
2405         """
2406         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2407         Return (z, n).
2408 
2409         >>> from sympy import exp_polar, I, pi
2410         >>> from sympy.abc import x, y
2411         >>> exp_polar(I*pi).extract_branch_factor()
2412         (exp_polar(I*pi), 0)
2413         >>> exp_polar(2*I*pi).extract_branch_factor()
2414         (1, 1)
2415         >>> exp_polar(-pi*I).extract_branch_factor()
2416         (exp_polar(I*pi), -1)
2417         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2418         (exp_polar(x + I*pi), 1)
2419         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2420         (y*exp_polar(2*pi*x), -1)
2421         >>> exp_polar(-I*pi/2).extract_branch_factor()
2422         (exp_polar(-I*pi/2), 0)
2423 
2424         If allow_half is True, also extract exp_polar(I*pi):
2425 
2426         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2427         (1, 1/2)
2428         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2429         (1, 1)
2430         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2431         (1, 3/2)
2432         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2433         (1, -1/2)
2434         """
2435         from sympy import exp_polar, pi, I, ceiling, Add
2436         n = S(0)
2437         res = S(1)
2438         args = Mul.make_args(self)
2439         exps = []
2440         for arg in args:
2441             if isinstance(arg, exp_polar):
2442                 exps += [arg.exp]
2443             else:
2444                 res *= arg
2445         piimult = S(0)
2446         extras = []
2447         while exps:
2448             exp = exps.pop()
2449             if exp.is_Add:
2450                 exps += exp.args
2451                 continue
2452             if exp.is_Mul:
2453                 coeff = exp.as_coefficient(pi*I)
2454                 if coeff is not None:
2455                     piimult += coeff
2456                     continue
2457             extras += [exp]
2458         if piimult.is_number:
2459             coeff = piimult
2460             tail = ()
2461         else:
2462             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2463         # round down to nearest multiple of 2
2464         branchfact = ceiling(coeff/2 - S(1)/2)*2
2465         n += branchfact/2
2466         c = coeff - branchfact
2467         if allow_half:
2468             nc = c.extract_additively(1)
2469             if nc is not None:
2470                 n += S(1)/2
2471                 c = nc
2472         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2473         if newexp != 0:
2474             res *= exp_polar(newexp)
2475         return res, n
2476 
2477     def _eval_is_polynomial(self, syms):
2478         if self.free_symbols.intersection(syms) == set([]):
2479             return True
2480         return False
2481 
2482     def is_polynomial(self, *syms):
2483         r"""
2484         Return True if self is a polynomial in syms and False otherwise.
2485 
2486         This checks if self is an exact polynomial in syms.  This function
2487         returns False for expressions that are "polynomials" with symbolic
2488         exponents.  Thus, you should be able to apply polynomial algorithms to
2489         expressions for which this returns True, and Poly(expr, \*syms) should
2490         work if and only if expr.is_polynomial(\*syms) returns True. The
2491         polynomial does not have to be in expanded form.  If no symbols are
2492         given, all free symbols in the expression will be used.
2493 
2494         This is not part of the assumptions system.  You cannot do
2495         Symbol('z', polynomial=True).
2496 
2497         Examples
2498         ========
2499 
2500         >>> from sympy import Symbol
2501         >>> x = Symbol('x')
2502         >>> ((x**2 + 1)**4).is_polynomial(x)
2503         True
2504         >>> ((x**2 + 1)**4).is_polynomial()
2505         True
2506         >>> (2**x + 1).is_polynomial(x)
2507         False
2508 
2509 
2510         >>> n = Symbol('n', nonnegative=True, integer=True)
2511         >>> (x**n + 1).is_polynomial(x)
2512         False
2513 
2514         This function does not attempt any nontrivial simplifications that may
2515         result in an expression that does not appear to be a polynomial to
2516         become one.
2517 
2518         >>> from sympy import sqrt, factor, cancel
2519         >>> y = Symbol('y', positive=True)
2520         >>> a = sqrt(y**2 + 2*y + 1)
2521         >>> a.is_polynomial(y)
2522         False
2523         >>> factor(a)
2524         y + 1
2525         >>> factor(a).is_polynomial(y)
2526         True
2527 
2528         >>> b = (y**2 + 2*y + 1)/(y + 1)
2529         >>> b.is_polynomial(y)
2530         False
2531         >>> cancel(b)
2532         y + 1
2533         >>> cancel(b).is_polynomial(y)
2534         True
2535 
2536         See also .is_rational_function()
2537 
2538         """
2539         if syms:
2540             syms = set(map(sympify, syms))
2541         else:
2542             syms = self.free_symbols
2543 
2544         if syms.intersection(self.free_symbols) == set([]):
2545             # constant polynomial
2546             return True
2547         else:
2548             return self._eval_is_polynomial(syms)
2549 
2550     def _eval_is_rational_function(self, syms):
2551         if self.free_symbols.intersection(syms) == set([]):
2552             return True
2553         return False
2554 
2555     def is_rational_function(self, *syms):
2556         """
2557         Test whether function is a ratio of two polynomials in the given
2558         symbols, syms. When syms is not given, all free symbols will be used.
2559         The rational function does not have to be in expanded or in any kind of
2560         canonical form.
2561 
2562         This function returns False for expressions that are "rational
2563         functions" with symbolic exponents.  Thus, you should be able to call
2564         .as_numer_denom() and apply polynomial algorithms to the result for
2565         expressions for which this returns True.
2566 
2567         This is not part of the assumptions system.  You cannot do
2568         Symbol('z', rational_function=True).
2569 
2570         Examples
2571         ========
2572 
2573         >>> from sympy import Symbol, sin
2574         >>> from sympy.abc import x, y
2575 
2576         >>> (x/y).is_rational_function()
2577         True
2578 
2579         >>> (x**2).is_rational_function()
2580         True
2581 
2582         >>> (x/sin(y)).is_rational_function(y)
2583         False
2584 
2585         >>> n = Symbol('n', integer=True)
2586         >>> (x**n + 1).is_rational_function(x)
2587         False
2588 
2589         This function does not attempt any nontrivial simplifications that may
2590         result in an expression that does not appear to be a rational function
2591         to become one.
2592 
2593         >>> from sympy import sqrt, factor
2594         >>> y = Symbol('y', positive=True)
2595         >>> a = sqrt(y**2 + 2*y + 1)/y
2596         >>> a.is_rational_function(y)
2597         False
2598         >>> factor(a)
2599         (y + 1)/y
2600         >>> factor(a).is_rational_function(y)
2601         True
2602 
2603         See also is_algebraic_expr().
2604 
2605         """
2606         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2607             return False
2608 
2609         if syms:
2610             syms = set(map(sympify, syms))
2611         else:
2612             syms = self.free_symbols
2613 
2614         if syms.intersection(self.free_symbols) == set([]):
2615             # constant rational function
2616             return True
2617         else:
2618             return self._eval_is_rational_function(syms)
2619 
2620     def _eval_is_algebraic_expr(self, syms):
2621         if self.free_symbols.intersection(syms) == set([]):
2622             return True
2623         return False
2624 
2625     def is_algebraic_expr(self, *syms):
2626         """
2627         This tests whether a given expression is algebraic or not, in the
2628         given symbols, syms. When syms is not given, all free symbols
2629         will be used. The rational function does not have to be in expanded
2630         or in any kind of canonical form.
2631 
2632         This function returns False for expressions that are "algebraic
2633         expressions" with symbolic exponents. This is a simple extension to the
2634         is_rational_function, including rational exponentiation.
2635 
2636         Examples
2637         ========
2638 
2639         >>> from sympy import Symbol, sqrt
2640         >>> x = Symbol('x', real=True)
2641         >>> sqrt(1 + x).is_rational_function()
2642         False
2643         >>> sqrt(1 + x).is_algebraic_expr()
2644         True
2645 
2646         This function does not attempt any nontrivial simplifications that may
2647         result in an expression that does not appear to be an algebraic
2648         expression to become one.
2649 
2650         >>> from sympy import exp, factor
2651         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2652         >>> a.is_algebraic_expr(x)
2653         False
2654         >>> factor(a).is_algebraic_expr()
2655         True
2656 
2657         See Also
2658         ========
2659         is_rational_function()
2660 
2661         References
2662         ==========
2663 
2664         - https://en.wikipedia.org/wiki/Algebraic_expression
2665 
2666         """
2667         if syms:
2668             syms = set(map(sympify, syms))
2669         else:
2670             syms = self.free_symbols
2671 
2672         if syms.intersection(self.free_symbols) == set([]):
2673             # constant algebraic expression
2674             return True
2675         else:
2676             return self._eval_is_algebraic_expr(syms)
2677 
2678     ###################################################################################
2679     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2680     ###################################################################################
2681 
2682     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2683         """
2684         Series expansion of "self" around ``x = x0`` yielding either terms of
2685         the series one by one (the lazy series given when n=None), else
2686         all the terms at once when n != None.
2687 
2688         Returns the series expansion of "self" around the point ``x = x0``
2689         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2690 
2691         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2692         be supplied, otherwise an error will be raised.
2693 
2694         >>> from sympy import cos, exp
2695         >>> from sympy.abc import x, y
2696         >>> cos(x).series()
2697         1 - x**2/2 + x**4/24 + O(x**6)
2698         >>> cos(x).series(n=4)
2699         1 - x**2/2 + O(x**4)
2700         >>> cos(x).series(x, x0=1, n=2)
2701         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2702         >>> e = cos(x + exp(y))
2703         >>> e.series(y, n=2)
2704         cos(x + 1) - y*sin(x + 1) + O(y**2)
2705         >>> e.series(x, n=2)
2706         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2707 
2708         If ``n=None`` then a generator of the series terms will be returned.
2709 
2710         >>> term=cos(x).series(n=None)
2711         >>> [next(term) for i in range(2)]
2712         [1, -x**2/2]
2713 
2714         For ``dir=+`` (default) the series is calculated from the right and
2715         for ``dir=-`` the series from the left. For smooth functions this
2716         flag will not alter the results.
2717 
2718         >>> abs(x).series(dir="+")
2719         x
2720         >>> abs(x).series(dir="-")
2721         -x
2722 
2723         """
2724         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2725         if x is None:
2726             syms = self.free_symbols
2727             if not syms:
2728                 return self
2729             elif len(syms) > 1:
2730                 raise ValueError('x must be given for multivariate functions.')
2731             x = syms.pop()
2732 
2733         if isinstance(x, Symbol):
2734             dep = x in self.free_symbols
2735         else:
2736             d = Dummy()
2737             dep = d in self.xreplace({x: d}).free_symbols
2738         if not dep:
2739             if n is None:
2740                 return (s for s in [self])
2741             else:
2742                 return self
2743 
2744         if len(dir) != 1 or dir not in '+-':
2745             raise ValueError("Dir must be '+' or '-'")
2746 
2747         if x0 in [S.Infinity, S.NegativeInfinity]:
2748             sgn = 1 if x0 is S.Infinity else -1
2749             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2750             if n is None:
2751                 return (si.subs(x, sgn/x) for si in s)
2752             return s.subs(x, sgn/x)
2753 
2754 
2755         # use rep to shift origin to x0 and change sign (if dir is negative)
2756         # and undo the process with rep2
2757         if x0 or dir == '-':
2758             if dir == '-':
2759                 rep = -x + x0
2760                 rep2 = -x
2761                 rep2b = x0
2762             else:
2763                 rep = x + x0
2764                 rep2 = x
2765                 rep2b = -x0
2766             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2767             if n is None:  # lseries...
2768                 return (si.subs(x, rep2 + rep2b) for si in s)
2769             return s.subs(x, rep2 + rep2b)
2770 
2771         # from here on it's x0=0 and dir='+' handling
2772 
2773         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2774             # replace x with an x that has a positive assumption
2775             xpos = Dummy('x', positive=True, finite=True)
2776             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2777             if n is None:
2778                 return (s.subs(xpos, x) for s in rv)
2779             else:
2780                 return rv.subs(xpos, x)
2781 
2782         if n is not None:  # nseries handling
2783             s1 = self._eval_nseries(x, n=n, logx=logx)
2784             o = s1.getO() or S.Zero
2785             if o:
2786                 # make sure the requested order is returned
2787                 ngot = o.getn()
2788                 if ngot > n:
2789                     # leave o in its current form (e.g. with x*log(x)) so
2790                     # it eats terms properly, then replace it below
2791                     if n != 0:
2792                         s1 += o.subs(x, x**Rational(n, ngot))
2793                     else:
2794                         s1 += Order(1, x)
2795                 elif ngot < n:
2796                     # increase the requested number of terms to get the desired
2797                     # number keep increasing (up to 9) until the received order
2798                     # is different than the original order and then predict how
2799                     # many additional terms are needed
2800                     for more in range(1, 9):
2801                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2802                         newn = s1.getn()
2803                         if newn != ngot:
2804                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2805                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2806                             while s1.getn() < n:
2807                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2808                                 ndo += 1
2809                             break
2810                     else:
2811                         raise ValueError('Could not calculate %s terms for %s'
2812                                          % (str(n), self))
2813                     s1 += Order(x**n, x)
2814                 o = s1.getO()
2815                 s1 = s1.removeO()
2816             else:
2817                 o = Order(x**n, x)
2818                 s1done = s1.doit()
2819                 if (s1done + o).removeO() == s1done:
2820                     o = S.Zero
2821 
2822             try:
2823                 return collect(s1, x) + o
2824             except NotImplementedError:
2825                 return s1 + o
2826 
2827         else:  # lseries handling
2828             def yield_lseries(s):
2829                 """Return terms of lseries one at a time."""
2830                 for si in s:
2831                     if not si.is_Add:
2832                         yield si
2833                         continue
2834                     # yield terms 1 at a time if possible
2835                     # by increasing order until all the
2836                     # terms have been returned
2837                     yielded = 0
2838                     o = Order(si, x)*x
2839                     ndid = 0
2840                     ndo = len(si.args)
2841                     while 1:
2842                         do = (si - yielded + o).removeO()
2843                         o *= x
2844                         if not do or do.is_Order:
2845                             continue
2846                         if do.is_Add:
2847                             ndid += len(do.args)
2848                         else:
2849                             ndid += 1
2850                         yield do
2851                         if ndid == ndo:
2852                             break
2853                         yielded += do
2854 
2855             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2856 
2857     def taylor_term(self, n, x, *previous_terms):
2858         """General method for the taylor term.
2859 
2860         This method is slow, because it differentiates n-times. Subclasses can
2861         redefine it to make it faster by using the "previous_terms".
2862         """
2863         from sympy import Dummy, factorial
2864         x = sympify(x)
2865         _x = Dummy('x')
2866         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2867 
2868     def lseries(self, x=None, x0=0, dir='+', logx=None):
2869         """
2870         Wrapper for series yielding an iterator of the terms of the series.
2871 
2872         Note: an infinite series will yield an infinite iterator. The following,
2873         for exaxmple, will never terminate. It will just keep printing terms
2874         of the sin(x) series::
2875 
2876           for term in sin(x).lseries(x):
2877               print term
2878 
2879         The advantage of lseries() over nseries() is that many times you are
2880         just interested in the next term in the series (i.e. the first term for
2881         example), but you don't know how many you should ask for in nseries()
2882         using the "n" parameter.
2883 
2884         See also nseries().
2885         """
2886         return self.series(x, x0, n=None, dir=dir, logx=logx)
2887 
2888     def _eval_lseries(self, x, logx=None):
2889         # default implementation of lseries is using nseries(), and adaptively
2890         # increasing the "n". As you can see, it is not very efficient, because
2891         # we are calculating the series over and over again. Subclasses should
2892         # override this method and implement much more efficient yielding of
2893         # terms.
2894         n = 0
2895         series = self._eval_nseries(x, n=n, logx=logx)
2896         if not series.is_Order:
2897             if series.is_Add:
2898                 yield series.removeO()
2899             else:
2900                 yield series
2901             return
2902 
2903         while series.is_Order:
2904             n += 1
2905             series = self._eval_nseries(x, n=n, logx=logx)
2906         e = series.removeO()
2907         yield e
2908         while 1:
2909             while 1:
2910                 n += 1
2911                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2912                 if e != series:
2913                     break
2914             yield series - e
2915             e = series
2916 
2917     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2918         """
2919         Wrapper to _eval_nseries if assumptions allow, else to series.
2920 
2921         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2922         called. This calculates "n" terms in the innermost expressions and
2923         then builds up the final series just by "cross-multiplying" everything
2924         out.
2925 
2926         The optional ``logx`` parameter can be used to replace any log(x) in the
2927         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2928         symbol to use in place of log(x) should be provided.
2929 
2930         Advantage -- it's fast, because we don't have to determine how many
2931         terms we need to calculate in advance.
2932 
2933         Disadvantage -- you may end up with less terms than you may have
2934         expected, but the O(x**n) term appended will always be correct and
2935         so the result, though perhaps shorter, will also be correct.
2936 
2937         If any of those assumptions is not met, this is treated like a
2938         wrapper to series which will try harder to return the correct
2939         number of terms.
2940 
2941         See also lseries().
2942 
2943         Examples
2944         ========
2945 
2946         >>> from sympy import sin, log, Symbol
2947         >>> from sympy.abc import x, y
2948         >>> sin(x).nseries(x, 0, 6)
2949         x - x**3/6 + x**5/120 + O(x**6)
2950         >>> log(x+1).nseries(x, 0, 5)
2951         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2952 
2953         Handling of the ``logx`` parameter --- in the following example the
2954         expansion fails since ``sin`` does not have an asymptotic expansion
2955         at -oo (the limit of log(x) as x approaches 0):
2956 
2957         >>> e = sin(log(x))
2958         >>> e.nseries(x, 0, 6)
2959         Traceback (most recent call last):
2960         ...
2961         PoleError: ...
2962         ...
2963         >>> logx = Symbol('logx')
2964         >>> e.nseries(x, 0, 6, logx=logx)
2965         sin(logx)
2966 
2967         In the following example, the expansion works but gives only an Order term
2968         unless the ``logx`` parameter is used:
2969 
2970         >>> e = x**y
2971         >>> e.nseries(x, 0, 2)
2972         O(log(x)**2)
2973         >>> e.nseries(x, 0, 2, logx=logx)
2974         exp(logx*y)
2975 
2976         """
2977         if x and not x in self.free_symbols:
2978             return self
2979         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2980             return self.series(x, x0, n, dir)
2981         else:
2982             return self._eval_nseries(x, n=n, logx=logx)
2983 
2984     def _eval_nseries(self, x, n, logx):
2985         """
2986         Return terms of series for self up to O(x**n) at x=0
2987         from the positive direction.
2988 
2989         This is a method that should be overridden in subclasses. Users should
2990         never call this method directly (use .nseries() instead), so you don't
2991         have to write docstrings for _eval_nseries().
2992         """
2993         from sympy.utilities.misc import filldedent
2994         raise NotImplementedError(filldedent("""
2995                      The _eval_nseries method should be added to
2996                      %s to give terms up to O(x**n) at x=0
2997                      from the positive direction so it is available when
2998                      nseries calls it.""" % self.func)
2999                      )
3000 
3001     def limit(self, x, xlim, dir='+'):
3002         """ Compute limit x->xlim.
3003         """
3004         from sympy.series.limits import limit
3005         return limit(self, x, xlim, dir)
3006 
3007     def compute_leading_term(self, x, logx=None):
3008         """
3009         as_leading_term is only allowed for results of .series()
3010         This is a wrapper to compute a series first.
3011         """
3012         from sympy import Dummy, log
3013         from sympy.series.gruntz import calculate_series
3014 
3015         if self.removeO() == 0:
3016             return self
3017 
3018         if logx is None:
3019             d = Dummy('logx')
3020             s = calculate_series(self, x, d).subs(d, log(x))
3021         else:
3022             s = calculate_series(self, x, logx)
3023 
3024         return s.as_leading_term(x)
3025 
3026     @cacheit
3027     def as_leading_term(self, *symbols):
3028         """
3029         Returns the leading (nonzero) term of the series expansion of self.
3030 
3031         The _eval_as_leading_term routines are used to do this, and they must
3032         always return a non-zero value.
3033 
3034         Examples
3035         ========
3036 
3037         >>> from sympy.abc import x
3038         >>> (1 + x + x**2).as_leading_term(x)
3039         1
3040         >>> (1/x**2 + x + x**2).as_leading_term(x)
3041         x**(-2)
3042 
3043         """
3044         from sympy import powsimp
3045         if len(symbols) > 1:
3046             c = self
3047             for x in symbols:
3048                 c = c.as_leading_term(x)
3049             return c
3050         elif not symbols:
3051             return self
3052         x = sympify(symbols[0])
3053         if not x.is_symbol:
3054             raise ValueError('expecting a Symbol but got %s' % x)
3055         if x not in self.free_symbols:
3056             return self
3057         obj = self._eval_as_leading_term(x)
3058         if obj is not None:
3059             return powsimp(obj, deep=True, combine='exp')
3060         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3061 
3062     def _eval_as_leading_term(self, x):
3063         return self
3064 
3065     def as_coeff_exponent(self, x):
3066         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3067         """
3068         from sympy import collect
3069         s = collect(self, x)
3070         c, p = s.as_coeff_mul(x)
3071         if len(p) == 1:
3072             b, e = p[0].as_base_exp()
3073             if b == x:
3074                 return c, e
3075         return s, S.Zero
3076 
3077     def leadterm(self, x):
3078         """
3079         Returns the leading term a*x**b as a tuple (a, b).
3080 
3081         Examples
3082         ========
3083 
3084         >>> from sympy.abc import x
3085         >>> (1+x+x**2).leadterm(x)
3086         (1, 0)
3087         >>> (1/x**2+x+x**2).leadterm(x)
3088         (1, -2)
3089 
3090         """
3091         from sympy import Dummy, log
3092         l = self.as_leading_term(x)
3093         d = Dummy('logx')
3094         if l.has(log(x)):
3095             l = l.subs(log(x), d)
3096         c, e = l.as_coeff_exponent(x)
3097         if x in c.free_symbols:
3098             from sympy.utilities.misc import filldedent
3099             raise ValueError(filldedent("""
3100                 cannot compute leadterm(%s, %s). The coefficient
3101                 should have been free of x but got %s""" % (self, x, c)))
3102         c = c.subs(d, log(x))
3103         return c, e
3104 
3105     def as_coeff_Mul(self, rational=False):
3106         """Efficiently extract the coefficient of a product. """
3107         return S.One, self
3108 
3109     def as_coeff_Add(self, rational=False):
3110         """Efficiently extract the coefficient of a summation. """
3111         return S.Zero, self
3112 
3113     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3114             full=False):
3115         """
3116         Compute formal power power series of self.
3117 
3118         See the docstring of the :func:`fps` function in sympy.series.formal for
3119         more information.
3120         """
3121         from sympy.series.formal import fps
3122 
3123         return fps(self, x, x0, dir, hyper, order, rational, full)
3124 
3125     def fourier_series(self, limits=None):
3126         """Compute fourier sine/cosine series of self.
3127 
3128         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3129         for more information.
3130         """
3131         from sympy.series.fourier import fourier_series
3132 
3133         return fourier_series(self, limits)
3134 
3135     ###################################################################################
3136     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3137     ###################################################################################
3138 
3139     def diff(self, *symbols, **assumptions):
3140         assumptions.setdefault("evaluate", True)
3141         return Derivative(self, *symbols, **assumptions)
3142 
3143     ###########################################################################
3144     ###################### EXPRESSION EXPANSION METHODS #######################
3145     ###########################################################################
3146 
3147     # Relevant subclasses should override _eval_expand_hint() methods.  See
3148     # the docstring of expand() for more info.
3149 
3150     def _eval_expand_complex(self, **hints):
3151         real, imag = self.as_real_imag(**hints)
3152         return real + S.ImaginaryUnit*imag
3153 
3154     @staticmethod
3155     def _expand_hint(expr, hint, deep=True, **hints):
3156         """
3157         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3158 
3159         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3160         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3161         ``False`` otherwise.
3162         """
3163         hit = False
3164         # XXX: Hack to support non-Basic args
3165         #              |
3166         #              V
3167         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3168             sargs = []
3169             for arg in expr.args:
3170                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3171                 hit |= arghit
3172                 sargs.append(arg)
3173 
3174             if hit:
3175                 expr = expr.func(*sargs)
3176 
3177         if hasattr(expr, hint):
3178             newexpr = getattr(expr, hint)(**hints)
3179             if newexpr != expr:
3180                 return (newexpr, True)
3181 
3182         return (expr, hit)
3183 
3184     @cacheit
3185     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3186             mul=True, log=True, multinomial=True, basic=True, **hints):
3187         """
3188         Expand an expression using hints.
3189 
3190         See the docstring of the expand() function in sympy.core.function for
3191         more information.
3192 
3193         """
3194         from sympy.simplify.radsimp import fraction
3195 
3196         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3197            log=log, multinomial=multinomial, basic=basic)
3198 
3199         expr = self
3200         if hints.pop('frac', False):
3201             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3202                     for a in fraction(self)]
3203             return n/d
3204         elif hints.pop('denom', False):
3205             n, d = fraction(self)
3206             return n/d.expand(deep=deep, modulus=modulus, **hints)
3207         elif hints.pop('numer', False):
3208             n, d = fraction(self)
3209             return n.expand(deep=deep, modulus=modulus, **hints)/d
3210 
3211         # Although the hints are sorted here, an earlier hint may get applied
3212         # at a given node in the expression tree before another because of how
3213         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3214         # x*z) because while applying log at the top level, log and mul are
3215         # applied at the deeper level in the tree so that when the log at the
3216         # upper level gets applied, the mul has already been applied at the
3217         # lower level.
3218 
3219         # Additionally, because hints are only applied once, the expression
3220         # may not be expanded all the way.   For example, if mul is applied
3221         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3222         # now, we just use a special case to make multinomial run before mul,
3223         # so that at least polynomials will be expanded all the way.  In the
3224         # future, smarter heuristics should be applied.
3225         # TODO: Smarter heuristics
3226 
3227         def _expand_hint_key(hint):
3228             """Make multinomial come before mul"""
3229             if hint == 'mul':
3230                 return 'mulz'
3231             return hint
3232 
3233         for hint in sorted(hints.keys(), key=_expand_hint_key):
3234             use_hint = hints[hint]
3235             if use_hint:
3236                 hint = '_eval_expand_' + hint
3237                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3238 
3239         while True:
3240             was = expr
3241             if hints.get('multinomial', False):
3242                 expr, _ = Expr._expand_hint(
3243                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3244             if hints.get('mul', False):
3245                 expr, _ = Expr._expand_hint(
3246                     expr, '_eval_expand_mul', deep=deep, **hints)
3247             if hints.get('log', False):
3248                 expr, _ = Expr._expand_hint(
3249                     expr, '_eval_expand_log', deep=deep, **hints)
3250             if expr == was:
3251                 break
3252 
3253         if modulus is not None:
3254             modulus = sympify(modulus)
3255 
3256             if not modulus.is_Integer or modulus <= 0:
3257                 raise ValueError(
3258                     "modulus must be a positive integer, got %s" % modulus)
3259 
3260             terms = []
3261 
3262             for term in Add.make_args(expr):
3263                 coeff, tail = term.as_coeff_Mul(rational=True)
3264 
3265                 coeff %= modulus
3266 
3267                 if coeff:
3268                     terms.append(coeff*tail)
3269 
3270             expr = Add(*terms)
3271 
3272         return expr
3273 
3274     ###########################################################################
3275     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3276     ###########################################################################
3277 
3278     def integrate(self, *args, **kwargs):
3279         """See the integrate function in sympy.integrals"""
3280         from sympy.integrals import integrate
3281         return integrate(self, *args, **kwargs)
3282 
3283     def simplify(self, ratio=1.7, measure=None, rational=False, inverse=False):
3284         """See the simplify function in sympy.simplify"""
3285         from sympy.simplify import simplify
3286         from sympy.core.function import count_ops
3287         measure = measure or count_ops
3288         return simplify(self, ratio, measure)
3289 
3290     def nsimplify(self, constants=[], tolerance=None, full=False):
3291         """See the nsimplify function in sympy.simplify"""
3292         from sympy.simplify import nsimplify
3293         return nsimplify(self, constants, tolerance, full)
3294 
3295     def separate(self, deep=False, force=False):
3296         """See the separate function in sympy.simplify"""
3297         from sympy.core.function import expand_power_base
3298         return expand_power_base(self, deep=deep, force=force)
3299 
3300     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3301         """See the collect function in sympy.simplify"""
3302         from sympy.simplify import collect
3303         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3304 
3305     def together(self, *args, **kwargs):
3306         """See the together function in sympy.polys"""
3307         from sympy.polys import together
3308         return together(self, *args, **kwargs)
3309 
3310     def apart(self, x=None, **args):
3311         """See the apart function in sympy.polys"""
3312         from sympy.polys import apart
3313         return apart(self, x, **args)
3314 
3315     def ratsimp(self):
3316         """See the ratsimp function in sympy.simplify"""
3317         from sympy.simplify import ratsimp
3318         return ratsimp(self)
3319 
3320     def trigsimp(self, **args):
3321         """See the trigsimp function in sympy.simplify"""
3322         from sympy.simplify import trigsimp
3323         return trigsimp(self, **args)
3324 
3325     def radsimp(self, **kwargs):
3326         """See the radsimp function in sympy.simplify"""
3327         from sympy.simplify import radsimp
3328         return radsimp(self, **kwargs)
3329 
3330     def powsimp(self, *args, **kwargs):
3331         """See the powsimp function in sympy.simplify"""
3332         from sympy.simplify import powsimp
3333         return powsimp(self, *args, **kwargs)
3334 
3335     def combsimp(self):
3336         """See the combsimp function in sympy.simplify"""
3337         from sympy.simplify import combsimp
3338         return combsimp(self)
3339 
3340     def gammasimp(self):
3341         """See the gammasimp function in sympy.simplify"""
3342         from sympy.simplify import gammasimp
3343         return gammasimp(self)
3344 
3345     def factor(self, *gens, **args):
3346         """See the factor() function in sympy.polys.polytools"""
3347         from sympy.polys import factor
3348         return factor(self, *gens, **args)
3349 
3350     def refine(self, assumption=True):
3351         """See the refine function in sympy.assumptions"""
3352         from sympy.assumptions import refine
3353         return refine(self, assumption)
3354 
3355     def cancel(self, *gens, **args):
3356         """See the cancel function in sympy.polys"""
3357         from sympy.polys import cancel
3358         return cancel(self, *gens, **args)
3359 
3360     def invert(self, g, *gens, **args):
3361         """Return the multiplicative inverse of ``self`` mod ``g``
3362         where ``self`` (and ``g``) may be symbolic expressions).
3363 
3364         See Also
3365         ========
3366         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3367         """
3368         from sympy.polys.polytools import invert
3369         from sympy.core.numbers import mod_inverse
3370         if self.is_number and getattr(g, 'is_number', True):
3371             return mod_inverse(self, g)
3372         return invert(self, g, *gens, **args)
3373 
3374     def round(self, n=None):
3375         """Return x rounded to the given decimal place.
3376 
3377         If a complex number would results, apply round to the real
3378         and imaginary components of the number.
3379 
3380         Examples
3381         ========
3382 
3383         >>> from sympy import pi, E, I, S, Add, Mul, Number
3384         >>> pi.round()
3385         3
3386         >>> pi.round(2)
3387         3.14
3388         >>> (2*pi + E*I).round()
3389         6 + 3*I
3390 
3391         The round method has a chopping effect:
3392 
3393         >>> (2*pi + I/10).round()
3394         6
3395         >>> (pi/10 + 2*I).round()
3396         2*I
3397         >>> (pi/10 + E*I).round(2)
3398         0.31 + 2.72*I
3399 
3400         Notes
3401         =====
3402 
3403         The Python builtin function, round, always returns a
3404         float in Python 2 while the SymPy round method (and
3405         round with a Number argument in Python 3) returns a
3406         Number.
3407 
3408         >>> from sympy.core.compatibility import PY3
3409         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3410         True
3411 
3412         For a consistent behavior, and Python 3 rounding
3413         rules, import `round` from sympy.core.compatibility.
3414 
3415         >>> from sympy.core.compatibility import round
3416         >>> isinstance(round(S(123), -2), Number)
3417         True
3418         """
3419         from sympy.core.power import integer_log
3420         from sympy.core.numbers import Float
3421 
3422         x = self
3423 
3424         if not x.is_number:
3425             raise TypeError("can't round symbolic expression")
3426         if not x.is_Atom:
3427             if not pure_complex(x.n(2), or_real=True):
3428                 raise TypeError(
3429                     'Expected a number but got %s:' % func_name(x))
3430         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3431             return x
3432         if not x.is_extended_real:
3433             i, r = x.as_real_imag()
3434             return i.round(n) + S.ImaginaryUnit*r.round(n)
3435         if not x:
3436             return S.Zero if n is None else x
3437 
3438 
3439         p = as_int(n or 0)
3440 
3441         if x.is_Integer:
3442             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3443             if p >= 0:
3444                 return x
3445             m = 10**-p
3446             i, r = divmod(abs(x), m)
3447             if i%2 and 2*r == m:
3448               i += 1
3449             elif 2*r > m:
3450                 i += 1
3451             if x < 0:
3452                 i *= -1
3453             return i*m
3454 
3455         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3456         allow = digits_needed = digits_to_decimal + p
3457         precs = [f._prec for f in x.atoms(Float)]
3458         dps = prec_to_dps(max(precs)) if precs else None
3459         if dps is None:
3460             # assume everything is exact so use the Python
3461             # float default or whatever was requested
3462             dps = max(15, allow)
3463         else:
3464             allow = min(allow, dps)
3465         # this will shift all digits to right of decimal
3466         # and give us dps to work with as an int
3467         shift = -digits_to_decimal + dps
3468         extra = 1  # how far we look past known digits
3469         # NOTE
3470         # mpmath will calculate the binary representation to
3471         # an arbitrary number of digits but we must base our
3472         # answer on a finite number of those digits, e.g.
3473         # .575 2589569785738035/2**52 in binary.
3474         # mpmath shows us that the first 18 digits are
3475         #     >>> Float(.575).n(18)
3476         #     0.574999999999999956
3477         # The default precision is 15 digits and if we ask
3478         # for 15 we get
3479         #     >>> Float(.575).n(15)
3480         #     0.575000000000000
3481         # mpmath handles rounding at the 15th digit. But we
3482         # need to be careful since the user might be asking
3483         # for rounding at the last digit and our semantics
3484         # are to round toward the even final digit when there
3485         # is a tie. So the extra digit will be used to make
3486         # that decision. In this case, the value is the same
3487         # to 15 digits:
3488         #     >>> Float(.575).n(16)
3489         #     0.5750000000000000
3490         # Now converting this to the 15 known digits gives
3491         #     575000000000000.0
3492         # which rounds to integer
3493         #    5750000000000000
3494         # And now we can round to the desired digt, e.g. at
3495         # the second from the left and we get
3496         #    5800000000000000
3497         # and rescaling that gives
3498         #    0.58
3499         # as the final result.
3500         # If the value is made slightly less than 0.575 we might
3501         # still obtain the same value:
3502         #    >>> Float(.575-1e-16).n(16)*10**15
3503         #    574999999999999.8
3504         # What 15 digits best represents the known digits (which are
3505         # to the left of the decimal? 5750000000000000, the same as
3506         # before. The only way we will round down (in this case) is
3507         # if we declared that we had more than 15 digits of precision.
3508         # For example, if we use 16 digits of precision, the integer
3509         # we deal with is
3510         #    >>> Float(.575-1e-16).n(17)*10**16
3511         #    5749999999999998.4
3512         # and this now rounds to 5749999999999998 and (if we round to
3513         # the 2nd digit from the left) we get 5700000000000000.
3514         #
3515         xf = x.n(dps + extra)*Pow(10, shift)
3516         xi = Integer(xf)
3517         # use the last digit to select the value of xi
3518         # nearest to x before rounding at the desired digit
3519         sign = 1 if x > 0 else -1
3520         dif2 = sign*(xf - xi).n(extra)
3521         if dif2 < 0:
3522             raise NotImplementedError(
3523                 'not expecting int(x) to round away from 0')
3524         if dif2 > .5:
3525             xi += sign  # round away from 0
3526         elif dif2 == .5:
3527             xi += sign if xi%2 else -sign  # round toward even
3528         # shift p to the new position
3529         ip = p - shift
3530         # let Python handle the int rounding then rescale
3531         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3532         # restore scale
3533         rv = Rational(xr, Pow(10, shift))
3534         # return Float or Integer
3535         if rv.is_Integer:
3536             if n is None:  # the single-arg case
3537                 return rv
3538             # use str or else it won't be a float
3539             return Float(str(rv), dps)  # keep same precision
3540         else:
3541             if not allow and rv > self:
3542                 allow += 1
3543             return Float(rv, allow)
3544 
3545     __round__ = round
3546 
3547     def _eval_derivative_matrix_lines(self, x):
3548         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3549         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-16 02:55:40.511 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 02:55:40.512 | INFO     | Search-only: skipping patch selection
2025-10-16 02:55:40.609 | INFO     | Task sympy__sympy-16943 completed successfully.
2025-10-16 02:55:40.610 | INFO     | No patch generated. You can try running ACR again.
