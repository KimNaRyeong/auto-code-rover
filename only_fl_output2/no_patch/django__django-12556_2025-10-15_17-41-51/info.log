2025-10-15 17:41:51.498 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 17:41:56.831 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=133, output_tokens=12, cost=0.001690
2025-10-15 17:41:56.832 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 17:41:56.835 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:42:02.095 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=442, output_tokens=219, cost=0.010990
2025-10-15 17:42:02.098 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:42:06.134 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=573, output_tokens=52, cost=0.007290
2025-10-15 17:42:06.135 | DEBUG    | Extracted a valid json.
2025-10-15 17:42:06.136 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"get_random_string\")",
        "search_code(\"get_random_string(\")",
        "search_code(\"from django.utils.crypto import get_random_string\")"
    ],
    "bug_locations": []
}
2025-10-15 17:42:06.221 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 17:42:06.222 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 17:42:28.411 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1226, output_tokens=628, cost=0.031100
2025-10-15 17:42:28.424 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:42:43.094 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2070, output_tokens=544, cost=0.037020
2025-10-15 17:42:43.107 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:42:55.656 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=898, output_tokens=537, cost=0.025090
2025-10-15 17:42:55.657 | DEBUG    | Extracted a valid json.
2025-10-15 17:42:55.658 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/utils/crypto.py",
            "class": "",
            "method": "get_random_string",
            "intended_behavior": "Modify the signature of `get_random_string` to remove the default value for the `length` parameter, forcing callers of the function to specify the length explicitly. Ensure that the method's docstring is updated to reflect this change and highlight the necessity of specifying the length."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Determine an appropriate explicit `length` for the `get_random_string` call, considering CSRF tokens' security requirements."
        },
        {
            "file": "django/db/backends/oracle/creation.py",
            "class": "",
            "method": "",
            "intended_behavior": "Specify an explicit `length` where `get_random_string` is used, likely pertaining to object naming or temporary passwords during database creation."
        },
        {
            "file": "django/contrib/sessions/backends/base.py",
            "class": "",
            "method": "",
            "intended_behavior": "Adjust the usage of `get_random_string` by setting a suitable `length` for session identifiers to maintain security standards."
        },
        {
            "file": "django/contrib/auth/base_user.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update calls to `get_random_string` with an explicit `length`, ensuring user tokens or temporary passwords are securely generated."
        },
        {
            "file": "django/contrib/auth/hashers.py",
            "class": "",
            "method": "",
            "intended_behavior": "Revise all three matches in `hashers.py` to use `get_random_string` with an explicit length, which might vary based on the context of each use, such as salt generation for password hashing."
        },
        {
            "file": "django/core/files/storage.py",
            "class": "",
            "method": "",
            "intended_behavior": "Provide an explicit `length` for file storage-related uses of `get_random_string`, which could involve generating random filenames or paths."
        },
        {
            "file": "django/core/management/utils.py",
            "class": "",
            "method": "",
            "intended_behavior": "Specify an explicit length for any administrative or management tasks calling `get_random_string`, ensuring that any temporary files or identifiers are generated securely."
        }
    ]
}
2025-10-15 17:42:55.672 | DEBUG    | Bug location extracted successfully: [<file>django/utils/crypto.py</file>
<class>None</class>
<method>get_random_string</method>
<code>
47 def get_random_string(length=12,
48                       allowed_chars='abcdefghijklmnopqrstuvwxyz'
49                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):
50     """
51     Return a securely generated random string.
52 
53     The default length of 12 with the a-z, A-Z, 0-9 character set returns
54     a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
55     """
56     return ''.join(secrets.choice(allowed_chars) for i in range(length))

</code><intended_behavior>Modify the signature of `get_random_string` to remove the default value for the `length` parameter, forcing callers of the function to specify the length explicitly. Ensure that the method's docstring is updated to reflect this change and highlight the necessity of specifying the length.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _mask_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a mask and applying it to the secret.
49     """
50     mask = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return mask + cipher
55 
56 
57 def _unmask_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
61     the second half to produce the original secret.
62     """
63     mask = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
67     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68 
69 
70 def _get_new_csrf_token():
71     return _mask_cipher_secret(_get_new_csrf_string())
72 
73 
74 def get_token(request):
75     """
76     Return the CSRF token required for a POST form. The token is an
77     alphanumeric value. A new token is created if one is not already set.
78 
79     A side effect of calling this function is to make the csrf_protect
80     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
81     header to the outgoing response.  For this reason, you may need to use this
82     function lazily, as is done by the csrf context processor.
83     """
84     if "CSRF_COOKIE" not in request.META:
85         csrf_secret = _get_new_csrf_string()
86         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
87     else:
88         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
89     request.META["CSRF_COOKIE_USED"] = True
90     return _mask_cipher_secret(csrf_secret)
91 
92 
93 def rotate_token(request):
94     """
95     Change the CSRF token in use for a request - should be done on login
96     for security purposes.
97     """
98     request.META.update({
99         "CSRF_COOKIE_USED": True,
100         "CSRF_COOKIE": _get_new_csrf_token(),
101     })
102     request.csrf_cookie_needs_reset = True
103 
104 
105 def _sanitize_token(token):
106     # Allow only ASCII alphanumerics
107     if re.search('[^a-zA-Z0-9]', token):
108         return _get_new_csrf_token()
109     elif len(token) == CSRF_TOKEN_LENGTH:
110         return token
111     elif len(token) == CSRF_SECRET_LENGTH:
112         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
113         # alphanumeric characters. For backwards compatibility, accept
114         # such values as unmasked secrets.
115         # It's easier to mask here and be consistent later, rather than add
116         # different code paths in the checks, although that might be a tad more
117         # efficient.
118         return _mask_cipher_secret(token)
119     return _get_new_csrf_token()
120 
121 
122 def _compare_masked_tokens(request_csrf_token, csrf_token):
123     # Assume both arguments are sanitized -- that is, strings of
124     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
125     return constant_time_compare(
126         _unmask_cipher_token(request_csrf_token),
127         _unmask_cipher_token(csrf_token),
128     )
129 
130 
131 class CsrfViewMiddleware(MiddlewareMixin):
132     """
133     Require a present and correct csrfmiddlewaretoken for POST requests that
134     have a CSRF cookie, and set an outgoing CSRF cookie.
135 
136     This middleware should be used in conjunction with the {% csrf_token %}
137     template tag.
138     """
139     # The _accept and _reject methods currently only exist for the sake of the
140     # requires_csrf_token decorator.
141     def _accept(self, request):
142         # Avoid checking the request twice by adding a custom attribute to
143         # request.  This will be relevant when both decorator and middleware
144         # are used.
145         request.csrf_processing_done = True
146         return None
147 
148     def _reject(self, request, reason):
149         response = _get_failure_view()(request, reason=reason)
150         log_response(
151             'Forbidden (%s): %s', reason, request.path,
152             response=response,
153             request=request,
154             logger=logger,
155         )
156         return response
157 
158     def _get_token(self, request):
159         if settings.CSRF_USE_SESSIONS:
160             try:
161                 return request.session.get(CSRF_SESSION_KEY)
162             except AttributeError:
163                 raise ImproperlyConfigured(
164                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
165                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
166                     'in MIDDLEWARE.'
167                 )
168         else:
169             try:
170                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
171             except KeyError:
172                 return None
173 
174             csrf_token = _sanitize_token(cookie_token)
175             if csrf_token != cookie_token:
176                 # Cookie token needed to be replaced;
177                 # the cookie needs to be reset.
178                 request.csrf_cookie_needs_reset = True
179             return csrf_token
180 
181     def _set_token(self, request, response):
182         if settings.CSRF_USE_SESSIONS:
183             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
184                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
185         else:
186             response.set_cookie(
187                 settings.CSRF_COOKIE_NAME,
188                 request.META['CSRF_COOKIE'],
189                 max_age=settings.CSRF_COOKIE_AGE,
190                 domain=settings.CSRF_COOKIE_DOMAIN,
191                 path=settings.CSRF_COOKIE_PATH,
192                 secure=settings.CSRF_COOKIE_SECURE,
193                 httponly=settings.CSRF_COOKIE_HTTPONLY,
194                 samesite=settings.CSRF_COOKIE_SAMESITE,
195             )
196             # Set the Vary header since content varies with the CSRF cookie.
197             patch_vary_headers(response, ('Cookie',))
198 
199     def process_request(self, request):
200         csrf_token = self._get_token(request)
201         if csrf_token is not None:
202             # Use same token next time.
203             request.META['CSRF_COOKIE'] = csrf_token
204 
205     def process_view(self, request, callback, callback_args, callback_kwargs):
206         if getattr(request, 'csrf_processing_done', False):
207             return None
208 
209         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
210         # bailing out, so that get_token still works
211         if getattr(callback, 'csrf_exempt', False):
212             return None
213 
214         # Assume that anything not defined as 'safe' by RFC7231 needs protection
215         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
216             if getattr(request, '_dont_enforce_csrf_checks', False):
217                 # Mechanism to turn off CSRF checks for test suite.
218                 # It comes after the creation of CSRF cookies, so that
219                 # everything else continues to work exactly the same
220                 # (e.g. cookies are sent, etc.), but before any
221                 # branches that call reject().
222                 return self._accept(request)
223 
224             if request.is_secure():
225                 # Suppose user visits http://example.com/
226                 # An active network attacker (man-in-the-middle, MITM) sends a
227                 # POST form that targets https://example.com/detonate-bomb/ and
228                 # submits it via JavaScript.
229                 #
230                 # The attacker will need to provide a CSRF cookie and token, but
231                 # that's no problem for a MITM and the session-independent
232                 # secret we're using. So the MITM can circumvent the CSRF
233                 # protection. This is true for any HTTP connection, but anyone
234                 # using HTTPS expects better! For this reason, for
235                 # https://example.com/ we need additional protection that treats
236                 # http://example.com/ as completely untrusted. Under HTTPS,
237                 # Barth et al. found that the Referer header is missing for
238                 # same-domain requests in only about 0.2% of cases or less, so
239                 # we can use strict Referer checking.
240                 referer = request.META.get('HTTP_REFERER')
241                 if referer is None:
242                     return self._reject(request, REASON_NO_REFERER)
243 
244                 referer = urlparse(referer)
245 
246                 # Make sure we have a valid URL for Referer.
247                 if '' in (referer.scheme, referer.netloc):
248                     return self._reject(request, REASON_MALFORMED_REFERER)
249 
250                 # Ensure that our Referer is also secure.
251                 if referer.scheme != 'https':
252                     return self._reject(request, REASON_INSECURE_REFERER)
253 
254                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
255                 # match on host:port. If not, obey the cookie rules (or those
256                 # for the session cookie, if CSRF_USE_SESSIONS).
257                 good_referer = (
258                     settings.SESSION_COOKIE_DOMAIN
259                     if settings.CSRF_USE_SESSIONS
260                     else settings.CSRF_COOKIE_DOMAIN
261                 )
262                 if good_referer is not None:
263                     server_port = request.get_port()
264                     if server_port not in ('443', '80'):
265                         good_referer = '%s:%s' % (good_referer, server_port)
266                 else:
267                     try:
268                         # request.get_host() includes the port.
269                         good_referer = request.get_host()
270                     except DisallowedHost:
271                         pass
272 
273                 # Create a list of all acceptable HTTP referers, including the
274                 # current host if it's permitted by ALLOWED_HOSTS.
275                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
276                 if good_referer is not None:
277                     good_hosts.append(good_referer)
278 
279                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
280                     reason = REASON_BAD_REFERER % referer.geturl()
281                     return self._reject(request, reason)
282 
283             # Access csrf_token via self._get_token() as rotate_token() may
284             # have been called by an authentication middleware during the
285             # process_request() phase.
286             csrf_token = self._get_token(request)
287             if csrf_token is None:
288                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
289                 # and in this way we can avoid all CSRF attacks, including login
290                 # CSRF.
291                 return self._reject(request, REASON_NO_CSRF_COOKIE)
292 
293             # Check non-cookie token for match.
294             request_csrf_token = ""
295             if request.method == "POST":
296                 try:
297                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
298                 except OSError:
299                     # Handle a broken connection before we've completed reading
300                     # the POST data. process_view shouldn't raise any
301                     # exceptions, so we'll ignore and serve the user a 403
302                     # (assuming they're still listening, which they probably
303                     # aren't because of the error).
304                     pass
305 
306             if request_csrf_token == "":
307                 # Fall back to X-CSRFToken, to make things easier for AJAX,
308                 # and possible for PUT/DELETE.
309                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
310 
311             request_csrf_token = _sanitize_token(request_csrf_token)
312             if not _compare_masked_tokens(request_csrf_token, csrf_token):
313                 return self._reject(request, REASON_BAD_TOKEN)
314 
315         return self._accept(request)
316 
317     def process_response(self, request, response):
318         if not getattr(request, 'csrf_cookie_needs_reset', False):
319             if getattr(response, 'csrf_cookie_set', False):
320                 return response
321 
322         if not request.META.get("CSRF_COOKIE_USED", False):
323             return response
324 
325         # Set the CSRF cookie even if it's already set, so we renew
326         # the expiry timer.
327         self._set_token(request, response)
328         response.csrf_cookie_set = True
329         return response

</code><intended_behavior>Determine an appropriate explicit `length` for the `get_random_string` call, considering CSRF tokens' security requirements.</intended_behavior>, <file>django/db/backends/oracle/creation.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 
3 from django.conf import settings
4 from django.db import DatabaseError
5 from django.db.backends.base.creation import BaseDatabaseCreation
6 from django.utils.crypto import get_random_string
7 from django.utils.functional import cached_property
8 
9 TEST_DATABASE_PREFIX = 'test_'
10 
11 
12 class DatabaseCreation(BaseDatabaseCreation):
13 
14     @cached_property
15     def _maindb_connection(self):
16         """
17         This is analogous to other backends' `_nodb_connection` property,
18         which allows access to an "administrative" connection which can
19         be used to manage the test databases.
20         For Oracle, the only connection that can be used for that purpose
21         is the main (non-test) connection.
22         """
23         settings_dict = settings.DATABASES[self.connection.alias]
24         user = settings_dict.get('SAVED_USER') or settings_dict['USER']
25         password = settings_dict.get('SAVED_PASSWORD') or settings_dict['PASSWORD']
26         settings_dict = {**settings_dict, 'USER': user, 'PASSWORD': password}
27         DatabaseWrapper = type(self.connection)
28         return DatabaseWrapper(settings_dict, alias=self.connection.alias)
29 
30     def _create_test_db(self, verbosity=1, autoclobber=False, keepdb=False):
31         parameters = self._get_test_db_params()
32         with self._maindb_connection.cursor() as cursor:
33             if self._test_database_create():
34                 try:
35                     self._execute_test_db_creation(cursor, parameters, verbosity, keepdb)
36                 except Exception as e:
37                     if 'ORA-01543' not in str(e):
38                         # All errors except "tablespace already exists" cancel tests
39                         self.log('Got an error creating the test database: %s' % e)
40                         sys.exit(2)
41                     if not autoclobber:
42                         confirm = input(
43                             "It appears the test database, %s, already exists. "
44                             "Type 'yes' to delete it, or 'no' to cancel: " % parameters['user'])
45                     if autoclobber or confirm == 'yes':
46                         if verbosity >= 1:
47                             self.log("Destroying old test database for alias '%s'..." % self.connection.alias)
48                         try:
49                             self._execute_test_db_destruction(cursor, parameters, verbosity)
50                         except DatabaseError as e:
51                             if 'ORA-29857' in str(e):
52                                 self._handle_objects_preventing_db_destruction(cursor, parameters,
53                                                                                verbosity, autoclobber)
54                             else:
55                                 # Ran into a database error that isn't about leftover objects in the tablespace
56                                 self.log('Got an error destroying the old test database: %s' % e)
57                                 sys.exit(2)
58                         except Exception as e:
59                             self.log('Got an error destroying the old test database: %s' % e)
60                             sys.exit(2)
61                         try:
62                             self._execute_test_db_creation(cursor, parameters, verbosity, keepdb)
63                         except Exception as e:
64                             self.log('Got an error recreating the test database: %s' % e)
65                             sys.exit(2)
66                     else:
67                         self.log('Tests cancelled.')
68                         sys.exit(1)
69 
70             if self._test_user_create():
71                 if verbosity >= 1:
72                     self.log('Creating test user...')
73                 try:
74                     self._create_test_user(cursor, parameters, verbosity, keepdb)
75                 except Exception as e:
76                     if 'ORA-01920' not in str(e):
77                         # All errors except "user already exists" cancel tests
78                         self.log('Got an error creating the test user: %s' % e)
79                         sys.exit(2)
80                     if not autoclobber:
81                         confirm = input(
82                             "It appears the test user, %s, already exists. Type "
83                             "'yes' to delete it, or 'no' to cancel: " % parameters['user'])
84                     if autoclobber or confirm == 'yes':
85                         try:
86                             if verbosity >= 1:
87                                 self.log('Destroying old test user...')
88                             self._destroy_test_user(cursor, parameters, verbosity)
89                             if verbosity >= 1:
90                                 self.log('Creating test user...')
91                             self._create_test_user(cursor, parameters, verbosity, keepdb)
92                         except Exception as e:
93                             self.log('Got an error recreating the test user: %s' % e)
94                             sys.exit(2)
95                     else:
96                         self.log('Tests cancelled.')
97                         sys.exit(1)
98         self._maindb_connection.close()  # done with main user -- test user and tablespaces created
99         self._switch_to_test_user(parameters)
100         return self.connection.settings_dict['NAME']
101 
102     def _switch_to_test_user(self, parameters):
103         """
104         Switch to the user that's used for creating the test database.
105 
106         Oracle doesn't have the concept of separate databases under the same
107         user, so a separate user is used; see _create_test_db(). The main user
108         is also needed for cleanup when testing is completed, so save its
109         credentials in the SAVED_USER/SAVED_PASSWORD key in the settings dict.
110         """
111         real_settings = settings.DATABASES[self.connection.alias]
112         real_settings['SAVED_USER'] = self.connection.settings_dict['SAVED_USER'] = \
113             self.connection.settings_dict['USER']
114         real_settings['SAVED_PASSWORD'] = self.connection.settings_dict['SAVED_PASSWORD'] = \
115             self.connection.settings_dict['PASSWORD']
116         real_test_settings = real_settings['TEST']
117         test_settings = self.connection.settings_dict['TEST']
118         real_test_settings['USER'] = real_settings['USER'] = test_settings['USER'] = \
119             self.connection.settings_dict['USER'] = parameters['user']
120         real_settings['PASSWORD'] = self.connection.settings_dict['PASSWORD'] = parameters['password']
121 
122     def set_as_test_mirror(self, primary_settings_dict):
123         """
124         Set this database up to be used in testing as a mirror of a primary
125         database whose settings are given.
126         """
127         self.connection.settings_dict['USER'] = primary_settings_dict['USER']
128         self.connection.settings_dict['PASSWORD'] = primary_settings_dict['PASSWORD']
129 
130     def _handle_objects_preventing_db_destruction(self, cursor, parameters, verbosity, autoclobber):
131         # There are objects in the test tablespace which prevent dropping it
132         # The easy fix is to drop the test user -- but are we allowed to do so?
133         self.log(
134             'There are objects in the old test database which prevent its destruction.\n'
135             'If they belong to the test user, deleting the user will allow the test '
136             'database to be recreated.\n'
137             'Otherwise, you will need to find and remove each of these objects, '
138             'or use a different tablespace.\n'
139         )
140         if self._test_user_create():
141             if not autoclobber:
142                 confirm = input("Type 'yes' to delete user %s: " % parameters['user'])
143             if autoclobber or confirm == 'yes':
144                 try:
145                     if verbosity >= 1:
146                         self.log('Destroying old test user...')
147                     self._destroy_test_user(cursor, parameters, verbosity)
148                 except Exception as e:
149                     self.log('Got an error destroying the test user: %s' % e)
150                     sys.exit(2)
151                 try:
152                     if verbosity >= 1:
153                         self.log("Destroying old test database for alias '%s'..." % self.connection.alias)
154                     self._execute_test_db_destruction(cursor, parameters, verbosity)
155                 except Exception as e:
156                     self.log('Got an error destroying the test database: %s' % e)
157                     sys.exit(2)
158             else:
159                 self.log('Tests cancelled -- test database cannot be recreated.')
160                 sys.exit(1)
161         else:
162             self.log("Django is configured to use pre-existing test user '%s',"
163                      " and will not attempt to delete it." % parameters['user'])
164             self.log('Tests cancelled -- test database cannot be recreated.')
165             sys.exit(1)
166 
167     def _destroy_test_db(self, test_database_name, verbosity=1):
168         """
169         Destroy a test database, prompting the user for confirmation if the
170         database already exists. Return the name of the test database created.
171         """
172         self.connection.settings_dict['USER'] = self.connection.settings_dict['SAVED_USER']
173         self.connection.settings_dict['PASSWORD'] = self.connection.settings_dict['SAVED_PASSWORD']
174         self.connection.close()
175         parameters = self._get_test_db_params()
176         with self._maindb_connection.cursor() as cursor:
177             if self._test_user_create():
178                 if verbosity >= 1:
179                     self.log('Destroying test user...')
180                 self._destroy_test_user(cursor, parameters, verbosity)
181             if self._test_database_create():
182                 if verbosity >= 1:
183                     self.log('Destroying test database tables...')
184                 self._execute_test_db_destruction(cursor, parameters, verbosity)
185         self._maindb_connection.close()
186 
187     def _execute_test_db_creation(self, cursor, parameters, verbosity, keepdb=False):
188         if verbosity >= 2:
189             self.log('_create_test_db(): dbname = %s' % parameters['user'])
190         if self._test_database_oracle_managed_files():
191             statements = [
192                 """
193                 CREATE TABLESPACE %(tblspace)s
194                 DATAFILE SIZE %(size)s
195                 AUTOEXTEND ON NEXT %(extsize)s MAXSIZE %(maxsize)s
196                 """,
197                 """
198                 CREATE TEMPORARY TABLESPACE %(tblspace_temp)s
199                 TEMPFILE SIZE %(size_tmp)s
200                 AUTOEXTEND ON NEXT %(extsize_tmp)s MAXSIZE %(maxsize_tmp)s
201                 """,
202             ]
203         else:
204             statements = [
205                 """
206                 CREATE TABLESPACE %(tblspace)s
207                 DATAFILE '%(datafile)s' SIZE %(size)s REUSE
208                 AUTOEXTEND ON NEXT %(extsize)s MAXSIZE %(maxsize)s
209                 """,
210                 """
211                 CREATE TEMPORARY TABLESPACE %(tblspace_temp)s
212                 TEMPFILE '%(datafile_tmp)s' SIZE %(size_tmp)s REUSE
213                 AUTOEXTEND ON NEXT %(extsize_tmp)s MAXSIZE %(maxsize_tmp)s
214                 """,
215             ]
216         # Ignore "tablespace already exists" error when keepdb is on.
217         acceptable_ora_err = 'ORA-01543' if keepdb else None
218         self._execute_allow_fail_statements(cursor, statements, parameters, verbosity, acceptable_ora_err)
219 
220     def _create_test_user(self, cursor, parameters, verbosity, keepdb=False):
221         if verbosity >= 2:
222             self.log('_create_test_user(): username = %s' % parameters['user'])
223         statements = [
224             """CREATE USER %(user)s
225                IDENTIFIED BY "%(password)s"
226                DEFAULT TABLESPACE %(tblspace)s
227                TEMPORARY TABLESPACE %(tblspace_temp)s
228                QUOTA UNLIMITED ON %(tblspace)s
229             """,
230             """GRANT CREATE SESSION,
231                      CREATE TABLE,
232                      CREATE SEQUENCE,
233                      CREATE PROCEDURE,
234                      CREATE TRIGGER
235                TO %(user)s""",
236         ]
237         # Ignore "user already exists" error when keepdb is on
238         acceptable_ora_err = 'ORA-01920' if keepdb else None
239         success = self._execute_allow_fail_statements(cursor, statements, parameters, verbosity, acceptable_ora_err)
240         # If the password was randomly generated, change the user accordingly.
241         if not success and self._test_settings_get('PASSWORD') is None:
242             set_password = 'ALTER USER %(user)s IDENTIFIED BY "%(password)s"'
243             self._execute_statements(cursor, [set_password], parameters, verbosity)
244         # Most test suites can be run without "create view" and
245         # "create materialized view" privileges. But some need it.
246         for object_type in ('VIEW', 'MATERIALIZED VIEW'):
247             extra = 'GRANT CREATE %(object_type)s TO %(user)s'
248             parameters['object_type'] = object_type
249             success = self._execute_allow_fail_statements(cursor, [extra], parameters, verbosity, 'ORA-01031')
250             if not success and verbosity >= 2:
251                 self.log('Failed to grant CREATE %s permission to test user. This may be ok.' % object_type)
252 
253     def _execute_test_db_destruction(self, cursor, parameters, verbosity):
254         if verbosity >= 2:
255             self.log('_execute_test_db_destruction(): dbname=%s' % parameters['user'])
256         statements = [
257             'DROP TABLESPACE %(tblspace)s INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS',
258             'DROP TABLESPACE %(tblspace_temp)s INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS',
259         ]
260         self._execute_statements(cursor, statements, parameters, verbosity)
261 
262     def _destroy_test_user(self, cursor, parameters, verbosity):
263         if verbosity >= 2:
264             self.log('_destroy_test_user(): user=%s' % parameters['user'])
265             self.log('Be patient. This can take some time...')
266         statements = [
267             'DROP USER %(user)s CASCADE',
268         ]
269         self._execute_statements(cursor, statements, parameters, verbosity)
270 
271     def _execute_statements(self, cursor, statements, parameters, verbosity, allow_quiet_fail=False):
272         for template in statements:
273             stmt = template % parameters
274             if verbosity >= 2:
275                 print(stmt)
276             try:
277                 cursor.execute(stmt)
278             except Exception as err:
279                 if (not allow_quiet_fail) or verbosity >= 2:
280                     self.log('Failed (%s)' % (err))
281                 raise
282 
283     def _execute_allow_fail_statements(self, cursor, statements, parameters, verbosity, acceptable_ora_err):
284         """
285         Execute statements which are allowed to fail silently if the Oracle
286         error code given by `acceptable_ora_err` is raised. Return True if the
287         statements execute without an exception, or False otherwise.
288         """
289         try:
290             # Statement can fail when acceptable_ora_err is not None
291             allow_quiet_fail = acceptable_ora_err is not None and len(acceptable_ora_err) > 0
292             self._execute_statements(cursor, statements, parameters, verbosity, allow_quiet_fail=allow_quiet_fail)
293             return True
294         except DatabaseError as err:
295             description = str(err)
296             if acceptable_ora_err is None or acceptable_ora_err not in description:
297                 raise
298             return False
299 
300     def _get_test_db_params(self):
301         return {
302             'dbname': self._test_database_name(),
303             'user': self._test_database_user(),
304             'password': self._test_database_passwd(),
305             'tblspace': self._test_database_tblspace(),
306             'tblspace_temp': self._test_database_tblspace_tmp(),
307             'datafile': self._test_database_tblspace_datafile(),
308             'datafile_tmp': self._test_database_tblspace_tmp_datafile(),
309             'maxsize': self._test_database_tblspace_maxsize(),
310             'maxsize_tmp': self._test_database_tblspace_tmp_maxsize(),
311             'size': self._test_database_tblspace_size(),
312             'size_tmp': self._test_database_tblspace_tmp_size(),
313             'extsize': self._test_database_tblspace_extsize(),
314             'extsize_tmp': self._test_database_tblspace_tmp_extsize(),
315         }
316 
317     def _test_settings_get(self, key, default=None, prefixed=None):
318         """
319         Return a value from the test settings dict, or a given default, or a
320         prefixed entry from the main settings dict.
321         """
322         settings_dict = self.connection.settings_dict
323         val = settings_dict['TEST'].get(key, default)
324         if val is None and prefixed:
325             val = TEST_DATABASE_PREFIX + settings_dict[prefixed]
326         return val
327 
328     def _test_database_name(self):
329         return self._test_settings_get('NAME', prefixed='NAME')
330 
331     def _test_database_create(self):
332         return self._test_settings_get('CREATE_DB', default=True)
333 
334     def _test_user_create(self):
335         return self._test_settings_get('CREATE_USER', default=True)
336 
337     def _test_database_user(self):
338         return self._test_settings_get('USER', prefixed='USER')
339 
340     def _test_database_passwd(self):
341         password = self._test_settings_get('PASSWORD')
342         if password is None and self._test_user_create():
343             # Oracle passwords are limited to 30 chars and can't contain symbols.
344             password = get_random_string(length=30)
345         return password
346 
347     def _test_database_tblspace(self):
348         return self._test_settings_get('TBLSPACE', prefixed='USER')
349 
350     def _test_database_tblspace_tmp(self):
351         settings_dict = self.connection.settings_dict
352         return settings_dict['TEST'].get('TBLSPACE_TMP',
353                                          TEST_DATABASE_PREFIX + settings_dict['USER'] + '_temp')
354 
355     def _test_database_tblspace_datafile(self):
356         tblspace = '%s.dbf' % self._test_database_tblspace()
357         return self._test_settings_get('DATAFILE', default=tblspace)
358 
359     def _test_database_tblspace_tmp_datafile(self):
360         tblspace = '%s.dbf' % self._test_database_tblspace_tmp()
361         return self._test_settings_get('DATAFILE_TMP', default=tblspace)
362 
363     def _test_database_tblspace_maxsize(self):
364         return self._test_settings_get('DATAFILE_MAXSIZE', default='500M')
365 
366     def _test_database_tblspace_tmp_maxsize(self):
367         return self._test_settings_get('DATAFILE_TMP_MAXSIZE', default='500M')
368 
369     def _test_database_tblspace_size(self):
370         return self._test_settings_get('DATAFILE_SIZE', default='50M')
371 
372     def _test_database_tblspace_tmp_size(self):
373         return self._test_settings_get('DATAFILE_TMP_SIZE', default='50M')
374 
375     def _test_database_tblspace_extsize(self):
376         return self._test_settings_get('DATAFILE_EXTSIZE', default='25M')
377 
378     def _test_database_tblspace_tmp_extsize(self):
379         return self._test_settings_get('DATAFILE_TMP_EXTSIZE', default='25M')
380 
381     def _test_database_oracle_managed_files(self):
382         return self._test_settings_get('ORACLE_MANAGED_FILES', default=False)
383 
384     def _get_test_db_name(self):
385         """
386         Return the 'production' DB name to get the test DB creation machinery
387         to work. This isn't a great deal in this case because DB names as
388         handled by Django don't have real counterparts in Oracle.
389         """
390         return self.connection.settings_dict['NAME']
391 
392     def test_db_signature(self):
393         settings_dict = self.connection.settings_dict
394         return (
395             settings_dict['HOST'],
396             settings_dict['PORT'],
397             settings_dict['ENGINE'],
398             settings_dict['NAME'],
399             self._test_database_user(),
400         )

</code><intended_behavior>Specify an explicit `length` where `get_random_string` is used, likely pertaining to object naming or temporary passwords during database creation.</intended_behavior>, <file>django/contrib/sessions/backends/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 import base64
2 import logging
3 import string
4 import warnings
5 from datetime import datetime, timedelta
6 
7 from django.conf import settings
8 from django.contrib.sessions.exceptions import SuspiciousSession
9 from django.core import signing
10 from django.core.exceptions import SuspiciousOperation
11 from django.utils import timezone
12 from django.utils.crypto import (
13     constant_time_compare, get_random_string, salted_hmac,
14 )
15 from django.utils.deprecation import RemovedInDjango40Warning
16 from django.utils.module_loading import import_string
17 from django.utils.translation import LANGUAGE_SESSION_KEY
18 
19 # session_key should not be case sensitive because some backends can store it
20 # on case insensitive file systems.
21 VALID_KEY_CHARS = string.ascii_lowercase + string.digits
22 
23 
24 class CreateError(Exception):
25     """
26     Used internally as a consistent exception type to catch from save (see the
27     docstring for SessionBase.save() for details).
28     """
29     pass
30 
31 
32 class UpdateError(Exception):
33     """
34     Occurs if Django tries to update a session that was deleted.
35     """
36     pass
37 
38 
39 class SessionBase:
40     """
41     Base class for all Session classes.
42     """
43     TEST_COOKIE_NAME = 'testcookie'
44     TEST_COOKIE_VALUE = 'worked'
45 
46     __not_given = object()
47 
48     def __init__(self, session_key=None):
49         self._session_key = session_key
50         self.accessed = False
51         self.modified = False
52         self.serializer = import_string(settings.SESSION_SERIALIZER)
53 
54     def __contains__(self, key):
55         return key in self._session
56 
57     def __getitem__(self, key):
58         if key == LANGUAGE_SESSION_KEY:
59             warnings.warn(
60                 'The user language will no longer be stored in '
61                 'request.session in Django 4.0. Read it from '
62                 'request.COOKIES[settings.LANGUAGE_COOKIE_NAME] instead.',
63                 RemovedInDjango40Warning, stacklevel=2,
64             )
65         return self._session[key]
66 
67     def __setitem__(self, key, value):
68         self._session[key] = value
69         self.modified = True
70 
71     def __delitem__(self, key):
72         del self._session[key]
73         self.modified = True
74 
75     @property
76     def key_salt(self):
77         return 'django.contrib.sessions.' + self.__class__.__qualname__
78 
79     def get(self, key, default=None):
80         return self._session.get(key, default)
81 
82     def pop(self, key, default=__not_given):
83         self.modified = self.modified or key in self._session
84         args = () if default is self.__not_given else (default,)
85         return self._session.pop(key, *args)
86 
87     def setdefault(self, key, value):
88         if key in self._session:
89             return self._session[key]
90         else:
91             self.modified = True
92             self._session[key] = value
93             return value
94 
95     def set_test_cookie(self):
96         self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE
97 
98     def test_cookie_worked(self):
99         return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE
100 
101     def delete_test_cookie(self):
102         del self[self.TEST_COOKIE_NAME]
103 
104     def _hash(self, value):
105         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.
106         key_salt = "django.contrib.sessions" + self.__class__.__name__
107         return salted_hmac(key_salt, value).hexdigest()
108 
109     def encode(self, session_dict):
110         "Return the given session dictionary serialized and encoded as a string."
111         return signing.dumps(
112             session_dict, salt=self.key_salt, serializer=self.serializer,
113             compress=True,
114         )
115 
116     def decode(self, session_data):
117         try:
118             return signing.loads(session_data, salt=self.key_salt, serializer=self.serializer)
119         # RemovedInDjango40Warning: when the deprecation ends, handle here
120         # exceptions similar to what _legacy_decode() does now.
121         except Exception:
122             return self._legacy_decode(session_data)
123 
124     def _legacy_decode(self, session_data):
125         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.
126         encoded_data = base64.b64decode(session_data.encode('ascii'))
127         try:
128             # could produce ValueError if there is no ':'
129             hash, serialized = encoded_data.split(b':', 1)
130             expected_hash = self._hash(serialized)
131             if not constant_time_compare(hash.decode(), expected_hash):
132                 raise SuspiciousSession("Session data corrupted")
133             else:
134                 return self.serializer().loads(serialized)
135         except Exception as e:
136             # ValueError, SuspiciousOperation, unpickling exceptions. If any of
137             # these happen, just return an empty dictionary (an empty session).
138             if isinstance(e, SuspiciousOperation):
139                 logger = logging.getLogger('django.security.%s' % e.__class__.__name__)
140                 logger.warning(str(e))
141             return {}
142 
143     def update(self, dict_):
144         self._session.update(dict_)
145         self.modified = True
146 
147     def has_key(self, key):
148         return key in self._session
149 
150     def keys(self):
151         return self._session.keys()
152 
153     def values(self):
154         return self._session.values()
155 
156     def items(self):
157         return self._session.items()
158 
159     def clear(self):
160         # To avoid unnecessary persistent storage accesses, we set up the
161         # internals directly (loading data wastes time, since we are going to
162         # set it to an empty dict anyway).
163         self._session_cache = {}
164         self.accessed = True
165         self.modified = True
166 
167     def is_empty(self):
168         "Return True when there is no session_key and the session is empty."
169         try:
170             return not self._session_key and not self._session_cache
171         except AttributeError:
172             return True
173 
174     def _get_new_session_key(self):
175         "Return session key that isn't being used."
176         while True:
177             session_key = get_random_string(32, VALID_KEY_CHARS)
178             if not self.exists(session_key):
179                 return session_key
180 
181     def _get_or_create_session_key(self):
182         if self._session_key is None:
183             self._session_key = self._get_new_session_key()
184         return self._session_key
185 
186     def _validate_session_key(self, key):
187         """
188         Key must be truthy and at least 8 characters long. 8 characters is an
189         arbitrary lower bound for some minimal key security.
190         """
191         return key and len(key) >= 8
192 
193     def _get_session_key(self):
194         return self.__session_key
195 
196     def _set_session_key(self, value):
197         """
198         Validate session key on assignment. Invalid values will set to None.
199         """
200         if self._validate_session_key(value):
201             self.__session_key = value
202         else:
203             self.__session_key = None
204 
205     session_key = property(_get_session_key)
206     _session_key = property(_get_session_key, _set_session_key)
207 
208     def _get_session(self, no_load=False):
209         """
210         Lazily load session from storage (unless "no_load" is True, when only
211         an empty dict is stored) and store it in the current instance.
212         """
213         self.accessed = True
214         try:
215             return self._session_cache
216         except AttributeError:
217             if self.session_key is None or no_load:
218                 self._session_cache = {}
219             else:
220                 self._session_cache = self.load()
221         return self._session_cache
222 
223     _session = property(_get_session)
224 
225     def get_session_cookie_age(self):
226         return settings.SESSION_COOKIE_AGE
227 
228     def get_expiry_age(self, **kwargs):
229         """Get the number of seconds until the session expires.
230 
231         Optionally, this function accepts `modification` and `expiry` keyword
232         arguments specifying the modification and expiry of the session.
233         """
234         try:
235             modification = kwargs['modification']
236         except KeyError:
237             modification = timezone.now()
238         # Make the difference between "expiry=None passed in kwargs" and
239         # "expiry not passed in kwargs", in order to guarantee not to trigger
240         # self.load() when expiry is provided.
241         try:
242             expiry = kwargs['expiry']
243         except KeyError:
244             expiry = self.get('_session_expiry')
245 
246         if not expiry:   # Checks both None and 0 cases
247             return self.get_session_cookie_age()
248         if not isinstance(expiry, datetime):
249             return expiry
250         delta = expiry - modification
251         return delta.days * 86400 + delta.seconds
252 
253     def get_expiry_date(self, **kwargs):
254         """Get session the expiry date (as a datetime object).
255 
256         Optionally, this function accepts `modification` and `expiry` keyword
257         arguments specifying the modification and expiry of the session.
258         """
259         try:
260             modification = kwargs['modification']
261         except KeyError:
262             modification = timezone.now()
263         # Same comment as in get_expiry_age
264         try:
265             expiry = kwargs['expiry']
266         except KeyError:
267             expiry = self.get('_session_expiry')
268 
269         if isinstance(expiry, datetime):
270             return expiry
271         expiry = expiry or self.get_session_cookie_age()
272         return modification + timedelta(seconds=expiry)
273 
274     def set_expiry(self, value):
275         """
276         Set a custom expiration for the session. ``value`` can be an integer,
277         a Python ``datetime`` or ``timedelta`` object or ``None``.
278 
279         If ``value`` is an integer, the session will expire after that many
280         seconds of inactivity. If set to ``0`` then the session will expire on
281         browser close.
282 
283         If ``value`` is a ``datetime`` or ``timedelta`` object, the session
284         will expire at that specific future time.
285 
286         If ``value`` is ``None``, the session uses the global session expiry
287         policy.
288         """
289         if value is None:
290             # Remove any custom expiration for this session.
291             try:
292                 del self['_session_expiry']
293             except KeyError:
294                 pass
295             return
296         if isinstance(value, timedelta):
297             value = timezone.now() + value
298         self['_session_expiry'] = value
299 
300     def get_expire_at_browser_close(self):
301         """
302         Return ``True`` if the session is set to expire when the browser
303         closes, and ``False`` if there's an expiry date. Use
304         ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry
305         date/age, if there is one.
306         """
307         if self.get('_session_expiry') is None:
308             return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE
309         return self.get('_session_expiry') == 0
310 
311     def flush(self):
312         """
313         Remove the current session data from the database and regenerate the
314         key.
315         """
316         self.clear()
317         self.delete()
318         self._session_key = None
319 
320     def cycle_key(self):
321         """
322         Create a new session key, while retaining the current session data.
323         """
324         data = self._session
325         key = self.session_key
326         self.create()
327         self._session_cache = data
328         if key:
329             self.delete(key)
330 
331     # Methods that child classes must implement.
332 
333     def exists(self, session_key):
334         """
335         Return True if the given session_key already exists.
336         """
337         raise NotImplementedError('subclasses of SessionBase must provide an exists() method')
338 
339     def create(self):
340         """
341         Create a new session instance. Guaranteed to create a new object with
342         a unique key and will have saved the result once (with empty data)
343         before the method returns.
344         """
345         raise NotImplementedError('subclasses of SessionBase must provide a create() method')
346 
347     def save(self, must_create=False):
348         """
349         Save the session data. If 'must_create' is True, create a new session
350         object (or raise CreateError). Otherwise, only update an existing
351         object and don't create one (raise UpdateError if needed).
352         """
353         raise NotImplementedError('subclasses of SessionBase must provide a save() method')
354 
355     def delete(self, session_key=None):
356         """
357         Delete the session data under this key. If the key is None, use the
358         current session key value.
359         """
360         raise NotImplementedError('subclasses of SessionBase must provide a delete() method')
361 
362     def load(self):
363         """
364         Load the session data and return a dictionary.
365         """
366         raise NotImplementedError('subclasses of SessionBase must provide a load() method')
367 
368     @classmethod
369     def clear_expired(cls):
370         """
371         Remove expired sessions from the session store.
372 
373         If this operation isn't possible on a given backend, it should raise
374         NotImplementedError. If it isn't necessary, because the backend has
375         a built-in expiration mechanism, it should be a no-op.
376         """
377         raise NotImplementedError('This backend does not support clear_expired().')

</code><intended_behavior>Adjust the usage of `get_random_string` by setting a suitable `length` for session identifiers to maintain security standards.</intended_behavior>, <file>django/contrib/auth/base_user.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module allows importing AbstractBaseUser even when django.contrib.auth is
3 not in INSTALLED_APPS.
4 """
5 import unicodedata
6 
7 from django.contrib.auth import password_validation
8 from django.contrib.auth.hashers import (
9     check_password, is_password_usable, make_password,
10 )
11 from django.db import models
12 from django.utils.crypto import get_random_string, salted_hmac
13 from django.utils.translation import gettext_lazy as _
14 
15 
16 class BaseUserManager(models.Manager):
17 
18     @classmethod
19     def normalize_email(cls, email):
20         """
21         Normalize the email address by lowercasing the domain part of it.
22         """
23         email = email or ''
24         try:
25             email_name, domain_part = email.strip().rsplit('@', 1)
26         except ValueError:
27             pass
28         else:
29             email = email_name + '@' + domain_part.lower()
30         return email
31 
32     def make_random_password(self, length=10,
33                              allowed_chars='abcdefghjkmnpqrstuvwxyz'
34                                            'ABCDEFGHJKLMNPQRSTUVWXYZ'
35                                            '23456789'):
36         """
37         Generate a random password with the given length and given
38         allowed_chars. The default value of allowed_chars does not have "I" or
39         "O" or letters and digits that look similar -- just to avoid confusion.
40         """
41         return get_random_string(length, allowed_chars)
42 
43     def get_by_natural_key(self, username):
44         return self.get(**{self.model.USERNAME_FIELD: username})
45 
46 
47 class AbstractBaseUser(models.Model):
48     password = models.CharField(_('password'), max_length=128)
49     last_login = models.DateTimeField(_('last login'), blank=True, null=True)
50 
51     is_active = True
52 
53     REQUIRED_FIELDS = []
54 
55     # Stores the raw password if set_password() is called so that it can
56     # be passed to password_changed() after the model is saved.
57     _password = None
58 
59     class Meta:
60         abstract = True
61 
62     def __str__(self):
63         return self.get_username()
64 
65     def save(self, *args, **kwargs):
66         super().save(*args, **kwargs)
67         if self._password is not None:
68             password_validation.password_changed(self._password, self)
69             self._password = None
70 
71     def get_username(self):
72         """Return the username for this User."""
73         return getattr(self, self.USERNAME_FIELD)
74 
75     def clean(self):
76         setattr(self, self.USERNAME_FIELD, self.normalize_username(self.get_username()))
77 
78     def natural_key(self):
79         return (self.get_username(),)
80 
81     @property
82     def is_anonymous(self):
83         """
84         Always return False. This is a way of comparing User objects to
85         anonymous users.
86         """
87         return False
88 
89     @property
90     def is_authenticated(self):
91         """
92         Always return True. This is a way to tell if the user has been
93         authenticated in templates.
94         """
95         return True
96 
97     def set_password(self, raw_password):
98         self.password = make_password(raw_password)
99         self._password = raw_password
100 
101     def check_password(self, raw_password):
102         """
103         Return a boolean of whether the raw_password was correct. Handles
104         hashing formats behind the scenes.
105         """
106         def setter(raw_password):
107             self.set_password(raw_password)
108             # Password hash upgrades shouldn't be considered password changes.
109             self._password = None
110             self.save(update_fields=["password"])
111         return check_password(raw_password, self.password, setter)
112 
113     def set_unusable_password(self):
114         # Set a value that will never be a valid hash
115         self.password = make_password(None)
116 
117     def has_usable_password(self):
118         """
119         Return False if set_unusable_password() has been called for this user.
120         """
121         return is_password_usable(self.password)
122 
123     def get_session_auth_hash(self):
124         """
125         Return an HMAC of the password field.
126         """
127         key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
128         return salted_hmac(key_salt, self.password).hexdigest()
129 
130     @classmethod
131     def get_email_field_name(cls):
132         try:
133             return cls.EMAIL_FIELD
134         except AttributeError:
135             return 'email'
136 
137     @classmethod
138     def normalize_username(cls, username):
139         return unicodedata.normalize('NFKC', username) if isinstance(username, str) else username

</code><intended_behavior>Update calls to `get_random_string` with an explicit `length`, ensuring user tokens or temporary passwords are securely generated.</intended_behavior>, <file>django/contrib/auth/hashers.py</file>
<class>None</class>
<method>None</method>
<code>
1 import base64
2 import binascii
3 import functools
4 import hashlib
5 import importlib
6 import warnings
7 
8 from django.conf import settings
9 from django.core.exceptions import ImproperlyConfigured
10 from django.core.signals import setting_changed
11 from django.dispatch import receiver
12 from django.utils.crypto import (
13     constant_time_compare, get_random_string, pbkdf2,
14 )
15 from django.utils.module_loading import import_string
16 from django.utils.translation import gettext_noop as _
17 
18 UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash
19 UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
20 
21 
22 def is_password_usable(encoded):
23     """
24     Return True if this password wasn't generated by
25     User.set_unusable_password(), i.e. make_password(None).
26     """
27     return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)
28 
29 
30 def check_password(password, encoded, setter=None, preferred='default'):
31     """
32     Return a boolean of whether the raw password matches the three
33     part encoded digest.
34 
35     If setter is specified, it'll be called when you need to
36     regenerate the password.
37     """
38     if password is None or not is_password_usable(encoded):
39         return False
40 
41     preferred = get_hasher(preferred)
42     try:
43         hasher = identify_hasher(encoded)
44     except ValueError:
45         # encoded is gibberish or uses a hasher that's no longer installed.
46         return False
47 
48     hasher_changed = hasher.algorithm != preferred.algorithm
49     must_update = hasher_changed or preferred.must_update(encoded)
50     is_correct = hasher.verify(password, encoded)
51 
52     # If the hasher didn't change (we don't protect against enumeration if it
53     # does) and the password should get updated, try to close the timing gap
54     # between the work factor of the current encoded password and the default
55     # work factor.
56     if not is_correct and not hasher_changed and must_update:
57         hasher.harden_runtime(password, encoded)
58 
59     if setter and is_correct and must_update:
60         setter(password)
61     return is_correct
62 
63 
64 def make_password(password, salt=None, hasher='default'):
65     """
66     Turn a plain-text password into a hash for database storage
67 
68     Same as encode() but generate a new random salt. If password is None then
69     return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
70     which disallows logins. Additional random string reduces chances of gaining
71     access to staff or superuser accounts. See ticket #20079 for more info.
72     """
73     if password is None:
74         return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)
75     hasher = get_hasher(hasher)
76     salt = salt or hasher.salt()
77     return hasher.encode(password, salt)
78 
79 
80 @functools.lru_cache()
81 def get_hashers():
82     hashers = []
83     for hasher_path in settings.PASSWORD_HASHERS:
84         hasher_cls = import_string(hasher_path)
85         hasher = hasher_cls()
86         if not getattr(hasher, 'algorithm'):
87             raise ImproperlyConfigured("hasher doesn't specify an "
88                                        "algorithm name: %s" % hasher_path)
89         hashers.append(hasher)
90     return hashers
91 
92 
93 @functools.lru_cache()
94 def get_hashers_by_algorithm():
95     return {hasher.algorithm: hasher for hasher in get_hashers()}
96 
97 
98 @receiver(setting_changed)
99 def reset_hashers(**kwargs):
100     if kwargs['setting'] == 'PASSWORD_HASHERS':
101         get_hashers.cache_clear()
102         get_hashers_by_algorithm.cache_clear()
103 
104 
105 def get_hasher(algorithm='default'):
106     """
107     Return an instance of a loaded password hasher.
108 
109     If algorithm is 'default', return the default hasher. Lazily import hashers
110     specified in the project's settings file if needed.
111     """
112     if hasattr(algorithm, 'algorithm'):
113         return algorithm
114 
115     elif algorithm == 'default':
116         return get_hashers()[0]
117 
118     else:
119         hashers = get_hashers_by_algorithm()
120         try:
121             return hashers[algorithm]
122         except KeyError:
123             raise ValueError("Unknown password hashing algorithm '%s'. "
124                              "Did you specify it in the PASSWORD_HASHERS "
125                              "setting?" % algorithm)
126 
127 
128 def identify_hasher(encoded):
129     """
130     Return an instance of a loaded password hasher.
131 
132     Identify hasher algorithm by examining encoded hash, and call
133     get_hasher() to return hasher. Raise ValueError if
134     algorithm cannot be identified, or if hasher is not loaded.
135     """
136     # Ancient versions of Django created plain MD5 passwords and accepted
137     # MD5 passwords with an empty salt.
138     if ((len(encoded) == 32 and '$' not in encoded) or
139             (len(encoded) == 37 and encoded.startswith('md5$$'))):
140         algorithm = 'unsalted_md5'
141     # Ancient versions of Django accepted SHA1 passwords with an empty salt.
142     elif len(encoded) == 46 and encoded.startswith('sha1$$'):
143         algorithm = 'unsalted_sha1'
144     else:
145         algorithm = encoded.split('$', 1)[0]
146     return get_hasher(algorithm)
147 
148 
149 def mask_hash(hash, show=6, char="*"):
150     """
151     Return the given hash, with only the first ``show`` number shown. The
152     rest are masked with ``char`` for security reasons.
153     """
154     masked = hash[:show]
155     masked += char * len(hash[show:])
156     return masked
157 
158 
159 class BasePasswordHasher:
160     """
161     Abstract base class for password hashers
162 
163     When creating your own hasher, you need to override algorithm,
164     verify(), encode() and safe_summary().
165 
166     PasswordHasher objects are immutable.
167     """
168     algorithm = None
169     library = None
170 
171     def _load_library(self):
172         if self.library is not None:
173             if isinstance(self.library, (tuple, list)):
174                 name, mod_path = self.library
175             else:
176                 mod_path = self.library
177             try:
178                 module = importlib.import_module(mod_path)
179             except ImportError as e:
180                 raise ValueError("Couldn't load %r algorithm library: %s" %
181                                  (self.__class__.__name__, e))
182             return module
183         raise ValueError("Hasher %r doesn't specify a library attribute" %
184                          self.__class__.__name__)
185 
186     def salt(self):
187         """Generate a cryptographically secure nonce salt in ASCII."""
188         return get_random_string()
189 
190     def verify(self, password, encoded):
191         """Check if the given password is correct."""
192         raise NotImplementedError('subclasses of BasePasswordHasher must provide a verify() method')
193 
194     def encode(self, password, salt):
195         """
196         Create an encoded database value.
197 
198         The result is normally formatted as "algorithm$salt$hash" and
199         must be fewer than 128 characters.
200         """
201         raise NotImplementedError('subclasses of BasePasswordHasher must provide an encode() method')
202 
203     def safe_summary(self, encoded):
204         """
205         Return a summary of safe values.
206 
207         The result is a dictionary and will be used where the password field
208         must be displayed to construct a safe representation of the password.
209         """
210         raise NotImplementedError('subclasses of BasePasswordHasher must provide a safe_summary() method')
211 
212     def must_update(self, encoded):
213         return False
214 
215     def harden_runtime(self, password, encoded):
216         """
217         Bridge the runtime gap between the work factor supplied in `encoded`
218         and the work factor suggested by this hasher.
219 
220         Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
221         `self.iterations` is 30000, this method should run password through
222         another 10000 iterations of PBKDF2. Similar approaches should exist
223         for any hasher that has a work factor. If not, this method should be
224         defined as a no-op to silence the warning.
225         """
226         warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')
227 
228 
229 class PBKDF2PasswordHasher(BasePasswordHasher):
230     """
231     Secure password hashing using the PBKDF2 algorithm (recommended)
232 
233     Configured to use PBKDF2 + HMAC + SHA256.
234     The result is a 64 byte binary string.  Iterations may be changed
235     safely but you must rename the algorithm if you change SHA256.
236     """
237     algorithm = "pbkdf2_sha256"
238     iterations = 216000
239     digest = hashlib.sha256
240 
241     def encode(self, password, salt, iterations=None):
242         assert password is not None
243         assert salt and '$' not in salt
244         iterations = iterations or self.iterations
245         hash = pbkdf2(password, salt, iterations, digest=self.digest)
246         hash = base64.b64encode(hash).decode('ascii').strip()
247         return "%s$%d$%s$%s" % (self.algorithm, iterations, salt, hash)
248 
249     def verify(self, password, encoded):
250         algorithm, iterations, salt, hash = encoded.split('$', 3)
251         assert algorithm == self.algorithm
252         encoded_2 = self.encode(password, salt, int(iterations))
253         return constant_time_compare(encoded, encoded_2)
254 
255     def safe_summary(self, encoded):
256         algorithm, iterations, salt, hash = encoded.split('$', 3)
257         assert algorithm == self.algorithm
258         return {
259             _('algorithm'): algorithm,
260             _('iterations'): iterations,
261             _('salt'): mask_hash(salt),
262             _('hash'): mask_hash(hash),
263         }
264 
265     def must_update(self, encoded):
266         algorithm, iterations, salt, hash = encoded.split('$', 3)
267         return int(iterations) != self.iterations
268 
269     def harden_runtime(self, password, encoded):
270         algorithm, iterations, salt, hash = encoded.split('$', 3)
271         extra_iterations = self.iterations - int(iterations)
272         if extra_iterations > 0:
273             self.encode(password, salt, extra_iterations)
274 
275 
276 class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
277     """
278     Alternate PBKDF2 hasher which uses SHA1, the default PRF
279     recommended by PKCS #5. This is compatible with other
280     implementations of PBKDF2, such as openssl's
281     PKCS5_PBKDF2_HMAC_SHA1().
282     """
283     algorithm = "pbkdf2_sha1"
284     digest = hashlib.sha1
285 
286 
287 class Argon2PasswordHasher(BasePasswordHasher):
288     """
289     Secure password hashing using the argon2 algorithm.
290 
291     This is the winner of the Password Hashing Competition 2013-2015
292     (https://password-hashing.net). It requires the argon2-cffi library which
293     depends on native C code and might cause portability issues.
294     """
295     algorithm = 'argon2'
296     library = 'argon2'
297 
298     time_cost = 2
299     memory_cost = 512
300     parallelism = 2
301 
302     def encode(self, password, salt):
303         argon2 = self._load_library()
304         data = argon2.low_level.hash_secret(
305             password.encode(),
306             salt.encode(),
307             time_cost=self.time_cost,
308             memory_cost=self.memory_cost,
309             parallelism=self.parallelism,
310             hash_len=argon2.DEFAULT_HASH_LENGTH,
311             type=argon2.low_level.Type.I,
312         )
313         return self.algorithm + data.decode('ascii')
314 
315     def verify(self, password, encoded):
316         argon2 = self._load_library()
317         algorithm, rest = encoded.split('$', 1)
318         assert algorithm == self.algorithm
319         try:
320             return argon2.low_level.verify_secret(
321                 ('$' + rest).encode('ascii'),
322                 password.encode(),
323                 type=argon2.low_level.Type.I,
324             )
325         except argon2.exceptions.VerificationError:
326             return False
327 
328     def safe_summary(self, encoded):
329         (algorithm, variety, version, time_cost, memory_cost, parallelism,
330             salt, data) = self._decode(encoded)
331         assert algorithm == self.algorithm
332         return {
333             _('algorithm'): algorithm,
334             _('variety'): variety,
335             _('version'): version,
336             _('memory cost'): memory_cost,
337             _('time cost'): time_cost,
338             _('parallelism'): parallelism,
339             _('salt'): mask_hash(salt),
340             _('hash'): mask_hash(data),
341         }
342 
343     def must_update(self, encoded):
344         (algorithm, variety, version, time_cost, memory_cost, parallelism,
345             salt, data) = self._decode(encoded)
346         assert algorithm == self.algorithm
347         argon2 = self._load_library()
348         return (
349             argon2.low_level.ARGON2_VERSION != version or
350             self.time_cost != time_cost or
351             self.memory_cost != memory_cost or
352             self.parallelism != parallelism
353         )
354 
355     def harden_runtime(self, password, encoded):
356         # The runtime for Argon2 is too complicated to implement a sensible
357         # hardening algorithm.
358         pass
359 
360     def _decode(self, encoded):
361         """
362         Split an encoded hash and return: (
363             algorithm, variety, version, time_cost, memory_cost,
364             parallelism, salt, data,
365         ).
366         """
367         bits = encoded.split('$')
368         if len(bits) == 5:
369             # Argon2 < 1.3
370             algorithm, variety, raw_params, salt, data = bits
371             version = 0x10
372         else:
373             assert len(bits) == 6
374             algorithm, variety, raw_version, raw_params, salt, data = bits
375             assert raw_version.startswith('v=')
376             version = int(raw_version[len('v='):])
377         params = dict(bit.split('=', 1) for bit in raw_params.split(','))
378         assert len(params) == 3 and all(x in params for x in ('t', 'm', 'p'))
379         time_cost = int(params['t'])
380         memory_cost = int(params['m'])
381         parallelism = int(params['p'])
382         return (
383             algorithm, variety, version, time_cost, memory_cost, parallelism,
384             salt, data,
385         )
386 
387 
388 class BCryptSHA256PasswordHasher(BasePasswordHasher):
389     """
390     Secure password hashing using the bcrypt algorithm (recommended)
391 
392     This is considered by many to be the most secure algorithm but you
393     must first install the bcrypt library.  Please be warned that
394     this library depends on native C code and might cause portability
395     issues.
396     """
397     algorithm = "bcrypt_sha256"
398     digest = hashlib.sha256
399     library = ("bcrypt", "bcrypt")
400     rounds = 12
401 
402     def salt(self):
403         bcrypt = self._load_library()
404         return bcrypt.gensalt(self.rounds)
405 
406     def encode(self, password, salt):
407         bcrypt = self._load_library()
408         password = password.encode()
409         # Hash the password prior to using bcrypt to prevent password
410         # truncation as described in #20138.
411         if self.digest is not None:
412             # Use binascii.hexlify() because a hex encoded bytestring is str.
413             password = binascii.hexlify(self.digest(password).digest())
414 
415         data = bcrypt.hashpw(password, salt)
416         return "%s$%s" % (self.algorithm, data.decode('ascii'))
417 
418     def verify(self, password, encoded):
419         algorithm, data = encoded.split('$', 1)
420         assert algorithm == self.algorithm
421         encoded_2 = self.encode(password, data.encode('ascii'))
422         return constant_time_compare(encoded, encoded_2)
423 
424     def safe_summary(self, encoded):
425         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)
426         assert algorithm == self.algorithm
427         salt, checksum = data[:22], data[22:]
428         return {
429             _('algorithm'): algorithm,
430             _('work factor'): work_factor,
431             _('salt'): mask_hash(salt),
432             _('checksum'): mask_hash(checksum),
433         }
434 
435     def must_update(self, encoded):
436         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)
437         return int(rounds) != self.rounds
438 
439     def harden_runtime(self, password, encoded):
440         _, data = encoded.split('$', 1)
441         salt = data[:29]  # Length of the salt in bcrypt.
442         rounds = data.split('$')[2]
443         # work factor is logarithmic, adding one doubles the load.
444         diff = 2**(self.rounds - int(rounds)) - 1
445         while diff > 0:
446             self.encode(password, salt.encode('ascii'))
447             diff -= 1
448 
449 
450 class BCryptPasswordHasher(BCryptSHA256PasswordHasher):
451     """
452     Secure password hashing using the bcrypt algorithm
453 
454     This is considered by many to be the most secure algorithm but you
455     must first install the bcrypt library.  Please be warned that
456     this library depends on native C code and might cause portability
457     issues.
458 
459     This hasher does not first hash the password which means it is subject to
460     bcrypt's 72 bytes password truncation. Most use cases should prefer the
461     BCryptSHA256PasswordHasher.
462     """
463     algorithm = "bcrypt"
464     digest = None
465 
466 
467 class SHA1PasswordHasher(BasePasswordHasher):
468     """
469     The SHA1 password hashing algorithm (not recommended)
470     """
471     algorithm = "sha1"
472 
473     def encode(self, password, salt):
474         assert password is not None
475         assert salt and '$' not in salt
476         hash = hashlib.sha1((salt + password).encode()).hexdigest()
477         return "%s$%s$%s" % (self.algorithm, salt, hash)
478 
479     def verify(self, password, encoded):
480         algorithm, salt, hash = encoded.split('$', 2)
481         assert algorithm == self.algorithm
482         encoded_2 = self.encode(password, salt)
483         return constant_time_compare(encoded, encoded_2)
484 
485     def safe_summary(self, encoded):
486         algorithm, salt, hash = encoded.split('$', 2)
487         assert algorithm == self.algorithm
488         return {
489             _('algorithm'): algorithm,
490             _('salt'): mask_hash(salt, show=2),
491             _('hash'): mask_hash(hash),
492         }
493 
494     def harden_runtime(self, password, encoded):
495         pass
496 
497 
498 class MD5PasswordHasher(BasePasswordHasher):
499     """
500     The Salted MD5 password hashing algorithm (not recommended)
501     """
502     algorithm = "md5"
503 
504     def encode(self, password, salt):
505         assert password is not None
506         assert salt and '$' not in salt
507         hash = hashlib.md5((salt + password).encode()).hexdigest()
508         return "%s$%s$%s" % (self.algorithm, salt, hash)
509 
510     def verify(self, password, encoded):
511         algorithm, salt, hash = encoded.split('$', 2)
512         assert algorithm == self.algorithm
513         encoded_2 = self.encode(password, salt)
514         return constant_time_compare(encoded, encoded_2)
515 
516     def safe_summary(self, encoded):
517         algorithm, salt, hash = encoded.split('$', 2)
518         assert algorithm == self.algorithm
519         return {
520             _('algorithm'): algorithm,
521             _('salt'): mask_hash(salt, show=2),
522             _('hash'): mask_hash(hash),
523         }
524 
525     def harden_runtime(self, password, encoded):
526         pass
527 
528 
529 class UnsaltedSHA1PasswordHasher(BasePasswordHasher):
530     """
531     Very insecure algorithm that you should *never* use; store SHA1 hashes
532     with an empty salt.
533 
534     This class is implemented because Django used to accept such password
535     hashes. Some older Django installs still have these values lingering
536     around so we need to handle and upgrade them properly.
537     """
538     algorithm = "unsalted_sha1"
539 
540     def salt(self):
541         return ''
542 
543     def encode(self, password, salt):
544         assert salt == ''
545         hash = hashlib.sha1(password.encode()).hexdigest()
546         return 'sha1$$%s' % hash
547 
548     def verify(self, password, encoded):
549         encoded_2 = self.encode(password, '')
550         return constant_time_compare(encoded, encoded_2)
551 
552     def safe_summary(self, encoded):
553         assert encoded.startswith('sha1$$')
554         hash = encoded[6:]
555         return {
556             _('algorithm'): self.algorithm,
557             _('hash'): mask_hash(hash),
558         }
559 
560     def harden_runtime(self, password, encoded):
561         pass
562 
563 
564 class UnsaltedMD5PasswordHasher(BasePasswordHasher):
565     """
566     Incredibly insecure algorithm that you should *never* use; stores unsalted
567     MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an
568     empty salt.
569 
570     This class is implemented because Django used to store passwords this way
571     and to accept such password hashes. Some older Django installs still have
572     these values lingering around so we need to handle and upgrade them
573     properly.
574     """
575     algorithm = "unsalted_md5"
576 
577     def salt(self):
578         return ''
579 
580     def encode(self, password, salt):
581         assert salt == ''
582         return hashlib.md5(password.encode()).hexdigest()
583 
584     def verify(self, password, encoded):
585         if len(encoded) == 37 and encoded.startswith('md5$$'):
586             encoded = encoded[5:]
587         encoded_2 = self.encode(password, '')
588         return constant_time_compare(encoded, encoded_2)
589 
590     def safe_summary(self, encoded):
591         return {
592             _('algorithm'): self.algorithm,
593             _('hash'): mask_hash(encoded, show=3),
594         }
595 
596     def harden_runtime(self, password, encoded):
597         pass
598 
599 
600 class CryptPasswordHasher(BasePasswordHasher):
601     """
602     Password hashing using UNIX crypt (not recommended)
603 
604     The crypt module is not supported on all platforms.
605     """
606     algorithm = "crypt"
607     library = "crypt"
608 
609     def salt(self):
610         return get_random_string(2)
611 
612     def encode(self, password, salt):
613         crypt = self._load_library()
614         assert len(salt) == 2
615         data = crypt.crypt(password, salt)
616         assert data is not None  # A platform like OpenBSD with a dummy crypt module.
617         # we don't need to store the salt, but Django used to do this
618         return "%s$%s$%s" % (self.algorithm, '', data)
619 
620     def verify(self, password, encoded):
621         crypt = self._load_library()
622         algorithm, salt, data = encoded.split('$', 2)
623         assert algorithm == self.algorithm
624         return constant_time_compare(data, crypt.crypt(password, data))
625 
626     def safe_summary(self, encoded):
627         algorithm, salt, data = encoded.split('$', 2)
628         assert algorithm == self.algorithm
629         return {
630             _('algorithm'): algorithm,
631             _('salt'): salt,
632             _('hash'): mask_hash(data, show=3),
633         }
634 
635     def harden_runtime(self, password, encoded):
636         pass

</code><intended_behavior>Revise all three matches in `hashers.py` to use `get_random_string` with an explicit length, which might vary based on the context of each use, such as salt generation for password hashing.</intended_behavior>, <file>django/core/files/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os
2 from datetime import datetime
3 from urllib.parse import urljoin
4 
5 from django.conf import settings
6 from django.core.exceptions import SuspiciousFileOperation
7 from django.core.files import File, locks
8 from django.core.files.move import file_move_safe
9 from django.core.signals import setting_changed
10 from django.utils import timezone
11 from django.utils._os import safe_join
12 from django.utils.crypto import get_random_string
13 from django.utils.deconstruct import deconstructible
14 from django.utils.encoding import filepath_to_uri
15 from django.utils.functional import LazyObject, cached_property
16 from django.utils.module_loading import import_string
17 from django.utils.text import get_valid_filename
18 
19 __all__ = (
20     'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',
21     'get_storage_class',
22 )
23 
24 
25 class Storage:
26     """
27     A base storage class, providing some default behaviors that all other
28     storage systems can inherit or override, as necessary.
29     """
30 
31     # The following methods represent a public interface to private methods.
32     # These shouldn't be overridden by subclasses unless absolutely necessary.
33 
34     def open(self, name, mode='rb'):
35         """Retrieve the specified file from storage."""
36         return self._open(name, mode)
37 
38     def save(self, name, content, max_length=None):
39         """
40         Save new content to the file specified by name. The content should be
41         a proper File object or any Python file-like object, ready to be read
42         from the beginning.
43         """
44         # Get the proper name for the file, as it will actually be saved.
45         if name is None:
46             name = content.name
47 
48         if not hasattr(content, 'chunks'):
49             content = File(content, name)
50 
51         name = self.get_available_name(name, max_length=max_length)
52         return self._save(name, content)
53 
54     # These methods are part of the public API, with default implementations.
55 
56     def get_valid_name(self, name):
57         """
58         Return a filename, based on the provided filename, that's suitable for
59         use in the target storage system.
60         """
61         return get_valid_filename(name)
62 
63     def get_alternative_name(self, file_root, file_ext):
64         """
65         Return an alternative filename, by adding an underscore and a random 7
66         character alphanumeric string (before the file extension, if one
67         exists) to the filename.
68         """
69         return '%s_%s%s' % (file_root, get_random_string(7), file_ext)
70 
71     def get_available_name(self, name, max_length=None):
72         """
73         Return a filename that's free on the target storage system and
74         available for new content to be written to.
75         """
76         dir_name, file_name = os.path.split(name)
77         file_root, file_ext = os.path.splitext(file_name)
78         # If the filename already exists, generate an alternative filename
79         # until it doesn't exist.
80         # Truncate original name if required, so the new filename does not
81         # exceed the max_length.
82         while self.exists(name) or (max_length and len(name) > max_length):
83             # file_ext includes the dot.
84             name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
85             if max_length is None:
86                 continue
87             # Truncate file_root if max_length exceeded.
88             truncation = len(name) - max_length
89             if truncation > 0:
90                 file_root = file_root[:-truncation]
91                 # Entire file_root was truncated in attempt to find an available filename.
92                 if not file_root:
93                     raise SuspiciousFileOperation(
94                         'Storage can not find an available filename for "%s". '
95                         'Please make sure that the corresponding file field '
96                         'allows sufficient "max_length".' % name
97                     )
98                 name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
99         return name
100 
101     def generate_filename(self, filename):
102         """
103         Validate the filename by calling get_valid_name() and return a filename
104         to be passed to the save() method.
105         """
106         # `filename` may include a path as returned by FileField.upload_to.
107         dirname, filename = os.path.split(filename)
108         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))
109 
110     def path(self, name):
111         """
112         Return a local filesystem path where the file can be retrieved using
113         Python's built-in open() function. Storage systems that can't be
114         accessed using open() should *not* implement this method.
115         """
116         raise NotImplementedError("This backend doesn't support absolute paths.")
117 
118     # The following methods form the public API for storage systems, but with
119     # no default implementations. Subclasses must implement *all* of these.
120 
121     def delete(self, name):
122         """
123         Delete the specified file from the storage system.
124         """
125         raise NotImplementedError('subclasses of Storage must provide a delete() method')
126 
127     def exists(self, name):
128         """
129         Return True if a file referenced by the given name already exists in the
130         storage system, or False if the name is available for a new file.
131         """
132         raise NotImplementedError('subclasses of Storage must provide an exists() method')
133 
134     def listdir(self, path):
135         """
136         List the contents of the specified path. Return a 2-tuple of lists:
137         the first item being directories, the second item being files.
138         """
139         raise NotImplementedError('subclasses of Storage must provide a listdir() method')
140 
141     def size(self, name):
142         """
143         Return the total size, in bytes, of the file specified by name.
144         """
145         raise NotImplementedError('subclasses of Storage must provide a size() method')
146 
147     def url(self, name):
148         """
149         Return an absolute URL where the file's contents can be accessed
150         directly by a Web browser.
151         """
152         raise NotImplementedError('subclasses of Storage must provide a url() method')
153 
154     def get_accessed_time(self, name):
155         """
156         Return the last accessed time (as a datetime) of the file specified by
157         name. The datetime will be timezone-aware if USE_TZ=True.
158         """
159         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')
160 
161     def get_created_time(self, name):
162         """
163         Return the creation time (as a datetime) of the file specified by name.
164         The datetime will be timezone-aware if USE_TZ=True.
165         """
166         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')
167 
168     def get_modified_time(self, name):
169         """
170         Return the last modified time (as a datetime) of the file specified by
171         name. The datetime will be timezone-aware if USE_TZ=True.
172         """
173         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')
174 
175 
176 @deconstructible
177 class FileSystemStorage(Storage):
178     """
179     Standard filesystem storage
180     """
181     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if
182     # the file already exists before it's opened.
183     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)
184 
185     def __init__(self, location=None, base_url=None, file_permissions_mode=None,
186                  directory_permissions_mode=None):
187         self._location = location
188         self._base_url = base_url
189         self._file_permissions_mode = file_permissions_mode
190         self._directory_permissions_mode = directory_permissions_mode
191         setting_changed.connect(self._clear_cached_properties)
192 
193     def _clear_cached_properties(self, setting, **kwargs):
194         """Reset setting based property values."""
195         if setting == 'MEDIA_ROOT':
196             self.__dict__.pop('base_location', None)
197             self.__dict__.pop('location', None)
198         elif setting == 'MEDIA_URL':
199             self.__dict__.pop('base_url', None)
200         elif setting == 'FILE_UPLOAD_PERMISSIONS':
201             self.__dict__.pop('file_permissions_mode', None)
202         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':
203             self.__dict__.pop('directory_permissions_mode', None)
204 
205     def _value_or_setting(self, value, setting):
206         return setting if value is None else value
207 
208     @cached_property
209     def base_location(self):
210         return self._value_or_setting(self._location, settings.MEDIA_ROOT)
211 
212     @cached_property
213     def location(self):
214         return os.path.abspath(self.base_location)
215 
216     @cached_property
217     def base_url(self):
218         if self._base_url is not None and not self._base_url.endswith('/'):
219             self._base_url += '/'
220         return self._value_or_setting(self._base_url, settings.MEDIA_URL)
221 
222     @cached_property
223     def file_permissions_mode(self):
224         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)
225 
226     @cached_property
227     def directory_permissions_mode(self):
228         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)
229 
230     def _open(self, name, mode='rb'):
231         return File(open(self.path(name), mode))
232 
233     def _save(self, name, content):
234         full_path = self.path(name)
235 
236         # Create any intermediate directories that do not exist.
237         directory = os.path.dirname(full_path)
238         try:
239             if self.directory_permissions_mode is not None:
240                 # os.makedirs applies the global umask, so we reset it,
241                 # for consistency with file_permissions_mode behavior.
242                 old_umask = os.umask(0)
243                 try:
244                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)
245                 finally:
246                     os.umask(old_umask)
247             else:
248                 os.makedirs(directory, exist_ok=True)
249         except FileExistsError:
250             raise FileExistsError('%s exists and is not a directory.' % directory)
251 
252         # There's a potential race condition between get_available_name and
253         # saving the file; it's possible that two threads might return the
254         # same name, at which point all sorts of fun happens. So we need to
255         # try to create the file, but if it already exists we have to go back
256         # to get_available_name() and try again.
257 
258         while True:
259             try:
260                 # This file has a file path that we can move.
261                 if hasattr(content, 'temporary_file_path'):
262                     file_move_safe(content.temporary_file_path(), full_path)
263 
264                 # This is a normal uploadedfile that we can stream.
265                 else:
266                     # The current umask value is masked out by os.open!
267                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)
268                     _file = None
269                     try:
270                         locks.lock(fd, locks.LOCK_EX)
271                         for chunk in content.chunks():
272                             if _file is None:
273                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'
274                                 _file = os.fdopen(fd, mode)
275                             _file.write(chunk)
276                     finally:
277                         locks.unlock(fd)
278                         if _file is not None:
279                             _file.close()
280                         else:
281                             os.close(fd)
282             except FileExistsError:
283                 # A new name is needed if the file exists.
284                 name = self.get_available_name(name)
285                 full_path = self.path(name)
286             else:
287                 # OK, the file save worked. Break out of the loop.
288                 break
289 
290         if self.file_permissions_mode is not None:
291             os.chmod(full_path, self.file_permissions_mode)
292 
293         # Store filenames with forward slashes, even on Windows.
294         return str(name).replace('\\', '/')
295 
296     def delete(self, name):
297         assert name, "The name argument is not allowed to be empty."
298         name = self.path(name)
299         # If the file or directory exists, delete it from the filesystem.
300         try:
301             if os.path.isdir(name):
302                 os.rmdir(name)
303             else:
304                 os.remove(name)
305         except FileNotFoundError:
306             # FileNotFoundError is raised if the file or directory was removed
307             # concurrently.
308             pass
309 
310     def exists(self, name):
311         return os.path.exists(self.path(name))
312 
313     def listdir(self, path):
314         path = self.path(path)
315         directories, files = [], []
316         for entry in os.scandir(path):
317             if entry.is_dir():
318                 directories.append(entry.name)
319             else:
320                 files.append(entry.name)
321         return directories, files
322 
323     def path(self, name):
324         return safe_join(self.location, name)
325 
326     def size(self, name):
327         return os.path.getsize(self.path(name))
328 
329     def url(self, name):
330         if self.base_url is None:
331             raise ValueError("This file is not accessible via a URL.")
332         url = filepath_to_uri(name)
333         if url is not None:
334             url = url.lstrip('/')
335         return urljoin(self.base_url, url)
336 
337     def _datetime_from_timestamp(self, ts):
338         """
339         If timezone support is enabled, make an aware datetime object in UTC;
340         otherwise make a naive one in the local timezone.
341         """
342         if settings.USE_TZ:
343             # Safe to use .replace() because UTC doesn't have DST
344             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)
345         else:
346             return datetime.fromtimestamp(ts)
347 
348     def get_accessed_time(self, name):
349         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))
350 
351     def get_created_time(self, name):
352         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))
353 
354     def get_modified_time(self, name):
355         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))
356 
357 
358 def get_storage_class(import_path=None):
359     return import_string(import_path or settings.DEFAULT_FILE_STORAGE)
360 
361 
362 class DefaultStorage(LazyObject):
363     def _setup(self):
364         self._wrapped = get_storage_class()()
365 
366 
367 default_storage = DefaultStorage()

</code><intended_behavior>Provide an explicit `length` for file storage-related uses of `get_random_string`, which could involve generating random filenames or paths.</intended_behavior>, <file>django/core/management/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import fnmatch
2 import os
3 from pathlib import Path
4 from subprocess import PIPE, run
5 
6 from django.apps import apps as installed_apps
7 from django.utils.crypto import get_random_string
8 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
9 
10 from .base import CommandError, CommandParser
11 
12 
13 def popen_wrapper(args, stdout_encoding='utf-8'):
14     """
15     Friendly wrapper around Popen.
16 
17     Return stdout output, stderr output, and OS status code.
18     """
19     try:
20         p = run(args, stdout=PIPE, stderr=PIPE, close_fds=os.name != 'nt')
21     except OSError as err:
22         raise CommandError('Error executing %s' % args[0]) from err
23     return (
24         p.stdout.decode(stdout_encoding),
25         p.stderr.decode(DEFAULT_LOCALE_ENCODING, errors='replace'),
26         p.returncode
27     )
28 
29 
30 def handle_extensions(extensions):
31     """
32     Organize multiple extensions that are separated with commas or passed by
33     using --extension/-e multiple times.
34 
35     For example: running 'django-admin makemessages -e js,txt -e xhtml -a'
36     would result in an extension list: ['.js', '.txt', '.xhtml']
37 
38     >>> handle_extensions(['.html', 'html,js,py,py,py,.py', 'py,.py'])
39     {'.html', '.js', '.py'}
40     >>> handle_extensions(['.html, txt,.tpl'])
41     {'.html', '.tpl', '.txt'}
42     """
43     ext_list = []
44     for ext in extensions:
45         ext_list.extend(ext.replace(' ', '').split(','))
46     for i, ext in enumerate(ext_list):
47         if not ext.startswith('.'):
48             ext_list[i] = '.%s' % ext_list[i]
49     return set(ext_list)
50 
51 
52 def find_command(cmd, path=None, pathext=None):
53     if path is None:
54         path = os.environ.get('PATH', '').split(os.pathsep)
55     if isinstance(path, str):
56         path = [path]
57     # check if there are funny path extensions for executables, e.g. Windows
58     if pathext is None:
59         pathext = os.environ.get('PATHEXT', '.COM;.EXE;.BAT;.CMD').split(os.pathsep)
60     # don't use extensions if the command ends with one of them
61     for ext in pathext:
62         if cmd.endswith(ext):
63             pathext = ['']
64             break
65     # check if we find the command on PATH
66     for p in path:
67         f = os.path.join(p, cmd)
68         if os.path.isfile(f):
69             return f
70         for ext in pathext:
71             fext = f + ext
72             if os.path.isfile(fext):
73                 return fext
74     return None
75 
76 
77 def get_random_secret_key():
78     """
79     Return a 50 character random string usable as a SECRET_KEY setting value.
80     """
81     chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'
82     return get_random_string(50, chars)
83 
84 
85 def parse_apps_and_model_labels(labels):
86     """
87     Parse a list of "app_label.ModelName" or "app_label" strings into actual
88     objects and return a two-element tuple:
89         (set of model classes, set of app_configs).
90     Raise a CommandError if some specified models or apps don't exist.
91     """
92     apps = set()
93     models = set()
94 
95     for label in labels:
96         if '.' in label:
97             try:
98                 model = installed_apps.get_model(label)
99             except LookupError:
100                 raise CommandError('Unknown model: %s' % label)
101             models.add(model)
102         else:
103             try:
104                 app_config = installed_apps.get_app_config(label)
105             except LookupError as e:
106                 raise CommandError(str(e))
107             apps.add(app_config)
108 
109     return models, apps
110 
111 
112 def get_command_line_option(argv, option):
113     """
114     Return the value of a command line option (which should include leading
115     dashes, e.g. '--testrunner') from an argument list. Return None if the
116     option wasn't passed or if the argument list couldn't be parsed.
117     """
118     parser = CommandParser(add_help=False, allow_abbrev=False)
119     parser.add_argument(option, dest='value')
120     try:
121         options, _ = parser.parse_known_args(argv[2:])
122     except CommandError:
123         return None
124     else:
125         return options.value
126 
127 
128 def normalize_path_patterns(patterns):
129     """Normalize an iterable of glob style patterns based on OS."""
130     patterns = [os.path.normcase(p) for p in patterns]
131     dir_suffixes = {'%s*' % path_sep for path_sep in {'/', os.sep}}
132     norm_patterns = []
133     for pattern in patterns:
134         for dir_suffix in dir_suffixes:
135             if pattern.endswith(dir_suffix):
136                 norm_patterns.append(pattern[:-len(dir_suffix)])
137                 break
138         else:
139             norm_patterns.append(pattern)
140     return norm_patterns
141 
142 
143 def is_ignored_path(path, ignore_patterns):
144     """
145     Check if the given path should be ignored or not based on matching
146     one of the glob style `ignore_patterns`.
147     """
148     path = Path(path)
149 
150     def ignore(pattern):
151         return fnmatch.fnmatchcase(path.name, pattern) or fnmatch.fnmatchcase(str(path), pattern)
152 
153     return any(ignore(pattern) for pattern in normalize_path_patterns(ignore_patterns))

</code><intended_behavior>Specify an explicit length for any administrative or management tasks calling `get_random_string`, ensuring that any temporary files or identifiers are generated securely.</intended_behavior>]
2025-10-15 17:42:55.672 | INFO     | Search completed. Bug locations: [<file>django/utils/crypto.py</file>
<class>None</class>
<method>get_random_string</method>
<code>
47 def get_random_string(length=12,
48                       allowed_chars='abcdefghijklmnopqrstuvwxyz'
49                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):
50     """
51     Return a securely generated random string.
52 
53     The default length of 12 with the a-z, A-Z, 0-9 character set returns
54     a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
55     """
56     return ''.join(secrets.choice(allowed_chars) for i in range(length))

</code><intended_behavior>Modify the signature of `get_random_string` to remove the default value for the `length` parameter, forcing callers of the function to specify the length explicitly. Ensure that the method's docstring is updated to reflect this change and highlight the necessity of specifying the length.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import re
9 import string
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.urls import get_callable
15 from django.utils.cache import patch_vary_headers
16 from django.utils.crypto import constant_time_compare, get_random_string
17 from django.utils.deprecation import MiddlewareMixin
18 from django.utils.http import is_same_domain
19 from django.utils.log import log_response
20 
21 logger = logging.getLogger('django.security.csrf')
22 
23 REASON_NO_REFERER = "Referer checking failed - no Referer."
24 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
25 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
26 REASON_BAD_TOKEN = "CSRF token missing or incorrect."
27 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
28 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
29 
30 CSRF_SECRET_LENGTH = 32
31 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
32 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
33 CSRF_SESSION_KEY = '_csrftoken'
34 
35 
36 def _get_failure_view():
37     """Return the view to be used for CSRF rejections."""
38     return get_callable(settings.CSRF_FAILURE_VIEW)
39 
40 
41 def _get_new_csrf_string():
42     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
43 
44 
45 def _mask_cipher_secret(secret):
46     """
47     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
48     token by adding a mask and applying it to the secret.
49     """
50     mask = _get_new_csrf_string()
51     chars = CSRF_ALLOWED_CHARS
52     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
53     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
54     return mask + cipher
55 
56 
57 def _unmask_cipher_token(token):
58     """
59     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
60     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
61     the second half to produce the original secret.
62     """
63     mask = token[:CSRF_SECRET_LENGTH]
64     token = token[CSRF_SECRET_LENGTH:]
65     chars = CSRF_ALLOWED_CHARS
66     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
67     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
68 
69 
70 def _get_new_csrf_token():
71     return _mask_cipher_secret(_get_new_csrf_string())
72 
73 
74 def get_token(request):
75     """
76     Return the CSRF token required for a POST form. The token is an
77     alphanumeric value. A new token is created if one is not already set.
78 
79     A side effect of calling this function is to make the csrf_protect
80     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
81     header to the outgoing response.  For this reason, you may need to use this
82     function lazily, as is done by the csrf context processor.
83     """
84     if "CSRF_COOKIE" not in request.META:
85         csrf_secret = _get_new_csrf_string()
86         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
87     else:
88         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
89     request.META["CSRF_COOKIE_USED"] = True
90     return _mask_cipher_secret(csrf_secret)
91 
92 
93 def rotate_token(request):
94     """
95     Change the CSRF token in use for a request - should be done on login
96     for security purposes.
97     """
98     request.META.update({
99         "CSRF_COOKIE_USED": True,
100         "CSRF_COOKIE": _get_new_csrf_token(),
101     })
102     request.csrf_cookie_needs_reset = True
103 
104 
105 def _sanitize_token(token):
106     # Allow only ASCII alphanumerics
107     if re.search('[^a-zA-Z0-9]', token):
108         return _get_new_csrf_token()
109     elif len(token) == CSRF_TOKEN_LENGTH:
110         return token
111     elif len(token) == CSRF_SECRET_LENGTH:
112         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
113         # alphanumeric characters. For backwards compatibility, accept
114         # such values as unmasked secrets.
115         # It's easier to mask here and be consistent later, rather than add
116         # different code paths in the checks, although that might be a tad more
117         # efficient.
118         return _mask_cipher_secret(token)
119     return _get_new_csrf_token()
120 
121 
122 def _compare_masked_tokens(request_csrf_token, csrf_token):
123     # Assume both arguments are sanitized -- that is, strings of
124     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
125     return constant_time_compare(
126         _unmask_cipher_token(request_csrf_token),
127         _unmask_cipher_token(csrf_token),
128     )
129 
130 
131 class CsrfViewMiddleware(MiddlewareMixin):
132     """
133     Require a present and correct csrfmiddlewaretoken for POST requests that
134     have a CSRF cookie, and set an outgoing CSRF cookie.
135 
136     This middleware should be used in conjunction with the {% csrf_token %}
137     template tag.
138     """
139     # The _accept and _reject methods currently only exist for the sake of the
140     # requires_csrf_token decorator.
141     def _accept(self, request):
142         # Avoid checking the request twice by adding a custom attribute to
143         # request.  This will be relevant when both decorator and middleware
144         # are used.
145         request.csrf_processing_done = True
146         return None
147 
148     def _reject(self, request, reason):
149         response = _get_failure_view()(request, reason=reason)
150         log_response(
151             'Forbidden (%s): %s', reason, request.path,
152             response=response,
153             request=request,
154             logger=logger,
155         )
156         return response
157 
158     def _get_token(self, request):
159         if settings.CSRF_USE_SESSIONS:
160             try:
161                 return request.session.get(CSRF_SESSION_KEY)
162             except AttributeError:
163                 raise ImproperlyConfigured(
164                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
165                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
166                     'in MIDDLEWARE.'
167                 )
168         else:
169             try:
170                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
171             except KeyError:
172                 return None
173 
174             csrf_token = _sanitize_token(cookie_token)
175             if csrf_token != cookie_token:
176                 # Cookie token needed to be replaced;
177                 # the cookie needs to be reset.
178                 request.csrf_cookie_needs_reset = True
179             return csrf_token
180 
181     def _set_token(self, request, response):
182         if settings.CSRF_USE_SESSIONS:
183             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
184                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
185         else:
186             response.set_cookie(
187                 settings.CSRF_COOKIE_NAME,
188                 request.META['CSRF_COOKIE'],
189                 max_age=settings.CSRF_COOKIE_AGE,
190                 domain=settings.CSRF_COOKIE_DOMAIN,
191                 path=settings.CSRF_COOKIE_PATH,
192                 secure=settings.CSRF_COOKIE_SECURE,
193                 httponly=settings.CSRF_COOKIE_HTTPONLY,
194                 samesite=settings.CSRF_COOKIE_SAMESITE,
195             )
196             # Set the Vary header since content varies with the CSRF cookie.
197             patch_vary_headers(response, ('Cookie',))
198 
199     def process_request(self, request):
200         csrf_token = self._get_token(request)
201         if csrf_token is not None:
202             # Use same token next time.
203             request.META['CSRF_COOKIE'] = csrf_token
204 
205     def process_view(self, request, callback, callback_args, callback_kwargs):
206         if getattr(request, 'csrf_processing_done', False):
207             return None
208 
209         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
210         # bailing out, so that get_token still works
211         if getattr(callback, 'csrf_exempt', False):
212             return None
213 
214         # Assume that anything not defined as 'safe' by RFC7231 needs protection
215         if request.method not in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
216             if getattr(request, '_dont_enforce_csrf_checks', False):
217                 # Mechanism to turn off CSRF checks for test suite.
218                 # It comes after the creation of CSRF cookies, so that
219                 # everything else continues to work exactly the same
220                 # (e.g. cookies are sent, etc.), but before any
221                 # branches that call reject().
222                 return self._accept(request)
223 
224             if request.is_secure():
225                 # Suppose user visits http://example.com/
226                 # An active network attacker (man-in-the-middle, MITM) sends a
227                 # POST form that targets https://example.com/detonate-bomb/ and
228                 # submits it via JavaScript.
229                 #
230                 # The attacker will need to provide a CSRF cookie and token, but
231                 # that's no problem for a MITM and the session-independent
232                 # secret we're using. So the MITM can circumvent the CSRF
233                 # protection. This is true for any HTTP connection, but anyone
234                 # using HTTPS expects better! For this reason, for
235                 # https://example.com/ we need additional protection that treats
236                 # http://example.com/ as completely untrusted. Under HTTPS,
237                 # Barth et al. found that the Referer header is missing for
238                 # same-domain requests in only about 0.2% of cases or less, so
239                 # we can use strict Referer checking.
240                 referer = request.META.get('HTTP_REFERER')
241                 if referer is None:
242                     return self._reject(request, REASON_NO_REFERER)
243 
244                 referer = urlparse(referer)
245 
246                 # Make sure we have a valid URL for Referer.
247                 if '' in (referer.scheme, referer.netloc):
248                     return self._reject(request, REASON_MALFORMED_REFERER)
249 
250                 # Ensure that our Referer is also secure.
251                 if referer.scheme != 'https':
252                     return self._reject(request, REASON_INSECURE_REFERER)
253 
254                 # If there isn't a CSRF_COOKIE_DOMAIN, require an exact match
255                 # match on host:port. If not, obey the cookie rules (or those
256                 # for the session cookie, if CSRF_USE_SESSIONS).
257                 good_referer = (
258                     settings.SESSION_COOKIE_DOMAIN
259                     if settings.CSRF_USE_SESSIONS
260                     else settings.CSRF_COOKIE_DOMAIN
261                 )
262                 if good_referer is not None:
263                     server_port = request.get_port()
264                     if server_port not in ('443', '80'):
265                         good_referer = '%s:%s' % (good_referer, server_port)
266                 else:
267                     try:
268                         # request.get_host() includes the port.
269                         good_referer = request.get_host()
270                     except DisallowedHost:
271                         pass
272 
273                 # Create a list of all acceptable HTTP referers, including the
274                 # current host if it's permitted by ALLOWED_HOSTS.
275                 good_hosts = list(settings.CSRF_TRUSTED_ORIGINS)
276                 if good_referer is not None:
277                     good_hosts.append(good_referer)
278 
279                 if not any(is_same_domain(referer.netloc, host) for host in good_hosts):
280                     reason = REASON_BAD_REFERER % referer.geturl()
281                     return self._reject(request, reason)
282 
283             # Access csrf_token via self._get_token() as rotate_token() may
284             # have been called by an authentication middleware during the
285             # process_request() phase.
286             csrf_token = self._get_token(request)
287             if csrf_token is None:
288                 # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
289                 # and in this way we can avoid all CSRF attacks, including login
290                 # CSRF.
291                 return self._reject(request, REASON_NO_CSRF_COOKIE)
292 
293             # Check non-cookie token for match.
294             request_csrf_token = ""
295             if request.method == "POST":
296                 try:
297                     request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
298                 except OSError:
299                     # Handle a broken connection before we've completed reading
300                     # the POST data. process_view shouldn't raise any
301                     # exceptions, so we'll ignore and serve the user a 403
302                     # (assuming they're still listening, which they probably
303                     # aren't because of the error).
304                     pass
305 
306             if request_csrf_token == "":
307                 # Fall back to X-CSRFToken, to make things easier for AJAX,
308                 # and possible for PUT/DELETE.
309                 request_csrf_token = request.META.get(settings.CSRF_HEADER_NAME, '')
310 
311             request_csrf_token = _sanitize_token(request_csrf_token)
312             if not _compare_masked_tokens(request_csrf_token, csrf_token):
313                 return self._reject(request, REASON_BAD_TOKEN)
314 
315         return self._accept(request)
316 
317     def process_response(self, request, response):
318         if not getattr(request, 'csrf_cookie_needs_reset', False):
319             if getattr(response, 'csrf_cookie_set', False):
320                 return response
321 
322         if not request.META.get("CSRF_COOKIE_USED", False):
323             return response
324 
325         # Set the CSRF cookie even if it's already set, so we renew
326         # the expiry timer.
327         self._set_token(request, response)
328         response.csrf_cookie_set = True
329         return response

</code><intended_behavior>Determine an appropriate explicit `length` for the `get_random_string` call, considering CSRF tokens' security requirements.</intended_behavior>, <file>django/db/backends/oracle/creation.py</file>
<class>None</class>
<method>None</method>
<code>
1 import sys
2 
3 from django.conf import settings
4 from django.db import DatabaseError
5 from django.db.backends.base.creation import BaseDatabaseCreation
6 from django.utils.crypto import get_random_string
7 from django.utils.functional import cached_property
8 
9 TEST_DATABASE_PREFIX = 'test_'
10 
11 
12 class DatabaseCreation(BaseDatabaseCreation):
13 
14     @cached_property
15     def _maindb_connection(self):
16         """
17         This is analogous to other backends' `_nodb_connection` property,
18         which allows access to an "administrative" connection which can
19         be used to manage the test databases.
20         For Oracle, the only connection that can be used for that purpose
21         is the main (non-test) connection.
22         """
23         settings_dict = settings.DATABASES[self.connection.alias]
24         user = settings_dict.get('SAVED_USER') or settings_dict['USER']
25         password = settings_dict.get('SAVED_PASSWORD') or settings_dict['PASSWORD']
26         settings_dict = {**settings_dict, 'USER': user, 'PASSWORD': password}
27         DatabaseWrapper = type(self.connection)
28         return DatabaseWrapper(settings_dict, alias=self.connection.alias)
29 
30     def _create_test_db(self, verbosity=1, autoclobber=False, keepdb=False):
31         parameters = self._get_test_db_params()
32         with self._maindb_connection.cursor() as cursor:
33             if self._test_database_create():
34                 try:
35                     self._execute_test_db_creation(cursor, parameters, verbosity, keepdb)
36                 except Exception as e:
37                     if 'ORA-01543' not in str(e):
38                         # All errors except "tablespace already exists" cancel tests
39                         self.log('Got an error creating the test database: %s' % e)
40                         sys.exit(2)
41                     if not autoclobber:
42                         confirm = input(
43                             "It appears the test database, %s, already exists. "
44                             "Type 'yes' to delete it, or 'no' to cancel: " % parameters['user'])
45                     if autoclobber or confirm == 'yes':
46                         if verbosity >= 1:
47                             self.log("Destroying old test database for alias '%s'..." % self.connection.alias)
48                         try:
49                             self._execute_test_db_destruction(cursor, parameters, verbosity)
50                         except DatabaseError as e:
51                             if 'ORA-29857' in str(e):
52                                 self._handle_objects_preventing_db_destruction(cursor, parameters,
53                                                                                verbosity, autoclobber)
54                             else:
55                                 # Ran into a database error that isn't about leftover objects in the tablespace
56                                 self.log('Got an error destroying the old test database: %s' % e)
57                                 sys.exit(2)
58                         except Exception as e:
59                             self.log('Got an error destroying the old test database: %s' % e)
60                             sys.exit(2)
61                         try:
62                             self._execute_test_db_creation(cursor, parameters, verbosity, keepdb)
63                         except Exception as e:
64                             self.log('Got an error recreating the test database: %s' % e)
65                             sys.exit(2)
66                     else:
67                         self.log('Tests cancelled.')
68                         sys.exit(1)
69 
70             if self._test_user_create():
71                 if verbosity >= 1:
72                     self.log('Creating test user...')
73                 try:
74                     self._create_test_user(cursor, parameters, verbosity, keepdb)
75                 except Exception as e:
76                     if 'ORA-01920' not in str(e):
77                         # All errors except "user already exists" cancel tests
78                         self.log('Got an error creating the test user: %s' % e)
79                         sys.exit(2)
80                     if not autoclobber:
81                         confirm = input(
82                             "It appears the test user, %s, already exists. Type "
83                             "'yes' to delete it, or 'no' to cancel: " % parameters['user'])
84                     if autoclobber or confirm == 'yes':
85                         try:
86                             if verbosity >= 1:
87                                 self.log('Destroying old test user...')
88                             self._destroy_test_user(cursor, parameters, verbosity)
89                             if verbosity >= 1:
90                                 self.log('Creating test user...')
91                             self._create_test_user(cursor, parameters, verbosity, keepdb)
92                         except Exception as e:
93                             self.log('Got an error recreating the test user: %s' % e)
94                             sys.exit(2)
95                     else:
96                         self.log('Tests cancelled.')
97                         sys.exit(1)
98         self._maindb_connection.close()  # done with main user -- test user and tablespaces created
99         self._switch_to_test_user(parameters)
100         return self.connection.settings_dict['NAME']
101 
102     def _switch_to_test_user(self, parameters):
103         """
104         Switch to the user that's used for creating the test database.
105 
106         Oracle doesn't have the concept of separate databases under the same
107         user, so a separate user is used; see _create_test_db(). The main user
108         is also needed for cleanup when testing is completed, so save its
109         credentials in the SAVED_USER/SAVED_PASSWORD key in the settings dict.
110         """
111         real_settings = settings.DATABASES[self.connection.alias]
112         real_settings['SAVED_USER'] = self.connection.settings_dict['SAVED_USER'] = \
113             self.connection.settings_dict['USER']
114         real_settings['SAVED_PASSWORD'] = self.connection.settings_dict['SAVED_PASSWORD'] = \
115             self.connection.settings_dict['PASSWORD']
116         real_test_settings = real_settings['TEST']
117         test_settings = self.connection.settings_dict['TEST']
118         real_test_settings['USER'] = real_settings['USER'] = test_settings['USER'] = \
119             self.connection.settings_dict['USER'] = parameters['user']
120         real_settings['PASSWORD'] = self.connection.settings_dict['PASSWORD'] = parameters['password']
121 
122     def set_as_test_mirror(self, primary_settings_dict):
123         """
124         Set this database up to be used in testing as a mirror of a primary
125         database whose settings are given.
126         """
127         self.connection.settings_dict['USER'] = primary_settings_dict['USER']
128         self.connection.settings_dict['PASSWORD'] = primary_settings_dict['PASSWORD']
129 
130     def _handle_objects_preventing_db_destruction(self, cursor, parameters, verbosity, autoclobber):
131         # There are objects in the test tablespace which prevent dropping it
132         # The easy fix is to drop the test user -- but are we allowed to do so?
133         self.log(
134             'There are objects in the old test database which prevent its destruction.\n'
135             'If they belong to the test user, deleting the user will allow the test '
136             'database to be recreated.\n'
137             'Otherwise, you will need to find and remove each of these objects, '
138             'or use a different tablespace.\n'
139         )
140         if self._test_user_create():
141             if not autoclobber:
142                 confirm = input("Type 'yes' to delete user %s: " % parameters['user'])
143             if autoclobber or confirm == 'yes':
144                 try:
145                     if verbosity >= 1:
146                         self.log('Destroying old test user...')
147                     self._destroy_test_user(cursor, parameters, verbosity)
148                 except Exception as e:
149                     self.log('Got an error destroying the test user: %s' % e)
150                     sys.exit(2)
151                 try:
152                     if verbosity >= 1:
153                         self.log("Destroying old test database for alias '%s'..." % self.connection.alias)
154                     self._execute_test_db_destruction(cursor, parameters, verbosity)
155                 except Exception as e:
156                     self.log('Got an error destroying the test database: %s' % e)
157                     sys.exit(2)
158             else:
159                 self.log('Tests cancelled -- test database cannot be recreated.')
160                 sys.exit(1)
161         else:
162             self.log("Django is configured to use pre-existing test user '%s',"
163                      " and will not attempt to delete it." % parameters['user'])
164             self.log('Tests cancelled -- test database cannot be recreated.')
165             sys.exit(1)
166 
167     def _destroy_test_db(self, test_database_name, verbosity=1):
168         """
169         Destroy a test database, prompting the user for confirmation if the
170         database already exists. Return the name of the test database created.
171         """
172         self.connection.settings_dict['USER'] = self.connection.settings_dict['SAVED_USER']
173         self.connection.settings_dict['PASSWORD'] = self.connection.settings_dict['SAVED_PASSWORD']
174         self.connection.close()
175         parameters = self._get_test_db_params()
176         with self._maindb_connection.cursor() as cursor:
177             if self._test_user_create():
178                 if verbosity >= 1:
179                     self.log('Destroying test user...')
180                 self._destroy_test_user(cursor, parameters, verbosity)
181             if self._test_database_create():
182                 if verbosity >= 1:
183                     self.log('Destroying test database tables...')
184                 self._execute_test_db_destruction(cursor, parameters, verbosity)
185         self._maindb_connection.close()
186 
187     def _execute_test_db_creation(self, cursor, parameters, verbosity, keepdb=False):
188         if verbosity >= 2:
189             self.log('_create_test_db(): dbname = %s' % parameters['user'])
190         if self._test_database_oracle_managed_files():
191             statements = [
192                 """
193                 CREATE TABLESPACE %(tblspace)s
194                 DATAFILE SIZE %(size)s
195                 AUTOEXTEND ON NEXT %(extsize)s MAXSIZE %(maxsize)s
196                 """,
197                 """
198                 CREATE TEMPORARY TABLESPACE %(tblspace_temp)s
199                 TEMPFILE SIZE %(size_tmp)s
200                 AUTOEXTEND ON NEXT %(extsize_tmp)s MAXSIZE %(maxsize_tmp)s
201                 """,
202             ]
203         else:
204             statements = [
205                 """
206                 CREATE TABLESPACE %(tblspace)s
207                 DATAFILE '%(datafile)s' SIZE %(size)s REUSE
208                 AUTOEXTEND ON NEXT %(extsize)s MAXSIZE %(maxsize)s
209                 """,
210                 """
211                 CREATE TEMPORARY TABLESPACE %(tblspace_temp)s
212                 TEMPFILE '%(datafile_tmp)s' SIZE %(size_tmp)s REUSE
213                 AUTOEXTEND ON NEXT %(extsize_tmp)s MAXSIZE %(maxsize_tmp)s
214                 """,
215             ]
216         # Ignore "tablespace already exists" error when keepdb is on.
217         acceptable_ora_err = 'ORA-01543' if keepdb else None
218         self._execute_allow_fail_statements(cursor, statements, parameters, verbosity, acceptable_ora_err)
219 
220     def _create_test_user(self, cursor, parameters, verbosity, keepdb=False):
221         if verbosity >= 2:
222             self.log('_create_test_user(): username = %s' % parameters['user'])
223         statements = [
224             """CREATE USER %(user)s
225                IDENTIFIED BY "%(password)s"
226                DEFAULT TABLESPACE %(tblspace)s
227                TEMPORARY TABLESPACE %(tblspace_temp)s
228                QUOTA UNLIMITED ON %(tblspace)s
229             """,
230             """GRANT CREATE SESSION,
231                      CREATE TABLE,
232                      CREATE SEQUENCE,
233                      CREATE PROCEDURE,
234                      CREATE TRIGGER
235                TO %(user)s""",
236         ]
237         # Ignore "user already exists" error when keepdb is on
238         acceptable_ora_err = 'ORA-01920' if keepdb else None
239         success = self._execute_allow_fail_statements(cursor, statements, parameters, verbosity, acceptable_ora_err)
240         # If the password was randomly generated, change the user accordingly.
241         if not success and self._test_settings_get('PASSWORD') is None:
242             set_password = 'ALTER USER %(user)s IDENTIFIED BY "%(password)s"'
243             self._execute_statements(cursor, [set_password], parameters, verbosity)
244         # Most test suites can be run without "create view" and
245         # "create materialized view" privileges. But some need it.
246         for object_type in ('VIEW', 'MATERIALIZED VIEW'):
247             extra = 'GRANT CREATE %(object_type)s TO %(user)s'
248             parameters['object_type'] = object_type
249             success = self._execute_allow_fail_statements(cursor, [extra], parameters, verbosity, 'ORA-01031')
250             if not success and verbosity >= 2:
251                 self.log('Failed to grant CREATE %s permission to test user. This may be ok.' % object_type)
252 
253     def _execute_test_db_destruction(self, cursor, parameters, verbosity):
254         if verbosity >= 2:
255             self.log('_execute_test_db_destruction(): dbname=%s' % parameters['user'])
256         statements = [
257             'DROP TABLESPACE %(tblspace)s INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS',
258             'DROP TABLESPACE %(tblspace_temp)s INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS',
259         ]
260         self._execute_statements(cursor, statements, parameters, verbosity)
261 
262     def _destroy_test_user(self, cursor, parameters, verbosity):
263         if verbosity >= 2:
264             self.log('_destroy_test_user(): user=%s' % parameters['user'])
265             self.log('Be patient. This can take some time...')
266         statements = [
267             'DROP USER %(user)s CASCADE',
268         ]
269         self._execute_statements(cursor, statements, parameters, verbosity)
270 
271     def _execute_statements(self, cursor, statements, parameters, verbosity, allow_quiet_fail=False):
272         for template in statements:
273             stmt = template % parameters
274             if verbosity >= 2:
275                 print(stmt)
276             try:
277                 cursor.execute(stmt)
278             except Exception as err:
279                 if (not allow_quiet_fail) or verbosity >= 2:
280                     self.log('Failed (%s)' % (err))
281                 raise
282 
283     def _execute_allow_fail_statements(self, cursor, statements, parameters, verbosity, acceptable_ora_err):
284         """
285         Execute statements which are allowed to fail silently if the Oracle
286         error code given by `acceptable_ora_err` is raised. Return True if the
287         statements execute without an exception, or False otherwise.
288         """
289         try:
290             # Statement can fail when acceptable_ora_err is not None
291             allow_quiet_fail = acceptable_ora_err is not None and len(acceptable_ora_err) > 0
292             self._execute_statements(cursor, statements, parameters, verbosity, allow_quiet_fail=allow_quiet_fail)
293             return True
294         except DatabaseError as err:
295             description = str(err)
296             if acceptable_ora_err is None or acceptable_ora_err not in description:
297                 raise
298             return False
299 
300     def _get_test_db_params(self):
301         return {
302             'dbname': self._test_database_name(),
303             'user': self._test_database_user(),
304             'password': self._test_database_passwd(),
305             'tblspace': self._test_database_tblspace(),
306             'tblspace_temp': self._test_database_tblspace_tmp(),
307             'datafile': self._test_database_tblspace_datafile(),
308             'datafile_tmp': self._test_database_tblspace_tmp_datafile(),
309             'maxsize': self._test_database_tblspace_maxsize(),
310             'maxsize_tmp': self._test_database_tblspace_tmp_maxsize(),
311             'size': self._test_database_tblspace_size(),
312             'size_tmp': self._test_database_tblspace_tmp_size(),
313             'extsize': self._test_database_tblspace_extsize(),
314             'extsize_tmp': self._test_database_tblspace_tmp_extsize(),
315         }
316 
317     def _test_settings_get(self, key, default=None, prefixed=None):
318         """
319         Return a value from the test settings dict, or a given default, or a
320         prefixed entry from the main settings dict.
321         """
322         settings_dict = self.connection.settings_dict
323         val = settings_dict['TEST'].get(key, default)
324         if val is None and prefixed:
325             val = TEST_DATABASE_PREFIX + settings_dict[prefixed]
326         return val
327 
328     def _test_database_name(self):
329         return self._test_settings_get('NAME', prefixed='NAME')
330 
331     def _test_database_create(self):
332         return self._test_settings_get('CREATE_DB', default=True)
333 
334     def _test_user_create(self):
335         return self._test_settings_get('CREATE_USER', default=True)
336 
337     def _test_database_user(self):
338         return self._test_settings_get('USER', prefixed='USER')
339 
340     def _test_database_passwd(self):
341         password = self._test_settings_get('PASSWORD')
342         if password is None and self._test_user_create():
343             # Oracle passwords are limited to 30 chars and can't contain symbols.
344             password = get_random_string(length=30)
345         return password
346 
347     def _test_database_tblspace(self):
348         return self._test_settings_get('TBLSPACE', prefixed='USER')
349 
350     def _test_database_tblspace_tmp(self):
351         settings_dict = self.connection.settings_dict
352         return settings_dict['TEST'].get('TBLSPACE_TMP',
353                                          TEST_DATABASE_PREFIX + settings_dict['USER'] + '_temp')
354 
355     def _test_database_tblspace_datafile(self):
356         tblspace = '%s.dbf' % self._test_database_tblspace()
357         return self._test_settings_get('DATAFILE', default=tblspace)
358 
359     def _test_database_tblspace_tmp_datafile(self):
360         tblspace = '%s.dbf' % self._test_database_tblspace_tmp()
361         return self._test_settings_get('DATAFILE_TMP', default=tblspace)
362 
363     def _test_database_tblspace_maxsize(self):
364         return self._test_settings_get('DATAFILE_MAXSIZE', default='500M')
365 
366     def _test_database_tblspace_tmp_maxsize(self):
367         return self._test_settings_get('DATAFILE_TMP_MAXSIZE', default='500M')
368 
369     def _test_database_tblspace_size(self):
370         return self._test_settings_get('DATAFILE_SIZE', default='50M')
371 
372     def _test_database_tblspace_tmp_size(self):
373         return self._test_settings_get('DATAFILE_TMP_SIZE', default='50M')
374 
375     def _test_database_tblspace_extsize(self):
376         return self._test_settings_get('DATAFILE_EXTSIZE', default='25M')
377 
378     def _test_database_tblspace_tmp_extsize(self):
379         return self._test_settings_get('DATAFILE_TMP_EXTSIZE', default='25M')
380 
381     def _test_database_oracle_managed_files(self):
382         return self._test_settings_get('ORACLE_MANAGED_FILES', default=False)
383 
384     def _get_test_db_name(self):
385         """
386         Return the 'production' DB name to get the test DB creation machinery
387         to work. This isn't a great deal in this case because DB names as
388         handled by Django don't have real counterparts in Oracle.
389         """
390         return self.connection.settings_dict['NAME']
391 
392     def test_db_signature(self):
393         settings_dict = self.connection.settings_dict
394         return (
395             settings_dict['HOST'],
396             settings_dict['PORT'],
397             settings_dict['ENGINE'],
398             settings_dict['NAME'],
399             self._test_database_user(),
400         )

</code><intended_behavior>Specify an explicit `length` where `get_random_string` is used, likely pertaining to object naming or temporary passwords during database creation.</intended_behavior>, <file>django/contrib/sessions/backends/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 import base64
2 import logging
3 import string
4 import warnings
5 from datetime import datetime, timedelta
6 
7 from django.conf import settings
8 from django.contrib.sessions.exceptions import SuspiciousSession
9 from django.core import signing
10 from django.core.exceptions import SuspiciousOperation
11 from django.utils import timezone
12 from django.utils.crypto import (
13     constant_time_compare, get_random_string, salted_hmac,
14 )
15 from django.utils.deprecation import RemovedInDjango40Warning
16 from django.utils.module_loading import import_string
17 from django.utils.translation import LANGUAGE_SESSION_KEY
18 
19 # session_key should not be case sensitive because some backends can store it
20 # on case insensitive file systems.
21 VALID_KEY_CHARS = string.ascii_lowercase + string.digits
22 
23 
24 class CreateError(Exception):
25     """
26     Used internally as a consistent exception type to catch from save (see the
27     docstring for SessionBase.save() for details).
28     """
29     pass
30 
31 
32 class UpdateError(Exception):
33     """
34     Occurs if Django tries to update a session that was deleted.
35     """
36     pass
37 
38 
39 class SessionBase:
40     """
41     Base class for all Session classes.
42     """
43     TEST_COOKIE_NAME = 'testcookie'
44     TEST_COOKIE_VALUE = 'worked'
45 
46     __not_given = object()
47 
48     def __init__(self, session_key=None):
49         self._session_key = session_key
50         self.accessed = False
51         self.modified = False
52         self.serializer = import_string(settings.SESSION_SERIALIZER)
53 
54     def __contains__(self, key):
55         return key in self._session
56 
57     def __getitem__(self, key):
58         if key == LANGUAGE_SESSION_KEY:
59             warnings.warn(
60                 'The user language will no longer be stored in '
61                 'request.session in Django 4.0. Read it from '
62                 'request.COOKIES[settings.LANGUAGE_COOKIE_NAME] instead.',
63                 RemovedInDjango40Warning, stacklevel=2,
64             )
65         return self._session[key]
66 
67     def __setitem__(self, key, value):
68         self._session[key] = value
69         self.modified = True
70 
71     def __delitem__(self, key):
72         del self._session[key]
73         self.modified = True
74 
75     @property
76     def key_salt(self):
77         return 'django.contrib.sessions.' + self.__class__.__qualname__
78 
79     def get(self, key, default=None):
80         return self._session.get(key, default)
81 
82     def pop(self, key, default=__not_given):
83         self.modified = self.modified or key in self._session
84         args = () if default is self.__not_given else (default,)
85         return self._session.pop(key, *args)
86 
87     def setdefault(self, key, value):
88         if key in self._session:
89             return self._session[key]
90         else:
91             self.modified = True
92             self._session[key] = value
93             return value
94 
95     def set_test_cookie(self):
96         self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE
97 
98     def test_cookie_worked(self):
99         return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE
100 
101     def delete_test_cookie(self):
102         del self[self.TEST_COOKIE_NAME]
103 
104     def _hash(self, value):
105         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.
106         key_salt = "django.contrib.sessions" + self.__class__.__name__
107         return salted_hmac(key_salt, value).hexdigest()
108 
109     def encode(self, session_dict):
110         "Return the given session dictionary serialized and encoded as a string."
111         return signing.dumps(
112             session_dict, salt=self.key_salt, serializer=self.serializer,
113             compress=True,
114         )
115 
116     def decode(self, session_data):
117         try:
118             return signing.loads(session_data, salt=self.key_salt, serializer=self.serializer)
119         # RemovedInDjango40Warning: when the deprecation ends, handle here
120         # exceptions similar to what _legacy_decode() does now.
121         except Exception:
122             return self._legacy_decode(session_data)
123 
124     def _legacy_decode(self, session_data):
125         # RemovedInDjango40Warning: pre-Django 3.1 format will be invalid.
126         encoded_data = base64.b64decode(session_data.encode('ascii'))
127         try:
128             # could produce ValueError if there is no ':'
129             hash, serialized = encoded_data.split(b':', 1)
130             expected_hash = self._hash(serialized)
131             if not constant_time_compare(hash.decode(), expected_hash):
132                 raise SuspiciousSession("Session data corrupted")
133             else:
134                 return self.serializer().loads(serialized)
135         except Exception as e:
136             # ValueError, SuspiciousOperation, unpickling exceptions. If any of
137             # these happen, just return an empty dictionary (an empty session).
138             if isinstance(e, SuspiciousOperation):
139                 logger = logging.getLogger('django.security.%s' % e.__class__.__name__)
140                 logger.warning(str(e))
141             return {}
142 
143     def update(self, dict_):
144         self._session.update(dict_)
145         self.modified = True
146 
147     def has_key(self, key):
148         return key in self._session
149 
150     def keys(self):
151         return self._session.keys()
152 
153     def values(self):
154         return self._session.values()
155 
156     def items(self):
157         return self._session.items()
158 
159     def clear(self):
160         # To avoid unnecessary persistent storage accesses, we set up the
161         # internals directly (loading data wastes time, since we are going to
162         # set it to an empty dict anyway).
163         self._session_cache = {}
164         self.accessed = True
165         self.modified = True
166 
167     def is_empty(self):
168         "Return True when there is no session_key and the session is empty."
169         try:
170             return not self._session_key and not self._session_cache
171         except AttributeError:
172             return True
173 
174     def _get_new_session_key(self):
175         "Return session key that isn't being used."
176         while True:
177             session_key = get_random_string(32, VALID_KEY_CHARS)
178             if not self.exists(session_key):
179                 return session_key
180 
181     def _get_or_create_session_key(self):
182         if self._session_key is None:
183             self._session_key = self._get_new_session_key()
184         return self._session_key
185 
186     def _validate_session_key(self, key):
187         """
188         Key must be truthy and at least 8 characters long. 8 characters is an
189         arbitrary lower bound for some minimal key security.
190         """
191         return key and len(key) >= 8
192 
193     def _get_session_key(self):
194         return self.__session_key
195 
196     def _set_session_key(self, value):
197         """
198         Validate session key on assignment. Invalid values will set to None.
199         """
200         if self._validate_session_key(value):
201             self.__session_key = value
202         else:
203             self.__session_key = None
204 
205     session_key = property(_get_session_key)
206     _session_key = property(_get_session_key, _set_session_key)
207 
208     def _get_session(self, no_load=False):
209         """
210         Lazily load session from storage (unless "no_load" is True, when only
211         an empty dict is stored) and store it in the current instance.
212         """
213         self.accessed = True
214         try:
215             return self._session_cache
216         except AttributeError:
217             if self.session_key is None or no_load:
218                 self._session_cache = {}
219             else:
220                 self._session_cache = self.load()
221         return self._session_cache
222 
223     _session = property(_get_session)
224 
225     def get_session_cookie_age(self):
226         return settings.SESSION_COOKIE_AGE
227 
228     def get_expiry_age(self, **kwargs):
229         """Get the number of seconds until the session expires.
230 
231         Optionally, this function accepts `modification` and `expiry` keyword
232         arguments specifying the modification and expiry of the session.
233         """
234         try:
235             modification = kwargs['modification']
236         except KeyError:
237             modification = timezone.now()
238         # Make the difference between "expiry=None passed in kwargs" and
239         # "expiry not passed in kwargs", in order to guarantee not to trigger
240         # self.load() when expiry is provided.
241         try:
242             expiry = kwargs['expiry']
243         except KeyError:
244             expiry = self.get('_session_expiry')
245 
246         if not expiry:   # Checks both None and 0 cases
247             return self.get_session_cookie_age()
248         if not isinstance(expiry, datetime):
249             return expiry
250         delta = expiry - modification
251         return delta.days * 86400 + delta.seconds
252 
253     def get_expiry_date(self, **kwargs):
254         """Get session the expiry date (as a datetime object).
255 
256         Optionally, this function accepts `modification` and `expiry` keyword
257         arguments specifying the modification and expiry of the session.
258         """
259         try:
260             modification = kwargs['modification']
261         except KeyError:
262             modification = timezone.now()
263         # Same comment as in get_expiry_age
264         try:
265             expiry = kwargs['expiry']
266         except KeyError:
267             expiry = self.get('_session_expiry')
268 
269         if isinstance(expiry, datetime):
270             return expiry
271         expiry = expiry or self.get_session_cookie_age()
272         return modification + timedelta(seconds=expiry)
273 
274     def set_expiry(self, value):
275         """
276         Set a custom expiration for the session. ``value`` can be an integer,
277         a Python ``datetime`` or ``timedelta`` object or ``None``.
278 
279         If ``value`` is an integer, the session will expire after that many
280         seconds of inactivity. If set to ``0`` then the session will expire on
281         browser close.
282 
283         If ``value`` is a ``datetime`` or ``timedelta`` object, the session
284         will expire at that specific future time.
285 
286         If ``value`` is ``None``, the session uses the global session expiry
287         policy.
288         """
289         if value is None:
290             # Remove any custom expiration for this session.
291             try:
292                 del self['_session_expiry']
293             except KeyError:
294                 pass
295             return
296         if isinstance(value, timedelta):
297             value = timezone.now() + value
298         self['_session_expiry'] = value
299 
300     def get_expire_at_browser_close(self):
301         """
302         Return ``True`` if the session is set to expire when the browser
303         closes, and ``False`` if there's an expiry date. Use
304         ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry
305         date/age, if there is one.
306         """
307         if self.get('_session_expiry') is None:
308             return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE
309         return self.get('_session_expiry') == 0
310 
311     def flush(self):
312         """
313         Remove the current session data from the database and regenerate the
314         key.
315         """
316         self.clear()
317         self.delete()
318         self._session_key = None
319 
320     def cycle_key(self):
321         """
322         Create a new session key, while retaining the current session data.
323         """
324         data = self._session
325         key = self.session_key
326         self.create()
327         self._session_cache = data
328         if key:
329             self.delete(key)
330 
331     # Methods that child classes must implement.
332 
333     def exists(self, session_key):
334         """
335         Return True if the given session_key already exists.
336         """
337         raise NotImplementedError('subclasses of SessionBase must provide an exists() method')
338 
339     def create(self):
340         """
341         Create a new session instance. Guaranteed to create a new object with
342         a unique key and will have saved the result once (with empty data)
343         before the method returns.
344         """
345         raise NotImplementedError('subclasses of SessionBase must provide a create() method')
346 
347     def save(self, must_create=False):
348         """
349         Save the session data. If 'must_create' is True, create a new session
350         object (or raise CreateError). Otherwise, only update an existing
351         object and don't create one (raise UpdateError if needed).
352         """
353         raise NotImplementedError('subclasses of SessionBase must provide a save() method')
354 
355     def delete(self, session_key=None):
356         """
357         Delete the session data under this key. If the key is None, use the
358         current session key value.
359         """
360         raise NotImplementedError('subclasses of SessionBase must provide a delete() method')
361 
362     def load(self):
363         """
364         Load the session data and return a dictionary.
365         """
366         raise NotImplementedError('subclasses of SessionBase must provide a load() method')
367 
368     @classmethod
369     def clear_expired(cls):
370         """
371         Remove expired sessions from the session store.
372 
373         If this operation isn't possible on a given backend, it should raise
374         NotImplementedError. If it isn't necessary, because the backend has
375         a built-in expiration mechanism, it should be a no-op.
376         """
377         raise NotImplementedError('This backend does not support clear_expired().')

</code><intended_behavior>Adjust the usage of `get_random_string` by setting a suitable `length` for session identifiers to maintain security standards.</intended_behavior>, <file>django/contrib/auth/base_user.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module allows importing AbstractBaseUser even when django.contrib.auth is
3 not in INSTALLED_APPS.
4 """
5 import unicodedata
6 
7 from django.contrib.auth import password_validation
8 from django.contrib.auth.hashers import (
9     check_password, is_password_usable, make_password,
10 )
11 from django.db import models
12 from django.utils.crypto import get_random_string, salted_hmac
13 from django.utils.translation import gettext_lazy as _
14 
15 
16 class BaseUserManager(models.Manager):
17 
18     @classmethod
19     def normalize_email(cls, email):
20         """
21         Normalize the email address by lowercasing the domain part of it.
22         """
23         email = email or ''
24         try:
25             email_name, domain_part = email.strip().rsplit('@', 1)
26         except ValueError:
27             pass
28         else:
29             email = email_name + '@' + domain_part.lower()
30         return email
31 
32     def make_random_password(self, length=10,
33                              allowed_chars='abcdefghjkmnpqrstuvwxyz'
34                                            'ABCDEFGHJKLMNPQRSTUVWXYZ'
35                                            '23456789'):
36         """
37         Generate a random password with the given length and given
38         allowed_chars. The default value of allowed_chars does not have "I" or
39         "O" or letters and digits that look similar -- just to avoid confusion.
40         """
41         return get_random_string(length, allowed_chars)
42 
43     def get_by_natural_key(self, username):
44         return self.get(**{self.model.USERNAME_FIELD: username})
45 
46 
47 class AbstractBaseUser(models.Model):
48     password = models.CharField(_('password'), max_length=128)
49     last_login = models.DateTimeField(_('last login'), blank=True, null=True)
50 
51     is_active = True
52 
53     REQUIRED_FIELDS = []
54 
55     # Stores the raw password if set_password() is called so that it can
56     # be passed to password_changed() after the model is saved.
57     _password = None
58 
59     class Meta:
60         abstract = True
61 
62     def __str__(self):
63         return self.get_username()
64 
65     def save(self, *args, **kwargs):
66         super().save(*args, **kwargs)
67         if self._password is not None:
68             password_validation.password_changed(self._password, self)
69             self._password = None
70 
71     def get_username(self):
72         """Return the username for this User."""
73         return getattr(self, self.USERNAME_FIELD)
74 
75     def clean(self):
76         setattr(self, self.USERNAME_FIELD, self.normalize_username(self.get_username()))
77 
78     def natural_key(self):
79         return (self.get_username(),)
80 
81     @property
82     def is_anonymous(self):
83         """
84         Always return False. This is a way of comparing User objects to
85         anonymous users.
86         """
87         return False
88 
89     @property
90     def is_authenticated(self):
91         """
92         Always return True. This is a way to tell if the user has been
93         authenticated in templates.
94         """
95         return True
96 
97     def set_password(self, raw_password):
98         self.password = make_password(raw_password)
99         self._password = raw_password
100 
101     def check_password(self, raw_password):
102         """
103         Return a boolean of whether the raw_password was correct. Handles
104         hashing formats behind the scenes.
105         """
106         def setter(raw_password):
107             self.set_password(raw_password)
108             # Password hash upgrades shouldn't be considered password changes.
109             self._password = None
110             self.save(update_fields=["password"])
111         return check_password(raw_password, self.password, setter)
112 
113     def set_unusable_password(self):
114         # Set a value that will never be a valid hash
115         self.password = make_password(None)
116 
117     def has_usable_password(self):
118         """
119         Return False if set_unusable_password() has been called for this user.
120         """
121         return is_password_usable(self.password)
122 
123     def get_session_auth_hash(self):
124         """
125         Return an HMAC of the password field.
126         """
127         key_salt = "django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"
128         return salted_hmac(key_salt, self.password).hexdigest()
129 
130     @classmethod
131     def get_email_field_name(cls):
132         try:
133             return cls.EMAIL_FIELD
134         except AttributeError:
135             return 'email'
136 
137     @classmethod
138     def normalize_username(cls, username):
139         return unicodedata.normalize('NFKC', username) if isinstance(username, str) else username

</code><intended_behavior>Update calls to `get_random_string` with an explicit `length`, ensuring user tokens or temporary passwords are securely generated.</intended_behavior>, <file>django/contrib/auth/hashers.py</file>
<class>None</class>
<method>None</method>
<code>
1 import base64
2 import binascii
3 import functools
4 import hashlib
5 import importlib
6 import warnings
7 
8 from django.conf import settings
9 from django.core.exceptions import ImproperlyConfigured
10 from django.core.signals import setting_changed
11 from django.dispatch import receiver
12 from django.utils.crypto import (
13     constant_time_compare, get_random_string, pbkdf2,
14 )
15 from django.utils.module_loading import import_string
16 from django.utils.translation import gettext_noop as _
17 
18 UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash
19 UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX
20 
21 
22 def is_password_usable(encoded):
23     """
24     Return True if this password wasn't generated by
25     User.set_unusable_password(), i.e. make_password(None).
26     """
27     return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)
28 
29 
30 def check_password(password, encoded, setter=None, preferred='default'):
31     """
32     Return a boolean of whether the raw password matches the three
33     part encoded digest.
34 
35     If setter is specified, it'll be called when you need to
36     regenerate the password.
37     """
38     if password is None or not is_password_usable(encoded):
39         return False
40 
41     preferred = get_hasher(preferred)
42     try:
43         hasher = identify_hasher(encoded)
44     except ValueError:
45         # encoded is gibberish or uses a hasher that's no longer installed.
46         return False
47 
48     hasher_changed = hasher.algorithm != preferred.algorithm
49     must_update = hasher_changed or preferred.must_update(encoded)
50     is_correct = hasher.verify(password, encoded)
51 
52     # If the hasher didn't change (we don't protect against enumeration if it
53     # does) and the password should get updated, try to close the timing gap
54     # between the work factor of the current encoded password and the default
55     # work factor.
56     if not is_correct and not hasher_changed and must_update:
57         hasher.harden_runtime(password, encoded)
58 
59     if setter and is_correct and must_update:
60         setter(password)
61     return is_correct
62 
63 
64 def make_password(password, salt=None, hasher='default'):
65     """
66     Turn a plain-text password into a hash for database storage
67 
68     Same as encode() but generate a new random salt. If password is None then
69     return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
70     which disallows logins. Additional random string reduces chances of gaining
71     access to staff or superuser accounts. See ticket #20079 for more info.
72     """
73     if password is None:
74         return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)
75     hasher = get_hasher(hasher)
76     salt = salt or hasher.salt()
77     return hasher.encode(password, salt)
78 
79 
80 @functools.lru_cache()
81 def get_hashers():
82     hashers = []
83     for hasher_path in settings.PASSWORD_HASHERS:
84         hasher_cls = import_string(hasher_path)
85         hasher = hasher_cls()
86         if not getattr(hasher, 'algorithm'):
87             raise ImproperlyConfigured("hasher doesn't specify an "
88                                        "algorithm name: %s" % hasher_path)
89         hashers.append(hasher)
90     return hashers
91 
92 
93 @functools.lru_cache()
94 def get_hashers_by_algorithm():
95     return {hasher.algorithm: hasher for hasher in get_hashers()}
96 
97 
98 @receiver(setting_changed)
99 def reset_hashers(**kwargs):
100     if kwargs['setting'] == 'PASSWORD_HASHERS':
101         get_hashers.cache_clear()
102         get_hashers_by_algorithm.cache_clear()
103 
104 
105 def get_hasher(algorithm='default'):
106     """
107     Return an instance of a loaded password hasher.
108 
109     If algorithm is 'default', return the default hasher. Lazily import hashers
110     specified in the project's settings file if needed.
111     """
112     if hasattr(algorithm, 'algorithm'):
113         return algorithm
114 
115     elif algorithm == 'default':
116         return get_hashers()[0]
117 
118     else:
119         hashers = get_hashers_by_algorithm()
120         try:
121             return hashers[algorithm]
122         except KeyError:
123             raise ValueError("Unknown password hashing algorithm '%s'. "
124                              "Did you specify it in the PASSWORD_HASHERS "
125                              "setting?" % algorithm)
126 
127 
128 def identify_hasher(encoded):
129     """
130     Return an instance of a loaded password hasher.
131 
132     Identify hasher algorithm by examining encoded hash, and call
133     get_hasher() to return hasher. Raise ValueError if
134     algorithm cannot be identified, or if hasher is not loaded.
135     """
136     # Ancient versions of Django created plain MD5 passwords and accepted
137     # MD5 passwords with an empty salt.
138     if ((len(encoded) == 32 and '$' not in encoded) or
139             (len(encoded) == 37 and encoded.startswith('md5$$'))):
140         algorithm = 'unsalted_md5'
141     # Ancient versions of Django accepted SHA1 passwords with an empty salt.
142     elif len(encoded) == 46 and encoded.startswith('sha1$$'):
143         algorithm = 'unsalted_sha1'
144     else:
145         algorithm = encoded.split('$', 1)[0]
146     return get_hasher(algorithm)
147 
148 
149 def mask_hash(hash, show=6, char="*"):
150     """
151     Return the given hash, with only the first ``show`` number shown. The
152     rest are masked with ``char`` for security reasons.
153     """
154     masked = hash[:show]
155     masked += char * len(hash[show:])
156     return masked
157 
158 
159 class BasePasswordHasher:
160     """
161     Abstract base class for password hashers
162 
163     When creating your own hasher, you need to override algorithm,
164     verify(), encode() and safe_summary().
165 
166     PasswordHasher objects are immutable.
167     """
168     algorithm = None
169     library = None
170 
171     def _load_library(self):
172         if self.library is not None:
173             if isinstance(self.library, (tuple, list)):
174                 name, mod_path = self.library
175             else:
176                 mod_path = self.library
177             try:
178                 module = importlib.import_module(mod_path)
179             except ImportError as e:
180                 raise ValueError("Couldn't load %r algorithm library: %s" %
181                                  (self.__class__.__name__, e))
182             return module
183         raise ValueError("Hasher %r doesn't specify a library attribute" %
184                          self.__class__.__name__)
185 
186     def salt(self):
187         """Generate a cryptographically secure nonce salt in ASCII."""
188         return get_random_string()
189 
190     def verify(self, password, encoded):
191         """Check if the given password is correct."""
192         raise NotImplementedError('subclasses of BasePasswordHasher must provide a verify() method')
193 
194     def encode(self, password, salt):
195         """
196         Create an encoded database value.
197 
198         The result is normally formatted as "algorithm$salt$hash" and
199         must be fewer than 128 characters.
200         """
201         raise NotImplementedError('subclasses of BasePasswordHasher must provide an encode() method')
202 
203     def safe_summary(self, encoded):
204         """
205         Return a summary of safe values.
206 
207         The result is a dictionary and will be used where the password field
208         must be displayed to construct a safe representation of the password.
209         """
210         raise NotImplementedError('subclasses of BasePasswordHasher must provide a safe_summary() method')
211 
212     def must_update(self, encoded):
213         return False
214 
215     def harden_runtime(self, password, encoded):
216         """
217         Bridge the runtime gap between the work factor supplied in `encoded`
218         and the work factor suggested by this hasher.
219 
220         Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
221         `self.iterations` is 30000, this method should run password through
222         another 10000 iterations of PBKDF2. Similar approaches should exist
223         for any hasher that has a work factor. If not, this method should be
224         defined as a no-op to silence the warning.
225         """
226         warnings.warn('subclasses of BasePasswordHasher should provide a harden_runtime() method')
227 
228 
229 class PBKDF2PasswordHasher(BasePasswordHasher):
230     """
231     Secure password hashing using the PBKDF2 algorithm (recommended)
232 
233     Configured to use PBKDF2 + HMAC + SHA256.
234     The result is a 64 byte binary string.  Iterations may be changed
235     safely but you must rename the algorithm if you change SHA256.
236     """
237     algorithm = "pbkdf2_sha256"
238     iterations = 216000
239     digest = hashlib.sha256
240 
241     def encode(self, password, salt, iterations=None):
242         assert password is not None
243         assert salt and '$' not in salt
244         iterations = iterations or self.iterations
245         hash = pbkdf2(password, salt, iterations, digest=self.digest)
246         hash = base64.b64encode(hash).decode('ascii').strip()
247         return "%s$%d$%s$%s" % (self.algorithm, iterations, salt, hash)
248 
249     def verify(self, password, encoded):
250         algorithm, iterations, salt, hash = encoded.split('$', 3)
251         assert algorithm == self.algorithm
252         encoded_2 = self.encode(password, salt, int(iterations))
253         return constant_time_compare(encoded, encoded_2)
254 
255     def safe_summary(self, encoded):
256         algorithm, iterations, salt, hash = encoded.split('$', 3)
257         assert algorithm == self.algorithm
258         return {
259             _('algorithm'): algorithm,
260             _('iterations'): iterations,
261             _('salt'): mask_hash(salt),
262             _('hash'): mask_hash(hash),
263         }
264 
265     def must_update(self, encoded):
266         algorithm, iterations, salt, hash = encoded.split('$', 3)
267         return int(iterations) != self.iterations
268 
269     def harden_runtime(self, password, encoded):
270         algorithm, iterations, salt, hash = encoded.split('$', 3)
271         extra_iterations = self.iterations - int(iterations)
272         if extra_iterations > 0:
273             self.encode(password, salt, extra_iterations)
274 
275 
276 class PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):
277     """
278     Alternate PBKDF2 hasher which uses SHA1, the default PRF
279     recommended by PKCS #5. This is compatible with other
280     implementations of PBKDF2, such as openssl's
281     PKCS5_PBKDF2_HMAC_SHA1().
282     """
283     algorithm = "pbkdf2_sha1"
284     digest = hashlib.sha1
285 
286 
287 class Argon2PasswordHasher(BasePasswordHasher):
288     """
289     Secure password hashing using the argon2 algorithm.
290 
291     This is the winner of the Password Hashing Competition 2013-2015
292     (https://password-hashing.net). It requires the argon2-cffi library which
293     depends on native C code and might cause portability issues.
294     """
295     algorithm = 'argon2'
296     library = 'argon2'
297 
298     time_cost = 2
299     memory_cost = 512
300     parallelism = 2
301 
302     def encode(self, password, salt):
303         argon2 = self._load_library()
304         data = argon2.low_level.hash_secret(
305             password.encode(),
306             salt.encode(),
307             time_cost=self.time_cost,
308             memory_cost=self.memory_cost,
309             parallelism=self.parallelism,
310             hash_len=argon2.DEFAULT_HASH_LENGTH,
311             type=argon2.low_level.Type.I,
312         )
313         return self.algorithm + data.decode('ascii')
314 
315     def verify(self, password, encoded):
316         argon2 = self._load_library()
317         algorithm, rest = encoded.split('$', 1)
318         assert algorithm == self.algorithm
319         try:
320             return argon2.low_level.verify_secret(
321                 ('$' + rest).encode('ascii'),
322                 password.encode(),
323                 type=argon2.low_level.Type.I,
324             )
325         except argon2.exceptions.VerificationError:
326             return False
327 
328     def safe_summary(self, encoded):
329         (algorithm, variety, version, time_cost, memory_cost, parallelism,
330             salt, data) = self._decode(encoded)
331         assert algorithm == self.algorithm
332         return {
333             _('algorithm'): algorithm,
334             _('variety'): variety,
335             _('version'): version,
336             _('memory cost'): memory_cost,
337             _('time cost'): time_cost,
338             _('parallelism'): parallelism,
339             _('salt'): mask_hash(salt),
340             _('hash'): mask_hash(data),
341         }
342 
343     def must_update(self, encoded):
344         (algorithm, variety, version, time_cost, memory_cost, parallelism,
345             salt, data) = self._decode(encoded)
346         assert algorithm == self.algorithm
347         argon2 = self._load_library()
348         return (
349             argon2.low_level.ARGON2_VERSION != version or
350             self.time_cost != time_cost or
351             self.memory_cost != memory_cost or
352             self.parallelism != parallelism
353         )
354 
355     def harden_runtime(self, password, encoded):
356         # The runtime for Argon2 is too complicated to implement a sensible
357         # hardening algorithm.
358         pass
359 
360     def _decode(self, encoded):
361         """
362         Split an encoded hash and return: (
363             algorithm, variety, version, time_cost, memory_cost,
364             parallelism, salt, data,
365         ).
366         """
367         bits = encoded.split('$')
368         if len(bits) == 5:
369             # Argon2 < 1.3
370             algorithm, variety, raw_params, salt, data = bits
371             version = 0x10
372         else:
373             assert len(bits) == 6
374             algorithm, variety, raw_version, raw_params, salt, data = bits
375             assert raw_version.startswith('v=')
376             version = int(raw_version[len('v='):])
377         params = dict(bit.split('=', 1) for bit in raw_params.split(','))
378         assert len(params) == 3 and all(x in params for x in ('t', 'm', 'p'))
379         time_cost = int(params['t'])
380         memory_cost = int(params['m'])
381         parallelism = int(params['p'])
382         return (
383             algorithm, variety, version, time_cost, memory_cost, parallelism,
384             salt, data,
385         )
386 
387 
388 class BCryptSHA256PasswordHasher(BasePasswordHasher):
389     """
390     Secure password hashing using the bcrypt algorithm (recommended)
391 
392     This is considered by many to be the most secure algorithm but you
393     must first install the bcrypt library.  Please be warned that
394     this library depends on native C code and might cause portability
395     issues.
396     """
397     algorithm = "bcrypt_sha256"
398     digest = hashlib.sha256
399     library = ("bcrypt", "bcrypt")
400     rounds = 12
401 
402     def salt(self):
403         bcrypt = self._load_library()
404         return bcrypt.gensalt(self.rounds)
405 
406     def encode(self, password, salt):
407         bcrypt = self._load_library()
408         password = password.encode()
409         # Hash the password prior to using bcrypt to prevent password
410         # truncation as described in #20138.
411         if self.digest is not None:
412             # Use binascii.hexlify() because a hex encoded bytestring is str.
413             password = binascii.hexlify(self.digest(password).digest())
414 
415         data = bcrypt.hashpw(password, salt)
416         return "%s$%s" % (self.algorithm, data.decode('ascii'))
417 
418     def verify(self, password, encoded):
419         algorithm, data = encoded.split('$', 1)
420         assert algorithm == self.algorithm
421         encoded_2 = self.encode(password, data.encode('ascii'))
422         return constant_time_compare(encoded, encoded_2)
423 
424     def safe_summary(self, encoded):
425         algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)
426         assert algorithm == self.algorithm
427         salt, checksum = data[:22], data[22:]
428         return {
429             _('algorithm'): algorithm,
430             _('work factor'): work_factor,
431             _('salt'): mask_hash(salt),
432             _('checksum'): mask_hash(checksum),
433         }
434 
435     def must_update(self, encoded):
436         algorithm, empty, algostr, rounds, data = encoded.split('$', 4)
437         return int(rounds) != self.rounds
438 
439     def harden_runtime(self, password, encoded):
440         _, data = encoded.split('$', 1)
441         salt = data[:29]  # Length of the salt in bcrypt.
442         rounds = data.split('$')[2]
443         # work factor is logarithmic, adding one doubles the load.
444         diff = 2**(self.rounds - int(rounds)) - 1
445         while diff > 0:
446             self.encode(password, salt.encode('ascii'))
447             diff -= 1
448 
449 
450 class BCryptPasswordHasher(BCryptSHA256PasswordHasher):
451     """
452     Secure password hashing using the bcrypt algorithm
453 
454     This is considered by many to be the most secure algorithm but you
455     must first install the bcrypt library.  Please be warned that
456     this library depends on native C code and might cause portability
457     issues.
458 
459     This hasher does not first hash the password which means it is subject to
460     bcrypt's 72 bytes password truncation. Most use cases should prefer the
461     BCryptSHA256PasswordHasher.
462     """
463     algorithm = "bcrypt"
464     digest = None
465 
466 
467 class SHA1PasswordHasher(BasePasswordHasher):
468     """
469     The SHA1 password hashing algorithm (not recommended)
470     """
471     algorithm = "sha1"
472 
473     def encode(self, password, salt):
474         assert password is not None
475         assert salt and '$' not in salt
476         hash = hashlib.sha1((salt + password).encode()).hexdigest()
477         return "%s$%s$%s" % (self.algorithm, salt, hash)
478 
479     def verify(self, password, encoded):
480         algorithm, salt, hash = encoded.split('$', 2)
481         assert algorithm == self.algorithm
482         encoded_2 = self.encode(password, salt)
483         return constant_time_compare(encoded, encoded_2)
484 
485     def safe_summary(self, encoded):
486         algorithm, salt, hash = encoded.split('$', 2)
487         assert algorithm == self.algorithm
488         return {
489             _('algorithm'): algorithm,
490             _('salt'): mask_hash(salt, show=2),
491             _('hash'): mask_hash(hash),
492         }
493 
494     def harden_runtime(self, password, encoded):
495         pass
496 
497 
498 class MD5PasswordHasher(BasePasswordHasher):
499     """
500     The Salted MD5 password hashing algorithm (not recommended)
501     """
502     algorithm = "md5"
503 
504     def encode(self, password, salt):
505         assert password is not None
506         assert salt and '$' not in salt
507         hash = hashlib.md5((salt + password).encode()).hexdigest()
508         return "%s$%s$%s" % (self.algorithm, salt, hash)
509 
510     def verify(self, password, encoded):
511         algorithm, salt, hash = encoded.split('$', 2)
512         assert algorithm == self.algorithm
513         encoded_2 = self.encode(password, salt)
514         return constant_time_compare(encoded, encoded_2)
515 
516     def safe_summary(self, encoded):
517         algorithm, salt, hash = encoded.split('$', 2)
518         assert algorithm == self.algorithm
519         return {
520             _('algorithm'): algorithm,
521             _('salt'): mask_hash(salt, show=2),
522             _('hash'): mask_hash(hash),
523         }
524 
525     def harden_runtime(self, password, encoded):
526         pass
527 
528 
529 class UnsaltedSHA1PasswordHasher(BasePasswordHasher):
530     """
531     Very insecure algorithm that you should *never* use; store SHA1 hashes
532     with an empty salt.
533 
534     This class is implemented because Django used to accept such password
535     hashes. Some older Django installs still have these values lingering
536     around so we need to handle and upgrade them properly.
537     """
538     algorithm = "unsalted_sha1"
539 
540     def salt(self):
541         return ''
542 
543     def encode(self, password, salt):
544         assert salt == ''
545         hash = hashlib.sha1(password.encode()).hexdigest()
546         return 'sha1$$%s' % hash
547 
548     def verify(self, password, encoded):
549         encoded_2 = self.encode(password, '')
550         return constant_time_compare(encoded, encoded_2)
551 
552     def safe_summary(self, encoded):
553         assert encoded.startswith('sha1$$')
554         hash = encoded[6:]
555         return {
556             _('algorithm'): self.algorithm,
557             _('hash'): mask_hash(hash),
558         }
559 
560     def harden_runtime(self, password, encoded):
561         pass
562 
563 
564 class UnsaltedMD5PasswordHasher(BasePasswordHasher):
565     """
566     Incredibly insecure algorithm that you should *never* use; stores unsalted
567     MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an
568     empty salt.
569 
570     This class is implemented because Django used to store passwords this way
571     and to accept such password hashes. Some older Django installs still have
572     these values lingering around so we need to handle and upgrade them
573     properly.
574     """
575     algorithm = "unsalted_md5"
576 
577     def salt(self):
578         return ''
579 
580     def encode(self, password, salt):
581         assert salt == ''
582         return hashlib.md5(password.encode()).hexdigest()
583 
584     def verify(self, password, encoded):
585         if len(encoded) == 37 and encoded.startswith('md5$$'):
586             encoded = encoded[5:]
587         encoded_2 = self.encode(password, '')
588         return constant_time_compare(encoded, encoded_2)
589 
590     def safe_summary(self, encoded):
591         return {
592             _('algorithm'): self.algorithm,
593             _('hash'): mask_hash(encoded, show=3),
594         }
595 
596     def harden_runtime(self, password, encoded):
597         pass
598 
599 
600 class CryptPasswordHasher(BasePasswordHasher):
601     """
602     Password hashing using UNIX crypt (not recommended)
603 
604     The crypt module is not supported on all platforms.
605     """
606     algorithm = "crypt"
607     library = "crypt"
608 
609     def salt(self):
610         return get_random_string(2)
611 
612     def encode(self, password, salt):
613         crypt = self._load_library()
614         assert len(salt) == 2
615         data = crypt.crypt(password, salt)
616         assert data is not None  # A platform like OpenBSD with a dummy crypt module.
617         # we don't need to store the salt, but Django used to do this
618         return "%s$%s$%s" % (self.algorithm, '', data)
619 
620     def verify(self, password, encoded):
621         crypt = self._load_library()
622         algorithm, salt, data = encoded.split('$', 2)
623         assert algorithm == self.algorithm
624         return constant_time_compare(data, crypt.crypt(password, data))
625 
626     def safe_summary(self, encoded):
627         algorithm, salt, data = encoded.split('$', 2)
628         assert algorithm == self.algorithm
629         return {
630             _('algorithm'): algorithm,
631             _('salt'): salt,
632             _('hash'): mask_hash(data, show=3),
633         }
634 
635     def harden_runtime(self, password, encoded):
636         pass

</code><intended_behavior>Revise all three matches in `hashers.py` to use `get_random_string` with an explicit length, which might vary based on the context of each use, such as salt generation for password hashing.</intended_behavior>, <file>django/core/files/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os
2 from datetime import datetime
3 from urllib.parse import urljoin
4 
5 from django.conf import settings
6 from django.core.exceptions import SuspiciousFileOperation
7 from django.core.files import File, locks
8 from django.core.files.move import file_move_safe
9 from django.core.signals import setting_changed
10 from django.utils import timezone
11 from django.utils._os import safe_join
12 from django.utils.crypto import get_random_string
13 from django.utils.deconstruct import deconstructible
14 from django.utils.encoding import filepath_to_uri
15 from django.utils.functional import LazyObject, cached_property
16 from django.utils.module_loading import import_string
17 from django.utils.text import get_valid_filename
18 
19 __all__ = (
20     'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',
21     'get_storage_class',
22 )
23 
24 
25 class Storage:
26     """
27     A base storage class, providing some default behaviors that all other
28     storage systems can inherit or override, as necessary.
29     """
30 
31     # The following methods represent a public interface to private methods.
32     # These shouldn't be overridden by subclasses unless absolutely necessary.
33 
34     def open(self, name, mode='rb'):
35         """Retrieve the specified file from storage."""
36         return self._open(name, mode)
37 
38     def save(self, name, content, max_length=None):
39         """
40         Save new content to the file specified by name. The content should be
41         a proper File object or any Python file-like object, ready to be read
42         from the beginning.
43         """
44         # Get the proper name for the file, as it will actually be saved.
45         if name is None:
46             name = content.name
47 
48         if not hasattr(content, 'chunks'):
49             content = File(content, name)
50 
51         name = self.get_available_name(name, max_length=max_length)
52         return self._save(name, content)
53 
54     # These methods are part of the public API, with default implementations.
55 
56     def get_valid_name(self, name):
57         """
58         Return a filename, based on the provided filename, that's suitable for
59         use in the target storage system.
60         """
61         return get_valid_filename(name)
62 
63     def get_alternative_name(self, file_root, file_ext):
64         """
65         Return an alternative filename, by adding an underscore and a random 7
66         character alphanumeric string (before the file extension, if one
67         exists) to the filename.
68         """
69         return '%s_%s%s' % (file_root, get_random_string(7), file_ext)
70 
71     def get_available_name(self, name, max_length=None):
72         """
73         Return a filename that's free on the target storage system and
74         available for new content to be written to.
75         """
76         dir_name, file_name = os.path.split(name)
77         file_root, file_ext = os.path.splitext(file_name)
78         # If the filename already exists, generate an alternative filename
79         # until it doesn't exist.
80         # Truncate original name if required, so the new filename does not
81         # exceed the max_length.
82         while self.exists(name) or (max_length and len(name) > max_length):
83             # file_ext includes the dot.
84             name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
85             if max_length is None:
86                 continue
87             # Truncate file_root if max_length exceeded.
88             truncation = len(name) - max_length
89             if truncation > 0:
90                 file_root = file_root[:-truncation]
91                 # Entire file_root was truncated in attempt to find an available filename.
92                 if not file_root:
93                     raise SuspiciousFileOperation(
94                         'Storage can not find an available filename for "%s". '
95                         'Please make sure that the corresponding file field '
96                         'allows sufficient "max_length".' % name
97                     )
98                 name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
99         return name
100 
101     def generate_filename(self, filename):
102         """
103         Validate the filename by calling get_valid_name() and return a filename
104         to be passed to the save() method.
105         """
106         # `filename` may include a path as returned by FileField.upload_to.
107         dirname, filename = os.path.split(filename)
108         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))
109 
110     def path(self, name):
111         """
112         Return a local filesystem path where the file can be retrieved using
113         Python's built-in open() function. Storage systems that can't be
114         accessed using open() should *not* implement this method.
115         """
116         raise NotImplementedError("This backend doesn't support absolute paths.")
117 
118     # The following methods form the public API for storage systems, but with
119     # no default implementations. Subclasses must implement *all* of these.
120 
121     def delete(self, name):
122         """
123         Delete the specified file from the storage system.
124         """
125         raise NotImplementedError('subclasses of Storage must provide a delete() method')
126 
127     def exists(self, name):
128         """
129         Return True if a file referenced by the given name already exists in the
130         storage system, or False if the name is available for a new file.
131         """
132         raise NotImplementedError('subclasses of Storage must provide an exists() method')
133 
134     def listdir(self, path):
135         """
136         List the contents of the specified path. Return a 2-tuple of lists:
137         the first item being directories, the second item being files.
138         """
139         raise NotImplementedError('subclasses of Storage must provide a listdir() method')
140 
141     def size(self, name):
142         """
143         Return the total size, in bytes, of the file specified by name.
144         """
145         raise NotImplementedError('subclasses of Storage must provide a size() method')
146 
147     def url(self, name):
148         """
149         Return an absolute URL where the file's contents can be accessed
150         directly by a Web browser.
151         """
152         raise NotImplementedError('subclasses of Storage must provide a url() method')
153 
154     def get_accessed_time(self, name):
155         """
156         Return the last accessed time (as a datetime) of the file specified by
157         name. The datetime will be timezone-aware if USE_TZ=True.
158         """
159         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')
160 
161     def get_created_time(self, name):
162         """
163         Return the creation time (as a datetime) of the file specified by name.
164         The datetime will be timezone-aware if USE_TZ=True.
165         """
166         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')
167 
168     def get_modified_time(self, name):
169         """
170         Return the last modified time (as a datetime) of the file specified by
171         name. The datetime will be timezone-aware if USE_TZ=True.
172         """
173         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')
174 
175 
176 @deconstructible
177 class FileSystemStorage(Storage):
178     """
179     Standard filesystem storage
180     """
181     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if
182     # the file already exists before it's opened.
183     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)
184 
185     def __init__(self, location=None, base_url=None, file_permissions_mode=None,
186                  directory_permissions_mode=None):
187         self._location = location
188         self._base_url = base_url
189         self._file_permissions_mode = file_permissions_mode
190         self._directory_permissions_mode = directory_permissions_mode
191         setting_changed.connect(self._clear_cached_properties)
192 
193     def _clear_cached_properties(self, setting, **kwargs):
194         """Reset setting based property values."""
195         if setting == 'MEDIA_ROOT':
196             self.__dict__.pop('base_location', None)
197             self.__dict__.pop('location', None)
198         elif setting == 'MEDIA_URL':
199             self.__dict__.pop('base_url', None)
200         elif setting == 'FILE_UPLOAD_PERMISSIONS':
201             self.__dict__.pop('file_permissions_mode', None)
202         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':
203             self.__dict__.pop('directory_permissions_mode', None)
204 
205     def _value_or_setting(self, value, setting):
206         return setting if value is None else value
207 
208     @cached_property
209     def base_location(self):
210         return self._value_or_setting(self._location, settings.MEDIA_ROOT)
211 
212     @cached_property
213     def location(self):
214         return os.path.abspath(self.base_location)
215 
216     @cached_property
217     def base_url(self):
218         if self._base_url is not None and not self._base_url.endswith('/'):
219             self._base_url += '/'
220         return self._value_or_setting(self._base_url, settings.MEDIA_URL)
221 
222     @cached_property
223     def file_permissions_mode(self):
224         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)
225 
226     @cached_property
227     def directory_permissions_mode(self):
228         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)
229 
230     def _open(self, name, mode='rb'):
231         return File(open(self.path(name), mode))
232 
233     def _save(self, name, content):
234         full_path = self.path(name)
235 
236         # Create any intermediate directories that do not exist.
237         directory = os.path.dirname(full_path)
238         try:
239             if self.directory_permissions_mode is not None:
240                 # os.makedirs applies the global umask, so we reset it,
241                 # for consistency with file_permissions_mode behavior.
242                 old_umask = os.umask(0)
243                 try:
244                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)
245                 finally:
246                     os.umask(old_umask)
247             else:
248                 os.makedirs(directory, exist_ok=True)
249         except FileExistsError:
250             raise FileExistsError('%s exists and is not a directory.' % directory)
251 
252         # There's a potential race condition between get_available_name and
253         # saving the file; it's possible that two threads might return the
254         # same name, at which point all sorts of fun happens. So we need to
255         # try to create the file, but if it already exists we have to go back
256         # to get_available_name() and try again.
257 
258         while True:
259             try:
260                 # This file has a file path that we can move.
261                 if hasattr(content, 'temporary_file_path'):
262                     file_move_safe(content.temporary_file_path(), full_path)
263 
264                 # This is a normal uploadedfile that we can stream.
265                 else:
266                     # The current umask value is masked out by os.open!
267                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)
268                     _file = None
269                     try:
270                         locks.lock(fd, locks.LOCK_EX)
271                         for chunk in content.chunks():
272                             if _file is None:
273                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'
274                                 _file = os.fdopen(fd, mode)
275                             _file.write(chunk)
276                     finally:
277                         locks.unlock(fd)
278                         if _file is not None:
279                             _file.close()
280                         else:
281                             os.close(fd)
282             except FileExistsError:
283                 # A new name is needed if the file exists.
284                 name = self.get_available_name(name)
285                 full_path = self.path(name)
286             else:
287                 # OK, the file save worked. Break out of the loop.
288                 break
289 
290         if self.file_permissions_mode is not None:
291             os.chmod(full_path, self.file_permissions_mode)
292 
293         # Store filenames with forward slashes, even on Windows.
294         return str(name).replace('\\', '/')
295 
296     def delete(self, name):
297         assert name, "The name argument is not allowed to be empty."
298         name = self.path(name)
299         # If the file or directory exists, delete it from the filesystem.
300         try:
301             if os.path.isdir(name):
302                 os.rmdir(name)
303             else:
304                 os.remove(name)
305         except FileNotFoundError:
306             # FileNotFoundError is raised if the file or directory was removed
307             # concurrently.
308             pass
309 
310     def exists(self, name):
311         return os.path.exists(self.path(name))
312 
313     def listdir(self, path):
314         path = self.path(path)
315         directories, files = [], []
316         for entry in os.scandir(path):
317             if entry.is_dir():
318                 directories.append(entry.name)
319             else:
320                 files.append(entry.name)
321         return directories, files
322 
323     def path(self, name):
324         return safe_join(self.location, name)
325 
326     def size(self, name):
327         return os.path.getsize(self.path(name))
328 
329     def url(self, name):
330         if self.base_url is None:
331             raise ValueError("This file is not accessible via a URL.")
332         url = filepath_to_uri(name)
333         if url is not None:
334             url = url.lstrip('/')
335         return urljoin(self.base_url, url)
336 
337     def _datetime_from_timestamp(self, ts):
338         """
339         If timezone support is enabled, make an aware datetime object in UTC;
340         otherwise make a naive one in the local timezone.
341         """
342         if settings.USE_TZ:
343             # Safe to use .replace() because UTC doesn't have DST
344             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)
345         else:
346             return datetime.fromtimestamp(ts)
347 
348     def get_accessed_time(self, name):
349         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))
350 
351     def get_created_time(self, name):
352         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))
353 
354     def get_modified_time(self, name):
355         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))
356 
357 
358 def get_storage_class(import_path=None):
359     return import_string(import_path or settings.DEFAULT_FILE_STORAGE)
360 
361 
362 class DefaultStorage(LazyObject):
363     def _setup(self):
364         self._wrapped = get_storage_class()()
365 
366 
367 default_storage = DefaultStorage()

</code><intended_behavior>Provide an explicit `length` for file storage-related uses of `get_random_string`, which could involve generating random filenames or paths.</intended_behavior>, <file>django/core/management/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 import fnmatch
2 import os
3 from pathlib import Path
4 from subprocess import PIPE, run
5 
6 from django.apps import apps as installed_apps
7 from django.utils.crypto import get_random_string
8 from django.utils.encoding import DEFAULT_LOCALE_ENCODING
9 
10 from .base import CommandError, CommandParser
11 
12 
13 def popen_wrapper(args, stdout_encoding='utf-8'):
14     """
15     Friendly wrapper around Popen.
16 
17     Return stdout output, stderr output, and OS status code.
18     """
19     try:
20         p = run(args, stdout=PIPE, stderr=PIPE, close_fds=os.name != 'nt')
21     except OSError as err:
22         raise CommandError('Error executing %s' % args[0]) from err
23     return (
24         p.stdout.decode(stdout_encoding),
25         p.stderr.decode(DEFAULT_LOCALE_ENCODING, errors='replace'),
26         p.returncode
27     )
28 
29 
30 def handle_extensions(extensions):
31     """
32     Organize multiple extensions that are separated with commas or passed by
33     using --extension/-e multiple times.
34 
35     For example: running 'django-admin makemessages -e js,txt -e xhtml -a'
36     would result in an extension list: ['.js', '.txt', '.xhtml']
37 
38     >>> handle_extensions(['.html', 'html,js,py,py,py,.py', 'py,.py'])
39     {'.html', '.js', '.py'}
40     >>> handle_extensions(['.html, txt,.tpl'])
41     {'.html', '.tpl', '.txt'}
42     """
43     ext_list = []
44     for ext in extensions:
45         ext_list.extend(ext.replace(' ', '').split(','))
46     for i, ext in enumerate(ext_list):
47         if not ext.startswith('.'):
48             ext_list[i] = '.%s' % ext_list[i]
49     return set(ext_list)
50 
51 
52 def find_command(cmd, path=None, pathext=None):
53     if path is None:
54         path = os.environ.get('PATH', '').split(os.pathsep)
55     if isinstance(path, str):
56         path = [path]
57     # check if there are funny path extensions for executables, e.g. Windows
58     if pathext is None:
59         pathext = os.environ.get('PATHEXT', '.COM;.EXE;.BAT;.CMD').split(os.pathsep)
60     # don't use extensions if the command ends with one of them
61     for ext in pathext:
62         if cmd.endswith(ext):
63             pathext = ['']
64             break
65     # check if we find the command on PATH
66     for p in path:
67         f = os.path.join(p, cmd)
68         if os.path.isfile(f):
69             return f
70         for ext in pathext:
71             fext = f + ext
72             if os.path.isfile(fext):
73                 return fext
74     return None
75 
76 
77 def get_random_secret_key():
78     """
79     Return a 50 character random string usable as a SECRET_KEY setting value.
80     """
81     chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'
82     return get_random_string(50, chars)
83 
84 
85 def parse_apps_and_model_labels(labels):
86     """
87     Parse a list of "app_label.ModelName" or "app_label" strings into actual
88     objects and return a two-element tuple:
89         (set of model classes, set of app_configs).
90     Raise a CommandError if some specified models or apps don't exist.
91     """
92     apps = set()
93     models = set()
94 
95     for label in labels:
96         if '.' in label:
97             try:
98                 model = installed_apps.get_model(label)
99             except LookupError:
100                 raise CommandError('Unknown model: %s' % label)
101             models.add(model)
102         else:
103             try:
104                 app_config = installed_apps.get_app_config(label)
105             except LookupError as e:
106                 raise CommandError(str(e))
107             apps.add(app_config)
108 
109     return models, apps
110 
111 
112 def get_command_line_option(argv, option):
113     """
114     Return the value of a command line option (which should include leading
115     dashes, e.g. '--testrunner') from an argument list. Return None if the
116     option wasn't passed or if the argument list couldn't be parsed.
117     """
118     parser = CommandParser(add_help=False, allow_abbrev=False)
119     parser.add_argument(option, dest='value')
120     try:
121         options, _ = parser.parse_known_args(argv[2:])
122     except CommandError:
123         return None
124     else:
125         return options.value
126 
127 
128 def normalize_path_patterns(patterns):
129     """Normalize an iterable of glob style patterns based on OS."""
130     patterns = [os.path.normcase(p) for p in patterns]
131     dir_suffixes = {'%s*' % path_sep for path_sep in {'/', os.sep}}
132     norm_patterns = []
133     for pattern in patterns:
134         for dir_suffix in dir_suffixes:
135             if pattern.endswith(dir_suffix):
136                 norm_patterns.append(pattern[:-len(dir_suffix)])
137                 break
138         else:
139             norm_patterns.append(pattern)
140     return norm_patterns
141 
142 
143 def is_ignored_path(path, ignore_patterns):
144     """
145     Check if the given path should be ignored or not based on matching
146     one of the glob style `ignore_patterns`.
147     """
148     path = Path(path)
149 
150     def ignore(pattern):
151         return fnmatch.fnmatchcase(path.name, pattern) or fnmatch.fnmatchcase(str(path), pattern)
152 
153     return any(ignore(pattern) for pattern in normalize_path_patterns(ignore_patterns))

</code><intended_behavior>Specify an explicit length for any administrative or management tasks calling `get_random_string`, ensuring that any temporary files or identifiers are generated securely.</intended_behavior>]
2025-10-15 17:42:55.673 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 17:42:55.673 | INFO     | Search-only: skipping patch selection
2025-10-15 17:42:55.815 | INFO     | Task django__django-12556 completed successfully.
2025-10-15 17:42:55.816 | INFO     | No patch generated. You can try running ACR again.
