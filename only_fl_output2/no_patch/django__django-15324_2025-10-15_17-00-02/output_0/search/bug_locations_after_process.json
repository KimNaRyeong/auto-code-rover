[
    {
        "rel_file_path": "django/core/files/uploadedfile.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/files/uploadedfile.py",
        "start": 1,
        "end": 120,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Classes representing uploaded files.\n3 \"\"\"\n4 \n5 import os\n6 from io import BytesIO\n7 \n8 from django.conf import settings\n9 from django.core.files import temp as tempfile\n10 from django.core.files.base import File\n11 from django.core.files.utils import validate_file_name\n12 \n13 __all__ = ('UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile',\n14            'SimpleUploadedFile')\n15 \n16 \n17 class UploadedFile(File):\n18     \"\"\"\n19     An abstract uploaded file (``TemporaryUploadedFile`` and\n20     ``InMemoryUploadedFile`` are the built-in concrete subclasses).\n21 \n22     An ``UploadedFile`` object behaves somewhat like a file object and\n23     represents some file data that the user submitted with a form.\n24     \"\"\"\n25 \n26     def __init__(self, file=None, name=None, content_type=None, size=None, charset=None, content_type_extra=None):\n27         super().__init__(file, name)\n28         self.size = size\n29         self.content_type = content_type\n30         self.charset = charset\n31         self.content_type_extra = content_type_extra\n32 \n33     def __repr__(self):\n34         return \"<%s: %s (%s)>\" % (self.__class__.__name__, self.name, self.content_type)\n35 \n36     def _get_name(self):\n37         return self._name\n38 \n39     def _set_name(self, name):\n40         # Sanitize the file name so that it can't be dangerous.\n41         if name is not None:\n42             # Just use the basename of the file -- anything else is dangerous.\n43             name = os.path.basename(name)\n44 \n45             # File names longer than 255 characters can cause problems on older OSes.\n46             if len(name) > 255:\n47                 name, ext = os.path.splitext(name)\n48                 ext = ext[:255]\n49                 name = name[:255 - len(ext)] + ext\n50 \n51             name = validate_file_name(name)\n52 \n53         self._name = name\n54 \n55     name = property(_get_name, _set_name)\n56 \n57 \n58 class TemporaryUploadedFile(UploadedFile):\n59     \"\"\"\n60     A file uploaded to a temporary location (i.e. stream-to-disk).\n61     \"\"\"\n62     def __init__(self, name, content_type, size, charset, content_type_extra=None):\n63         _, ext = os.path.splitext(name)\n64         file = tempfile.NamedTemporaryFile(suffix='.upload' + ext, dir=settings.FILE_UPLOAD_TEMP_DIR)\n65         super().__init__(file, name, content_type, size, charset, content_type_extra)\n66 \n67     def temporary_file_path(self):\n68         \"\"\"Return the full path of this file.\"\"\"\n69         return self.file.name\n70 \n71     def close(self):\n72         try:\n73             return self.file.close()\n74         except FileNotFoundError:\n75             # The file was moved or deleted before the tempfile could unlink\n76             # it. Still sets self.file.close_called and calls\n77             # self.file.file.close() before the exception.\n78             pass\n79 \n80 \n81 class InMemoryUploadedFile(UploadedFile):\n82     \"\"\"\n83     A file uploaded into memory (i.e. stream-to-memory).\n84     \"\"\"\n85     def __init__(self, file, field_name, name, content_type, size, charset, content_type_extra=None):\n86         super().__init__(file, name, content_type, size, charset, content_type_extra)\n87         self.field_name = field_name\n88 \n89     def open(self, mode=None):\n90         self.file.seek(0)\n91         return self\n92 \n93     def chunks(self, chunk_size=None):\n94         self.file.seek(0)\n95         yield self.read()\n96 \n97     def multiple_chunks(self, chunk_size=None):\n98         # Since it's in memory, we'll never have multiple chunks.\n99         return False\n100 \n101 \n102 class SimpleUploadedFile(InMemoryUploadedFile):\n103     \"\"\"\n104     A simple representation of a file, which just has content, size, and a name.\n105     \"\"\"\n106     def __init__(self, name, content, content_type='text/plain'):\n107         content = content or b''\n108         super().__init__(BytesIO(content), None, name, content_type, len(content), None, None)\n109 \n110     @classmethod\n111     def from_dict(cls, file_dict):\n112         \"\"\"\n113         Create a SimpleUploadedFile object from a dictionary with keys:\n114            - filename\n115            - content-type\n116            - content\n117         \"\"\"\n118         return cls(file_dict['filename'],\n119                    file_dict['content'],\n120                    file_dict.get('content-type', 'text/plain'))\n",
        "intended_behavior": "The code should sanitize the extracted file extension to ensure no null bytes are present before using it to create a temporary file. The functionality for handling file uploads should remain unaffected while gracefully handling or rejecting filenames with null bytes without leading to a server error."
    },
    {
        "rel_file_path": "django/core/files/temp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/core/files/temp.py",
        "start": 1,
        "end": 74,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 The temp module provides a NamedTemporaryFile that can be reopened in the same\n3 process on any platform. Most platforms use the standard Python\n4 tempfile.NamedTemporaryFile class, but Windows users are given a custom class.\n5 \n6 This is needed because the Python implementation of NamedTemporaryFile uses the\n7 O_TEMPORARY flag under Windows, which prevents the file from being reopened\n8 if the same flag is not provided [1][2]. Note that this does not address the\n9 more general issue of opening a file for writing and reading in multiple\n10 processes in a manner that works across platforms.\n11 \n12 The custom version of NamedTemporaryFile doesn't support the same keyword\n13 arguments available in tempfile.NamedTemporaryFile.\n14 \n15 1: https://mail.python.org/pipermail/python-list/2005-December/336957.html\n16 2: https://bugs.python.org/issue14243\n17 \"\"\"\n18 \n19 import os\n20 import tempfile\n21 \n22 from django.core.files.utils import FileProxyMixin\n23 \n24 __all__ = ('NamedTemporaryFile', 'gettempdir',)\n25 \n26 \n27 if os.name == 'nt':\n28     class TemporaryFile(FileProxyMixin):\n29         \"\"\"\n30         Temporary file object constructor that supports reopening of the\n31         temporary file in Windows.\n32 \n33         Unlike tempfile.NamedTemporaryFile from the standard library,\n34         __init__() doesn't support the 'delete', 'buffering', 'encoding', or\n35         'newline' keyword arguments.\n36         \"\"\"\n37         def __init__(self, mode='w+b', bufsize=-1, suffix='', prefix='', dir=None):\n38             fd, name = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)\n39             self.name = name\n40             self.file = os.fdopen(fd, mode, bufsize)\n41             self.close_called = False\n42 \n43         # Because close can be called during shutdown\n44         # we need to cache os.unlink and access it\n45         # as self.unlink only\n46         unlink = os.unlink\n47 \n48         def close(self):\n49             if not self.close_called:\n50                 self.close_called = True\n51                 try:\n52                     self.file.close()\n53                 except OSError:\n54                     pass\n55                 try:\n56                     self.unlink(self.name)\n57                 except OSError:\n58                     pass\n59 \n60         def __del__(self):\n61             self.close()\n62 \n63         def __enter__(self):\n64             self.file.__enter__()\n65             return self\n66 \n67         def __exit__(self, exc, value, tb):\n68             self.file.__exit__(exc, value, tb)\n69 \n70     NamedTemporaryFile = TemporaryFile\n71 else:\n72     NamedTemporaryFile = tempfile.NamedTemporaryFile\n73 \n74 gettempdir = tempfile.gettempdir\n",
        "intended_behavior": "The code should ensure that any temporary file creation logic considers the possibility of null bytes in file extensions, sanitizing such inputs or providing a consistent error handling mechanism that prevents crashes. This might involve adding validation checks or sanitization steps within methods responsible for generating temporary files from uploaded file data."
    }
]