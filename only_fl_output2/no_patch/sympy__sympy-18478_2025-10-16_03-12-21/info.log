2025-10-16 03:12:21.683 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 03:12:30.548 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=129, output_tokens=12, cost=0.001650
2025-10-16 03:12:44.429 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=309, output_tokens=568, cost=0.020130
2025-10-16 03:12:46.220 | INFO     | registered non reproducing test 0
2025-10-16 03:13:02.280 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1147, output_tokens=653, cost=0.031060
2025-10-16 03:13:03.493 | INFO     | registered non reproducing test 1
2025-10-16 03:13:16.202 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1232, output_tokens=558, cost=0.029060
2025-10-16 03:13:17.421 | INFO     | registered non reproducing test 2
2025-10-16 03:13:17.421 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 03:13:17.427 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:13:28.926 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=438, output_tokens=494, cost=0.019200
2025-10-16 03:13:28.938 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:13:32.039 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=848, output_tokens=58, cost=0.010220
2025-10-16 03:13:32.040 | DEBUG    | Extracted a valid json.
2025-10-16 03:13:32.040 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"subs\")",
        "search_class(\"exp\")",
        "search_class(\"cos\")",
        "search_code(\"AccumBounds\")",
        "search_code(\"oo\")"
    ],
    "bug_locations": []
}
2025-10-16 03:14:04.273 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 03:14:04.274 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 03:14:24.108 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12206, output_tokens=721, cost=0.143690
2025-10-16 03:14:24.115 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 03:14:38.496 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=13143, output_tokens=560, cost=0.148230
2025-10-16 03:14:38.502 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 03:14:50.151 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=914, output_tokens=421, cost=0.021770
2025-10-16 03:14:50.152 | DEBUG    | Extracted a valid json.
2025-10-16 03:14:50.152 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/basic.py",
            "class": "",
            "method": ".subs()",
            "intended_behavior": "The method should correctly evaluate or substitute expressions involving infinity, such as `(x + cos(x)).subs(x, oo)` and `(exp(x) + cos(x)).subs(x, oo)`. The intended behavior here is to ensure consistency in how expressions involving infinity are simplified or evaluated, possibly by refining how mathematical functions like `exp` and `cos` handle substitutions involving `oo`. This might involve checking if additional conditions or special handling for infinite substitutions need to be integrated into the `.subs()` method to accommodate the mathematical properties of these functions consistently."
        },
        {
            "file": "sympy/functions/elementary/exponential.py",
            "class": "exp",
            "method": "",
            "intended_behavior": "Ensure that the `exp` function's behavior when its variable tends towards infinity is consistent with mathematical principles and compatible with how the `.subs()` method processes such cases. Specifically, when `exp(x)` is evaluated at `x = oo`, the result should reflect the expected mathematical outcome (i.e., `oo`), and this evaluation should be handled in a manner consistent with the behavior observed in other similar expressions."
        },
        {
            "file": "sympy/functions/elementary/trigonometric.py",
            "class": "cos",
            "method": "",
            "intended_behavior": "For `cos(x)` where `x` is substituted with `oo`, it's not about altering the `cos` function's inherent behavior at infinity but ensuring that its handling within expressions substituted at infinity is consistent. Since `cos(x)` doesn't have a limit as `x` approaches infinity, the substitution might either need to prevent simplistic numerical evaluations or work cohesively with constructs like `AccumBounds` to present a result that accurately represents the function's behavior at infinity."
        }
    ]
}
2025-10-16 03:14:50.155 | WARNING  | Successfully split  and subs()
2025-10-16 03:14:50.159 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/basic.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Base class for all the objects in SymPy"""
2 from __future__ import print_function, division
3 from collections import defaultdict
4 from itertools import chain, zip_longest
5 
6 from .assumptions import BasicMeta, ManagedProperties
7 from .cache import cacheit
8 from .sympify import _sympify, sympify, SympifyError
9 from .compatibility import iterable, Iterator, ordered, Mapping
10 from .singleton import S
11 
12 from inspect import getmro
13 
14 
15 def as_Basic(expr):
16     """Return expr as a Basic instance using strict sympify
17     or raise a TypeError; this is just a wrapper to _sympify,
18     raising a TypeError instead of a SympifyError."""
19     from sympy.utilities.misc import func_name
20     try:
21         return _sympify(expr)
22     except SympifyError:
23         raise TypeError(
24             'Argument must be a Basic object, not `%s`' % func_name(
25             expr))
26 
27 
28 class Basic(metaclass=ManagedProperties):
29     """
30     Base class for all objects in SymPy.
31 
32     Conventions:
33 
34     1) Always use ``.args``, when accessing parameters of some instance:
35 
36     >>> from sympy import cot
37     >>> from sympy.abc import x, y
38 
39     >>> cot(x).args
40     (x,)
41 
42     >>> cot(x).args[0]
43     x
44 
45     >>> (x*y).args
46     (x, y)
47 
48     >>> (x*y).args[1]
49     y
50 
51 
52     2) Never use internal methods or variables (the ones prefixed with ``_``):
53 
54     >>> cot(x)._args    # do not use this, use cot(x).args instead
55     (x,)
56 
57     """
58     __slots__ = ('_mhash',              # hash value
59                  '_args',               # arguments
60                  '_assumptions'
61                 )
62 
63     # To be overridden with True in the appropriate subclasses
64     is_number = False
65     is_Atom = False
66     is_Symbol = False
67     is_symbol = False
68     is_Indexed = False
69     is_Dummy = False
70     is_Wild = False
71     is_Function = False
72     is_Add = False
73     is_Mul = False
74     is_Pow = False
75     is_Number = False
76     is_Float = False
77     is_Rational = False
78     is_Integer = False
79     is_NumberSymbol = False
80     is_Order = False
81     is_Derivative = False
82     is_Piecewise = False
83     is_Poly = False
84     is_AlgebraicNumber = False
85     is_Relational = False
86     is_Equality = False
87     is_Boolean = False
88     is_Not = False
89     is_Matrix = False
90     is_Vector = False
91     is_Point = False
92     is_MatAdd = False
93     is_MatMul = False
94 
95     def __new__(cls, *args):
96         obj = object.__new__(cls)
97         obj._assumptions = cls.default_assumptions
98         obj._mhash = None  # will be set by __hash__ method.
99 
100         obj._args = args  # all items in args must be Basic objects
101         return obj
102 
103     def copy(self):
104         return self.func(*self.args)
105 
106     def __reduce_ex__(self, proto):
107         """ Pickling support."""
108         return type(self), self.__getnewargs__(), self.__getstate__()
109 
110     def __getnewargs__(self):
111         return self.args
112 
113     def __getstate__(self):
114         return {}
115 
116     def __setstate__(self, state):
117         for k, v in state.items():
118             setattr(self, k, v)
119 
120     def __hash__(self):
121         # hash cannot be cached using cache_it because infinite recurrence
122         # occurs as hash is needed for setting cache dictionary keys
123         h = self._mhash
124         if h is None:
125             h = hash((type(self).__name__,) + self._hashable_content())
126             self._mhash = h
127         return h
128 
129     def _hashable_content(self):
130         """Return a tuple of information about self that can be used to
131         compute the hash. If a class defines additional attributes,
132         like ``name`` in Symbol, then this method should be updated
133         accordingly to return such relevant attributes.
134 
135         Defining more than _hashable_content is necessary if __eq__ has
136         been defined by a class. See note about this in Basic.__eq__."""
137         return self._args
138 
139     @property
140     def assumptions0(self):
141         """
142         Return object `type` assumptions.
143 
144         For example:
145 
146           Symbol('x', real=True)
147           Symbol('x', integer=True)
148 
149         are different objects. In other words, besides Python type (Symbol in
150         this case), the initial assumptions are also forming their typeinfo.
151 
152         Examples
153         ========
154 
155         >>> from sympy import Symbol
156         >>> from sympy.abc import x
157         >>> x.assumptions0
158         {'commutative': True}
159         >>> x = Symbol("x", positive=True)
160         >>> x.assumptions0
161         {'commutative': True, 'complex': True, 'extended_negative': False,
162          'extended_nonnegative': True, 'extended_nonpositive': False,
163          'extended_nonzero': True, 'extended_positive': True, 'extended_real':
164          True, 'finite': True, 'hermitian': True, 'imaginary': False,
165          'infinite': False, 'negative': False, 'nonnegative': True,
166          'nonpositive': False, 'nonzero': True, 'positive': True, 'real':
167          True, 'zero': False}
168         """
169         return {}
170 
171     def compare(self, other):
172         """
173         Return -1, 0, 1 if the object is smaller, equal, or greater than other.
174 
175         Not in the mathematical sense. If the object is of a different type
176         from the "other" then their classes are ordered according to
177         the sorted_classes list.
178 
179         Examples
180         ========
181 
182         >>> from sympy.abc import x, y
183         >>> x.compare(y)
184         -1
185         >>> x.compare(x)
186         0
187         >>> y.compare(x)
188         1
189 
190         """
191         # all redefinitions of __cmp__ method should start with the
192         # following lines:
193         if self is other:
194             return 0
195         n1 = self.__class__
196         n2 = other.__class__
197         c = (n1 > n2) - (n1 < n2)
198         if c:
199             return c
200         #
201         st = self._hashable_content()
202         ot = other._hashable_content()
203         c = (len(st) > len(ot)) - (len(st) < len(ot))
204         if c:
205             return c
206         for l, r in zip(st, ot):
207             l = Basic(*l) if isinstance(l, frozenset) else l
208             r = Basic(*r) if isinstance(r, frozenset) else r
209             if isinstance(l, Basic):
210                 c = l.compare(r)
211             else:
212                 c = (l > r) - (l < r)
213             if c:
214                 return c
215         return 0
216 
217     @staticmethod
218     def _compare_pretty(a, b):
219         from sympy.series.order import Order
220         if isinstance(a, Order) and not isinstance(b, Order):
221             return 1
222         if not isinstance(a, Order) and isinstance(b, Order):
223             return -1
224 
225         if a.is_Rational and b.is_Rational:
226             l = a.p * b.q
227             r = b.p * a.q
228             return (l > r) - (l < r)
229         else:
230             from sympy.core.symbol import Wild
231             p1, p2, p3 = Wild("p1"), Wild("p2"), Wild("p3")
232             r_a = a.match(p1 * p2**p3)
233             if r_a and p3 in r_a:
234                 a3 = r_a[p3]
235                 r_b = b.match(p1 * p2**p3)
236                 if r_b and p3 in r_b:
237                     b3 = r_b[p3]
238                     c = Basic.compare(a3, b3)
239                     if c != 0:
240                         return c
241 
242         return Basic.compare(a, b)
243 
244     @classmethod
245     def fromiter(cls, args, **assumptions):
246         """
247         Create a new object from an iterable.
248 
249         This is a convenience function that allows one to create objects from
250         any iterable, without having to convert to a list or tuple first.
251 
252         Examples
253         ========
254 
255         >>> from sympy import Tuple
256         >>> Tuple.fromiter(i for i in range(5))
257         (0, 1, 2, 3, 4)
258 
259         """
260         return cls(*tuple(args), **assumptions)
261 
262     @classmethod
263     def class_key(cls):
264         """Nice order of classes. """
265         return 5, 0, cls.__name__
266 
267     @cacheit
268     def sort_key(self, order=None):
269         """
270         Return a sort key.
271 
272         Examples
273         ========
274 
275         >>> from sympy.core import S, I
276 
277         >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
278         [1/2, -I, I]
279 
280         >>> S("[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]")
281         [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]
282         >>> sorted(_, key=lambda x: x.sort_key())
283         [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]
284 
285         """
286 
287         # XXX: remove this when issue 5169 is fixed
288         def inner_key(arg):
289             if isinstance(arg, Basic):
290                 return arg.sort_key(order)
291             else:
292                 return arg
293 
294         args = self._sorted_args
295         args = len(args), tuple([inner_key(arg) for arg in args])
296         return self.class_key(), args, S.One.sort_key(), S.One
297 
298     def __eq__(self, other):
299         """Return a boolean indicating whether a == b on the basis of
300         their symbolic trees.
301 
302         This is the same as a.compare(b) == 0 but faster.
303 
304         Notes
305         =====
306 
307         If a class that overrides __eq__() needs to retain the
308         implementation of __hash__() from a parent class, the
309         interpreter must be told this explicitly by setting __hash__ =
310         <ParentClass>.__hash__. Otherwise the inheritance of __hash__()
311         will be blocked, just as if __hash__ had been explicitly set to
312         None.
313 
314         References
315         ==========
316 
317         from http://docs.python.org/dev/reference/datamodel.html#object.__hash__
318         """
319         if self is other:
320             return True
321 
322         tself = type(self)
323         tother = type(other)
324         if tself is not tother:
325             try:
326                 other = _sympify(other)
327                 tother = type(other)
328             except SympifyError:
329                 return NotImplemented
330 
331             # As long as we have the ordering of classes (sympy.core),
332             # comparing types will be slow in Python 2, because it uses
333             # __cmp__. Until we can remove it
334             # (https://github.com/sympy/sympy/issues/4269), we only compare
335             # types in Python 2 directly if they actually have __ne__.
336             if type(tself).__ne__ is not type.__ne__:
337                 if tself != tother:
338                     return False
339             elif tself is not tother:
340                 return False
341 
342         return self._hashable_content() == other._hashable_content()
343 
344     def __ne__(self, other):
345         """``a != b``  -> Compare two symbolic trees and see whether they are different
346 
347         this is the same as:
348 
349         ``a.compare(b) != 0``
350 
351         but faster
352         """
353         return not self == other
354 
355     def dummy_eq(self, other, symbol=None):
356         """
357         Compare two expressions and handle dummy symbols.
358 
359         Examples
360         ========
361 
362         >>> from sympy import Dummy
363         >>> from sympy.abc import x, y
364 
365         >>> u = Dummy('u')
366 
367         >>> (u**2 + 1).dummy_eq(x**2 + 1)
368         True
369         >>> (u**2 + 1) == (x**2 + 1)
370         False
371 
372         >>> (u**2 + y).dummy_eq(x**2 + y, x)
373         True
374         >>> (u**2 + y).dummy_eq(x**2 + y, y)
375         False
376 
377         """
378         s = self.as_dummy()
379         o = _sympify(other)
380         o = o.as_dummy()
381 
382         dummy_symbols = [i for i in s.free_symbols if i.is_Dummy]
383 
384         if len(dummy_symbols) == 1:
385             dummy = dummy_symbols.pop()
386         else:
387             return s == o
388 
389         if symbol is None:
390             symbols = o.free_symbols
391 
392             if len(symbols) == 1:
393                 symbol = symbols.pop()
394             else:
395                 return s == o
396 
397         tmp = dummy.__class__()
398 
399         return s.subs(dummy, tmp) == o.subs(symbol, tmp)
400 
401     # Note, we always use the default ordering (lex) in __str__ and __repr__,
402     # regardless of the global setting.  See issue 5487.
403     def __repr__(self):
404         """Method to return the string representation.
405 
406         Return the expression as a string.
407         """
408         from sympy.printing import sstr
409         return sstr(self, order=None)
410 
411     def __str__(self):
412         from sympy.printing import sstr
413         return sstr(self, order=None)
414 
415     # We don't define _repr_png_ here because it would add a large amount of
416     # data to any notebook containing SymPy expressions, without adding
417     # anything useful to the notebook. It can still enabled manually, e.g.,
418     # for the qtconsole, with init_printing().
419     def _repr_latex_(self):
420         """
421         IPython/Jupyter LaTeX printing
422 
423         To change the behavior of this (e.g., pass in some settings to LaTeX),
424         use init_printing(). init_printing() will also enable LaTeX printing
425         for built in numeric types like ints and container types that contain
426         SymPy objects, like lists and dictionaries of expressions.
427         """
428         from sympy.printing.latex import latex
429         s = latex(self, mode='plain')
430         return "$\\displaystyle %s$" % s
431 
432     _repr_latex_orig = _repr_latex_
433 
434     def atoms(self, *types):
435         """Returns the atoms that form the current object.
436 
437         By default, only objects that are truly atomic and can't
438         be divided into smaller pieces are returned: symbols, numbers,
439         and number symbols like I and pi. It is possible to request
440         atoms of any type, however, as demonstrated below.
441 
442         Examples
443         ========
444 
445         >>> from sympy import I, pi, sin
446         >>> from sympy.abc import x, y
447         >>> (1 + x + 2*sin(y + I*pi)).atoms()
448         {1, 2, I, pi, x, y}
449 
450         If one or more types are given, the results will contain only
451         those types of atoms.
452 
453         >>> from sympy import Number, NumberSymbol, Symbol
454         >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)
455         {x, y}
456 
457         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)
458         {1, 2}
459 
460         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)
461         {1, 2, pi}
462 
463         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)
464         {1, 2, I, pi}
465 
466         Note that I (imaginary unit) and zoo (complex infinity) are special
467         types of number symbols and are not part of the NumberSymbol class.
468 
469         The type can be given implicitly, too:
470 
471         >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol
472         {x, y}
473 
474         Be careful to check your assumptions when using the implicit option
475         since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type
476         of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all
477         integers in an expression:
478 
479         >>> from sympy import S
480         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))
481         {1}
482 
483         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))
484         {1, 2}
485 
486         Finally, arguments to atoms() can select more than atomic atoms: any
487         sympy type (loaded in core/__init__.py) can be listed as an argument
488         and those types of "atoms" as found in scanning the arguments of the
489         expression recursively:
490 
491         >>> from sympy import Function, Mul
492         >>> from sympy.core.function import AppliedUndef
493         >>> f = Function('f')
494         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)
495         {f(x), sin(y + I*pi)}
496         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)
497         {f(x)}
498 
499         >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)
500         {I*pi, 2*sin(y + I*pi)}
501 
502         """
503         if types:
504             types = tuple(
505                 [t if isinstance(t, type) else type(t) for t in types])
506         else:
507             types = (Atom,)
508         result = set()
509         for expr in preorder_traversal(self):
510             if isinstance(expr, types):
511                 result.add(expr)
512         return result
513 
514     @property
515     def free_symbols(self):
516         """Return from the atoms of self those which are free symbols.
517 
518         For most expressions, all symbols are free symbols. For some classes
519         this is not true. e.g. Integrals use Symbols for the dummy variables
520         which are bound variables, so Integral has a method to return all
521         symbols except those. Derivative keeps track of symbols with respect
522         to which it will perform a derivative; those are
523         bound variables, too, so it has its own free_symbols method.
524 
525         Any other method that uses bound variables should implement a
526         free_symbols method."""
527         return set().union(*[a.free_symbols for a in self.args])
528 
529     @property
530     def expr_free_symbols(self):
531         return set([])
532 
533     def as_dummy(self):
534         """Return the expression with any objects having structurally
535         bound symbols replaced with unique, canonical symbols within
536         the object in which they appear and having only the default
537         assumption for commutativity being True.
538 
539         Examples
540         ========
541 
542         >>> from sympy import Integral, Symbol
543         >>> from sympy.abc import x, y
544         >>> r = Symbol('r', real=True)
545         >>> Integral(r, (r, x)).as_dummy()
546         Integral(_0, (_0, x))
547         >>> _.variables[0].is_real is None
548         True
549 
550         Notes
551         =====
552 
553         Any object that has structural dummy variables should have
554         a property, `bound_symbols` that returns a list of structural
555         dummy symbols of the object itself.
556 
557         Lambda and Subs have bound symbols, but because of how they
558         are cached, they already compare the same regardless of their
559         bound symbols:
560 
561         >>> from sympy import Lambda
562         >>> Lambda(x, x + 1) == Lambda(y, y + 1)
563         True
564         """
565         def can(x):
566             d = {i: i.as_dummy() for i in x.bound_symbols}
567             # mask free that shadow bound
568             x = x.subs(d)
569             c = x.canonical_variables
570             # replace bound
571             x = x.xreplace(c)
572             # undo masking
573             x = x.xreplace(dict((v, k) for k, v in d.items()))
574             return x
575         return self.replace(
576             lambda x: hasattr(x, 'bound_symbols'),
577             lambda x: can(x))
578 
579     @property
580     def canonical_variables(self):
581         """Return a dictionary mapping any variable defined in
582         ``self.bound_symbols`` to Symbols that do not clash
583         with any existing symbol in the expression.
584 
585         Examples
586         ========
587 
588         >>> from sympy import Lambda
589         >>> from sympy.abc import x
590         >>> Lambda(x, 2*x).canonical_variables
591         {x: _0}
592         """
593         from sympy.core.symbol import Symbol
594         from sympy.utilities.iterables import numbered_symbols
595         if not hasattr(self, 'bound_symbols'):
596             return {}
597         dums = numbered_symbols('_')
598         reps = {}
599         v = self.bound_symbols
600         # this free will include bound symbols that are not part of
601         # self's bound symbols
602         free = set([i.name for i in self.atoms(Symbol) - set(v)])
603         for v in v:
604             d = next(dums)
605             if v.is_Symbol:
606                 while v.name == d.name or d.name in free:
607                     d = next(dums)
608             reps[v] = d
609         return reps
610 
611     def rcall(self, *args):
612         """Apply on the argument recursively through the expression tree.
613 
614         This method is used to simulate a common abuse of notation for
615         operators. For instance in SymPy the the following will not work:
616 
617         ``(x+Lambda(y, 2*y))(z) == x+2*z``,
618 
619         however you can use
620 
621         >>> from sympy import Lambda
622         >>> from sympy.abc import x, y, z
623         >>> (x + Lambda(y, 2*y)).rcall(z)
624         x + 2*z
625         """
626         return Basic._recursive_call(self, args)
627 
628     @staticmethod
629     def _recursive_call(expr_to_call, on_args):
630         """Helper for rcall method."""
631         from sympy import Symbol
632         def the_call_method_is_overridden(expr):
633             for cls in getmro(type(expr)):
634                 if '__call__' in cls.__dict__:
635                     return cls != Basic
636 
637         if callable(expr_to_call) and the_call_method_is_overridden(expr_to_call):
638             if isinstance(expr_to_call, Symbol):  # XXX When you call a Symbol it is
639                 return expr_to_call               # transformed into an UndefFunction
640             else:
641                 return expr_to_call(*on_args)
642         elif expr_to_call.args:
643             args = [Basic._recursive_call(
644                 sub, on_args) for sub in expr_to_call.args]
645             return type(expr_to_call)(*args)
646         else:
647             return expr_to_call
648 
649     def is_hypergeometric(self, k):
650         from sympy.simplify import hypersimp
651         return hypersimp(self, k) is not None
652 
653     @property
654     def is_comparable(self):
655         """Return True if self can be computed to a real number
656         (or already is a real number) with precision, else False.
657 
658         Examples
659         ========
660 
661         >>> from sympy import exp_polar, pi, I
662         >>> (I*exp_polar(I*pi/2)).is_comparable
663         True
664         >>> (I*exp_polar(I*pi*2)).is_comparable
665         False
666 
667         A False result does not mean that `self` cannot be rewritten
668         into a form that would be comparable. For example, the
669         difference computed below is zero but without simplification
670         it does not evaluate to a zero with precision:
671 
672         >>> e = 2**pi*(1 + 2**pi)
673         >>> dif = e - e.expand()
674         >>> dif.is_comparable
675         False
676         >>> dif.n(2)._prec
677         1
678 
679         """
680         is_extended_real = self.is_extended_real
681         if is_extended_real is False:
682             return False
683         if not self.is_number:
684             return False
685         # don't re-eval numbers that are already evaluated since
686         # this will create spurious precision
687         n, i = [p.evalf(2) if not p.is_Number else p
688             for p in self.as_real_imag()]
689         if not (i.is_Number and n.is_Number):
690             return False
691         if i:
692             # if _prec = 1 we can't decide and if not,
693             # the answer is False because numbers with
694             # imaginary parts can't be compared
695             # so return False
696             return False
697         else:
698             return n._prec != 1
699 
700     @property
701     def func(self):
702         """
703         The top-level function in an expression.
704 
705         The following should hold for all objects::
706 
707             >> x == x.func(*x.args)
708 
709         Examples
710         ========
711 
712         >>> from sympy.abc import x
713         >>> a = 2*x
714         >>> a.func
715         <class 'sympy.core.mul.Mul'>
716         >>> a.args
717         (2, x)
718         >>> a.func(*a.args)
719         2*x
720         >>> a == a.func(*a.args)
721         True
722 
723         """
724         return self.__class__
725 
726     @property
727     def args(self):
728         """Returns a tuple of arguments of 'self'.
729 
730         Examples
731         ========
732 
733         >>> from sympy import cot
734         >>> from sympy.abc import x, y
735 
736         >>> cot(x).args
737         (x,)
738 
739         >>> cot(x).args[0]
740         x
741 
742         >>> (x*y).args
743         (x, y)
744 
745         >>> (x*y).args[1]
746         y
747 
748         Notes
749         =====
750 
751         Never use self._args, always use self.args.
752         Only use _args in __new__ when creating a new function.
753         Don't override .args() from Basic (so that it's easy to
754         change the interface in the future if needed).
755         """
756         return self._args
757 
758     @property
759     def _sorted_args(self):
760         """
761         The same as ``args``.  Derived classes which don't fix an
762         order on their arguments should override this method to
763         produce the sorted representation.
764         """
765         return self.args
766 
767     def as_content_primitive(self, radical=False, clear=True):
768         """A stub to allow Basic args (like Tuple) to be skipped when computing
769         the content and primitive components of an expression.
770 
771         See Also
772         ========
773 
774         sympy.core.expr.Expr.as_content_primitive
775         """
776         return S.One, self
777 
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv
976 
977     @cacheit
978     def _subs(self, old, new, **hints):
979         """Substitutes an expression old -> new.
980 
981         If self is not equal to old then _eval_subs is called.
982         If _eval_subs doesn't want to make any special replacement
983         then a None is received which indicates that the fallback
984         should be applied wherein a search for replacements is made
985         amongst the arguments of self.
986 
987         >>> from sympy import Add
988         >>> from sympy.abc import x, y, z
989 
990         Examples
991         ========
992 
993         Add's _eval_subs knows how to target x + y in the following
994         so it makes the change:
995 
996         >>> (x + y + z).subs(x + y, 1)
997         z + 1
998 
999         Add's _eval_subs doesn't need to know how to find x + y in
1000         the following:
1001 
1002         >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None
1003         True
1004 
1005         The returned None will cause the fallback routine to traverse the args and
1006         pass the z*(x + y) arg to Mul where the change will take place and the
1007         substitution will succeed:
1008 
1009         >>> (z*(x + y) + 3).subs(x + y, 1)
1010         z + 3
1011 
1012         ** Developers Notes **
1013 
1014         An _eval_subs routine for a class should be written if:
1015 
1016             1) any arguments are not instances of Basic (e.g. bool, tuple);
1017 
1018             2) some arguments should not be targeted (as in integration
1019                variables);
1020 
1021             3) if there is something other than a literal replacement
1022                that should be attempted (as in Piecewise where the condition
1023                may be updated without doing a replacement).
1024 
1025         If it is overridden, here are some special cases that might arise:
1026 
1027             1) If it turns out that no special change was made and all
1028                the original sub-arguments should be checked for
1029                replacements then None should be returned.
1030 
1031             2) If it is necessary to do substitutions on a portion of
1032                the expression then _subs should be called. _subs will
1033                handle the case of any sub-expression being equal to old
1034                (which usually would not be the case) while its fallback
1035                will handle the recursion into the sub-arguments. For
1036                example, after Add's _eval_subs removes some matching terms
1037                it must process the remaining terms so it calls _subs
1038                on each of the un-matched terms and then adds them
1039                onto the terms previously obtained.
1040 
1041            3) If the initial expression should remain unchanged then
1042               the original expression should be returned. (Whenever an
1043               expression is returned, modified or not, no further
1044               substitution of old -> new is attempted.) Sum's _eval_subs
1045               routine uses this strategy when a substitution is attempted
1046               on any of its summation variables.
1047         """
1048 
1049         def fallback(self, old, new):
1050             """
1051             Try to replace old with new in any of self's arguments.
1052             """
1053             hit = False
1054             args = list(self.args)
1055             for i, arg in enumerate(args):
1056                 if not hasattr(arg, '_eval_subs'):
1057                     continue
1058                 arg = arg._subs(old, new, **hints)
1059                 if not _aresame(arg, args[i]):
1060                     hit = True
1061                     args[i] = arg
1062             if hit:
1063                 rv = self.func(*args)
1064                 hack2 = hints.get('hack2', False)
1065                 if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack
1066                     coeff = S.One
1067                     nonnumber = []
1068                     for i in args:
1069                         if i.is_Number:
1070                             coeff *= i
1071                         else:
1072                             nonnumber.append(i)
1073                     nonnumber = self.func(*nonnumber)
1074                     if coeff is S.One:
1075                         return nonnumber
1076                     else:
1077                         return self.func(coeff, nonnumber, evaluate=False)
1078                 return rv
1079             return self
1080 
1081         if _aresame(self, old):
1082             return new
1083 
1084         rv = self._eval_subs(old, new)
1085         if rv is None:
1086             rv = fallback(self, old, new)
1087         return rv
1088 
1089     def _eval_subs(self, old, new):
1090         """Override this stub if you want to do anything more than
1091         attempt a replacement of old with new in the arguments of self.
1092 
1093         See also
1094         ========
1095 
1096         _subs
1097         """
1098         return None
1099 
1100     def xreplace(self, rule):
1101         """
1102         Replace occurrences of objects within the expression.
1103 
1104         Parameters
1105         ==========
1106 
1107         rule : dict-like
1108             Expresses a replacement rule
1109 
1110         Returns
1111         =======
1112 
1113         xreplace : the result of the replacement
1114 
1115         Examples
1116         ========
1117 
1118         >>> from sympy import symbols, pi, exp
1119         >>> x, y, z = symbols('x y z')
1120         >>> (1 + x*y).xreplace({x: pi})
1121         pi*y + 1
1122         >>> (1 + x*y).xreplace({x: pi, y: 2})
1123         1 + 2*pi
1124 
1125         Replacements occur only if an entire node in the expression tree is
1126         matched:
1127 
1128         >>> (x*y + z).xreplace({x*y: pi})
1129         z + pi
1130         >>> (x*y*z).xreplace({x*y: pi})
1131         x*y*z
1132         >>> (2*x).xreplace({2*x: y, x: z})
1133         y
1134         >>> (2*2*x).xreplace({2*x: y, x: z})
1135         4*z
1136         >>> (x + y + 2).xreplace({x + y: 2})
1137         x + y + 2
1138         >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})
1139         x + exp(y) + 2
1140 
1141         xreplace doesn't differentiate between free and bound symbols. In the
1142         following, subs(x, y) would not change x since it is a bound symbol,
1143         but xreplace does:
1144 
1145         >>> from sympy import Integral
1146         >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})
1147         Integral(y, (y, 1, 2*y))
1148 
1149         Trying to replace x with an expression raises an error:
1150 
1151         >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP
1152         ValueError: Invalid limits given: ((2*y, 1, 4*y),)
1153 
1154         See Also
1155         ========
1156         replace: replacement capable of doing wildcard-like matching,
1157                  parsing of match, and conditional replacements
1158         subs: substitution of subexpressions as defined by the objects
1159               themselves.
1160 
1161         """
1162         value, _ = self._xreplace(rule)
1163         return value
1164 
1165     def _xreplace(self, rule):
1166         """
1167         Helper for xreplace. Tracks whether a replacement actually occurred.
1168         """
1169         if self in rule:
1170             return rule[self], True
1171         elif rule:
1172             args = []
1173             changed = False
1174             for a in self.args:
1175                 _xreplace = getattr(a, '_xreplace', None)
1176                 if _xreplace is not None:
1177                     a_xr = _xreplace(rule)
1178                     args.append(a_xr[0])
1179                     changed |= a_xr[1]
1180                 else:
1181                     args.append(a)
1182             args = tuple(args)
1183             if changed:
1184                 return self.func(*args), True
1185         return self, False
1186 
1187     @cacheit
1188     def has(self, *patterns):
1189         """
1190         Test whether any subexpression matches any of the patterns.
1191 
1192         Examples
1193         ========
1194 
1195         >>> from sympy import sin
1196         >>> from sympy.abc import x, y, z
1197         >>> (x**2 + sin(x*y)).has(z)
1198         False
1199         >>> (x**2 + sin(x*y)).has(x, y, z)
1200         True
1201         >>> x.has(x)
1202         True
1203 
1204         Note ``has`` is a structural algorithm with no knowledge of
1205         mathematics. Consider the following half-open interval:
1206 
1207         >>> from sympy.sets import Interval
1208         >>> i = Interval.Lopen(0, 5); i
1209         Interval.Lopen(0, 5)
1210         >>> i.args
1211         (0, 5, True, False)
1212         >>> i.has(4)  # there is no "4" in the arguments
1213         False
1214         >>> i.has(0)  # there *is* a "0" in the arguments
1215         True
1216 
1217         Instead, use ``contains`` to determine whether a number is in the
1218         interval or not:
1219 
1220         >>> i.contains(4)
1221         True
1222         >>> i.contains(0)
1223         False
1224 
1225 
1226         Note that ``expr.has(*patterns)`` is exactly equivalent to
1227         ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is
1228         returned when the list of patterns is empty.
1229 
1230         >>> x.has()
1231         False
1232 
1233         """
1234         return any(self._has(pattern) for pattern in patterns)
1235 
1236     def _has(self, pattern):
1237         """Helper for .has()"""
1238         from sympy.core.function import UndefinedFunction, Function
1239         if isinstance(pattern, UndefinedFunction):
1240             return any(f.func == pattern or f == pattern
1241             for f in self.atoms(Function, UndefinedFunction))
1242 
1243         pattern = sympify(pattern)
1244         if isinstance(pattern, BasicMeta):
1245             return any(isinstance(arg, pattern)
1246             for arg in preorder_traversal(self))
1247 
1248         _has_matcher = getattr(pattern, '_has_matcher', None)
1249         if _has_matcher is not None:
1250             match = _has_matcher()
1251             return any(match(arg) for arg in preorder_traversal(self))
1252         else:
1253             return any(arg == pattern for arg in preorder_traversal(self))
1254 
1255     def _has_matcher(self):
1256         """Helper for .has()"""
1257         return lambda other: self == other
1258 
1259     def replace(self, query, value, map=False, simultaneous=True, exact=None):
1260         """
1261         Replace matching subexpressions of ``self`` with ``value``.
1262 
1263         If ``map = True`` then also return the mapping {old: new} where ``old``
1264         was a sub-expression found with query and ``new`` is the replacement
1265         value for it. If the expression itself doesn't match the query, then
1266         the returned value will be ``self.xreplace(map)`` otherwise it should
1267         be ``self.subs(ordered(map.items()))``.
1268 
1269         Traverses an expression tree and performs replacement of matching
1270         subexpressions from the bottom to the top of the tree. The default
1271         approach is to do the replacement in a simultaneous fashion so
1272         changes made are targeted only once. If this is not desired or causes
1273         problems, ``simultaneous`` can be set to False.
1274 
1275         In addition, if an expression containing more than one Wild symbol
1276         is being used to match subexpressions and the ``exact`` flag is None
1277         it will be set to True so the match will only succeed if all non-zero
1278         values are received for each Wild that appears in the match pattern.
1279         Setting this to False accepts a match of 0; while setting it True
1280         accepts all matches that have a 0 in them. See example below for
1281         cautions.
1282 
1283         The list of possible combinations of queries and replacement values
1284         is listed below:
1285 
1286         Examples
1287         ========
1288 
1289         Initial setup
1290 
1291         >>> from sympy import log, sin, cos, tan, Wild, Mul, Add
1292         >>> from sympy.abc import x, y
1293         >>> f = log(sin(x)) + tan(sin(x**2))
1294 
1295         1.1. type -> type
1296             obj.replace(type, newtype)
1297 
1298             When object of type ``type`` is found, replace it with the
1299             result of passing its argument(s) to ``newtype``.
1300 
1301             >>> f.replace(sin, cos)
1302             log(cos(x)) + tan(cos(x**2))
1303             >>> sin(x).replace(sin, cos, map=True)
1304             (cos(x), {sin(x): cos(x)})
1305             >>> (x*y).replace(Mul, Add)
1306             x + y
1307 
1308         1.2. type -> func
1309             obj.replace(type, func)
1310 
1311             When object of type ``type`` is found, apply ``func`` to its
1312             argument(s). ``func`` must be written to handle the number
1313             of arguments of ``type``.
1314 
1315             >>> f.replace(sin, lambda arg: sin(2*arg))
1316             log(sin(2*x)) + tan(sin(2*x**2))
1317             >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
1318             sin(2*x*y)
1319 
1320         2.1. pattern -> expr
1321             obj.replace(pattern(wild), expr(wild))
1322 
1323             Replace subexpressions matching ``pattern`` with the expression
1324             written in terms of the Wild symbols in ``pattern``.
1325 
1326             >>> a, b = map(Wild, 'ab')
1327             >>> f.replace(sin(a), tan(a))
1328             log(tan(x)) + tan(tan(x**2))
1329             >>> f.replace(sin(a), tan(a/2))
1330             log(tan(x/2)) + tan(tan(x**2/2))
1331             >>> f.replace(sin(a), a)
1332             log(x) + tan(x**2)
1333             >>> (x*y).replace(a*x, a)
1334             y
1335 
1336             Matching is exact by default when more than one Wild symbol
1337             is used: matching fails unless the match gives non-zero
1338             values for all Wild symbols:
1339 
1340             >>> (2*x + y).replace(a*x + b, b - a)
1341             y - 2
1342             >>> (2*x).replace(a*x + b, b - a)
1343             2*x
1344 
1345             When set to False, the results may be non-intuitive:
1346 
1347             >>> (2*x).replace(a*x + b, b - a, exact=False)
1348             2/x
1349 
1350         2.2. pattern -> func
1351             obj.replace(pattern(wild), lambda wild: expr(wild))
1352 
1353             All behavior is the same as in 2.1 but now a function in terms of
1354             pattern variables is used rather than an expression:
1355 
1356             >>> f.replace(sin(a), lambda a: sin(2*a))
1357             log(sin(2*x)) + tan(sin(2*x**2))
1358 
1359         3.1. func -> func
1360             obj.replace(filter, func)
1361 
1362             Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
1363             is True.
1364 
1365             >>> g = 2*sin(x**3)
1366             >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
1367             4*sin(x**9)
1368 
1369         The expression itself is also targeted by the query but is done in
1370         such a fashion that changes are not made twice.
1371 
1372             >>> e = x*(x*y + 1)
1373             >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)
1374             2*x*(2*x*y + 1)
1375 
1376         When matching a single symbol, `exact` will default to True, but
1377         this may or may not be the behavior that is desired:
1378 
1379         Here, we want `exact=False`:
1380 
1381         >>> from sympy import Function
1382         >>> f = Function('f')
1383         >>> e = f(1) + f(0)
1384         >>> q = f(a), lambda a: f(a + 1)
1385         >>> e.replace(*q, exact=False)
1386         f(1) + f(2)
1387         >>> e.replace(*q, exact=True)
1388         f(0) + f(2)
1389 
1390         But here, the nature of matching makes selecting
1391         the right setting tricky:
1392 
1393         >>> e = x**(1 + y)
1394         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)
1395         1
1396         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)
1397         x**(-x - y + 1)
1398         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)
1399         1
1400         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)
1401         x**(1 - y)
1402 
1403         It is probably better to use a different form of the query
1404         that describes the target expression more precisely:
1405 
1406         >>> (1 + x**(1 + y)).replace(
1407         ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
1408         ... lambda x: x.base**(1 - (x.exp - 1)))
1409         ...
1410         x**(1 - y) + 1
1411 
1412         See Also
1413         ========
1414 
1415         subs: substitution of subexpressions as defined by the objects
1416               themselves.
1417         xreplace: exact node replacement in expr tree; also capable of
1418                   using matching rules
1419 
1420         """
1421         from sympy.core.symbol import Dummy, Wild
1422         from sympy.simplify.simplify import bottom_up
1423 
1424         try:
1425             query = _sympify(query)
1426         except SympifyError:
1427             pass
1428         try:
1429             value = _sympify(value)
1430         except SympifyError:
1431             pass
1432         if isinstance(query, type):
1433             _query = lambda expr: isinstance(expr, query)
1434 
1435             if isinstance(value, type):
1436                 _value = lambda expr, result: value(*expr.args)
1437             elif callable(value):
1438                 _value = lambda expr, result: value(*expr.args)
1439             else:
1440                 raise TypeError(
1441                     "given a type, replace() expects another "
1442                     "type or a callable")
1443         elif isinstance(query, Basic):
1444             _query = lambda expr: expr.match(query)
1445             if exact is None:
1446                 exact = (len(query.atoms(Wild)) > 1)
1447 
1448             if isinstance(value, Basic):
1449                 if exact:
1450                     _value = lambda expr, result: (value.subs(result)
1451                         if all(result.values()) else expr)
1452                 else:
1453                     _value = lambda expr, result: value.subs(result)
1454             elif callable(value):
1455                 # match dictionary keys get the trailing underscore stripped
1456                 # from them and are then passed as keywords to the callable;
1457                 # if ``exact`` is True, only accept match if there are no null
1458                 # values amongst those matched.
1459                 if exact:
1460                     _value = lambda expr, result: (value(**
1461                         {str(k)[:-1]: v for k, v in result.items()})
1462                         if all(val for val in result.values()) else expr)
1463                 else:
1464                     _value = lambda expr, result: value(**
1465                         {str(k)[:-1]: v for k, v in result.items()})
1466             else:
1467                 raise TypeError(
1468                     "given an expression, replace() expects "
1469                     "another expression or a callable")
1470         elif callable(query):
1471             _query = query
1472 
1473             if callable(value):
1474                 _value = lambda expr, result: value(expr)
1475             else:
1476                 raise TypeError(
1477                     "given a callable, replace() expects "
1478                     "another callable")
1479         else:
1480             raise TypeError(
1481                 "first argument to replace() must be a "
1482                 "type, an expression or a callable")
1483 
1484         mapping = {}  # changes that took place
1485         mask = []  # the dummies that were used as change placeholders
1486 
1487         def rec_replace(expr):
1488             result = _query(expr)
1489             if result or result == {}:
1490                 new = _value(expr, result)
1491                 if new is not None and new != expr:
1492                     mapping[expr] = new
1493                     if simultaneous:
1494                         # don't let this change during rebuilding;
1495                         # XXX this may fail if the object being replaced
1496                         # cannot be represented as a Dummy in the expression
1497                         # tree, e.g. an ExprConditionPair in Piecewise
1498                         # cannot be represented with a Dummy
1499                         com = getattr(new, 'is_commutative', True)
1500                         if com is None:
1501                             com = True
1502                         d = Dummy('rec_replace', commutative=com)
1503                         mask.append((d, new))
1504                         expr = d
1505                     else:
1506                         expr = new
1507             return expr
1508 
1509         rv = bottom_up(self, rec_replace, atoms=True)
1510 
1511         # restore original expressions for Dummy symbols
1512         if simultaneous:
1513             mask = list(reversed(mask))
1514             for o, n in mask:
1515                 r = {o: n}
1516                 # if a sub-expression could not be replaced with
1517                 # a Dummy then this will fail; either filter
1518                 # against such sub-expressions or figure out a
1519                 # way to carry out simultaneous replacement
1520                 # in this situation.
1521                 rv = rv.xreplace(r)  # if this fails, see above
1522 
1523         if not map:
1524             return rv
1525         else:
1526             if simultaneous:
1527                 # restore subexpressions in mapping
1528                 for o, n in mask:
1529                     r = {o: n}
1530                     mapping = {k.xreplace(r): v.xreplace(r)
1531                         for k, v in mapping.items()}
1532             return rv, mapping
1533 
1534     def find(self, query, group=False):
1535         """Find all subexpressions matching a query. """
1536         query = _make_find_query(query)
1537         results = list(filter(query, preorder_traversal(self)))
1538 
1539         if not group:
1540             return set(results)
1541         else:
1542             groups = {}
1543 
1544             for result in results:
1545                 if result in groups:
1546                     groups[result] += 1
1547                 else:
1548                     groups[result] = 1
1549 
1550             return groups
1551 
1552     def count(self, query):
1553         """Count the number of matching subexpressions. """
1554         query = _make_find_query(query)
1555         return sum(bool(query(sub)) for sub in preorder_traversal(self))
1556 
1557     def matches(self, expr, repl_dict={}, old=False):
1558         """
1559         Helper method for match() that looks for a match between Wild symbols
1560         in self and expressions in expr.
1561 
1562         Examples
1563         ========
1564 
1565         >>> from sympy import symbols, Wild, Basic
1566         >>> a, b, c = symbols('a b c')
1567         >>> x = Wild('x')
1568         >>> Basic(a + x, x).matches(Basic(a + b, c)) is None
1569         True
1570         >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))
1571         {x_: b + c}
1572         """
1573         expr = sympify(expr)
1574         if not isinstance(expr, self.__class__):
1575             return None
1576 
1577         if self == expr:
1578             return repl_dict
1579 
1580         if len(self.args) != len(expr.args):
1581             return None
1582 
1583         d = repl_dict.copy()
1584         for arg, other_arg in zip(self.args, expr.args):
1585             if arg == other_arg:
1586                 continue
1587             d = arg.xreplace(d).matches(other_arg, d, old=old)
1588             if d is None:
1589                 return None
1590         return d
1591 
1592     def match(self, pattern, old=False):
1593         """
1594         Pattern matching.
1595 
1596         Wild symbols match all.
1597 
1598         Return ``None`` when expression (self) does not match
1599         with pattern. Otherwise return a dictionary such that::
1600 
1601           pattern.xreplace(self.match(pattern)) == self
1602 
1603         Examples
1604         ========
1605 
1606         >>> from sympy import Wild
1607         >>> from sympy.abc import x, y
1608         >>> p = Wild("p")
1609         >>> q = Wild("q")
1610         >>> r = Wild("r")
1611         >>> e = (x+y)**(x+y)
1612         >>> e.match(p**p)
1613         {p_: x + y}
1614         >>> e.match(p**q)
1615         {p_: x + y, q_: x + y}
1616         >>> e = (2*x)**2
1617         >>> e.match(p*q**r)
1618         {p_: 4, q_: x, r_: 2}
1619         >>> (p*q**r).xreplace(e.match(p*q**r))
1620         4*x**2
1621 
1622         The ``old`` flag will give the old-style pattern matching where
1623         expressions and patterns are essentially solved to give the
1624         match. Both of the following give None unless ``old=True``:
1625 
1626         >>> (x - 2).match(p - x, old=True)
1627         {p_: 2*x - 2}
1628         >>> (2/x).match(p*x, old=True)
1629         {p_: 2/x**2}
1630 
1631         """
1632         pattern = sympify(pattern)
1633         return pattern.matches(self, old=old)
1634 
1635     def count_ops(self, visual=None):
1636         """wrapper for count_ops that returns the operation count."""
1637         from sympy import count_ops
1638         return count_ops(self, visual)
1639 
1640     def doit(self, **hints):
1641         """Evaluate objects that are not evaluated by default like limits,
1642         integrals, sums and products. All objects of this kind will be
1643         evaluated recursively, unless some species were excluded via 'hints'
1644         or unless the 'deep' hint was set to 'False'.
1645 
1646         >>> from sympy import Integral
1647         >>> from sympy.abc import x
1648 
1649         >>> 2*Integral(x, x)
1650         2*Integral(x, x)
1651 
1652         >>> (2*Integral(x, x)).doit()
1653         x**2
1654 
1655         >>> (2*Integral(x, x)).doit(deep=False)
1656         2*Integral(x, x)
1657 
1658         """
1659         if hints.get('deep', True):
1660             terms = [term.doit(**hints) if isinstance(term, Basic) else term
1661                                          for term in self.args]
1662             return self.func(*terms)
1663         else:
1664             return self
1665 
1666     def simplify(self, **kwargs):
1667         """See the simplify function in sympy.simplify"""
1668         from sympy.simplify import simplify
1669         return simplify(self, **kwargs)
1670 
1671     def _eval_rewrite(self, pattern, rule, **hints):
1672         if self.is_Atom:
1673             if hasattr(self, rule):
1674                 return getattr(self, rule)()
1675             return self
1676 
1677         if hints.get('deep', True):
1678             args = [a._eval_rewrite(pattern, rule, **hints)
1679                         if isinstance(a, Basic) else a
1680                         for a in self.args]
1681         else:
1682             args = self.args
1683 
1684         if pattern is None or isinstance(self, pattern):
1685             if hasattr(self, rule):
1686                 rewritten = getattr(self, rule)(*args, **hints)
1687                 if rewritten is not None:
1688                     return rewritten
1689 
1690         return self.func(*args) if hints.get('evaluate', True) else self
1691 
1692     def _accept_eval_derivative(self, s):
1693         # This method needs to be overridden by array-like objects
1694         return s._visit_eval_derivative_scalar(self)
1695 
1696     def _visit_eval_derivative_scalar(self, base):
1697         # Base is a scalar
1698         # Types are (base: scalar, self: scalar)
1699         return base._eval_derivative(self)
1700 
1701     def _visit_eval_derivative_array(self, base):
1702         # Types are (base: array/matrix, self: scalar)
1703         # Base is some kind of array/matrix,
1704         # it should have `.applyfunc(lambda x: x.diff(self)` implemented:
1705         return base._eval_derivative_array(self)
1706 
1707     def _eval_derivative_n_times(self, s, n):
1708         # This is the default evaluator for derivatives (as called by `diff`
1709         # and `Derivative`), it will attempt a loop to derive the expression
1710         # `n` times by calling the corresponding `_eval_derivative` method,
1711         # while leaving the derivative unevaluated if `n` is symbolic.  This
1712         # method should be overridden if the object has a closed form for its
1713         # symbolic n-th derivative.
1714         from sympy import Integer
1715         if isinstance(n, (int, Integer)):
1716             obj = self
1717             for i in range(n):
1718                 obj2 = obj._accept_eval_derivative(s)
1719                 if obj == obj2 or obj2 is None:
1720                     break
1721                 obj = obj2
1722             return obj2
1723         else:
1724             return None
1725 
1726     def rewrite(self, *args, **hints):
1727         """ Rewrite functions in terms of other functions.
1728 
1729         Rewrites expression containing applications of functions
1730         of one kind in terms of functions of different kind. For
1731         example you can rewrite trigonometric functions as complex
1732         exponentials or combinatorial functions as gamma function.
1733 
1734         As a pattern this function accepts a list of functions to
1735         to rewrite (instances of DefinedFunction class). As rule
1736         you can use string or a destination function instance (in
1737         this case rewrite() will use the str() function).
1738 
1739         There is also the possibility to pass hints on how to rewrite
1740         the given expressions. For now there is only one such hint
1741         defined called 'deep'. When 'deep' is set to False it will
1742         forbid functions to rewrite their contents.
1743 
1744         Examples
1745         ========
1746 
1747         >>> from sympy import sin, exp
1748         >>> from sympy.abc import x
1749 
1750         Unspecified pattern:
1751 
1752         >>> sin(x).rewrite(exp)
1753         -I*(exp(I*x) - exp(-I*x))/2
1754 
1755         Pattern as a single function:
1756 
1757         >>> sin(x).rewrite(sin, exp)
1758         -I*(exp(I*x) - exp(-I*x))/2
1759 
1760         Pattern as a list of functions:
1761 
1762         >>> sin(x).rewrite([sin, ], exp)
1763         -I*(exp(I*x) - exp(-I*x))/2
1764 
1765         """
1766         if not args:
1767             return self
1768         else:
1769             pattern = args[:-1]
1770             if isinstance(args[-1], str):
1771                 rule = '_eval_rewrite_as_' + args[-1]
1772             else:
1773                 # rewrite arg is usually a class but can also be a
1774                 # singleton (e.g. GoldenRatio) so we check
1775                 # __name__ or __class__.__name__
1776                 clsname = getattr(args[-1], "__name__", None)
1777                 if clsname is None:
1778                     clsname = args[-1].__class__.__name__
1779                 rule = '_eval_rewrite_as_' + clsname
1780 
1781             if not pattern:
1782                 return self._eval_rewrite(None, rule, **hints)
1783             else:
1784                 if iterable(pattern[0]):
1785                     pattern = pattern[0]
1786 
1787                 pattern = [p for p in pattern if self.has(p)]
1788 
1789                 if pattern:
1790                     return self._eval_rewrite(tuple(pattern), rule, **hints)
1791                 else:
1792                     return self
1793 
1794     _constructor_postprocessor_mapping = {}  # type: ignore
1795 
1796     @classmethod
1797     def _exec_constructor_postprocessors(cls, obj):
1798         # WARNING: This API is experimental.
1799 
1800         # This is an experimental API that introduces constructor
1801         # postprosessors for SymPy Core elements. If an argument of a SymPy
1802         # expression has a `_constructor_postprocessor_mapping` attribute, it will
1803         # be interpreted as a dictionary containing lists of postprocessing
1804         # functions for matching expression node names.
1805 
1806         clsname = obj.__class__.__name__
1807         postprocessors = defaultdict(list)
1808         for i in obj.args:
1809             try:
1810                 postprocessor_mappings = (
1811                     Basic._constructor_postprocessor_mapping[cls].items()
1812                     for cls in type(i).mro()
1813                     if cls in Basic._constructor_postprocessor_mapping
1814                 )
1815                 for k, v in chain.from_iterable(postprocessor_mappings):
1816                     postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
1817             except TypeError:
1818                 pass
1819 
1820         for f in postprocessors.get(clsname, []):
1821             obj = f(obj)
1822 
1823         return obj
1824 
1825 
1826 class Atom(Basic):
1827     """
1828     A parent class for atomic things. An atom is an expression with no subexpressions.
1829 
1830     Examples
1831     ========
1832 
1833     Symbol, Number, Rational, Integer, ...
1834     But not: Add, Mul, Pow, ...
1835     """
1836 
1837     is_Atom = True
1838 
1839     __slots__ = ()
1840 
1841     def matches(self, expr, repl_dict={}, old=False):
1842         if self == expr:
1843             return repl_dict
1844 
1845     def xreplace(self, rule, hack2=False):
1846         return rule.get(self, self)
1847 
1848     def doit(self, **hints):
1849         return self
1850 
1851     @classmethod
1852     def class_key(cls):
1853         return 2, 0, cls.__name__
1854 
1855     @cacheit
1856     def sort_key(self, order=None):
1857         return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One
1858 
1859     def _eval_simplify(self, **kwargs):
1860         return self
1861 
1862     @property
1863     def _sorted_args(self):
1864         # this is here as a safeguard against accidentally using _sorted_args
1865         # on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)
1866         # since there are no args. So the calling routine should be checking
1867         # to see that this property is not called for Atoms.
1868         raise AttributeError('Atoms have no args. It might be necessary'
1869         ' to make a check for Atoms in the calling code.')
1870 
1871 
1872 def _aresame(a, b):
1873     """Return True if a and b are structurally the same, else False.
1874 
1875     Examples
1876     ========
1877 
1878     In SymPy (as in Python) two numbers compare the same if they
1879     have the same underlying base-2 representation even though
1880     they may not be the same type:
1881 
1882     >>> from sympy import S
1883     >>> 2.0 == S(2)
1884     True
1885     >>> 0.5 == S.Half
1886     True
1887 
1888     This routine was written to provide a query for such cases that
1889     would give false when the types do not match:
1890 
1891     >>> from sympy.core.basic import _aresame
1892     >>> _aresame(S(2.0), S(2))
1893     False
1894 
1895     """
1896     from .numbers import Number
1897     from .function import AppliedUndef, UndefinedFunction as UndefFunc
1898     if isinstance(a, Number) and isinstance(b, Number):
1899         return a == b and a.__class__ == b.__class__
1900     for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):
1901         if i != j or type(i) != type(j):
1902             if ((isinstance(i, UndefFunc) and isinstance(j, UndefFunc)) or
1903                 (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef))):
1904                 if i.class_key() != j.class_key():
1905                     return False
1906             else:
1907                 return False
1908     return True
1909 
1910 
1911 def _atomic(e, recursive=False):
1912     """Return atom-like quantities as far as substitution is
1913     concerned: Derivatives, Functions and Symbols. Don't
1914     return any 'atoms' that are inside such quantities unless
1915     they also appear outside, too, unless `recursive` is True.
1916 
1917     Examples
1918     ========
1919 
1920     >>> from sympy import Derivative, Function, cos
1921     >>> from sympy.abc import x, y
1922     >>> from sympy.core.basic import _atomic
1923     >>> f = Function('f')
1924     >>> _atomic(x + y)
1925     {x, y}
1926     >>> _atomic(x + f(y))
1927     {x, f(y)}
1928     >>> _atomic(Derivative(f(x), x) + cos(x) + y)
1929     {y, cos(x), Derivative(f(x), x)}
1930 
1931     """
1932     from sympy import Derivative, Function, Symbol
1933     pot = preorder_traversal(e)
1934     seen = set()
1935     if isinstance(e, Basic):
1936         free = getattr(e, "free_symbols", None)
1937         if free is None:
1938             return {e}
1939     else:
1940         return set()
1941     atoms = set()
1942     for p in pot:
1943         if p in seen:
1944             pot.skip()
1945             continue
1946         seen.add(p)
1947         if isinstance(p, Symbol) and p in free:
1948             atoms.add(p)
1949         elif isinstance(p, (Derivative, Function)):
1950             if not recursive:
1951                 pot.skip()
1952             atoms.add(p)
1953     return atoms
1954 
1955 
1956 class preorder_traversal(Iterator):
1957     """
1958     Do a pre-order traversal of a tree.
1959 
1960     This iterator recursively yields nodes that it has visited in a pre-order
1961     fashion. That is, it yields the current node then descends through the
1962     tree breadth-first to yield all of a node's children's pre-order
1963     traversal.
1964 
1965 
1966     For an expression, the order of the traversal depends on the order of
1967     .args, which in many cases can be arbitrary.
1968 
1969     Parameters
1970     ==========
1971     node : sympy expression
1972         The expression to traverse.
1973     keys : (default None) sort key(s)
1974         The key(s) used to sort args of Basic objects. When None, args of Basic
1975         objects are processed in arbitrary order. If key is defined, it will
1976         be passed along to ordered() as the only key(s) to use to sort the
1977         arguments; if ``key`` is simply True then the default keys of ordered
1978         will be used.
1979 
1980     Yields
1981     ======
1982     subtree : sympy expression
1983         All of the subtrees in the tree.
1984 
1985     Examples
1986     ========
1987 
1988     >>> from sympy import symbols
1989     >>> from sympy.core.basic import preorder_traversal
1990     >>> x, y, z = symbols('x y z')
1991 
1992     The nodes are returned in the order that they are encountered unless key
1993     is given; simply passing key=True will guarantee that the traversal is
1994     unique.
1995 
1996     >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP
1997     [z*(x + y), z, x + y, y, x]
1998     >>> list(preorder_traversal((x + y)*z, keys=True))
1999     [z*(x + y), z, x + y, x, y]
2000 
2001     """
2002     def __init__(self, node, keys=None):
2003         self._skip_flag = False
2004         self._pt = self._preorder_traversal(node, keys)
2005 
2006     def _preorder_traversal(self, node, keys):
2007         yield node
2008         if self._skip_flag:
2009             self._skip_flag = False
2010             return
2011         if isinstance(node, Basic):
2012             if not keys and hasattr(node, '_argset'):
2013                 # LatticeOp keeps args as a set. We should use this if we
2014                 # don't care about the order, to prevent unnecessary sorting.
2015                 args = node._argset
2016             else:
2017                 args = node.args
2018             if keys:
2019                 if keys != True:
2020                     args = ordered(args, keys, default=False)
2021                 else:
2022                     args = ordered(args)
2023             for arg in args:
2024                 for subtree in self._preorder_traversal(arg, keys):
2025                     yield subtree
2026         elif iterable(node):
2027             for item in node:
2028                 for subtree in self._preorder_traversal(item, keys):
2029                     yield subtree
2030 
2031     def skip(self):
2032         """
2033         Skip yielding current node's (last yielded node's) subtrees.
2034 
2035         Examples
2036         ========
2037 
2038         >>> from sympy.core import symbols
2039         >>> from sympy.core.basic import preorder_traversal
2040         >>> x, y, z = symbols('x y z')
2041         >>> pt = preorder_traversal((x+y*z)*z)
2042         >>> for i in pt:
2043         ...     print(i)
2044         ...     if i == x+y*z:
2045         ...             pt.skip()
2046         z*(x + y*z)
2047         z
2048         x + y*z
2049         """
2050         self._skip_flag = True
2051 
2052     def __next__(self):
2053         return next(self._pt)
2054 
2055     def __iter__(self):
2056         return self
2057 
2058 
2059 def _make_find_query(query):
2060     """Convert the argument of Basic.find() into a callable"""
2061     try:
2062         query = sympify(query)
2063     except SympifyError:
2064         pass
2065     if isinstance(query, type):
2066         return lambda expr: isinstance(expr, query)
2067     elif isinstance(query, Basic):
2068         return lambda expr: expr.match(query) is not None
2069     return query

</code><intended_behavior>The method should correctly evaluate or substitute expressions involving infinity, such as `(x + cos(x)).subs(x, oo)` and `(exp(x) + cos(x)).subs(x, oo)`. The intended behavior here is to ensure consistency in how expressions involving infinity are simplified or evaluated, possibly by refining how mathematical functions like `exp` and `cos` handle substitutions involving `oo`. This might involve checking if additional conditions or special handling for infinite substitutions need to be integrated into the `.subs()` method to accommodate the mathematical properties of these functions consistently.</intended_behavior>, <file>sympy/functions/elementary/exponential.py</file>
<class>exp</class>
<method>None</method>
<code>
189 class exp(ExpBase):
190     """
191     The exponential function, :math:`e^x`.
192 
193     See Also
194     ========
195 
196     log
197     """
198 
199     def fdiff(self, argindex=1):
200         """
201         Returns the first derivative of this function.
202         """
203         if argindex == 1:
204             return self
205         else:
206             raise ArgumentIndexError(self, argindex)
207 
208     def _eval_refine(self, assumptions):
209         from sympy.assumptions import ask, Q
210         arg = self.args[0]
211         if arg.is_Mul:
212             Ioo = S.ImaginaryUnit*S.Infinity
213             if arg in [Ioo, -Ioo]:
214                 return S.NaN
215 
216             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
217             if coeff:
218                 if ask(Q.integer(2*coeff)):
219                     if ask(Q.even(coeff)):
220                         return S.One
221                     elif ask(Q.odd(coeff)):
222                         return S.NegativeOne
223                     elif ask(Q.even(coeff + S.Half)):
224                         return -S.ImaginaryUnit
225                     elif ask(Q.odd(coeff + S.Half)):
226                         return S.ImaginaryUnit
227 
228     @classmethod
229     def eval(cls, arg):
230         from sympy.calculus import AccumBounds
231         from sympy.sets.setexpr import SetExpr
232         from sympy.matrices.matrices import MatrixBase
233         from sympy import logcombine
234         if arg.is_Number:
235             if arg is S.NaN:
236                 return S.NaN
237             elif arg.is_zero:
238                 return S.One
239             elif arg is S.One:
240                 return S.Exp1
241             elif arg is S.Infinity:
242                 return S.Infinity
243             elif arg is S.NegativeInfinity:
244                 return S.Zero
245         elif arg is S.ComplexInfinity:
246             return S.NaN
247         elif isinstance(arg, log):
248             return arg.args[0]
249         elif isinstance(arg, AccumBounds):
250             return AccumBounds(exp(arg.min), exp(arg.max))
251         elif isinstance(arg, SetExpr):
252             return arg._eval_func(cls)
253         elif arg.is_Mul:
254             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
255             if coeff:
256                 if (2*coeff).is_integer:
257                     if coeff.is_even:
258                         return S.One
259                     elif coeff.is_odd:
260                         return S.NegativeOne
261                     elif (coeff + S.Half).is_even:
262                         return -S.ImaginaryUnit
263                     elif (coeff + S.Half).is_odd:
264                         return S.ImaginaryUnit
265                 elif coeff.is_Rational:
266                     ncoeff = coeff % 2 # restrict to [0, 2pi)
267                     if ncoeff > 1: # restrict to (-pi, pi]
268                         ncoeff -= 2
269                     if ncoeff != coeff:
270                         return cls(ncoeff*S.Pi*S.ImaginaryUnit)
271 
272             # Warning: code in risch.py will be very sensitive to changes
273             # in this (see DifferentialExtension).
274 
275             # look for a single log factor
276 
277             coeff, terms = arg.as_coeff_Mul()
278 
279             # but it can't be multiplied by oo
280             if coeff in [S.NegativeInfinity, S.Infinity]:
281                 return None
282 
283             coeffs, log_term = [coeff], None
284             for term in Mul.make_args(terms):
285                 term_ = logcombine(term)
286                 if isinstance(term_, log):
287                     if log_term is None:
288                         log_term = term_.args[0]
289                     else:
290                         return None
291                 elif term.is_comparable:
292                     coeffs.append(term)
293                 else:
294                     return None
295 
296             return log_term**Mul(*coeffs) if log_term else None
297 
298         elif arg.is_Add:
299             out = []
300             add = []
301             argchanged = False
302             for a in arg.args:
303                 if a is S.One:
304                     add.append(a)
305                     continue
306                 newa = cls(a)
307                 if isinstance(newa, cls):
308                     if newa.args[0] != a:
309                         add.append(newa.args[0])
310                         argchanged = True
311                     else:
312                         add.append(a)
313                 else:
314                     out.append(newa)
315             if out or argchanged:
316                 return Mul(*out)*cls(Add(*add), evaluate=False)
317 
318         elif isinstance(arg, MatrixBase):
319             return arg.exp()
320 
321         if arg.is_zero:
322             return S.One
323 
324     @property
325     def base(self):
326         """
327         Returns the base of the exponential function.
328         """
329         return S.Exp1
330 
331     @staticmethod
332     @cacheit
333     def taylor_term(n, x, *previous_terms):
334         """
335         Calculates the next term in the Taylor series expansion.
336         """
337         if n < 0:
338             return S.Zero
339         if n == 0:
340             return S.One
341         x = sympify(x)
342         if previous_terms:
343             p = previous_terms[-1]
344             if p is not None:
345                 return p * x / n
346         return x**n/factorial(n)
347 
348     def as_real_imag(self, deep=True, **hints):
349         """
350         Returns this function as a 2-tuple representing a complex number.
351 
352         Examples
353         ========
354 
355         >>> from sympy import I
356         >>> from sympy.abc import x
357         >>> from sympy.functions import exp
358         >>> exp(x).as_real_imag()
359         (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))
360         >>> exp(1).as_real_imag()
361         (E, 0)
362         >>> exp(I).as_real_imag()
363         (cos(1), sin(1))
364         >>> exp(1+I).as_real_imag()
365         (E*cos(1), E*sin(1))
366 
367         See Also
368         ========
369 
370         sympy.functions.elementary.complexes.re
371         sympy.functions.elementary.complexes.im
372         """
373         import sympy
374         re, im = self.args[0].as_real_imag()
375         if deep:
376             re = re.expand(deep, **hints)
377             im = im.expand(deep, **hints)
378         cos, sin = sympy.cos(im), sympy.sin(im)
379         return (exp(re)*cos, exp(re)*sin)
380 
381     def _eval_subs(self, old, new):
382         # keep processing of power-like args centralized in Pow
383         if old.is_Pow:  # handle (exp(3*log(x))).subs(x**2, z) -> z**(3/2)
384             old = exp(old.exp*log(old.base))
385         elif old is S.Exp1 and new.is_Function:
386             old = exp
387         if isinstance(old, exp) or old is S.Exp1:
388             f = lambda a: Pow(*a.as_base_exp(), evaluate=False) if (
389                 a.is_Pow or isinstance(a, exp)) else a
390             return Pow._eval_subs(f(self), f(old), new)
391 
392         if old is exp and not new.is_Function:
393             return new**self.exp._subs(old, new)
394         return Function._eval_subs(self, old, new)
395 
396     def _eval_is_extended_real(self):
397         if self.args[0].is_extended_real:
398             return True
399         elif self.args[0].is_imaginary:
400             arg2 = -S(2) * S.ImaginaryUnit * self.args[0] / S.Pi
401             return arg2.is_even
402 
403     def _eval_is_complex(self):
404         def complex_extended_negative(arg):
405             yield arg.is_complex
406             yield arg.is_extended_negative
407         return fuzzy_or(complex_extended_negative(self.args[0]))
408 
409     def _eval_is_algebraic(self):
410         s = self.func(*self.args)
411         if s.func == self.func:
412             if fuzzy_not(self.exp.is_zero):
413                 if self.exp.is_algebraic:
414                     return False
415                 elif (self.exp/S.Pi).is_rational:
416                     return False
417         else:
418             return s.is_algebraic
419 
420     def _eval_is_extended_positive(self):
421         if self.args[0].is_extended_real:
422             return not self.args[0] is S.NegativeInfinity
423         elif self.args[0].is_imaginary:
424             arg2 = -S.ImaginaryUnit * self.args[0] / S.Pi
425             return arg2.is_even
426 
427     def _eval_nseries(self, x, n, logx):
428         # NOTE Please see the comment at the beginning of this file, labelled
429         #      IMPORTANT.
430         from sympy import limit, oo, Order, powsimp, Wild, expand_complex
431         arg = self.args[0]
432         arg_series = arg._eval_nseries(x, n=n, logx=logx)
433         if arg_series.is_Order:
434             return 1 + arg_series
435         arg0 = limit(arg_series.removeO(), x, 0)
436         if arg0 in [-oo, oo]:
437             return self
438         t = Dummy("t")
439         exp_series = exp(t)._taylor(t, n)
440         o = exp_series.getO()
441         exp_series = exp_series.removeO()
442         r = exp(arg0)*exp_series.subs(t, arg_series - arg0)
443         r += Order(o.expr.subs(t, (arg_series - arg0)), x)
444         r = r.expand()
445         r = powsimp(r, deep=True, combine='exp')
446         # powsimp may introduce unexpanded (-1)**Rational; see PR #17201
447         simplerat = lambda x: x.is_Rational and x.q in [3, 4, 6]
448         w = Wild('w', properties=[simplerat])
449         r = r.replace((-1)**w, expand_complex((-1)**w))
450         return r
451 
452     def _taylor(self, x, n):
453         from sympy import Order
454         l = []
455         g = None
456         for i in range(n):
457             g = self.taylor_term(i, self.args[0], g)
458             g = g.nseries(x, n=n)
459             l.append(g)
460         return Add(*l) + Order(x**n, x)
461 
462     def _eval_as_leading_term(self, x):
463         from sympy import Order
464         arg = self.args[0]
465         if arg.is_Add:
466             return Mul(*[exp(f).as_leading_term(x) for f in arg.args])
467         arg_1 = arg.as_leading_term(x)
468         if Order(x, x).contains(arg_1):
469             return S.One
470         if Order(1, x).contains(arg_1):
471             return exp(arg_1)
472         ####################################################
473         # The correct result here should be 'None'.        #
474         # Indeed arg in not bounded as x tends to 0.       #
475         # Consequently the series expansion does not admit #
476         # the leading term.                                #
477         # For compatibility reasons, the return value here #
478         # is the original function, i.e. exp(arg),         #
479         # instead of None.                                 #
480         ####################################################
481         return exp(arg)
482 
483     def _eval_rewrite_as_sin(self, arg, **kwargs):
484         from sympy import sin
485         I = S.ImaginaryUnit
486         return sin(I*arg + S.Pi/2) - I*sin(I*arg)
487 
488     def _eval_rewrite_as_cos(self, arg, **kwargs):
489         from sympy import cos
490         I = S.ImaginaryUnit
491         return cos(I*arg) + I*cos(I*arg + S.Pi/2)
492 
493     def _eval_rewrite_as_tanh(self, arg, **kwargs):
494         from sympy import tanh
495         return (1 + tanh(arg/2))/(1 - tanh(arg/2))
496 
497     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
498         from sympy.functions.elementary.trigonometric import sin, cos
499         if arg.is_Mul:
500             coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
501             if coeff and coeff.is_number:
502                 cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)
503                 if not isinstance(cosine, cos) and not isinstance (sine, sin):
504                     return cosine + S.ImaginaryUnit*sine
505 
506     def _eval_rewrite_as_Pow(self, arg, **kwargs):
507         if arg.is_Mul:
508             logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]
509             if logs:
510                 return Pow(logs[0].args[0], arg.coeff(logs[0]))

</code><intended_behavior>Ensure that the `exp` function's behavior when its variable tends towards infinity is consistent with mathematical principles and compatible with how the `.subs()` method processes such cases. Specifically, when `exp(x)` is evaluated at `x = oo`, the result should reflect the expected mathematical outcome (i.e., `oo`), and this evaluation should be handled in a manner consistent with the behavior observed in other similar expressions.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>cos</class>
<method>None</method>
<code>
494 class cos(TrigonometricFunction):
495     """
496     The cosine function.
497 
498     Returns the cosine of x (measured in radians).
499 
500     Notes
501     =====
502 
503     See :func:`sin` for notes about automatic evaluation.
504 
505     Examples
506     ========
507 
508     >>> from sympy import cos, pi
509     >>> from sympy.abc import x
510     >>> cos(x**2).diff(x)
511     -2*x*sin(x**2)
512     >>> cos(1).diff(x)
513     0
514     >>> cos(pi)
515     -1
516     >>> cos(pi/2)
517     0
518     >>> cos(2*pi/3)
519     -1/2
520     >>> cos(pi/12)
521     sqrt(2)/4 + sqrt(6)/4
522 
523     See Also
524     ========
525 
526     sin, csc, sec, tan, cot
527     asin, acsc, acos, asec, atan, acot, atan2
528 
529     References
530     ==========
531 
532     .. [1] https://en.wikipedia.org/wiki/Trigonometric_functions
533     .. [2] http://dlmf.nist.gov/4.14
534     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
535 
536     """
537 
538     def period(self, symbol=None):
539         return self._period(2*pi, symbol)
540 
541     def fdiff(self, argindex=1):
542         if argindex == 1:
543             return -sin(self.args[0])
544         else:
545             raise ArgumentIndexError(self, argindex)
546 
547     @classmethod
548     def eval(cls, arg):
549         from sympy.functions.special.polynomials import chebyshevt
550         from sympy.calculus.util import AccumBounds
551         from sympy.sets.setexpr import SetExpr
552         if arg.is_Number:
553             if arg is S.NaN:
554                 return S.NaN
555             elif arg.is_zero:
556                 return S.One
557             elif arg is S.Infinity or arg is S.NegativeInfinity:
558                 # In this case it is better to return AccumBounds(-1, 1)
559                 # rather than returning S.NaN, since AccumBounds(-1, 1)
560                 # preserves the information that sin(oo) is between
561                 # -1 and 1, where S.NaN does not do that.
562                 return AccumBounds(-1, 1)
563 
564         if arg is S.ComplexInfinity:
565             return S.NaN
566 
567         if isinstance(arg, AccumBounds):
568             return sin(arg + S.Pi/2)
569         elif isinstance(arg, SetExpr):
570             return arg._eval_func(cls)
571 
572         if arg.could_extract_minus_sign():
573             return cls(-arg)
574 
575         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
576         if i_coeff is not None:
577             return cosh(i_coeff)
578 
579         pi_coeff = _pi_coeff(arg)
580         if pi_coeff is not None:
581             if pi_coeff.is_integer:
582                 return (S.NegativeOne)**pi_coeff
583 
584             if (2*pi_coeff).is_integer:
585                 # is_even-case handled above as then pi_coeff.is_integer,
586                 # so check if known to be not even
587                 if pi_coeff.is_even is False:
588                     return S.Zero
589 
590             if not pi_coeff.is_Rational:
591                 narg = pi_coeff*S.Pi
592                 if narg != arg:
593                     return cls(narg)
594                 return None
595 
596             # cosine formula #####################
597             # https://github.com/sympy/sympy/issues/6048
598             # explicit calculations are performed for
599             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
600             # Some other exact values like cos(k pi/240) can be
601             # calculated using a partial-fraction decomposition
602             # by calling cos( X ).rewrite(sqrt)
603             cst_table_some = {
604                 3: S.Half,
605                 5: (sqrt(5) + 1)/4,
606             }
607             if pi_coeff.is_Rational:
608                 q = pi_coeff.q
609                 p = pi_coeff.p % (2*q)
610                 if p > q:
611                     narg = (pi_coeff - 1)*S.Pi
612                     return -cls(narg)
613                 if 2*p > q:
614                     narg = (1 - pi_coeff)*S.Pi
615                     return -cls(narg)
616 
617                 # If nested sqrt's are worse than un-evaluation
618                 # you can require q to be in (1, 2, 3, 4, 6, 12)
619                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
620                 # expressions with 2 or fewer sqrt nestings.
621                 table2 = {
622                     12: (3, 4),
623                     20: (4, 5),
624                     30: (5, 6),
625                     15: (6, 10),
626                     24: (6, 8),
627                     40: (8, 10),
628                     60: (20, 30),
629                     120: (40, 60)
630                     }
631                 if q in table2:
632                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
633                     nvala, nvalb = cls(a), cls(b)
634                     if None == nvala or None == nvalb:
635                         return None
636                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
637 
638                 if q > 12:
639                     return None
640 
641                 if q in cst_table_some:
642                     cts = cst_table_some[pi_coeff.q]
643                     return chebyshevt(pi_coeff.p, cts).expand()
644 
645                 if 0 == q % 2:
646                     narg = (pi_coeff*2)*S.Pi
647                     nval = cls(narg)
648                     if None == nval:
649                         return None
650                     x = (2*pi_coeff + 1)/2
651                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
652                     return sign_cos*sqrt( (1 + nval)/2 )
653             return None
654 
655         if arg.is_Add:
656             x, m = _peeloff_pi(arg)
657             if m:
658                 return cos(m)*cos(x) - sin(m)*sin(x)
659 
660         if arg.is_zero:
661             return S.One
662 
663         if isinstance(arg, acos):
664             return arg.args[0]
665 
666         if isinstance(arg, atan):
667             x = arg.args[0]
668             return 1/sqrt(1 + x**2)
669 
670         if isinstance(arg, atan2):
671             y, x = arg.args
672             return x/sqrt(x**2 + y**2)
673 
674         if isinstance(arg, asin):
675             x = arg.args[0]
676             return sqrt(1 - x ** 2)
677 
678         if isinstance(arg, acot):
679             x = arg.args[0]
680             return 1/sqrt(1 + 1/x**2)
681 
682         if isinstance(arg, acsc):
683             x = arg.args[0]
684             return sqrt(1 - 1/x**2)
685 
686         if isinstance(arg, asec):
687             x = arg.args[0]
688             return 1/x
689 
690     @staticmethod
691     @cacheit
692     def taylor_term(n, x, *previous_terms):
693         if n < 0 or n % 2 == 1:
694             return S.Zero
695         else:
696             x = sympify(x)
697 
698             if len(previous_terms) > 2:
699                 p = previous_terms[-2]
700                 return -p*x**2/(n*(n - 1))
701             else:
702                 return (-1)**(n//2)*x**(n)/factorial(n)
703 
704     def _eval_rewrite_as_exp(self, arg, **kwargs):
705         I = S.ImaginaryUnit
706         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
707             arg = arg.func(arg.args[0]).rewrite(exp)
708         return (exp(arg*I) + exp(-arg*I))/2
709 
710     def _eval_rewrite_as_Pow(self, arg, **kwargs):
711         if isinstance(arg, log):
712             I = S.ImaginaryUnit
713             x = arg.args[0]
714             return x**I/2 + x**-I/2
715 
716     def _eval_rewrite_as_sin(self, arg, **kwargs):
717         return sin(arg + S.Pi/2, evaluate=False)
718 
719     def _eval_rewrite_as_tan(self, arg, **kwargs):
720         tan_half = tan(S.Half*arg)**2
721         return (1 - tan_half)/(1 + tan_half)
722 
723     def _eval_rewrite_as_sincos(self, arg, **kwargs):
724         return sin(arg)*cos(arg)/sin(arg)
725 
726     def _eval_rewrite_as_cot(self, arg, **kwargs):
727         cot_half = cot(S.Half*arg)**2
728         return (cot_half - 1)/(cot_half + 1)
729 
730     def _eval_rewrite_as_pow(self, arg, **kwargs):
731         return self._eval_rewrite_as_sqrt(arg)
732 
733     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
734         from sympy.functions.special.polynomials import chebyshevt
735 
736         def migcdex(x):
737             # recursive calcuation of gcd and linear combination
738             # for a sequence of integers.
739             # Given  (x1, x2, x3)
740             # Returns (y1, y1, y3, g)
741             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
742             # Note, that this is only one such linear combination.
743             if len(x) == 1:
744                 return (1, x[0])
745             if len(x) == 2:
746                 return igcdex(x[0], x[-1])
747             g = migcdex(x[1:])
748             u, v, h = igcdex(x[0], g[-1])
749             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
750 
751         def ipartfrac(r, factors=None):
752             from sympy.ntheory import factorint
753             if isinstance(r, int):
754                 return r
755             if not isinstance(r, Rational):
756                 raise TypeError("r is not rational")
757             n = r.q
758             if 2 > r.q*r.q:
759                 return r.q
760 
761             if None == factors:
762                 a = [n//x**y for x, y in factorint(r.q).items()]
763             else:
764                 a = [n//x for x in factors]
765             if len(a) == 1:
766                 return [ r ]
767             h = migcdex(a)
768             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
769             assert r == sum(ans)
770             return ans
771         pi_coeff = _pi_coeff(arg)
772         if pi_coeff is None:
773             return None
774 
775         if pi_coeff.is_integer:
776             # it was unevaluated
777             return self.func(pi_coeff*S.Pi)
778 
779         if not pi_coeff.is_Rational:
780             return None
781 
782         def _cospi257():
783             """ Express cos(pi/257) explicitly as a function of radicals
784                 Based upon the equations in
785                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
786                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
787             """
788             def f1(a, b):
789                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
790 
791             def f2(a, b):
792                 return (a - sqrt(a**2 + b))/2
793 
794             t1, t2 = f1(-1, 256)
795             z1, z3 = f1(t1, 64)
796             z2, z4 = f1(t2, 64)
797             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
798             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
799             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
800             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
801             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
802             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
803             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
804             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
805             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
806             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
807             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
808             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
809             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
810             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
811             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
812             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
813             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
814             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
815             u1 = -f2(-v1, -4*(v2 + v3))
816             u2 = -f2(-v4, -4*(v5 + v6))
817             w1 = -2*f2(-u1, -4*u2)
818             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
819 
820         cst_table_some = {
821             3: S.Half,
822             5: (sqrt(5) + 1)/4,
823             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
824                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
825                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
826             257: _cospi257()
827             # 65537 is the only other known Fermat prime and the very
828             # large expression is intentionally omitted from SymPy; see
829             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
830         }
831 
832         def _fermatCoords(n):
833             # if n can be factored in terms of Fermat primes with
834             # multiplicity of each being 1, return those primes, else
835             # False
836             primes = []
837             for p_i in cst_table_some:
838                 quotient, remainder = divmod(n, p_i)
839                 if remainder == 0:
840                     n = quotient
841                     primes.append(p_i)
842                     if n == 1:
843                         return tuple(primes)
844             return False
845 
846         if pi_coeff.q in cst_table_some:
847             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
848             if pi_coeff.q < 257:
849                 rv = rv.expand()
850             return rv
851 
852         if not pi_coeff.q % 2:  # recursively remove factors of 2
853             pico2 = pi_coeff*2
854             nval = cos(pico2*S.Pi).rewrite(sqrt)
855             x = (pico2 + 1)/2
856             sign_cos = -1 if int(x) % 2 else 1
857             return sign_cos*sqrt( (1 + nval)/2 )
858 
859         FC = _fermatCoords(pi_coeff.q)
860         if FC:
861             decomp = ipartfrac(pi_coeff, FC)
862             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
863             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
864             return pcls.rewrite(sqrt)
865         else:
866             decomp = ipartfrac(pi_coeff)
867             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
868             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
869             return pcls
870 
871     def _eval_rewrite_as_sec(self, arg, **kwargs):
872         return 1/sec(arg)
873 
874     def _eval_rewrite_as_csc(self, arg, **kwargs):
875         return 1/sec(arg).rewrite(csc)
876 
877     def _eval_conjugate(self):
878         return self.func(self.args[0].conjugate())
879 
880     def as_real_imag(self, deep=True, **hints):
881         re, im = self._as_real_imag(deep=deep, **hints)
882         return (cos(re)*cosh(im), -sin(re)*sinh(im))
883 
884     def _eval_expand_trig(self, **hints):
885         from sympy.functions.special.polynomials import chebyshevt
886         arg = self.args[0]
887         x = None
888         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
889             x, y = arg.as_two_terms()
890             sx = sin(x, evaluate=False)._eval_expand_trig()
891             sy = sin(y, evaluate=False)._eval_expand_trig()
892             cx = cos(x, evaluate=False)._eval_expand_trig()
893             cy = cos(y, evaluate=False)._eval_expand_trig()
894             return cx*cy - sx*sy
895         else:
896             coeff, terms = arg.as_coeff_Mul(rational=True)
897             if coeff.is_Integer:
898                 return chebyshevt(coeff, cos(terms))
899             pi_coeff = _pi_coeff(arg)
900             if pi_coeff is not None:
901                 if pi_coeff.is_Rational:
902                     return self.rewrite(sqrt)
903         return cos(arg)
904 
905     def _eval_as_leading_term(self, x):
906         from sympy import Order
907         arg = self.args[0].as_leading_term(x)
908 
909         if x in arg.free_symbols and Order(1, x).contains(arg):
910             return S.One
911         else:
912             return self.func(arg)
913 
914     def _eval_is_extended_real(self):
915         if self.args[0].is_extended_real:
916             return True
917 
918     def _eval_is_finite(self):
919         arg = self.args[0]
920 
921         if arg.is_extended_real:
922             return True
923 
924     def _eval_is_complex(self):
925         if self.args[0].is_extended_real \
926             or self.args[0].is_complex:
927             return True

</code><intended_behavior>For `cos(x)` where `x` is substituted with `oo`, it's not about altering the `cos` function's inherent behavior at infinity but ensuring that its handling within expressions substituted at infinity is consistent. Since `cos(x)` doesn't have a limit as `x` approaches infinity, the substitution might either need to prevent simplistic numerical evaluations or work cohesively with constructs like `AccumBounds` to present a result that accurately represents the function's behavior at infinity.</intended_behavior>]
2025-10-16 03:14:50.160 | INFO     | Search completed. Bug locations: [<file>sympy/core/basic.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Base class for all the objects in SymPy"""
2 from __future__ import print_function, division
3 from collections import defaultdict
4 from itertools import chain, zip_longest
5 
6 from .assumptions import BasicMeta, ManagedProperties
7 from .cache import cacheit
8 from .sympify import _sympify, sympify, SympifyError
9 from .compatibility import iterable, Iterator, ordered, Mapping
10 from .singleton import S
11 
12 from inspect import getmro
13 
14 
15 def as_Basic(expr):
16     """Return expr as a Basic instance using strict sympify
17     or raise a TypeError; this is just a wrapper to _sympify,
18     raising a TypeError instead of a SympifyError."""
19     from sympy.utilities.misc import func_name
20     try:
21         return _sympify(expr)
22     except SympifyError:
23         raise TypeError(
24             'Argument must be a Basic object, not `%s`' % func_name(
25             expr))
26 
27 
28 class Basic(metaclass=ManagedProperties):
29     """
30     Base class for all objects in SymPy.
31 
32     Conventions:
33 
34     1) Always use ``.args``, when accessing parameters of some instance:
35 
36     >>> from sympy import cot
37     >>> from sympy.abc import x, y
38 
39     >>> cot(x).args
40     (x,)
41 
42     >>> cot(x).args[0]
43     x
44 
45     >>> (x*y).args
46     (x, y)
47 
48     >>> (x*y).args[1]
49     y
50 
51 
52     2) Never use internal methods or variables (the ones prefixed with ``_``):
53 
54     >>> cot(x)._args    # do not use this, use cot(x).args instead
55     (x,)
56 
57     """
58     __slots__ = ('_mhash',              # hash value
59                  '_args',               # arguments
60                  '_assumptions'
61                 )
62 
63     # To be overridden with True in the appropriate subclasses
64     is_number = False
65     is_Atom = False
66     is_Symbol = False
67     is_symbol = False
68     is_Indexed = False
69     is_Dummy = False
70     is_Wild = False
71     is_Function = False
72     is_Add = False
73     is_Mul = False
74     is_Pow = False
75     is_Number = False
76     is_Float = False
77     is_Rational = False
78     is_Integer = False
79     is_NumberSymbol = False
80     is_Order = False
81     is_Derivative = False
82     is_Piecewise = False
83     is_Poly = False
84     is_AlgebraicNumber = False
85     is_Relational = False
86     is_Equality = False
87     is_Boolean = False
88     is_Not = False
89     is_Matrix = False
90     is_Vector = False
91     is_Point = False
92     is_MatAdd = False
93     is_MatMul = False
94 
95     def __new__(cls, *args):
96         obj = object.__new__(cls)
97         obj._assumptions = cls.default_assumptions
98         obj._mhash = None  # will be set by __hash__ method.
99 
100         obj._args = args  # all items in args must be Basic objects
101         return obj
102 
103     def copy(self):
104         return self.func(*self.args)
105 
106     def __reduce_ex__(self, proto):
107         """ Pickling support."""
108         return type(self), self.__getnewargs__(), self.__getstate__()
109 
110     def __getnewargs__(self):
111         return self.args
112 
113     def __getstate__(self):
114         return {}
115 
116     def __setstate__(self, state):
117         for k, v in state.items():
118             setattr(self, k, v)
119 
120     def __hash__(self):
121         # hash cannot be cached using cache_it because infinite recurrence
122         # occurs as hash is needed for setting cache dictionary keys
123         h = self._mhash
124         if h is None:
125             h = hash((type(self).__name__,) + self._hashable_content())
126             self._mhash = h
127         return h
128 
129     def _hashable_content(self):
130         """Return a tuple of information about self that can be used to
131         compute the hash. If a class defines additional attributes,
132         like ``name`` in Symbol, then this method should be updated
133         accordingly to return such relevant attributes.
134 
135         Defining more than _hashable_content is necessary if __eq__ has
136         been defined by a class. See note about this in Basic.__eq__."""
137         return self._args
138 
139     @property
140     def assumptions0(self):
141         """
142         Return object `type` assumptions.
143 
144         For example:
145 
146           Symbol('x', real=True)
147           Symbol('x', integer=True)
148 
149         are different objects. In other words, besides Python type (Symbol in
150         this case), the initial assumptions are also forming their typeinfo.
151 
152         Examples
153         ========
154 
155         >>> from sympy import Symbol
156         >>> from sympy.abc import x
157         >>> x.assumptions0
158         {'commutative': True}
159         >>> x = Symbol("x", positive=True)
160         >>> x.assumptions0
161         {'commutative': True, 'complex': True, 'extended_negative': False,
162          'extended_nonnegative': True, 'extended_nonpositive': False,
163          'extended_nonzero': True, 'extended_positive': True, 'extended_real':
164          True, 'finite': True, 'hermitian': True, 'imaginary': False,
165          'infinite': False, 'negative': False, 'nonnegative': True,
166          'nonpositive': False, 'nonzero': True, 'positive': True, 'real':
167          True, 'zero': False}
168         """
169         return {}
170 
171     def compare(self, other):
172         """
173         Return -1, 0, 1 if the object is smaller, equal, or greater than other.
174 
175         Not in the mathematical sense. If the object is of a different type
176         from the "other" then their classes are ordered according to
177         the sorted_classes list.
178 
179         Examples
180         ========
181 
182         >>> from sympy.abc import x, y
183         >>> x.compare(y)
184         -1
185         >>> x.compare(x)
186         0
187         >>> y.compare(x)
188         1
189 
190         """
191         # all redefinitions of __cmp__ method should start with the
192         # following lines:
193         if self is other:
194             return 0
195         n1 = self.__class__
196         n2 = other.__class__
197         c = (n1 > n2) - (n1 < n2)
198         if c:
199             return c
200         #
201         st = self._hashable_content()
202         ot = other._hashable_content()
203         c = (len(st) > len(ot)) - (len(st) < len(ot))
204         if c:
205             return c
206         for l, r in zip(st, ot):
207             l = Basic(*l) if isinstance(l, frozenset) else l
208             r = Basic(*r) if isinstance(r, frozenset) else r
209             if isinstance(l, Basic):
210                 c = l.compare(r)
211             else:
212                 c = (l > r) - (l < r)
213             if c:
214                 return c
215         return 0
216 
217     @staticmethod
218     def _compare_pretty(a, b):
219         from sympy.series.order import Order
220         if isinstance(a, Order) and not isinstance(b, Order):
221             return 1
222         if not isinstance(a, Order) and isinstance(b, Order):
223             return -1
224 
225         if a.is_Rational and b.is_Rational:
226             l = a.p * b.q
227             r = b.p * a.q
228             return (l > r) - (l < r)
229         else:
230             from sympy.core.symbol import Wild
231             p1, p2, p3 = Wild("p1"), Wild("p2"), Wild("p3")
232             r_a = a.match(p1 * p2**p3)
233             if r_a and p3 in r_a:
234                 a3 = r_a[p3]
235                 r_b = b.match(p1 * p2**p3)
236                 if r_b and p3 in r_b:
237                     b3 = r_b[p3]
238                     c = Basic.compare(a3, b3)
239                     if c != 0:
240                         return c
241 
242         return Basic.compare(a, b)
243 
244     @classmethod
245     def fromiter(cls, args, **assumptions):
246         """
247         Create a new object from an iterable.
248 
249         This is a convenience function that allows one to create objects from
250         any iterable, without having to convert to a list or tuple first.
251 
252         Examples
253         ========
254 
255         >>> from sympy import Tuple
256         >>> Tuple.fromiter(i for i in range(5))
257         (0, 1, 2, 3, 4)
258 
259         """
260         return cls(*tuple(args), **assumptions)
261 
262     @classmethod
263     def class_key(cls):
264         """Nice order of classes. """
265         return 5, 0, cls.__name__
266 
267     @cacheit
268     def sort_key(self, order=None):
269         """
270         Return a sort key.
271 
272         Examples
273         ========
274 
275         >>> from sympy.core import S, I
276 
277         >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())
278         [1/2, -I, I]
279 
280         >>> S("[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]")
281         [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]
282         >>> sorted(_, key=lambda x: x.sort_key())
283         [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]
284 
285         """
286 
287         # XXX: remove this when issue 5169 is fixed
288         def inner_key(arg):
289             if isinstance(arg, Basic):
290                 return arg.sort_key(order)
291             else:
292                 return arg
293 
294         args = self._sorted_args
295         args = len(args), tuple([inner_key(arg) for arg in args])
296         return self.class_key(), args, S.One.sort_key(), S.One
297 
298     def __eq__(self, other):
299         """Return a boolean indicating whether a == b on the basis of
300         their symbolic trees.
301 
302         This is the same as a.compare(b) == 0 but faster.
303 
304         Notes
305         =====
306 
307         If a class that overrides __eq__() needs to retain the
308         implementation of __hash__() from a parent class, the
309         interpreter must be told this explicitly by setting __hash__ =
310         <ParentClass>.__hash__. Otherwise the inheritance of __hash__()
311         will be blocked, just as if __hash__ had been explicitly set to
312         None.
313 
314         References
315         ==========
316 
317         from http://docs.python.org/dev/reference/datamodel.html#object.__hash__
318         """
319         if self is other:
320             return True
321 
322         tself = type(self)
323         tother = type(other)
324         if tself is not tother:
325             try:
326                 other = _sympify(other)
327                 tother = type(other)
328             except SympifyError:
329                 return NotImplemented
330 
331             # As long as we have the ordering of classes (sympy.core),
332             # comparing types will be slow in Python 2, because it uses
333             # __cmp__. Until we can remove it
334             # (https://github.com/sympy/sympy/issues/4269), we only compare
335             # types in Python 2 directly if they actually have __ne__.
336             if type(tself).__ne__ is not type.__ne__:
337                 if tself != tother:
338                     return False
339             elif tself is not tother:
340                 return False
341 
342         return self._hashable_content() == other._hashable_content()
343 
344     def __ne__(self, other):
345         """``a != b``  -> Compare two symbolic trees and see whether they are different
346 
347         this is the same as:
348 
349         ``a.compare(b) != 0``
350 
351         but faster
352         """
353         return not self == other
354 
355     def dummy_eq(self, other, symbol=None):
356         """
357         Compare two expressions and handle dummy symbols.
358 
359         Examples
360         ========
361 
362         >>> from sympy import Dummy
363         >>> from sympy.abc import x, y
364 
365         >>> u = Dummy('u')
366 
367         >>> (u**2 + 1).dummy_eq(x**2 + 1)
368         True
369         >>> (u**2 + 1) == (x**2 + 1)
370         False
371 
372         >>> (u**2 + y).dummy_eq(x**2 + y, x)
373         True
374         >>> (u**2 + y).dummy_eq(x**2 + y, y)
375         False
376 
377         """
378         s = self.as_dummy()
379         o = _sympify(other)
380         o = o.as_dummy()
381 
382         dummy_symbols = [i for i in s.free_symbols if i.is_Dummy]
383 
384         if len(dummy_symbols) == 1:
385             dummy = dummy_symbols.pop()
386         else:
387             return s == o
388 
389         if symbol is None:
390             symbols = o.free_symbols
391 
392             if len(symbols) == 1:
393                 symbol = symbols.pop()
394             else:
395                 return s == o
396 
397         tmp = dummy.__class__()
398 
399         return s.subs(dummy, tmp) == o.subs(symbol, tmp)
400 
401     # Note, we always use the default ordering (lex) in __str__ and __repr__,
402     # regardless of the global setting.  See issue 5487.
403     def __repr__(self):
404         """Method to return the string representation.
405 
406         Return the expression as a string.
407         """
408         from sympy.printing import sstr
409         return sstr(self, order=None)
410 
411     def __str__(self):
412         from sympy.printing import sstr
413         return sstr(self, order=None)
414 
415     # We don't define _repr_png_ here because it would add a large amount of
416     # data to any notebook containing SymPy expressions, without adding
417     # anything useful to the notebook. It can still enabled manually, e.g.,
418     # for the qtconsole, with init_printing().
419     def _repr_latex_(self):
420         """
421         IPython/Jupyter LaTeX printing
422 
423         To change the behavior of this (e.g., pass in some settings to LaTeX),
424         use init_printing(). init_printing() will also enable LaTeX printing
425         for built in numeric types like ints and container types that contain
426         SymPy objects, like lists and dictionaries of expressions.
427         """
428         from sympy.printing.latex import latex
429         s = latex(self, mode='plain')
430         return "$\\displaystyle %s$" % s
431 
432     _repr_latex_orig = _repr_latex_
433 
434     def atoms(self, *types):
435         """Returns the atoms that form the current object.
436 
437         By default, only objects that are truly atomic and can't
438         be divided into smaller pieces are returned: symbols, numbers,
439         and number symbols like I and pi. It is possible to request
440         atoms of any type, however, as demonstrated below.
441 
442         Examples
443         ========
444 
445         >>> from sympy import I, pi, sin
446         >>> from sympy.abc import x, y
447         >>> (1 + x + 2*sin(y + I*pi)).atoms()
448         {1, 2, I, pi, x, y}
449 
450         If one or more types are given, the results will contain only
451         those types of atoms.
452 
453         >>> from sympy import Number, NumberSymbol, Symbol
454         >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)
455         {x, y}
456 
457         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)
458         {1, 2}
459 
460         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)
461         {1, 2, pi}
462 
463         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)
464         {1, 2, I, pi}
465 
466         Note that I (imaginary unit) and zoo (complex infinity) are special
467         types of number symbols and are not part of the NumberSymbol class.
468 
469         The type can be given implicitly, too:
470 
471         >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol
472         {x, y}
473 
474         Be careful to check your assumptions when using the implicit option
475         since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type
476         of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all
477         integers in an expression:
478 
479         >>> from sympy import S
480         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))
481         {1}
482 
483         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))
484         {1, 2}
485 
486         Finally, arguments to atoms() can select more than atomic atoms: any
487         sympy type (loaded in core/__init__.py) can be listed as an argument
488         and those types of "atoms" as found in scanning the arguments of the
489         expression recursively:
490 
491         >>> from sympy import Function, Mul
492         >>> from sympy.core.function import AppliedUndef
493         >>> f = Function('f')
494         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)
495         {f(x), sin(y + I*pi)}
496         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)
497         {f(x)}
498 
499         >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)
500         {I*pi, 2*sin(y + I*pi)}
501 
502         """
503         if types:
504             types = tuple(
505                 [t if isinstance(t, type) else type(t) for t in types])
506         else:
507             types = (Atom,)
508         result = set()
509         for expr in preorder_traversal(self):
510             if isinstance(expr, types):
511                 result.add(expr)
512         return result
513 
514     @property
515     def free_symbols(self):
516         """Return from the atoms of self those which are free symbols.
517 
518         For most expressions, all symbols are free symbols. For some classes
519         this is not true. e.g. Integrals use Symbols for the dummy variables
520         which are bound variables, so Integral has a method to return all
521         symbols except those. Derivative keeps track of symbols with respect
522         to which it will perform a derivative; those are
523         bound variables, too, so it has its own free_symbols method.
524 
525         Any other method that uses bound variables should implement a
526         free_symbols method."""
527         return set().union(*[a.free_symbols for a in self.args])
528 
529     @property
530     def expr_free_symbols(self):
531         return set([])
532 
533     def as_dummy(self):
534         """Return the expression with any objects having structurally
535         bound symbols replaced with unique, canonical symbols within
536         the object in which they appear and having only the default
537         assumption for commutativity being True.
538 
539         Examples
540         ========
541 
542         >>> from sympy import Integral, Symbol
543         >>> from sympy.abc import x, y
544         >>> r = Symbol('r', real=True)
545         >>> Integral(r, (r, x)).as_dummy()
546         Integral(_0, (_0, x))
547         >>> _.variables[0].is_real is None
548         True
549 
550         Notes
551         =====
552 
553         Any object that has structural dummy variables should have
554         a property, `bound_symbols` that returns a list of structural
555         dummy symbols of the object itself.
556 
557         Lambda and Subs have bound symbols, but because of how they
558         are cached, they already compare the same regardless of their
559         bound symbols:
560 
561         >>> from sympy import Lambda
562         >>> Lambda(x, x + 1) == Lambda(y, y + 1)
563         True
564         """
565         def can(x):
566             d = {i: i.as_dummy() for i in x.bound_symbols}
567             # mask free that shadow bound
568             x = x.subs(d)
569             c = x.canonical_variables
570             # replace bound
571             x = x.xreplace(c)
572             # undo masking
573             x = x.xreplace(dict((v, k) for k, v in d.items()))
574             return x
575         return self.replace(
576             lambda x: hasattr(x, 'bound_symbols'),
577             lambda x: can(x))
578 
579     @property
580     def canonical_variables(self):
581         """Return a dictionary mapping any variable defined in
582         ``self.bound_symbols`` to Symbols that do not clash
583         with any existing symbol in the expression.
584 
585         Examples
586         ========
587 
588         >>> from sympy import Lambda
589         >>> from sympy.abc import x
590         >>> Lambda(x, 2*x).canonical_variables
591         {x: _0}
592         """
593         from sympy.core.symbol import Symbol
594         from sympy.utilities.iterables import numbered_symbols
595         if not hasattr(self, 'bound_symbols'):
596             return {}
597         dums = numbered_symbols('_')
598         reps = {}
599         v = self.bound_symbols
600         # this free will include bound symbols that are not part of
601         # self's bound symbols
602         free = set([i.name for i in self.atoms(Symbol) - set(v)])
603         for v in v:
604             d = next(dums)
605             if v.is_Symbol:
606                 while v.name == d.name or d.name in free:
607                     d = next(dums)
608             reps[v] = d
609         return reps
610 
611     def rcall(self, *args):
612         """Apply on the argument recursively through the expression tree.
613 
614         This method is used to simulate a common abuse of notation for
615         operators. For instance in SymPy the the following will not work:
616 
617         ``(x+Lambda(y, 2*y))(z) == x+2*z``,
618 
619         however you can use
620 
621         >>> from sympy import Lambda
622         >>> from sympy.abc import x, y, z
623         >>> (x + Lambda(y, 2*y)).rcall(z)
624         x + 2*z
625         """
626         return Basic._recursive_call(self, args)
627 
628     @staticmethod
629     def _recursive_call(expr_to_call, on_args):
630         """Helper for rcall method."""
631         from sympy import Symbol
632         def the_call_method_is_overridden(expr):
633             for cls in getmro(type(expr)):
634                 if '__call__' in cls.__dict__:
635                     return cls != Basic
636 
637         if callable(expr_to_call) and the_call_method_is_overridden(expr_to_call):
638             if isinstance(expr_to_call, Symbol):  # XXX When you call a Symbol it is
639                 return expr_to_call               # transformed into an UndefFunction
640             else:
641                 return expr_to_call(*on_args)
642         elif expr_to_call.args:
643             args = [Basic._recursive_call(
644                 sub, on_args) for sub in expr_to_call.args]
645             return type(expr_to_call)(*args)
646         else:
647             return expr_to_call
648 
649     def is_hypergeometric(self, k):
650         from sympy.simplify import hypersimp
651         return hypersimp(self, k) is not None
652 
653     @property
654     def is_comparable(self):
655         """Return True if self can be computed to a real number
656         (or already is a real number) with precision, else False.
657 
658         Examples
659         ========
660 
661         >>> from sympy import exp_polar, pi, I
662         >>> (I*exp_polar(I*pi/2)).is_comparable
663         True
664         >>> (I*exp_polar(I*pi*2)).is_comparable
665         False
666 
667         A False result does not mean that `self` cannot be rewritten
668         into a form that would be comparable. For example, the
669         difference computed below is zero but without simplification
670         it does not evaluate to a zero with precision:
671 
672         >>> e = 2**pi*(1 + 2**pi)
673         >>> dif = e - e.expand()
674         >>> dif.is_comparable
675         False
676         >>> dif.n(2)._prec
677         1
678 
679         """
680         is_extended_real = self.is_extended_real
681         if is_extended_real is False:
682             return False
683         if not self.is_number:
684             return False
685         # don't re-eval numbers that are already evaluated since
686         # this will create spurious precision
687         n, i = [p.evalf(2) if not p.is_Number else p
688             for p in self.as_real_imag()]
689         if not (i.is_Number and n.is_Number):
690             return False
691         if i:
692             # if _prec = 1 we can't decide and if not,
693             # the answer is False because numbers with
694             # imaginary parts can't be compared
695             # so return False
696             return False
697         else:
698             return n._prec != 1
699 
700     @property
701     def func(self):
702         """
703         The top-level function in an expression.
704 
705         The following should hold for all objects::
706 
707             >> x == x.func(*x.args)
708 
709         Examples
710         ========
711 
712         >>> from sympy.abc import x
713         >>> a = 2*x
714         >>> a.func
715         <class 'sympy.core.mul.Mul'>
716         >>> a.args
717         (2, x)
718         >>> a.func(*a.args)
719         2*x
720         >>> a == a.func(*a.args)
721         True
722 
723         """
724         return self.__class__
725 
726     @property
727     def args(self):
728         """Returns a tuple of arguments of 'self'.
729 
730         Examples
731         ========
732 
733         >>> from sympy import cot
734         >>> from sympy.abc import x, y
735 
736         >>> cot(x).args
737         (x,)
738 
739         >>> cot(x).args[0]
740         x
741 
742         >>> (x*y).args
743         (x, y)
744 
745         >>> (x*y).args[1]
746         y
747 
748         Notes
749         =====
750 
751         Never use self._args, always use self.args.
752         Only use _args in __new__ when creating a new function.
753         Don't override .args() from Basic (so that it's easy to
754         change the interface in the future if needed).
755         """
756         return self._args
757 
758     @property
759     def _sorted_args(self):
760         """
761         The same as ``args``.  Derived classes which don't fix an
762         order on their arguments should override this method to
763         produce the sorted representation.
764         """
765         return self.args
766 
767     def as_content_primitive(self, radical=False, clear=True):
768         """A stub to allow Basic args (like Tuple) to be skipped when computing
769         the content and primitive components of an expression.
770 
771         See Also
772         ========
773 
774         sympy.core.expr.Expr.as_content_primitive
775         """
776         return S.One, self
777 
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv
976 
977     @cacheit
978     def _subs(self, old, new, **hints):
979         """Substitutes an expression old -> new.
980 
981         If self is not equal to old then _eval_subs is called.
982         If _eval_subs doesn't want to make any special replacement
983         then a None is received which indicates that the fallback
984         should be applied wherein a search for replacements is made
985         amongst the arguments of self.
986 
987         >>> from sympy import Add
988         >>> from sympy.abc import x, y, z
989 
990         Examples
991         ========
992 
993         Add's _eval_subs knows how to target x + y in the following
994         so it makes the change:
995 
996         >>> (x + y + z).subs(x + y, 1)
997         z + 1
998 
999         Add's _eval_subs doesn't need to know how to find x + y in
1000         the following:
1001 
1002         >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None
1003         True
1004 
1005         The returned None will cause the fallback routine to traverse the args and
1006         pass the z*(x + y) arg to Mul where the change will take place and the
1007         substitution will succeed:
1008 
1009         >>> (z*(x + y) + 3).subs(x + y, 1)
1010         z + 3
1011 
1012         ** Developers Notes **
1013 
1014         An _eval_subs routine for a class should be written if:
1015 
1016             1) any arguments are not instances of Basic (e.g. bool, tuple);
1017 
1018             2) some arguments should not be targeted (as in integration
1019                variables);
1020 
1021             3) if there is something other than a literal replacement
1022                that should be attempted (as in Piecewise where the condition
1023                may be updated without doing a replacement).
1024 
1025         If it is overridden, here are some special cases that might arise:
1026 
1027             1) If it turns out that no special change was made and all
1028                the original sub-arguments should be checked for
1029                replacements then None should be returned.
1030 
1031             2) If it is necessary to do substitutions on a portion of
1032                the expression then _subs should be called. _subs will
1033                handle the case of any sub-expression being equal to old
1034                (which usually would not be the case) while its fallback
1035                will handle the recursion into the sub-arguments. For
1036                example, after Add's _eval_subs removes some matching terms
1037                it must process the remaining terms so it calls _subs
1038                on each of the un-matched terms and then adds them
1039                onto the terms previously obtained.
1040 
1041            3) If the initial expression should remain unchanged then
1042               the original expression should be returned. (Whenever an
1043               expression is returned, modified or not, no further
1044               substitution of old -> new is attempted.) Sum's _eval_subs
1045               routine uses this strategy when a substitution is attempted
1046               on any of its summation variables.
1047         """
1048 
1049         def fallback(self, old, new):
1050             """
1051             Try to replace old with new in any of self's arguments.
1052             """
1053             hit = False
1054             args = list(self.args)
1055             for i, arg in enumerate(args):
1056                 if not hasattr(arg, '_eval_subs'):
1057                     continue
1058                 arg = arg._subs(old, new, **hints)
1059                 if not _aresame(arg, args[i]):
1060                     hit = True
1061                     args[i] = arg
1062             if hit:
1063                 rv = self.func(*args)
1064                 hack2 = hints.get('hack2', False)
1065                 if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack
1066                     coeff = S.One
1067                     nonnumber = []
1068                     for i in args:
1069                         if i.is_Number:
1070                             coeff *= i
1071                         else:
1072                             nonnumber.append(i)
1073                     nonnumber = self.func(*nonnumber)
1074                     if coeff is S.One:
1075                         return nonnumber
1076                     else:
1077                         return self.func(coeff, nonnumber, evaluate=False)
1078                 return rv
1079             return self
1080 
1081         if _aresame(self, old):
1082             return new
1083 
1084         rv = self._eval_subs(old, new)
1085         if rv is None:
1086             rv = fallback(self, old, new)
1087         return rv
1088 
1089     def _eval_subs(self, old, new):
1090         """Override this stub if you want to do anything more than
1091         attempt a replacement of old with new in the arguments of self.
1092 
1093         See also
1094         ========
1095 
1096         _subs
1097         """
1098         return None
1099 
1100     def xreplace(self, rule):
1101         """
1102         Replace occurrences of objects within the expression.
1103 
1104         Parameters
1105         ==========
1106 
1107         rule : dict-like
1108             Expresses a replacement rule
1109 
1110         Returns
1111         =======
1112 
1113         xreplace : the result of the replacement
1114 
1115         Examples
1116         ========
1117 
1118         >>> from sympy import symbols, pi, exp
1119         >>> x, y, z = symbols('x y z')
1120         >>> (1 + x*y).xreplace({x: pi})
1121         pi*y + 1
1122         >>> (1 + x*y).xreplace({x: pi, y: 2})
1123         1 + 2*pi
1124 
1125         Replacements occur only if an entire node in the expression tree is
1126         matched:
1127 
1128         >>> (x*y + z).xreplace({x*y: pi})
1129         z + pi
1130         >>> (x*y*z).xreplace({x*y: pi})
1131         x*y*z
1132         >>> (2*x).xreplace({2*x: y, x: z})
1133         y
1134         >>> (2*2*x).xreplace({2*x: y, x: z})
1135         4*z
1136         >>> (x + y + 2).xreplace({x + y: 2})
1137         x + y + 2
1138         >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})
1139         x + exp(y) + 2
1140 
1141         xreplace doesn't differentiate between free and bound symbols. In the
1142         following, subs(x, y) would not change x since it is a bound symbol,
1143         but xreplace does:
1144 
1145         >>> from sympy import Integral
1146         >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})
1147         Integral(y, (y, 1, 2*y))
1148 
1149         Trying to replace x with an expression raises an error:
1150 
1151         >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP
1152         ValueError: Invalid limits given: ((2*y, 1, 4*y),)
1153 
1154         See Also
1155         ========
1156         replace: replacement capable of doing wildcard-like matching,
1157                  parsing of match, and conditional replacements
1158         subs: substitution of subexpressions as defined by the objects
1159               themselves.
1160 
1161         """
1162         value, _ = self._xreplace(rule)
1163         return value
1164 
1165     def _xreplace(self, rule):
1166         """
1167         Helper for xreplace. Tracks whether a replacement actually occurred.
1168         """
1169         if self in rule:
1170             return rule[self], True
1171         elif rule:
1172             args = []
1173             changed = False
1174             for a in self.args:
1175                 _xreplace = getattr(a, '_xreplace', None)
1176                 if _xreplace is not None:
1177                     a_xr = _xreplace(rule)
1178                     args.append(a_xr[0])
1179                     changed |= a_xr[1]
1180                 else:
1181                     args.append(a)
1182             args = tuple(args)
1183             if changed:
1184                 return self.func(*args), True
1185         return self, False
1186 
1187     @cacheit
1188     def has(self, *patterns):
1189         """
1190         Test whether any subexpression matches any of the patterns.
1191 
1192         Examples
1193         ========
1194 
1195         >>> from sympy import sin
1196         >>> from sympy.abc import x, y, z
1197         >>> (x**2 + sin(x*y)).has(z)
1198         False
1199         >>> (x**2 + sin(x*y)).has(x, y, z)
1200         True
1201         >>> x.has(x)
1202         True
1203 
1204         Note ``has`` is a structural algorithm with no knowledge of
1205         mathematics. Consider the following half-open interval:
1206 
1207         >>> from sympy.sets import Interval
1208         >>> i = Interval.Lopen(0, 5); i
1209         Interval.Lopen(0, 5)
1210         >>> i.args
1211         (0, 5, True, False)
1212         >>> i.has(4)  # there is no "4" in the arguments
1213         False
1214         >>> i.has(0)  # there *is* a "0" in the arguments
1215         True
1216 
1217         Instead, use ``contains`` to determine whether a number is in the
1218         interval or not:
1219 
1220         >>> i.contains(4)
1221         True
1222         >>> i.contains(0)
1223         False
1224 
1225 
1226         Note that ``expr.has(*patterns)`` is exactly equivalent to
1227         ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is
1228         returned when the list of patterns is empty.
1229 
1230         >>> x.has()
1231         False
1232 
1233         """
1234         return any(self._has(pattern) for pattern in patterns)
1235 
1236     def _has(self, pattern):
1237         """Helper for .has()"""
1238         from sympy.core.function import UndefinedFunction, Function
1239         if isinstance(pattern, UndefinedFunction):
1240             return any(f.func == pattern or f == pattern
1241             for f in self.atoms(Function, UndefinedFunction))
1242 
1243         pattern = sympify(pattern)
1244         if isinstance(pattern, BasicMeta):
1245             return any(isinstance(arg, pattern)
1246             for arg in preorder_traversal(self))
1247 
1248         _has_matcher = getattr(pattern, '_has_matcher', None)
1249         if _has_matcher is not None:
1250             match = _has_matcher()
1251             return any(match(arg) for arg in preorder_traversal(self))
1252         else:
1253             return any(arg == pattern for arg in preorder_traversal(self))
1254 
1255     def _has_matcher(self):
1256         """Helper for .has()"""
1257         return lambda other: self == other
1258 
1259     def replace(self, query, value, map=False, simultaneous=True, exact=None):
1260         """
1261         Replace matching subexpressions of ``self`` with ``value``.
1262 
1263         If ``map = True`` then also return the mapping {old: new} where ``old``
1264         was a sub-expression found with query and ``new`` is the replacement
1265         value for it. If the expression itself doesn't match the query, then
1266         the returned value will be ``self.xreplace(map)`` otherwise it should
1267         be ``self.subs(ordered(map.items()))``.
1268 
1269         Traverses an expression tree and performs replacement of matching
1270         subexpressions from the bottom to the top of the tree. The default
1271         approach is to do the replacement in a simultaneous fashion so
1272         changes made are targeted only once. If this is not desired or causes
1273         problems, ``simultaneous`` can be set to False.
1274 
1275         In addition, if an expression containing more than one Wild symbol
1276         is being used to match subexpressions and the ``exact`` flag is None
1277         it will be set to True so the match will only succeed if all non-zero
1278         values are received for each Wild that appears in the match pattern.
1279         Setting this to False accepts a match of 0; while setting it True
1280         accepts all matches that have a 0 in them. See example below for
1281         cautions.
1282 
1283         The list of possible combinations of queries and replacement values
1284         is listed below:
1285 
1286         Examples
1287         ========
1288 
1289         Initial setup
1290 
1291         >>> from sympy import log, sin, cos, tan, Wild, Mul, Add
1292         >>> from sympy.abc import x, y
1293         >>> f = log(sin(x)) + tan(sin(x**2))
1294 
1295         1.1. type -> type
1296             obj.replace(type, newtype)
1297 
1298             When object of type ``type`` is found, replace it with the
1299             result of passing its argument(s) to ``newtype``.
1300 
1301             >>> f.replace(sin, cos)
1302             log(cos(x)) + tan(cos(x**2))
1303             >>> sin(x).replace(sin, cos, map=True)
1304             (cos(x), {sin(x): cos(x)})
1305             >>> (x*y).replace(Mul, Add)
1306             x + y
1307 
1308         1.2. type -> func
1309             obj.replace(type, func)
1310 
1311             When object of type ``type`` is found, apply ``func`` to its
1312             argument(s). ``func`` must be written to handle the number
1313             of arguments of ``type``.
1314 
1315             >>> f.replace(sin, lambda arg: sin(2*arg))
1316             log(sin(2*x)) + tan(sin(2*x**2))
1317             >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))
1318             sin(2*x*y)
1319 
1320         2.1. pattern -> expr
1321             obj.replace(pattern(wild), expr(wild))
1322 
1323             Replace subexpressions matching ``pattern`` with the expression
1324             written in terms of the Wild symbols in ``pattern``.
1325 
1326             >>> a, b = map(Wild, 'ab')
1327             >>> f.replace(sin(a), tan(a))
1328             log(tan(x)) + tan(tan(x**2))
1329             >>> f.replace(sin(a), tan(a/2))
1330             log(tan(x/2)) + tan(tan(x**2/2))
1331             >>> f.replace(sin(a), a)
1332             log(x) + tan(x**2)
1333             >>> (x*y).replace(a*x, a)
1334             y
1335 
1336             Matching is exact by default when more than one Wild symbol
1337             is used: matching fails unless the match gives non-zero
1338             values for all Wild symbols:
1339 
1340             >>> (2*x + y).replace(a*x + b, b - a)
1341             y - 2
1342             >>> (2*x).replace(a*x + b, b - a)
1343             2*x
1344 
1345             When set to False, the results may be non-intuitive:
1346 
1347             >>> (2*x).replace(a*x + b, b - a, exact=False)
1348             2/x
1349 
1350         2.2. pattern -> func
1351             obj.replace(pattern(wild), lambda wild: expr(wild))
1352 
1353             All behavior is the same as in 2.1 but now a function in terms of
1354             pattern variables is used rather than an expression:
1355 
1356             >>> f.replace(sin(a), lambda a: sin(2*a))
1357             log(sin(2*x)) + tan(sin(2*x**2))
1358 
1359         3.1. func -> func
1360             obj.replace(filter, func)
1361 
1362             Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``
1363             is True.
1364 
1365             >>> g = 2*sin(x**3)
1366             >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)
1367             4*sin(x**9)
1368 
1369         The expression itself is also targeted by the query but is done in
1370         such a fashion that changes are not made twice.
1371 
1372             >>> e = x*(x*y + 1)
1373             >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)
1374             2*x*(2*x*y + 1)
1375 
1376         When matching a single symbol, `exact` will default to True, but
1377         this may or may not be the behavior that is desired:
1378 
1379         Here, we want `exact=False`:
1380 
1381         >>> from sympy import Function
1382         >>> f = Function('f')
1383         >>> e = f(1) + f(0)
1384         >>> q = f(a), lambda a: f(a + 1)
1385         >>> e.replace(*q, exact=False)
1386         f(1) + f(2)
1387         >>> e.replace(*q, exact=True)
1388         f(0) + f(2)
1389 
1390         But here, the nature of matching makes selecting
1391         the right setting tricky:
1392 
1393         >>> e = x**(1 + y)
1394         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)
1395         1
1396         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)
1397         x**(-x - y + 1)
1398         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)
1399         1
1400         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)
1401         x**(1 - y)
1402 
1403         It is probably better to use a different form of the query
1404         that describes the target expression more precisely:
1405 
1406         >>> (1 + x**(1 + y)).replace(
1407         ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,
1408         ... lambda x: x.base**(1 - (x.exp - 1)))
1409         ...
1410         x**(1 - y) + 1
1411 
1412         See Also
1413         ========
1414 
1415         subs: substitution of subexpressions as defined by the objects
1416               themselves.
1417         xreplace: exact node replacement in expr tree; also capable of
1418                   using matching rules
1419 
1420         """
1421         from sympy.core.symbol import Dummy, Wild
1422         from sympy.simplify.simplify import bottom_up
1423 
1424         try:
1425             query = _sympify(query)
1426         except SympifyError:
1427             pass
1428         try:
1429             value = _sympify(value)
1430         except SympifyError:
1431             pass
1432         if isinstance(query, type):
1433             _query = lambda expr: isinstance(expr, query)
1434 
1435             if isinstance(value, type):
1436                 _value = lambda expr, result: value(*expr.args)
1437             elif callable(value):
1438                 _value = lambda expr, result: value(*expr.args)
1439             else:
1440                 raise TypeError(
1441                     "given a type, replace() expects another "
1442                     "type or a callable")
1443         elif isinstance(query, Basic):
1444             _query = lambda expr: expr.match(query)
1445             if exact is None:
1446                 exact = (len(query.atoms(Wild)) > 1)
1447 
1448             if isinstance(value, Basic):
1449                 if exact:
1450                     _value = lambda expr, result: (value.subs(result)
1451                         if all(result.values()) else expr)
1452                 else:
1453                     _value = lambda expr, result: value.subs(result)
1454             elif callable(value):
1455                 # match dictionary keys get the trailing underscore stripped
1456                 # from them and are then passed as keywords to the callable;
1457                 # if ``exact`` is True, only accept match if there are no null
1458                 # values amongst those matched.
1459                 if exact:
1460                     _value = lambda expr, result: (value(**
1461                         {str(k)[:-1]: v for k, v in result.items()})
1462                         if all(val for val in result.values()) else expr)
1463                 else:
1464                     _value = lambda expr, result: value(**
1465                         {str(k)[:-1]: v for k, v in result.items()})
1466             else:
1467                 raise TypeError(
1468                     "given an expression, replace() expects "
1469                     "another expression or a callable")
1470         elif callable(query):
1471             _query = query
1472 
1473             if callable(value):
1474                 _value = lambda expr, result: value(expr)
1475             else:
1476                 raise TypeError(
1477                     "given a callable, replace() expects "
1478                     "another callable")
1479         else:
1480             raise TypeError(
1481                 "first argument to replace() must be a "
1482                 "type, an expression or a callable")
1483 
1484         mapping = {}  # changes that took place
1485         mask = []  # the dummies that were used as change placeholders
1486 
1487         def rec_replace(expr):
1488             result = _query(expr)
1489             if result or result == {}:
1490                 new = _value(expr, result)
1491                 if new is not None and new != expr:
1492                     mapping[expr] = new
1493                     if simultaneous:
1494                         # don't let this change during rebuilding;
1495                         # XXX this may fail if the object being replaced
1496                         # cannot be represented as a Dummy in the expression
1497                         # tree, e.g. an ExprConditionPair in Piecewise
1498                         # cannot be represented with a Dummy
1499                         com = getattr(new, 'is_commutative', True)
1500                         if com is None:
1501                             com = True
1502                         d = Dummy('rec_replace', commutative=com)
1503                         mask.append((d, new))
1504                         expr = d
1505                     else:
1506                         expr = new
1507             return expr
1508 
1509         rv = bottom_up(self, rec_replace, atoms=True)
1510 
1511         # restore original expressions for Dummy symbols
1512         if simultaneous:
1513             mask = list(reversed(mask))
1514             for o, n in mask:
1515                 r = {o: n}
1516                 # if a sub-expression could not be replaced with
1517                 # a Dummy then this will fail; either filter
1518                 # against such sub-expressions or figure out a
1519                 # way to carry out simultaneous replacement
1520                 # in this situation.
1521                 rv = rv.xreplace(r)  # if this fails, see above
1522 
1523         if not map:
1524             return rv
1525         else:
1526             if simultaneous:
1527                 # restore subexpressions in mapping
1528                 for o, n in mask:
1529                     r = {o: n}
1530                     mapping = {k.xreplace(r): v.xreplace(r)
1531                         for k, v in mapping.items()}
1532             return rv, mapping
1533 
1534     def find(self, query, group=False):
1535         """Find all subexpressions matching a query. """
1536         query = _make_find_query(query)
1537         results = list(filter(query, preorder_traversal(self)))
1538 
1539         if not group:
1540             return set(results)
1541         else:
1542             groups = {}
1543 
1544             for result in results:
1545                 if result in groups:
1546                     groups[result] += 1
1547                 else:
1548                     groups[result] = 1
1549 
1550             return groups
1551 
1552     def count(self, query):
1553         """Count the number of matching subexpressions. """
1554         query = _make_find_query(query)
1555         return sum(bool(query(sub)) for sub in preorder_traversal(self))
1556 
1557     def matches(self, expr, repl_dict={}, old=False):
1558         """
1559         Helper method for match() that looks for a match between Wild symbols
1560         in self and expressions in expr.
1561 
1562         Examples
1563         ========
1564 
1565         >>> from sympy import symbols, Wild, Basic
1566         >>> a, b, c = symbols('a b c')
1567         >>> x = Wild('x')
1568         >>> Basic(a + x, x).matches(Basic(a + b, c)) is None
1569         True
1570         >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))
1571         {x_: b + c}
1572         """
1573         expr = sympify(expr)
1574         if not isinstance(expr, self.__class__):
1575             return None
1576 
1577         if self == expr:
1578             return repl_dict
1579 
1580         if len(self.args) != len(expr.args):
1581             return None
1582 
1583         d = repl_dict.copy()
1584         for arg, other_arg in zip(self.args, expr.args):
1585             if arg == other_arg:
1586                 continue
1587             d = arg.xreplace(d).matches(other_arg, d, old=old)
1588             if d is None:
1589                 return None
1590         return d
1591 
1592     def match(self, pattern, old=False):
1593         """
1594         Pattern matching.
1595 
1596         Wild symbols match all.
1597 
1598         Return ``None`` when expression (self) does not match
1599         with pattern. Otherwise return a dictionary such that::
1600 
1601           pattern.xreplace(self.match(pattern)) == self
1602 
1603         Examples
1604         ========
1605 
1606         >>> from sympy import Wild
1607         >>> from sympy.abc import x, y
1608         >>> p = Wild("p")
1609         >>> q = Wild("q")
1610         >>> r = Wild("r")
1611         >>> e = (x+y)**(x+y)
1612         >>> e.match(p**p)
1613         {p_: x + y}
1614         >>> e.match(p**q)
1615         {p_: x + y, q_: x + y}
1616         >>> e = (2*x)**2
1617         >>> e.match(p*q**r)
1618         {p_: 4, q_: x, r_: 2}
1619         >>> (p*q**r).xreplace(e.match(p*q**r))
1620         4*x**2
1621 
1622         The ``old`` flag will give the old-style pattern matching where
1623         expressions and patterns are essentially solved to give the
1624         match. Both of the following give None unless ``old=True``:
1625 
1626         >>> (x - 2).match(p - x, old=True)
1627         {p_: 2*x - 2}
1628         >>> (2/x).match(p*x, old=True)
1629         {p_: 2/x**2}
1630 
1631         """
1632         pattern = sympify(pattern)
1633         return pattern.matches(self, old=old)
1634 
1635     def count_ops(self, visual=None):
1636         """wrapper for count_ops that returns the operation count."""
1637         from sympy import count_ops
1638         return count_ops(self, visual)
1639 
1640     def doit(self, **hints):
1641         """Evaluate objects that are not evaluated by default like limits,
1642         integrals, sums and products. All objects of this kind will be
1643         evaluated recursively, unless some species were excluded via 'hints'
1644         or unless the 'deep' hint was set to 'False'.
1645 
1646         >>> from sympy import Integral
1647         >>> from sympy.abc import x
1648 
1649         >>> 2*Integral(x, x)
1650         2*Integral(x, x)
1651 
1652         >>> (2*Integral(x, x)).doit()
1653         x**2
1654 
1655         >>> (2*Integral(x, x)).doit(deep=False)
1656         2*Integral(x, x)
1657 
1658         """
1659         if hints.get('deep', True):
1660             terms = [term.doit(**hints) if isinstance(term, Basic) else term
1661                                          for term in self.args]
1662             return self.func(*terms)
1663         else:
1664             return self
1665 
1666     def simplify(self, **kwargs):
1667         """See the simplify function in sympy.simplify"""
1668         from sympy.simplify import simplify
1669         return simplify(self, **kwargs)
1670 
1671     def _eval_rewrite(self, pattern, rule, **hints):
1672         if self.is_Atom:
1673             if hasattr(self, rule):
1674                 return getattr(self, rule)()
1675             return self
1676 
1677         if hints.get('deep', True):
1678             args = [a._eval_rewrite(pattern, rule, **hints)
1679                         if isinstance(a, Basic) else a
1680                         for a in self.args]
1681         else:
1682             args = self.args
1683 
1684         if pattern is None or isinstance(self, pattern):
1685             if hasattr(self, rule):
1686                 rewritten = getattr(self, rule)(*args, **hints)
1687                 if rewritten is not None:
1688                     return rewritten
1689 
1690         return self.func(*args) if hints.get('evaluate', True) else self
1691 
1692     def _accept_eval_derivative(self, s):
1693         # This method needs to be overridden by array-like objects
1694         return s._visit_eval_derivative_scalar(self)
1695 
1696     def _visit_eval_derivative_scalar(self, base):
1697         # Base is a scalar
1698         # Types are (base: scalar, self: scalar)
1699         return base._eval_derivative(self)
1700 
1701     def _visit_eval_derivative_array(self, base):
1702         # Types are (base: array/matrix, self: scalar)
1703         # Base is some kind of array/matrix,
1704         # it should have `.applyfunc(lambda x: x.diff(self)` implemented:
1705         return base._eval_derivative_array(self)
1706 
1707     def _eval_derivative_n_times(self, s, n):
1708         # This is the default evaluator for derivatives (as called by `diff`
1709         # and `Derivative`), it will attempt a loop to derive the expression
1710         # `n` times by calling the corresponding `_eval_derivative` method,
1711         # while leaving the derivative unevaluated if `n` is symbolic.  This
1712         # method should be overridden if the object has a closed form for its
1713         # symbolic n-th derivative.
1714         from sympy import Integer
1715         if isinstance(n, (int, Integer)):
1716             obj = self
1717             for i in range(n):
1718                 obj2 = obj._accept_eval_derivative(s)
1719                 if obj == obj2 or obj2 is None:
1720                     break
1721                 obj = obj2
1722             return obj2
1723         else:
1724             return None
1725 
1726     def rewrite(self, *args, **hints):
1727         """ Rewrite functions in terms of other functions.
1728 
1729         Rewrites expression containing applications of functions
1730         of one kind in terms of functions of different kind. For
1731         example you can rewrite trigonometric functions as complex
1732         exponentials or combinatorial functions as gamma function.
1733 
1734         As a pattern this function accepts a list of functions to
1735         to rewrite (instances of DefinedFunction class). As rule
1736         you can use string or a destination function instance (in
1737         this case rewrite() will use the str() function).
1738 
1739         There is also the possibility to pass hints on how to rewrite
1740         the given expressions. For now there is only one such hint
1741         defined called 'deep'. When 'deep' is set to False it will
1742         forbid functions to rewrite their contents.
1743 
1744         Examples
1745         ========
1746 
1747         >>> from sympy import sin, exp
1748         >>> from sympy.abc import x
1749 
1750         Unspecified pattern:
1751 
1752         >>> sin(x).rewrite(exp)
1753         -I*(exp(I*x) - exp(-I*x))/2
1754 
1755         Pattern as a single function:
1756 
1757         >>> sin(x).rewrite(sin, exp)
1758         -I*(exp(I*x) - exp(-I*x))/2
1759 
1760         Pattern as a list of functions:
1761 
1762         >>> sin(x).rewrite([sin, ], exp)
1763         -I*(exp(I*x) - exp(-I*x))/2
1764 
1765         """
1766         if not args:
1767             return self
1768         else:
1769             pattern = args[:-1]
1770             if isinstance(args[-1], str):
1771                 rule = '_eval_rewrite_as_' + args[-1]
1772             else:
1773                 # rewrite arg is usually a class but can also be a
1774                 # singleton (e.g. GoldenRatio) so we check
1775                 # __name__ or __class__.__name__
1776                 clsname = getattr(args[-1], "__name__", None)
1777                 if clsname is None:
1778                     clsname = args[-1].__class__.__name__
1779                 rule = '_eval_rewrite_as_' + clsname
1780 
1781             if not pattern:
1782                 return self._eval_rewrite(None, rule, **hints)
1783             else:
1784                 if iterable(pattern[0]):
1785                     pattern = pattern[0]
1786 
1787                 pattern = [p for p in pattern if self.has(p)]
1788 
1789                 if pattern:
1790                     return self._eval_rewrite(tuple(pattern), rule, **hints)
1791                 else:
1792                     return self
1793 
1794     _constructor_postprocessor_mapping = {}  # type: ignore
1795 
1796     @classmethod
1797     def _exec_constructor_postprocessors(cls, obj):
1798         # WARNING: This API is experimental.
1799 
1800         # This is an experimental API that introduces constructor
1801         # postprosessors for SymPy Core elements. If an argument of a SymPy
1802         # expression has a `_constructor_postprocessor_mapping` attribute, it will
1803         # be interpreted as a dictionary containing lists of postprocessing
1804         # functions for matching expression node names.
1805 
1806         clsname = obj.__class__.__name__
1807         postprocessors = defaultdict(list)
1808         for i in obj.args:
1809             try:
1810                 postprocessor_mappings = (
1811                     Basic._constructor_postprocessor_mapping[cls].items()
1812                     for cls in type(i).mro()
1813                     if cls in Basic._constructor_postprocessor_mapping
1814                 )
1815                 for k, v in chain.from_iterable(postprocessor_mappings):
1816                     postprocessors[k].extend([j for j in v if j not in postprocessors[k]])
1817             except TypeError:
1818                 pass
1819 
1820         for f in postprocessors.get(clsname, []):
1821             obj = f(obj)
1822 
1823         return obj
1824 
1825 
1826 class Atom(Basic):
1827     """
1828     A parent class for atomic things. An atom is an expression with no subexpressions.
1829 
1830     Examples
1831     ========
1832 
1833     Symbol, Number, Rational, Integer, ...
1834     But not: Add, Mul, Pow, ...
1835     """
1836 
1837     is_Atom = True
1838 
1839     __slots__ = ()
1840 
1841     def matches(self, expr, repl_dict={}, old=False):
1842         if self == expr:
1843             return repl_dict
1844 
1845     def xreplace(self, rule, hack2=False):
1846         return rule.get(self, self)
1847 
1848     def doit(self, **hints):
1849         return self
1850 
1851     @classmethod
1852     def class_key(cls):
1853         return 2, 0, cls.__name__
1854 
1855     @cacheit
1856     def sort_key(self, order=None):
1857         return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One
1858 
1859     def _eval_simplify(self, **kwargs):
1860         return self
1861 
1862     @property
1863     def _sorted_args(self):
1864         # this is here as a safeguard against accidentally using _sorted_args
1865         # on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)
1866         # since there are no args. So the calling routine should be checking
1867         # to see that this property is not called for Atoms.
1868         raise AttributeError('Atoms have no args. It might be necessary'
1869         ' to make a check for Atoms in the calling code.')
1870 
1871 
1872 def _aresame(a, b):
1873     """Return True if a and b are structurally the same, else False.
1874 
1875     Examples
1876     ========
1877 
1878     In SymPy (as in Python) two numbers compare the same if they
1879     have the same underlying base-2 representation even though
1880     they may not be the same type:
1881 
1882     >>> from sympy import S
1883     >>> 2.0 == S(2)
1884     True
1885     >>> 0.5 == S.Half
1886     True
1887 
1888     This routine was written to provide a query for such cases that
1889     would give false when the types do not match:
1890 
1891     >>> from sympy.core.basic import _aresame
1892     >>> _aresame(S(2.0), S(2))
1893     False
1894 
1895     """
1896     from .numbers import Number
1897     from .function import AppliedUndef, UndefinedFunction as UndefFunc
1898     if isinstance(a, Number) and isinstance(b, Number):
1899         return a == b and a.__class__ == b.__class__
1900     for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):
1901         if i != j or type(i) != type(j):
1902             if ((isinstance(i, UndefFunc) and isinstance(j, UndefFunc)) or
1903                 (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef))):
1904                 if i.class_key() != j.class_key():
1905                     return False
1906             else:
1907                 return False
1908     return True
1909 
1910 
1911 def _atomic(e, recursive=False):
1912     """Return atom-like quantities as far as substitution is
1913     concerned: Derivatives, Functions and Symbols. Don't
1914     return any 'atoms' that are inside such quantities unless
1915     they also appear outside, too, unless `recursive` is True.
1916 
1917     Examples
1918     ========
1919 
1920     >>> from sympy import Derivative, Function, cos
1921     >>> from sympy.abc import x, y
1922     >>> from sympy.core.basic import _atomic
1923     >>> f = Function('f')
1924     >>> _atomic(x + y)
1925     {x, y}
1926     >>> _atomic(x + f(y))
1927     {x, f(y)}
1928     >>> _atomic(Derivative(f(x), x) + cos(x) + y)
1929     {y, cos(x), Derivative(f(x), x)}
1930 
1931     """
1932     from sympy import Derivative, Function, Symbol
1933     pot = preorder_traversal(e)
1934     seen = set()
1935     if isinstance(e, Basic):
1936         free = getattr(e, "free_symbols", None)
1937         if free is None:
1938             return {e}
1939     else:
1940         return set()
1941     atoms = set()
1942     for p in pot:
1943         if p in seen:
1944             pot.skip()
1945             continue
1946         seen.add(p)
1947         if isinstance(p, Symbol) and p in free:
1948             atoms.add(p)
1949         elif isinstance(p, (Derivative, Function)):
1950             if not recursive:
1951                 pot.skip()
1952             atoms.add(p)
1953     return atoms
1954 
1955 
1956 class preorder_traversal(Iterator):
1957     """
1958     Do a pre-order traversal of a tree.
1959 
1960     This iterator recursively yields nodes that it has visited in a pre-order
1961     fashion. That is, it yields the current node then descends through the
1962     tree breadth-first to yield all of a node's children's pre-order
1963     traversal.
1964 
1965 
1966     For an expression, the order of the traversal depends on the order of
1967     .args, which in many cases can be arbitrary.
1968 
1969     Parameters
1970     ==========
1971     node : sympy expression
1972         The expression to traverse.
1973     keys : (default None) sort key(s)
1974         The key(s) used to sort args of Basic objects. When None, args of Basic
1975         objects are processed in arbitrary order. If key is defined, it will
1976         be passed along to ordered() as the only key(s) to use to sort the
1977         arguments; if ``key`` is simply True then the default keys of ordered
1978         will be used.
1979 
1980     Yields
1981     ======
1982     subtree : sympy expression
1983         All of the subtrees in the tree.
1984 
1985     Examples
1986     ========
1987 
1988     >>> from sympy import symbols
1989     >>> from sympy.core.basic import preorder_traversal
1990     >>> x, y, z = symbols('x y z')
1991 
1992     The nodes are returned in the order that they are encountered unless key
1993     is given; simply passing key=True will guarantee that the traversal is
1994     unique.
1995 
1996     >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP
1997     [z*(x + y), z, x + y, y, x]
1998     >>> list(preorder_traversal((x + y)*z, keys=True))
1999     [z*(x + y), z, x + y, x, y]
2000 
2001     """
2002     def __init__(self, node, keys=None):
2003         self._skip_flag = False
2004         self._pt = self._preorder_traversal(node, keys)
2005 
2006     def _preorder_traversal(self, node, keys):
2007         yield node
2008         if self._skip_flag:
2009             self._skip_flag = False
2010             return
2011         if isinstance(node, Basic):
2012             if not keys and hasattr(node, '_argset'):
2013                 # LatticeOp keeps args as a set. We should use this if we
2014                 # don't care about the order, to prevent unnecessary sorting.
2015                 args = node._argset
2016             else:
2017                 args = node.args
2018             if keys:
2019                 if keys != True:
2020                     args = ordered(args, keys, default=False)
2021                 else:
2022                     args = ordered(args)
2023             for arg in args:
2024                 for subtree in self._preorder_traversal(arg, keys):
2025                     yield subtree
2026         elif iterable(node):
2027             for item in node:
2028                 for subtree in self._preorder_traversal(item, keys):
2029                     yield subtree
2030 
2031     def skip(self):
2032         """
2033         Skip yielding current node's (last yielded node's) subtrees.
2034 
2035         Examples
2036         ========
2037 
2038         >>> from sympy.core import symbols
2039         >>> from sympy.core.basic import preorder_traversal
2040         >>> x, y, z = symbols('x y z')
2041         >>> pt = preorder_traversal((x+y*z)*z)
2042         >>> for i in pt:
2043         ...     print(i)
2044         ...     if i == x+y*z:
2045         ...             pt.skip()
2046         z*(x + y*z)
2047         z
2048         x + y*z
2049         """
2050         self._skip_flag = True
2051 
2052     def __next__(self):
2053         return next(self._pt)
2054 
2055     def __iter__(self):
2056         return self
2057 
2058 
2059 def _make_find_query(query):
2060     """Convert the argument of Basic.find() into a callable"""
2061     try:
2062         query = sympify(query)
2063     except SympifyError:
2064         pass
2065     if isinstance(query, type):
2066         return lambda expr: isinstance(expr, query)
2067     elif isinstance(query, Basic):
2068         return lambda expr: expr.match(query) is not None
2069     return query

</code><intended_behavior>The method should correctly evaluate or substitute expressions involving infinity, such as `(x + cos(x)).subs(x, oo)` and `(exp(x) + cos(x)).subs(x, oo)`. The intended behavior here is to ensure consistency in how expressions involving infinity are simplified or evaluated, possibly by refining how mathematical functions like `exp` and `cos` handle substitutions involving `oo`. This might involve checking if additional conditions or special handling for infinite substitutions need to be integrated into the `.subs()` method to accommodate the mathematical properties of these functions consistently.</intended_behavior>, <file>sympy/functions/elementary/exponential.py</file>
<class>exp</class>
<method>None</method>
<code>
189 class exp(ExpBase):
190     """
191     The exponential function, :math:`e^x`.
192 
193     See Also
194     ========
195 
196     log
197     """
198 
199     def fdiff(self, argindex=1):
200         """
201         Returns the first derivative of this function.
202         """
203         if argindex == 1:
204             return self
205         else:
206             raise ArgumentIndexError(self, argindex)
207 
208     def _eval_refine(self, assumptions):
209         from sympy.assumptions import ask, Q
210         arg = self.args[0]
211         if arg.is_Mul:
212             Ioo = S.ImaginaryUnit*S.Infinity
213             if arg in [Ioo, -Ioo]:
214                 return S.NaN
215 
216             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
217             if coeff:
218                 if ask(Q.integer(2*coeff)):
219                     if ask(Q.even(coeff)):
220                         return S.One
221                     elif ask(Q.odd(coeff)):
222                         return S.NegativeOne
223                     elif ask(Q.even(coeff + S.Half)):
224                         return -S.ImaginaryUnit
225                     elif ask(Q.odd(coeff + S.Half)):
226                         return S.ImaginaryUnit
227 
228     @classmethod
229     def eval(cls, arg):
230         from sympy.calculus import AccumBounds
231         from sympy.sets.setexpr import SetExpr
232         from sympy.matrices.matrices import MatrixBase
233         from sympy import logcombine
234         if arg.is_Number:
235             if arg is S.NaN:
236                 return S.NaN
237             elif arg.is_zero:
238                 return S.One
239             elif arg is S.One:
240                 return S.Exp1
241             elif arg is S.Infinity:
242                 return S.Infinity
243             elif arg is S.NegativeInfinity:
244                 return S.Zero
245         elif arg is S.ComplexInfinity:
246             return S.NaN
247         elif isinstance(arg, log):
248             return arg.args[0]
249         elif isinstance(arg, AccumBounds):
250             return AccumBounds(exp(arg.min), exp(arg.max))
251         elif isinstance(arg, SetExpr):
252             return arg._eval_func(cls)
253         elif arg.is_Mul:
254             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)
255             if coeff:
256                 if (2*coeff).is_integer:
257                     if coeff.is_even:
258                         return S.One
259                     elif coeff.is_odd:
260                         return S.NegativeOne
261                     elif (coeff + S.Half).is_even:
262                         return -S.ImaginaryUnit
263                     elif (coeff + S.Half).is_odd:
264                         return S.ImaginaryUnit
265                 elif coeff.is_Rational:
266                     ncoeff = coeff % 2 # restrict to [0, 2pi)
267                     if ncoeff > 1: # restrict to (-pi, pi]
268                         ncoeff -= 2
269                     if ncoeff != coeff:
270                         return cls(ncoeff*S.Pi*S.ImaginaryUnit)
271 
272             # Warning: code in risch.py will be very sensitive to changes
273             # in this (see DifferentialExtension).
274 
275             # look for a single log factor
276 
277             coeff, terms = arg.as_coeff_Mul()
278 
279             # but it can't be multiplied by oo
280             if coeff in [S.NegativeInfinity, S.Infinity]:
281                 return None
282 
283             coeffs, log_term = [coeff], None
284             for term in Mul.make_args(terms):
285                 term_ = logcombine(term)
286                 if isinstance(term_, log):
287                     if log_term is None:
288                         log_term = term_.args[0]
289                     else:
290                         return None
291                 elif term.is_comparable:
292                     coeffs.append(term)
293                 else:
294                     return None
295 
296             return log_term**Mul(*coeffs) if log_term else None
297 
298         elif arg.is_Add:
299             out = []
300             add = []
301             argchanged = False
302             for a in arg.args:
303                 if a is S.One:
304                     add.append(a)
305                     continue
306                 newa = cls(a)
307                 if isinstance(newa, cls):
308                     if newa.args[0] != a:
309                         add.append(newa.args[0])
310                         argchanged = True
311                     else:
312                         add.append(a)
313                 else:
314                     out.append(newa)
315             if out or argchanged:
316                 return Mul(*out)*cls(Add(*add), evaluate=False)
317 
318         elif isinstance(arg, MatrixBase):
319             return arg.exp()
320 
321         if arg.is_zero:
322             return S.One
323 
324     @property
325     def base(self):
326         """
327         Returns the base of the exponential function.
328         """
329         return S.Exp1
330 
331     @staticmethod
332     @cacheit
333     def taylor_term(n, x, *previous_terms):
334         """
335         Calculates the next term in the Taylor series expansion.
336         """
337         if n < 0:
338             return S.Zero
339         if n == 0:
340             return S.One
341         x = sympify(x)
342         if previous_terms:
343             p = previous_terms[-1]
344             if p is not None:
345                 return p * x / n
346         return x**n/factorial(n)
347 
348     def as_real_imag(self, deep=True, **hints):
349         """
350         Returns this function as a 2-tuple representing a complex number.
351 
352         Examples
353         ========
354 
355         >>> from sympy import I
356         >>> from sympy.abc import x
357         >>> from sympy.functions import exp
358         >>> exp(x).as_real_imag()
359         (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))
360         >>> exp(1).as_real_imag()
361         (E, 0)
362         >>> exp(I).as_real_imag()
363         (cos(1), sin(1))
364         >>> exp(1+I).as_real_imag()
365         (E*cos(1), E*sin(1))
366 
367         See Also
368         ========
369 
370         sympy.functions.elementary.complexes.re
371         sympy.functions.elementary.complexes.im
372         """
373         import sympy
374         re, im = self.args[0].as_real_imag()
375         if deep:
376             re = re.expand(deep, **hints)
377             im = im.expand(deep, **hints)
378         cos, sin = sympy.cos(im), sympy.sin(im)
379         return (exp(re)*cos, exp(re)*sin)
380 
381     def _eval_subs(self, old, new):
382         # keep processing of power-like args centralized in Pow
383         if old.is_Pow:  # handle (exp(3*log(x))).subs(x**2, z) -> z**(3/2)
384             old = exp(old.exp*log(old.base))
385         elif old is S.Exp1 and new.is_Function:
386             old = exp
387         if isinstance(old, exp) or old is S.Exp1:
388             f = lambda a: Pow(*a.as_base_exp(), evaluate=False) if (
389                 a.is_Pow or isinstance(a, exp)) else a
390             return Pow._eval_subs(f(self), f(old), new)
391 
392         if old is exp and not new.is_Function:
393             return new**self.exp._subs(old, new)
394         return Function._eval_subs(self, old, new)
395 
396     def _eval_is_extended_real(self):
397         if self.args[0].is_extended_real:
398             return True
399         elif self.args[0].is_imaginary:
400             arg2 = -S(2) * S.ImaginaryUnit * self.args[0] / S.Pi
401             return arg2.is_even
402 
403     def _eval_is_complex(self):
404         def complex_extended_negative(arg):
405             yield arg.is_complex
406             yield arg.is_extended_negative
407         return fuzzy_or(complex_extended_negative(self.args[0]))
408 
409     def _eval_is_algebraic(self):
410         s = self.func(*self.args)
411         if s.func == self.func:
412             if fuzzy_not(self.exp.is_zero):
413                 if self.exp.is_algebraic:
414                     return False
415                 elif (self.exp/S.Pi).is_rational:
416                     return False
417         else:
418             return s.is_algebraic
419 
420     def _eval_is_extended_positive(self):
421         if self.args[0].is_extended_real:
422             return not self.args[0] is S.NegativeInfinity
423         elif self.args[0].is_imaginary:
424             arg2 = -S.ImaginaryUnit * self.args[0] / S.Pi
425             return arg2.is_even
426 
427     def _eval_nseries(self, x, n, logx):
428         # NOTE Please see the comment at the beginning of this file, labelled
429         #      IMPORTANT.
430         from sympy import limit, oo, Order, powsimp, Wild, expand_complex
431         arg = self.args[0]
432         arg_series = arg._eval_nseries(x, n=n, logx=logx)
433         if arg_series.is_Order:
434             return 1 + arg_series
435         arg0 = limit(arg_series.removeO(), x, 0)
436         if arg0 in [-oo, oo]:
437             return self
438         t = Dummy("t")
439         exp_series = exp(t)._taylor(t, n)
440         o = exp_series.getO()
441         exp_series = exp_series.removeO()
442         r = exp(arg0)*exp_series.subs(t, arg_series - arg0)
443         r += Order(o.expr.subs(t, (arg_series - arg0)), x)
444         r = r.expand()
445         r = powsimp(r, deep=True, combine='exp')
446         # powsimp may introduce unexpanded (-1)**Rational; see PR #17201
447         simplerat = lambda x: x.is_Rational and x.q in [3, 4, 6]
448         w = Wild('w', properties=[simplerat])
449         r = r.replace((-1)**w, expand_complex((-1)**w))
450         return r
451 
452     def _taylor(self, x, n):
453         from sympy import Order
454         l = []
455         g = None
456         for i in range(n):
457             g = self.taylor_term(i, self.args[0], g)
458             g = g.nseries(x, n=n)
459             l.append(g)
460         return Add(*l) + Order(x**n, x)
461 
462     def _eval_as_leading_term(self, x):
463         from sympy import Order
464         arg = self.args[0]
465         if arg.is_Add:
466             return Mul(*[exp(f).as_leading_term(x) for f in arg.args])
467         arg_1 = arg.as_leading_term(x)
468         if Order(x, x).contains(arg_1):
469             return S.One
470         if Order(1, x).contains(arg_1):
471             return exp(arg_1)
472         ####################################################
473         # The correct result here should be 'None'.        #
474         # Indeed arg in not bounded as x tends to 0.       #
475         # Consequently the series expansion does not admit #
476         # the leading term.                                #
477         # For compatibility reasons, the return value here #
478         # is the original function, i.e. exp(arg),         #
479         # instead of None.                                 #
480         ####################################################
481         return exp(arg)
482 
483     def _eval_rewrite_as_sin(self, arg, **kwargs):
484         from sympy import sin
485         I = S.ImaginaryUnit
486         return sin(I*arg + S.Pi/2) - I*sin(I*arg)
487 
488     def _eval_rewrite_as_cos(self, arg, **kwargs):
489         from sympy import cos
490         I = S.ImaginaryUnit
491         return cos(I*arg) + I*cos(I*arg + S.Pi/2)
492 
493     def _eval_rewrite_as_tanh(self, arg, **kwargs):
494         from sympy import tanh
495         return (1 + tanh(arg/2))/(1 - tanh(arg/2))
496 
497     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
498         from sympy.functions.elementary.trigonometric import sin, cos
499         if arg.is_Mul:
500             coeff = arg.coeff(S.Pi*S.ImaginaryUnit)
501             if coeff and coeff.is_number:
502                 cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)
503                 if not isinstance(cosine, cos) and not isinstance (sine, sin):
504                     return cosine + S.ImaginaryUnit*sine
505 
506     def _eval_rewrite_as_Pow(self, arg, **kwargs):
507         if arg.is_Mul:
508             logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]
509             if logs:
510                 return Pow(logs[0].args[0], arg.coeff(logs[0]))

</code><intended_behavior>Ensure that the `exp` function's behavior when its variable tends towards infinity is consistent with mathematical principles and compatible with how the `.subs()` method processes such cases. Specifically, when `exp(x)` is evaluated at `x = oo`, the result should reflect the expected mathematical outcome (i.e., `oo`), and this evaluation should be handled in a manner consistent with the behavior observed in other similar expressions.</intended_behavior>, <file>sympy/functions/elementary/trigonometric.py</file>
<class>cos</class>
<method>None</method>
<code>
494 class cos(TrigonometricFunction):
495     """
496     The cosine function.
497 
498     Returns the cosine of x (measured in radians).
499 
500     Notes
501     =====
502 
503     See :func:`sin` for notes about automatic evaluation.
504 
505     Examples
506     ========
507 
508     >>> from sympy import cos, pi
509     >>> from sympy.abc import x
510     >>> cos(x**2).diff(x)
511     -2*x*sin(x**2)
512     >>> cos(1).diff(x)
513     0
514     >>> cos(pi)
515     -1
516     >>> cos(pi/2)
517     0
518     >>> cos(2*pi/3)
519     -1/2
520     >>> cos(pi/12)
521     sqrt(2)/4 + sqrt(6)/4
522 
523     See Also
524     ========
525 
526     sin, csc, sec, tan, cot
527     asin, acsc, acos, asec, atan, acot, atan2
528 
529     References
530     ==========
531 
532     .. [1] https://en.wikipedia.org/wiki/Trigonometric_functions
533     .. [2] http://dlmf.nist.gov/4.14
534     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos
535 
536     """
537 
538     def period(self, symbol=None):
539         return self._period(2*pi, symbol)
540 
541     def fdiff(self, argindex=1):
542         if argindex == 1:
543             return -sin(self.args[0])
544         else:
545             raise ArgumentIndexError(self, argindex)
546 
547     @classmethod
548     def eval(cls, arg):
549         from sympy.functions.special.polynomials import chebyshevt
550         from sympy.calculus.util import AccumBounds
551         from sympy.sets.setexpr import SetExpr
552         if arg.is_Number:
553             if arg is S.NaN:
554                 return S.NaN
555             elif arg.is_zero:
556                 return S.One
557             elif arg is S.Infinity or arg is S.NegativeInfinity:
558                 # In this case it is better to return AccumBounds(-1, 1)
559                 # rather than returning S.NaN, since AccumBounds(-1, 1)
560                 # preserves the information that sin(oo) is between
561                 # -1 and 1, where S.NaN does not do that.
562                 return AccumBounds(-1, 1)
563 
564         if arg is S.ComplexInfinity:
565             return S.NaN
566 
567         if isinstance(arg, AccumBounds):
568             return sin(arg + S.Pi/2)
569         elif isinstance(arg, SetExpr):
570             return arg._eval_func(cls)
571 
572         if arg.could_extract_minus_sign():
573             return cls(-arg)
574 
575         i_coeff = arg.as_coefficient(S.ImaginaryUnit)
576         if i_coeff is not None:
577             return cosh(i_coeff)
578 
579         pi_coeff = _pi_coeff(arg)
580         if pi_coeff is not None:
581             if pi_coeff.is_integer:
582                 return (S.NegativeOne)**pi_coeff
583 
584             if (2*pi_coeff).is_integer:
585                 # is_even-case handled above as then pi_coeff.is_integer,
586                 # so check if known to be not even
587                 if pi_coeff.is_even is False:
588                     return S.Zero
589 
590             if not pi_coeff.is_Rational:
591                 narg = pi_coeff*S.Pi
592                 if narg != arg:
593                     return cls(narg)
594                 return None
595 
596             # cosine formula #####################
597             # https://github.com/sympy/sympy/issues/6048
598             # explicit calculations are performed for
599             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120
600             # Some other exact values like cos(k pi/240) can be
601             # calculated using a partial-fraction decomposition
602             # by calling cos( X ).rewrite(sqrt)
603             cst_table_some = {
604                 3: S.Half,
605                 5: (sqrt(5) + 1)/4,
606             }
607             if pi_coeff.is_Rational:
608                 q = pi_coeff.q
609                 p = pi_coeff.p % (2*q)
610                 if p > q:
611                     narg = (pi_coeff - 1)*S.Pi
612                     return -cls(narg)
613                 if 2*p > q:
614                     narg = (1 - pi_coeff)*S.Pi
615                     return -cls(narg)
616 
617                 # If nested sqrt's are worse than un-evaluation
618                 # you can require q to be in (1, 2, 3, 4, 6, 12)
619                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return
620                 # expressions with 2 or fewer sqrt nestings.
621                 table2 = {
622                     12: (3, 4),
623                     20: (4, 5),
624                     30: (5, 6),
625                     15: (6, 10),
626                     24: (6, 8),
627                     40: (8, 10),
628                     60: (20, 30),
629                     120: (40, 60)
630                     }
631                 if q in table2:
632                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]
633                     nvala, nvalb = cls(a), cls(b)
634                     if None == nvala or None == nvalb:
635                         return None
636                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)
637 
638                 if q > 12:
639                     return None
640 
641                 if q in cst_table_some:
642                     cts = cst_table_some[pi_coeff.q]
643                     return chebyshevt(pi_coeff.p, cts).expand()
644 
645                 if 0 == q % 2:
646                     narg = (pi_coeff*2)*S.Pi
647                     nval = cls(narg)
648                     if None == nval:
649                         return None
650                     x = (2*pi_coeff + 1)/2
651                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))
652                     return sign_cos*sqrt( (1 + nval)/2 )
653             return None
654 
655         if arg.is_Add:
656             x, m = _peeloff_pi(arg)
657             if m:
658                 return cos(m)*cos(x) - sin(m)*sin(x)
659 
660         if arg.is_zero:
661             return S.One
662 
663         if isinstance(arg, acos):
664             return arg.args[0]
665 
666         if isinstance(arg, atan):
667             x = arg.args[0]
668             return 1/sqrt(1 + x**2)
669 
670         if isinstance(arg, atan2):
671             y, x = arg.args
672             return x/sqrt(x**2 + y**2)
673 
674         if isinstance(arg, asin):
675             x = arg.args[0]
676             return sqrt(1 - x ** 2)
677 
678         if isinstance(arg, acot):
679             x = arg.args[0]
680             return 1/sqrt(1 + 1/x**2)
681 
682         if isinstance(arg, acsc):
683             x = arg.args[0]
684             return sqrt(1 - 1/x**2)
685 
686         if isinstance(arg, asec):
687             x = arg.args[0]
688             return 1/x
689 
690     @staticmethod
691     @cacheit
692     def taylor_term(n, x, *previous_terms):
693         if n < 0 or n % 2 == 1:
694             return S.Zero
695         else:
696             x = sympify(x)
697 
698             if len(previous_terms) > 2:
699                 p = previous_terms[-2]
700                 return -p*x**2/(n*(n - 1))
701             else:
702                 return (-1)**(n//2)*x**(n)/factorial(n)
703 
704     def _eval_rewrite_as_exp(self, arg, **kwargs):
705         I = S.ImaginaryUnit
706         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):
707             arg = arg.func(arg.args[0]).rewrite(exp)
708         return (exp(arg*I) + exp(-arg*I))/2
709 
710     def _eval_rewrite_as_Pow(self, arg, **kwargs):
711         if isinstance(arg, log):
712             I = S.ImaginaryUnit
713             x = arg.args[0]
714             return x**I/2 + x**-I/2
715 
716     def _eval_rewrite_as_sin(self, arg, **kwargs):
717         return sin(arg + S.Pi/2, evaluate=False)
718 
719     def _eval_rewrite_as_tan(self, arg, **kwargs):
720         tan_half = tan(S.Half*arg)**2
721         return (1 - tan_half)/(1 + tan_half)
722 
723     def _eval_rewrite_as_sincos(self, arg, **kwargs):
724         return sin(arg)*cos(arg)/sin(arg)
725 
726     def _eval_rewrite_as_cot(self, arg, **kwargs):
727         cot_half = cot(S.Half*arg)**2
728         return (cot_half - 1)/(cot_half + 1)
729 
730     def _eval_rewrite_as_pow(self, arg, **kwargs):
731         return self._eval_rewrite_as_sqrt(arg)
732 
733     def _eval_rewrite_as_sqrt(self, arg, **kwargs):
734         from sympy.functions.special.polynomials import chebyshevt
735 
736         def migcdex(x):
737             # recursive calcuation of gcd and linear combination
738             # for a sequence of integers.
739             # Given  (x1, x2, x3)
740             # Returns (y1, y1, y3, g)
741             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0
742             # Note, that this is only one such linear combination.
743             if len(x) == 1:
744                 return (1, x[0])
745             if len(x) == 2:
746                 return igcdex(x[0], x[-1])
747             g = migcdex(x[1:])
748             u, v, h = igcdex(x[0], g[-1])
749             return tuple([u] + [v*i for i in g[0:-1] ] + [h])
750 
751         def ipartfrac(r, factors=None):
752             from sympy.ntheory import factorint
753             if isinstance(r, int):
754                 return r
755             if not isinstance(r, Rational):
756                 raise TypeError("r is not rational")
757             n = r.q
758             if 2 > r.q*r.q:
759                 return r.q
760 
761             if None == factors:
762                 a = [n//x**y for x, y in factorint(r.q).items()]
763             else:
764                 a = [n//x for x in factors]
765             if len(a) == 1:
766                 return [ r ]
767             h = migcdex(a)
768             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]
769             assert r == sum(ans)
770             return ans
771         pi_coeff = _pi_coeff(arg)
772         if pi_coeff is None:
773             return None
774 
775         if pi_coeff.is_integer:
776             # it was unevaluated
777             return self.func(pi_coeff*S.Pi)
778 
779         if not pi_coeff.is_Rational:
780             return None
781 
782         def _cospi257():
783             """ Express cos(pi/257) explicitly as a function of radicals
784                 Based upon the equations in
785                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals
786                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt
787             """
788             def f1(a, b):
789                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2
790 
791             def f2(a, b):
792                 return (a - sqrt(a**2 + b))/2
793 
794             t1, t2 = f1(-1, 256)
795             z1, z3 = f1(t1, 64)
796             z2, z4 = f1(t2, 64)
797             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))
798             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))
799             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))
800             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))
801             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))
802             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))
803             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))
804             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))
805             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))
806             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))
807             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))
808             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))
809             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))
810             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))
811             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))
812             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))
813             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))
814             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))
815             u1 = -f2(-v1, -4*(v2 + v3))
816             u2 = -f2(-v4, -4*(v5 + v6))
817             w1 = -2*f2(-u1, -4*u2)
818             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)
819 
820         cst_table_some = {
821             3: S.Half,
822             5: (sqrt(5) + 1)/4,
823             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +
824                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))
825                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),
826             257: _cospi257()
827             # 65537 is the only other known Fermat prime and the very
828             # large expression is intentionally omitted from SymPy; see
829             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt
830         }
831 
832         def _fermatCoords(n):
833             # if n can be factored in terms of Fermat primes with
834             # multiplicity of each being 1, return those primes, else
835             # False
836             primes = []
837             for p_i in cst_table_some:
838                 quotient, remainder = divmod(n, p_i)
839                 if remainder == 0:
840                     n = quotient
841                     primes.append(p_i)
842                     if n == 1:
843                         return tuple(primes)
844             return False
845 
846         if pi_coeff.q in cst_table_some:
847             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])
848             if pi_coeff.q < 257:
849                 rv = rv.expand()
850             return rv
851 
852         if not pi_coeff.q % 2:  # recursively remove factors of 2
853             pico2 = pi_coeff*2
854             nval = cos(pico2*S.Pi).rewrite(sqrt)
855             x = (pico2 + 1)/2
856             sign_cos = -1 if int(x) % 2 else 1
857             return sign_cos*sqrt( (1 + nval)/2 )
858 
859         FC = _fermatCoords(pi_coeff.q)
860         if FC:
861             decomp = ipartfrac(pi_coeff, FC)
862             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
863             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
864             return pcls.rewrite(sqrt)
865         else:
866             decomp = ipartfrac(pi_coeff)
867             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]
868             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)
869             return pcls
870 
871     def _eval_rewrite_as_sec(self, arg, **kwargs):
872         return 1/sec(arg)
873 
874     def _eval_rewrite_as_csc(self, arg, **kwargs):
875         return 1/sec(arg).rewrite(csc)
876 
877     def _eval_conjugate(self):
878         return self.func(self.args[0].conjugate())
879 
880     def as_real_imag(self, deep=True, **hints):
881         re, im = self._as_real_imag(deep=deep, **hints)
882         return (cos(re)*cosh(im), -sin(re)*sinh(im))
883 
884     def _eval_expand_trig(self, **hints):
885         from sympy.functions.special.polynomials import chebyshevt
886         arg = self.args[0]
887         x = None
888         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms
889             x, y = arg.as_two_terms()
890             sx = sin(x, evaluate=False)._eval_expand_trig()
891             sy = sin(y, evaluate=False)._eval_expand_trig()
892             cx = cos(x, evaluate=False)._eval_expand_trig()
893             cy = cos(y, evaluate=False)._eval_expand_trig()
894             return cx*cy - sx*sy
895         else:
896             coeff, terms = arg.as_coeff_Mul(rational=True)
897             if coeff.is_Integer:
898                 return chebyshevt(coeff, cos(terms))
899             pi_coeff = _pi_coeff(arg)
900             if pi_coeff is not None:
901                 if pi_coeff.is_Rational:
902                     return self.rewrite(sqrt)
903         return cos(arg)
904 
905     def _eval_as_leading_term(self, x):
906         from sympy import Order
907         arg = self.args[0].as_leading_term(x)
908 
909         if x in arg.free_symbols and Order(1, x).contains(arg):
910             return S.One
911         else:
912             return self.func(arg)
913 
914     def _eval_is_extended_real(self):
915         if self.args[0].is_extended_real:
916             return True
917 
918     def _eval_is_finite(self):
919         arg = self.args[0]
920 
921         if arg.is_extended_real:
922             return True
923 
924     def _eval_is_complex(self):
925         if self.args[0].is_extended_real \
926             or self.args[0].is_complex:
927             return True

</code><intended_behavior>For `cos(x)` where `x` is substituted with `oo`, it's not about altering the `cos` function's inherent behavior at infinity but ensuring that its handling within expressions substituted at infinity is consistent. Since `cos(x)` doesn't have a limit as `x` approaches infinity, the substitution might either need to prevent simplistic numerical evaluations or work cohesively with constructs like `AccumBounds` to present a result that accurately represents the function's behavior at infinity.</intended_behavior>]
2025-10-16 03:14:50.160 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 03:14:50.160 | INFO     | Search-only: skipping patch selection
2025-10-16 03:14:50.240 | INFO     | Task sympy__sympy-18478 completed successfully.
2025-10-16 03:14:50.241 | INFO     | No patch generated. You can try running ACR again.
