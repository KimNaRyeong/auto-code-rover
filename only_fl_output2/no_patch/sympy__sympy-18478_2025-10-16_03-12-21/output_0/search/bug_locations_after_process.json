[
    {
        "rel_file_path": "sympy/core/basic.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/basic.py",
        "start": 1,
        "end": 2069,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Base class for all the objects in SymPy\"\"\"\n2 from __future__ import print_function, division\n3 from collections import defaultdict\n4 from itertools import chain, zip_longest\n5 \n6 from .assumptions import BasicMeta, ManagedProperties\n7 from .cache import cacheit\n8 from .sympify import _sympify, sympify, SympifyError\n9 from .compatibility import iterable, Iterator, ordered, Mapping\n10 from .singleton import S\n11 \n12 from inspect import getmro\n13 \n14 \n15 def as_Basic(expr):\n16     \"\"\"Return expr as a Basic instance using strict sympify\n17     or raise a TypeError; this is just a wrapper to _sympify,\n18     raising a TypeError instead of a SympifyError.\"\"\"\n19     from sympy.utilities.misc import func_name\n20     try:\n21         return _sympify(expr)\n22     except SympifyError:\n23         raise TypeError(\n24             'Argument must be a Basic object, not `%s`' % func_name(\n25             expr))\n26 \n27 \n28 class Basic(metaclass=ManagedProperties):\n29     \"\"\"\n30     Base class for all objects in SymPy.\n31 \n32     Conventions:\n33 \n34     1) Always use ``.args``, when accessing parameters of some instance:\n35 \n36     >>> from sympy import cot\n37     >>> from sympy.abc import x, y\n38 \n39     >>> cot(x).args\n40     (x,)\n41 \n42     >>> cot(x).args[0]\n43     x\n44 \n45     >>> (x*y).args\n46     (x, y)\n47 \n48     >>> (x*y).args[1]\n49     y\n50 \n51 \n52     2) Never use internal methods or variables (the ones prefixed with ``_``):\n53 \n54     >>> cot(x)._args    # do not use this, use cot(x).args instead\n55     (x,)\n56 \n57     \"\"\"\n58     __slots__ = ('_mhash',              # hash value\n59                  '_args',               # arguments\n60                  '_assumptions'\n61                 )\n62 \n63     # To be overridden with True in the appropriate subclasses\n64     is_number = False\n65     is_Atom = False\n66     is_Symbol = False\n67     is_symbol = False\n68     is_Indexed = False\n69     is_Dummy = False\n70     is_Wild = False\n71     is_Function = False\n72     is_Add = False\n73     is_Mul = False\n74     is_Pow = False\n75     is_Number = False\n76     is_Float = False\n77     is_Rational = False\n78     is_Integer = False\n79     is_NumberSymbol = False\n80     is_Order = False\n81     is_Derivative = False\n82     is_Piecewise = False\n83     is_Poly = False\n84     is_AlgebraicNumber = False\n85     is_Relational = False\n86     is_Equality = False\n87     is_Boolean = False\n88     is_Not = False\n89     is_Matrix = False\n90     is_Vector = False\n91     is_Point = False\n92     is_MatAdd = False\n93     is_MatMul = False\n94 \n95     def __new__(cls, *args):\n96         obj = object.__new__(cls)\n97         obj._assumptions = cls.default_assumptions\n98         obj._mhash = None  # will be set by __hash__ method.\n99 \n100         obj._args = args  # all items in args must be Basic objects\n101         return obj\n102 \n103     def copy(self):\n104         return self.func(*self.args)\n105 \n106     def __reduce_ex__(self, proto):\n107         \"\"\" Pickling support.\"\"\"\n108         return type(self), self.__getnewargs__(), self.__getstate__()\n109 \n110     def __getnewargs__(self):\n111         return self.args\n112 \n113     def __getstate__(self):\n114         return {}\n115 \n116     def __setstate__(self, state):\n117         for k, v in state.items():\n118             setattr(self, k, v)\n119 \n120     def __hash__(self):\n121         # hash cannot be cached using cache_it because infinite recurrence\n122         # occurs as hash is needed for setting cache dictionary keys\n123         h = self._mhash\n124         if h is None:\n125             h = hash((type(self).__name__,) + self._hashable_content())\n126             self._mhash = h\n127         return h\n128 \n129     def _hashable_content(self):\n130         \"\"\"Return a tuple of information about self that can be used to\n131         compute the hash. If a class defines additional attributes,\n132         like ``name`` in Symbol, then this method should be updated\n133         accordingly to return such relevant attributes.\n134 \n135         Defining more than _hashable_content is necessary if __eq__ has\n136         been defined by a class. See note about this in Basic.__eq__.\"\"\"\n137         return self._args\n138 \n139     @property\n140     def assumptions0(self):\n141         \"\"\"\n142         Return object `type` assumptions.\n143 \n144         For example:\n145 \n146           Symbol('x', real=True)\n147           Symbol('x', integer=True)\n148 \n149         are different objects. In other words, besides Python type (Symbol in\n150         this case), the initial assumptions are also forming their typeinfo.\n151 \n152         Examples\n153         ========\n154 \n155         >>> from sympy import Symbol\n156         >>> from sympy.abc import x\n157         >>> x.assumptions0\n158         {'commutative': True}\n159         >>> x = Symbol(\"x\", positive=True)\n160         >>> x.assumptions0\n161         {'commutative': True, 'complex': True, 'extended_negative': False,\n162          'extended_nonnegative': True, 'extended_nonpositive': False,\n163          'extended_nonzero': True, 'extended_positive': True, 'extended_real':\n164          True, 'finite': True, 'hermitian': True, 'imaginary': False,\n165          'infinite': False, 'negative': False, 'nonnegative': True,\n166          'nonpositive': False, 'nonzero': True, 'positive': True, 'real':\n167          True, 'zero': False}\n168         \"\"\"\n169         return {}\n170 \n171     def compare(self, other):\n172         \"\"\"\n173         Return -1, 0, 1 if the object is smaller, equal, or greater than other.\n174 \n175         Not in the mathematical sense. If the object is of a different type\n176         from the \"other\" then their classes are ordered according to\n177         the sorted_classes list.\n178 \n179         Examples\n180         ========\n181 \n182         >>> from sympy.abc import x, y\n183         >>> x.compare(y)\n184         -1\n185         >>> x.compare(x)\n186         0\n187         >>> y.compare(x)\n188         1\n189 \n190         \"\"\"\n191         # all redefinitions of __cmp__ method should start with the\n192         # following lines:\n193         if self is other:\n194             return 0\n195         n1 = self.__class__\n196         n2 = other.__class__\n197         c = (n1 > n2) - (n1 < n2)\n198         if c:\n199             return c\n200         #\n201         st = self._hashable_content()\n202         ot = other._hashable_content()\n203         c = (len(st) > len(ot)) - (len(st) < len(ot))\n204         if c:\n205             return c\n206         for l, r in zip(st, ot):\n207             l = Basic(*l) if isinstance(l, frozenset) else l\n208             r = Basic(*r) if isinstance(r, frozenset) else r\n209             if isinstance(l, Basic):\n210                 c = l.compare(r)\n211             else:\n212                 c = (l > r) - (l < r)\n213             if c:\n214                 return c\n215         return 0\n216 \n217     @staticmethod\n218     def _compare_pretty(a, b):\n219         from sympy.series.order import Order\n220         if isinstance(a, Order) and not isinstance(b, Order):\n221             return 1\n222         if not isinstance(a, Order) and isinstance(b, Order):\n223             return -1\n224 \n225         if a.is_Rational and b.is_Rational:\n226             l = a.p * b.q\n227             r = b.p * a.q\n228             return (l > r) - (l < r)\n229         else:\n230             from sympy.core.symbol import Wild\n231             p1, p2, p3 = Wild(\"p1\"), Wild(\"p2\"), Wild(\"p3\")\n232             r_a = a.match(p1 * p2**p3)\n233             if r_a and p3 in r_a:\n234                 a3 = r_a[p3]\n235                 r_b = b.match(p1 * p2**p3)\n236                 if r_b and p3 in r_b:\n237                     b3 = r_b[p3]\n238                     c = Basic.compare(a3, b3)\n239                     if c != 0:\n240                         return c\n241 \n242         return Basic.compare(a, b)\n243 \n244     @classmethod\n245     def fromiter(cls, args, **assumptions):\n246         \"\"\"\n247         Create a new object from an iterable.\n248 \n249         This is a convenience function that allows one to create objects from\n250         any iterable, without having to convert to a list or tuple first.\n251 \n252         Examples\n253         ========\n254 \n255         >>> from sympy import Tuple\n256         >>> Tuple.fromiter(i for i in range(5))\n257         (0, 1, 2, 3, 4)\n258 \n259         \"\"\"\n260         return cls(*tuple(args), **assumptions)\n261 \n262     @classmethod\n263     def class_key(cls):\n264         \"\"\"Nice order of classes. \"\"\"\n265         return 5, 0, cls.__name__\n266 \n267     @cacheit\n268     def sort_key(self, order=None):\n269         \"\"\"\n270         Return a sort key.\n271 \n272         Examples\n273         ========\n274 \n275         >>> from sympy.core import S, I\n276 \n277         >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())\n278         [1/2, -I, I]\n279 \n280         >>> S(\"[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]\")\n281         [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]\n282         >>> sorted(_, key=lambda x: x.sort_key())\n283         [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]\n284 \n285         \"\"\"\n286 \n287         # XXX: remove this when issue 5169 is fixed\n288         def inner_key(arg):\n289             if isinstance(arg, Basic):\n290                 return arg.sort_key(order)\n291             else:\n292                 return arg\n293 \n294         args = self._sorted_args\n295         args = len(args), tuple([inner_key(arg) for arg in args])\n296         return self.class_key(), args, S.One.sort_key(), S.One\n297 \n298     def __eq__(self, other):\n299         \"\"\"Return a boolean indicating whether a == b on the basis of\n300         their symbolic trees.\n301 \n302         This is the same as a.compare(b) == 0 but faster.\n303 \n304         Notes\n305         =====\n306 \n307         If a class that overrides __eq__() needs to retain the\n308         implementation of __hash__() from a parent class, the\n309         interpreter must be told this explicitly by setting __hash__ =\n310         <ParentClass>.__hash__. Otherwise the inheritance of __hash__()\n311         will be blocked, just as if __hash__ had been explicitly set to\n312         None.\n313 \n314         References\n315         ==========\n316 \n317         from http://docs.python.org/dev/reference/datamodel.html#object.__hash__\n318         \"\"\"\n319         if self is other:\n320             return True\n321 \n322         tself = type(self)\n323         tother = type(other)\n324         if tself is not tother:\n325             try:\n326                 other = _sympify(other)\n327                 tother = type(other)\n328             except SympifyError:\n329                 return NotImplemented\n330 \n331             # As long as we have the ordering of classes (sympy.core),\n332             # comparing types will be slow in Python 2, because it uses\n333             # __cmp__. Until we can remove it\n334             # (https://github.com/sympy/sympy/issues/4269), we only compare\n335             # types in Python 2 directly if they actually have __ne__.\n336             if type(tself).__ne__ is not type.__ne__:\n337                 if tself != tother:\n338                     return False\n339             elif tself is not tother:\n340                 return False\n341 \n342         return self._hashable_content() == other._hashable_content()\n343 \n344     def __ne__(self, other):\n345         \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n346 \n347         this is the same as:\n348 \n349         ``a.compare(b) != 0``\n350 \n351         but faster\n352         \"\"\"\n353         return not self == other\n354 \n355     def dummy_eq(self, other, symbol=None):\n356         \"\"\"\n357         Compare two expressions and handle dummy symbols.\n358 \n359         Examples\n360         ========\n361 \n362         >>> from sympy import Dummy\n363         >>> from sympy.abc import x, y\n364 \n365         >>> u = Dummy('u')\n366 \n367         >>> (u**2 + 1).dummy_eq(x**2 + 1)\n368         True\n369         >>> (u**2 + 1) == (x**2 + 1)\n370         False\n371 \n372         >>> (u**2 + y).dummy_eq(x**2 + y, x)\n373         True\n374         >>> (u**2 + y).dummy_eq(x**2 + y, y)\n375         False\n376 \n377         \"\"\"\n378         s = self.as_dummy()\n379         o = _sympify(other)\n380         o = o.as_dummy()\n381 \n382         dummy_symbols = [i for i in s.free_symbols if i.is_Dummy]\n383 \n384         if len(dummy_symbols) == 1:\n385             dummy = dummy_symbols.pop()\n386         else:\n387             return s == o\n388 \n389         if symbol is None:\n390             symbols = o.free_symbols\n391 \n392             if len(symbols) == 1:\n393                 symbol = symbols.pop()\n394             else:\n395                 return s == o\n396 \n397         tmp = dummy.__class__()\n398 \n399         return s.subs(dummy, tmp) == o.subs(symbol, tmp)\n400 \n401     # Note, we always use the default ordering (lex) in __str__ and __repr__,\n402     # regardless of the global setting.  See issue 5487.\n403     def __repr__(self):\n404         \"\"\"Method to return the string representation.\n405 \n406         Return the expression as a string.\n407         \"\"\"\n408         from sympy.printing import sstr\n409         return sstr(self, order=None)\n410 \n411     def __str__(self):\n412         from sympy.printing import sstr\n413         return sstr(self, order=None)\n414 \n415     # We don't define _repr_png_ here because it would add a large amount of\n416     # data to any notebook containing SymPy expressions, without adding\n417     # anything useful to the notebook. It can still enabled manually, e.g.,\n418     # for the qtconsole, with init_printing().\n419     def _repr_latex_(self):\n420         \"\"\"\n421         IPython/Jupyter LaTeX printing\n422 \n423         To change the behavior of this (e.g., pass in some settings to LaTeX),\n424         use init_printing(). init_printing() will also enable LaTeX printing\n425         for built in numeric types like ints and container types that contain\n426         SymPy objects, like lists and dictionaries of expressions.\n427         \"\"\"\n428         from sympy.printing.latex import latex\n429         s = latex(self, mode='plain')\n430         return \"$\\\\displaystyle %s$\" % s\n431 \n432     _repr_latex_orig = _repr_latex_\n433 \n434     def atoms(self, *types):\n435         \"\"\"Returns the atoms that form the current object.\n436 \n437         By default, only objects that are truly atomic and can't\n438         be divided into smaller pieces are returned: symbols, numbers,\n439         and number symbols like I and pi. It is possible to request\n440         atoms of any type, however, as demonstrated below.\n441 \n442         Examples\n443         ========\n444 \n445         >>> from sympy import I, pi, sin\n446         >>> from sympy.abc import x, y\n447         >>> (1 + x + 2*sin(y + I*pi)).atoms()\n448         {1, 2, I, pi, x, y}\n449 \n450         If one or more types are given, the results will contain only\n451         those types of atoms.\n452 \n453         >>> from sympy import Number, NumberSymbol, Symbol\n454         >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n455         {x, y}\n456 \n457         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n458         {1, 2}\n459 \n460         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n461         {1, 2, pi}\n462 \n463         >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n464         {1, 2, I, pi}\n465 \n466         Note that I (imaginary unit) and zoo (complex infinity) are special\n467         types of number symbols and are not part of the NumberSymbol class.\n468 \n469         The type can be given implicitly, too:\n470 \n471         >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n472         {x, y}\n473 \n474         Be careful to check your assumptions when using the implicit option\n475         since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n476         of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n477         integers in an expression:\n478 \n479         >>> from sympy import S\n480         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n481         {1}\n482 \n483         >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n484         {1, 2}\n485 \n486         Finally, arguments to atoms() can select more than atomic atoms: any\n487         sympy type (loaded in core/__init__.py) can be listed as an argument\n488         and those types of \"atoms\" as found in scanning the arguments of the\n489         expression recursively:\n490 \n491         >>> from sympy import Function, Mul\n492         >>> from sympy.core.function import AppliedUndef\n493         >>> f = Function('f')\n494         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n495         {f(x), sin(y + I*pi)}\n496         >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n497         {f(x)}\n498 \n499         >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n500         {I*pi, 2*sin(y + I*pi)}\n501 \n502         \"\"\"\n503         if types:\n504             types = tuple(\n505                 [t if isinstance(t, type) else type(t) for t in types])\n506         else:\n507             types = (Atom,)\n508         result = set()\n509         for expr in preorder_traversal(self):\n510             if isinstance(expr, types):\n511                 result.add(expr)\n512         return result\n513 \n514     @property\n515     def free_symbols(self):\n516         \"\"\"Return from the atoms of self those which are free symbols.\n517 \n518         For most expressions, all symbols are free symbols. For some classes\n519         this is not true. e.g. Integrals use Symbols for the dummy variables\n520         which are bound variables, so Integral has a method to return all\n521         symbols except those. Derivative keeps track of symbols with respect\n522         to which it will perform a derivative; those are\n523         bound variables, too, so it has its own free_symbols method.\n524 \n525         Any other method that uses bound variables should implement a\n526         free_symbols method.\"\"\"\n527         return set().union(*[a.free_symbols for a in self.args])\n528 \n529     @property\n530     def expr_free_symbols(self):\n531         return set([])\n532 \n533     def as_dummy(self):\n534         \"\"\"Return the expression with any objects having structurally\n535         bound symbols replaced with unique, canonical symbols within\n536         the object in which they appear and having only the default\n537         assumption for commutativity being True.\n538 \n539         Examples\n540         ========\n541 \n542         >>> from sympy import Integral, Symbol\n543         >>> from sympy.abc import x, y\n544         >>> r = Symbol('r', real=True)\n545         >>> Integral(r, (r, x)).as_dummy()\n546         Integral(_0, (_0, x))\n547         >>> _.variables[0].is_real is None\n548         True\n549 \n550         Notes\n551         =====\n552 \n553         Any object that has structural dummy variables should have\n554         a property, `bound_symbols` that returns a list of structural\n555         dummy symbols of the object itself.\n556 \n557         Lambda and Subs have bound symbols, but because of how they\n558         are cached, they already compare the same regardless of their\n559         bound symbols:\n560 \n561         >>> from sympy import Lambda\n562         >>> Lambda(x, x + 1) == Lambda(y, y + 1)\n563         True\n564         \"\"\"\n565         def can(x):\n566             d = {i: i.as_dummy() for i in x.bound_symbols}\n567             # mask free that shadow bound\n568             x = x.subs(d)\n569             c = x.canonical_variables\n570             # replace bound\n571             x = x.xreplace(c)\n572             # undo masking\n573             x = x.xreplace(dict((v, k) for k, v in d.items()))\n574             return x\n575         return self.replace(\n576             lambda x: hasattr(x, 'bound_symbols'),\n577             lambda x: can(x))\n578 \n579     @property\n580     def canonical_variables(self):\n581         \"\"\"Return a dictionary mapping any variable defined in\n582         ``self.bound_symbols`` to Symbols that do not clash\n583         with any existing symbol in the expression.\n584 \n585         Examples\n586         ========\n587 \n588         >>> from sympy import Lambda\n589         >>> from sympy.abc import x\n590         >>> Lambda(x, 2*x).canonical_variables\n591         {x: _0}\n592         \"\"\"\n593         from sympy.core.symbol import Symbol\n594         from sympy.utilities.iterables import numbered_symbols\n595         if not hasattr(self, 'bound_symbols'):\n596             return {}\n597         dums = numbered_symbols('_')\n598         reps = {}\n599         v = self.bound_symbols\n600         # this free will include bound symbols that are not part of\n601         # self's bound symbols\n602         free = set([i.name for i in self.atoms(Symbol) - set(v)])\n603         for v in v:\n604             d = next(dums)\n605             if v.is_Symbol:\n606                 while v.name == d.name or d.name in free:\n607                     d = next(dums)\n608             reps[v] = d\n609         return reps\n610 \n611     def rcall(self, *args):\n612         \"\"\"Apply on the argument recursively through the expression tree.\n613 \n614         This method is used to simulate a common abuse of notation for\n615         operators. For instance in SymPy the the following will not work:\n616 \n617         ``(x+Lambda(y, 2*y))(z) == x+2*z``,\n618 \n619         however you can use\n620 \n621         >>> from sympy import Lambda\n622         >>> from sympy.abc import x, y, z\n623         >>> (x + Lambda(y, 2*y)).rcall(z)\n624         x + 2*z\n625         \"\"\"\n626         return Basic._recursive_call(self, args)\n627 \n628     @staticmethod\n629     def _recursive_call(expr_to_call, on_args):\n630         \"\"\"Helper for rcall method.\"\"\"\n631         from sympy import Symbol\n632         def the_call_method_is_overridden(expr):\n633             for cls in getmro(type(expr)):\n634                 if '__call__' in cls.__dict__:\n635                     return cls != Basic\n636 \n637         if callable(expr_to_call) and the_call_method_is_overridden(expr_to_call):\n638             if isinstance(expr_to_call, Symbol):  # XXX When you call a Symbol it is\n639                 return expr_to_call               # transformed into an UndefFunction\n640             else:\n641                 return expr_to_call(*on_args)\n642         elif expr_to_call.args:\n643             args = [Basic._recursive_call(\n644                 sub, on_args) for sub in expr_to_call.args]\n645             return type(expr_to_call)(*args)\n646         else:\n647             return expr_to_call\n648 \n649     def is_hypergeometric(self, k):\n650         from sympy.simplify import hypersimp\n651         return hypersimp(self, k) is not None\n652 \n653     @property\n654     def is_comparable(self):\n655         \"\"\"Return True if self can be computed to a real number\n656         (or already is a real number) with precision, else False.\n657 \n658         Examples\n659         ========\n660 \n661         >>> from sympy import exp_polar, pi, I\n662         >>> (I*exp_polar(I*pi/2)).is_comparable\n663         True\n664         >>> (I*exp_polar(I*pi*2)).is_comparable\n665         False\n666 \n667         A False result does not mean that `self` cannot be rewritten\n668         into a form that would be comparable. For example, the\n669         difference computed below is zero but without simplification\n670         it does not evaluate to a zero with precision:\n671 \n672         >>> e = 2**pi*(1 + 2**pi)\n673         >>> dif = e - e.expand()\n674         >>> dif.is_comparable\n675         False\n676         >>> dif.n(2)._prec\n677         1\n678 \n679         \"\"\"\n680         is_extended_real = self.is_extended_real\n681         if is_extended_real is False:\n682             return False\n683         if not self.is_number:\n684             return False\n685         # don't re-eval numbers that are already evaluated since\n686         # this will create spurious precision\n687         n, i = [p.evalf(2) if not p.is_Number else p\n688             for p in self.as_real_imag()]\n689         if not (i.is_Number and n.is_Number):\n690             return False\n691         if i:\n692             # if _prec = 1 we can't decide and if not,\n693             # the answer is False because numbers with\n694             # imaginary parts can't be compared\n695             # so return False\n696             return False\n697         else:\n698             return n._prec != 1\n699 \n700     @property\n701     def func(self):\n702         \"\"\"\n703         The top-level function in an expression.\n704 \n705         The following should hold for all objects::\n706 \n707             >> x == x.func(*x.args)\n708 \n709         Examples\n710         ========\n711 \n712         >>> from sympy.abc import x\n713         >>> a = 2*x\n714         >>> a.func\n715         <class 'sympy.core.mul.Mul'>\n716         >>> a.args\n717         (2, x)\n718         >>> a.func(*a.args)\n719         2*x\n720         >>> a == a.func(*a.args)\n721         True\n722 \n723         \"\"\"\n724         return self.__class__\n725 \n726     @property\n727     def args(self):\n728         \"\"\"Returns a tuple of arguments of 'self'.\n729 \n730         Examples\n731         ========\n732 \n733         >>> from sympy import cot\n734         >>> from sympy.abc import x, y\n735 \n736         >>> cot(x).args\n737         (x,)\n738 \n739         >>> cot(x).args[0]\n740         x\n741 \n742         >>> (x*y).args\n743         (x, y)\n744 \n745         >>> (x*y).args[1]\n746         y\n747 \n748         Notes\n749         =====\n750 \n751         Never use self._args, always use self.args.\n752         Only use _args in __new__ when creating a new function.\n753         Don't override .args() from Basic (so that it's easy to\n754         change the interface in the future if needed).\n755         \"\"\"\n756         return self._args\n757 \n758     @property\n759     def _sorted_args(self):\n760         \"\"\"\n761         The same as ``args``.  Derived classes which don't fix an\n762         order on their arguments should override this method to\n763         produce the sorted representation.\n764         \"\"\"\n765         return self.args\n766 \n767     def as_content_primitive(self, radical=False, clear=True):\n768         \"\"\"A stub to allow Basic args (like Tuple) to be skipped when computing\n769         the content and primitive components of an expression.\n770 \n771         See Also\n772         ========\n773 \n774         sympy.core.expr.Expr.as_content_primitive\n775         \"\"\"\n776         return S.One, self\n777 \n778     def subs(self, *args, **kwargs):\n779         \"\"\"\n780         Substitutes old for new in an expression after sympifying args.\n781 \n782         `args` is either:\n783           - two arguments, e.g. foo.subs(old, new)\n784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n785              o an iterable container with (old, new) pairs. In this case the\n786                replacements are processed in the order given with successive\n787                patterns possibly affecting replacements already made.\n788              o a dict or set whose key/value items correspond to old/new pairs.\n789                In this case the old/new pairs will be sorted by op count and in\n790                case of a tie, by number of args and the default_sort_key. The\n791                resulting sorted list is then processed as an iterable container\n792                (see previous).\n793 \n794         If the keyword ``simultaneous`` is True, the subexpressions will not be\n795         evaluated until all the substitutions have been made.\n796 \n797         Examples\n798         ========\n799 \n800         >>> from sympy import pi, exp, limit, oo\n801         >>> from sympy.abc import x, y\n802         >>> (1 + x*y).subs(x, pi)\n803         pi*y + 1\n804         >>> (1 + x*y).subs({x:pi, y:2})\n805         1 + 2*pi\n806         >>> (1 + x*y).subs([(x, pi), (y, 2)])\n807         1 + 2*pi\n808         >>> reps = [(y, x**2), (x, 2)]\n809         >>> (x + y).subs(reps)\n810         6\n811         >>> (x + y).subs(reversed(reps))\n812         x**2 + 2\n813 \n814         >>> (x**2 + x**4).subs(x**2, y)\n815         y**2 + y\n816 \n817         To replace only the x**2 but not the x**4, use xreplace:\n818 \n819         >>> (x**2 + x**4).xreplace({x**2: y})\n820         x**4 + y\n821 \n822         To delay evaluation until all substitutions have been made,\n823         set the keyword ``simultaneous`` to True:\n824 \n825         >>> (x/y).subs([(x, 0), (y, 0)])\n826         0\n827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n828         nan\n829 \n830         This has the added feature of not allowing subsequent substitutions\n831         to affect those already made:\n832 \n833         >>> ((x + y)/y).subs({x + y: y, y: x + y})\n834         1\n835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n836         y/(x + y)\n837 \n838         In order to obtain a canonical result, unordered iterables are\n839         sorted by count_op length, number of arguments and by the\n840         default_sort_key to break any ties. All other iterables are left\n841         unsorted.\n842 \n843         >>> from sympy import sqrt, sin, cos\n844         >>> from sympy.abc import a, b, c, d, e\n845 \n846         >>> A = (sqrt(sin(2*x)), a)\n847         >>> B = (sin(2*x), b)\n848         >>> C = (cos(2*x), c)\n849         >>> D = (x, d)\n850         >>> E = (exp(x), e)\n851 \n852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n853 \n854         >>> expr.subs(dict([A, B, C, D, E]))\n855         a*c*sin(d*e) + b\n856 \n857         The resulting expression represents a literal replacement of the\n858         old arguments with the new arguments. This may not reflect the\n859         limiting behavior of the expression:\n860 \n861         >>> (x**3 - 3*x).subs({x: oo})\n862         nan\n863 \n864         >>> limit(x**3 - 3*x, x, oo)\n865         oo\n866 \n867         If the substitution will be followed by numerical\n868         evaluation, it is better to pass the substitution to\n869         evalf as\n870 \n871         >>> (1/x).evalf(subs={x: 3.0}, n=21)\n872         0.333333333333333333333\n873 \n874         rather than\n875 \n876         >>> (1/x).subs({x: 3.0}).evalf(21)\n877         0.333333333333333314830\n878 \n879         as the former will ensure that the desired level of precision is\n880         obtained.\n881 \n882         See Also\n883         ========\n884         replace: replacement capable of doing wildcard-like matching,\n885                  parsing of match, and conditional replacements\n886         xreplace: exact node replacement in expr tree; also capable of\n887                   using matching rules\n888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n889 \n890         \"\"\"\n891         from sympy.core.containers import Dict\n892         from sympy.utilities import default_sort_key\n893         from sympy import Dummy, Symbol\n894 \n895         unordered = False\n896         if len(args) == 1:\n897             sequence = args[0]\n898             if isinstance(sequence, set):\n899                 unordered = True\n900             elif isinstance(sequence, (Dict, Mapping)):\n901                 unordered = True\n902                 sequence = sequence.items()\n903             elif not iterable(sequence):\n904                 from sympy.utilities.misc import filldedent\n905                 raise ValueError(filldedent(\"\"\"\n906                    When a single argument is passed to subs\n907                    it should be a dictionary of old: new pairs or an iterable\n908                    of (old, new) tuples.\"\"\"))\n909         elif len(args) == 2:\n910             sequence = [args]\n911         else:\n912             raise ValueError(\"subs accepts either 1 or 2 arguments\")\n913 \n914         sequence = list(sequence)\n915         for i, s in enumerate(sequence):\n916             if isinstance(s[0], str):\n917                 # when old is a string we prefer Symbol\n918                 s = Symbol(s[0]), s[1]\n919             try:\n920                 s = [sympify(_, strict=not isinstance(_, str))\n921                      for _ in s]\n922             except SympifyError:\n923                 # if it can't be sympified, skip it\n924                 sequence[i] = None\n925                 continue\n926             # skip if there is no change\n927             sequence[i] = None if _aresame(*s) else tuple(s)\n928         sequence = list(filter(None, sequence))\n929 \n930         if unordered:\n931             sequence = dict(sequence)\n932             if not all(k.is_Atom for k in sequence):\n933                 d = {}\n934                 for o, n in sequence.items():\n935                     try:\n936                         ops = o.count_ops(), len(o.args)\n937                     except TypeError:\n938                         ops = (0, 0)\n939                     d.setdefault(ops, []).append((o, n))\n940                 newseq = []\n941                 for k in sorted(d.keys(), reverse=True):\n942                     newseq.extend(\n943                         sorted([v[0] for v in d[k]], key=default_sort_key))\n944                 sequence = [(k, sequence[k]) for k in newseq]\n945                 del newseq, d\n946             else:\n947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],\n948                                   key=default_sort_key)\n949 \n950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n951             reps = {}\n952             rv = self\n953             kwargs['hack2'] = True\n954             m = Dummy('subs_m')\n955             for old, new in sequence:\n956                 com = new.is_commutative\n957                 if com is None:\n958                     com = True\n959                 d = Dummy('subs_d', commutative=com)\n960                 # using d*m so Subs will be used on dummy variables\n961                 # in things like Derivative(f(x, y), x) in which x\n962                 # is both free and bound\n963                 rv = rv._subs(old, d*m, **kwargs)\n964                 if not isinstance(rv, Basic):\n965                     break\n966                 reps[d] = new\n967             reps[m] = S.One  # get rid of m\n968             return rv.xreplace(reps)\n969         else:\n970             rv = self\n971             for old, new in sequence:\n972                 rv = rv._subs(old, new, **kwargs)\n973                 if not isinstance(rv, Basic):\n974                     break\n975             return rv\n976 \n977     @cacheit\n978     def _subs(self, old, new, **hints):\n979         \"\"\"Substitutes an expression old -> new.\n980 \n981         If self is not equal to old then _eval_subs is called.\n982         If _eval_subs doesn't want to make any special replacement\n983         then a None is received which indicates that the fallback\n984         should be applied wherein a search for replacements is made\n985         amongst the arguments of self.\n986 \n987         >>> from sympy import Add\n988         >>> from sympy.abc import x, y, z\n989 \n990         Examples\n991         ========\n992 \n993         Add's _eval_subs knows how to target x + y in the following\n994         so it makes the change:\n995 \n996         >>> (x + y + z).subs(x + y, 1)\n997         z + 1\n998 \n999         Add's _eval_subs doesn't need to know how to find x + y in\n1000         the following:\n1001 \n1002         >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n1003         True\n1004 \n1005         The returned None will cause the fallback routine to traverse the args and\n1006         pass the z*(x + y) arg to Mul where the change will take place and the\n1007         substitution will succeed:\n1008 \n1009         >>> (z*(x + y) + 3).subs(x + y, 1)\n1010         z + 3\n1011 \n1012         ** Developers Notes **\n1013 \n1014         An _eval_subs routine for a class should be written if:\n1015 \n1016             1) any arguments are not instances of Basic (e.g. bool, tuple);\n1017 \n1018             2) some arguments should not be targeted (as in integration\n1019                variables);\n1020 \n1021             3) if there is something other than a literal replacement\n1022                that should be attempted (as in Piecewise where the condition\n1023                may be updated without doing a replacement).\n1024 \n1025         If it is overridden, here are some special cases that might arise:\n1026 \n1027             1) If it turns out that no special change was made and all\n1028                the original sub-arguments should be checked for\n1029                replacements then None should be returned.\n1030 \n1031             2) If it is necessary to do substitutions on a portion of\n1032                the expression then _subs should be called. _subs will\n1033                handle the case of any sub-expression being equal to old\n1034                (which usually would not be the case) while its fallback\n1035                will handle the recursion into the sub-arguments. For\n1036                example, after Add's _eval_subs removes some matching terms\n1037                it must process the remaining terms so it calls _subs\n1038                on each of the un-matched terms and then adds them\n1039                onto the terms previously obtained.\n1040 \n1041            3) If the initial expression should remain unchanged then\n1042               the original expression should be returned. (Whenever an\n1043               expression is returned, modified or not, no further\n1044               substitution of old -> new is attempted.) Sum's _eval_subs\n1045               routine uses this strategy when a substitution is attempted\n1046               on any of its summation variables.\n1047         \"\"\"\n1048 \n1049         def fallback(self, old, new):\n1050             \"\"\"\n1051             Try to replace old with new in any of self's arguments.\n1052             \"\"\"\n1053             hit = False\n1054             args = list(self.args)\n1055             for i, arg in enumerate(args):\n1056                 if not hasattr(arg, '_eval_subs'):\n1057                     continue\n1058                 arg = arg._subs(old, new, **hints)\n1059                 if not _aresame(arg, args[i]):\n1060                     hit = True\n1061                     args[i] = arg\n1062             if hit:\n1063                 rv = self.func(*args)\n1064                 hack2 = hints.get('hack2', False)\n1065                 if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n1066                     coeff = S.One\n1067                     nonnumber = []\n1068                     for i in args:\n1069                         if i.is_Number:\n1070                             coeff *= i\n1071                         else:\n1072                             nonnumber.append(i)\n1073                     nonnumber = self.func(*nonnumber)\n1074                     if coeff is S.One:\n1075                         return nonnumber\n1076                     else:\n1077                         return self.func(coeff, nonnumber, evaluate=False)\n1078                 return rv\n1079             return self\n1080 \n1081         if _aresame(self, old):\n1082             return new\n1083 \n1084         rv = self._eval_subs(old, new)\n1085         if rv is None:\n1086             rv = fallback(self, old, new)\n1087         return rv\n1088 \n1089     def _eval_subs(self, old, new):\n1090         \"\"\"Override this stub if you want to do anything more than\n1091         attempt a replacement of old with new in the arguments of self.\n1092 \n1093         See also\n1094         ========\n1095 \n1096         _subs\n1097         \"\"\"\n1098         return None\n1099 \n1100     def xreplace(self, rule):\n1101         \"\"\"\n1102         Replace occurrences of objects within the expression.\n1103 \n1104         Parameters\n1105         ==========\n1106 \n1107         rule : dict-like\n1108             Expresses a replacement rule\n1109 \n1110         Returns\n1111         =======\n1112 \n1113         xreplace : the result of the replacement\n1114 \n1115         Examples\n1116         ========\n1117 \n1118         >>> from sympy import symbols, pi, exp\n1119         >>> x, y, z = symbols('x y z')\n1120         >>> (1 + x*y).xreplace({x: pi})\n1121         pi*y + 1\n1122         >>> (1 + x*y).xreplace({x: pi, y: 2})\n1123         1 + 2*pi\n1124 \n1125         Replacements occur only if an entire node in the expression tree is\n1126         matched:\n1127 \n1128         >>> (x*y + z).xreplace({x*y: pi})\n1129         z + pi\n1130         >>> (x*y*z).xreplace({x*y: pi})\n1131         x*y*z\n1132         >>> (2*x).xreplace({2*x: y, x: z})\n1133         y\n1134         >>> (2*2*x).xreplace({2*x: y, x: z})\n1135         4*z\n1136         >>> (x + y + 2).xreplace({x + y: 2})\n1137         x + y + 2\n1138         >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n1139         x + exp(y) + 2\n1140 \n1141         xreplace doesn't differentiate between free and bound symbols. In the\n1142         following, subs(x, y) would not change x since it is a bound symbol,\n1143         but xreplace does:\n1144 \n1145         >>> from sympy import Integral\n1146         >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n1147         Integral(y, (y, 1, 2*y))\n1148 \n1149         Trying to replace x with an expression raises an error:\n1150 \n1151         >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n1152         ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n1153 \n1154         See Also\n1155         ========\n1156         replace: replacement capable of doing wildcard-like matching,\n1157                  parsing of match, and conditional replacements\n1158         subs: substitution of subexpressions as defined by the objects\n1159               themselves.\n1160 \n1161         \"\"\"\n1162         value, _ = self._xreplace(rule)\n1163         return value\n1164 \n1165     def _xreplace(self, rule):\n1166         \"\"\"\n1167         Helper for xreplace. Tracks whether a replacement actually occurred.\n1168         \"\"\"\n1169         if self in rule:\n1170             return rule[self], True\n1171         elif rule:\n1172             args = []\n1173             changed = False\n1174             for a in self.args:\n1175                 _xreplace = getattr(a, '_xreplace', None)\n1176                 if _xreplace is not None:\n1177                     a_xr = _xreplace(rule)\n1178                     args.append(a_xr[0])\n1179                     changed |= a_xr[1]\n1180                 else:\n1181                     args.append(a)\n1182             args = tuple(args)\n1183             if changed:\n1184                 return self.func(*args), True\n1185         return self, False\n1186 \n1187     @cacheit\n1188     def has(self, *patterns):\n1189         \"\"\"\n1190         Test whether any subexpression matches any of the patterns.\n1191 \n1192         Examples\n1193         ========\n1194 \n1195         >>> from sympy import sin\n1196         >>> from sympy.abc import x, y, z\n1197         >>> (x**2 + sin(x*y)).has(z)\n1198         False\n1199         >>> (x**2 + sin(x*y)).has(x, y, z)\n1200         True\n1201         >>> x.has(x)\n1202         True\n1203 \n1204         Note ``has`` is a structural algorithm with no knowledge of\n1205         mathematics. Consider the following half-open interval:\n1206 \n1207         >>> from sympy.sets import Interval\n1208         >>> i = Interval.Lopen(0, 5); i\n1209         Interval.Lopen(0, 5)\n1210         >>> i.args\n1211         (0, 5, True, False)\n1212         >>> i.has(4)  # there is no \"4\" in the arguments\n1213         False\n1214         >>> i.has(0)  # there *is* a \"0\" in the arguments\n1215         True\n1216 \n1217         Instead, use ``contains`` to determine whether a number is in the\n1218         interval or not:\n1219 \n1220         >>> i.contains(4)\n1221         True\n1222         >>> i.contains(0)\n1223         False\n1224 \n1225 \n1226         Note that ``expr.has(*patterns)`` is exactly equivalent to\n1227         ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is\n1228         returned when the list of patterns is empty.\n1229 \n1230         >>> x.has()\n1231         False\n1232 \n1233         \"\"\"\n1234         return any(self._has(pattern) for pattern in patterns)\n1235 \n1236     def _has(self, pattern):\n1237         \"\"\"Helper for .has()\"\"\"\n1238         from sympy.core.function import UndefinedFunction, Function\n1239         if isinstance(pattern, UndefinedFunction):\n1240             return any(f.func == pattern or f == pattern\n1241             for f in self.atoms(Function, UndefinedFunction))\n1242 \n1243         pattern = sympify(pattern)\n1244         if isinstance(pattern, BasicMeta):\n1245             return any(isinstance(arg, pattern)\n1246             for arg in preorder_traversal(self))\n1247 \n1248         _has_matcher = getattr(pattern, '_has_matcher', None)\n1249         if _has_matcher is not None:\n1250             match = _has_matcher()\n1251             return any(match(arg) for arg in preorder_traversal(self))\n1252         else:\n1253             return any(arg == pattern for arg in preorder_traversal(self))\n1254 \n1255     def _has_matcher(self):\n1256         \"\"\"Helper for .has()\"\"\"\n1257         return lambda other: self == other\n1258 \n1259     def replace(self, query, value, map=False, simultaneous=True, exact=None):\n1260         \"\"\"\n1261         Replace matching subexpressions of ``self`` with ``value``.\n1262 \n1263         If ``map = True`` then also return the mapping {old: new} where ``old``\n1264         was a sub-expression found with query and ``new`` is the replacement\n1265         value for it. If the expression itself doesn't match the query, then\n1266         the returned value will be ``self.xreplace(map)`` otherwise it should\n1267         be ``self.subs(ordered(map.items()))``.\n1268 \n1269         Traverses an expression tree and performs replacement of matching\n1270         subexpressions from the bottom to the top of the tree. The default\n1271         approach is to do the replacement in a simultaneous fashion so\n1272         changes made are targeted only once. If this is not desired or causes\n1273         problems, ``simultaneous`` can be set to False.\n1274 \n1275         In addition, if an expression containing more than one Wild symbol\n1276         is being used to match subexpressions and the ``exact`` flag is None\n1277         it will be set to True so the match will only succeed if all non-zero\n1278         values are received for each Wild that appears in the match pattern.\n1279         Setting this to False accepts a match of 0; while setting it True\n1280         accepts all matches that have a 0 in them. See example below for\n1281         cautions.\n1282 \n1283         The list of possible combinations of queries and replacement values\n1284         is listed below:\n1285 \n1286         Examples\n1287         ========\n1288 \n1289         Initial setup\n1290 \n1291         >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n1292         >>> from sympy.abc import x, y\n1293         >>> f = log(sin(x)) + tan(sin(x**2))\n1294 \n1295         1.1. type -> type\n1296             obj.replace(type, newtype)\n1297 \n1298             When object of type ``type`` is found, replace it with the\n1299             result of passing its argument(s) to ``newtype``.\n1300 \n1301             >>> f.replace(sin, cos)\n1302             log(cos(x)) + tan(cos(x**2))\n1303             >>> sin(x).replace(sin, cos, map=True)\n1304             (cos(x), {sin(x): cos(x)})\n1305             >>> (x*y).replace(Mul, Add)\n1306             x + y\n1307 \n1308         1.2. type -> func\n1309             obj.replace(type, func)\n1310 \n1311             When object of type ``type`` is found, apply ``func`` to its\n1312             argument(s). ``func`` must be written to handle the number\n1313             of arguments of ``type``.\n1314 \n1315             >>> f.replace(sin, lambda arg: sin(2*arg))\n1316             log(sin(2*x)) + tan(sin(2*x**2))\n1317             >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n1318             sin(2*x*y)\n1319 \n1320         2.1. pattern -> expr\n1321             obj.replace(pattern(wild), expr(wild))\n1322 \n1323             Replace subexpressions matching ``pattern`` with the expression\n1324             written in terms of the Wild symbols in ``pattern``.\n1325 \n1326             >>> a, b = map(Wild, 'ab')\n1327             >>> f.replace(sin(a), tan(a))\n1328             log(tan(x)) + tan(tan(x**2))\n1329             >>> f.replace(sin(a), tan(a/2))\n1330             log(tan(x/2)) + tan(tan(x**2/2))\n1331             >>> f.replace(sin(a), a)\n1332             log(x) + tan(x**2)\n1333             >>> (x*y).replace(a*x, a)\n1334             y\n1335 \n1336             Matching is exact by default when more than one Wild symbol\n1337             is used: matching fails unless the match gives non-zero\n1338             values for all Wild symbols:\n1339 \n1340             >>> (2*x + y).replace(a*x + b, b - a)\n1341             y - 2\n1342             >>> (2*x).replace(a*x + b, b - a)\n1343             2*x\n1344 \n1345             When set to False, the results may be non-intuitive:\n1346 \n1347             >>> (2*x).replace(a*x + b, b - a, exact=False)\n1348             2/x\n1349 \n1350         2.2. pattern -> func\n1351             obj.replace(pattern(wild), lambda wild: expr(wild))\n1352 \n1353             All behavior is the same as in 2.1 but now a function in terms of\n1354             pattern variables is used rather than an expression:\n1355 \n1356             >>> f.replace(sin(a), lambda a: sin(2*a))\n1357             log(sin(2*x)) + tan(sin(2*x**2))\n1358 \n1359         3.1. func -> func\n1360             obj.replace(filter, func)\n1361 \n1362             Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n1363             is True.\n1364 \n1365             >>> g = 2*sin(x**3)\n1366             >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n1367             4*sin(x**9)\n1368 \n1369         The expression itself is also targeted by the query but is done in\n1370         such a fashion that changes are not made twice.\n1371 \n1372             >>> e = x*(x*y + 1)\n1373             >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n1374             2*x*(2*x*y + 1)\n1375 \n1376         When matching a single symbol, `exact` will default to True, but\n1377         this may or may not be the behavior that is desired:\n1378 \n1379         Here, we want `exact=False`:\n1380 \n1381         >>> from sympy import Function\n1382         >>> f = Function('f')\n1383         >>> e = f(1) + f(0)\n1384         >>> q = f(a), lambda a: f(a + 1)\n1385         >>> e.replace(*q, exact=False)\n1386         f(1) + f(2)\n1387         >>> e.replace(*q, exact=True)\n1388         f(0) + f(2)\n1389 \n1390         But here, the nature of matching makes selecting\n1391         the right setting tricky:\n1392 \n1393         >>> e = x**(1 + y)\n1394         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n1395         1\n1396         >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n1397         x**(-x - y + 1)\n1398         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n1399         1\n1400         >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n1401         x**(1 - y)\n1402 \n1403         It is probably better to use a different form of the query\n1404         that describes the target expression more precisely:\n1405 \n1406         >>> (1 + x**(1 + y)).replace(\n1407         ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n1408         ... lambda x: x.base**(1 - (x.exp - 1)))\n1409         ...\n1410         x**(1 - y) + 1\n1411 \n1412         See Also\n1413         ========\n1414 \n1415         subs: substitution of subexpressions as defined by the objects\n1416               themselves.\n1417         xreplace: exact node replacement in expr tree; also capable of\n1418                   using matching rules\n1419 \n1420         \"\"\"\n1421         from sympy.core.symbol import Dummy, Wild\n1422         from sympy.simplify.simplify import bottom_up\n1423 \n1424         try:\n1425             query = _sympify(query)\n1426         except SympifyError:\n1427             pass\n1428         try:\n1429             value = _sympify(value)\n1430         except SympifyError:\n1431             pass\n1432         if isinstance(query, type):\n1433             _query = lambda expr: isinstance(expr, query)\n1434 \n1435             if isinstance(value, type):\n1436                 _value = lambda expr, result: value(*expr.args)\n1437             elif callable(value):\n1438                 _value = lambda expr, result: value(*expr.args)\n1439             else:\n1440                 raise TypeError(\n1441                     \"given a type, replace() expects another \"\n1442                     \"type or a callable\")\n1443         elif isinstance(query, Basic):\n1444             _query = lambda expr: expr.match(query)\n1445             if exact is None:\n1446                 exact = (len(query.atoms(Wild)) > 1)\n1447 \n1448             if isinstance(value, Basic):\n1449                 if exact:\n1450                     _value = lambda expr, result: (value.subs(result)\n1451                         if all(result.values()) else expr)\n1452                 else:\n1453                     _value = lambda expr, result: value.subs(result)\n1454             elif callable(value):\n1455                 # match dictionary keys get the trailing underscore stripped\n1456                 # from them and are then passed as keywords to the callable;\n1457                 # if ``exact`` is True, only accept match if there are no null\n1458                 # values amongst those matched.\n1459                 if exact:\n1460                     _value = lambda expr, result: (value(**\n1461                         {str(k)[:-1]: v for k, v in result.items()})\n1462                         if all(val for val in result.values()) else expr)\n1463                 else:\n1464                     _value = lambda expr, result: value(**\n1465                         {str(k)[:-1]: v for k, v in result.items()})\n1466             else:\n1467                 raise TypeError(\n1468                     \"given an expression, replace() expects \"\n1469                     \"another expression or a callable\")\n1470         elif callable(query):\n1471             _query = query\n1472 \n1473             if callable(value):\n1474                 _value = lambda expr, result: value(expr)\n1475             else:\n1476                 raise TypeError(\n1477                     \"given a callable, replace() expects \"\n1478                     \"another callable\")\n1479         else:\n1480             raise TypeError(\n1481                 \"first argument to replace() must be a \"\n1482                 \"type, an expression or a callable\")\n1483 \n1484         mapping = {}  # changes that took place\n1485         mask = []  # the dummies that were used as change placeholders\n1486 \n1487         def rec_replace(expr):\n1488             result = _query(expr)\n1489             if result or result == {}:\n1490                 new = _value(expr, result)\n1491                 if new is not None and new != expr:\n1492                     mapping[expr] = new\n1493                     if simultaneous:\n1494                         # don't let this change during rebuilding;\n1495                         # XXX this may fail if the object being replaced\n1496                         # cannot be represented as a Dummy in the expression\n1497                         # tree, e.g. an ExprConditionPair in Piecewise\n1498                         # cannot be represented with a Dummy\n1499                         com = getattr(new, 'is_commutative', True)\n1500                         if com is None:\n1501                             com = True\n1502                         d = Dummy('rec_replace', commutative=com)\n1503                         mask.append((d, new))\n1504                         expr = d\n1505                     else:\n1506                         expr = new\n1507             return expr\n1508 \n1509         rv = bottom_up(self, rec_replace, atoms=True)\n1510 \n1511         # restore original expressions for Dummy symbols\n1512         if simultaneous:\n1513             mask = list(reversed(mask))\n1514             for o, n in mask:\n1515                 r = {o: n}\n1516                 # if a sub-expression could not be replaced with\n1517                 # a Dummy then this will fail; either filter\n1518                 # against such sub-expressions or figure out a\n1519                 # way to carry out simultaneous replacement\n1520                 # in this situation.\n1521                 rv = rv.xreplace(r)  # if this fails, see above\n1522 \n1523         if not map:\n1524             return rv\n1525         else:\n1526             if simultaneous:\n1527                 # restore subexpressions in mapping\n1528                 for o, n in mask:\n1529                     r = {o: n}\n1530                     mapping = {k.xreplace(r): v.xreplace(r)\n1531                         for k, v in mapping.items()}\n1532             return rv, mapping\n1533 \n1534     def find(self, query, group=False):\n1535         \"\"\"Find all subexpressions matching a query. \"\"\"\n1536         query = _make_find_query(query)\n1537         results = list(filter(query, preorder_traversal(self)))\n1538 \n1539         if not group:\n1540             return set(results)\n1541         else:\n1542             groups = {}\n1543 \n1544             for result in results:\n1545                 if result in groups:\n1546                     groups[result] += 1\n1547                 else:\n1548                     groups[result] = 1\n1549 \n1550             return groups\n1551 \n1552     def count(self, query):\n1553         \"\"\"Count the number of matching subexpressions. \"\"\"\n1554         query = _make_find_query(query)\n1555         return sum(bool(query(sub)) for sub in preorder_traversal(self))\n1556 \n1557     def matches(self, expr, repl_dict={}, old=False):\n1558         \"\"\"\n1559         Helper method for match() that looks for a match between Wild symbols\n1560         in self and expressions in expr.\n1561 \n1562         Examples\n1563         ========\n1564 \n1565         >>> from sympy import symbols, Wild, Basic\n1566         >>> a, b, c = symbols('a b c')\n1567         >>> x = Wild('x')\n1568         >>> Basic(a + x, x).matches(Basic(a + b, c)) is None\n1569         True\n1570         >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))\n1571         {x_: b + c}\n1572         \"\"\"\n1573         expr = sympify(expr)\n1574         if not isinstance(expr, self.__class__):\n1575             return None\n1576 \n1577         if self == expr:\n1578             return repl_dict\n1579 \n1580         if len(self.args) != len(expr.args):\n1581             return None\n1582 \n1583         d = repl_dict.copy()\n1584         for arg, other_arg in zip(self.args, expr.args):\n1585             if arg == other_arg:\n1586                 continue\n1587             d = arg.xreplace(d).matches(other_arg, d, old=old)\n1588             if d is None:\n1589                 return None\n1590         return d\n1591 \n1592     def match(self, pattern, old=False):\n1593         \"\"\"\n1594         Pattern matching.\n1595 \n1596         Wild symbols match all.\n1597 \n1598         Return ``None`` when expression (self) does not match\n1599         with pattern. Otherwise return a dictionary such that::\n1600 \n1601           pattern.xreplace(self.match(pattern)) == self\n1602 \n1603         Examples\n1604         ========\n1605 \n1606         >>> from sympy import Wild\n1607         >>> from sympy.abc import x, y\n1608         >>> p = Wild(\"p\")\n1609         >>> q = Wild(\"q\")\n1610         >>> r = Wild(\"r\")\n1611         >>> e = (x+y)**(x+y)\n1612         >>> e.match(p**p)\n1613         {p_: x + y}\n1614         >>> e.match(p**q)\n1615         {p_: x + y, q_: x + y}\n1616         >>> e = (2*x)**2\n1617         >>> e.match(p*q**r)\n1618         {p_: 4, q_: x, r_: 2}\n1619         >>> (p*q**r).xreplace(e.match(p*q**r))\n1620         4*x**2\n1621 \n1622         The ``old`` flag will give the old-style pattern matching where\n1623         expressions and patterns are essentially solved to give the\n1624         match. Both of the following give None unless ``old=True``:\n1625 \n1626         >>> (x - 2).match(p - x, old=True)\n1627         {p_: 2*x - 2}\n1628         >>> (2/x).match(p*x, old=True)\n1629         {p_: 2/x**2}\n1630 \n1631         \"\"\"\n1632         pattern = sympify(pattern)\n1633         return pattern.matches(self, old=old)\n1634 \n1635     def count_ops(self, visual=None):\n1636         \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n1637         from sympy import count_ops\n1638         return count_ops(self, visual)\n1639 \n1640     def doit(self, **hints):\n1641         \"\"\"Evaluate objects that are not evaluated by default like limits,\n1642         integrals, sums and products. All objects of this kind will be\n1643         evaluated recursively, unless some species were excluded via 'hints'\n1644         or unless the 'deep' hint was set to 'False'.\n1645 \n1646         >>> from sympy import Integral\n1647         >>> from sympy.abc import x\n1648 \n1649         >>> 2*Integral(x, x)\n1650         2*Integral(x, x)\n1651 \n1652         >>> (2*Integral(x, x)).doit()\n1653         x**2\n1654 \n1655         >>> (2*Integral(x, x)).doit(deep=False)\n1656         2*Integral(x, x)\n1657 \n1658         \"\"\"\n1659         if hints.get('deep', True):\n1660             terms = [term.doit(**hints) if isinstance(term, Basic) else term\n1661                                          for term in self.args]\n1662             return self.func(*terms)\n1663         else:\n1664             return self\n1665 \n1666     def simplify(self, **kwargs):\n1667         \"\"\"See the simplify function in sympy.simplify\"\"\"\n1668         from sympy.simplify import simplify\n1669         return simplify(self, **kwargs)\n1670 \n1671     def _eval_rewrite(self, pattern, rule, **hints):\n1672         if self.is_Atom:\n1673             if hasattr(self, rule):\n1674                 return getattr(self, rule)()\n1675             return self\n1676 \n1677         if hints.get('deep', True):\n1678             args = [a._eval_rewrite(pattern, rule, **hints)\n1679                         if isinstance(a, Basic) else a\n1680                         for a in self.args]\n1681         else:\n1682             args = self.args\n1683 \n1684         if pattern is None or isinstance(self, pattern):\n1685             if hasattr(self, rule):\n1686                 rewritten = getattr(self, rule)(*args, **hints)\n1687                 if rewritten is not None:\n1688                     return rewritten\n1689 \n1690         return self.func(*args) if hints.get('evaluate', True) else self\n1691 \n1692     def _accept_eval_derivative(self, s):\n1693         # This method needs to be overridden by array-like objects\n1694         return s._visit_eval_derivative_scalar(self)\n1695 \n1696     def _visit_eval_derivative_scalar(self, base):\n1697         # Base is a scalar\n1698         # Types are (base: scalar, self: scalar)\n1699         return base._eval_derivative(self)\n1700 \n1701     def _visit_eval_derivative_array(self, base):\n1702         # Types are (base: array/matrix, self: scalar)\n1703         # Base is some kind of array/matrix,\n1704         # it should have `.applyfunc(lambda x: x.diff(self)` implemented:\n1705         return base._eval_derivative_array(self)\n1706 \n1707     def _eval_derivative_n_times(self, s, n):\n1708         # This is the default evaluator for derivatives (as called by `diff`\n1709         # and `Derivative`), it will attempt a loop to derive the expression\n1710         # `n` times by calling the corresponding `_eval_derivative` method,\n1711         # while leaving the derivative unevaluated if `n` is symbolic.  This\n1712         # method should be overridden if the object has a closed form for its\n1713         # symbolic n-th derivative.\n1714         from sympy import Integer\n1715         if isinstance(n, (int, Integer)):\n1716             obj = self\n1717             for i in range(n):\n1718                 obj2 = obj._accept_eval_derivative(s)\n1719                 if obj == obj2 or obj2 is None:\n1720                     break\n1721                 obj = obj2\n1722             return obj2\n1723         else:\n1724             return None\n1725 \n1726     def rewrite(self, *args, **hints):\n1727         \"\"\" Rewrite functions in terms of other functions.\n1728 \n1729         Rewrites expression containing applications of functions\n1730         of one kind in terms of functions of different kind. For\n1731         example you can rewrite trigonometric functions as complex\n1732         exponentials or combinatorial functions as gamma function.\n1733 \n1734         As a pattern this function accepts a list of functions to\n1735         to rewrite (instances of DefinedFunction class). As rule\n1736         you can use string or a destination function instance (in\n1737         this case rewrite() will use the str() function).\n1738 \n1739         There is also the possibility to pass hints on how to rewrite\n1740         the given expressions. For now there is only one such hint\n1741         defined called 'deep'. When 'deep' is set to False it will\n1742         forbid functions to rewrite their contents.\n1743 \n1744         Examples\n1745         ========\n1746 \n1747         >>> from sympy import sin, exp\n1748         >>> from sympy.abc import x\n1749 \n1750         Unspecified pattern:\n1751 \n1752         >>> sin(x).rewrite(exp)\n1753         -I*(exp(I*x) - exp(-I*x))/2\n1754 \n1755         Pattern as a single function:\n1756 \n1757         >>> sin(x).rewrite(sin, exp)\n1758         -I*(exp(I*x) - exp(-I*x))/2\n1759 \n1760         Pattern as a list of functions:\n1761 \n1762         >>> sin(x).rewrite([sin, ], exp)\n1763         -I*(exp(I*x) - exp(-I*x))/2\n1764 \n1765         \"\"\"\n1766         if not args:\n1767             return self\n1768         else:\n1769             pattern = args[:-1]\n1770             if isinstance(args[-1], str):\n1771                 rule = '_eval_rewrite_as_' + args[-1]\n1772             else:\n1773                 # rewrite arg is usually a class but can also be a\n1774                 # singleton (e.g. GoldenRatio) so we check\n1775                 # __name__ or __class__.__name__\n1776                 clsname = getattr(args[-1], \"__name__\", None)\n1777                 if clsname is None:\n1778                     clsname = args[-1].__class__.__name__\n1779                 rule = '_eval_rewrite_as_' + clsname\n1780 \n1781             if not pattern:\n1782                 return self._eval_rewrite(None, rule, **hints)\n1783             else:\n1784                 if iterable(pattern[0]):\n1785                     pattern = pattern[0]\n1786 \n1787                 pattern = [p for p in pattern if self.has(p)]\n1788 \n1789                 if pattern:\n1790                     return self._eval_rewrite(tuple(pattern), rule, **hints)\n1791                 else:\n1792                     return self\n1793 \n1794     _constructor_postprocessor_mapping = {}  # type: ignore\n1795 \n1796     @classmethod\n1797     def _exec_constructor_postprocessors(cls, obj):\n1798         # WARNING: This API is experimental.\n1799 \n1800         # This is an experimental API that introduces constructor\n1801         # postprosessors for SymPy Core elements. If an argument of a SymPy\n1802         # expression has a `_constructor_postprocessor_mapping` attribute, it will\n1803         # be interpreted as a dictionary containing lists of postprocessing\n1804         # functions for matching expression node names.\n1805 \n1806         clsname = obj.__class__.__name__\n1807         postprocessors = defaultdict(list)\n1808         for i in obj.args:\n1809             try:\n1810                 postprocessor_mappings = (\n1811                     Basic._constructor_postprocessor_mapping[cls].items()\n1812                     for cls in type(i).mro()\n1813                     if cls in Basic._constructor_postprocessor_mapping\n1814                 )\n1815                 for k, v in chain.from_iterable(postprocessor_mappings):\n1816                     postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n1817             except TypeError:\n1818                 pass\n1819 \n1820         for f in postprocessors.get(clsname, []):\n1821             obj = f(obj)\n1822 \n1823         return obj\n1824 \n1825 \n1826 class Atom(Basic):\n1827     \"\"\"\n1828     A parent class for atomic things. An atom is an expression with no subexpressions.\n1829 \n1830     Examples\n1831     ========\n1832 \n1833     Symbol, Number, Rational, Integer, ...\n1834     But not: Add, Mul, Pow, ...\n1835     \"\"\"\n1836 \n1837     is_Atom = True\n1838 \n1839     __slots__ = ()\n1840 \n1841     def matches(self, expr, repl_dict={}, old=False):\n1842         if self == expr:\n1843             return repl_dict\n1844 \n1845     def xreplace(self, rule, hack2=False):\n1846         return rule.get(self, self)\n1847 \n1848     def doit(self, **hints):\n1849         return self\n1850 \n1851     @classmethod\n1852     def class_key(cls):\n1853         return 2, 0, cls.__name__\n1854 \n1855     @cacheit\n1856     def sort_key(self, order=None):\n1857         return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One\n1858 \n1859     def _eval_simplify(self, **kwargs):\n1860         return self\n1861 \n1862     @property\n1863     def _sorted_args(self):\n1864         # this is here as a safeguard against accidentally using _sorted_args\n1865         # on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)\n1866         # since there are no args. So the calling routine should be checking\n1867         # to see that this property is not called for Atoms.\n1868         raise AttributeError('Atoms have no args. It might be necessary'\n1869         ' to make a check for Atoms in the calling code.')\n1870 \n1871 \n1872 def _aresame(a, b):\n1873     \"\"\"Return True if a and b are structurally the same, else False.\n1874 \n1875     Examples\n1876     ========\n1877 \n1878     In SymPy (as in Python) two numbers compare the same if they\n1879     have the same underlying base-2 representation even though\n1880     they may not be the same type:\n1881 \n1882     >>> from sympy import S\n1883     >>> 2.0 == S(2)\n1884     True\n1885     >>> 0.5 == S.Half\n1886     True\n1887 \n1888     This routine was written to provide a query for such cases that\n1889     would give false when the types do not match:\n1890 \n1891     >>> from sympy.core.basic import _aresame\n1892     >>> _aresame(S(2.0), S(2))\n1893     False\n1894 \n1895     \"\"\"\n1896     from .numbers import Number\n1897     from .function import AppliedUndef, UndefinedFunction as UndefFunc\n1898     if isinstance(a, Number) and isinstance(b, Number):\n1899         return a == b and a.__class__ == b.__class__\n1900     for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):\n1901         if i != j or type(i) != type(j):\n1902             if ((isinstance(i, UndefFunc) and isinstance(j, UndefFunc)) or\n1903                 (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef))):\n1904                 if i.class_key() != j.class_key():\n1905                     return False\n1906             else:\n1907                 return False\n1908     return True\n1909 \n1910 \n1911 def _atomic(e, recursive=False):\n1912     \"\"\"Return atom-like quantities as far as substitution is\n1913     concerned: Derivatives, Functions and Symbols. Don't\n1914     return any 'atoms' that are inside such quantities unless\n1915     they also appear outside, too, unless `recursive` is True.\n1916 \n1917     Examples\n1918     ========\n1919 \n1920     >>> from sympy import Derivative, Function, cos\n1921     >>> from sympy.abc import x, y\n1922     >>> from sympy.core.basic import _atomic\n1923     >>> f = Function('f')\n1924     >>> _atomic(x + y)\n1925     {x, y}\n1926     >>> _atomic(x + f(y))\n1927     {x, f(y)}\n1928     >>> _atomic(Derivative(f(x), x) + cos(x) + y)\n1929     {y, cos(x), Derivative(f(x), x)}\n1930 \n1931     \"\"\"\n1932     from sympy import Derivative, Function, Symbol\n1933     pot = preorder_traversal(e)\n1934     seen = set()\n1935     if isinstance(e, Basic):\n1936         free = getattr(e, \"free_symbols\", None)\n1937         if free is None:\n1938             return {e}\n1939     else:\n1940         return set()\n1941     atoms = set()\n1942     for p in pot:\n1943         if p in seen:\n1944             pot.skip()\n1945             continue\n1946         seen.add(p)\n1947         if isinstance(p, Symbol) and p in free:\n1948             atoms.add(p)\n1949         elif isinstance(p, (Derivative, Function)):\n1950             if not recursive:\n1951                 pot.skip()\n1952             atoms.add(p)\n1953     return atoms\n1954 \n1955 \n1956 class preorder_traversal(Iterator):\n1957     \"\"\"\n1958     Do a pre-order traversal of a tree.\n1959 \n1960     This iterator recursively yields nodes that it has visited in a pre-order\n1961     fashion. That is, it yields the current node then descends through the\n1962     tree breadth-first to yield all of a node's children's pre-order\n1963     traversal.\n1964 \n1965 \n1966     For an expression, the order of the traversal depends on the order of\n1967     .args, which in many cases can be arbitrary.\n1968 \n1969     Parameters\n1970     ==========\n1971     node : sympy expression\n1972         The expression to traverse.\n1973     keys : (default None) sort key(s)\n1974         The key(s) used to sort args of Basic objects. When None, args of Basic\n1975         objects are processed in arbitrary order. If key is defined, it will\n1976         be passed along to ordered() as the only key(s) to use to sort the\n1977         arguments; if ``key`` is simply True then the default keys of ordered\n1978         will be used.\n1979 \n1980     Yields\n1981     ======\n1982     subtree : sympy expression\n1983         All of the subtrees in the tree.\n1984 \n1985     Examples\n1986     ========\n1987 \n1988     >>> from sympy import symbols\n1989     >>> from sympy.core.basic import preorder_traversal\n1990     >>> x, y, z = symbols('x y z')\n1991 \n1992     The nodes are returned in the order that they are encountered unless key\n1993     is given; simply passing key=True will guarantee that the traversal is\n1994     unique.\n1995 \n1996     >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP\n1997     [z*(x + y), z, x + y, y, x]\n1998     >>> list(preorder_traversal((x + y)*z, keys=True))\n1999     [z*(x + y), z, x + y, x, y]\n2000 \n2001     \"\"\"\n2002     def __init__(self, node, keys=None):\n2003         self._skip_flag = False\n2004         self._pt = self._preorder_traversal(node, keys)\n2005 \n2006     def _preorder_traversal(self, node, keys):\n2007         yield node\n2008         if self._skip_flag:\n2009             self._skip_flag = False\n2010             return\n2011         if isinstance(node, Basic):\n2012             if not keys and hasattr(node, '_argset'):\n2013                 # LatticeOp keeps args as a set. We should use this if we\n2014                 # don't care about the order, to prevent unnecessary sorting.\n2015                 args = node._argset\n2016             else:\n2017                 args = node.args\n2018             if keys:\n2019                 if keys != True:\n2020                     args = ordered(args, keys, default=False)\n2021                 else:\n2022                     args = ordered(args)\n2023             for arg in args:\n2024                 for subtree in self._preorder_traversal(arg, keys):\n2025                     yield subtree\n2026         elif iterable(node):\n2027             for item in node:\n2028                 for subtree in self._preorder_traversal(item, keys):\n2029                     yield subtree\n2030 \n2031     def skip(self):\n2032         \"\"\"\n2033         Skip yielding current node's (last yielded node's) subtrees.\n2034 \n2035         Examples\n2036         ========\n2037 \n2038         >>> from sympy.core import symbols\n2039         >>> from sympy.core.basic import preorder_traversal\n2040         >>> x, y, z = symbols('x y z')\n2041         >>> pt = preorder_traversal((x+y*z)*z)\n2042         >>> for i in pt:\n2043         ...     print(i)\n2044         ...     if i == x+y*z:\n2045         ...             pt.skip()\n2046         z*(x + y*z)\n2047         z\n2048         x + y*z\n2049         \"\"\"\n2050         self._skip_flag = True\n2051 \n2052     def __next__(self):\n2053         return next(self._pt)\n2054 \n2055     def __iter__(self):\n2056         return self\n2057 \n2058 \n2059 def _make_find_query(query):\n2060     \"\"\"Convert the argument of Basic.find() into a callable\"\"\"\n2061     try:\n2062         query = sympify(query)\n2063     except SympifyError:\n2064         pass\n2065     if isinstance(query, type):\n2066         return lambda expr: isinstance(expr, query)\n2067     elif isinstance(query, Basic):\n2068         return lambda expr: expr.match(query) is not None\n2069     return query\n",
        "intended_behavior": "The method should correctly evaluate or substitute expressions involving infinity, such as `(x + cos(x)).subs(x, oo)` and `(exp(x) + cos(x)).subs(x, oo)`. The intended behavior here is to ensure consistency in how expressions involving infinity are simplified or evaluated, possibly by refining how mathematical functions like `exp` and `cos` handle substitutions involving `oo`. This might involve checking if additional conditions or special handling for infinite substitutions need to be integrated into the `.subs()` method to accommodate the mathematical properties of these functions consistently."
    },
    {
        "rel_file_path": "sympy/functions/elementary/exponential.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/functions/elementary/exponential.py",
        "start": 189,
        "end": 510,
        "class_name": "exp",
        "method_name": null,
        "code": "189 class exp(ExpBase):\n190     \"\"\"\n191     The exponential function, :math:`e^x`.\n192 \n193     See Also\n194     ========\n195 \n196     log\n197     \"\"\"\n198 \n199     def fdiff(self, argindex=1):\n200         \"\"\"\n201         Returns the first derivative of this function.\n202         \"\"\"\n203         if argindex == 1:\n204             return self\n205         else:\n206             raise ArgumentIndexError(self, argindex)\n207 \n208     def _eval_refine(self, assumptions):\n209         from sympy.assumptions import ask, Q\n210         arg = self.args[0]\n211         if arg.is_Mul:\n212             Ioo = S.ImaginaryUnit*S.Infinity\n213             if arg in [Ioo, -Ioo]:\n214                 return S.NaN\n215 \n216             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)\n217             if coeff:\n218                 if ask(Q.integer(2*coeff)):\n219                     if ask(Q.even(coeff)):\n220                         return S.One\n221                     elif ask(Q.odd(coeff)):\n222                         return S.NegativeOne\n223                     elif ask(Q.even(coeff + S.Half)):\n224                         return -S.ImaginaryUnit\n225                     elif ask(Q.odd(coeff + S.Half)):\n226                         return S.ImaginaryUnit\n227 \n228     @classmethod\n229     def eval(cls, arg):\n230         from sympy.calculus import AccumBounds\n231         from sympy.sets.setexpr import SetExpr\n232         from sympy.matrices.matrices import MatrixBase\n233         from sympy import logcombine\n234         if arg.is_Number:\n235             if arg is S.NaN:\n236                 return S.NaN\n237             elif arg.is_zero:\n238                 return S.One\n239             elif arg is S.One:\n240                 return S.Exp1\n241             elif arg is S.Infinity:\n242                 return S.Infinity\n243             elif arg is S.NegativeInfinity:\n244                 return S.Zero\n245         elif arg is S.ComplexInfinity:\n246             return S.NaN\n247         elif isinstance(arg, log):\n248             return arg.args[0]\n249         elif isinstance(arg, AccumBounds):\n250             return AccumBounds(exp(arg.min), exp(arg.max))\n251         elif isinstance(arg, SetExpr):\n252             return arg._eval_func(cls)\n253         elif arg.is_Mul:\n254             coeff = arg.as_coefficient(S.Pi*S.ImaginaryUnit)\n255             if coeff:\n256                 if (2*coeff).is_integer:\n257                     if coeff.is_even:\n258                         return S.One\n259                     elif coeff.is_odd:\n260                         return S.NegativeOne\n261                     elif (coeff + S.Half).is_even:\n262                         return -S.ImaginaryUnit\n263                     elif (coeff + S.Half).is_odd:\n264                         return S.ImaginaryUnit\n265                 elif coeff.is_Rational:\n266                     ncoeff = coeff % 2 # restrict to [0, 2pi)\n267                     if ncoeff > 1: # restrict to (-pi, pi]\n268                         ncoeff -= 2\n269                     if ncoeff != coeff:\n270                         return cls(ncoeff*S.Pi*S.ImaginaryUnit)\n271 \n272             # Warning: code in risch.py will be very sensitive to changes\n273             # in this (see DifferentialExtension).\n274 \n275             # look for a single log factor\n276 \n277             coeff, terms = arg.as_coeff_Mul()\n278 \n279             # but it can't be multiplied by oo\n280             if coeff in [S.NegativeInfinity, S.Infinity]:\n281                 return None\n282 \n283             coeffs, log_term = [coeff], None\n284             for term in Mul.make_args(terms):\n285                 term_ = logcombine(term)\n286                 if isinstance(term_, log):\n287                     if log_term is None:\n288                         log_term = term_.args[0]\n289                     else:\n290                         return None\n291                 elif term.is_comparable:\n292                     coeffs.append(term)\n293                 else:\n294                     return None\n295 \n296             return log_term**Mul(*coeffs) if log_term else None\n297 \n298         elif arg.is_Add:\n299             out = []\n300             add = []\n301             argchanged = False\n302             for a in arg.args:\n303                 if a is S.One:\n304                     add.append(a)\n305                     continue\n306                 newa = cls(a)\n307                 if isinstance(newa, cls):\n308                     if newa.args[0] != a:\n309                         add.append(newa.args[0])\n310                         argchanged = True\n311                     else:\n312                         add.append(a)\n313                 else:\n314                     out.append(newa)\n315             if out or argchanged:\n316                 return Mul(*out)*cls(Add(*add), evaluate=False)\n317 \n318         elif isinstance(arg, MatrixBase):\n319             return arg.exp()\n320 \n321         if arg.is_zero:\n322             return S.One\n323 \n324     @property\n325     def base(self):\n326         \"\"\"\n327         Returns the base of the exponential function.\n328         \"\"\"\n329         return S.Exp1\n330 \n331     @staticmethod\n332     @cacheit\n333     def taylor_term(n, x, *previous_terms):\n334         \"\"\"\n335         Calculates the next term in the Taylor series expansion.\n336         \"\"\"\n337         if n < 0:\n338             return S.Zero\n339         if n == 0:\n340             return S.One\n341         x = sympify(x)\n342         if previous_terms:\n343             p = previous_terms[-1]\n344             if p is not None:\n345                 return p * x / n\n346         return x**n/factorial(n)\n347 \n348     def as_real_imag(self, deep=True, **hints):\n349         \"\"\"\n350         Returns this function as a 2-tuple representing a complex number.\n351 \n352         Examples\n353         ========\n354 \n355         >>> from sympy import I\n356         >>> from sympy.abc import x\n357         >>> from sympy.functions import exp\n358         >>> exp(x).as_real_imag()\n359         (exp(re(x))*cos(im(x)), exp(re(x))*sin(im(x)))\n360         >>> exp(1).as_real_imag()\n361         (E, 0)\n362         >>> exp(I).as_real_imag()\n363         (cos(1), sin(1))\n364         >>> exp(1+I).as_real_imag()\n365         (E*cos(1), E*sin(1))\n366 \n367         See Also\n368         ========\n369 \n370         sympy.functions.elementary.complexes.re\n371         sympy.functions.elementary.complexes.im\n372         \"\"\"\n373         import sympy\n374         re, im = self.args[0].as_real_imag()\n375         if deep:\n376             re = re.expand(deep, **hints)\n377             im = im.expand(deep, **hints)\n378         cos, sin = sympy.cos(im), sympy.sin(im)\n379         return (exp(re)*cos, exp(re)*sin)\n380 \n381     def _eval_subs(self, old, new):\n382         # keep processing of power-like args centralized in Pow\n383         if old.is_Pow:  # handle (exp(3*log(x))).subs(x**2, z) -> z**(3/2)\n384             old = exp(old.exp*log(old.base))\n385         elif old is S.Exp1 and new.is_Function:\n386             old = exp\n387         if isinstance(old, exp) or old is S.Exp1:\n388             f = lambda a: Pow(*a.as_base_exp(), evaluate=False) if (\n389                 a.is_Pow or isinstance(a, exp)) else a\n390             return Pow._eval_subs(f(self), f(old), new)\n391 \n392         if old is exp and not new.is_Function:\n393             return new**self.exp._subs(old, new)\n394         return Function._eval_subs(self, old, new)\n395 \n396     def _eval_is_extended_real(self):\n397         if self.args[0].is_extended_real:\n398             return True\n399         elif self.args[0].is_imaginary:\n400             arg2 = -S(2) * S.ImaginaryUnit * self.args[0] / S.Pi\n401             return arg2.is_even\n402 \n403     def _eval_is_complex(self):\n404         def complex_extended_negative(arg):\n405             yield arg.is_complex\n406             yield arg.is_extended_negative\n407         return fuzzy_or(complex_extended_negative(self.args[0]))\n408 \n409     def _eval_is_algebraic(self):\n410         s = self.func(*self.args)\n411         if s.func == self.func:\n412             if fuzzy_not(self.exp.is_zero):\n413                 if self.exp.is_algebraic:\n414                     return False\n415                 elif (self.exp/S.Pi).is_rational:\n416                     return False\n417         else:\n418             return s.is_algebraic\n419 \n420     def _eval_is_extended_positive(self):\n421         if self.args[0].is_extended_real:\n422             return not self.args[0] is S.NegativeInfinity\n423         elif self.args[0].is_imaginary:\n424             arg2 = -S.ImaginaryUnit * self.args[0] / S.Pi\n425             return arg2.is_even\n426 \n427     def _eval_nseries(self, x, n, logx):\n428         # NOTE Please see the comment at the beginning of this file, labelled\n429         #      IMPORTANT.\n430         from sympy import limit, oo, Order, powsimp, Wild, expand_complex\n431         arg = self.args[0]\n432         arg_series = arg._eval_nseries(x, n=n, logx=logx)\n433         if arg_series.is_Order:\n434             return 1 + arg_series\n435         arg0 = limit(arg_series.removeO(), x, 0)\n436         if arg0 in [-oo, oo]:\n437             return self\n438         t = Dummy(\"t\")\n439         exp_series = exp(t)._taylor(t, n)\n440         o = exp_series.getO()\n441         exp_series = exp_series.removeO()\n442         r = exp(arg0)*exp_series.subs(t, arg_series - arg0)\n443         r += Order(o.expr.subs(t, (arg_series - arg0)), x)\n444         r = r.expand()\n445         r = powsimp(r, deep=True, combine='exp')\n446         # powsimp may introduce unexpanded (-1)**Rational; see PR #17201\n447         simplerat = lambda x: x.is_Rational and x.q in [3, 4, 6]\n448         w = Wild('w', properties=[simplerat])\n449         r = r.replace((-1)**w, expand_complex((-1)**w))\n450         return r\n451 \n452     def _taylor(self, x, n):\n453         from sympy import Order\n454         l = []\n455         g = None\n456         for i in range(n):\n457             g = self.taylor_term(i, self.args[0], g)\n458             g = g.nseries(x, n=n)\n459             l.append(g)\n460         return Add(*l) + Order(x**n, x)\n461 \n462     def _eval_as_leading_term(self, x):\n463         from sympy import Order\n464         arg = self.args[0]\n465         if arg.is_Add:\n466             return Mul(*[exp(f).as_leading_term(x) for f in arg.args])\n467         arg_1 = arg.as_leading_term(x)\n468         if Order(x, x).contains(arg_1):\n469             return S.One\n470         if Order(1, x).contains(arg_1):\n471             return exp(arg_1)\n472         ####################################################\n473         # The correct result here should be 'None'.        #\n474         # Indeed arg in not bounded as x tends to 0.       #\n475         # Consequently the series expansion does not admit #\n476         # the leading term.                                #\n477         # For compatibility reasons, the return value here #\n478         # is the original function, i.e. exp(arg),         #\n479         # instead of None.                                 #\n480         ####################################################\n481         return exp(arg)\n482 \n483     def _eval_rewrite_as_sin(self, arg, **kwargs):\n484         from sympy import sin\n485         I = S.ImaginaryUnit\n486         return sin(I*arg + S.Pi/2) - I*sin(I*arg)\n487 \n488     def _eval_rewrite_as_cos(self, arg, **kwargs):\n489         from sympy import cos\n490         I = S.ImaginaryUnit\n491         return cos(I*arg) + I*cos(I*arg + S.Pi/2)\n492 \n493     def _eval_rewrite_as_tanh(self, arg, **kwargs):\n494         from sympy import tanh\n495         return (1 + tanh(arg/2))/(1 - tanh(arg/2))\n496 \n497     def _eval_rewrite_as_sqrt(self, arg, **kwargs):\n498         from sympy.functions.elementary.trigonometric import sin, cos\n499         if arg.is_Mul:\n500             coeff = arg.coeff(S.Pi*S.ImaginaryUnit)\n501             if coeff and coeff.is_number:\n502                 cosine, sine = cos(S.Pi*coeff), sin(S.Pi*coeff)\n503                 if not isinstance(cosine, cos) and not isinstance (sine, sin):\n504                     return cosine + S.ImaginaryUnit*sine\n505 \n506     def _eval_rewrite_as_Pow(self, arg, **kwargs):\n507         if arg.is_Mul:\n508             logs = [a for a in arg.args if isinstance(a, log) and len(a.args) == 1]\n509             if logs:\n510                 return Pow(logs[0].args[0], arg.coeff(logs[0]))\n",
        "intended_behavior": "Ensure that the `exp` function's behavior when its variable tends towards infinity is consistent with mathematical principles and compatible with how the `.subs()` method processes such cases. Specifically, when `exp(x)` is evaluated at `x = oo`, the result should reflect the expected mathematical outcome (i.e., `oo`), and this evaluation should be handled in a manner consistent with the behavior observed in other similar expressions."
    },
    {
        "rel_file_path": "sympy/functions/elementary/trigonometric.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/functions/elementary/trigonometric.py",
        "start": 494,
        "end": 927,
        "class_name": "cos",
        "method_name": null,
        "code": "494 class cos(TrigonometricFunction):\n495     \"\"\"\n496     The cosine function.\n497 \n498     Returns the cosine of x (measured in radians).\n499 \n500     Notes\n501     =====\n502 \n503     See :func:`sin` for notes about automatic evaluation.\n504 \n505     Examples\n506     ========\n507 \n508     >>> from sympy import cos, pi\n509     >>> from sympy.abc import x\n510     >>> cos(x**2).diff(x)\n511     -2*x*sin(x**2)\n512     >>> cos(1).diff(x)\n513     0\n514     >>> cos(pi)\n515     -1\n516     >>> cos(pi/2)\n517     0\n518     >>> cos(2*pi/3)\n519     -1/2\n520     >>> cos(pi/12)\n521     sqrt(2)/4 + sqrt(6)/4\n522 \n523     See Also\n524     ========\n525 \n526     sin, csc, sec, tan, cot\n527     asin, acsc, acos, asec, atan, acot, atan2\n528 \n529     References\n530     ==========\n531 \n532     .. [1] https://en.wikipedia.org/wiki/Trigonometric_functions\n533     .. [2] http://dlmf.nist.gov/4.14\n534     .. [3] http://functions.wolfram.com/ElementaryFunctions/Cos\n535 \n536     \"\"\"\n537 \n538     def period(self, symbol=None):\n539         return self._period(2*pi, symbol)\n540 \n541     def fdiff(self, argindex=1):\n542         if argindex == 1:\n543             return -sin(self.args[0])\n544         else:\n545             raise ArgumentIndexError(self, argindex)\n546 \n547     @classmethod\n548     def eval(cls, arg):\n549         from sympy.functions.special.polynomials import chebyshevt\n550         from sympy.calculus.util import AccumBounds\n551         from sympy.sets.setexpr import SetExpr\n552         if arg.is_Number:\n553             if arg is S.NaN:\n554                 return S.NaN\n555             elif arg.is_zero:\n556                 return S.One\n557             elif arg is S.Infinity or arg is S.NegativeInfinity:\n558                 # In this case it is better to return AccumBounds(-1, 1)\n559                 # rather than returning S.NaN, since AccumBounds(-1, 1)\n560                 # preserves the information that sin(oo) is between\n561                 # -1 and 1, where S.NaN does not do that.\n562                 return AccumBounds(-1, 1)\n563 \n564         if arg is S.ComplexInfinity:\n565             return S.NaN\n566 \n567         if isinstance(arg, AccumBounds):\n568             return sin(arg + S.Pi/2)\n569         elif isinstance(arg, SetExpr):\n570             return arg._eval_func(cls)\n571 \n572         if arg.could_extract_minus_sign():\n573             return cls(-arg)\n574 \n575         i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n576         if i_coeff is not None:\n577             return cosh(i_coeff)\n578 \n579         pi_coeff = _pi_coeff(arg)\n580         if pi_coeff is not None:\n581             if pi_coeff.is_integer:\n582                 return (S.NegativeOne)**pi_coeff\n583 \n584             if (2*pi_coeff).is_integer:\n585                 # is_even-case handled above as then pi_coeff.is_integer,\n586                 # so check if known to be not even\n587                 if pi_coeff.is_even is False:\n588                     return S.Zero\n589 \n590             if not pi_coeff.is_Rational:\n591                 narg = pi_coeff*S.Pi\n592                 if narg != arg:\n593                     return cls(narg)\n594                 return None\n595 \n596             # cosine formula #####################\n597             # https://github.com/sympy/sympy/issues/6048\n598             # explicit calculations are performed for\n599             # cos(k pi/n) for n = 8,10,12,15,20,24,30,40,60,120\n600             # Some other exact values like cos(k pi/240) can be\n601             # calculated using a partial-fraction decomposition\n602             # by calling cos( X ).rewrite(sqrt)\n603             cst_table_some = {\n604                 3: S.Half,\n605                 5: (sqrt(5) + 1)/4,\n606             }\n607             if pi_coeff.is_Rational:\n608                 q = pi_coeff.q\n609                 p = pi_coeff.p % (2*q)\n610                 if p > q:\n611                     narg = (pi_coeff - 1)*S.Pi\n612                     return -cls(narg)\n613                 if 2*p > q:\n614                     narg = (1 - pi_coeff)*S.Pi\n615                     return -cls(narg)\n616 \n617                 # If nested sqrt's are worse than un-evaluation\n618                 # you can require q to be in (1, 2, 3, 4, 6, 12)\n619                 # q <= 12, q=15, q=20, q=24, q=30, q=40, q=60, q=120 return\n620                 # expressions with 2 or fewer sqrt nestings.\n621                 table2 = {\n622                     12: (3, 4),\n623                     20: (4, 5),\n624                     30: (5, 6),\n625                     15: (6, 10),\n626                     24: (6, 8),\n627                     40: (8, 10),\n628                     60: (20, 30),\n629                     120: (40, 60)\n630                     }\n631                 if q in table2:\n632                     a, b = p*S.Pi/table2[q][0], p*S.Pi/table2[q][1]\n633                     nvala, nvalb = cls(a), cls(b)\n634                     if None == nvala or None == nvalb:\n635                         return None\n636                     return nvala*nvalb + cls(S.Pi/2 - a)*cls(S.Pi/2 - b)\n637 \n638                 if q > 12:\n639                     return None\n640 \n641                 if q in cst_table_some:\n642                     cts = cst_table_some[pi_coeff.q]\n643                     return chebyshevt(pi_coeff.p, cts).expand()\n644 \n645                 if 0 == q % 2:\n646                     narg = (pi_coeff*2)*S.Pi\n647                     nval = cls(narg)\n648                     if None == nval:\n649                         return None\n650                     x = (2*pi_coeff + 1)/2\n651                     sign_cos = (-1)**((-1 if x < 0 else 1)*int(abs(x)))\n652                     return sign_cos*sqrt( (1 + nval)/2 )\n653             return None\n654 \n655         if arg.is_Add:\n656             x, m = _peeloff_pi(arg)\n657             if m:\n658                 return cos(m)*cos(x) - sin(m)*sin(x)\n659 \n660         if arg.is_zero:\n661             return S.One\n662 \n663         if isinstance(arg, acos):\n664             return arg.args[0]\n665 \n666         if isinstance(arg, atan):\n667             x = arg.args[0]\n668             return 1/sqrt(1 + x**2)\n669 \n670         if isinstance(arg, atan2):\n671             y, x = arg.args\n672             return x/sqrt(x**2 + y**2)\n673 \n674         if isinstance(arg, asin):\n675             x = arg.args[0]\n676             return sqrt(1 - x ** 2)\n677 \n678         if isinstance(arg, acot):\n679             x = arg.args[0]\n680             return 1/sqrt(1 + 1/x**2)\n681 \n682         if isinstance(arg, acsc):\n683             x = arg.args[0]\n684             return sqrt(1 - 1/x**2)\n685 \n686         if isinstance(arg, asec):\n687             x = arg.args[0]\n688             return 1/x\n689 \n690     @staticmethod\n691     @cacheit\n692     def taylor_term(n, x, *previous_terms):\n693         if n < 0 or n % 2 == 1:\n694             return S.Zero\n695         else:\n696             x = sympify(x)\n697 \n698             if len(previous_terms) > 2:\n699                 p = previous_terms[-2]\n700                 return -p*x**2/(n*(n - 1))\n701             else:\n702                 return (-1)**(n//2)*x**(n)/factorial(n)\n703 \n704     def _eval_rewrite_as_exp(self, arg, **kwargs):\n705         I = S.ImaginaryUnit\n706         if isinstance(arg, TrigonometricFunction) or isinstance(arg, HyperbolicFunction):\n707             arg = arg.func(arg.args[0]).rewrite(exp)\n708         return (exp(arg*I) + exp(-arg*I))/2\n709 \n710     def _eval_rewrite_as_Pow(self, arg, **kwargs):\n711         if isinstance(arg, log):\n712             I = S.ImaginaryUnit\n713             x = arg.args[0]\n714             return x**I/2 + x**-I/2\n715 \n716     def _eval_rewrite_as_sin(self, arg, **kwargs):\n717         return sin(arg + S.Pi/2, evaluate=False)\n718 \n719     def _eval_rewrite_as_tan(self, arg, **kwargs):\n720         tan_half = tan(S.Half*arg)**2\n721         return (1 - tan_half)/(1 + tan_half)\n722 \n723     def _eval_rewrite_as_sincos(self, arg, **kwargs):\n724         return sin(arg)*cos(arg)/sin(arg)\n725 \n726     def _eval_rewrite_as_cot(self, arg, **kwargs):\n727         cot_half = cot(S.Half*arg)**2\n728         return (cot_half - 1)/(cot_half + 1)\n729 \n730     def _eval_rewrite_as_pow(self, arg, **kwargs):\n731         return self._eval_rewrite_as_sqrt(arg)\n732 \n733     def _eval_rewrite_as_sqrt(self, arg, **kwargs):\n734         from sympy.functions.special.polynomials import chebyshevt\n735 \n736         def migcdex(x):\n737             # recursive calcuation of gcd and linear combination\n738             # for a sequence of integers.\n739             # Given  (x1, x2, x3)\n740             # Returns (y1, y1, y3, g)\n741             # such that g is the gcd and x1*y1+x2*y2+x3*y3 - g = 0\n742             # Note, that this is only one such linear combination.\n743             if len(x) == 1:\n744                 return (1, x[0])\n745             if len(x) == 2:\n746                 return igcdex(x[0], x[-1])\n747             g = migcdex(x[1:])\n748             u, v, h = igcdex(x[0], g[-1])\n749             return tuple([u] + [v*i for i in g[0:-1] ] + [h])\n750 \n751         def ipartfrac(r, factors=None):\n752             from sympy.ntheory import factorint\n753             if isinstance(r, int):\n754                 return r\n755             if not isinstance(r, Rational):\n756                 raise TypeError(\"r is not rational\")\n757             n = r.q\n758             if 2 > r.q*r.q:\n759                 return r.q\n760 \n761             if None == factors:\n762                 a = [n//x**y for x, y in factorint(r.q).items()]\n763             else:\n764                 a = [n//x for x in factors]\n765             if len(a) == 1:\n766                 return [ r ]\n767             h = migcdex(a)\n768             ans = [ r.p*Rational(i*j, r.q) for i, j in zip(h[:-1], a) ]\n769             assert r == sum(ans)\n770             return ans\n771         pi_coeff = _pi_coeff(arg)\n772         if pi_coeff is None:\n773             return None\n774 \n775         if pi_coeff.is_integer:\n776             # it was unevaluated\n777             return self.func(pi_coeff*S.Pi)\n778 \n779         if not pi_coeff.is_Rational:\n780             return None\n781 \n782         def _cospi257():\n783             \"\"\" Express cos(pi/257) explicitly as a function of radicals\n784                 Based upon the equations in\n785                 http://math.stackexchange.com/questions/516142/how-does-cos2-pi-257-look-like-in-real-radicals\n786                 See also http://www.susqu.edu/brakke/constructions/257-gon.m.txt\n787             \"\"\"\n788             def f1(a, b):\n789                 return (a + sqrt(a**2 + b))/2, (a - sqrt(a**2 + b))/2\n790 \n791             def f2(a, b):\n792                 return (a - sqrt(a**2 + b))/2\n793 \n794             t1, t2 = f1(-1, 256)\n795             z1, z3 = f1(t1, 64)\n796             z2, z4 = f1(t2, 64)\n797             y1, y5 = f1(z1, 4*(5 + t1 + 2*z1))\n798             y6, y2 = f1(z2, 4*(5 + t2 + 2*z2))\n799             y3, y7 = f1(z3, 4*(5 + t1 + 2*z3))\n800             y8, y4 = f1(z4, 4*(5 + t2 + 2*z4))\n801             x1, x9 = f1(y1, -4*(t1 + y1 + y3 + 2*y6))\n802             x2, x10 = f1(y2, -4*(t2 + y2 + y4 + 2*y7))\n803             x3, x11 = f1(y3, -4*(t1 + y3 + y5 + 2*y8))\n804             x4, x12 = f1(y4, -4*(t2 + y4 + y6 + 2*y1))\n805             x5, x13 = f1(y5, -4*(t1 + y5 + y7 + 2*y2))\n806             x6, x14 = f1(y6, -4*(t2 + y6 + y8 + 2*y3))\n807             x15, x7 = f1(y7, -4*(t1 + y7 + y1 + 2*y4))\n808             x8, x16 = f1(y8, -4*(t2 + y8 + y2 + 2*y5))\n809             v1 = f2(x1, -4*(x1 + x2 + x3 + x6))\n810             v2 = f2(x2, -4*(x2 + x3 + x4 + x7))\n811             v3 = f2(x8, -4*(x8 + x9 + x10 + x13))\n812             v4 = f2(x9, -4*(x9 + x10 + x11 + x14))\n813             v5 = f2(x10, -4*(x10 + x11 + x12 + x15))\n814             v6 = f2(x16, -4*(x16 + x1 + x2 + x5))\n815             u1 = -f2(-v1, -4*(v2 + v3))\n816             u2 = -f2(-v4, -4*(v5 + v6))\n817             w1 = -2*f2(-u1, -4*u2)\n818             return sqrt(sqrt(2)*sqrt(w1 + 4)/8 + S.Half)\n819 \n820         cst_table_some = {\n821             3: S.Half,\n822             5: (sqrt(5) + 1)/4,\n823             17: sqrt((15 + sqrt(17))/32 + sqrt(2)*(sqrt(17 - sqrt(17)) +\n824                 sqrt(sqrt(2)*(-8*sqrt(17 + sqrt(17)) - (1 - sqrt(17))\n825                 *sqrt(17 - sqrt(17))) + 6*sqrt(17) + 34))/32),\n826             257: _cospi257()\n827             # 65537 is the only other known Fermat prime and the very\n828             # large expression is intentionally omitted from SymPy; see\n829             # http://www.susqu.edu/brakke/constructions/65537-gon.m.txt\n830         }\n831 \n832         def _fermatCoords(n):\n833             # if n can be factored in terms of Fermat primes with\n834             # multiplicity of each being 1, return those primes, else\n835             # False\n836             primes = []\n837             for p_i in cst_table_some:\n838                 quotient, remainder = divmod(n, p_i)\n839                 if remainder == 0:\n840                     n = quotient\n841                     primes.append(p_i)\n842                     if n == 1:\n843                         return tuple(primes)\n844             return False\n845 \n846         if pi_coeff.q in cst_table_some:\n847             rv = chebyshevt(pi_coeff.p, cst_table_some[pi_coeff.q])\n848             if pi_coeff.q < 257:\n849                 rv = rv.expand()\n850             return rv\n851 \n852         if not pi_coeff.q % 2:  # recursively remove factors of 2\n853             pico2 = pi_coeff*2\n854             nval = cos(pico2*S.Pi).rewrite(sqrt)\n855             x = (pico2 + 1)/2\n856             sign_cos = -1 if int(x) % 2 else 1\n857             return sign_cos*sqrt( (1 + nval)/2 )\n858 \n859         FC = _fermatCoords(pi_coeff.q)\n860         if FC:\n861             decomp = ipartfrac(pi_coeff, FC)\n862             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n863             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n864             return pcls.rewrite(sqrt)\n865         else:\n866             decomp = ipartfrac(pi_coeff)\n867             X = [(x[1], x[0]*S.Pi) for x in zip(decomp, numbered_symbols('z'))]\n868             pcls = cos(sum([x[0] for x in X]))._eval_expand_trig().subs(X)\n869             return pcls\n870 \n871     def _eval_rewrite_as_sec(self, arg, **kwargs):\n872         return 1/sec(arg)\n873 \n874     def _eval_rewrite_as_csc(self, arg, **kwargs):\n875         return 1/sec(arg).rewrite(csc)\n876 \n877     def _eval_conjugate(self):\n878         return self.func(self.args[0].conjugate())\n879 \n880     def as_real_imag(self, deep=True, **hints):\n881         re, im = self._as_real_imag(deep=deep, **hints)\n882         return (cos(re)*cosh(im), -sin(re)*sinh(im))\n883 \n884     def _eval_expand_trig(self, **hints):\n885         from sympy.functions.special.polynomials import chebyshevt\n886         arg = self.args[0]\n887         x = None\n888         if arg.is_Add:  # TODO: Do this more efficiently for more than two terms\n889             x, y = arg.as_two_terms()\n890             sx = sin(x, evaluate=False)._eval_expand_trig()\n891             sy = sin(y, evaluate=False)._eval_expand_trig()\n892             cx = cos(x, evaluate=False)._eval_expand_trig()\n893             cy = cos(y, evaluate=False)._eval_expand_trig()\n894             return cx*cy - sx*sy\n895         else:\n896             coeff, terms = arg.as_coeff_Mul(rational=True)\n897             if coeff.is_Integer:\n898                 return chebyshevt(coeff, cos(terms))\n899             pi_coeff = _pi_coeff(arg)\n900             if pi_coeff is not None:\n901                 if pi_coeff.is_Rational:\n902                     return self.rewrite(sqrt)\n903         return cos(arg)\n904 \n905     def _eval_as_leading_term(self, x):\n906         from sympy import Order\n907         arg = self.args[0].as_leading_term(x)\n908 \n909         if x in arg.free_symbols and Order(1, x).contains(arg):\n910             return S.One\n911         else:\n912             return self.func(arg)\n913 \n914     def _eval_is_extended_real(self):\n915         if self.args[0].is_extended_real:\n916             return True\n917 \n918     def _eval_is_finite(self):\n919         arg = self.args[0]\n920 \n921         if arg.is_extended_real:\n922             return True\n923 \n924     def _eval_is_complex(self):\n925         if self.args[0].is_extended_real \\\n926             or self.args[0].is_complex:\n927             return True\n",
        "intended_behavior": "For `cos(x)` where `x` is substituted with `oo`, it's not about altering the `cos` function's inherent behavior at infinity but ensuring that its handling within expressions substituted at infinity is consistent. Since `cos(x)` doesn't have a limit as `x` approaches infinity, the substitution might either need to prevent simplistic numerical evaluations or work cohesively with constructs like `AccumBounds` to present a result that accurately represents the function's behavior at infinity."
    }
]