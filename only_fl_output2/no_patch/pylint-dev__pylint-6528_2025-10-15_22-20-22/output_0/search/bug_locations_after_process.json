[
    {
        "rel_file_path": "pylint/config/arguments_manager.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/arguments_manager.py",
        "start": 60,
        "end": 753,
        "class_name": "_ArgumentsManager",
        "method_name": null,
        "code": "60 class _ArgumentsManager:\n61     \"\"\"Arguments manager class used to handle command-line arguments and options.\"\"\"\n62 \n63     def __init__(\n64         self, prog: str, usage: str | None = None, description: str | None = None\n65     ) -> None:\n66         self._config = argparse.Namespace()\n67         \"\"\"Namespace for all options.\"\"\"\n68 \n69         self._arg_parser = argparse.ArgumentParser(\n70             prog=prog,\n71             usage=usage or \"%(prog)s [options]\",\n72             description=description,\n73             formatter_class=_HelpFormatter,\n74         )\n75         \"\"\"The command line argument parser.\"\"\"\n76 \n77         self._argument_groups_dict: dict[str, argparse._ArgumentGroup] = {}\n78         \"\"\"Dictionary of all the argument groups.\"\"\"\n79 \n80         self._option_dicts: dict[str, OptionDict] = {}\n81         \"\"\"All option dictionaries that have been registered.\"\"\"\n82 \n83         # TODO: 3.0: Remove deprecated attributes introduced to keep API\n84         # parity with optparse. Until '_maxlevel'\n85         with warnings.catch_warnings():\n86             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n87             self.reset_parsers(usage or \"\")\n88         # list of registered options providers\n89         self._options_providers: list[ConfigProvider] = []\n90         # dictionary associating option name to checker\n91         self._all_options: OrderedDict[str, ConfigProvider] = OrderedDict()\n92         self._short_options: dict[str, str] = {}\n93         self._nocallback_options: dict[ConfigProvider, str] = {}\n94         self._mygroups: dict[str, optparse.OptionGroup] = {}\n95         # verbosity\n96         self._maxlevel: int = 0\n97 \n98     @property\n99     def config(self) -> argparse.Namespace:\n100         \"\"\"Namespace for all options.\"\"\"\n101         return self._config\n102 \n103     @config.setter\n104     def config(self, value: argparse.Namespace) -> None:\n105         self._config = value\n106 \n107     @property\n108     def options_providers(self) -> list[ConfigProvider]:\n109         # TODO: 3.0: Remove deprecated attribute.\n110         warnings.warn(\n111             \"options_providers has been deprecated. It will be removed in pylint 3.0.\",\n112             DeprecationWarning,\n113         )\n114         return self._options_providers\n115 \n116     @options_providers.setter\n117     def options_providers(self, value: list[ConfigProvider]) -> None:\n118         warnings.warn(\n119             \"Setting options_providers has been deprecated. It will be removed in pylint 3.0.\",\n120             DeprecationWarning,\n121         )\n122         self._options_providers = value\n123 \n124     def _register_options_provider(self, provider: _ArgumentsProvider) -> None:\n125         \"\"\"Register an options provider and load its defaults.\"\"\"\n126         for opt, optdict in provider.options:\n127             self._option_dicts[opt] = optdict\n128             argument = _convert_option_to_argument(opt, optdict)\n129             section = argument.section or provider.name.capitalize()\n130 \n131             section_desc = provider.option_groups_descs.get(section, None)\n132 \n133             # We exclude master since its docstring comes from PyLinter\n134             if provider.name != MAIN_CHECKER_NAME and provider.__doc__:\n135                 section_desc = provider.__doc__.split(\"\\n\\n\")[0]\n136 \n137             self._add_arguments_to_parser(section, section_desc, argument)\n138 \n139         self._load_default_argument_values()\n140 \n141     def _add_arguments_to_parser(\n142         self, section: str, section_desc: str | None, argument: _Argument\n143     ) -> None:\n144         \"\"\"Add an argument to the correct argument section/group.\"\"\"\n145         try:\n146             section_group = self._argument_groups_dict[section]\n147         except KeyError:\n148             if section_desc:\n149                 section_group = self._arg_parser.add_argument_group(\n150                     section, section_desc\n151                 )\n152             else:\n153                 section_group = self._arg_parser.add_argument_group(title=section)\n154             self._argument_groups_dict[section] = section_group\n155         self._add_parser_option(section_group, argument)\n156 \n157     @staticmethod\n158     def _add_parser_option(\n159         section_group: argparse._ArgumentGroup, argument: _Argument\n160     ) -> None:\n161         \"\"\"Add an argument.\"\"\"\n162         if isinstance(argument, _StoreArgument):\n163             section_group.add_argument(\n164                 *argument.flags,\n165                 action=argument.action,\n166                 default=argument.default,\n167                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n168                 help=argument.help,\n169                 metavar=argument.metavar,\n170                 choices=argument.choices,\n171             )\n172         elif isinstance(argument, _StoreOldNamesArgument):\n173             section_group.add_argument(\n174                 *argument.flags,\n175                 **argument.kwargs,\n176                 action=argument.action,\n177                 default=argument.default,\n178                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n179                 help=argument.help,\n180                 metavar=argument.metavar,\n181                 choices=argument.choices,\n182             )\n183             # We add the old name as hidden option to make it's default value gets loaded when\n184             # argparse initializes all options from the checker\n185             assert argument.kwargs[\"old_names\"]\n186             for old_name in argument.kwargs[\"old_names\"]:\n187                 section_group.add_argument(\n188                     f\"--{old_name}\",\n189                     action=\"store\",\n190                     default=argument.default,\n191                     type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n192                     help=argparse.SUPPRESS,\n193                     metavar=argument.metavar,\n194                     choices=argument.choices,\n195                 )\n196         elif isinstance(argument, _StoreNewNamesArgument):\n197             section_group.add_argument(\n198                 *argument.flags,\n199                 **argument.kwargs,\n200                 action=argument.action,\n201                 default=argument.default,\n202                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n203                 help=argument.help,\n204                 metavar=argument.metavar,\n205                 choices=argument.choices,\n206             )\n207         elif isinstance(argument, _StoreTrueArgument):\n208             section_group.add_argument(\n209                 *argument.flags,\n210                 action=argument.action,\n211                 default=argument.default,\n212                 help=argument.help,\n213             )\n214         elif isinstance(argument, _CallableArgument):\n215             section_group.add_argument(\n216                 *argument.flags,\n217                 **argument.kwargs,\n218                 action=argument.action,\n219                 help=argument.help,\n220                 metavar=argument.metavar,\n221             )\n222         elif isinstance(argument, _ExtendArgument):\n223             section_group.add_argument(\n224                 *argument.flags,\n225                 action=argument.action,\n226                 default=argument.default,\n227                 type=argument.type,  # type: ignore[arg-type] # incorrect typing in typeshed\n228                 help=argument.help,\n229                 metavar=argument.metavar,\n230                 choices=argument.choices,\n231                 dest=argument.dest,\n232             )\n233         else:\n234             raise UnrecognizedArgumentAction\n235 \n236     def _load_default_argument_values(self) -> None:\n237         \"\"\"Loads the default values of all registered options.\"\"\"\n238         self.config = self._arg_parser.parse_args([], self.config)\n239 \n240     def _parse_configuration_file(self, arguments: list[str]) -> None:\n241         \"\"\"Parse the arguments found in a configuration file into the namespace.\"\"\"\n242         self.config, parsed_args = self._arg_parser.parse_known_args(\n243             arguments, self.config\n244         )\n245         unrecognized_options: list[str] = []\n246         for opt in parsed_args:\n247             if opt.startswith(\"--\"):\n248                 unrecognized_options.append(opt[2:])\n249         if unrecognized_options:\n250             raise _UnrecognizedOptionError(options=unrecognized_options)\n251 \n252     def _parse_command_line_configuration(\n253         self, arguments: Sequence[str] | None = None\n254     ) -> list[str]:\n255         \"\"\"Parse the arguments found on the command line into the namespace.\"\"\"\n256         arguments = sys.argv[1:] if arguments is None else arguments\n257 \n258         self.config, parsed_args = self._arg_parser.parse_known_args(\n259             arguments, self.config\n260         )\n261 \n262         return parsed_args\n263 \n264     def reset_parsers(self, usage: str = \"\") -> None:  # pragma: no cover\n265         \"\"\"DEPRECATED.\"\"\"\n266         warnings.warn(\n267             \"reset_parsers has been deprecated. Parsers should be instantiated \"\n268             \"once during initialization and do not need to be reset.\",\n269             DeprecationWarning,\n270         )\n271         # configuration file parser\n272         self.cfgfile_parser = configparser.ConfigParser(\n273             inline_comment_prefixes=(\"#\", \";\")\n274         )\n275         # command line parser\n276         self.cmdline_parser = OptionParser(Option, usage=usage)\n277         self.cmdline_parser.options_manager = self  # type: ignore[attr-defined]\n278         self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)\n279 \n280     def register_options_provider(\n281         self, provider: ConfigProvider, own_group: bool = True\n282     ) -> None:  # pragma: no cover\n283         \"\"\"DEPRECATED: Register an options provider.\"\"\"\n284         warnings.warn(\n285             \"register_options_provider has been deprecated. Options providers and \"\n286             \"arguments providers should be registered by initializing ArgumentsProvider. \"\n287             \"This automatically registers the provider on the ArgumentsManager.\",\n288             DeprecationWarning,\n289         )\n290         self.options_providers.append(provider)\n291         non_group_spec_options = [\n292             option for option in provider.options if \"group\" not in option[1]\n293         ]\n294         groups = getattr(provider, \"option_groups\", ())\n295         if own_group and non_group_spec_options:\n296             with warnings.catch_warnings():\n297                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n298                 self.add_option_group(\n299                     provider.name.upper(),\n300                     provider.__doc__,\n301                     non_group_spec_options,\n302                     provider,\n303                 )\n304         else:\n305             for opt, optdict in non_group_spec_options:\n306                 with warnings.catch_warnings():\n307                     warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n308                     self.add_optik_option(provider, self.cmdline_parser, opt, optdict)\n309         for gname, gdoc in groups:\n310             gname = gname.upper()\n311             goptions = [\n312                 option\n313                 for option in provider.options\n314                 if option[1].get(\"group\", \"\").upper() == gname  # type: ignore[union-attr]\n315             ]\n316             with warnings.catch_warnings():\n317                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n318                 self.add_option_group(gname, gdoc, goptions, provider)\n319 \n320     def add_option_group(\n321         self,\n322         group_name: str,\n323         _: str | None,\n324         options: list[tuple[str, OptionDict]],\n325         provider: ConfigProvider,\n326     ) -> None:  # pragma: no cover\n327         \"\"\"DEPRECATED.\"\"\"\n328         warnings.warn(\n329             \"add_option_group has been deprecated. Option groups should be \"\n330             \"registered by initializing ArgumentsProvider. \"\n331             \"This automatically registers the group on the ArgumentsManager.\",\n332             DeprecationWarning,\n333         )\n334         # add option group to the command line parser\n335         if group_name in self._mygroups:\n336             group = self._mygroups[group_name]\n337         else:\n338             group = optparse.OptionGroup(\n339                 self.cmdline_parser, title=group_name.capitalize()\n340             )\n341             self.cmdline_parser.add_option_group(group)\n342             self._mygroups[group_name] = group\n343             # add section to the config file\n344             if (\n345                 group_name != \"DEFAULT\"\n346                 and group_name not in self.cfgfile_parser._sections  # type: ignore[attr-defined]\n347             ):\n348                 self.cfgfile_parser.add_section(group_name)\n349         # add provider's specific options\n350         for opt, optdict in options:\n351             if not isinstance(optdict.get(\"action\", \"store\"), str):\n352                 optdict[\"action\"] = \"callback\"\n353             with warnings.catch_warnings():\n354                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n355                 self.add_optik_option(provider, group, opt, optdict)\n356 \n357     def add_optik_option(\n358         self,\n359         provider: ConfigProvider,\n360         optikcontainer: optparse.OptionParser | optparse.OptionGroup,\n361         opt: str,\n362         optdict: OptionDict,\n363     ) -> None:  # pragma: no cover\n364         \"\"\"DEPRECATED.\"\"\"\n365         warnings.warn(\n366             \"add_optik_option has been deprecated. Options should be automatically \"\n367             \"added by initializing an ArgumentsProvider.\",\n368             DeprecationWarning,\n369         )\n370         with warnings.catch_warnings():\n371             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n372             args, optdict = self.optik_option(provider, opt, optdict)\n373         option = optikcontainer.add_option(*args, **optdict)\n374         self._all_options[opt] = provider\n375         self._maxlevel = max(self._maxlevel, option.level or 0)\n376 \n377     def optik_option(\n378         self, provider: ConfigProvider, opt: str, optdict: OptionDict\n379     ) -> tuple[list[str], OptionDict]:  # pragma: no cover\n380         \"\"\"DEPRECATED: Get our personal option definition and return a suitable form for\n381         use with optik/optparse.\n382         \"\"\"\n383         warnings.warn(\n384             \"optik_option has been deprecated. Parsing of option dictionaries should be done \"\n385             \"automatically by initializing an ArgumentsProvider.\",\n386             DeprecationWarning,\n387         )\n388         optdict = copy.copy(optdict)\n389         if \"action\" in optdict:\n390             self._nocallback_options[provider] = opt\n391         else:\n392             optdict[\"action\"] = \"callback\"\n393             optdict[\"callback\"] = self.cb_set_provider_option\n394         # default is handled here and *must not* be given to optik if you\n395         # want the whole machinery to work\n396         if \"default\" in optdict:\n397             if (\n398                 \"help\" in optdict\n399                 and optdict.get(\"default\") is not None\n400                 and optdict[\"action\"] not in (\"store_true\", \"store_false\")\n401             ):\n402                 optdict[\"help\"] += \" [current: %default]\"  # type: ignore[operator]\n403             del optdict[\"default\"]\n404         args = [\"--\" + str(opt)]\n405         if \"short\" in optdict:\n406             self._short_options[optdict[\"short\"]] = opt  # type: ignore[index]\n407             args.append(\"-\" + optdict[\"short\"])  # type: ignore[operator]\n408             del optdict[\"short\"]\n409         # cleanup option definition dict before giving it to optik\n410         for key in list(optdict.keys()):\n411             if key not in self._optik_option_attrs:\n412                 optdict.pop(key)\n413         return args, optdict\n414 \n415     def generate_config(\n416         self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()\n417     ) -> None:  # pragma: no cover\n418         \"\"\"DEPRECATED: Write a configuration file according to the current configuration\n419         into the given stream or stdout.\n420         \"\"\"\n421         warnings.warn(\n422             \"generate_config has been deprecated. It will be removed in pylint 3.0.\",\n423             DeprecationWarning,\n424         )\n425         options_by_section = {}\n426         sections = []\n427         for group in self._arg_parser._action_groups:\n428             group_name = group.title\n429             assert group_name\n430             if group_name in skipsections:\n431                 continue\n432 \n433             options = []\n434             for opt in group._group_actions:\n435                 if \"--help\" in opt.option_strings:\n436                     continue\n437 \n438                 optname = opt.option_strings[0][2:]\n439 \n440                 try:\n441                     optdict = self._option_dicts[optname]\n442                 except KeyError:\n443                     continue\n444 \n445                 options.append(\n446                     (\n447                         optname,\n448                         optdict,\n449                         getattr(self.config, optname.replace(\"-\", \"_\")),\n450                     )\n451                 )\n452 \n453                 options = [\n454                     (n, d, v) for (n, d, v) in options if not d.get(\"deprecated\")\n455                 ]\n456 \n457             if options:\n458                 sections.append(group_name)\n459                 options_by_section[group_name] = options\n460         stream = stream or sys.stdout\n461         printed = False\n462         for section in sections:\n463             if printed:\n464                 print(\"\\n\", file=stream)\n465             with warnings.catch_warnings():\n466                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n467                 utils.format_section(\n468                     stream, section.upper(), sorted(options_by_section[section])\n469                 )\n470             printed = True\n471 \n472     def load_provider_defaults(self) -> None:  # pragma: no cover\n473         \"\"\"DEPRECATED: Initialize configuration using default values.\"\"\"\n474         warnings.warn(\n475             \"load_provider_defaults has been deprecated. Parsing of option defaults should be done \"\n476             \"automatically by initializing an ArgumentsProvider.\",\n477             DeprecationWarning,\n478         )\n479         for provider in self.options_providers:\n480             with warnings.catch_warnings():\n481                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n482                 provider.load_defaults()\n483 \n484     def read_config_file(\n485         self, config_file: Path | None = None, verbose: bool = False\n486     ) -> None:  # pragma: no cover\n487         \"\"\"DEPRECATED: Read the configuration file but do not load it (i.e. dispatching\n488         values to each option's provider).\n489 \n490         :raises OSError: When the specified config file doesn't exist\n491         \"\"\"\n492         warnings.warn(\n493             \"read_config_file has been deprecated. It will be removed in pylint 3.0.\",\n494             DeprecationWarning,\n495         )\n496         if not config_file:\n497             if verbose:\n498                 print(\n499                     \"No config file found, using default configuration\", file=sys.stderr\n500                 )\n501             return\n502         config_file = Path(os.path.expandvars(config_file)).expanduser()\n503         if not config_file.exists():\n504             raise OSError(f\"The config file {str(config_file)} doesn't exist!\")\n505         parser = self.cfgfile_parser\n506         if config_file.suffix == \".toml\":\n507             try:\n508                 self._parse_toml(config_file, parser)\n509             except tomllib.TOMLDecodeError:\n510                 pass\n511         else:\n512             # Use this encoding in order to strip the BOM marker, if any.\n513             with open(config_file, encoding=\"utf_8_sig\") as fp:\n514                 parser.read_file(fp)\n515             # normalize each section's title\n516             for sect, values in list(parser._sections.items()):  # type: ignore[attr-defined]\n517                 if sect.startswith(\"pylint.\"):\n518                     sect = sect[len(\"pylint.\") :]\n519                 if not sect.isupper() and values:\n520                     parser._sections[sect.upper()] = values  # type: ignore[attr-defined]\n521 \n522         if verbose:\n523             print(f\"Using config file '{config_file}'\", file=sys.stderr)\n524 \n525     @staticmethod\n526     def _parse_toml(\n527         config_file: Path, parser: configparser.ConfigParser\n528     ) -> None:  # pragma: no cover\n529         \"\"\"DEPRECATED: Parse and handle errors of a toml configuration file.\n530 \n531         TODO: 3.0: Remove deprecated method.\n532         \"\"\"\n533         with open(config_file, mode=\"rb\") as fp:\n534             content = tomllib.load(fp)\n535         try:\n536             sections_values = content[\"tool\"][\"pylint\"]\n537         except KeyError:\n538             return\n539         for section, values in sections_values.items():\n540             section_name = section.upper()\n541             # TOML has rich types, convert values to\n542             # strings as ConfigParser expects.\n543             if not isinstance(values, dict):\n544                 continue\n545             for option, value in values.items():\n546                 if isinstance(value, bool):\n547                     values[option] = \"yes\" if value else \"no\"\n548                 elif isinstance(value, list):\n549                     values[option] = \",\".join(value)\n550                 else:\n551                     values[option] = str(value)\n552             for option, value in values.items():\n553                 try:\n554                     parser.set(section_name, option, value=value)\n555                 except configparser.NoSectionError:\n556                     parser.add_section(section_name)\n557                     parser.set(section_name, option, value=value)\n558 \n559     def load_config_file(self) -> None:  # pragma: no cover\n560         \"\"\"DEPRECATED: Dispatch values previously read from a configuration file to each\n561         option's provider.\n562         \"\"\"\n563         warnings.warn(\n564             \"load_config_file has been deprecated. It will be removed in pylint 3.0.\",\n565             DeprecationWarning,\n566         )\n567         parser = self.cfgfile_parser\n568         for section in parser.sections():\n569             for option, value in parser.items(section):\n570                 try:\n571                     self.global_set_option(option, value)\n572                 except (KeyError, optparse.OptionError):\n573                     continue\n574 \n575     def load_configuration(self, **kwargs: Any) -> None:  # pragma: no cover\n576         \"\"\"DEPRECATED: Override configuration according to given parameters.\"\"\"\n577         warnings.warn(\n578             \"load_configuration has been deprecated. It will be removed in pylint 3.0.\",\n579             DeprecationWarning,\n580         )\n581         with warnings.catch_warnings():\n582             warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n583             return self.load_configuration_from_config(kwargs)\n584 \n585     def load_configuration_from_config(\n586         self, config: dict[str, Any]\n587     ) -> None:  # pragma: no cover\n588         warnings.warn(\n589             \"DEPRECATED: load_configuration_from_config has been deprecated. It will be removed in pylint 3.0.\",\n590             DeprecationWarning,\n591         )\n592         for opt, opt_value in config.items():\n593             opt = opt.replace(\"_\", \"-\")\n594             provider = self._all_options[opt]\n595             provider.set_option(opt, opt_value)\n596 \n597     def load_command_line_configuration(\n598         self, args: list[str] | None = None\n599     ) -> list[str]:  # pragma: no cover\n600         \"\"\"DEPRECATED: Override configuration according to command line parameters.\n601 \n602         return additional arguments\n603         \"\"\"\n604         warnings.warn(\n605             \"load_command_line_configuration has been deprecated. It will be removed in pylint 3.0.\",\n606             DeprecationWarning,\n607         )\n608         args = sys.argv[1:] if args is None else list(args)\n609         (options, args) = self.cmdline_parser.parse_args(args=args)\n610         for provider in self._nocallback_options:\n611             config = provider.config\n612             for attr in config.__dict__.keys():\n613                 value = getattr(options, attr, None)\n614                 if value is None:\n615                     continue\n616                 setattr(config, attr, value)\n617         return args\n618 \n619     def help(self, level: int | None = None) -> str:\n620         \"\"\"Return the usage string based on the available options.\"\"\"\n621         if level is not None:\n622             warnings.warn(\n623                 \"Supplying a 'level' argument to help() has been deprecated.\"\n624                 \"You can call help() without any arguments.\",\n625                 DeprecationWarning,\n626             )\n627         return self._arg_parser.format_help()\n628 \n629     def cb_set_provider_option(self, option, opt, value, parser):  # pragma: no cover\n630         \"\"\"DEPRECATED: Optik callback for option setting.\"\"\"\n631         # TODO: 3.0: Remove deprecated method.\n632         warnings.warn(\n633             \"cb_set_provider_option has been deprecated. It will be removed in pylint 3.0.\",\n634             DeprecationWarning,\n635         )\n636         if opt.startswith(\"--\"):\n637             # remove -- on long option\n638             opt = opt[2:]\n639         else:\n640             # short option, get its long equivalent\n641             opt = self._short_options[opt[1:]]\n642         # trick since we can't set action='store_true' on options\n643         if value is None:\n644             value = 1\n645         self.set_option(opt, value)\n646 \n647     def global_set_option(self, opt: str, value: Any) -> None:  # pragma: no cover\n648         \"\"\"DEPRECATED: Set option on the correct option provider.\"\"\"\n649         # TODO: 3.0: Remove deprecated method.\n650         warnings.warn(\n651             \"global_set_option has been deprecated. You can use _arguments_manager.set_option \"\n652             \"or linter.set_option to set options on the global configuration object.\",\n653             DeprecationWarning,\n654         )\n655         self.set_option(opt, value)\n656 \n657     def _generate_config_file(self) -> None:\n658         \"\"\"Write a configuration file according to the current configuration into stdout.\"\"\"\n659         toml_doc = tomlkit.document()\n660         pylint_tool_table = tomlkit.table(is_super_table=True)\n661         toml_doc.add(tomlkit.key([\"tool\", \"pylint\"]), pylint_tool_table)\n662 \n663         for group in sorted(\n664             self._arg_parser._action_groups,\n665             key=lambda x: (x.title != \"Master\", x.title),\n666         ):\n667             # Skip the options section with the --help option\n668             if group.title == \"options\":\n669                 continue\n670 \n671             # Skip sections without options such as \"positional arguments\"\n672             if not group._group_actions:\n673                 continue\n674 \n675             group_table = tomlkit.table()\n676             for action in sorted(\n677                 group._group_actions, key=lambda x: x.option_strings[0][2:]\n678             ):\n679                 optname = action.option_strings[0][2:]\n680 \n681                 # We skip old name options that don't have their own optdict\n682                 try:\n683                     optdict = self._option_dicts[optname]\n684                 except KeyError:\n685                     continue\n686 \n687                 if optdict.get(\"hide_from_config_file\"):\n688                     continue\n689 \n690                 # Add help comment\n691                 help_msg = optdict.get(\"help\", \"\")\n692                 assert isinstance(help_msg, str)\n693                 help_text = textwrap.wrap(help_msg, width=79)\n694                 for line in help_text:\n695                     group_table.add(tomlkit.comment(line))\n696 \n697                 # Get current value of option\n698                 value = getattr(self.config, optname.replace(\"-\", \"_\"))\n699 \n700                 # Create a comment if the option has no value\n701                 if not value:\n702                     group_table.add(tomlkit.comment(f\"{optname} =\"))\n703                     group_table.add(tomlkit.nl())\n704                     continue\n705 \n706                 # Tomlkit doesn't support regular expressions\n707                 if isinstance(value, re.Pattern):\n708                     value = value.pattern\n709                 elif isinstance(value, (list, tuple)) and isinstance(\n710                     value[0], re.Pattern\n711                 ):\n712                     value = [i.pattern for i in value]\n713 \n714                 # Add to table\n715                 group_table.add(optname, value)\n716                 group_table.add(tomlkit.nl())\n717 \n718             assert group.title\n719             pylint_tool_table.add(group.title.lower(), group_table)\n720 \n721         toml_string = tomlkit.dumps(toml_doc)\n722 \n723         # Make sure the string we produce is valid toml and can be parsed\n724         tomllib.loads(toml_string)\n725 \n726         print(toml_string)\n727 \n728     def set_option(\n729         self,\n730         optname: str,\n731         value: Any,\n732         action: str | None = \"default_value\",\n733         optdict: None | str | OptionDict = \"default_value\",\n734     ) -> None:\n735         \"\"\"Set an option on the namespace object.\"\"\"\n736         # TODO: 3.0: Remove deprecated arguments.\n737         if action != \"default_value\":\n738             warnings.warn(\n739                 \"The 'action' argument has been deprecated. You can use set_option \"\n740                 \"without the 'action' or 'optdict' arguments.\",\n741                 DeprecationWarning,\n742             )\n743         if optdict != \"default_value\":\n744             warnings.warn(\n745                 \"The 'optdict' argument has been deprecated. You can use set_option \"\n746                 \"without the 'action' or 'optdict' arguments.\",\n747                 DeprecationWarning,\n748             )\n749 \n750         self.config = self._arg_parser.parse_known_args(\n751             [f\"--{optname.replace('_', '-')}\", _parse_rich_type_value(value)],\n752             self.config,\n753         )[0]\n",
        "intended_behavior": "The code should accurately parse `--ignore`, `--ignore-patterns`, and `--ignore-paths` arguments from the command line, ensuring they are stored for intended application. It should ensure that ignore rules are applied to exclude specified files or directories from analysis during recursive mode. This involves making sure any file paths matching the ignore criteria are skipped in the file selection process before linting."
    }
]