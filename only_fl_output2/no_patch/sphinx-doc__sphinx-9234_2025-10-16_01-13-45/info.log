2025-10-16 01:13:45.534 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 01:13:49.056 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=364, output_tokens=12, cost=0.004000
2025-10-16 01:13:49.057 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 01:13:49.061 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:13:56.648 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=307, cost=0.015920
2025-10-16 01:13:56.656 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:13:59.614 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=661, output_tokens=81, cost=0.009040
2025-10-16 01:13:59.616 | DEBUG    | Extracted a valid json.
2025-10-16 01:13:59.621 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LinkCheck\")",
        "search_method(\"checkLink\")",
        "search_method(\"validateRedirect\")",
        "search_method(\"handleRedirect\")",
        "search_code(\"allowed redirects\")",
        "search_code(\"redirect whitelist\")",
        "search_code(\"linkcheck/output.txt\")"
    ],
    "bug_locations": []
}
2025-10-16 01:13:59.657 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:13:59.658 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:14:12.356 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1233, output_tokens=394, cost=0.024150
2025-10-16 01:14:12.367 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:14:20.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1843, output_tokens=357, cost=0.029140
2025-10-16 01:14:20.608 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:14:22.775 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=14, cost=0.007530
2025-10-16 01:14:22.776 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:22.782 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:14:24.631 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=14, cost=0.007530
2025-10-16 01:14:24.632 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:24.632 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:14:26.095 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=14, cost=0.007530
2025-10-16 01:14:26.096 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:26.096 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:14:27.333 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=14, cost=0.007530
2025-10-16 01:14:27.334 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:27.335 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:14:28.611 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=14, cost=0.007530
2025-10-16 01:14:28.612 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:28.612 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:14:28.613 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:14:28.614 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:14:28.614 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:14:40.281 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2227, output_tokens=368, cost=0.033310
2025-10-16 01:14:40.289 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:14:42.394 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-16 01:14:42.395 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:42.395 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:14:45.532 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-16 01:14:45.534 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:45.539 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:14:47.039 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-16 01:14:47.040 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:47.040 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:14:48.444 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-16 01:14:48.445 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:48.445 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:14:49.407 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-16 01:14:49.408 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:14:49.408 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:14:49.409 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:14:49.410 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:14:49.410 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:14:58.141 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2622, output_tokens=259, cost=0.033990
2025-10-16 01:14:58.148 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:15:02.877 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=613, output_tokens=86, cost=0.008710
2025-10-16 01:15:02.879 | DEBUG    | Extracted a valid json.
2025-10-16 01:15:02.879 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"HTTP request\")",
        "search_code(\"HTTP response\")",
        "search_code(\"configuration\")",
        "search_code(\"settings\")",
        "search_code(\"generate report\")",
        "search_code(\"log output\")",
        "search_method(\"processURL\")",
        "search_method(\"verifyURL\")"
    ],
    "bug_locations": []
}
2025-10-16 01:15:03.048 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:15:03.048 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:15:17.733 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4208, output_tokens=661, cost=0.061910
2025-10-16 01:15:17.740 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:15:32.258 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5085, output_tokens=577, cost=0.068160
2025-10-16 01:15:32.270 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:15:39.476 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=309, cost=0.018580
2025-10-16 01:15:39.477 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-16 01:15:39.477 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:15:47.079 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=328, cost=0.019150
2025-10-16 01:15:47.080 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-16 01:15:47.080 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:15:53.858 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=309, cost=0.018580
2025-10-16 01:15:53.859 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-16 01:15:53.859 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:15:57.681 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=150, cost=0.013810
2025-10-16 01:15:57.682 | DEBUG    | Extracted a valid json.
2025-10-16 01:15:57.682 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/config.py",
            "class": "",
            "method": "",
            "intended_behavior": "Add a new configuration option that allows users to specify allowed redirect pairs. This configuration should be designed to preserve backward compatibility, defaulting to a mode that behaves as the link checker currently does unless explicitly configured to enforce redirect constraints."
        },
        {
            "file": "doc/conf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Document the usage of the new configuration option for specifying allowed redirect pairs. Provide examples on how to set it to help users adopt the feature."
        }
    ]
}
2025-10-16 01:15:57.687 | DEBUG    | Bug location extracted successfully: [<file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 from collections import OrderedDict
15 from os import getenv, path
16 from typing import (TYPE_CHECKING, Any, Callable, Dict, Generator, Iterator, List, NamedTuple,
17                     Optional, Set, Tuple, Union)
18 
19 from sphinx.errors import ConfigError, ExtensionError
20 from sphinx.locale import _, __
21 from sphinx.util import logging
22 from sphinx.util.i18n import format_date
23 from sphinx.util.osutil import cd, fs_encoding
24 from sphinx.util.tags import Tags
25 from sphinx.util.typing import NoneType
26 
27 if TYPE_CHECKING:
28     from sphinx.application import Sphinx
29     from sphinx.environment import BuildEnvironment
30 
31 logger = logging.getLogger(__name__)
32 
33 CONFIG_FILENAME = 'conf.py'
34 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
35 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
36 
37 
38 class ConfigValue(NamedTuple):
39     name: str
40     value: Any
41     rebuild: Union[bool, str]
42 
43 
44 def is_serializable(obj: Any) -> bool:
45     """Check if object is serializable or not."""
46     if isinstance(obj, UNSERIALIZABLE_TYPES):
47         return False
48     elif isinstance(obj, dict):
49         for key, value in obj.items():
50             if not is_serializable(key) or not is_serializable(value):
51                 return False
52     elif isinstance(obj, (list, tuple, set)):
53         return all(is_serializable(i) for i in obj)
54 
55     return True
56 
57 
58 class ENUM:
59     """represents the config value should be a one of candidates.
60 
61     Example:
62         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
63     """
64     def __init__(self, *candidates: str) -> None:
65         self.candidates = candidates
66 
67     def match(self, value: Union[str, List, Tuple]) -> bool:
68         if isinstance(value, (list, tuple)):
69             return all(item in self.candidates for item in value)
70         else:
71             return value in self.candidates
72 
73 
74 class Config:
75     """Configuration file abstraction.
76 
77     The config object makes the values of all config values available as
78     attributes.
79 
80     It is exposed via the :py:attr:`sphinx.application.Application.config` and
81     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
82     to get the value of :confval:`language`, use either ``app.config.language``
83     or ``env.config.language``.
84     """
85 
86     # the values are: (default, what needs to be rebuilt if changed)
87 
88     # If you add a value here, don't forget to include it in the
89     # quickstart.py file template as well as in the docs!
90 
91     config_values: Dict[str, Tuple] = {
92         # general options
93         'project': ('Python', 'env', []),
94         'author': ('unknown', 'env', []),
95         'project_copyright': ('', 'html', [str]),
96         'copyright': (lambda c: c.project_copyright, 'html', [str]),
97         'version': ('', 'env', []),
98         'release': ('', 'env', []),
99         'today': ('', 'env', []),
100         # the real default is locale-dependent
101         'today_fmt': (None, 'env', [str]),
102 
103         'language': (None, 'env', [str]),
104         'locale_dirs': (['locales'], 'env', []),
105         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
106 
107         'master_doc': ('index', 'env', []),
108         'root_doc': (lambda config: config.master_doc, 'env', []),
109         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
110         'source_encoding': ('utf-8-sig', 'env', []),
111         'exclude_patterns': ([], 'env', []),
112         'default_role': (None, 'env', [str]),
113         'add_function_parentheses': (True, 'env', []),
114         'add_module_names': (True, 'env', []),
115         'trim_footnote_reference_space': (False, 'env', []),
116         'show_authors': (False, 'env', []),
117         'pygments_style': (None, 'html', [str]),
118         'highlight_language': ('default', 'env', []),
119         'highlight_options': ({}, 'env', []),
120         'templates_path': ([], 'html', []),
121         'template_bridge': (None, 'html', [str]),
122         'keep_warnings': (False, 'env', []),
123         'suppress_warnings': ([], 'env', []),
124         'modindex_common_prefix': ([], 'html', []),
125         'rst_epilog': (None, 'env', [str]),
126         'rst_prolog': (None, 'env', [str]),
127         'trim_doctest_flags': (True, 'env', []),
128         'primary_domain': ('py', 'env', [NoneType]),
129         'needs_sphinx': (None, None, [str]),
130         'needs_extensions': ({}, None, []),
131         'manpages_url': (None, 'env', []),
132         'nitpicky': (False, None, []),
133         'nitpick_ignore': ([], None, []),
134         'nitpick_ignore_regex': ([], None, []),
135         'numfig': (False, 'env', []),
136         'numfig_secnum_depth': (1, 'env', []),
137         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
138 
139         'math_number_all': (False, 'env', []),
140         'math_eqref_format': (None, 'env', [str]),
141         'math_numfig': (True, 'env', []),
142         'tls_verify': (True, 'env', []),
143         'tls_cacerts': (None, 'env', []),
144         'user_agent': (None, 'env', [str]),
145         'smartquotes': (True, 'env', []),
146         'smartquotes_action': ('qDe', 'env', []),
147         'smartquotes_excludes': ({'languages': ['ja'],
148                                   'builders': ['man', 'text']},
149                                  'env', []),
150     }
151 
152     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
153         self.overrides = dict(overrides)
154         self.values = Config.config_values.copy()
155         self._raw_config = config
156         self.setup: Optional[Callable] = config.get('setup', None)
157 
158         if 'extensions' in self.overrides:
159             if isinstance(self.overrides['extensions'], str):
160                 config['extensions'] = self.overrides.pop('extensions').split(',')
161             else:
162                 config['extensions'] = self.overrides.pop('extensions')
163         self.extensions: List[str] = config.get('extensions', [])
164 
165     @classmethod
166     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
167         """Create a Config object from configuration file."""
168         filename = path.join(confdir, CONFIG_FILENAME)
169         if not path.isfile(filename):
170             raise ConfigError(__("config directory doesn't contain a conf.py file (%s)") %
171                               confdir)
172         namespace = eval_config_file(filename, tags)
173         return cls(namespace, overrides or {})
174 
175     def convert_overrides(self, name: str, value: Any) -> Any:
176         if not isinstance(value, str):
177             return value
178         else:
179             defvalue = self.values[name][0]
180             if self.values[name][2] == Any:
181                 return value
182             elif self.values[name][2] == {bool, str}:
183                 if value == '0':
184                     # given falsy string from command line option
185                     return False
186                 elif value == '1':
187                     return True
188                 else:
189                     return value
190             elif type(defvalue) is bool or self.values[name][2] == [bool]:
191                 if value == '0':
192                     # given falsy string from command line option
193                     return False
194                 else:
195                     return bool(value)
196             elif isinstance(defvalue, dict):
197                 raise ValueError(__('cannot override dictionary config setting %r, '
198                                     'ignoring (use %r to set individual elements)') %
199                                  (name, name + '.key=value'))
200             elif isinstance(defvalue, list):
201                 return value.split(',')
202             elif isinstance(defvalue, int):
203                 try:
204                     return int(value)
205                 except ValueError as exc:
206                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
207                                      (value, name)) from exc
208             elif hasattr(defvalue, '__call__'):
209                 return value
210             elif defvalue is not None and not isinstance(defvalue, str):
211                 raise ValueError(__('cannot override config setting %r with unsupported '
212                                     'type, ignoring') % name)
213             else:
214                 return value
215 
216     def pre_init_values(self) -> None:
217         """
218         Initialize some limited config variables before initialize i18n and loading extensions
219         """
220         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
221         for name in variables:
222             try:
223                 if name in self.overrides:
224                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
225                 elif name in self._raw_config:
226                     self.__dict__[name] = self._raw_config[name]
227             except ValueError as exc:
228                 logger.warning("%s", exc)
229 
230     def init_values(self) -> None:
231         config = self._raw_config
232         for valname, value in self.overrides.items():
233             try:
234                 if '.' in valname:
235                     realvalname, key = valname.split('.', 1)
236                     config.setdefault(realvalname, {})[key] = value
237                     continue
238                 elif valname not in self.values:
239                     logger.warning(__('unknown config value %r in override, ignoring'),
240                                    valname)
241                     continue
242                 if isinstance(value, str):
243                     config[valname] = self.convert_overrides(valname, value)
244                 else:
245                     config[valname] = value
246             except ValueError as exc:
247                 logger.warning("%s", exc)
248         for name in config:
249             if name in self.values:
250                 self.__dict__[name] = config[name]
251 
252     def __getattr__(self, name: str) -> Any:
253         if name.startswith('_'):
254             raise AttributeError(name)
255         if name not in self.values:
256             raise AttributeError(__('No such config value: %s') % name)
257         default = self.values[name][0]
258         if hasattr(default, '__call__'):
259             return default(self)
260         return default
261 
262     def __getitem__(self, name: str) -> Any:
263         return getattr(self, name)
264 
265     def __setitem__(self, name: str, value: Any) -> None:
266         setattr(self, name, value)
267 
268     def __delitem__(self, name: str) -> None:
269         delattr(self, name)
270 
271     def __contains__(self, name: str) -> bool:
272         return name in self.values
273 
274     def __iter__(self) -> Generator[ConfigValue, None, None]:
275         for name, value in self.values.items():
276             yield ConfigValue(name, getattr(self, name), value[1])
277 
278     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
279         if name in self.values:
280             raise ExtensionError(__('Config value %r already present') % name)
281         else:
282             self.values[name] = (default, rebuild, types)
283 
284     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
285         if isinstance(rebuild, str):
286             rebuild = [rebuild]
287         return (value for value in self if value.rebuild in rebuild)
288 
289     def __getstate__(self) -> Dict:
290         """Obtains serializable data for pickling."""
291         # remove potentially pickling-problematic values from config
292         __dict__ = {}
293         for key, value in self.__dict__.items():
294             if key.startswith('_') or not is_serializable(value):
295                 pass
296             else:
297                 __dict__[key] = value
298 
299         # create a picklable copy of values list
300         __dict__['values'] = {}
301         for key, value in self.values.items():
302             real_value = getattr(self, key)
303             if not is_serializable(real_value):
304                 # omit unserializable value
305                 real_value = None
306 
307             # types column is also omitted
308             __dict__['values'][key] = (real_value, value[1], None)
309 
310         return __dict__
311 
312     def __setstate__(self, state: Dict) -> None:
313         self.__dict__.update(state)
314 
315 
316 def eval_config_file(filename: str, tags: Optional[Tags]) -> Dict[str, Any]:
317     """Evaluate a config file."""
318     namespace: Dict[str, Any] = {}
319     namespace['__file__'] = filename
320     namespace['tags'] = tags
321 
322     with cd(path.dirname(filename)):
323         # during executing config file, current dir is changed to ``confdir``.
324         try:
325             with open(filename, 'rb') as f:
326                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')
327                 exec(code, namespace)
328         except SyntaxError as err:
329             msg = __("There is a syntax error in your configuration file: %s\n")
330             raise ConfigError(msg % err) from err
331         except SystemExit as exc:
332             msg = __("The configuration file (or one of the modules it imports) "
333                      "called sys.exit()")
334             raise ConfigError(msg) from exc
335         except ConfigError:
336             # pass through ConfigError from conf.py as is.  It will be shown in console.
337             raise
338         except Exception as exc:
339             msg = __("There is a programmable error in your configuration file:\n\n%s")
340             raise ConfigError(msg % traceback.format_exc()) from exc
341 
342     return namespace
343 
344 
345 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
346     """This converts old styled source_suffix to new styled one.
347 
348     * old style: str or list
349     * new style: a dict which maps from fileext to filetype
350     """
351     source_suffix = config.source_suffix
352     if isinstance(source_suffix, str):
353         # if str, considers as default filetype (None)
354         #
355         # The default filetype is determined on later step.
356         # By default, it is considered as restructuredtext.
357         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
358     elif isinstance(source_suffix, (list, tuple)):
359         # if list, considers as all of them are default filetype
360         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
361     elif isinstance(source_suffix, dict):
362         # if dict, convert it to OrderedDict
363         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
364     else:
365         logger.warning(__("The config value `source_suffix' expects "
366                           "a string, list of strings, or dictionary. "
367                           "But `%r' is given." % source_suffix))
368 
369 
370 def convert_highlight_options(app: "Sphinx", config: Config) -> None:
371     """Convert old styled highlight_options to new styled one.
372 
373     * old style: options
374     * new style: dict that maps language names to options
375     """
376     options = config.highlight_options
377     if options and not all(isinstance(v, dict) for v in options.values()):
378         # old styled option detected because all values are not dictionary.
379         config.highlight_options = {config.highlight_language: options}  # type: ignore
380 
381 
382 def init_numfig_format(app: "Sphinx", config: Config) -> None:
383     """Initialize :confval:`numfig_format`."""
384     numfig_format = {'section': _('Section %s'),
385                      'figure': _('Fig. %s'),
386                      'table': _('Table %s'),
387                      'code-block': _('Listing %s')}
388 
389     # override default labels by configuration
390     numfig_format.update(config.numfig_format)
391     config.numfig_format = numfig_format  # type: ignore
392 
393 
394 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
395     """correct values of copyright year that are not coherent with
396     the SOURCE_DATE_EPOCH environment variable (if set)
397 
398     See https://reproducible-builds.org/specs/source-date-epoch/
399     """
400     if getenv('SOURCE_DATE_EPOCH') is not None:
401         for k in ('copyright', 'epub_copyright'):
402             if k in config:
403                 replace = r'\g<1>%s' % format_date('%Y')
404                 config[k] = copyright_year_re.sub(replace, config[k])
405 
406 
407 def check_confval_types(app: "Sphinx", config: Config) -> None:
408     """check all values for deviation from the default value's type, since
409     that can result in TypeErrors all over the place NB.
410     """
411     for confval in config:
412         default, rebuild, annotations = config.values[confval.name]
413 
414         if hasattr(default, '__call__'):
415             default = default(config)  # evaluate default value
416         if default is None and not annotations:
417             continue  # neither inferrable nor expliclitly annotated types
418 
419         if annotations is Any:
420             # any type of value is accepted
421             pass
422         elif isinstance(annotations, ENUM):
423             if not annotations.match(confval.value):
424                 msg = __("The config value `{name}` has to be a one of {candidates}, "
425                          "but `{current}` is given.")
426                 logger.warning(msg.format(name=confval.name,
427                                           current=confval.value,
428                                           candidates=annotations.candidates))
429         else:
430             if type(confval.value) is type(default):
431                 continue
432             if type(confval.value) in annotations:
433                 continue
434 
435             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
436                             set(type(default).__bases__))
437             common_bases.discard(object)
438             if common_bases:
439                 continue  # at least we share a non-trivial base class
440 
441             if annotations:
442                 msg = __("The config value `{name}' has type `{current.__name__}'; "
443                          "expected {permitted}.")
444                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
445                 if len(wrapped_annotations) > 2:
446                     permitted = "{}, or {}".format(
447                         ", ".join(wrapped_annotations[:-1]),
448                         wrapped_annotations[-1])
449                 else:
450                     permitted = " or ".join(wrapped_annotations)
451                 logger.warning(msg.format(name=confval.name,
452                                           current=type(confval.value),
453                                           permitted=permitted))
454             else:
455                 msg = __("The config value `{name}' has type `{current.__name__}', "
456                          "defaults to `{default.__name__}'.")
457                 logger.warning(msg.format(name=confval.name,
458                                           current=type(confval.value),
459                                           default=type(default)))
460 
461 
462 def check_primary_domain(app: "Sphinx", config: Config) -> None:
463     primary_domain = config.primary_domain
464     if primary_domain and not app.registry.has_domain(primary_domain):
465         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
466         config.primary_domain = None  # type: ignore
467 
468 
469 def check_root_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
470                    changed: Set[str], removed: Set[str]) -> Set[str]:
471     """Adjust root_doc to 'contents' to support an old project which does not have
472     no root_doc setting.
473     """
474     if (app.config.root_doc == 'index' and
475             'index' not in app.project.docnames and
476             'contents' in app.project.docnames):
477         logger.warning(__('Since v2.0, Sphinx uses "index" as root_doc by default. '
478                           'Please add "root_doc = \'contents\'" to your conf.py.'))
479         app.config.root_doc = "contents"  # type: ignore
480 
481     return changed
482 
483 
484 def setup(app: "Sphinx") -> Dict[str, Any]:
485     app.connect('config-inited', convert_source_suffix, priority=800)
486     app.connect('config-inited', convert_highlight_options, priority=800)
487     app.connect('config-inited', init_numfig_format, priority=800)
488     app.connect('config-inited', correct_copyright_year, priority=800)
489     app.connect('config-inited', check_confval_types, priority=800)
490     app.connect('config-inited', check_primary_domain, priority=800)
491     app.connect('env-get-outdated', check_root_doc)
492 
493     return {
494         'version': 'builtin',
495         'parallel_read_safe': True,
496         'parallel_write_safe': True,
497     }

</code><intended_behavior>Add a new configuration option that allows users to specify allowed redirect pairs. This configuration should be designed to preserve backward compatibility, defaulting to a mode that behaves as the link checker currently does unless explicitly configured to enforce redirect constraints.</intended_behavior>, <file>doc/conf.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Sphinx documentation build configuration file
2 
3 import re
4 
5 import sphinx
6 
7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',
8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',
9               'sphinx.ext.intersphinx',
10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']
11 
12 root_doc = 'contents'
13 templates_path = ['_templates']
14 exclude_patterns = ['_build']
15 
16 project = 'Sphinx'
17 copyright = '2007-2021, Georg Brandl and the Sphinx team'
18 version = sphinx.__display_version__
19 release = version
20 show_authors = True
21 
22 html_theme = 'sphinx13'
23 html_theme_path = ['_themes']
24 modindex_common_prefix = ['sphinx.']
25 html_static_path = ['_static']
26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}
27 html_title = 'Sphinx documentation'
28 html_additional_pages = {'index': 'index.html'}
29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'
30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'
31 html_favicon = '_static/favicon.svg'
32 
33 htmlhelp_basename = 'Sphinxdoc'
34 
35 epub_theme = 'epub'
36 epub_basename = 'sphinx'
37 epub_author = 'Georg Brandl'
38 epub_publisher = 'https://sphinx-doc.org/'
39 epub_uid = 'web-site'
40 epub_scheme = 'url'
41 epub_identifier = epub_publisher
42 epub_pre_files = [('index.xhtml', 'Welcome')]
43 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),
44                    ('develop.xhtml', 'Sphinx development')]
45 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',
46                       '_static/jquery.js', '_static/searchtools.js',
47                       '_static/underscore.js', '_static/basic.css',
48                       '_static/language_data.js',
49                       'search.html', '_static/websupport.js']
50 epub_fix_images = False
51 epub_max_image_width = 0
52 epub_show_urls = 'inline'
53 epub_use_index = False
54 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)
55 epub_description = 'Sphinx documentation generator system manual'
56 
57 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',
58                     'Georg Brandl', 'manual', 1)]
59 latex_logo = '_static/sphinx.png'
60 latex_elements = {
61     'fontenc': r'\usepackage[LGR,X2,T1]{fontenc}',
62     'passoptionstopackages': r'''
63 \PassOptionsToPackage{svgnames}{xcolor}
64 ''',
65     'preamble': r'''
66 \DeclareUnicodeCharacter{229E}{\ensuremath{\boxplus}}
67 \setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)
68 \setcounter{secnumdepth}{1}% depth of section numbering
69 ''',
70     # fix missing index entry due to RTD doing only once pdflatex after makeindex
71     'printindex': r'''
72 \IfFileExists{\jobname.ind}
73              {\footnotesize\raggedright\printindex}
74              {\begin{sphinxtheindex}\end{sphinxtheindex}}
75 ''',
76 }
77 latex_show_urls = 'footnote'
78 latex_use_xindy = True
79 
80 autodoc_member_order = 'groupwise'
81 autosummary_generate = False
82 todo_include_todos = True
83 extlinks = {'duref': ('https://docutils.sourceforge.io/docs/ref/rst/'
84                       'restructuredtext.html#%s', ''),
85             'durole': ('https://docutils.sourceforge.io/docs/ref/rst/'
86                        'roles.html#%s', ''),
87             'dudir': ('https://docutils.sourceforge.io/docs/ref/rst/'
88                       'directives.html#%s', '')}
89 
90 man_pages = [
91     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',
92      'Georg Brandl', 1),
93     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',
94      '', 1),
95     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '
96      'template generator', '', 1),
97     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',
98      '', 1),
99     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',
100      '', 1),
101 ]
102 
103 texinfo_documents = [
104     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',
105      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',
106      1),
107 ]
108 
109 intersphinx_mapping = {
110     'python': ('https://docs.python.org/3/', None),
111     'requests': ('https://requests.readthedocs.io/en/master', None),
112 }
113 
114 # Sphinx document translation with sphinx gettext feature uses these settings:
115 locale_dirs = ['locale/']
116 gettext_compact = False
117 
118 
119 # -- Extension interface -------------------------------------------------------
120 
121 from sphinx import addnodes  # noqa
122 
123 event_sig_re = re.compile(r'([a-zA-Z-]+)\s*\((.*)\)')
124 
125 
126 def parse_event(env, sig, signode):
127     m = event_sig_re.match(sig)
128     if not m:
129         signode += addnodes.desc_name(sig, sig)
130         return sig
131     name, args = m.groups()
132     signode += addnodes.desc_name(name, name)
133     plist = addnodes.desc_parameterlist()
134     for arg in args.split(','):
135         arg = arg.strip()
136         plist += addnodes.desc_parameter(arg, arg)
137     signode += plist
138     return name
139 
140 
141 def setup(app):
142     from sphinx.ext.autodoc import cut_lines
143     from sphinx.util.docfields import GroupedField
144     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
145     app.add_object_type('confval', 'confval',
146                         objname='configuration value',
147                         indextemplate='pair: %s; configuration value')
148     app.add_object_type('setuptools-confval', 'setuptools-confval',
149                         objname='setuptools configuration value',
150                         indextemplate='pair: %s; setuptools configuration value')
151     fdesc = GroupedField('parameter', label='Parameters',
152                          names=['param'], can_collapse=True)
153     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,
154                         doc_field_types=[fdesc])
155 
156     # workaround for RTD
157     from sphinx.util import logging
158     logger = logging.getLogger(__name__)
159     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)
160     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)
161     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)

</code><intended_behavior>Document the usage of the new configuration option for specifying allowed redirect pairs. Provide examples on how to set it to help users adopt the feature.</intended_behavior>]
2025-10-16 01:15:57.687 | INFO     | Search completed. Bug locations: [<file>sphinx/config.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.config
3     ~~~~~~~~~~~~~
4 
5     Build configuration file handling.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import traceback
13 import types
14 from collections import OrderedDict
15 from os import getenv, path
16 from typing import (TYPE_CHECKING, Any, Callable, Dict, Generator, Iterator, List, NamedTuple,
17                     Optional, Set, Tuple, Union)
18 
19 from sphinx.errors import ConfigError, ExtensionError
20 from sphinx.locale import _, __
21 from sphinx.util import logging
22 from sphinx.util.i18n import format_date
23 from sphinx.util.osutil import cd, fs_encoding
24 from sphinx.util.tags import Tags
25 from sphinx.util.typing import NoneType
26 
27 if TYPE_CHECKING:
28     from sphinx.application import Sphinx
29     from sphinx.environment import BuildEnvironment
30 
31 logger = logging.getLogger(__name__)
32 
33 CONFIG_FILENAME = 'conf.py'
34 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)
35 copyright_year_re = re.compile(r'^((\d{4}-)?)(\d{4})(?=[ ,])')
36 
37 
38 class ConfigValue(NamedTuple):
39     name: str
40     value: Any
41     rebuild: Union[bool, str]
42 
43 
44 def is_serializable(obj: Any) -> bool:
45     """Check if object is serializable or not."""
46     if isinstance(obj, UNSERIALIZABLE_TYPES):
47         return False
48     elif isinstance(obj, dict):
49         for key, value in obj.items():
50             if not is_serializable(key) or not is_serializable(value):
51                 return False
52     elif isinstance(obj, (list, tuple, set)):
53         return all(is_serializable(i) for i in obj)
54 
55     return True
56 
57 
58 class ENUM:
59     """represents the config value should be a one of candidates.
60 
61     Example:
62         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))
63     """
64     def __init__(self, *candidates: str) -> None:
65         self.candidates = candidates
66 
67     def match(self, value: Union[str, List, Tuple]) -> bool:
68         if isinstance(value, (list, tuple)):
69             return all(item in self.candidates for item in value)
70         else:
71             return value in self.candidates
72 
73 
74 class Config:
75     """Configuration file abstraction.
76 
77     The config object makes the values of all config values available as
78     attributes.
79 
80     It is exposed via the :py:attr:`sphinx.application.Application.config` and
81     :py:attr:`sphinx.environment.Environment.config` attributes. For example,
82     to get the value of :confval:`language`, use either ``app.config.language``
83     or ``env.config.language``.
84     """
85 
86     # the values are: (default, what needs to be rebuilt if changed)
87 
88     # If you add a value here, don't forget to include it in the
89     # quickstart.py file template as well as in the docs!
90 
91     config_values: Dict[str, Tuple] = {
92         # general options
93         'project': ('Python', 'env', []),
94         'author': ('unknown', 'env', []),
95         'project_copyright': ('', 'html', [str]),
96         'copyright': (lambda c: c.project_copyright, 'html', [str]),
97         'version': ('', 'env', []),
98         'release': ('', 'env', []),
99         'today': ('', 'env', []),
100         # the real default is locale-dependent
101         'today_fmt': (None, 'env', [str]),
102 
103         'language': (None, 'env', [str]),
104         'locale_dirs': (['locales'], 'env', []),
105         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),
106 
107         'master_doc': ('index', 'env', []),
108         'root_doc': (lambda config: config.master_doc, 'env', []),
109         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),
110         'source_encoding': ('utf-8-sig', 'env', []),
111         'exclude_patterns': ([], 'env', []),
112         'default_role': (None, 'env', [str]),
113         'add_function_parentheses': (True, 'env', []),
114         'add_module_names': (True, 'env', []),
115         'trim_footnote_reference_space': (False, 'env', []),
116         'show_authors': (False, 'env', []),
117         'pygments_style': (None, 'html', [str]),
118         'highlight_language': ('default', 'env', []),
119         'highlight_options': ({}, 'env', []),
120         'templates_path': ([], 'html', []),
121         'template_bridge': (None, 'html', [str]),
122         'keep_warnings': (False, 'env', []),
123         'suppress_warnings': ([], 'env', []),
124         'modindex_common_prefix': ([], 'html', []),
125         'rst_epilog': (None, 'env', [str]),
126         'rst_prolog': (None, 'env', [str]),
127         'trim_doctest_flags': (True, 'env', []),
128         'primary_domain': ('py', 'env', [NoneType]),
129         'needs_sphinx': (None, None, [str]),
130         'needs_extensions': ({}, None, []),
131         'manpages_url': (None, 'env', []),
132         'nitpicky': (False, None, []),
133         'nitpick_ignore': ([], None, []),
134         'nitpick_ignore_regex': ([], None, []),
135         'numfig': (False, 'env', []),
136         'numfig_secnum_depth': (1, 'env', []),
137         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()
138 
139         'math_number_all': (False, 'env', []),
140         'math_eqref_format': (None, 'env', [str]),
141         'math_numfig': (True, 'env', []),
142         'tls_verify': (True, 'env', []),
143         'tls_cacerts': (None, 'env', []),
144         'user_agent': (None, 'env', [str]),
145         'smartquotes': (True, 'env', []),
146         'smartquotes_action': ('qDe', 'env', []),
147         'smartquotes_excludes': ({'languages': ['ja'],
148                                   'builders': ['man', 'text']},
149                                  'env', []),
150     }
151 
152     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:
153         self.overrides = dict(overrides)
154         self.values = Config.config_values.copy()
155         self._raw_config = config
156         self.setup: Optional[Callable] = config.get('setup', None)
157 
158         if 'extensions' in self.overrides:
159             if isinstance(self.overrides['extensions'], str):
160                 config['extensions'] = self.overrides.pop('extensions').split(',')
161             else:
162                 config['extensions'] = self.overrides.pop('extensions')
163         self.extensions: List[str] = config.get('extensions', [])
164 
165     @classmethod
166     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> "Config":
167         """Create a Config object from configuration file."""
168         filename = path.join(confdir, CONFIG_FILENAME)
169         if not path.isfile(filename):
170             raise ConfigError(__("config directory doesn't contain a conf.py file (%s)") %
171                               confdir)
172         namespace = eval_config_file(filename, tags)
173         return cls(namespace, overrides or {})
174 
175     def convert_overrides(self, name: str, value: Any) -> Any:
176         if not isinstance(value, str):
177             return value
178         else:
179             defvalue = self.values[name][0]
180             if self.values[name][2] == Any:
181                 return value
182             elif self.values[name][2] == {bool, str}:
183                 if value == '0':
184                     # given falsy string from command line option
185                     return False
186                 elif value == '1':
187                     return True
188                 else:
189                     return value
190             elif type(defvalue) is bool or self.values[name][2] == [bool]:
191                 if value == '0':
192                     # given falsy string from command line option
193                     return False
194                 else:
195                     return bool(value)
196             elif isinstance(defvalue, dict):
197                 raise ValueError(__('cannot override dictionary config setting %r, '
198                                     'ignoring (use %r to set individual elements)') %
199                                  (name, name + '.key=value'))
200             elif isinstance(defvalue, list):
201                 return value.split(',')
202             elif isinstance(defvalue, int):
203                 try:
204                     return int(value)
205                 except ValueError as exc:
206                     raise ValueError(__('invalid number %r for config value %r, ignoring') %
207                                      (value, name)) from exc
208             elif hasattr(defvalue, '__call__'):
209                 return value
210             elif defvalue is not None and not isinstance(defvalue, str):
211                 raise ValueError(__('cannot override config setting %r with unsupported '
212                                     'type, ignoring') % name)
213             else:
214                 return value
215 
216     def pre_init_values(self) -> None:
217         """
218         Initialize some limited config variables before initialize i18n and loading extensions
219         """
220         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']
221         for name in variables:
222             try:
223                 if name in self.overrides:
224                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])
225                 elif name in self._raw_config:
226                     self.__dict__[name] = self._raw_config[name]
227             except ValueError as exc:
228                 logger.warning("%s", exc)
229 
230     def init_values(self) -> None:
231         config = self._raw_config
232         for valname, value in self.overrides.items():
233             try:
234                 if '.' in valname:
235                     realvalname, key = valname.split('.', 1)
236                     config.setdefault(realvalname, {})[key] = value
237                     continue
238                 elif valname not in self.values:
239                     logger.warning(__('unknown config value %r in override, ignoring'),
240                                    valname)
241                     continue
242                 if isinstance(value, str):
243                     config[valname] = self.convert_overrides(valname, value)
244                 else:
245                     config[valname] = value
246             except ValueError as exc:
247                 logger.warning("%s", exc)
248         for name in config:
249             if name in self.values:
250                 self.__dict__[name] = config[name]
251 
252     def __getattr__(self, name: str) -> Any:
253         if name.startswith('_'):
254             raise AttributeError(name)
255         if name not in self.values:
256             raise AttributeError(__('No such config value: %s') % name)
257         default = self.values[name][0]
258         if hasattr(default, '__call__'):
259             return default(self)
260         return default
261 
262     def __getitem__(self, name: str) -> Any:
263         return getattr(self, name)
264 
265     def __setitem__(self, name: str, value: Any) -> None:
266         setattr(self, name, value)
267 
268     def __delitem__(self, name: str) -> None:
269         delattr(self, name)
270 
271     def __contains__(self, name: str) -> bool:
272         return name in self.values
273 
274     def __iter__(self) -> Generator[ConfigValue, None, None]:
275         for name, value in self.values.items():
276             yield ConfigValue(name, getattr(self, name), value[1])
277 
278     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:
279         if name in self.values:
280             raise ExtensionError(__('Config value %r already present') % name)
281         else:
282             self.values[name] = (default, rebuild, types)
283 
284     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:
285         if isinstance(rebuild, str):
286             rebuild = [rebuild]
287         return (value for value in self if value.rebuild in rebuild)
288 
289     def __getstate__(self) -> Dict:
290         """Obtains serializable data for pickling."""
291         # remove potentially pickling-problematic values from config
292         __dict__ = {}
293         for key, value in self.__dict__.items():
294             if key.startswith('_') or not is_serializable(value):
295                 pass
296             else:
297                 __dict__[key] = value
298 
299         # create a picklable copy of values list
300         __dict__['values'] = {}
301         for key, value in self.values.items():
302             real_value = getattr(self, key)
303             if not is_serializable(real_value):
304                 # omit unserializable value
305                 real_value = None
306 
307             # types column is also omitted
308             __dict__['values'][key] = (real_value, value[1], None)
309 
310         return __dict__
311 
312     def __setstate__(self, state: Dict) -> None:
313         self.__dict__.update(state)
314 
315 
316 def eval_config_file(filename: str, tags: Optional[Tags]) -> Dict[str, Any]:
317     """Evaluate a config file."""
318     namespace: Dict[str, Any] = {}
319     namespace['__file__'] = filename
320     namespace['tags'] = tags
321 
322     with cd(path.dirname(filename)):
323         # during executing config file, current dir is changed to ``confdir``.
324         try:
325             with open(filename, 'rb') as f:
326                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')
327                 exec(code, namespace)
328         except SyntaxError as err:
329             msg = __("There is a syntax error in your configuration file: %s\n")
330             raise ConfigError(msg % err) from err
331         except SystemExit as exc:
332             msg = __("The configuration file (or one of the modules it imports) "
333                      "called sys.exit()")
334             raise ConfigError(msg) from exc
335         except ConfigError:
336             # pass through ConfigError from conf.py as is.  It will be shown in console.
337             raise
338         except Exception as exc:
339             msg = __("There is a programmable error in your configuration file:\n\n%s")
340             raise ConfigError(msg % traceback.format_exc()) from exc
341 
342     return namespace
343 
344 
345 def convert_source_suffix(app: "Sphinx", config: Config) -> None:
346     """This converts old styled source_suffix to new styled one.
347 
348     * old style: str or list
349     * new style: a dict which maps from fileext to filetype
350     """
351     source_suffix = config.source_suffix
352     if isinstance(source_suffix, str):
353         # if str, considers as default filetype (None)
354         #
355         # The default filetype is determined on later step.
356         # By default, it is considered as restructuredtext.
357         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore
358     elif isinstance(source_suffix, (list, tuple)):
359         # if list, considers as all of them are default filetype
360         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA
361     elif isinstance(source_suffix, dict):
362         # if dict, convert it to OrderedDict
363         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore
364     else:
365         logger.warning(__("The config value `source_suffix' expects "
366                           "a string, list of strings, or dictionary. "
367                           "But `%r' is given." % source_suffix))
368 
369 
370 def convert_highlight_options(app: "Sphinx", config: Config) -> None:
371     """Convert old styled highlight_options to new styled one.
372 
373     * old style: options
374     * new style: dict that maps language names to options
375     """
376     options = config.highlight_options
377     if options and not all(isinstance(v, dict) for v in options.values()):
378         # old styled option detected because all values are not dictionary.
379         config.highlight_options = {config.highlight_language: options}  # type: ignore
380 
381 
382 def init_numfig_format(app: "Sphinx", config: Config) -> None:
383     """Initialize :confval:`numfig_format`."""
384     numfig_format = {'section': _('Section %s'),
385                      'figure': _('Fig. %s'),
386                      'table': _('Table %s'),
387                      'code-block': _('Listing %s')}
388 
389     # override default labels by configuration
390     numfig_format.update(config.numfig_format)
391     config.numfig_format = numfig_format  # type: ignore
392 
393 
394 def correct_copyright_year(app: "Sphinx", config: Config) -> None:
395     """correct values of copyright year that are not coherent with
396     the SOURCE_DATE_EPOCH environment variable (if set)
397 
398     See https://reproducible-builds.org/specs/source-date-epoch/
399     """
400     if getenv('SOURCE_DATE_EPOCH') is not None:
401         for k in ('copyright', 'epub_copyright'):
402             if k in config:
403                 replace = r'\g<1>%s' % format_date('%Y')
404                 config[k] = copyright_year_re.sub(replace, config[k])
405 
406 
407 def check_confval_types(app: "Sphinx", config: Config) -> None:
408     """check all values for deviation from the default value's type, since
409     that can result in TypeErrors all over the place NB.
410     """
411     for confval in config:
412         default, rebuild, annotations = config.values[confval.name]
413 
414         if hasattr(default, '__call__'):
415             default = default(config)  # evaluate default value
416         if default is None and not annotations:
417             continue  # neither inferrable nor expliclitly annotated types
418 
419         if annotations is Any:
420             # any type of value is accepted
421             pass
422         elif isinstance(annotations, ENUM):
423             if not annotations.match(confval.value):
424                 msg = __("The config value `{name}` has to be a one of {candidates}, "
425                          "but `{current}` is given.")
426                 logger.warning(msg.format(name=confval.name,
427                                           current=confval.value,
428                                           candidates=annotations.candidates))
429         else:
430             if type(confval.value) is type(default):
431                 continue
432             if type(confval.value) in annotations:
433                 continue
434 
435             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &
436                             set(type(default).__bases__))
437             common_bases.discard(object)
438             if common_bases:
439                 continue  # at least we share a non-trivial base class
440 
441             if annotations:
442                 msg = __("The config value `{name}' has type `{current.__name__}'; "
443                          "expected {permitted}.")
444                 wrapped_annotations = ["`{}'".format(c.__name__) for c in annotations]
445                 if len(wrapped_annotations) > 2:
446                     permitted = "{}, or {}".format(
447                         ", ".join(wrapped_annotations[:-1]),
448                         wrapped_annotations[-1])
449                 else:
450                     permitted = " or ".join(wrapped_annotations)
451                 logger.warning(msg.format(name=confval.name,
452                                           current=type(confval.value),
453                                           permitted=permitted))
454             else:
455                 msg = __("The config value `{name}' has type `{current.__name__}', "
456                          "defaults to `{default.__name__}'.")
457                 logger.warning(msg.format(name=confval.name,
458                                           current=type(confval.value),
459                                           default=type(default)))
460 
461 
462 def check_primary_domain(app: "Sphinx", config: Config) -> None:
463     primary_domain = config.primary_domain
464     if primary_domain and not app.registry.has_domain(primary_domain):
465         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)
466         config.primary_domain = None  # type: ignore
467 
468 
469 def check_root_doc(app: "Sphinx", env: "BuildEnvironment", added: Set[str],
470                    changed: Set[str], removed: Set[str]) -> Set[str]:
471     """Adjust root_doc to 'contents' to support an old project which does not have
472     no root_doc setting.
473     """
474     if (app.config.root_doc == 'index' and
475             'index' not in app.project.docnames and
476             'contents' in app.project.docnames):
477         logger.warning(__('Since v2.0, Sphinx uses "index" as root_doc by default. '
478                           'Please add "root_doc = \'contents\'" to your conf.py.'))
479         app.config.root_doc = "contents"  # type: ignore
480 
481     return changed
482 
483 
484 def setup(app: "Sphinx") -> Dict[str, Any]:
485     app.connect('config-inited', convert_source_suffix, priority=800)
486     app.connect('config-inited', convert_highlight_options, priority=800)
487     app.connect('config-inited', init_numfig_format, priority=800)
488     app.connect('config-inited', correct_copyright_year, priority=800)
489     app.connect('config-inited', check_confval_types, priority=800)
490     app.connect('config-inited', check_primary_domain, priority=800)
491     app.connect('env-get-outdated', check_root_doc)
492 
493     return {
494         'version': 'builtin',
495         'parallel_read_safe': True,
496         'parallel_write_safe': True,
497     }

</code><intended_behavior>Add a new configuration option that allows users to specify allowed redirect pairs. This configuration should be designed to preserve backward compatibility, defaulting to a mode that behaves as the link checker currently does unless explicitly configured to enforce redirect constraints.</intended_behavior>, <file>doc/conf.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Sphinx documentation build configuration file
2 
3 import re
4 
5 import sphinx
6 
7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',
8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',
9               'sphinx.ext.intersphinx',
10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']
11 
12 root_doc = 'contents'
13 templates_path = ['_templates']
14 exclude_patterns = ['_build']
15 
16 project = 'Sphinx'
17 copyright = '2007-2021, Georg Brandl and the Sphinx team'
18 version = sphinx.__display_version__
19 release = version
20 show_authors = True
21 
22 html_theme = 'sphinx13'
23 html_theme_path = ['_themes']
24 modindex_common_prefix = ['sphinx.']
25 html_static_path = ['_static']
26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}
27 html_title = 'Sphinx documentation'
28 html_additional_pages = {'index': 'index.html'}
29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'
30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'
31 html_favicon = '_static/favicon.svg'
32 
33 htmlhelp_basename = 'Sphinxdoc'
34 
35 epub_theme = 'epub'
36 epub_basename = 'sphinx'
37 epub_author = 'Georg Brandl'
38 epub_publisher = 'https://sphinx-doc.org/'
39 epub_uid = 'web-site'
40 epub_scheme = 'url'
41 epub_identifier = epub_publisher
42 epub_pre_files = [('index.xhtml', 'Welcome')]
43 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),
44                    ('develop.xhtml', 'Sphinx development')]
45 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',
46                       '_static/jquery.js', '_static/searchtools.js',
47                       '_static/underscore.js', '_static/basic.css',
48                       '_static/language_data.js',
49                       'search.html', '_static/websupport.js']
50 epub_fix_images = False
51 epub_max_image_width = 0
52 epub_show_urls = 'inline'
53 epub_use_index = False
54 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)
55 epub_description = 'Sphinx documentation generator system manual'
56 
57 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',
58                     'Georg Brandl', 'manual', 1)]
59 latex_logo = '_static/sphinx.png'
60 latex_elements = {
61     'fontenc': r'\usepackage[LGR,X2,T1]{fontenc}',
62     'passoptionstopackages': r'''
63 \PassOptionsToPackage{svgnames}{xcolor}
64 ''',
65     'preamble': r'''
66 \DeclareUnicodeCharacter{229E}{\ensuremath{\boxplus}}
67 \setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)
68 \setcounter{secnumdepth}{1}% depth of section numbering
69 ''',
70     # fix missing index entry due to RTD doing only once pdflatex after makeindex
71     'printindex': r'''
72 \IfFileExists{\jobname.ind}
73              {\footnotesize\raggedright\printindex}
74              {\begin{sphinxtheindex}\end{sphinxtheindex}}
75 ''',
76 }
77 latex_show_urls = 'footnote'
78 latex_use_xindy = True
79 
80 autodoc_member_order = 'groupwise'
81 autosummary_generate = False
82 todo_include_todos = True
83 extlinks = {'duref': ('https://docutils.sourceforge.io/docs/ref/rst/'
84                       'restructuredtext.html#%s', ''),
85             'durole': ('https://docutils.sourceforge.io/docs/ref/rst/'
86                        'roles.html#%s', ''),
87             'dudir': ('https://docutils.sourceforge.io/docs/ref/rst/'
88                       'directives.html#%s', '')}
89 
90 man_pages = [
91     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',
92      'Georg Brandl', 1),
93     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',
94      '', 1),
95     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '
96      'template generator', '', 1),
97     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',
98      '', 1),
99     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',
100      '', 1),
101 ]
102 
103 texinfo_documents = [
104     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',
105      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',
106      1),
107 ]
108 
109 intersphinx_mapping = {
110     'python': ('https://docs.python.org/3/', None),
111     'requests': ('https://requests.readthedocs.io/en/master', None),
112 }
113 
114 # Sphinx document translation with sphinx gettext feature uses these settings:
115 locale_dirs = ['locale/']
116 gettext_compact = False
117 
118 
119 # -- Extension interface -------------------------------------------------------
120 
121 from sphinx import addnodes  # noqa
122 
123 event_sig_re = re.compile(r'([a-zA-Z-]+)\s*\((.*)\)')
124 
125 
126 def parse_event(env, sig, signode):
127     m = event_sig_re.match(sig)
128     if not m:
129         signode += addnodes.desc_name(sig, sig)
130         return sig
131     name, args = m.groups()
132     signode += addnodes.desc_name(name, name)
133     plist = addnodes.desc_parameterlist()
134     for arg in args.split(','):
135         arg = arg.strip()
136         plist += addnodes.desc_parameter(arg, arg)
137     signode += plist
138     return name
139 
140 
141 def setup(app):
142     from sphinx.ext.autodoc import cut_lines
143     from sphinx.util.docfields import GroupedField
144     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
145     app.add_object_type('confval', 'confval',
146                         objname='configuration value',
147                         indextemplate='pair: %s; configuration value')
148     app.add_object_type('setuptools-confval', 'setuptools-confval',
149                         objname='setuptools configuration value',
150                         indextemplate='pair: %s; setuptools configuration value')
151     fdesc = GroupedField('parameter', label='Parameters',
152                          names=['param'], can_collapse=True)
153     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,
154                         doc_field_types=[fdesc])
155 
156     # workaround for RTD
157     from sphinx.util import logging
158     logger = logging.getLogger(__name__)
159     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)
160     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)
161     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)

</code><intended_behavior>Document the usage of the new configuration option for specifying allowed redirect pairs. Provide examples on how to set it to help users adopt the feature.</intended_behavior>]
2025-10-16 01:15:57.688 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 01:15:57.688 | INFO     | Search-only: skipping patch selection
2025-10-16 01:15:57.810 | INFO     | Task sphinx-doc__sphinx-9234 completed successfully.
2025-10-16 01:15:57.811 | INFO     | No patch generated. You can try running ACR again.
