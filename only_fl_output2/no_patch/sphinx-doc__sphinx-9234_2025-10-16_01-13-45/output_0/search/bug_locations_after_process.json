[
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.1/sphinx/config.py",
        "start": 1,
        "end": 497,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.config\n3     ~~~~~~~~~~~~~\n4 \n5     Build configuration file handling.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import traceback\n13 import types\n14 from collections import OrderedDict\n15 from os import getenv, path\n16 from typing import (TYPE_CHECKING, Any, Callable, Dict, Generator, Iterator, List, NamedTuple,\n17                     Optional, Set, Tuple, Union)\n18 \n19 from sphinx.errors import ConfigError, ExtensionError\n20 from sphinx.locale import _, __\n21 from sphinx.util import logging\n22 from sphinx.util.i18n import format_date\n23 from sphinx.util.osutil import cd, fs_encoding\n24 from sphinx.util.tags import Tags\n25 from sphinx.util.typing import NoneType\n26 \n27 if TYPE_CHECKING:\n28     from sphinx.application import Sphinx\n29     from sphinx.environment import BuildEnvironment\n30 \n31 logger = logging.getLogger(__name__)\n32 \n33 CONFIG_FILENAME = 'conf.py'\n34 UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\n35 copyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n36 \n37 \n38 class ConfigValue(NamedTuple):\n39     name: str\n40     value: Any\n41     rebuild: Union[bool, str]\n42 \n43 \n44 def is_serializable(obj: Any) -> bool:\n45     \"\"\"Check if object is serializable or not.\"\"\"\n46     if isinstance(obj, UNSERIALIZABLE_TYPES):\n47         return False\n48     elif isinstance(obj, dict):\n49         for key, value in obj.items():\n50             if not is_serializable(key) or not is_serializable(value):\n51                 return False\n52     elif isinstance(obj, (list, tuple, set)):\n53         return all(is_serializable(i) for i in obj)\n54 \n55     return True\n56 \n57 \n58 class ENUM:\n59     \"\"\"represents the config value should be a one of candidates.\n60 \n61     Example:\n62         app.add_config_value('latex_show_urls', 'no', None, ENUM('no', 'footnote', 'inline'))\n63     \"\"\"\n64     def __init__(self, *candidates: str) -> None:\n65         self.candidates = candidates\n66 \n67     def match(self, value: Union[str, List, Tuple]) -> bool:\n68         if isinstance(value, (list, tuple)):\n69             return all(item in self.candidates for item in value)\n70         else:\n71             return value in self.candidates\n72 \n73 \n74 class Config:\n75     \"\"\"Configuration file abstraction.\n76 \n77     The config object makes the values of all config values available as\n78     attributes.\n79 \n80     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n81     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n82     to get the value of :confval:`language`, use either ``app.config.language``\n83     or ``env.config.language``.\n84     \"\"\"\n85 \n86     # the values are: (default, what needs to be rebuilt if changed)\n87 \n88     # If you add a value here, don't forget to include it in the\n89     # quickstart.py file template as well as in the docs!\n90 \n91     config_values: Dict[str, Tuple] = {\n92         # general options\n93         'project': ('Python', 'env', []),\n94         'author': ('unknown', 'env', []),\n95         'project_copyright': ('', 'html', [str]),\n96         'copyright': (lambda c: c.project_copyright, 'html', [str]),\n97         'version': ('', 'env', []),\n98         'release': ('', 'env', []),\n99         'today': ('', 'env', []),\n100         # the real default is locale-dependent\n101         'today_fmt': (None, 'env', [str]),\n102 \n103         'language': (None, 'env', [str]),\n104         'locale_dirs': (['locales'], 'env', []),\n105         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n106 \n107         'master_doc': ('index', 'env', []),\n108         'root_doc': (lambda config: config.master_doc, 'env', []),\n109         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n110         'source_encoding': ('utf-8-sig', 'env', []),\n111         'exclude_patterns': ([], 'env', []),\n112         'default_role': (None, 'env', [str]),\n113         'add_function_parentheses': (True, 'env', []),\n114         'add_module_names': (True, 'env', []),\n115         'trim_footnote_reference_space': (False, 'env', []),\n116         'show_authors': (False, 'env', []),\n117         'pygments_style': (None, 'html', [str]),\n118         'highlight_language': ('default', 'env', []),\n119         'highlight_options': ({}, 'env', []),\n120         'templates_path': ([], 'html', []),\n121         'template_bridge': (None, 'html', [str]),\n122         'keep_warnings': (False, 'env', []),\n123         'suppress_warnings': ([], 'env', []),\n124         'modindex_common_prefix': ([], 'html', []),\n125         'rst_epilog': (None, 'env', [str]),\n126         'rst_prolog': (None, 'env', [str]),\n127         'trim_doctest_flags': (True, 'env', []),\n128         'primary_domain': ('py', 'env', [NoneType]),\n129         'needs_sphinx': (None, None, [str]),\n130         'needs_extensions': ({}, None, []),\n131         'manpages_url': (None, 'env', []),\n132         'nitpicky': (False, None, []),\n133         'nitpick_ignore': ([], None, []),\n134         'nitpick_ignore_regex': ([], None, []),\n135         'numfig': (False, 'env', []),\n136         'numfig_secnum_depth': (1, 'env', []),\n137         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n138 \n139         'math_number_all': (False, 'env', []),\n140         'math_eqref_format': (None, 'env', [str]),\n141         'math_numfig': (True, 'env', []),\n142         'tls_verify': (True, 'env', []),\n143         'tls_cacerts': (None, 'env', []),\n144         'user_agent': (None, 'env', [str]),\n145         'smartquotes': (True, 'env', []),\n146         'smartquotes_action': ('qDe', 'env', []),\n147         'smartquotes_excludes': ({'languages': ['ja'],\n148                                   'builders': ['man', 'text']},\n149                                  'env', []),\n150     }\n151 \n152     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n153         self.overrides = dict(overrides)\n154         self.values = Config.config_values.copy()\n155         self._raw_config = config\n156         self.setup: Optional[Callable] = config.get('setup', None)\n157 \n158         if 'extensions' in self.overrides:\n159             if isinstance(self.overrides['extensions'], str):\n160                 config['extensions'] = self.overrides.pop('extensions').split(',')\n161             else:\n162                 config['extensions'] = self.overrides.pop('extensions')\n163         self.extensions: List[str] = config.get('extensions', [])\n164 \n165     @classmethod\n166     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n167         \"\"\"Create a Config object from configuration file.\"\"\"\n168         filename = path.join(confdir, CONFIG_FILENAME)\n169         if not path.isfile(filename):\n170             raise ConfigError(__(\"config directory doesn't contain a conf.py file (%s)\") %\n171                               confdir)\n172         namespace = eval_config_file(filename, tags)\n173         return cls(namespace, overrides or {})\n174 \n175     def convert_overrides(self, name: str, value: Any) -> Any:\n176         if not isinstance(value, str):\n177             return value\n178         else:\n179             defvalue = self.values[name][0]\n180             if self.values[name][2] == Any:\n181                 return value\n182             elif self.values[name][2] == {bool, str}:\n183                 if value == '0':\n184                     # given falsy string from command line option\n185                     return False\n186                 elif value == '1':\n187                     return True\n188                 else:\n189                     return value\n190             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n191                 if value == '0':\n192                     # given falsy string from command line option\n193                     return False\n194                 else:\n195                     return bool(value)\n196             elif isinstance(defvalue, dict):\n197                 raise ValueError(__('cannot override dictionary config setting %r, '\n198                                     'ignoring (use %r to set individual elements)') %\n199                                  (name, name + '.key=value'))\n200             elif isinstance(defvalue, list):\n201                 return value.split(',')\n202             elif isinstance(defvalue, int):\n203                 try:\n204                     return int(value)\n205                 except ValueError as exc:\n206                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n207                                      (value, name)) from exc\n208             elif hasattr(defvalue, '__call__'):\n209                 return value\n210             elif defvalue is not None and not isinstance(defvalue, str):\n211                 raise ValueError(__('cannot override config setting %r with unsupported '\n212                                     'type, ignoring') % name)\n213             else:\n214                 return value\n215 \n216     def pre_init_values(self) -> None:\n217         \"\"\"\n218         Initialize some limited config variables before initialize i18n and loading extensions\n219         \"\"\"\n220         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n221         for name in variables:\n222             try:\n223                 if name in self.overrides:\n224                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n225                 elif name in self._raw_config:\n226                     self.__dict__[name] = self._raw_config[name]\n227             except ValueError as exc:\n228                 logger.warning(\"%s\", exc)\n229 \n230     def init_values(self) -> None:\n231         config = self._raw_config\n232         for valname, value in self.overrides.items():\n233             try:\n234                 if '.' in valname:\n235                     realvalname, key = valname.split('.', 1)\n236                     config.setdefault(realvalname, {})[key] = value\n237                     continue\n238                 elif valname not in self.values:\n239                     logger.warning(__('unknown config value %r in override, ignoring'),\n240                                    valname)\n241                     continue\n242                 if isinstance(value, str):\n243                     config[valname] = self.convert_overrides(valname, value)\n244                 else:\n245                     config[valname] = value\n246             except ValueError as exc:\n247                 logger.warning(\"%s\", exc)\n248         for name in config:\n249             if name in self.values:\n250                 self.__dict__[name] = config[name]\n251 \n252     def __getattr__(self, name: str) -> Any:\n253         if name.startswith('_'):\n254             raise AttributeError(name)\n255         if name not in self.values:\n256             raise AttributeError(__('No such config value: %s') % name)\n257         default = self.values[name][0]\n258         if hasattr(default, '__call__'):\n259             return default(self)\n260         return default\n261 \n262     def __getitem__(self, name: str) -> Any:\n263         return getattr(self, name)\n264 \n265     def __setitem__(self, name: str, value: Any) -> None:\n266         setattr(self, name, value)\n267 \n268     def __delitem__(self, name: str) -> None:\n269         delattr(self, name)\n270 \n271     def __contains__(self, name: str) -> bool:\n272         return name in self.values\n273 \n274     def __iter__(self) -> Generator[ConfigValue, None, None]:\n275         for name, value in self.values.items():\n276             yield ConfigValue(name, getattr(self, name), value[1])\n277 \n278     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n279         if name in self.values:\n280             raise ExtensionError(__('Config value %r already present') % name)\n281         else:\n282             self.values[name] = (default, rebuild, types)\n283 \n284     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n285         if isinstance(rebuild, str):\n286             rebuild = [rebuild]\n287         return (value for value in self if value.rebuild in rebuild)\n288 \n289     def __getstate__(self) -> Dict:\n290         \"\"\"Obtains serializable data for pickling.\"\"\"\n291         # remove potentially pickling-problematic values from config\n292         __dict__ = {}\n293         for key, value in self.__dict__.items():\n294             if key.startswith('_') or not is_serializable(value):\n295                 pass\n296             else:\n297                 __dict__[key] = value\n298 \n299         # create a picklable copy of values list\n300         __dict__['values'] = {}\n301         for key, value in self.values.items():\n302             real_value = getattr(self, key)\n303             if not is_serializable(real_value):\n304                 # omit unserializable value\n305                 real_value = None\n306 \n307             # types column is also omitted\n308             __dict__['values'][key] = (real_value, value[1], None)\n309 \n310         return __dict__\n311 \n312     def __setstate__(self, state: Dict) -> None:\n313         self.__dict__.update(state)\n314 \n315 \n316 def eval_config_file(filename: str, tags: Optional[Tags]) -> Dict[str, Any]:\n317     \"\"\"Evaluate a config file.\"\"\"\n318     namespace: Dict[str, Any] = {}\n319     namespace['__file__'] = filename\n320     namespace['tags'] = tags\n321 \n322     with cd(path.dirname(filename)):\n323         # during executing config file, current dir is changed to ``confdir``.\n324         try:\n325             with open(filename, 'rb') as f:\n326                 code = compile(f.read(), filename.encode(fs_encoding), 'exec')\n327                 exec(code, namespace)\n328         except SyntaxError as err:\n329             msg = __(\"There is a syntax error in your configuration file: %s\\n\")\n330             raise ConfigError(msg % err) from err\n331         except SystemExit as exc:\n332             msg = __(\"The configuration file (or one of the modules it imports) \"\n333                      \"called sys.exit()\")\n334             raise ConfigError(msg) from exc\n335         except ConfigError:\n336             # pass through ConfigError from conf.py as is.  It will be shown in console.\n337             raise\n338         except Exception as exc:\n339             msg = __(\"There is a programmable error in your configuration file:\\n\\n%s\")\n340             raise ConfigError(msg % traceback.format_exc()) from exc\n341 \n342     return namespace\n343 \n344 \n345 def convert_source_suffix(app: \"Sphinx\", config: Config) -> None:\n346     \"\"\"This converts old styled source_suffix to new styled one.\n347 \n348     * old style: str or list\n349     * new style: a dict which maps from fileext to filetype\n350     \"\"\"\n351     source_suffix = config.source_suffix\n352     if isinstance(source_suffix, str):\n353         # if str, considers as default filetype (None)\n354         #\n355         # The default filetype is determined on later step.\n356         # By default, it is considered as restructuredtext.\n357         config.source_suffix = OrderedDict({source_suffix: None})  # type: ignore\n358     elif isinstance(source_suffix, (list, tuple)):\n359         # if list, considers as all of them are default filetype\n360         config.source_suffix = OrderedDict([(s, None) for s in source_suffix])  # type: ignore  # NOQA\n361     elif isinstance(source_suffix, dict):\n362         # if dict, convert it to OrderedDict\n363         config.source_suffix = OrderedDict(config.source_suffix)  # type: ignore\n364     else:\n365         logger.warning(__(\"The config value `source_suffix' expects \"\n366                           \"a string, list of strings, or dictionary. \"\n367                           \"But `%r' is given.\" % source_suffix))\n368 \n369 \n370 def convert_highlight_options(app: \"Sphinx\", config: Config) -> None:\n371     \"\"\"Convert old styled highlight_options to new styled one.\n372 \n373     * old style: options\n374     * new style: dict that maps language names to options\n375     \"\"\"\n376     options = config.highlight_options\n377     if options and not all(isinstance(v, dict) for v in options.values()):\n378         # old styled option detected because all values are not dictionary.\n379         config.highlight_options = {config.highlight_language: options}  # type: ignore\n380 \n381 \n382 def init_numfig_format(app: \"Sphinx\", config: Config) -> None:\n383     \"\"\"Initialize :confval:`numfig_format`.\"\"\"\n384     numfig_format = {'section': _('Section %s'),\n385                      'figure': _('Fig. %s'),\n386                      'table': _('Table %s'),\n387                      'code-block': _('Listing %s')}\n388 \n389     # override default labels by configuration\n390     numfig_format.update(config.numfig_format)\n391     config.numfig_format = numfig_format  # type: ignore\n392 \n393 \n394 def correct_copyright_year(app: \"Sphinx\", config: Config) -> None:\n395     \"\"\"correct values of copyright year that are not coherent with\n396     the SOURCE_DATE_EPOCH environment variable (if set)\n397 \n398     See https://reproducible-builds.org/specs/source-date-epoch/\n399     \"\"\"\n400     if getenv('SOURCE_DATE_EPOCH') is not None:\n401         for k in ('copyright', 'epub_copyright'):\n402             if k in config:\n403                 replace = r'\\g<1>%s' % format_date('%Y')\n404                 config[k] = copyright_year_re.sub(replace, config[k])\n405 \n406 \n407 def check_confval_types(app: \"Sphinx\", config: Config) -> None:\n408     \"\"\"check all values for deviation from the default value's type, since\n409     that can result in TypeErrors all over the place NB.\n410     \"\"\"\n411     for confval in config:\n412         default, rebuild, annotations = config.values[confval.name]\n413 \n414         if hasattr(default, '__call__'):\n415             default = default(config)  # evaluate default value\n416         if default is None and not annotations:\n417             continue  # neither inferrable nor expliclitly annotated types\n418 \n419         if annotations is Any:\n420             # any type of value is accepted\n421             pass\n422         elif isinstance(annotations, ENUM):\n423             if not annotations.match(confval.value):\n424                 msg = __(\"The config value `{name}` has to be a one of {candidates}, \"\n425                          \"but `{current}` is given.\")\n426                 logger.warning(msg.format(name=confval.name,\n427                                           current=confval.value,\n428                                           candidates=annotations.candidates))\n429         else:\n430             if type(confval.value) is type(default):\n431                 continue\n432             if type(confval.value) in annotations:\n433                 continue\n434 \n435             common_bases = (set(type(confval.value).__bases__ + (type(confval.value),)) &\n436                             set(type(default).__bases__))\n437             common_bases.discard(object)\n438             if common_bases:\n439                 continue  # at least we share a non-trivial base class\n440 \n441             if annotations:\n442                 msg = __(\"The config value `{name}' has type `{current.__name__}'; \"\n443                          \"expected {permitted}.\")\n444                 wrapped_annotations = [\"`{}'\".format(c.__name__) for c in annotations]\n445                 if len(wrapped_annotations) > 2:\n446                     permitted = \"{}, or {}\".format(\n447                         \", \".join(wrapped_annotations[:-1]),\n448                         wrapped_annotations[-1])\n449                 else:\n450                     permitted = \" or \".join(wrapped_annotations)\n451                 logger.warning(msg.format(name=confval.name,\n452                                           current=type(confval.value),\n453                                           permitted=permitted))\n454             else:\n455                 msg = __(\"The config value `{name}' has type `{current.__name__}', \"\n456                          \"defaults to `{default.__name__}'.\")\n457                 logger.warning(msg.format(name=confval.name,\n458                                           current=type(confval.value),\n459                                           default=type(default)))\n460 \n461 \n462 def check_primary_domain(app: \"Sphinx\", config: Config) -> None:\n463     primary_domain = config.primary_domain\n464     if primary_domain and not app.registry.has_domain(primary_domain):\n465         logger.warning(__('primary_domain %r not found, ignored.'), primary_domain)\n466         config.primary_domain = None  # type: ignore\n467 \n468 \n469 def check_root_doc(app: \"Sphinx\", env: \"BuildEnvironment\", added: Set[str],\n470                    changed: Set[str], removed: Set[str]) -> Set[str]:\n471     \"\"\"Adjust root_doc to 'contents' to support an old project which does not have\n472     no root_doc setting.\n473     \"\"\"\n474     if (app.config.root_doc == 'index' and\n475             'index' not in app.project.docnames and\n476             'contents' in app.project.docnames):\n477         logger.warning(__('Since v2.0, Sphinx uses \"index\" as root_doc by default. '\n478                           'Please add \"root_doc = \\'contents\\'\" to your conf.py.'))\n479         app.config.root_doc = \"contents\"  # type: ignore\n480 \n481     return changed\n482 \n483 \n484 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n485     app.connect('config-inited', convert_source_suffix, priority=800)\n486     app.connect('config-inited', convert_highlight_options, priority=800)\n487     app.connect('config-inited', init_numfig_format, priority=800)\n488     app.connect('config-inited', correct_copyright_year, priority=800)\n489     app.connect('config-inited', check_confval_types, priority=800)\n490     app.connect('config-inited', check_primary_domain, priority=800)\n491     app.connect('env-get-outdated', check_root_doc)\n492 \n493     return {\n494         'version': 'builtin',\n495         'parallel_read_safe': True,\n496         'parallel_write_safe': True,\n497     }\n",
        "intended_behavior": "Add a new configuration option that allows users to specify allowed redirect pairs. This configuration should be designed to preserve backward compatibility, defaulting to a mode that behaves as the link checker currently does unless explicitly configured to enforce redirect constraints."
    },
    {
        "rel_file_path": "doc/conf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.1/doc/conf.py",
        "start": 1,
        "end": 161,
        "class_name": null,
        "method_name": null,
        "code": "1 # Sphinx documentation build configuration file\n2 \n3 import re\n4 \n5 import sphinx\n6 \n7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',\n9               'sphinx.ext.intersphinx',\n10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']\n11 \n12 root_doc = 'contents'\n13 templates_path = ['_templates']\n14 exclude_patterns = ['_build']\n15 \n16 project = 'Sphinx'\n17 copyright = '2007-2021, Georg Brandl and the Sphinx team'\n18 version = sphinx.__display_version__\n19 release = version\n20 show_authors = True\n21 \n22 html_theme = 'sphinx13'\n23 html_theme_path = ['_themes']\n24 modindex_common_prefix = ['sphinx.']\n25 html_static_path = ['_static']\n26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}\n27 html_title = 'Sphinx documentation'\n28 html_additional_pages = {'index': 'index.html'}\n29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'\n30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'\n31 html_favicon = '_static/favicon.svg'\n32 \n33 htmlhelp_basename = 'Sphinxdoc'\n34 \n35 epub_theme = 'epub'\n36 epub_basename = 'sphinx'\n37 epub_author = 'Georg Brandl'\n38 epub_publisher = 'https://sphinx-doc.org/'\n39 epub_uid = 'web-site'\n40 epub_scheme = 'url'\n41 epub_identifier = epub_publisher\n42 epub_pre_files = [('index.xhtml', 'Welcome')]\n43 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),\n44                    ('develop.xhtml', 'Sphinx development')]\n45 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',\n46                       '_static/jquery.js', '_static/searchtools.js',\n47                       '_static/underscore.js', '_static/basic.css',\n48                       '_static/language_data.js',\n49                       'search.html', '_static/websupport.js']\n50 epub_fix_images = False\n51 epub_max_image_width = 0\n52 epub_show_urls = 'inline'\n53 epub_use_index = False\n54 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)\n55 epub_description = 'Sphinx documentation generator system manual'\n56 \n57 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',\n58                     'Georg Brandl', 'manual', 1)]\n59 latex_logo = '_static/sphinx.png'\n60 latex_elements = {\n61     'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n62     'passoptionstopackages': r'''\n63 \\PassOptionsToPackage{svgnames}{xcolor}\n64 ''',\n65     'preamble': r'''\n66 \\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}\n67 \\setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)\n68 \\setcounter{secnumdepth}{1}% depth of section numbering\n69 ''',\n70     # fix missing index entry due to RTD doing only once pdflatex after makeindex\n71     'printindex': r'''\n72 \\IfFileExists{\\jobname.ind}\n73              {\\footnotesize\\raggedright\\printindex}\n74              {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n75 ''',\n76 }\n77 latex_show_urls = 'footnote'\n78 latex_use_xindy = True\n79 \n80 autodoc_member_order = 'groupwise'\n81 autosummary_generate = False\n82 todo_include_todos = True\n83 extlinks = {'duref': ('https://docutils.sourceforge.io/docs/ref/rst/'\n84                       'restructuredtext.html#%s', ''),\n85             'durole': ('https://docutils.sourceforge.io/docs/ref/rst/'\n86                        'roles.html#%s', ''),\n87             'dudir': ('https://docutils.sourceforge.io/docs/ref/rst/'\n88                       'directives.html#%s', '')}\n89 \n90 man_pages = [\n91     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',\n92      'Georg Brandl', 1),\n93     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',\n94      '', 1),\n95     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '\n96      'template generator', '', 1),\n97     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',\n98      '', 1),\n99     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',\n100      '', 1),\n101 ]\n102 \n103 texinfo_documents = [\n104     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',\n105      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',\n106      1),\n107 ]\n108 \n109 intersphinx_mapping = {\n110     'python': ('https://docs.python.org/3/', None),\n111     'requests': ('https://requests.readthedocs.io/en/master', None),\n112 }\n113 \n114 # Sphinx document translation with sphinx gettext feature uses these settings:\n115 locale_dirs = ['locale/']\n116 gettext_compact = False\n117 \n118 \n119 # -- Extension interface -------------------------------------------------------\n120 \n121 from sphinx import addnodes  # noqa\n122 \n123 event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n124 \n125 \n126 def parse_event(env, sig, signode):\n127     m = event_sig_re.match(sig)\n128     if not m:\n129         signode += addnodes.desc_name(sig, sig)\n130         return sig\n131     name, args = m.groups()\n132     signode += addnodes.desc_name(name, name)\n133     plist = addnodes.desc_parameterlist()\n134     for arg in args.split(','):\n135         arg = arg.strip()\n136         plist += addnodes.desc_parameter(arg, arg)\n137     signode += plist\n138     return name\n139 \n140 \n141 def setup(app):\n142     from sphinx.ext.autodoc import cut_lines\n143     from sphinx.util.docfields import GroupedField\n144     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n145     app.add_object_type('confval', 'confval',\n146                         objname='configuration value',\n147                         indextemplate='pair: %s; configuration value')\n148     app.add_object_type('setuptools-confval', 'setuptools-confval',\n149                         objname='setuptools configuration value',\n150                         indextemplate='pair: %s; setuptools configuration value')\n151     fdesc = GroupedField('parameter', label='Parameters',\n152                          names=['param'], can_collapse=True)\n153     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,\n154                         doc_field_types=[fdesc])\n155 \n156     # workaround for RTD\n157     from sphinx.util import logging\n158     logger = logging.getLogger(__name__)\n159     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)\n160     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)\n161     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n",
        "intended_behavior": "Document the usage of the new configuration option for specifying allowed redirect pairs. Provide examples on how to set it to help users adopt the feature."
    }
]