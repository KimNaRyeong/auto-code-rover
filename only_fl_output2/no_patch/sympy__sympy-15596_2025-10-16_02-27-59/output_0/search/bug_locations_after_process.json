[
    {
        "rel_file_path": "sympy/polys/polytools.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/polys/polytools.py",
        "start": 4422,
        "end": 4472,
        "class_name": null,
        "method_name": "degree",
        "code": "4422 def degree(f, gen=0):\n4423     \"\"\"\n4424     Return the degree of ``f`` in the given variable.\n4425 \n4426     The degree of 0 is negative infinity.\n4427 \n4428     Examples\n4429     ========\n4430 \n4431     >>> from sympy import degree\n4432     >>> from sympy.abc import x, y\n4433 \n4434     >>> degree(x**2 + y*x + 1, gen=x)\n4435     2\n4436     >>> degree(x**2 + y*x + 1, gen=y)\n4437     1\n4438     >>> degree(0, x)\n4439     -oo\n4440 \n4441     See also\n4442     ========\n4443     total_degree\n4444     degree_list\n4445     \"\"\"\n4446 \n4447     f = sympify(f, strict=True)\n4448     if f.is_Poly:\n4449         p = f\n4450         isNum = p.as_expr().is_Number\n4451     else:\n4452         isNum = f.is_Number\n4453         if not isNum:\n4454             p, _ = poly_from_expr(f)\n4455 \n4456     if isNum:\n4457         return S.Zero if f else S.NegativeInfinity\n4458 \n4459     if not sympify(gen, strict=True).is_Number:\n4460         if f.is_Poly and gen not in p.gens:\n4461             # try recast without explicit gens\n4462             p, _ = poly_from_expr(f.as_expr())\n4463         if gen not in p.gens:\n4464             return S.Zero\n4465     elif not f.is_Poly and len(f.free_symbols) > 1:\n4466         raise TypeError(filldedent('''\n4467          A symbolic generator of interest is required for a multivariate\n4468          expression like func = %s, e.g. degree(func, gen = %s) instead of\n4469          degree(func, gen = %s).\n4470         ''' % (f, next(ordered(f.free_symbols)), gen)))\n4471 \n4472     return Integer(p.degree(gen))\n",
        "intended_behavior": "The `degree` method in `polytools.py` should have a clear mechanism to handle rational functions directly or provide a meaningful exception if such computation cannot be conducted. To resolve the issue, the method might need an enhancement to correctly identify and compute the degree of a rational function as the maximum degree of its numerator polynomial minus the degree of its denominator polynomial, following the mathematical definition of the degree of a rational function. This functionality should be added in such a way that it doesn't interfere with the existing handling of polynomial degree computation, potentially by adding a check to see if the input is a rational function and then applying the appropriate logic. If the implementation cannot support rational functions, it should fail more gracefully with a specific error message indicating that the degree of a rational function is not supported or directly compute it if possible."
    },
    {
        "rel_file_path": "sympy/polys/polytools.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/polys/polytools.py",
        "start": 1758,
        "end": 1783,
        "class_name": null,
        "method_name": "degree",
        "code": "1758     def degree(f, gen=0):\n1759         \"\"\"\n1760         Returns degree of ``f`` in ``x_j``.\n1761 \n1762         The degree of 0 is negative infinity.\n1763 \n1764         Examples\n1765         ========\n1766 \n1767         >>> from sympy import Poly\n1768         >>> from sympy.abc import x, y\n1769 \n1770         >>> Poly(x**2 + y*x + 1, x, y).degree()\n1771         2\n1772         >>> Poly(x**2 + y*x + y, x, y).degree(y)\n1773         1\n1774         >>> Poly(0, x).degree()\n1775         -oo\n1776 \n1777         \"\"\"\n1778         j = f._gen_to_level(gen)\n1779 \n1780         if hasattr(f.rep, 'degree'):\n1781             return f.rep.degree(j)\n1782         else:  # pragma: no cover\n1783             raise OperationNotSupported(f, 'degree')\n",
        "intended_behavior": "The `degree` method in `polytools.py` should have a clear mechanism to handle rational functions directly or provide a meaningful exception if such computation cannot be conducted. To resolve the issue, the method might need an enhancement to correctly identify and compute the degree of a rational function as the maximum degree of its numerator polynomial minus the degree of its denominator polynomial, following the mathematical definition of the degree of a rational function. This functionality should be added in such a way that it doesn't interfere with the existing handling of polynomial degree computation, potentially by adding a check to see if the input is a rational function and then applying the appropriate logic. If the implementation cannot support rational functions, it should fail more gracefully with a specific error message indicating that the degree of a rational function is not supported or directly compute it if possible."
    },
    {
        "rel_file_path": "sympy/polys/polytools.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/polys/polytools.py",
        "start": 1758,
        "end": 1783,
        "class_name": "Poly",
        "method_name": "degree",
        "code": "1758     def degree(f, gen=0):\n1759         \"\"\"\n1760         Returns degree of ``f`` in ``x_j``.\n1761 \n1762         The degree of 0 is negative infinity.\n1763 \n1764         Examples\n1765         ========\n1766 \n1767         >>> from sympy import Poly\n1768         >>> from sympy.abc import x, y\n1769 \n1770         >>> Poly(x**2 + y*x + 1, x, y).degree()\n1771         2\n1772         >>> Poly(x**2 + y*x + y, x, y).degree(y)\n1773         1\n1774         >>> Poly(0, x).degree()\n1775         -oo\n1776 \n1777         \"\"\"\n1778         j = f._gen_to_level(gen)\n1779 \n1780         if hasattr(f.rep, 'degree'):\n1781             return f.rep.degree(j)\n1782         else:  # pragma: no cover\n1783             raise OperationNotSupported(f, 'degree')\n",
        "intended_behavior": "The `degree` method in `polytools.py` should have a clear mechanism to handle rational functions directly or provide a meaningful exception if such computation cannot be conducted. To resolve the issue, the method might need an enhancement to correctly identify and compute the degree of a rational function as the maximum degree of its numerator polynomial minus the degree of its denominator polynomial, following the mathematical definition of the degree of a rational function. This functionality should be added in such a way that it doesn't interfere with the existing handling of polynomial degree computation, potentially by adding a check to see if the input is a rational function and then applying the appropriate logic. If the implementation cannot support rational functions, it should fail more gracefully with a specific error message indicating that the degree of a rational function is not supported or directly compute it if possible."
    }
]