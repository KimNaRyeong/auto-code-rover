2025-10-16 00:00:30.852 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:00:33.906 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=258, output_tokens=12, cost=0.002940
2025-10-16 00:00:47.814 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=438, output_tokens=474, cost=0.018600
2025-10-16 00:00:48.863 | INFO     | registered non reproducing test 0
2025-10-16 00:01:07.544 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1764, output_tokens=655, cost=0.037290
2025-10-16 00:01:08.571 | INFO     | registered non reproducing test 1
2025-10-16 00:01:24.792 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1800, output_tokens=585, cost=0.035550
2025-10-16 00:01:25.954 | INFO     | registered non reproducing test 2
2025-10-16 00:01:25.954 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 00:01:25.961 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:01:32.154 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=566, output_tokens=242, cost=0.012920
2025-10-16 00:01:32.160 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:01:34.984 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=596, output_tokens=64, cost=0.007880
2025-10-16 00:01:34.986 | DEBUG    | Extracted a valid json.
2025-10-16 00:01:34.986 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"SplineTransformer\")",
        "search_code(\"fit_transform\")",
        "search_method(\"fit_transform\")",
        "search_code(\"import numpy as np\")",
        "search_code(\"import scipy\")"
    ],
    "bug_locations": []
}
2025-10-16 00:01:35.947 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:01:35.948 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:01:56.817 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14738, output_tokens=699, cost=0.168350
2025-10-16 00:01:56.825 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:02:07.678 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=15653, output_tokens=342, cost=0.166790
2025-10-16 00:02:07.684 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:02:16.357 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=696, output_tokens=338, cost=0.017100
2025-10-16 00:02:16.358 | DEBUG    | Extracted a valid json.
2025-10-16 00:02:16.358 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sklearn/preprocessing/_polynomial.py",
            "class": "SplineTransformer",
            "method": "transform",
            "intended_behavior": "The `transform` method inside the `SplineTransformer` class needs to be enhanced to support returning a sparse matrix based on a new parameter, say `sparse_output`, with a default value of `False` to ensure backward compatibility. This modification would involve utilizing the `design_matrix` functionality from `scipy` when `sparse=True`, converting the dense output into a sparse matrix format efficiently. The method must check the version of `scipy` to ensure compatibility and fall back to the previous behavior if the version is less than 1.8. Additionally, clear documentation should be provided regarding the usage of the new `sparse` parameter, including notes on `scipy` version requirements."
        },
        {
            "file": "sklearn/preprocessing/_polynomial.py",
            "class": "SplineTransformer",
            "method": "__init__",
            "intended_behavior": "In the `__init__` method of the `SplineTransformer` class, a new parameter named `sparse` with default value `False` should be added. This parameter would control whether the output of the `transform` method is dense (the default, as per current behavior) or sparse. The documentation for `__init__` should be updated to describe this new parameter, specifying that setting it to `True` requires `scipy>=1.8` for sparse output support."
        }
    ]
}
2025-10-16 00:02:16.368 | DEBUG    | Bug location extracted successfully: [<file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>transform</method>
<code>
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]

</code><intended_behavior>The `transform` method inside the `SplineTransformer` class needs to be enhanced to support returning a sparse matrix based on a new parameter, say `sparse_output`, with a default value of `False` to ensure backward compatibility. This modification would involve utilizing the `design_matrix` functionality from `scipy` when `sparse=True`, converting the dense output into a sparse matrix format efficiently. The method must check the version of `scipy` to ensure compatibility and fall back to the previous behavior if the version is less than 1.8. Additionally, clear documentation should be provided regarding the usage of the new `sparse` parameter, including notes on `scipy` version requirements.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>None</method>
<code>
579 class SplineTransformer(TransformerMixin, BaseEstimator):
580     """Generate univariate B-spline bases for features.
581 
582     Generate a new feature matrix consisting of
583     `n_splines=n_knots + degree - 1` (`n_knots - 1` for
584     `extrapolation="periodic"`) spline basis functions
585     (B-splines) of polynomial order=`degree` for each feature.
586 
587     Read more in the :ref:`User Guide <spline_transformer>`.
588 
589     .. versionadded:: 1.0
590 
591     Parameters
592     ----------
593     n_knots : int, default=5
594         Number of knots of the splines if `knots` equals one of
595         {'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`
596         is array-like.
597 
598     degree : int, default=3
599         The polynomial degree of the spline basis. Must be a non-negative
600         integer.
601 
602     knots : {'uniform', 'quantile'} or array-like of shape \
603         (n_knots, n_features), default='uniform'
604         Set knot positions such that first knot <= features <= last knot.
605 
606         - If 'uniform', `n_knots` number of knots are distributed uniformly
607           from min to max values of the features.
608         - If 'quantile', they are distributed uniformly along the quantiles of
609           the features.
610         - If an array-like is given, it directly specifies the sorted knot
611           positions including the boundary knots. Note that, internally,
612           `degree` number of knots are added before the first knot, the same
613           after the last knot.
614 
615     extrapolation : {'error', 'constant', 'linear', 'continue', 'periodic'}, \
616         default='constant'
617         If 'error', values outside the min and max values of the training
618         features raises a `ValueError`. If 'constant', the value of the
619         splines at minimum and maximum value of the features is used as
620         constant extrapolation. If 'linear', a linear extrapolation is used.
621         If 'continue', the splines are extrapolated as is, i.e. option
622         `extrapolate=True` in :class:`scipy.interpolate.BSpline`. If
623         'periodic', periodic splines with a periodicity equal to the distance
624         between the first and last knot are used. Periodic splines enforce
625         equal function values and derivatives at the first and last knot.
626         For example, this makes it possible to avoid introducing an arbitrary
627         jump between Dec 31st and Jan 1st in spline features derived from a
628         naturally periodic "day-of-year" input feature. In this case it is
629         recommended to manually set the knot values to control the period.
630 
631     include_bias : bool, default=True
632         If False, then the last spline element inside the data range
633         of a feature is dropped. As B-splines sum to one over the spline basis
634         functions for each data point, they implicitly include a bias term,
635         i.e. a column of ones. It acts as an intercept term in a linear models.
636 
637     order : {'C', 'F'}, default='C'
638         Order of output array. 'F' order is faster to compute, but may slow
639         down subsequent estimators.
640 
641     Attributes
642     ----------
643     bsplines_ : list of shape (n_features,)
644         List of BSplines objects, one for each feature.
645 
646     n_features_in_ : int
647         The total number of input features.
648 
649     feature_names_in_ : ndarray of shape (`n_features_in_`,)
650         Names of features seen during :term:`fit`. Defined only when `X`
651         has feature names that are all strings.
652 
653         .. versionadded:: 1.0
654 
655     n_features_out_ : int
656         The total number of output features, which is computed as
657         `n_features * n_splines`, where `n_splines` is
658         the number of bases elements of the B-splines,
659         `n_knots + degree - 1` for non-periodic splines and
660         `n_knots - 1` for periodic ones.
661         If `include_bias=False`, then it is only
662         `n_features * (n_splines - 1)`.
663 
664     See Also
665     --------
666     KBinsDiscretizer : Transformer that bins continuous data into intervals.
667 
668     PolynomialFeatures : Transformer that generates polynomial and interaction
669         features.
670 
671     Notes
672     -----
673     High degrees and a high number of knots can cause overfitting.
674 
675     See :ref:`examples/linear_model/plot_polynomial_interpolation.py
676     <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.
677 
678     Examples
679     --------
680     >>> import numpy as np
681     >>> from sklearn.preprocessing import SplineTransformer
682     >>> X = np.arange(6).reshape(6, 1)
683     >>> spline = SplineTransformer(degree=2, n_knots=3)
684     >>> spline.fit_transform(X)
685     array([[0.5 , 0.5 , 0.  , 0.  ],
686            [0.18, 0.74, 0.08, 0.  ],
687            [0.02, 0.66, 0.32, 0.  ],
688            [0.  , 0.32, 0.66, 0.02],
689            [0.  , 0.08, 0.74, 0.18],
690            [0.  , 0.  , 0.5 , 0.5 ]])
691     """
692 
693     _parameter_constraints: dict = {
694         "n_knots": [Interval(Integral, 2, None, closed="left")],
695         "degree": [Interval(Integral, 0, None, closed="left")],
696         "knots": [StrOptions({"uniform", "quantile"}), "array-like"],
697         "extrapolation": [
698             StrOptions({"error", "constant", "linear", "continue", "periodic"})
699         ],
700         "include_bias": ["boolean"],
701         "order": [StrOptions({"C", "F"})],
702     }
703 
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order
720 
721     @staticmethod
722     def _get_base_knot_positions(X, n_knots=10, knots="uniform", sample_weight=None):
723         """Calculate base knot positions.
724 
725         Base knots such that first knot <= feature <= last knot. For the
726         B-spline construction with scipy.interpolate.BSpline, 2*degree knots
727         beyond the base interval are added.
728 
729         Returns
730         -------
731         knots : ndarray of shape (n_knots, n_features), dtype=np.float64
732             Knot positions (points) of base interval.
733         """
734         if knots == "quantile":
735             percentiles = 100 * np.linspace(
736                 start=0, stop=1, num=n_knots, dtype=np.float64
737             )
738 
739             if sample_weight is None:
740                 knots = np.percentile(X, percentiles, axis=0)
741             else:
742                 knots = np.array(
743                     [
744                         _weighted_percentile(X, sample_weight, percentile)
745                         for percentile in percentiles
746                     ]
747                 )
748 
749         else:
750             # knots == 'uniform':
751             # Note that the variable `knots` has already been validated and
752             # `else` is therefore safe.
753             # Disregard observations with zero weight.
754             mask = slice(None, None, 1) if sample_weight is None else sample_weight > 0
755             x_min = np.amin(X[mask], axis=0)
756             x_max = np.amax(X[mask], axis=0)
757 
758             knots = np.linspace(
759                 start=x_min,
760                 stop=x_max,
761                 num=n_knots,
762                 endpoint=True,
763                 dtype=np.float64,
764             )
765 
766         return knots
767 
768     def get_feature_names_out(self, input_features=None):
769         """Get output feature names for transformation.
770 
771         Parameters
772         ----------
773         input_features : array-like of str or None, default=None
774             Input features.
775 
776             - If `input_features` is `None`, then `feature_names_in_` is
777               used as feature names in. If `feature_names_in_` is not defined,
778               then the following input feature names are generated:
779               `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
780             - If `input_features` is an array-like, then `input_features` must
781               match `feature_names_in_` if `feature_names_in_` is defined.
782 
783         Returns
784         -------
785         feature_names_out : ndarray of str objects
786             Transformed feature names.
787         """
788         check_is_fitted(self, "n_features_in_")
789         n_splines = self.bsplines_[0].c.shape[1]
790 
791         input_features = _check_feature_names_in(self, input_features)
792         feature_names = []
793         for i in range(self.n_features_in_):
794             for j in range(n_splines - 1 + self.include_bias):
795                 feature_names.append(f"{input_features[i]}_sp_{j}")
796         return np.asarray(feature_names, dtype=object)
797 
798     def fit(self, X, y=None, sample_weight=None):
799         """Compute knot positions of splines.
800 
801         Parameters
802         ----------
803         X : array-like of shape (n_samples, n_features)
804             The data.
805 
806         y : None
807             Ignored.
808 
809         sample_weight : array-like of shape (n_samples,), default = None
810             Individual weights for each sample. Used to calculate quantiles if
811             `knots="quantile"`. For `knots="uniform"`, zero weighted
812             observations are ignored for finding the min and max of `X`.
813 
814         Returns
815         -------
816         self : object
817             Fitted transformer.
818         """
819         self._validate_params()
820 
821         X = self._validate_data(
822             X,
823             reset=True,
824             accept_sparse=False,
825             ensure_min_samples=2,
826             ensure_2d=True,
827         )
828         if sample_weight is not None:
829             sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)
830 
831         _, n_features = X.shape
832 
833         if isinstance(self.knots, str):
834             base_knots = self._get_base_knot_positions(
835                 X, n_knots=self.n_knots, knots=self.knots, sample_weight=sample_weight
836             )
837         else:
838             base_knots = check_array(self.knots, dtype=np.float64)
839             if base_knots.shape[0] < 2:
840                 raise ValueError("Number of knots, knots.shape[0], must be >= 2.")
841             elif base_knots.shape[1] != n_features:
842                 raise ValueError("knots.shape[1] == n_features is violated.")
843             elif not np.all(np.diff(base_knots, axis=0) > 0):
844                 raise ValueError("knots must be sorted without duplicates.")
845 
846         # number of knots for base interval
847         n_knots = base_knots.shape[0]
848 
849         if self.extrapolation == "periodic" and n_knots <= self.degree:
850             raise ValueError(
851                 "Periodic splines require degree < n_knots. Got n_knots="
852                 f"{n_knots} and degree={self.degree}."
853             )
854 
855         # number of splines basis functions
856         if self.extrapolation != "periodic":
857             n_splines = n_knots + self.degree - 1
858         else:
859             # periodic splines have self.degree less degrees of freedom
860             n_splines = n_knots - 1
861 
862         degree = self.degree
863         n_out = n_features * n_splines
864         # We have to add degree number of knots below, and degree number knots
865         # above the base knots in order to make the spline basis complete.
866         if self.extrapolation == "periodic":
867             # For periodic splines the spacing of the first / last degree knots
868             # needs to be a continuation of the spacing of the last / first
869             # base knots.
870             period = base_knots[-1] - base_knots[0]
871             knots = np.r_[
872                 base_knots[-(degree + 1) : -1] - period,
873                 base_knots,
874                 base_knots[1 : (degree + 1)] + period,
875             ]
876 
877         else:
878             # Eilers & Marx in "Flexible smoothing with B-splines and
879             # penalties" https://doi.org/10.1214/ss/1038425655 advice
880             # against repeating first and last knot several times, which
881             # would have inferior behaviour at boundaries if combined with
882             # a penalty (hence P-Spline). We follow this advice even if our
883             # splines are unpenalized. Meaning we do not:
884             # knots = np.r_[
885             #     np.tile(base_knots.min(axis=0), reps=[degree, 1]),
886             #     base_knots,
887             #     np.tile(base_knots.max(axis=0), reps=[degree, 1])
888             # ]
889             # Instead, we reuse the distance of the 2 fist/last knots.
890             dist_min = base_knots[1] - base_knots[0]
891             dist_max = base_knots[-1] - base_knots[-2]
892 
893             knots = np.r_[
894                 np.linspace(
895                     base_knots[0] - degree * dist_min,
896                     base_knots[0] - dist_min,
897                     num=degree,
898                 ),
899                 base_knots,
900                 np.linspace(
901                     base_knots[-1] + dist_max,
902                     base_knots[-1] + degree * dist_max,
903                     num=degree,
904                 ),
905             ]
906 
907         # With a diagonal coefficient matrix, we get back the spline basis
908         # elements, i.e. the design matrix of the spline.
909         # Note, BSpline appreciates C-contiguous float64 arrays as c=coef.
910         coef = np.eye(n_splines, dtype=np.float64)
911         if self.extrapolation == "periodic":
912             coef = np.concatenate((coef, coef[:degree, :]))
913 
914         extrapolate = self.extrapolation in ["periodic", "continue"]
915 
916         bsplines = [
917             BSpline.construct_fast(
918                 knots[:, i], coef, self.degree, extrapolate=extrapolate
919             )
920             for i in range(n_features)
921         ]
922         self.bsplines_ = bsplines
923 
924         self.n_features_out_ = n_out - n_features * (1 - self.include_bias)
925         return self
926 
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]
1051 
1052     def _more_tags(self):
1053         return {
1054             "_xfail_checks": {
1055                 "check_estimators_pickle": (
1056                     "Current Scipy implementation of _bsplines does not"
1057                     "support const memory views."
1058                 ),
1059             }
1060         }

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>__init__</method>
<code>
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order

</code><intended_behavior>In the `__init__` method of the `SplineTransformer` class, a new parameter named `sparse` with default value `False` should be added. This parameter would control whether the output of the `transform` method is dense (the default, as per current behavior) or sparse. The documentation for `__init__` should be updated to describe this new parameter, specifying that setting it to `True` requires `scipy>=1.8` for sparse output support.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>None</method>
<code>
579 class SplineTransformer(TransformerMixin, BaseEstimator):
580     """Generate univariate B-spline bases for features.
581 
582     Generate a new feature matrix consisting of
583     `n_splines=n_knots + degree - 1` (`n_knots - 1` for
584     `extrapolation="periodic"`) spline basis functions
585     (B-splines) of polynomial order=`degree` for each feature.
586 
587     Read more in the :ref:`User Guide <spline_transformer>`.
588 
589     .. versionadded:: 1.0
590 
591     Parameters
592     ----------
593     n_knots : int, default=5
594         Number of knots of the splines if `knots` equals one of
595         {'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`
596         is array-like.
597 
598     degree : int, default=3
599         The polynomial degree of the spline basis. Must be a non-negative
600         integer.
601 
602     knots : {'uniform', 'quantile'} or array-like of shape \
603         (n_knots, n_features), default='uniform'
604         Set knot positions such that first knot <= features <= last knot.
605 
606         - If 'uniform', `n_knots` number of knots are distributed uniformly
607           from min to max values of the features.
608         - If 'quantile', they are distributed uniformly along the quantiles of
609           the features.
610         - If an array-like is given, it directly specifies the sorted knot
611           positions including the boundary knots. Note that, internally,
612           `degree` number of knots are added before the first knot, the same
613           after the last knot.
614 
615     extrapolation : {'error', 'constant', 'linear', 'continue', 'periodic'}, \
616         default='constant'
617         If 'error', values outside the min and max values of the training
618         features raises a `ValueError`. If 'constant', the value of the
619         splines at minimum and maximum value of the features is used as
620         constant extrapolation. If 'linear', a linear extrapolation is used.
621         If 'continue', the splines are extrapolated as is, i.e. option
622         `extrapolate=True` in :class:`scipy.interpolate.BSpline`. If
623         'periodic', periodic splines with a periodicity equal to the distance
624         between the first and last knot are used. Periodic splines enforce
625         equal function values and derivatives at the first and last knot.
626         For example, this makes it possible to avoid introducing an arbitrary
627         jump between Dec 31st and Jan 1st in spline features derived from a
628         naturally periodic "day-of-year" input feature. In this case it is
629         recommended to manually set the knot values to control the period.
630 
631     include_bias : bool, default=True
632         If False, then the last spline element inside the data range
633         of a feature is dropped. As B-splines sum to one over the spline basis
634         functions for each data point, they implicitly include a bias term,
635         i.e. a column of ones. It acts as an intercept term in a linear models.
636 
637     order : {'C', 'F'}, default='C'
638         Order of output array. 'F' order is faster to compute, but may slow
639         down subsequent estimators.
640 
641     Attributes
642     ----------
643     bsplines_ : list of shape (n_features,)
644         List of BSplines objects, one for each feature.
645 
646     n_features_in_ : int
647         The total number of input features.
648 
649     feature_names_in_ : ndarray of shape (`n_features_in_`,)
650         Names of features seen during :term:`fit`. Defined only when `X`
651         has feature names that are all strings.
652 
653         .. versionadded:: 1.0
654 
655     n_features_out_ : int
656         The total number of output features, which is computed as
657         `n_features * n_splines`, where `n_splines` is
658         the number of bases elements of the B-splines,
659         `n_knots + degree - 1` for non-periodic splines and
660         `n_knots - 1` for periodic ones.
661         If `include_bias=False`, then it is only
662         `n_features * (n_splines - 1)`.
663 
664     See Also
665     --------
666     KBinsDiscretizer : Transformer that bins continuous data into intervals.
667 
668     PolynomialFeatures : Transformer that generates polynomial and interaction
669         features.
670 
671     Notes
672     -----
673     High degrees and a high number of knots can cause overfitting.
674 
675     See :ref:`examples/linear_model/plot_polynomial_interpolation.py
676     <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.
677 
678     Examples
679     --------
680     >>> import numpy as np
681     >>> from sklearn.preprocessing import SplineTransformer
682     >>> X = np.arange(6).reshape(6, 1)
683     >>> spline = SplineTransformer(degree=2, n_knots=3)
684     >>> spline.fit_transform(X)
685     array([[0.5 , 0.5 , 0.  , 0.  ],
686            [0.18, 0.74, 0.08, 0.  ],
687            [0.02, 0.66, 0.32, 0.  ],
688            [0.  , 0.32, 0.66, 0.02],
689            [0.  , 0.08, 0.74, 0.18],
690            [0.  , 0.  , 0.5 , 0.5 ]])
691     """
692 
693     _parameter_constraints: dict = {
694         "n_knots": [Interval(Integral, 2, None, closed="left")],
695         "degree": [Interval(Integral, 0, None, closed="left")],
696         "knots": [StrOptions({"uniform", "quantile"}), "array-like"],
697         "extrapolation": [
698             StrOptions({"error", "constant", "linear", "continue", "periodic"})
699         ],
700         "include_bias": ["boolean"],
701         "order": [StrOptions({"C", "F"})],
702     }
703 
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order
720 
721     @staticmethod
722     def _get_base_knot_positions(X, n_knots=10, knots="uniform", sample_weight=None):
723         """Calculate base knot positions.
724 
725         Base knots such that first knot <= feature <= last knot. For the
726         B-spline construction with scipy.interpolate.BSpline, 2*degree knots
727         beyond the base interval are added.
728 
729         Returns
730         -------
731         knots : ndarray of shape (n_knots, n_features), dtype=np.float64
732             Knot positions (points) of base interval.
733         """
734         if knots == "quantile":
735             percentiles = 100 * np.linspace(
736                 start=0, stop=1, num=n_knots, dtype=np.float64
737             )
738 
739             if sample_weight is None:
740                 knots = np.percentile(X, percentiles, axis=0)
741             else:
742                 knots = np.array(
743                     [
744                         _weighted_percentile(X, sample_weight, percentile)
745                         for percentile in percentiles
746                     ]
747                 )
748 
749         else:
750             # knots == 'uniform':
751             # Note that the variable `knots` has already been validated and
752             # `else` is therefore safe.
753             # Disregard observations with zero weight.
754             mask = slice(None, None, 1) if sample_weight is None else sample_weight > 0
755             x_min = np.amin(X[mask], axis=0)
756             x_max = np.amax(X[mask], axis=0)
757 
758             knots = np.linspace(
759                 start=x_min,
760                 stop=x_max,
761                 num=n_knots,
762                 endpoint=True,
763                 dtype=np.float64,
764             )
765 
766         return knots
767 
768     def get_feature_names_out(self, input_features=None):
769         """Get output feature names for transformation.
770 
771         Parameters
772         ----------
773         input_features : array-like of str or None, default=None
774             Input features.
775 
776             - If `input_features` is `None`, then `feature_names_in_` is
777               used as feature names in. If `feature_names_in_` is not defined,
778               then the following input feature names are generated:
779               `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
780             - If `input_features` is an array-like, then `input_features` must
781               match `feature_names_in_` if `feature_names_in_` is defined.
782 
783         Returns
784         -------
785         feature_names_out : ndarray of str objects
786             Transformed feature names.
787         """
788         check_is_fitted(self, "n_features_in_")
789         n_splines = self.bsplines_[0].c.shape[1]
790 
791         input_features = _check_feature_names_in(self, input_features)
792         feature_names = []
793         for i in range(self.n_features_in_):
794             for j in range(n_splines - 1 + self.include_bias):
795                 feature_names.append(f"{input_features[i]}_sp_{j}")
796         return np.asarray(feature_names, dtype=object)
797 
798     def fit(self, X, y=None, sample_weight=None):
799         """Compute knot positions of splines.
800 
801         Parameters
802         ----------
803         X : array-like of shape (n_samples, n_features)
804             The data.
805 
806         y : None
807             Ignored.
808 
809         sample_weight : array-like of shape (n_samples,), default = None
810             Individual weights for each sample. Used to calculate quantiles if
811             `knots="quantile"`. For `knots="uniform"`, zero weighted
812             observations are ignored for finding the min and max of `X`.
813 
814         Returns
815         -------
816         self : object
817             Fitted transformer.
818         """
819         self._validate_params()
820 
821         X = self._validate_data(
822             X,
823             reset=True,
824             accept_sparse=False,
825             ensure_min_samples=2,
826             ensure_2d=True,
827         )
828         if sample_weight is not None:
829             sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)
830 
831         _, n_features = X.shape
832 
833         if isinstance(self.knots, str):
834             base_knots = self._get_base_knot_positions(
835                 X, n_knots=self.n_knots, knots=self.knots, sample_weight=sample_weight
836             )
837         else:
838             base_knots = check_array(self.knots, dtype=np.float64)
839             if base_knots.shape[0] < 2:
840                 raise ValueError("Number of knots, knots.shape[0], must be >= 2.")
841             elif base_knots.shape[1] != n_features:
842                 raise ValueError("knots.shape[1] == n_features is violated.")
843             elif not np.all(np.diff(base_knots, axis=0) > 0):
844                 raise ValueError("knots must be sorted without duplicates.")
845 
846         # number of knots for base interval
847         n_knots = base_knots.shape[0]
848 
849         if self.extrapolation == "periodic" and n_knots <= self.degree:
850             raise ValueError(
851                 "Periodic splines require degree < n_knots. Got n_knots="
852                 f"{n_knots} and degree={self.degree}."
853             )
854 
855         # number of splines basis functions
856         if self.extrapolation != "periodic":
857             n_splines = n_knots + self.degree - 1
858         else:
859             # periodic splines have self.degree less degrees of freedom
860             n_splines = n_knots - 1
861 
862         degree = self.degree
863         n_out = n_features * n_splines
864         # We have to add degree number of knots below, and degree number knots
865         # above the base knots in order to make the spline basis complete.
866         if self.extrapolation == "periodic":
867             # For periodic splines the spacing of the first / last degree knots
868             # needs to be a continuation of the spacing of the last / first
869             # base knots.
870             period = base_knots[-1] - base_knots[0]
871             knots = np.r_[
872                 base_knots[-(degree + 1) : -1] - period,
873                 base_knots,
874                 base_knots[1 : (degree + 1)] + period,
875             ]
876 
877         else:
878             # Eilers & Marx in "Flexible smoothing with B-splines and
879             # penalties" https://doi.org/10.1214/ss/1038425655 advice
880             # against repeating first and last knot several times, which
881             # would have inferior behaviour at boundaries if combined with
882             # a penalty (hence P-Spline). We follow this advice even if our
883             # splines are unpenalized. Meaning we do not:
884             # knots = np.r_[
885             #     np.tile(base_knots.min(axis=0), reps=[degree, 1]),
886             #     base_knots,
887             #     np.tile(base_knots.max(axis=0), reps=[degree, 1])
888             # ]
889             # Instead, we reuse the distance of the 2 fist/last knots.
890             dist_min = base_knots[1] - base_knots[0]
891             dist_max = base_knots[-1] - base_knots[-2]
892 
893             knots = np.r_[
894                 np.linspace(
895                     base_knots[0] - degree * dist_min,
896                     base_knots[0] - dist_min,
897                     num=degree,
898                 ),
899                 base_knots,
900                 np.linspace(
901                     base_knots[-1] + dist_max,
902                     base_knots[-1] + degree * dist_max,
903                     num=degree,
904                 ),
905             ]
906 
907         # With a diagonal coefficient matrix, we get back the spline basis
908         # elements, i.e. the design matrix of the spline.
909         # Note, BSpline appreciates C-contiguous float64 arrays as c=coef.
910         coef = np.eye(n_splines, dtype=np.float64)
911         if self.extrapolation == "periodic":
912             coef = np.concatenate((coef, coef[:degree, :]))
913 
914         extrapolate = self.extrapolation in ["periodic", "continue"]
915 
916         bsplines = [
917             BSpline.construct_fast(
918                 knots[:, i], coef, self.degree, extrapolate=extrapolate
919             )
920             for i in range(n_features)
921         ]
922         self.bsplines_ = bsplines
923 
924         self.n_features_out_ = n_out - n_features * (1 - self.include_bias)
925         return self
926 
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]
1051 
1052     def _more_tags(self):
1053         return {
1054             "_xfail_checks": {
1055                 "check_estimators_pickle": (
1056                     "Current Scipy implementation of _bsplines does not"
1057                     "support const memory views."
1058                 ),
1059             }
1060         }

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-16 00:02:16.369 | INFO     | Search completed. Bug locations: [<file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>transform</method>
<code>
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]

</code><intended_behavior>The `transform` method inside the `SplineTransformer` class needs to be enhanced to support returning a sparse matrix based on a new parameter, say `sparse_output`, with a default value of `False` to ensure backward compatibility. This modification would involve utilizing the `design_matrix` functionality from `scipy` when `sparse=True`, converting the dense output into a sparse matrix format efficiently. The method must check the version of `scipy` to ensure compatibility and fall back to the previous behavior if the version is less than 1.8. Additionally, clear documentation should be provided regarding the usage of the new `sparse` parameter, including notes on `scipy` version requirements.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>None</method>
<code>
579 class SplineTransformer(TransformerMixin, BaseEstimator):
580     """Generate univariate B-spline bases for features.
581 
582     Generate a new feature matrix consisting of
583     `n_splines=n_knots + degree - 1` (`n_knots - 1` for
584     `extrapolation="periodic"`) spline basis functions
585     (B-splines) of polynomial order=`degree` for each feature.
586 
587     Read more in the :ref:`User Guide <spline_transformer>`.
588 
589     .. versionadded:: 1.0
590 
591     Parameters
592     ----------
593     n_knots : int, default=5
594         Number of knots of the splines if `knots` equals one of
595         {'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`
596         is array-like.
597 
598     degree : int, default=3
599         The polynomial degree of the spline basis. Must be a non-negative
600         integer.
601 
602     knots : {'uniform', 'quantile'} or array-like of shape \
603         (n_knots, n_features), default='uniform'
604         Set knot positions such that first knot <= features <= last knot.
605 
606         - If 'uniform', `n_knots` number of knots are distributed uniformly
607           from min to max values of the features.
608         - If 'quantile', they are distributed uniformly along the quantiles of
609           the features.
610         - If an array-like is given, it directly specifies the sorted knot
611           positions including the boundary knots. Note that, internally,
612           `degree` number of knots are added before the first knot, the same
613           after the last knot.
614 
615     extrapolation : {'error', 'constant', 'linear', 'continue', 'periodic'}, \
616         default='constant'
617         If 'error', values outside the min and max values of the training
618         features raises a `ValueError`. If 'constant', the value of the
619         splines at minimum and maximum value of the features is used as
620         constant extrapolation. If 'linear', a linear extrapolation is used.
621         If 'continue', the splines are extrapolated as is, i.e. option
622         `extrapolate=True` in :class:`scipy.interpolate.BSpline`. If
623         'periodic', periodic splines with a periodicity equal to the distance
624         between the first and last knot are used. Periodic splines enforce
625         equal function values and derivatives at the first and last knot.
626         For example, this makes it possible to avoid introducing an arbitrary
627         jump between Dec 31st and Jan 1st in spline features derived from a
628         naturally periodic "day-of-year" input feature. In this case it is
629         recommended to manually set the knot values to control the period.
630 
631     include_bias : bool, default=True
632         If False, then the last spline element inside the data range
633         of a feature is dropped. As B-splines sum to one over the spline basis
634         functions for each data point, they implicitly include a bias term,
635         i.e. a column of ones. It acts as an intercept term in a linear models.
636 
637     order : {'C', 'F'}, default='C'
638         Order of output array. 'F' order is faster to compute, but may slow
639         down subsequent estimators.
640 
641     Attributes
642     ----------
643     bsplines_ : list of shape (n_features,)
644         List of BSplines objects, one for each feature.
645 
646     n_features_in_ : int
647         The total number of input features.
648 
649     feature_names_in_ : ndarray of shape (`n_features_in_`,)
650         Names of features seen during :term:`fit`. Defined only when `X`
651         has feature names that are all strings.
652 
653         .. versionadded:: 1.0
654 
655     n_features_out_ : int
656         The total number of output features, which is computed as
657         `n_features * n_splines`, where `n_splines` is
658         the number of bases elements of the B-splines,
659         `n_knots + degree - 1` for non-periodic splines and
660         `n_knots - 1` for periodic ones.
661         If `include_bias=False`, then it is only
662         `n_features * (n_splines - 1)`.
663 
664     See Also
665     --------
666     KBinsDiscretizer : Transformer that bins continuous data into intervals.
667 
668     PolynomialFeatures : Transformer that generates polynomial and interaction
669         features.
670 
671     Notes
672     -----
673     High degrees and a high number of knots can cause overfitting.
674 
675     See :ref:`examples/linear_model/plot_polynomial_interpolation.py
676     <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.
677 
678     Examples
679     --------
680     >>> import numpy as np
681     >>> from sklearn.preprocessing import SplineTransformer
682     >>> X = np.arange(6).reshape(6, 1)
683     >>> spline = SplineTransformer(degree=2, n_knots=3)
684     >>> spline.fit_transform(X)
685     array([[0.5 , 0.5 , 0.  , 0.  ],
686            [0.18, 0.74, 0.08, 0.  ],
687            [0.02, 0.66, 0.32, 0.  ],
688            [0.  , 0.32, 0.66, 0.02],
689            [0.  , 0.08, 0.74, 0.18],
690            [0.  , 0.  , 0.5 , 0.5 ]])
691     """
692 
693     _parameter_constraints: dict = {
694         "n_knots": [Interval(Integral, 2, None, closed="left")],
695         "degree": [Interval(Integral, 0, None, closed="left")],
696         "knots": [StrOptions({"uniform", "quantile"}), "array-like"],
697         "extrapolation": [
698             StrOptions({"error", "constant", "linear", "continue", "periodic"})
699         ],
700         "include_bias": ["boolean"],
701         "order": [StrOptions({"C", "F"})],
702     }
703 
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order
720 
721     @staticmethod
722     def _get_base_knot_positions(X, n_knots=10, knots="uniform", sample_weight=None):
723         """Calculate base knot positions.
724 
725         Base knots such that first knot <= feature <= last knot. For the
726         B-spline construction with scipy.interpolate.BSpline, 2*degree knots
727         beyond the base interval are added.
728 
729         Returns
730         -------
731         knots : ndarray of shape (n_knots, n_features), dtype=np.float64
732             Knot positions (points) of base interval.
733         """
734         if knots == "quantile":
735             percentiles = 100 * np.linspace(
736                 start=0, stop=1, num=n_knots, dtype=np.float64
737             )
738 
739             if sample_weight is None:
740                 knots = np.percentile(X, percentiles, axis=0)
741             else:
742                 knots = np.array(
743                     [
744                         _weighted_percentile(X, sample_weight, percentile)
745                         for percentile in percentiles
746                     ]
747                 )
748 
749         else:
750             # knots == 'uniform':
751             # Note that the variable `knots` has already been validated and
752             # `else` is therefore safe.
753             # Disregard observations with zero weight.
754             mask = slice(None, None, 1) if sample_weight is None else sample_weight > 0
755             x_min = np.amin(X[mask], axis=0)
756             x_max = np.amax(X[mask], axis=0)
757 
758             knots = np.linspace(
759                 start=x_min,
760                 stop=x_max,
761                 num=n_knots,
762                 endpoint=True,
763                 dtype=np.float64,
764             )
765 
766         return knots
767 
768     def get_feature_names_out(self, input_features=None):
769         """Get output feature names for transformation.
770 
771         Parameters
772         ----------
773         input_features : array-like of str or None, default=None
774             Input features.
775 
776             - If `input_features` is `None`, then `feature_names_in_` is
777               used as feature names in. If `feature_names_in_` is not defined,
778               then the following input feature names are generated:
779               `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
780             - If `input_features` is an array-like, then `input_features` must
781               match `feature_names_in_` if `feature_names_in_` is defined.
782 
783         Returns
784         -------
785         feature_names_out : ndarray of str objects
786             Transformed feature names.
787         """
788         check_is_fitted(self, "n_features_in_")
789         n_splines = self.bsplines_[0].c.shape[1]
790 
791         input_features = _check_feature_names_in(self, input_features)
792         feature_names = []
793         for i in range(self.n_features_in_):
794             for j in range(n_splines - 1 + self.include_bias):
795                 feature_names.append(f"{input_features[i]}_sp_{j}")
796         return np.asarray(feature_names, dtype=object)
797 
798     def fit(self, X, y=None, sample_weight=None):
799         """Compute knot positions of splines.
800 
801         Parameters
802         ----------
803         X : array-like of shape (n_samples, n_features)
804             The data.
805 
806         y : None
807             Ignored.
808 
809         sample_weight : array-like of shape (n_samples,), default = None
810             Individual weights for each sample. Used to calculate quantiles if
811             `knots="quantile"`. For `knots="uniform"`, zero weighted
812             observations are ignored for finding the min and max of `X`.
813 
814         Returns
815         -------
816         self : object
817             Fitted transformer.
818         """
819         self._validate_params()
820 
821         X = self._validate_data(
822             X,
823             reset=True,
824             accept_sparse=False,
825             ensure_min_samples=2,
826             ensure_2d=True,
827         )
828         if sample_weight is not None:
829             sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)
830 
831         _, n_features = X.shape
832 
833         if isinstance(self.knots, str):
834             base_knots = self._get_base_knot_positions(
835                 X, n_knots=self.n_knots, knots=self.knots, sample_weight=sample_weight
836             )
837         else:
838             base_knots = check_array(self.knots, dtype=np.float64)
839             if base_knots.shape[0] < 2:
840                 raise ValueError("Number of knots, knots.shape[0], must be >= 2.")
841             elif base_knots.shape[1] != n_features:
842                 raise ValueError("knots.shape[1] == n_features is violated.")
843             elif not np.all(np.diff(base_knots, axis=0) > 0):
844                 raise ValueError("knots must be sorted without duplicates.")
845 
846         # number of knots for base interval
847         n_knots = base_knots.shape[0]
848 
849         if self.extrapolation == "periodic" and n_knots <= self.degree:
850             raise ValueError(
851                 "Periodic splines require degree < n_knots. Got n_knots="
852                 f"{n_knots} and degree={self.degree}."
853             )
854 
855         # number of splines basis functions
856         if self.extrapolation != "periodic":
857             n_splines = n_knots + self.degree - 1
858         else:
859             # periodic splines have self.degree less degrees of freedom
860             n_splines = n_knots - 1
861 
862         degree = self.degree
863         n_out = n_features * n_splines
864         # We have to add degree number of knots below, and degree number knots
865         # above the base knots in order to make the spline basis complete.
866         if self.extrapolation == "periodic":
867             # For periodic splines the spacing of the first / last degree knots
868             # needs to be a continuation of the spacing of the last / first
869             # base knots.
870             period = base_knots[-1] - base_knots[0]
871             knots = np.r_[
872                 base_knots[-(degree + 1) : -1] - period,
873                 base_knots,
874                 base_knots[1 : (degree + 1)] + period,
875             ]
876 
877         else:
878             # Eilers & Marx in "Flexible smoothing with B-splines and
879             # penalties" https://doi.org/10.1214/ss/1038425655 advice
880             # against repeating first and last knot several times, which
881             # would have inferior behaviour at boundaries if combined with
882             # a penalty (hence P-Spline). We follow this advice even if our
883             # splines are unpenalized. Meaning we do not:
884             # knots = np.r_[
885             #     np.tile(base_knots.min(axis=0), reps=[degree, 1]),
886             #     base_knots,
887             #     np.tile(base_knots.max(axis=0), reps=[degree, 1])
888             # ]
889             # Instead, we reuse the distance of the 2 fist/last knots.
890             dist_min = base_knots[1] - base_knots[0]
891             dist_max = base_knots[-1] - base_knots[-2]
892 
893             knots = np.r_[
894                 np.linspace(
895                     base_knots[0] - degree * dist_min,
896                     base_knots[0] - dist_min,
897                     num=degree,
898                 ),
899                 base_knots,
900                 np.linspace(
901                     base_knots[-1] + dist_max,
902                     base_knots[-1] + degree * dist_max,
903                     num=degree,
904                 ),
905             ]
906 
907         # With a diagonal coefficient matrix, we get back the spline basis
908         # elements, i.e. the design matrix of the spline.
909         # Note, BSpline appreciates C-contiguous float64 arrays as c=coef.
910         coef = np.eye(n_splines, dtype=np.float64)
911         if self.extrapolation == "periodic":
912             coef = np.concatenate((coef, coef[:degree, :]))
913 
914         extrapolate = self.extrapolation in ["periodic", "continue"]
915 
916         bsplines = [
917             BSpline.construct_fast(
918                 knots[:, i], coef, self.degree, extrapolate=extrapolate
919             )
920             for i in range(n_features)
921         ]
922         self.bsplines_ = bsplines
923 
924         self.n_features_out_ = n_out - n_features * (1 - self.include_bias)
925         return self
926 
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]
1051 
1052     def _more_tags(self):
1053         return {
1054             "_xfail_checks": {
1055                 "check_estimators_pickle": (
1056                     "Current Scipy implementation of _bsplines does not"
1057                     "support const memory views."
1058                 ),
1059             }
1060         }

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>__init__</method>
<code>
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order

</code><intended_behavior>In the `__init__` method of the `SplineTransformer` class, a new parameter named `sparse` with default value `False` should be added. This parameter would control whether the output of the `transform` method is dense (the default, as per current behavior) or sparse. The documentation for `__init__` should be updated to describe this new parameter, specifying that setting it to `True` requires `scipy>=1.8` for sparse output support.</intended_behavior>, <file>sklearn/preprocessing/_polynomial.py</file>
<class>SplineTransformer</class>
<method>None</method>
<code>
579 class SplineTransformer(TransformerMixin, BaseEstimator):
580     """Generate univariate B-spline bases for features.
581 
582     Generate a new feature matrix consisting of
583     `n_splines=n_knots + degree - 1` (`n_knots - 1` for
584     `extrapolation="periodic"`) spline basis functions
585     (B-splines) of polynomial order=`degree` for each feature.
586 
587     Read more in the :ref:`User Guide <spline_transformer>`.
588 
589     .. versionadded:: 1.0
590 
591     Parameters
592     ----------
593     n_knots : int, default=5
594         Number of knots of the splines if `knots` equals one of
595         {'uniform', 'quantile'}. Must be larger or equal 2. Ignored if `knots`
596         is array-like.
597 
598     degree : int, default=3
599         The polynomial degree of the spline basis. Must be a non-negative
600         integer.
601 
602     knots : {'uniform', 'quantile'} or array-like of shape \
603         (n_knots, n_features), default='uniform'
604         Set knot positions such that first knot <= features <= last knot.
605 
606         - If 'uniform', `n_knots` number of knots are distributed uniformly
607           from min to max values of the features.
608         - If 'quantile', they are distributed uniformly along the quantiles of
609           the features.
610         - If an array-like is given, it directly specifies the sorted knot
611           positions including the boundary knots. Note that, internally,
612           `degree` number of knots are added before the first knot, the same
613           after the last knot.
614 
615     extrapolation : {'error', 'constant', 'linear', 'continue', 'periodic'}, \
616         default='constant'
617         If 'error', values outside the min and max values of the training
618         features raises a `ValueError`. If 'constant', the value of the
619         splines at minimum and maximum value of the features is used as
620         constant extrapolation. If 'linear', a linear extrapolation is used.
621         If 'continue', the splines are extrapolated as is, i.e. option
622         `extrapolate=True` in :class:`scipy.interpolate.BSpline`. If
623         'periodic', periodic splines with a periodicity equal to the distance
624         between the first and last knot are used. Periodic splines enforce
625         equal function values and derivatives at the first and last knot.
626         For example, this makes it possible to avoid introducing an arbitrary
627         jump between Dec 31st and Jan 1st in spline features derived from a
628         naturally periodic "day-of-year" input feature. In this case it is
629         recommended to manually set the knot values to control the period.
630 
631     include_bias : bool, default=True
632         If False, then the last spline element inside the data range
633         of a feature is dropped. As B-splines sum to one over the spline basis
634         functions for each data point, they implicitly include a bias term,
635         i.e. a column of ones. It acts as an intercept term in a linear models.
636 
637     order : {'C', 'F'}, default='C'
638         Order of output array. 'F' order is faster to compute, but may slow
639         down subsequent estimators.
640 
641     Attributes
642     ----------
643     bsplines_ : list of shape (n_features,)
644         List of BSplines objects, one for each feature.
645 
646     n_features_in_ : int
647         The total number of input features.
648 
649     feature_names_in_ : ndarray of shape (`n_features_in_`,)
650         Names of features seen during :term:`fit`. Defined only when `X`
651         has feature names that are all strings.
652 
653         .. versionadded:: 1.0
654 
655     n_features_out_ : int
656         The total number of output features, which is computed as
657         `n_features * n_splines`, where `n_splines` is
658         the number of bases elements of the B-splines,
659         `n_knots + degree - 1` for non-periodic splines and
660         `n_knots - 1` for periodic ones.
661         If `include_bias=False`, then it is only
662         `n_features * (n_splines - 1)`.
663 
664     See Also
665     --------
666     KBinsDiscretizer : Transformer that bins continuous data into intervals.
667 
668     PolynomialFeatures : Transformer that generates polynomial and interaction
669         features.
670 
671     Notes
672     -----
673     High degrees and a high number of knots can cause overfitting.
674 
675     See :ref:`examples/linear_model/plot_polynomial_interpolation.py
676     <sphx_glr_auto_examples_linear_model_plot_polynomial_interpolation.py>`.
677 
678     Examples
679     --------
680     >>> import numpy as np
681     >>> from sklearn.preprocessing import SplineTransformer
682     >>> X = np.arange(6).reshape(6, 1)
683     >>> spline = SplineTransformer(degree=2, n_knots=3)
684     >>> spline.fit_transform(X)
685     array([[0.5 , 0.5 , 0.  , 0.  ],
686            [0.18, 0.74, 0.08, 0.  ],
687            [0.02, 0.66, 0.32, 0.  ],
688            [0.  , 0.32, 0.66, 0.02],
689            [0.  , 0.08, 0.74, 0.18],
690            [0.  , 0.  , 0.5 , 0.5 ]])
691     """
692 
693     _parameter_constraints: dict = {
694         "n_knots": [Interval(Integral, 2, None, closed="left")],
695         "degree": [Interval(Integral, 0, None, closed="left")],
696         "knots": [StrOptions({"uniform", "quantile"}), "array-like"],
697         "extrapolation": [
698             StrOptions({"error", "constant", "linear", "continue", "periodic"})
699         ],
700         "include_bias": ["boolean"],
701         "order": [StrOptions({"C", "F"})],
702     }
703 
704     def __init__(
705         self,
706         n_knots=5,
707         degree=3,
708         *,
709         knots="uniform",
710         extrapolation="constant",
711         include_bias=True,
712         order="C",
713     ):
714         self.n_knots = n_knots
715         self.degree = degree
716         self.knots = knots
717         self.extrapolation = extrapolation
718         self.include_bias = include_bias
719         self.order = order
720 
721     @staticmethod
722     def _get_base_knot_positions(X, n_knots=10, knots="uniform", sample_weight=None):
723         """Calculate base knot positions.
724 
725         Base knots such that first knot <= feature <= last knot. For the
726         B-spline construction with scipy.interpolate.BSpline, 2*degree knots
727         beyond the base interval are added.
728 
729         Returns
730         -------
731         knots : ndarray of shape (n_knots, n_features), dtype=np.float64
732             Knot positions (points) of base interval.
733         """
734         if knots == "quantile":
735             percentiles = 100 * np.linspace(
736                 start=0, stop=1, num=n_knots, dtype=np.float64
737             )
738 
739             if sample_weight is None:
740                 knots = np.percentile(X, percentiles, axis=0)
741             else:
742                 knots = np.array(
743                     [
744                         _weighted_percentile(X, sample_weight, percentile)
745                         for percentile in percentiles
746                     ]
747                 )
748 
749         else:
750             # knots == 'uniform':
751             # Note that the variable `knots` has already been validated and
752             # `else` is therefore safe.
753             # Disregard observations with zero weight.
754             mask = slice(None, None, 1) if sample_weight is None else sample_weight > 0
755             x_min = np.amin(X[mask], axis=0)
756             x_max = np.amax(X[mask], axis=0)
757 
758             knots = np.linspace(
759                 start=x_min,
760                 stop=x_max,
761                 num=n_knots,
762                 endpoint=True,
763                 dtype=np.float64,
764             )
765 
766         return knots
767 
768     def get_feature_names_out(self, input_features=None):
769         """Get output feature names for transformation.
770 
771         Parameters
772         ----------
773         input_features : array-like of str or None, default=None
774             Input features.
775 
776             - If `input_features` is `None`, then `feature_names_in_` is
777               used as feature names in. If `feature_names_in_` is not defined,
778               then the following input feature names are generated:
779               `["x0", "x1", ..., "x(n_features_in_ - 1)"]`.
780             - If `input_features` is an array-like, then `input_features` must
781               match `feature_names_in_` if `feature_names_in_` is defined.
782 
783         Returns
784         -------
785         feature_names_out : ndarray of str objects
786             Transformed feature names.
787         """
788         check_is_fitted(self, "n_features_in_")
789         n_splines = self.bsplines_[0].c.shape[1]
790 
791         input_features = _check_feature_names_in(self, input_features)
792         feature_names = []
793         for i in range(self.n_features_in_):
794             for j in range(n_splines - 1 + self.include_bias):
795                 feature_names.append(f"{input_features[i]}_sp_{j}")
796         return np.asarray(feature_names, dtype=object)
797 
798     def fit(self, X, y=None, sample_weight=None):
799         """Compute knot positions of splines.
800 
801         Parameters
802         ----------
803         X : array-like of shape (n_samples, n_features)
804             The data.
805 
806         y : None
807             Ignored.
808 
809         sample_weight : array-like of shape (n_samples,), default = None
810             Individual weights for each sample. Used to calculate quantiles if
811             `knots="quantile"`. For `knots="uniform"`, zero weighted
812             observations are ignored for finding the min and max of `X`.
813 
814         Returns
815         -------
816         self : object
817             Fitted transformer.
818         """
819         self._validate_params()
820 
821         X = self._validate_data(
822             X,
823             reset=True,
824             accept_sparse=False,
825             ensure_min_samples=2,
826             ensure_2d=True,
827         )
828         if sample_weight is not None:
829             sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)
830 
831         _, n_features = X.shape
832 
833         if isinstance(self.knots, str):
834             base_knots = self._get_base_knot_positions(
835                 X, n_knots=self.n_knots, knots=self.knots, sample_weight=sample_weight
836             )
837         else:
838             base_knots = check_array(self.knots, dtype=np.float64)
839             if base_knots.shape[0] < 2:
840                 raise ValueError("Number of knots, knots.shape[0], must be >= 2.")
841             elif base_knots.shape[1] != n_features:
842                 raise ValueError("knots.shape[1] == n_features is violated.")
843             elif not np.all(np.diff(base_knots, axis=0) > 0):
844                 raise ValueError("knots must be sorted without duplicates.")
845 
846         # number of knots for base interval
847         n_knots = base_knots.shape[0]
848 
849         if self.extrapolation == "periodic" and n_knots <= self.degree:
850             raise ValueError(
851                 "Periodic splines require degree < n_knots. Got n_knots="
852                 f"{n_knots} and degree={self.degree}."
853             )
854 
855         # number of splines basis functions
856         if self.extrapolation != "periodic":
857             n_splines = n_knots + self.degree - 1
858         else:
859             # periodic splines have self.degree less degrees of freedom
860             n_splines = n_knots - 1
861 
862         degree = self.degree
863         n_out = n_features * n_splines
864         # We have to add degree number of knots below, and degree number knots
865         # above the base knots in order to make the spline basis complete.
866         if self.extrapolation == "periodic":
867             # For periodic splines the spacing of the first / last degree knots
868             # needs to be a continuation of the spacing of the last / first
869             # base knots.
870             period = base_knots[-1] - base_knots[0]
871             knots = np.r_[
872                 base_knots[-(degree + 1) : -1] - period,
873                 base_knots,
874                 base_knots[1 : (degree + 1)] + period,
875             ]
876 
877         else:
878             # Eilers & Marx in "Flexible smoothing with B-splines and
879             # penalties" https://doi.org/10.1214/ss/1038425655 advice
880             # against repeating first and last knot several times, which
881             # would have inferior behaviour at boundaries if combined with
882             # a penalty (hence P-Spline). We follow this advice even if our
883             # splines are unpenalized. Meaning we do not:
884             # knots = np.r_[
885             #     np.tile(base_knots.min(axis=0), reps=[degree, 1]),
886             #     base_knots,
887             #     np.tile(base_knots.max(axis=0), reps=[degree, 1])
888             # ]
889             # Instead, we reuse the distance of the 2 fist/last knots.
890             dist_min = base_knots[1] - base_knots[0]
891             dist_max = base_knots[-1] - base_knots[-2]
892 
893             knots = np.r_[
894                 np.linspace(
895                     base_knots[0] - degree * dist_min,
896                     base_knots[0] - dist_min,
897                     num=degree,
898                 ),
899                 base_knots,
900                 np.linspace(
901                     base_knots[-1] + dist_max,
902                     base_knots[-1] + degree * dist_max,
903                     num=degree,
904                 ),
905             ]
906 
907         # With a diagonal coefficient matrix, we get back the spline basis
908         # elements, i.e. the design matrix of the spline.
909         # Note, BSpline appreciates C-contiguous float64 arrays as c=coef.
910         coef = np.eye(n_splines, dtype=np.float64)
911         if self.extrapolation == "periodic":
912             coef = np.concatenate((coef, coef[:degree, :]))
913 
914         extrapolate = self.extrapolation in ["periodic", "continue"]
915 
916         bsplines = [
917             BSpline.construct_fast(
918                 knots[:, i], coef, self.degree, extrapolate=extrapolate
919             )
920             for i in range(n_features)
921         ]
922         self.bsplines_ = bsplines
923 
924         self.n_features_out_ = n_out - n_features * (1 - self.include_bias)
925         return self
926 
927     def transform(self, X):
928         """Transform each feature data to B-splines.
929 
930         Parameters
931         ----------
932         X : array-like of shape (n_samples, n_features)
933             The data to transform.
934 
935         Returns
936         -------
937         XBS : ndarray of shape (n_samples, n_features * n_splines)
938             The matrix of features, where n_splines is the number of bases
939             elements of the B-splines, n_knots + degree - 1.
940         """
941         check_is_fitted(self)
942 
943         X = self._validate_data(X, reset=False, accept_sparse=False, ensure_2d=True)
944 
945         n_samples, n_features = X.shape
946         n_splines = self.bsplines_[0].c.shape[1]
947         degree = self.degree
948 
949         # Note that scipy BSpline returns float64 arrays and converts input
950         # x=X[:, i] to c-contiguous float64.
951         n_out = self.n_features_out_ + n_features * (1 - self.include_bias)
952         if X.dtype in FLOAT_DTYPES:
953             dtype = X.dtype
954         else:
955             dtype = np.float64
956         XBS = np.zeros((n_samples, n_out), dtype=dtype, order=self.order)
957 
958         for i in range(n_features):
959             spl = self.bsplines_[i]
960 
961             if self.extrapolation in ("continue", "error", "periodic"):
962                 if self.extrapolation == "periodic":
963                     # With periodic extrapolation we map x to the segment
964                     # [spl.t[k], spl.t[n]].
965                     # This is equivalent to BSpline(.., extrapolate="periodic")
966                     # for scipy>=1.0.0.
967                     n = spl.t.size - spl.k - 1
968                     # Assign to new array to avoid inplace operation
969                     x = spl.t[spl.k] + (X[:, i] - spl.t[spl.k]) % (
970                         spl.t[n] - spl.t[spl.k]
971                     )
972                 else:
973                     x = X[:, i]
974 
975                 XBS[:, (i * n_splines) : ((i + 1) * n_splines)] = spl(x)
976 
977             else:
978                 xmin = spl.t[degree]
979                 xmax = spl.t[-degree - 1]
980                 mask = (xmin <= X[:, i]) & (X[:, i] <= xmax)
981                 XBS[mask, (i * n_splines) : ((i + 1) * n_splines)] = spl(X[mask, i])
982 
983             # Note for extrapolation:
984             # 'continue' is already returned as is by scipy BSplines
985             if self.extrapolation == "error":
986                 # BSpline with extrapolate=False does not raise an error, but
987                 # output np.nan.
988                 if np.any(np.isnan(XBS[:, (i * n_splines) : ((i + 1) * n_splines)])):
989                     raise ValueError(
990                         "X contains values beyond the limits of the knots."
991                     )
992             elif self.extrapolation == "constant":
993                 # Set all values beyond xmin and xmax to the value of the
994                 # spline basis functions at those two positions.
995                 # Only the first degree and last degree number of splines
996                 # have non-zero values at the boundaries.
997 
998                 # spline values at boundaries
999                 f_min = spl(xmin)
1000                 f_max = spl(xmax)
1001                 mask = X[:, i] < xmin
1002                 if np.any(mask):
1003                     XBS[mask, (i * n_splines) : (i * n_splines + degree)] = f_min[
1004                         :degree
1005                     ]
1006 
1007                 mask = X[:, i] > xmax
1008                 if np.any(mask):
1009                     XBS[
1010                         mask,
1011                         ((i + 1) * n_splines - degree) : ((i + 1) * n_splines),
1012                     ] = f_max[-degree:]
1013 
1014             elif self.extrapolation == "linear":
1015                 # Continue the degree first and degree last spline bases
1016                 # linearly beyond the boundaries, with slope = derivative at
1017                 # the boundary.
1018                 # Note that all others have derivative = value = 0 at the
1019                 # boundaries.
1020 
1021                 # spline values at boundaries
1022                 f_min, f_max = spl(xmin), spl(xmax)
1023                 # spline derivatives = slopes at boundaries
1024                 fp_min, fp_max = spl(xmin, nu=1), spl(xmax, nu=1)
1025                 # Compute the linear continuation.
1026                 if degree <= 1:
1027                     # For degree=1, the derivative of 2nd spline is not zero at
1028                     # boundary. For degree=0 it is the same as 'constant'.
1029                     degree += 1
1030                 for j in range(degree):
1031                     mask = X[:, i] < xmin
1032                     if np.any(mask):
1033                         XBS[mask, i * n_splines + j] = (
1034                             f_min[j] + (X[mask, i] - xmin) * fp_min[j]
1035                         )
1036 
1037                     mask = X[:, i] > xmax
1038                     if np.any(mask):
1039                         k = n_splines - 1 - j
1040                         XBS[mask, i * n_splines + k] = (
1041                             f_max[k] + (X[mask, i] - xmax) * fp_max[k]
1042                         )
1043 
1044         if self.include_bias:
1045             return XBS
1046         else:
1047             # We throw away one spline basis per feature.
1048             # We chose the last one.
1049             indices = [j for j in range(XBS.shape[1]) if (j + 1) % n_splines != 0]
1050             return XBS[:, indices]
1051 
1052     def _more_tags(self):
1053         return {
1054             "_xfail_checks": {
1055                 "check_estimators_pickle": (
1056                     "Current Scipy implementation of _bsplines does not"
1057                     "support const memory views."
1058                 ),
1059             }
1060         }

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-16 00:02:16.369 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:02:16.369 | INFO     | Search-only: skipping patch selection
2025-10-16 00:02:16.480 | INFO     | Task scikit-learn__scikit-learn-24145 completed successfully.
2025-10-16 00:02:16.481 | INFO     | No patch generated. You can try running ACR again.
