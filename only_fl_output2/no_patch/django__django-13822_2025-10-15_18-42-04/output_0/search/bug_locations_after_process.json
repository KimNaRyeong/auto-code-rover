[
    {
        "rel_file_path": "django/db/migrations/autodetector.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/autodetector.py",
        "start": 1,
        "end": 1316,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import re\n3 from itertools import chain\n4 \n5 from django.conf import settings\n6 from django.db import models\n7 from django.db.migrations import operations\n8 from django.db.migrations.migration import Migration\n9 from django.db.migrations.operations.models import AlterModelOptions\n10 from django.db.migrations.optimizer import MigrationOptimizer\n11 from django.db.migrations.questioner import MigrationQuestioner\n12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject\n13 from django.utils.topological_sort import stable_topological_sort\n14 \n15 \n16 class MigrationAutodetector:\n17     \"\"\"\n18     Take a pair of ProjectStates and compare them to see what the first would\n19     need doing to make it match the second (the second usually being the\n20     project's current state).\n21 \n22     Note that this naturally operates on entire projects at a time,\n23     as it's likely that changes interact (for example, you can't\n24     add a ForeignKey without having a migration to add the table it\n25     depends on first). A user interface may offer single-app usage\n26     if it wishes, with the caveat that it may not always be possible.\n27     \"\"\"\n28 \n29     def __init__(self, from_state, to_state, questioner=None):\n30         self.from_state = from_state\n31         self.to_state = to_state\n32         self.questioner = questioner or MigrationQuestioner()\n33         self.existing_apps = {app for app, model in from_state.models}\n34 \n35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n36         \"\"\"\n37         Main entry point to produce a list of applicable changes.\n38         Take a graph to base names on and an optional set of apps\n39         to try and restrict to (restriction is not guaranteed)\n40         \"\"\"\n41         changes = self._detect_changes(convert_apps, graph)\n42         changes = self.arrange_for_graph(changes, graph, migration_name)\n43         if trim_to_apps:\n44             changes = self._trim_to_apps(changes, trim_to_apps)\n45         return changes\n46 \n47     def deep_deconstruct(self, obj):\n48         \"\"\"\n49         Recursive deconstruction for a field and its arguments.\n50         Used for full comparison for rename/alter; sometimes a single-level\n51         deconstruction will not compare correctly.\n52         \"\"\"\n53         if isinstance(obj, list):\n54             return [self.deep_deconstruct(value) for value in obj]\n55         elif isinstance(obj, tuple):\n56             return tuple(self.deep_deconstruct(value) for value in obj)\n57         elif isinstance(obj, dict):\n58             return {\n59                 key: self.deep_deconstruct(value)\n60                 for key, value in obj.items()\n61             }\n62         elif isinstance(obj, functools.partial):\n63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))\n64         elif isinstance(obj, COMPILED_REGEX_TYPE):\n65             return RegexObject(obj)\n66         elif isinstance(obj, type):\n67             # If this is a type that implements 'deconstruct' as an instance method,\n68             # avoid treating this as being deconstructible itself - see #22951\n69             return obj\n70         elif hasattr(obj, 'deconstruct'):\n71             deconstructed = obj.deconstruct()\n72             if isinstance(obj, models.Field):\n73                 # we have a field which also returns a name\n74                 deconstructed = deconstructed[1:]\n75             path, args, kwargs = deconstructed\n76             return (\n77                 path,\n78                 [self.deep_deconstruct(value) for value in args],\n79                 {\n80                     key: self.deep_deconstruct(value)\n81                     for key, value in kwargs.items()\n82                 },\n83             )\n84         else:\n85             return obj\n86 \n87     def only_relation_agnostic_fields(self, fields):\n88         \"\"\"\n89         Return a definition of the fields that ignores field names and\n90         what related fields actually relate to. Used for detecting renames (as\n91         the related fields change during renames).\n92         \"\"\"\n93         fields_def = []\n94         for name, field in sorted(fields.items()):\n95             deconstruction = self.deep_deconstruct(field)\n96             if field.remote_field and field.remote_field.model:\n97                 del deconstruction[2]['to']\n98             fields_def.append(deconstruction)\n99         return fields_def\n100 \n101     def _detect_changes(self, convert_apps=None, graph=None):\n102         \"\"\"\n103         Return a dict of migration plans which will achieve the\n104         change from from_state to to_state. The dict has app labels\n105         as keys and a list of migrations as values.\n106 \n107         The resulting migrations aren't specially named, but the names\n108         do matter for dependencies inside the set.\n109 \n110         convert_apps is the list of apps to convert to use migrations\n111         (i.e. to make initial migrations for, in the usual case)\n112 \n113         graph is an optional argument that, if provided, can help improve\n114         dependency generation and avoid potential circular dependencies.\n115         \"\"\"\n116         # The first phase is generating all the operations for each app\n117         # and gathering them into a big per-app list.\n118         # Then go through that list, order it, and split into migrations to\n119         # resolve dependencies caused by M2Ms and FKs.\n120         self.generated_operations = {}\n121         self.altered_indexes = {}\n122         self.altered_constraints = {}\n123 \n124         # Prepare some old/new state and model lists, separating\n125         # proxy models and ignoring unmigrated apps.\n126         self.old_apps = self.from_state.concrete_apps\n127         self.new_apps = self.to_state.apps\n128         self.old_model_keys = set()\n129         self.old_proxy_keys = set()\n130         self.old_unmanaged_keys = set()\n131         self.new_model_keys = set()\n132         self.new_proxy_keys = set()\n133         self.new_unmanaged_keys = set()\n134         for al, mn in self.from_state.models:\n135             model = self.old_apps.get_model(al, mn)\n136             if not model._meta.managed:\n137                 self.old_unmanaged_keys.add((al, mn))\n138             elif al not in self.from_state.real_apps:\n139                 if model._meta.proxy:\n140                     self.old_proxy_keys.add((al, mn))\n141                 else:\n142                     self.old_model_keys.add((al, mn))\n143 \n144         for al, mn in self.to_state.models:\n145             model = self.new_apps.get_model(al, mn)\n146             if not model._meta.managed:\n147                 self.new_unmanaged_keys.add((al, mn))\n148             elif (\n149                 al not in self.from_state.real_apps or\n150                 (convert_apps and al in convert_apps)\n151             ):\n152                 if model._meta.proxy:\n153                     self.new_proxy_keys.add((al, mn))\n154                 else:\n155                     self.new_model_keys.add((al, mn))\n156 \n157         # Renames have to come first\n158         self.generate_renamed_models()\n159 \n160         # Prepare lists of fields and generate through model map\n161         self._prepare_field_lists()\n162         self._generate_through_model_map()\n163 \n164         # Generate non-rename model operations\n165         self.generate_deleted_models()\n166         self.generate_created_models()\n167         self.generate_deleted_proxies()\n168         self.generate_created_proxies()\n169         self.generate_altered_options()\n170         self.generate_altered_managers()\n171 \n172         # Create the altered indexes and store them in self.altered_indexes.\n173         # This avoids the same computation in generate_removed_indexes()\n174         # and generate_added_indexes().\n175         self.create_altered_indexes()\n176         self.create_altered_constraints()\n177         # Generate index removal operations before field is removed\n178         self.generate_removed_constraints()\n179         self.generate_removed_indexes()\n180         # Generate field operations\n181         self.generate_renamed_fields()\n182         self.generate_removed_fields()\n183         self.generate_added_fields()\n184         self.generate_altered_fields()\n185         self.generate_altered_order_with_respect_to()\n186         self.generate_altered_unique_together()\n187         self.generate_altered_index_together()\n188         self.generate_added_indexes()\n189         self.generate_added_constraints()\n190         self.generate_altered_db_table()\n191 \n192         self._sort_migrations()\n193         self._build_migration_list(graph)\n194         self._optimize_migrations()\n195 \n196         return self.migrations\n197 \n198     def _prepare_field_lists(self):\n199         \"\"\"\n200         Prepare field lists and a list of the fields that used through models\n201         in the old state so dependencies can be made from the through model\n202         deletion to the field that uses it.\n203         \"\"\"\n204         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n207         self.through_users = {}\n208         self.old_field_keys = {\n209             (app_label, model_name, field_name)\n210             for app_label, model_name in self.kept_model_keys\n211             for field_name in self.from_state.models[\n212                 app_label,\n213                 self.renamed_models.get((app_label, model_name), model_name)\n214             ].fields\n215         }\n216         self.new_field_keys = {\n217             (app_label, model_name, field_name)\n218             for app_label, model_name in self.kept_model_keys\n219             for field_name in self.to_state.models[app_label, model_name].fields\n220         }\n221 \n222     def _generate_through_model_map(self):\n223         \"\"\"Through model map generation.\"\"\"\n224         for app_label, model_name in sorted(self.old_model_keys):\n225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n226             old_model_state = self.from_state.models[app_label, old_model_name]\n227             for field_name in old_model_state.fields:\n228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)\n229                 if (hasattr(old_field, \"remote_field\") and getattr(old_field.remote_field, \"through\", None) and\n230                         not old_field.remote_field.through._meta.auto_created):\n231                     through_key = (\n232                         old_field.remote_field.through._meta.app_label,\n233                         old_field.remote_field.through._meta.model_name,\n234                     )\n235                     self.through_users[through_key] = (app_label, old_model_name, field_name)\n236 \n237     @staticmethod\n238     def _resolve_dependency(dependency):\n239         \"\"\"\n240         Return the resolved dependency and a boolean denoting whether or not\n241         it was swappable.\n242         \"\"\"\n243         if dependency[0] != '__setting__':\n244             return dependency, False\n245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')\n246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n247 \n248     def _build_migration_list(self, graph=None):\n249         \"\"\"\n250         Chop the lists of operations up into migrations with dependencies on\n251         each other. Do this by going through an app's list of operations until\n252         one is found that has an outgoing dependency that isn't in another\n253         app's migration yet (hasn't been chopped off its list). Then chop off\n254         the operations before it into a migration and move onto the next app.\n255         If the loops completes without doing anything, there's a circular\n256         dependency (which _should_ be impossible as the operations are\n257         all split at this point so they can't depend and be depended on).\n258         \"\"\"\n259         self.migrations = {}\n260         num_ops = sum(len(x) for x in self.generated_operations.values())\n261         chop_mode = False\n262         while num_ops:\n263             # On every iteration, we step through all the apps and see if there\n264             # is a completed set of operations.\n265             # If we find that a subset of the operations are complete we can\n266             # try to chop it off from the rest and continue, but we only\n267             # do this if we've already been through the list once before\n268             # without any chopping and nothing has changed.\n269             for app_label in sorted(self.generated_operations):\n270                 chopped = []\n271                 dependencies = set()\n272                 for operation in list(self.generated_operations[app_label]):\n273                     deps_satisfied = True\n274                     operation_dependencies = set()\n275                     for dep in operation._auto_deps:\n276                         # Temporarily resolve the swappable dependency to\n277                         # prevent circular references. While keeping the\n278                         # dependency checks on the resolved model, add the\n279                         # swappable dependencies.\n280                         original_dep = dep\n281                         dep, is_swappable_dep = self._resolve_dependency(dep)\n282                         if dep[0] != app_label:\n283                             # External app dependency. See if it's not yet\n284                             # satisfied.\n285                             for other_operation in self.generated_operations.get(dep[0], []):\n286                                 if self.check_dependency(other_operation, dep):\n287                                     deps_satisfied = False\n288                                     break\n289                             if not deps_satisfied:\n290                                 break\n291                             else:\n292                                 if is_swappable_dep:\n293                                     operation_dependencies.add((original_dep[0], original_dep[1]))\n294                                 elif dep[0] in self.migrations:\n295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))\n296                                 else:\n297                                     # If we can't find the other app, we add a first/last dependency,\n298                                     # but only if we've already been through once and checked everything\n299                                     if chop_mode:\n300                                         # If the app already exists, we add a dependency on the last migration,\n301                                         # as we don't know which migration contains the target field.\n302                                         # If it's not yet migrated or has no migrations, we use __first__\n303                                         if graph and graph.leaf_nodes(dep[0]):\n304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])\n305                                         else:\n306                                             operation_dependencies.add((dep[0], \"__first__\"))\n307                                     else:\n308                                         deps_satisfied = False\n309                     if deps_satisfied:\n310                         chopped.append(operation)\n311                         dependencies.update(operation_dependencies)\n312                         del self.generated_operations[app_label][0]\n313                     else:\n314                         break\n315                 # Make a migration! Well, only if there's stuff to put in it\n316                 if dependencies or chopped:\n317                     if not self.generated_operations[app_label] or chop_mode:\n318                         subclass = type(\"Migration\", (Migration,), {\"operations\": [], \"dependencies\": []})\n319                         instance = subclass(\"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1), app_label)\n320                         instance.dependencies = list(dependencies)\n321                         instance.operations = chopped\n322                         instance.initial = app_label not in self.existing_apps\n323                         self.migrations.setdefault(app_label, []).append(instance)\n324                         chop_mode = False\n325                     else:\n326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]\n327             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n328             if new_num_ops == num_ops:\n329                 if not chop_mode:\n330                     chop_mode = True\n331                 else:\n332                     raise ValueError(\"Cannot resolve operation dependencies: %r\" % self.generated_operations)\n333             num_ops = new_num_ops\n334 \n335     def _sort_migrations(self):\n336         \"\"\"\n337         Reorder to make things possible. Reordering may be needed so FKs work\n338         nicely inside the same app.\n339         \"\"\"\n340         for app_label, ops in sorted(self.generated_operations.items()):\n341             # construct a dependency graph for intra-app dependencies\n342             dependency_graph = {op: set() for op in ops}\n343             for op in ops:\n344                 for dep in op._auto_deps:\n345                     # Resolve intra-app dependencies to handle circular\n346                     # references involving a swappable model.\n347                     dep = self._resolve_dependency(dep)[0]\n348                     if dep[0] == app_label:\n349                         for op2 in ops:\n350                             if self.check_dependency(op2, dep):\n351                                 dependency_graph[op].add(op2)\n352 \n353             # we use a stable sort for deterministic tests & general behavior\n354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n355 \n356     def _optimize_migrations(self):\n357         # Add in internal dependencies among the migrations\n358         for app_label, migrations in self.migrations.items():\n359             for m1, m2 in zip(migrations, migrations[1:]):\n360                 m2.dependencies.append((app_label, m1.name))\n361 \n362         # De-dupe dependencies\n363         for migrations in self.migrations.values():\n364             for migration in migrations:\n365                 migration.dependencies = list(set(migration.dependencies))\n366 \n367         # Optimize migrations\n368         for app_label, migrations in self.migrations.items():\n369             for migration in migrations:\n370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)\n371 \n372     def check_dependency(self, operation, dependency):\n373         \"\"\"\n374         Return True if the given operation depends on the given dependency,\n375         False otherwise.\n376         \"\"\"\n377         # Created model\n378         if dependency[2] is None and dependency[3] is True:\n379             return (\n380                 isinstance(operation, operations.CreateModel) and\n381                 operation.name_lower == dependency[1].lower()\n382             )\n383         # Created field\n384         elif dependency[2] is not None and dependency[3] is True:\n385             return (\n386                 (\n387                     isinstance(operation, operations.CreateModel) and\n388                     operation.name_lower == dependency[1].lower() and\n389                     any(dependency[2] == x for x, y in operation.fields)\n390                 ) or\n391                 (\n392                     isinstance(operation, operations.AddField) and\n393                     operation.model_name_lower == dependency[1].lower() and\n394                     operation.name_lower == dependency[2].lower()\n395                 )\n396             )\n397         # Removed field\n398         elif dependency[2] is not None and dependency[3] is False:\n399             return (\n400                 isinstance(operation, operations.RemoveField) and\n401                 operation.model_name_lower == dependency[1].lower() and\n402                 operation.name_lower == dependency[2].lower()\n403             )\n404         # Removed model\n405         elif dependency[2] is None and dependency[3] is False:\n406             return (\n407                 isinstance(operation, operations.DeleteModel) and\n408                 operation.name_lower == dependency[1].lower()\n409             )\n410         # Field being altered\n411         elif dependency[2] is not None and dependency[3] == \"alter\":\n412             return (\n413                 isinstance(operation, operations.AlterField) and\n414                 operation.model_name_lower == dependency[1].lower() and\n415                 operation.name_lower == dependency[2].lower()\n416             )\n417         # order_with_respect_to being unset for a field\n418         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n419             return (\n420                 isinstance(operation, operations.AlterOrderWithRespectTo) and\n421                 operation.name_lower == dependency[1].lower() and\n422                 (operation.order_with_respect_to or \"\").lower() != dependency[2].lower()\n423             )\n424         # Field is removed and part of an index/unique_together\n425         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n426             return (\n427                 isinstance(operation, (operations.AlterUniqueTogether,\n428                                        operations.AlterIndexTogether)) and\n429                 operation.name_lower == dependency[1].lower()\n430             )\n431         # Unknown dependency. Raise an error.\n432         else:\n433             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n434 \n435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n437         operation._auto_deps = dependencies or []\n438         if beginning:\n439             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n440         else:\n441             self.generated_operations.setdefault(app_label, []).append(operation)\n442 \n443     def swappable_first_key(self, item):\n444         \"\"\"\n445         Place potential swappable models first in lists of created models (only\n446         real way to solve #22783).\n447         \"\"\"\n448         try:\n449             model = self.new_apps.get_model(item[0], item[1])\n450             base_names = [base.__name__ for base in model.__bases__]\n451             string_version = \"%s.%s\" % (item[0], item[1])\n452             if (\n453                 model._meta.swappable or\n454                 \"AbstractUser\" in base_names or\n455                 \"AbstractBaseUser\" in base_names or\n456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()\n457             ):\n458                 return (\"___\" + item[0], \"___\" + item[1])\n459         except LookupError:\n460             pass\n461         return item\n462 \n463     def generate_renamed_models(self):\n464         \"\"\"\n465         Find any renamed models, generate the operations for them, and remove\n466         the old entry from the model lists. Must be run before other\n467         model-level generation.\n468         \"\"\"\n469         self.renamed_models = {}\n470         self.renamed_models_rel = {}\n471         added_models = self.new_model_keys - self.old_model_keys\n472         for app_label, model_name in sorted(added_models):\n473             model_state = self.to_state.models[app_label, model_name]\n474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n475 \n476             removed_models = self.old_model_keys - self.new_model_keys\n477             for rem_app_label, rem_model_name in removed_models:\n478                 if rem_app_label == app_label:\n479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)\n481                     if model_fields_def == rem_model_fields_def:\n482                         if self.questioner.ask_rename_model(rem_model_state, model_state):\n483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n484                             dependencies = []\n485                             for field in model_opts.get_fields():\n486                                 if field.is_relation:\n487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))\n488                             self.add_operation(\n489                                 app_label,\n490                                 operations.RenameModel(\n491                                     old_name=rem_model_state.name,\n492                                     new_name=model_state.name,\n493                                 ),\n494                                 dependencies=dependencies,\n495                             )\n496                             self.renamed_models[app_label, model_name] = rem_model_name\n497                             renamed_models_rel_key = '%s.%s' % (\n498                                 rem_model_state.app_label,\n499                                 rem_model_state.name_lower,\n500                             )\n501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (\n502                                 model_state.app_label,\n503                                 model_state.name_lower,\n504                             )\n505                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n506                             self.old_model_keys.add((app_label, model_name))\n507                             break\n508 \n509     def generate_created_models(self):\n510         \"\"\"\n511         Find all new models (both managed and unmanaged) and make create\n512         operations for them as well as separate operations to create any\n513         foreign key or M2M relationships (these are optimized later, if\n514         possible).\n515 \n516         Defer any model options that refer to collections of fields that might\n517         be deferred (e.g. unique_together, index_together).\n518         \"\"\"\n519         old_keys = self.old_model_keys | self.old_unmanaged_keys\n520         added_models = self.new_model_keys - old_keys\n521         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n522         all_added_models = chain(\n523             sorted(added_models, key=self.swappable_first_key, reverse=True),\n524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)\n525         )\n526         for app_label, model_name in all_added_models:\n527             model_state = self.to_state.models[app_label, model_name]\n528             model_opts = self.new_apps.get_model(app_label, model_name)._meta\n529             # Gather related fields\n530             related_fields = {}\n531             primary_key_rel = None\n532             for field in model_opts.local_fields:\n533                 if field.remote_field:\n534                     if field.remote_field.model:\n535                         if field.primary_key:\n536                             primary_key_rel = field.remote_field.model\n537                         elif not field.remote_field.parent_link:\n538                             related_fields[field.name] = field\n539                     # through will be none on M2Ms on swapped-out models;\n540                     # we can treat lack of through as auto_created=True, though.\n541                     if (getattr(field.remote_field, \"through\", None) and\n542                             not field.remote_field.through._meta.auto_created):\n543                         related_fields[field.name] = field\n544             for field in model_opts.local_many_to_many:\n545                 if field.remote_field.model:\n546                     related_fields[field.name] = field\n547                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n548                     related_fields[field.name] = field\n549             # Are there indexes/unique|index_together to defer?\n550             indexes = model_state.options.pop('indexes')\n551             constraints = model_state.options.pop('constraints')\n552             unique_together = model_state.options.pop('unique_together', None)\n553             index_together = model_state.options.pop('index_together', None)\n554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)\n555             # Depend on the deletion of any possible proxy version of us\n556             dependencies = [\n557                 (app_label, model_name, None, False),\n558             ]\n559             # Depend on all bases\n560             for base in model_state.bases:\n561                 if isinstance(base, str) and \".\" in base:\n562                     base_app_label, base_name = base.split(\".\", 1)\n563                     dependencies.append((base_app_label, base_name, None, True))\n564                     # Depend on the removal of base fields if the new model has\n565                     # a field with the same name.\n566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n568                     if old_base_model_state and new_base_model_state:\n569                         removed_base_fields = set(old_base_model_state.fields).difference(\n570                             new_base_model_state.fields,\n571                         ).intersection(model_state.fields)\n572                         for removed_base_field in removed_base_fields:\n573                             dependencies.append((base_app_label, base_name, removed_base_field, False))\n574             # Depend on the other end of the primary key if it's a relation\n575             if primary_key_rel:\n576                 dependencies.append((\n577                     primary_key_rel._meta.app_label,\n578                     primary_key_rel._meta.object_name,\n579                     None,\n580                     True\n581                 ))\n582             # Generate creation operation\n583             self.add_operation(\n584                 app_label,\n585                 operations.CreateModel(\n586                     name=model_state.name,\n587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],\n588                     options=model_state.options,\n589                     bases=model_state.bases,\n590                     managers=model_state.managers,\n591                 ),\n592                 dependencies=dependencies,\n593                 beginning=True,\n594             )\n595 \n596             # Don't add operations which modify the database for unmanaged models\n597             if not model_opts.managed:\n598                 continue\n599 \n600             # Generate operations for each related field\n601             for name, field in sorted(related_fields.items()):\n602                 dependencies = self._get_dependencies_for_foreign_key(field)\n603                 # Depend on our own model being created\n604                 dependencies.append((app_label, model_name, None, True))\n605                 # Make operation\n606                 self.add_operation(\n607                     app_label,\n608                     operations.AddField(\n609                         model_name=model_name,\n610                         name=name,\n611                         field=field,\n612                     ),\n613                     dependencies=list(set(dependencies)),\n614                 )\n615             # Generate other opns\n616             if order_with_respect_to:\n617                 self.add_operation(\n618                     app_label,\n619                     operations.AlterOrderWithRespectTo(\n620                         name=model_name,\n621                         order_with_respect_to=order_with_respect_to,\n622                     ),\n623                     dependencies=[\n624                         (app_label, model_name, order_with_respect_to, True),\n625                         (app_label, model_name, None, True),\n626                     ]\n627                 )\n628             related_dependencies = [\n629                 (app_label, model_name, name, True)\n630                 for name in sorted(related_fields)\n631             ]\n632             related_dependencies.append((app_label, model_name, None, True))\n633             for index in indexes:\n634                 self.add_operation(\n635                     app_label,\n636                     operations.AddIndex(\n637                         model_name=model_name,\n638                         index=index,\n639                     ),\n640                     dependencies=related_dependencies,\n641                 )\n642             for constraint in constraints:\n643                 self.add_operation(\n644                     app_label,\n645                     operations.AddConstraint(\n646                         model_name=model_name,\n647                         constraint=constraint,\n648                     ),\n649                     dependencies=related_dependencies,\n650                 )\n651             if unique_together:\n652                 self.add_operation(\n653                     app_label,\n654                     operations.AlterUniqueTogether(\n655                         name=model_name,\n656                         unique_together=unique_together,\n657                     ),\n658                     dependencies=related_dependencies\n659                 )\n660             if index_together:\n661                 self.add_operation(\n662                     app_label,\n663                     operations.AlterIndexTogether(\n664                         name=model_name,\n665                         index_together=index_together,\n666                     ),\n667                     dependencies=related_dependencies\n668                 )\n669             # Fix relationships if the model changed from a proxy model to a\n670             # concrete model.\n671             if (app_label, model_name) in self.old_proxy_keys:\n672                 for related_object in model_opts.related_objects:\n673                     self.add_operation(\n674                         related_object.related_model._meta.app_label,\n675                         operations.AlterField(\n676                             model_name=related_object.related_model._meta.object_name,\n677                             name=related_object.field.name,\n678                             field=related_object.field,\n679                         ),\n680                         dependencies=[(app_label, model_name, None, True)],\n681                     )\n682 \n683     def generate_created_proxies(self):\n684         \"\"\"\n685         Make CreateModel statements for proxy models. Use the same statements\n686         as that way there's less code duplication, but for proxy models it's\n687         safe to skip all the pointless field stuff and chuck out an operation.\n688         \"\"\"\n689         added = self.new_proxy_keys - self.old_proxy_keys\n690         for app_label, model_name in sorted(added):\n691             model_state = self.to_state.models[app_label, model_name]\n692             assert model_state.options.get(\"proxy\")\n693             # Depend on the deletion of any possible non-proxy version of us\n694             dependencies = [\n695                 (app_label, model_name, None, False),\n696             ]\n697             # Depend on all bases\n698             for base in model_state.bases:\n699                 if isinstance(base, str) and \".\" in base:\n700                     base_app_label, base_name = base.split(\".\", 1)\n701                     dependencies.append((base_app_label, base_name, None, True))\n702             # Generate creation operation\n703             self.add_operation(\n704                 app_label,\n705                 operations.CreateModel(\n706                     name=model_state.name,\n707                     fields=[],\n708                     options=model_state.options,\n709                     bases=model_state.bases,\n710                     managers=model_state.managers,\n711                 ),\n712                 # Depend on the deletion of any possible non-proxy version of us\n713                 dependencies=dependencies,\n714             )\n715 \n716     def generate_deleted_models(self):\n717         \"\"\"\n718         Find all deleted models (managed and unmanaged) and make delete\n719         operations for them as well as separate operations to delete any\n720         foreign key or M2M relationships (these are optimized later, if\n721         possible).\n722 \n723         Also bring forward removal of any model options that refer to\n724         collections of fields - the inverse of generate_created_models().\n725         \"\"\"\n726         new_keys = self.new_model_keys | self.new_unmanaged_keys\n727         deleted_models = self.old_model_keys - new_keys\n728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))\n730         for app_label, model_name in all_deleted_models:\n731             model_state = self.from_state.models[app_label, model_name]\n732             model = self.old_apps.get_model(app_label, model_name)\n733             # Gather related fields\n734             related_fields = {}\n735             for field in model._meta.local_fields:\n736                 if field.remote_field:\n737                     if field.remote_field.model:\n738                         related_fields[field.name] = field\n739                     # through will be none on M2Ms on swapped-out models;\n740                     # we can treat lack of through as auto_created=True, though.\n741                     if (getattr(field.remote_field, \"through\", None) and\n742                             not field.remote_field.through._meta.auto_created):\n743                         related_fields[field.name] = field\n744             for field in model._meta.local_many_to_many:\n745                 if field.remote_field.model:\n746                     related_fields[field.name] = field\n747                 if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n748                     related_fields[field.name] = field\n749             # Generate option removal first\n750             unique_together = model_state.options.pop('unique_together', None)\n751             index_together = model_state.options.pop('index_together', None)\n752             if unique_together:\n753                 self.add_operation(\n754                     app_label,\n755                     operations.AlterUniqueTogether(\n756                         name=model_name,\n757                         unique_together=None,\n758                     )\n759                 )\n760             if index_together:\n761                 self.add_operation(\n762                     app_label,\n763                     operations.AlterIndexTogether(\n764                         name=model_name,\n765                         index_together=None,\n766                     )\n767                 )\n768             # Then remove each related field\n769             for name in sorted(related_fields):\n770                 self.add_operation(\n771                     app_label,\n772                     operations.RemoveField(\n773                         model_name=model_name,\n774                         name=name,\n775                     )\n776                 )\n777             # Finally, remove the model.\n778             # This depends on both the removal/alteration of all incoming fields\n779             # and the removal of all its own related fields, and if it's\n780             # a through model the field that references it.\n781             dependencies = []\n782             for related_object in model._meta.related_objects:\n783                 related_object_app_label = related_object.related_model._meta.app_label\n784                 object_name = related_object.related_model._meta.object_name\n785                 field_name = related_object.field.name\n786                 dependencies.append((related_object_app_label, object_name, field_name, False))\n787                 if not related_object.many_to_many:\n788                     dependencies.append((related_object_app_label, object_name, field_name, \"alter\"))\n789 \n790             for name in sorted(related_fields):\n791                 dependencies.append((app_label, model_name, name, False))\n792             # We're referenced in another field's through=\n793             through_user = self.through_users.get((app_label, model_state.name_lower))\n794             if through_user:\n795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))\n796             # Finally, make the operation, deduping any dependencies\n797             self.add_operation(\n798                 app_label,\n799                 operations.DeleteModel(\n800                     name=model_state.name,\n801                 ),\n802                 dependencies=list(set(dependencies)),\n803             )\n804 \n805     def generate_deleted_proxies(self):\n806         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n807         deleted = self.old_proxy_keys - self.new_proxy_keys\n808         for app_label, model_name in sorted(deleted):\n809             model_state = self.from_state.models[app_label, model_name]\n810             assert model_state.options.get(\"proxy\")\n811             self.add_operation(\n812                 app_label,\n813                 operations.DeleteModel(\n814                     name=model_state.name,\n815                 ),\n816             )\n817 \n818     def generate_renamed_fields(self):\n819         \"\"\"Work out renamed fields.\"\"\"\n820         self.renamed_fields = {}\n821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n823             old_model_state = self.from_state.models[app_label, old_model_name]\n824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n825             # Scan to see if this is actually a rename!\n826             field_dec = self.deep_deconstruct(field)\n827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):\n828                 if rem_app_label == app_label and rem_model_name == model_name:\n829                     old_field = old_model_state.fields[rem_field_name]\n830                     old_field_dec = self.deep_deconstruct(old_field)\n831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:\n832                         old_rel_to = old_field_dec[2]['to']\n833                         if old_rel_to in self.renamed_models_rel:\n834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]\n835                     old_field.set_attributes_from_name(rem_field_name)\n836                     old_db_column = old_field.get_attname_column()[1]\n837                     if (old_field_dec == field_dec or (\n838                             # Was the field renamed and db_column equal to the\n839                             # old field's column added?\n840                             old_field_dec[0:2] == field_dec[0:2] and\n841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):\n842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):\n843                             self.add_operation(\n844                                 app_label,\n845                                 operations.RenameField(\n846                                     model_name=model_name,\n847                                     old_name=rem_field_name,\n848                                     new_name=field_name,\n849                                 )\n850                             )\n851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))\n852                             self.old_field_keys.add((app_label, model_name, field_name))\n853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name\n854                             break\n855 \n856     def generate_added_fields(self):\n857         \"\"\"Make AddField operations.\"\"\"\n858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n859             self._generate_added_field(app_label, model_name, field_name)\n860 \n861     def _generate_added_field(self, app_label, model_name, field_name):\n862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n863         # Fields that are foreignkeys/m2ms depend on stuff\n864         dependencies = []\n865         if field.remote_field and field.remote_field.model:\n866             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n867         # You can't just add NOT NULL fields with no default or fields\n868         # which don't allow empty strings as default.\n869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)\n870         preserve_default = (\n871             field.null or field.has_default() or field.many_to_many or\n872             (field.blank and field.empty_strings_allowed) or\n873             (isinstance(field, time_fields) and field.auto_now)\n874         )\n875         if not preserve_default:\n876             field = field.clone()\n877             if isinstance(field, time_fields) and field.auto_now_add:\n878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)\n879             else:\n880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)\n881         self.add_operation(\n882             app_label,\n883             operations.AddField(\n884                 model_name=model_name,\n885                 name=field_name,\n886                 field=field,\n887                 preserve_default=preserve_default,\n888             ),\n889             dependencies=dependencies,\n890         )\n891 \n892     def generate_removed_fields(self):\n893         \"\"\"Make RemoveField operations.\"\"\"\n894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):\n895             self._generate_removed_field(app_label, model_name, field_name)\n896 \n897     def _generate_removed_field(self, app_label, model_name, field_name):\n898         self.add_operation(\n899             app_label,\n900             operations.RemoveField(\n901                 model_name=model_name,\n902                 name=field_name,\n903             ),\n904             # We might need to depend on the removal of an\n905             # order_with_respect_to or index/unique_together operation;\n906             # this is safely ignored if there isn't one\n907             dependencies=[\n908                 (app_label, model_name, field_name, \"order_wrt_unset\"),\n909                 (app_label, model_name, field_name, \"foo_together_change\"),\n910             ],\n911         )\n912 \n913     def generate_altered_fields(self):\n914         \"\"\"\n915         Make AlterField operations, or possibly RemovedField/AddField if alter\n916         isn's possible.\n917         \"\"\"\n918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):\n919             # Did the field change?\n920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)\n922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)\n923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n924             dependencies = []\n925             # Implement any model renames on relations; these are handled by RenameModel\n926             # so we need to exclude them from the comparison\n927             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"model\", None):\n928                 rename_key = (\n929                     new_field.remote_field.model._meta.app_label,\n930                     new_field.remote_field.model._meta.model_name,\n931                 )\n932                 if rename_key in self.renamed_models:\n933                     new_field.remote_field.model = old_field.remote_field.model\n934                 # Handle ForeignKey which can only have a single to_field.\n935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)\n936                 if remote_field_name:\n937                     to_field_rename_key = rename_key + (remote_field_name,)\n938                     if to_field_rename_key in self.renamed_fields:\n939                         # Repoint both model and field name because to_field\n940                         # inclusion in ForeignKey.deconstruct() is based on\n941                         # both.\n942                         new_field.remote_field.model = old_field.remote_field.model\n943                         new_field.remote_field.field_name = old_field.remote_field.field_name\n944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.\n945                 from_fields = getattr(new_field, 'from_fields', None)\n946                 if from_fields:\n947                     from_rename_key = (app_label, model_name)\n948                     new_field.from_fields = tuple([\n949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)\n950                         for from_field in from_fields\n951                     ])\n952                     new_field.to_fields = tuple([\n953                         self.renamed_fields.get(rename_key + (to_field,), to_field)\n954                         for to_field in new_field.to_fields\n955                     ])\n956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))\n957             if hasattr(new_field, \"remote_field\") and getattr(new_field.remote_field, \"through\", None):\n958                 rename_key = (\n959                     new_field.remote_field.through._meta.app_label,\n960                     new_field.remote_field.through._meta.model_name,\n961                 )\n962                 if rename_key in self.renamed_models:\n963                     new_field.remote_field.through = old_field.remote_field.through\n964             old_field_dec = self.deep_deconstruct(old_field)\n965             new_field_dec = self.deep_deconstruct(new_field)\n966             if old_field_dec != new_field_dec:\n967                 both_m2m = old_field.many_to_many and new_field.many_to_many\n968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many\n969                 if both_m2m or neither_m2m:\n970                     # Either both fields are m2m or neither is\n971                     preserve_default = True\n972                     if (old_field.null and not new_field.null and not new_field.has_default() and\n973                             not new_field.many_to_many):\n974                         field = new_field.clone()\n975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)\n976                         if new_default is not models.NOT_PROVIDED:\n977                             field.default = new_default\n978                             preserve_default = False\n979                     else:\n980                         field = new_field\n981                     self.add_operation(\n982                         app_label,\n983                         operations.AlterField(\n984                             model_name=model_name,\n985                             name=field_name,\n986                             field=field,\n987                             preserve_default=preserve_default,\n988                         ),\n989                         dependencies=dependencies,\n990                     )\n991                 else:\n992                     # We cannot alter between m2m and concrete fields\n993                     self._generate_removed_field(app_label, model_name, field_name)\n994                     self._generate_added_field(app_label, model_name, field_name)\n995 \n996     def create_altered_indexes(self):\n997         option_name = operations.AddIndex.option_name\n998         for app_label, model_name in sorted(self.kept_model_keys):\n999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1000             old_model_state = self.from_state.models[app_label, old_model_name]\n1001             new_model_state = self.to_state.models[app_label, model_name]\n1002 \n1003             old_indexes = old_model_state.options[option_name]\n1004             new_indexes = new_model_state.options[option_name]\n1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]\n1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]\n1007 \n1008             self.altered_indexes.update({\n1009                 (app_label, model_name): {\n1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,\n1011                 }\n1012             })\n1013 \n1014     def generate_added_indexes(self):\n1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1016             for index in alt_indexes['added_indexes']:\n1017                 self.add_operation(\n1018                     app_label,\n1019                     operations.AddIndex(\n1020                         model_name=model_name,\n1021                         index=index,\n1022                     )\n1023                 )\n1024 \n1025     def generate_removed_indexes(self):\n1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():\n1027             for index in alt_indexes['removed_indexes']:\n1028                 self.add_operation(\n1029                     app_label,\n1030                     operations.RemoveIndex(\n1031                         model_name=model_name,\n1032                         name=index.name,\n1033                     )\n1034                 )\n1035 \n1036     def create_altered_constraints(self):\n1037         option_name = operations.AddConstraint.option_name\n1038         for app_label, model_name in sorted(self.kept_model_keys):\n1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1040             old_model_state = self.from_state.models[app_label, old_model_name]\n1041             new_model_state = self.to_state.models[app_label, model_name]\n1042 \n1043             old_constraints = old_model_state.options[option_name]\n1044             new_constraints = new_model_state.options[option_name]\n1045             add_constraints = [c for c in new_constraints if c not in old_constraints]\n1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]\n1047 \n1048             self.altered_constraints.update({\n1049                 (app_label, model_name): {\n1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,\n1051                 }\n1052             })\n1053 \n1054     def generate_added_constraints(self):\n1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1056             for constraint in alt_constraints['added_constraints']:\n1057                 self.add_operation(\n1058                     app_label,\n1059                     operations.AddConstraint(\n1060                         model_name=model_name,\n1061                         constraint=constraint,\n1062                     )\n1063                 )\n1064 \n1065     def generate_removed_constraints(self):\n1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():\n1067             for constraint in alt_constraints['removed_constraints']:\n1068                 self.add_operation(\n1069                     app_label,\n1070                     operations.RemoveConstraint(\n1071                         model_name=model_name,\n1072                         name=constraint.name,\n1073                     )\n1074                 )\n1075 \n1076     def _get_dependencies_for_foreign_key(self, field):\n1077         # Account for FKs to swappable models\n1078         swappable_setting = getattr(field, 'swappable_setting', None)\n1079         if swappable_setting is not None:\n1080             dep_app_label = \"__setting__\"\n1081             dep_object_name = swappable_setting\n1082         else:\n1083             dep_app_label = field.remote_field.model._meta.app_label\n1084             dep_object_name = field.remote_field.model._meta.object_name\n1085         dependencies = [(dep_app_label, dep_object_name, None, True)]\n1086         if getattr(field.remote_field, \"through\", None) and not field.remote_field.through._meta.auto_created:\n1087             dependencies.append((\n1088                 field.remote_field.through._meta.app_label,\n1089                 field.remote_field.through._meta.object_name,\n1090                 None,\n1091                 True,\n1092             ))\n1093         return dependencies\n1094 \n1095     def _generate_altered_foo_together(self, operation):\n1096         option_name = operation.option_name\n1097         for app_label, model_name in sorted(self.kept_model_keys):\n1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1099             old_model_state = self.from_state.models[app_label, old_model_name]\n1100             new_model_state = self.to_state.models[app_label, model_name]\n1101 \n1102             # We run the old version through the field renames to account for those\n1103             old_value = old_model_state.options.get(option_name)\n1104             old_value = {\n1105                 tuple(\n1106                     self.renamed_fields.get((app_label, model_name, n), n)\n1107                     for n in unique\n1108                 )\n1109                 for unique in old_value\n1110             } if old_value else set()\n1111 \n1112             new_value = new_model_state.options.get(option_name)\n1113             new_value = set(new_value) if new_value else set()\n1114 \n1115             if old_value != new_value:\n1116                 dependencies = []\n1117                 for foo_togethers in new_value:\n1118                     for field_name in foo_togethers:\n1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)\n1120                         if field.remote_field and field.remote_field.model:\n1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))\n1122 \n1123                 self.add_operation(\n1124                     app_label,\n1125                     operation(\n1126                         name=model_name,\n1127                         **{option_name: new_value}\n1128                     ),\n1129                     dependencies=dependencies,\n1130                 )\n1131 \n1132     def generate_altered_unique_together(self):\n1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)\n1134 \n1135     def generate_altered_index_together(self):\n1136         self._generate_altered_foo_together(operations.AlterIndexTogether)\n1137 \n1138     def generate_altered_db_table(self):\n1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)\n1140         for app_label, model_name in sorted(models_to_check):\n1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1142             old_model_state = self.from_state.models[app_label, old_model_name]\n1143             new_model_state = self.to_state.models[app_label, model_name]\n1144             old_db_table_name = old_model_state.options.get('db_table')\n1145             new_db_table_name = new_model_state.options.get('db_table')\n1146             if old_db_table_name != new_db_table_name:\n1147                 self.add_operation(\n1148                     app_label,\n1149                     operations.AlterModelTable(\n1150                         name=model_name,\n1151                         table=new_db_table_name,\n1152                     )\n1153                 )\n1154 \n1155     def generate_altered_options(self):\n1156         \"\"\"\n1157         Work out if any non-schema-affecting options have changed and make an\n1158         operation to represent them in state changes (in case Python code in\n1159         migrations needs them).\n1160         \"\"\"\n1161         models_to_check = self.kept_model_keys.union(\n1162             self.kept_proxy_keys,\n1163             self.kept_unmanaged_keys,\n1164             # unmanaged converted to managed\n1165             self.old_unmanaged_keys & self.new_model_keys,\n1166             # managed converted to unmanaged\n1167             self.old_model_keys & self.new_unmanaged_keys,\n1168         )\n1169 \n1170         for app_label, model_name in sorted(models_to_check):\n1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1172             old_model_state = self.from_state.models[app_label, old_model_name]\n1173             new_model_state = self.to_state.models[app_label, model_name]\n1174             old_options = {\n1175                 key: value for key, value in old_model_state.options.items()\n1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1177             }\n1178             new_options = {\n1179                 key: value for key, value in new_model_state.options.items()\n1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS\n1181             }\n1182             if old_options != new_options:\n1183                 self.add_operation(\n1184                     app_label,\n1185                     operations.AlterModelOptions(\n1186                         name=model_name,\n1187                         options=new_options,\n1188                     )\n1189                 )\n1190 \n1191     def generate_altered_order_with_respect_to(self):\n1192         for app_label, model_name in sorted(self.kept_model_keys):\n1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1194             old_model_state = self.from_state.models[app_label, old_model_name]\n1195             new_model_state = self.to_state.models[app_label, model_name]\n1196             if (old_model_state.options.get(\"order_with_respect_to\") !=\n1197                     new_model_state.options.get(\"order_with_respect_to\")):\n1198                 # Make sure it comes second if we're adding\n1199                 # (removal dependency is part of RemoveField)\n1200                 dependencies = []\n1201                 if new_model_state.options.get(\"order_with_respect_to\"):\n1202                     dependencies.append((\n1203                         app_label,\n1204                         model_name,\n1205                         new_model_state.options[\"order_with_respect_to\"],\n1206                         True,\n1207                     ))\n1208                 # Actually generate the operation\n1209                 self.add_operation(\n1210                     app_label,\n1211                     operations.AlterOrderWithRespectTo(\n1212                         name=model_name,\n1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),\n1214                     ),\n1215                     dependencies=dependencies,\n1216                 )\n1217 \n1218     def generate_altered_managers(self):\n1219         for app_label, model_name in sorted(self.kept_model_keys):\n1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n1221             old_model_state = self.from_state.models[app_label, old_model_name]\n1222             new_model_state = self.to_state.models[app_label, model_name]\n1223             if old_model_state.managers != new_model_state.managers:\n1224                 self.add_operation(\n1225                     app_label,\n1226                     operations.AlterModelManagers(\n1227                         name=model_name,\n1228                         managers=new_model_state.managers,\n1229                     )\n1230                 )\n1231 \n1232     def arrange_for_graph(self, changes, graph, migration_name=None):\n1233         \"\"\"\n1234         Take a result from changes() and a MigrationGraph, and fix the names\n1235         and dependencies of the changes so they extend the graph from the leaf\n1236         nodes for each app.\n1237         \"\"\"\n1238         leaves = graph.leaf_nodes()\n1239         name_map = {}\n1240         for app_label, migrations in list(changes.items()):\n1241             if not migrations:\n1242                 continue\n1243             # Find the app label's current leaf node\n1244             app_leaf = None\n1245             for leaf in leaves:\n1246                 if leaf[0] == app_label:\n1247                     app_leaf = leaf\n1248                     break\n1249             # Do they want an initial migration for this app?\n1250             if app_leaf is None and not self.questioner.ask_initial(app_label):\n1251                 # They don't.\n1252                 for migration in migrations:\n1253                     name_map[(app_label, migration.name)] = (app_label, \"__first__\")\n1254                 del changes[app_label]\n1255                 continue\n1256             # Work out the next number in the sequence\n1257             if app_leaf is None:\n1258                 next_number = 1\n1259             else:\n1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1\n1261             # Name each migration\n1262             for i, migration in enumerate(migrations):\n1263                 if i == 0 and app_leaf:\n1264                     migration.dependencies.append(app_leaf)\n1265                 new_name_parts = ['%04i' % next_number]\n1266                 if migration_name:\n1267                     new_name_parts.append(migration_name)\n1268                 elif i == 0 and not app_leaf:\n1269                     new_name_parts.append('initial')\n1270                 else:\n1271                     new_name_parts.append(migration.suggest_name()[:100])\n1272                 new_name = '_'.join(new_name_parts)\n1273                 name_map[(app_label, migration.name)] = (app_label, new_name)\n1274                 next_number += 1\n1275                 migration.name = new_name\n1276         # Now fix dependencies\n1277         for migrations in changes.values():\n1278             for migration in migrations:\n1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]\n1280         return changes\n1281 \n1282     def _trim_to_apps(self, changes, app_labels):\n1283         \"\"\"\n1284         Take changes from arrange_for_graph() and set of app labels, and return\n1285         a modified set of changes which trims out as many migrations that are\n1286         not in app_labels as possible. Note that some other migrations may\n1287         still be present as they may be required dependencies.\n1288         \"\"\"\n1289         # Gather other app dependencies in a first pass\n1290         app_dependencies = {}\n1291         for app_label, migrations in changes.items():\n1292             for migration in migrations:\n1293                 for dep_app_label, name in migration.dependencies:\n1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)\n1295         required_apps = set(app_labels)\n1296         # Keep resolving till there's no change\n1297         old_required_apps = None\n1298         while old_required_apps != required_apps:\n1299             old_required_apps = set(required_apps)\n1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])\n1301         # Remove all migrations that aren't needed\n1302         for app_label in list(changes):\n1303             if app_label not in required_apps:\n1304                 del changes[app_label]\n1305         return changes\n1306 \n1307     @classmethod\n1308     def parse_number(cls, name):\n1309         \"\"\"\n1310         Given a migration name, try to extract a number from the beginning of\n1311         it. If no number is found, return None.\n1312         \"\"\"\n1313         match = re.match(r'^\\d+', name)\n1314         if match:\n1315             return int(match[0])\n1316         return None\n",
        "intended_behavior": "The autodetector should correctly handle models with identical names across different apps when they use ManyToManyField with related_name='+', preventing fields.E305 errors. This means: Properly recognizing and respecting the related_name='+' to avoid unnecessary related name conflict checks between models in different apps. Ensuring that migration operations do not flag false positives for conflicts in ManyToManyField relations just because models share names across different Django apps."
    },
    {
        "rel_file_path": "django/db/migrations/state.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/state.py",
        "start": 1,
        "end": 604,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 from contextlib import contextmanager\n3 \n4 from django.apps import AppConfig\n5 from django.apps.registry import Apps, apps as global_apps\n6 from django.conf import settings\n7 from django.db import models\n8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n9 from django.db.models.options import DEFAULT_NAMES, normalize_together\n10 from django.db.models.utils import make_model_tuple\n11 from django.utils.functional import cached_property\n12 from django.utils.module_loading import import_string\n13 from django.utils.version import get_docs_version\n14 \n15 from .exceptions import InvalidBasesError\n16 \n17 \n18 def _get_app_label_and_model_name(model, app_label=''):\n19     if isinstance(model, str):\n20         split = model.split('.', 1)\n21         return tuple(split) if len(split) == 2 else (app_label, split[0])\n22     else:\n23         return model._meta.app_label, model._meta.model_name\n24 \n25 \n26 def _get_related_models(m):\n27     \"\"\"Return all models that have a direct relationship to the given model.\"\"\"\n28     related_models = [\n29         subclass for subclass in m.__subclasses__()\n30         if issubclass(subclass, models.Model)\n31     ]\n32     related_fields_models = set()\n33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):\n34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):\n35             related_fields_models.add(f.model)\n36             related_models.append(f.related_model)\n37     # Reverse accessors of foreign keys to proxy models are attached to their\n38     # concrete proxied model.\n39     opts = m._meta\n40     if opts.proxy and m in related_fields_models:\n41         related_models.append(opts.concrete_model)\n42     return related_models\n43 \n44 \n45 def get_related_models_tuples(model):\n46     \"\"\"\n47     Return a list of typical (app_label, model_name) tuples for all related\n48     models for the given model.\n49     \"\"\"\n50     return {\n51         (rel_mod._meta.app_label, rel_mod._meta.model_name)\n52         for rel_mod in _get_related_models(model)\n53     }\n54 \n55 \n56 def get_related_models_recursive(model):\n57     \"\"\"\n58     Return all models that have a direct or indirect relationship\n59     to the given model.\n60 \n61     Relationships are either defined by explicit relational fields, like\n62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another\n63     model (a superclass is related to its subclasses, but not vice versa). Note,\n64     however, that a model inheriting from a concrete model is also related to\n65     its superclass through the implicit *_ptr OneToOneField on the subclass.\n66     \"\"\"\n67     seen = set()\n68     queue = _get_related_models(model)\n69     for rel_mod in queue:\n70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name\n71         if (rel_app_label, rel_model_name) in seen:\n72             continue\n73         seen.add((rel_app_label, rel_model_name))\n74         queue.extend(_get_related_models(rel_mod))\n75     return seen - {(model._meta.app_label, model._meta.model_name)}\n76 \n77 \n78 class ProjectState:\n79     \"\"\"\n80     Represent the entire project's overall state. This is the item that is\n81     passed around - do it here rather than at the app level so that cross-app\n82     FKs/etc. resolve properly.\n83     \"\"\"\n84 \n85     def __init__(self, models=None, real_apps=None):\n86         self.models = models or {}\n87         # Apps to include from main registry, usually unmigrated ones\n88         self.real_apps = real_apps or []\n89         self.is_delayed = False\n90 \n91     def add_model(self, model_state):\n92         app_label, model_name = model_state.app_label, model_state.name_lower\n93         self.models[(app_label, model_name)] = model_state\n94         if 'apps' in self.__dict__:  # hasattr would cache the property\n95             self.reload_model(app_label, model_name)\n96 \n97     def remove_model(self, app_label, model_name):\n98         del self.models[app_label, model_name]\n99         if 'apps' in self.__dict__:  # hasattr would cache the property\n100             self.apps.unregister_model(app_label, model_name)\n101             # Need to do this explicitly since unregister_model() doesn't clear\n102             # the cache automatically (#24513)\n103             self.apps.clear_cache()\n104 \n105     def _find_reload_model(self, app_label, model_name, delay=False):\n106         if delay:\n107             self.is_delayed = True\n108 \n109         related_models = set()\n110 \n111         try:\n112             old_model = self.apps.get_model(app_label, model_name)\n113         except LookupError:\n114             pass\n115         else:\n116             # Get all relations to and from the old model before reloading,\n117             # as _meta.apps may change\n118             if delay:\n119                 related_models = get_related_models_tuples(old_model)\n120             else:\n121                 related_models = get_related_models_recursive(old_model)\n122 \n123         # Get all outgoing references from the model to be rendered\n124         model_state = self.models[(app_label, model_name)]\n125         # Directly related models are the models pointed to by ForeignKeys,\n126         # OneToOneFields, and ManyToManyFields.\n127         direct_related_models = set()\n128         for field in model_state.fields.values():\n129             if field.is_relation:\n130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n131                     continue\n132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)\n133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))\n134 \n135         # For all direct related models recursively get all related models.\n136         related_models.update(direct_related_models)\n137         for rel_app_label, rel_model_name in direct_related_models:\n138             try:\n139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)\n140             except LookupError:\n141                 pass\n142             else:\n143                 if delay:\n144                     related_models.update(get_related_models_tuples(rel_model))\n145                 else:\n146                     related_models.update(get_related_models_recursive(rel_model))\n147 \n148         # Include the model itself\n149         related_models.add((app_label, model_name))\n150 \n151         return related_models\n152 \n153     def reload_model(self, app_label, model_name, delay=False):\n154         if 'apps' in self.__dict__:  # hasattr would cache the property\n155             related_models = self._find_reload_model(app_label, model_name, delay)\n156             self._reload(related_models)\n157 \n158     def reload_models(self, models, delay=True):\n159         if 'apps' in self.__dict__:  # hasattr would cache the property\n160             related_models = set()\n161             for app_label, model_name in models:\n162                 related_models.update(self._find_reload_model(app_label, model_name, delay))\n163             self._reload(related_models)\n164 \n165     def _reload(self, related_models):\n166         # Unregister all related models\n167         with self.apps.bulk_update():\n168             for rel_app_label, rel_model_name in related_models:\n169                 self.apps.unregister_model(rel_app_label, rel_model_name)\n170 \n171         states_to_be_rendered = []\n172         # Gather all models states of those models that will be rerendered.\n173         # This includes:\n174         # 1. All related models of unmigrated apps\n175         for model_state in self.apps.real_models:\n176             if (model_state.app_label, model_state.name_lower) in related_models:\n177                 states_to_be_rendered.append(model_state)\n178 \n179         # 2. All related models of migrated apps\n180         for rel_app_label, rel_model_name in related_models:\n181             try:\n182                 model_state = self.models[rel_app_label, rel_model_name]\n183             except KeyError:\n184                 pass\n185             else:\n186                 states_to_be_rendered.append(model_state)\n187 \n188         # Render all models\n189         self.apps.render_multiple(states_to_be_rendered)\n190 \n191     def clone(self):\n192         \"\"\"Return an exact copy of this ProjectState.\"\"\"\n193         new_state = ProjectState(\n194             models={k: v.clone() for k, v in self.models.items()},\n195             real_apps=self.real_apps,\n196         )\n197         if 'apps' in self.__dict__:\n198             new_state.apps = self.apps.clone()\n199         new_state.is_delayed = self.is_delayed\n200         return new_state\n201 \n202     def clear_delayed_apps_cache(self):\n203         if self.is_delayed and 'apps' in self.__dict__:\n204             del self.__dict__['apps']\n205 \n206     @cached_property\n207     def apps(self):\n208         return StateApps(self.real_apps, self.models)\n209 \n210     @property\n211     def concrete_apps(self):\n212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)\n213         return self.apps\n214 \n215     @classmethod\n216     def from_apps(cls, apps):\n217         \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n218         app_models = {}\n219         for model in apps.get_models(include_swapped=True):\n220             model_state = ModelState.from_model(model)\n221             app_models[(model_state.app_label, model_state.name_lower)] = model_state\n222         return cls(app_models)\n223 \n224     def __eq__(self, other):\n225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)\n226 \n227 \n228 class AppConfigStub(AppConfig):\n229     \"\"\"Stub of an AppConfig. Only provides a label and a dict of models.\"\"\"\n230     def __init__(self, label):\n231         self.apps = None\n232         self.models = {}\n233         # App-label and app-name are not the same thing, so technically passing\n234         # in the label here is wrong. In practice, migrations don't care about\n235         # the app name, but we need something unique, and the label works fine.\n236         self.label = label\n237         self.name = label\n238 \n239     def import_models(self):\n240         self.models = self.apps.all_models[self.label]\n241 \n242 \n243 class StateApps(Apps):\n244     \"\"\"\n245     Subclass of the global Apps registry class to better handle dynamic model\n246     additions and removals.\n247     \"\"\"\n248     def __init__(self, real_apps, models, ignore_swappable=False):\n249         # Any apps in self.real_apps should have all their models included\n250         # in the render. We don't use the original model instances as there\n251         # are some variables that refer to the Apps object.\n252         # FKs/M2Ms from real apps are also not included as they just\n253         # mess things up with partial states (due to lack of dependencies)\n254         self.real_models = []\n255         for app_label in real_apps:\n256             app = global_apps.get_app_config(app_label)\n257             for model in app.get_models():\n258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))\n259         # Populate the app registry with a stub for each application.\n260         app_labels = {model_state.app_label for model_state in models.values()}\n261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]\n262         super().__init__(app_configs)\n263 \n264         # These locks get in the way of copying as implemented in clone(),\n265         # which is called whenever Django duplicates a StateApps before\n266         # updating it.\n267         self._lock = None\n268         self.ready_event = None\n269 \n270         self.render_multiple([*models.values(), *self.real_models])\n271 \n272         # There shouldn't be any operations pending at this point.\n273         from django.core.checks.model_checks import _check_lazy_references\n274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()\n275         errors = _check_lazy_references(self, ignore=ignore)\n276         if errors:\n277             raise ValueError(\"\\n\".join(error.msg for error in errors))\n278 \n279     @contextmanager\n280     def bulk_update(self):\n281         # Avoid clearing each model's cache for each change. Instead, clear\n282         # all caches when we're finished updating the model instances.\n283         ready = self.ready\n284         self.ready = False\n285         try:\n286             yield\n287         finally:\n288             self.ready = ready\n289             self.clear_cache()\n290 \n291     def render_multiple(self, model_states):\n292         # We keep trying to render the models in a loop, ignoring invalid\n293         # base errors, until the size of the unrendered models doesn't\n294         # decrease by at least one, meaning there's a base dependency loop/\n295         # missing base.\n296         if not model_states:\n297             return\n298         # Prevent that all model caches are expired for each render.\n299         with self.bulk_update():\n300             unrendered_models = model_states\n301             while unrendered_models:\n302                 new_unrendered_models = []\n303                 for model in unrendered_models:\n304                     try:\n305                         model.render(self)\n306                     except InvalidBasesError:\n307                         new_unrendered_models.append(model)\n308                 if len(new_unrendered_models) == len(unrendered_models):\n309                     raise InvalidBasesError(\n310                         \"Cannot resolve bases for %r\\nThis can happen if you are inheriting models from an \"\n311                         \"app with migrations (e.g. contrib.auth)\\n in an app with no migrations; see \"\n312                         \"https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies \"\n313                         \"for more\" % (new_unrendered_models, get_docs_version())\n314                     )\n315                 unrendered_models = new_unrendered_models\n316 \n317     def clone(self):\n318         \"\"\"Return a clone of this registry.\"\"\"\n319         clone = StateApps([], {})\n320         clone.all_models = copy.deepcopy(self.all_models)\n321         clone.app_configs = copy.deepcopy(self.app_configs)\n322         # Set the pointer to the correct app registry.\n323         for app_config in clone.app_configs.values():\n324             app_config.apps = clone\n325         # No need to actually clone them, they'll never change\n326         clone.real_models = self.real_models\n327         return clone\n328 \n329     def register_model(self, app_label, model):\n330         self.all_models[app_label][model._meta.model_name] = model\n331         if app_label not in self.app_configs:\n332             self.app_configs[app_label] = AppConfigStub(app_label)\n333             self.app_configs[app_label].apps = self\n334         self.app_configs[app_label].models[model._meta.model_name] = model\n335         self.do_pending_operations(model)\n336         self.clear_cache()\n337 \n338     def unregister_model(self, app_label, model_name):\n339         try:\n340             del self.all_models[app_label][model_name]\n341             del self.app_configs[app_label].models[model_name]\n342         except KeyError:\n343             pass\n344 \n345 \n346 class ModelState:\n347     \"\"\"\n348     Represent a Django Model. Don't use the actual Model class as it's not\n349     designed to have its options changed - instead, mutate this one and then\n350     render it into a Model as required.\n351 \n352     Note that while you are allowed to mutate .fields, you are not allowed\n353     to mutate the Field instances inside there themselves - you must instead\n354     assign new ones, as these are not detached during a clone.\n355     \"\"\"\n356 \n357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):\n358         self.app_label = app_label\n359         self.name = name\n360         self.fields = dict(fields)\n361         self.options = options or {}\n362         self.options.setdefault('indexes', [])\n363         self.options.setdefault('constraints', [])\n364         self.bases = bases or (models.Model,)\n365         self.managers = managers or []\n366         for name, field in self.fields.items():\n367             # Sanity-check that fields are NOT already bound to a model.\n368             if hasattr(field, 'model'):\n369                 raise ValueError(\n370                     'ModelState.fields cannot be bound to a model - \"%s\" is.' % name\n371                 )\n372             # Sanity-check that relation fields are NOT referring to a model class.\n373             if field.is_relation and hasattr(field.related_model, '_meta'):\n374                 raise ValueError(\n375                     'ModelState.fields cannot refer to a model class - \"%s.to\" does. '\n376                     'Use a string reference instead.' % name\n377                 )\n378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):\n379                 raise ValueError(\n380                     'ModelState.fields cannot refer to a model class - \"%s.through\" does. '\n381                     'Use a string reference instead.' % name\n382                 )\n383         # Sanity-check that indexes have their name set.\n384         for index in self.options['indexes']:\n385             if not index.name:\n386                 raise ValueError(\n387                     \"Indexes passed to ModelState require a name attribute. \"\n388                     \"%r doesn't have one.\" % index\n389                 )\n390 \n391     @cached_property\n392     def name_lower(self):\n393         return self.name.lower()\n394 \n395     @classmethod\n396     def from_model(cls, model, exclude_rels=False):\n397         \"\"\"Given a model, return a ModelState representing it.\"\"\"\n398         # Deconstruct the fields\n399         fields = []\n400         for field in model._meta.local_fields:\n401             if getattr(field, \"remote_field\", None) and exclude_rels:\n402                 continue\n403             if isinstance(field, models.OrderWrt):\n404                 continue\n405             name = field.name\n406             try:\n407                 fields.append((name, field.clone()))\n408             except TypeError as e:\n409                 raise TypeError(\"Couldn't reconstruct field %s on %s: %s\" % (\n410                     name,\n411                     model._meta.label,\n412                     e,\n413                 ))\n414         if not exclude_rels:\n415             for field in model._meta.local_many_to_many:\n416                 name = field.name\n417                 try:\n418                     fields.append((name, field.clone()))\n419                 except TypeError as e:\n420                     raise TypeError(\"Couldn't reconstruct m2m field %s on %s: %s\" % (\n421                         name,\n422                         model._meta.object_name,\n423                         e,\n424                     ))\n425         # Extract the options\n426         options = {}\n427         for name in DEFAULT_NAMES:\n428             # Ignore some special options\n429             if name in [\"apps\", \"app_label\"]:\n430                 continue\n431             elif name in model._meta.original_attrs:\n432                 if name == \"unique_together\":\n433                     ut = model._meta.original_attrs[\"unique_together\"]\n434                     options[name] = set(normalize_together(ut))\n435                 elif name == \"index_together\":\n436                     it = model._meta.original_attrs[\"index_together\"]\n437                     options[name] = set(normalize_together(it))\n438                 elif name == \"indexes\":\n439                     indexes = [idx.clone() for idx in model._meta.indexes]\n440                     for index in indexes:\n441                         if not index.name:\n442                             index.set_name_with_model(model)\n443                     options['indexes'] = indexes\n444                 elif name == 'constraints':\n445                     options['constraints'] = [con.clone() for con in model._meta.constraints]\n446                 else:\n447                     options[name] = model._meta.original_attrs[name]\n448         # If we're ignoring relationships, remove all field-listing model\n449         # options (that option basically just means \"make a stub model\")\n450         if exclude_rels:\n451             for key in [\"unique_together\", \"index_together\", \"order_with_respect_to\"]:\n452                 if key in options:\n453                     del options[key]\n454         # Private fields are ignored, so remove options that refer to them.\n455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:\n456             del options['order_with_respect_to']\n457 \n458         def flatten_bases(model):\n459             bases = []\n460             for base in model.__bases__:\n461                 if hasattr(base, \"_meta\") and base._meta.abstract:\n462                     bases.extend(flatten_bases(base))\n463                 else:\n464                     bases.append(base)\n465             return bases\n466 \n467         # We can't rely on __mro__ directly because we only want to flatten\n468         # abstract models and not the whole tree. However by recursing on\n469         # __bases__ we may end up with duplicates and ordering issues, we\n470         # therefore discard any duplicates and reorder the bases according\n471         # to their index in the MRO.\n472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))\n473 \n474         # Make our record\n475         bases = tuple(\n476             (\n477                 base._meta.label_lower\n478                 if hasattr(base, \"_meta\") else\n479                 base\n480             )\n481             for base in flattened_bases\n482         )\n483         # Ensure at least one base inherits from models.Model\n484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):\n485             bases = (models.Model,)\n486 \n487         managers = []\n488         manager_names = set()\n489         default_manager_shim = None\n490         for manager in model._meta.managers:\n491             if manager.name in manager_names:\n492                 # Skip overridden managers.\n493                 continue\n494             elif manager.use_in_migrations:\n495                 # Copy managers usable in migrations.\n496                 new_manager = copy.copy(manager)\n497                 new_manager._set_creation_counter()\n498             elif manager is model._base_manager or manager is model._default_manager:\n499                 # Shim custom managers used as default and base managers.\n500                 new_manager = models.Manager()\n501                 new_manager.model = manager.model\n502                 new_manager.name = manager.name\n503                 if manager is model._default_manager:\n504                     default_manager_shim = new_manager\n505             else:\n506                 continue\n507             manager_names.add(manager.name)\n508             managers.append((manager.name, new_manager))\n509 \n510         # Ignore a shimmed default manager called objects if it's the only one.\n511         if managers == [('objects', default_manager_shim)]:\n512             managers = []\n513 \n514         # Construct the new ModelState\n515         return cls(\n516             model._meta.app_label,\n517             model._meta.object_name,\n518             fields,\n519             options,\n520             bases,\n521             managers,\n522         )\n523 \n524     def construct_managers(self):\n525         \"\"\"Deep-clone the managers using deconstruction.\"\"\"\n526         # Sort all managers by their creation counter\n527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)\n528         for mgr_name, manager in sorted_managers:\n529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()\n530             if as_manager:\n531                 qs_class = import_string(qs_path)\n532                 yield mgr_name, qs_class.as_manager()\n533             else:\n534                 manager_class = import_string(manager_path)\n535                 yield mgr_name, manager_class(*args, **kwargs)\n536 \n537     def clone(self):\n538         \"\"\"Return an exact copy of this ModelState.\"\"\"\n539         return self.__class__(\n540             app_label=self.app_label,\n541             name=self.name,\n542             fields=dict(self.fields),\n543             # Since options are shallow-copied here, operations such as\n544             # AddIndex must replace their option (e.g 'indexes') rather\n545             # than mutating it.\n546             options=dict(self.options),\n547             bases=self.bases,\n548             managers=list(self.managers),\n549         )\n550 \n551     def render(self, apps):\n552         \"\"\"Create a Model object from our current state into the given apps.\"\"\"\n553         # First, make a Meta object\n554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}\n555         meta = type(\"Meta\", (), meta_contents)\n556         # Then, work out our bases\n557         try:\n558             bases = tuple(\n559                 (apps.get_model(base) if isinstance(base, str) else base)\n560                 for base in self.bases\n561             )\n562         except LookupError:\n563             raise InvalidBasesError(\"Cannot resolve one or more bases from %r\" % (self.bases,))\n564         # Clone fields for the body, add other bits.\n565         body = {name: field.clone() for name, field in self.fields.items()}\n566         body['Meta'] = meta\n567         body['__module__'] = \"__fake__\"\n568 \n569         # Restore managers\n570         body.update(self.construct_managers())\n571         # Then, make a Model object (apps.register_model is called in __new__)\n572         return type(self.name, bases, body)\n573 \n574     def get_index_by_name(self, name):\n575         for index in self.options['indexes']:\n576             if index.name == name:\n577                 return index\n578         raise ValueError(\"No index named %s on model %s\" % (name, self.name))\n579 \n580     def get_constraint_by_name(self, name):\n581         for constraint in self.options['constraints']:\n582             if constraint.name == name:\n583                 return constraint\n584         raise ValueError('No constraint named %s on model %s' % (name, self.name))\n585 \n586     def __repr__(self):\n587         return \"<%s: '%s.%s'>\" % (self.__class__.__name__, self.app_label, self.name)\n588 \n589     def __eq__(self, other):\n590         return (\n591             (self.app_label == other.app_label) and\n592             (self.name == other.name) and\n593             (len(self.fields) == len(other.fields)) and\n594             all(\n595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]\n596                 for (k1, f1), (k2, f2) in zip(\n597                     sorted(self.fields.items()),\n598                     sorted(other.fields.items()),\n599                 )\n600             ) and\n601             (self.options == other.options) and\n602             (self.bases == other.bases) and\n603             (self.managers == other.managers)\n604         )\n",
        "intended_behavior": "Ensure that the project state construction and validation logic properly scope model identifiers with app labels, thereby allowing models in different apps to share names without causing fields.E305 related to ManyToManyField relations. This could involve: Enhancing the logic that validates model names and related field attributes to consider the app label as part of the identity. This way, even if models share names (and have similar ManyToManyField configurations), they are treated as distinct as long as they reside in different apps."
    }
]