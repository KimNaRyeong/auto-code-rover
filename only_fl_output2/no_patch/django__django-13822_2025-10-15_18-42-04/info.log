2025-10-15 18:42:04.355 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 18:42:09.118 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=236, output_tokens=12, cost=0.002720
2025-10-15 18:42:24.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=670, cost=0.024260
2025-10-15 18:42:25.807 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 18:42:34.600 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=541, output_tokens=341, cost=0.015640
2025-10-15 18:42:34.607 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 18:42:38.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=695, output_tokens=85, cost=0.009500
2025-10-15 18:42:38.046 | DEBUG    | Extracted a valid json.
2025-10-15 18:42:38.046 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ManyToManyField(related_name='+')\")",
        "search_code(\"migrations\")",
        "search_code(\"pre_save\")",
        "search_code(\"post_save\")",
        "search_class(\"Migration\")",
        "search_method(\"makemigrations\")",
        "search_method(\"migrate\")"
    ],
    "bug_locations": []
}
2025-10-15 18:42:38.566 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 18:42:38.566 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 18:43:00.862 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4357, output_tokens=876, cost=0.069850
2025-10-15 18:43:00.870 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 18:43:15.025 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5449, output_tokens=565, cost=0.071440
2025-10-15 18:43:15.031 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 18:43:21.703 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=919, output_tokens=267, cost=0.017200
2025-10-15 18:43:21.704 | DEBUG    | Extracted a valid json.
2025-10-15 18:43:21.704 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "The autodetector should correctly handle models with identical names across different apps when they use ManyToManyField with related_name='+', preventing fields.E305 errors. This means: Properly recognizing and respecting the related_name='+' to avoid unnecessary related name conflict checks between models in different apps. Ensuring that migration operations do not flag false positives for conflicts in ManyToManyField relations just because models share names across different Django apps."
        },
        {
            "file": "django/db/migrations/state.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the project state construction and validation logic properly scope model identifiers with app labels, thereby allowing models in different apps to share names without causing fields.E305 related to ManyToManyField relations. This could involve: Enhancing the logic that validates model names and related field attributes to consider the app label as part of the identity. This way, even if models share names (and have similar ManyToManyField configurations), they are treated as distinct as long as they reside in different apps."
        }
    ]
}
2025-10-15 18:43:21.716 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_order_with_respect_to()
186         self.generate_altered_unique_together()
187         self.generate_altered_index_together()
188         self.generate_added_indexes()
189         self.generate_added_constraints()
190         self.generate_altered_db_table()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             if (app_label, model_name) in self.old_proxy_keys:
672                 for related_object in model_opts.related_objects:
673                     self.add_operation(
674                         related_object.related_model._meta.app_label,
675                         operations.AlterField(
676                             model_name=related_object.related_model._meta.object_name,
677                             name=related_object.field.name,
678                             field=related_object.field,
679                         ),
680                         dependencies=[(app_label, model_name, None, True)],
681                     )
682 
683     def generate_created_proxies(self):
684         """
685         Make CreateModel statements for proxy models. Use the same statements
686         as that way there's less code duplication, but for proxy models it's
687         safe to skip all the pointless field stuff and chuck out an operation.
688         """
689         added = self.new_proxy_keys - self.old_proxy_keys
690         for app_label, model_name in sorted(added):
691             model_state = self.to_state.models[app_label, model_name]
692             assert model_state.options.get("proxy")
693             # Depend on the deletion of any possible non-proxy version of us
694             dependencies = [
695                 (app_label, model_name, None, False),
696             ]
697             # Depend on all bases
698             for base in model_state.bases:
699                 if isinstance(base, str) and "." in base:
700                     base_app_label, base_name = base.split(".", 1)
701                     dependencies.append((base_app_label, base_name, None, True))
702             # Generate creation operation
703             self.add_operation(
704                 app_label,
705                 operations.CreateModel(
706                     name=model_state.name,
707                     fields=[],
708                     options=model_state.options,
709                     bases=model_state.bases,
710                     managers=model_state.managers,
711                 ),
712                 # Depend on the deletion of any possible non-proxy version of us
713                 dependencies=dependencies,
714             )
715 
716     def generate_deleted_models(self):
717         """
718         Find all deleted models (managed and unmanaged) and make delete
719         operations for them as well as separate operations to delete any
720         foreign key or M2M relationships (these are optimized later, if
721         possible).
722 
723         Also bring forward removal of any model options that refer to
724         collections of fields - the inverse of generate_created_models().
725         """
726         new_keys = self.new_model_keys | self.new_unmanaged_keys
727         deleted_models = self.old_model_keys - new_keys
728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
730         for app_label, model_name in all_deleted_models:
731             model_state = self.from_state.models[app_label, model_name]
732             model = self.old_apps.get_model(app_label, model_name)
733             # Gather related fields
734             related_fields = {}
735             for field in model._meta.local_fields:
736                 if field.remote_field:
737                     if field.remote_field.model:
738                         related_fields[field.name] = field
739                     # through will be none on M2Ms on swapped-out models;
740                     # we can treat lack of through as auto_created=True, though.
741                     if (getattr(field.remote_field, "through", None) and
742                             not field.remote_field.through._meta.auto_created):
743                         related_fields[field.name] = field
744             for field in model._meta.local_many_to_many:
745                 if field.remote_field.model:
746                     related_fields[field.name] = field
747                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
748                     related_fields[field.name] = field
749             # Generate option removal first
750             unique_together = model_state.options.pop('unique_together', None)
751             index_together = model_state.options.pop('index_together', None)
752             if unique_together:
753                 self.add_operation(
754                     app_label,
755                     operations.AlterUniqueTogether(
756                         name=model_name,
757                         unique_together=None,
758                     )
759                 )
760             if index_together:
761                 self.add_operation(
762                     app_label,
763                     operations.AlterIndexTogether(
764                         name=model_name,
765                         index_together=None,
766                     )
767                 )
768             # Then remove each related field
769             for name in sorted(related_fields):
770                 self.add_operation(
771                     app_label,
772                     operations.RemoveField(
773                         model_name=model_name,
774                         name=name,
775                     )
776                 )
777             # Finally, remove the model.
778             # This depends on both the removal/alteration of all incoming fields
779             # and the removal of all its own related fields, and if it's
780             # a through model the field that references it.
781             dependencies = []
782             for related_object in model._meta.related_objects:
783                 related_object_app_label = related_object.related_model._meta.app_label
784                 object_name = related_object.related_model._meta.object_name
785                 field_name = related_object.field.name
786                 dependencies.append((related_object_app_label, object_name, field_name, False))
787                 if not related_object.many_to_many:
788                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
789 
790             for name in sorted(related_fields):
791                 dependencies.append((app_label, model_name, name, False))
792             # We're referenced in another field's through=
793             through_user = self.through_users.get((app_label, model_state.name_lower))
794             if through_user:
795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
796             # Finally, make the operation, deduping any dependencies
797             self.add_operation(
798                 app_label,
799                 operations.DeleteModel(
800                     name=model_state.name,
801                 ),
802                 dependencies=list(set(dependencies)),
803             )
804 
805     def generate_deleted_proxies(self):
806         """Make DeleteModel options for proxy models."""
807         deleted = self.old_proxy_keys - self.new_proxy_keys
808         for app_label, model_name in sorted(deleted):
809             model_state = self.from_state.models[app_label, model_name]
810             assert model_state.options.get("proxy")
811             self.add_operation(
812                 app_label,
813                 operations.DeleteModel(
814                     name=model_state.name,
815                 ),
816             )
817 
818     def generate_renamed_fields(self):
819         """Work out renamed fields."""
820         self.renamed_fields = {}
821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
823             old_model_state = self.from_state.models[app_label, old_model_name]
824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.fields[rem_field_name]
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(field))
867         # You can't just add NOT NULL fields with no default or fields
868         # which don't allow empty strings as default.
869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
870         preserve_default = (
871             field.null or field.has_default() or field.many_to_many or
872             (field.blank and field.empty_strings_allowed) or
873             (isinstance(field, time_fields) and field.auto_now)
874         )
875         if not preserve_default:
876             field = field.clone()
877             if isinstance(field, time_fields) and field.auto_now_add:
878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
879             else:
880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
881         self.add_operation(
882             app_label,
883             operations.AddField(
884                 model_name=model_name,
885                 name=field_name,
886                 field=field,
887                 preserve_default=preserve_default,
888             ),
889             dependencies=dependencies,
890         )
891 
892     def generate_removed_fields(self):
893         """Make RemoveField operations."""
894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
895             self._generate_removed_field(app_label, model_name, field_name)
896 
897     def _generate_removed_field(self, app_label, model_name, field_name):
898         self.add_operation(
899             app_label,
900             operations.RemoveField(
901                 model_name=model_name,
902                 name=field_name,
903             ),
904             # We might need to depend on the removal of an
905             # order_with_respect_to or index/unique_together operation;
906             # this is safely ignored if there isn't one
907             dependencies=[
908                 (app_label, model_name, field_name, "order_wrt_unset"),
909                 (app_label, model_name, field_name, "foo_together_change"),
910             ],
911         )
912 
913     def generate_altered_fields(self):
914         """
915         Make AlterField operations, or possibly RemovedField/AddField if alter
916         isn's possible.
917         """
918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
919             # Did the field change?
920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
924             dependencies = []
925             # Implement any model renames on relations; these are handled by RenameModel
926             # so we need to exclude them from the comparison
927             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
928                 rename_key = (
929                     new_field.remote_field.model._meta.app_label,
930                     new_field.remote_field.model._meta.model_name,
931                 )
932                 if rename_key in self.renamed_models:
933                     new_field.remote_field.model = old_field.remote_field.model
934                 # Handle ForeignKey which can only have a single to_field.
935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
936                 if remote_field_name:
937                     to_field_rename_key = rename_key + (remote_field_name,)
938                     if to_field_rename_key in self.renamed_fields:
939                         # Repoint both model and field name because to_field
940                         # inclusion in ForeignKey.deconstruct() is based on
941                         # both.
942                         new_field.remote_field.model = old_field.remote_field.model
943                         new_field.remote_field.field_name = old_field.remote_field.field_name
944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
945                 from_fields = getattr(new_field, 'from_fields', None)
946                 if from_fields:
947                     from_rename_key = (app_label, model_name)
948                     new_field.from_fields = tuple([
949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
950                         for from_field in from_fields
951                     ])
952                     new_field.to_fields = tuple([
953                         self.renamed_fields.get(rename_key + (to_field,), to_field)
954                         for to_field in new_field.to_fields
955                     ])
956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
957             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
958                 rename_key = (
959                     new_field.remote_field.through._meta.app_label,
960                     new_field.remote_field.through._meta.model_name,
961                 )
962                 if rename_key in self.renamed_models:
963                     new_field.remote_field.through = old_field.remote_field.through
964             old_field_dec = self.deep_deconstruct(old_field)
965             new_field_dec = self.deep_deconstruct(new_field)
966             if old_field_dec != new_field_dec:
967                 both_m2m = old_field.many_to_many and new_field.many_to_many
968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
969                 if both_m2m or neither_m2m:
970                     # Either both fields are m2m or neither is
971                     preserve_default = True
972                     if (old_field.null and not new_field.null and not new_field.has_default() and
973                             not new_field.many_to_many):
974                         field = new_field.clone()
975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
976                         if new_default is not models.NOT_PROVIDED:
977                             field.default = new_default
978                             preserve_default = False
979                     else:
980                         field = new_field
981                     self.add_operation(
982                         app_label,
983                         operations.AlterField(
984                             model_name=model_name,
985                             name=field_name,
986                             field=field,
987                             preserve_default=preserve_default,
988                         ),
989                         dependencies=dependencies,
990                     )
991                 else:
992                     # We cannot alter between m2m and concrete fields
993                     self._generate_removed_field(app_label, model_name, field_name)
994                     self._generate_added_field(app_label, model_name, field_name)
995 
996     def create_altered_indexes(self):
997         option_name = operations.AddIndex.option_name
998         for app_label, model_name in sorted(self.kept_model_keys):
999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1000             old_model_state = self.from_state.models[app_label, old_model_name]
1001             new_model_state = self.to_state.models[app_label, model_name]
1002 
1003             old_indexes = old_model_state.options[option_name]
1004             new_indexes = new_model_state.options[option_name]
1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1007 
1008             self.altered_indexes.update({
1009                 (app_label, model_name): {
1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1011                 }
1012             })
1013 
1014     def generate_added_indexes(self):
1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1016             for index in alt_indexes['added_indexes']:
1017                 self.add_operation(
1018                     app_label,
1019                     operations.AddIndex(
1020                         model_name=model_name,
1021                         index=index,
1022                     )
1023                 )
1024 
1025     def generate_removed_indexes(self):
1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1027             for index in alt_indexes['removed_indexes']:
1028                 self.add_operation(
1029                     app_label,
1030                     operations.RemoveIndex(
1031                         model_name=model_name,
1032                         name=index.name,
1033                     )
1034                 )
1035 
1036     def create_altered_constraints(self):
1037         option_name = operations.AddConstraint.option_name
1038         for app_label, model_name in sorted(self.kept_model_keys):
1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1040             old_model_state = self.from_state.models[app_label, old_model_name]
1041             new_model_state = self.to_state.models[app_label, model_name]
1042 
1043             old_constraints = old_model_state.options[option_name]
1044             new_constraints = new_model_state.options[option_name]
1045             add_constraints = [c for c in new_constraints if c not in old_constraints]
1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1047 
1048             self.altered_constraints.update({
1049                 (app_label, model_name): {
1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1051                 }
1052             })
1053 
1054     def generate_added_constraints(self):
1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1056             for constraint in alt_constraints['added_constraints']:
1057                 self.add_operation(
1058                     app_label,
1059                     operations.AddConstraint(
1060                         model_name=model_name,
1061                         constraint=constraint,
1062                     )
1063                 )
1064 
1065     def generate_removed_constraints(self):
1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1067             for constraint in alt_constraints['removed_constraints']:
1068                 self.add_operation(
1069                     app_label,
1070                     operations.RemoveConstraint(
1071                         model_name=model_name,
1072                         name=constraint.name,
1073                     )
1074                 )
1075 
1076     def _get_dependencies_for_foreign_key(self, field):
1077         # Account for FKs to swappable models
1078         swappable_setting = getattr(field, 'swappable_setting', None)
1079         if swappable_setting is not None:
1080             dep_app_label = "__setting__"
1081             dep_object_name = swappable_setting
1082         else:
1083             dep_app_label = field.remote_field.model._meta.app_label
1084             dep_object_name = field.remote_field.model._meta.object_name
1085         dependencies = [(dep_app_label, dep_object_name, None, True)]
1086         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1087             dependencies.append((
1088                 field.remote_field.through._meta.app_label,
1089                 field.remote_field.through._meta.object_name,
1090                 None,
1091                 True,
1092             ))
1093         return dependencies
1094 
1095     def _generate_altered_foo_together(self, operation):
1096         option_name = operation.option_name
1097         for app_label, model_name in sorted(self.kept_model_keys):
1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1099             old_model_state = self.from_state.models[app_label, old_model_name]
1100             new_model_state = self.to_state.models[app_label, model_name]
1101 
1102             # We run the old version through the field renames to account for those
1103             old_value = old_model_state.options.get(option_name)
1104             old_value = {
1105                 tuple(
1106                     self.renamed_fields.get((app_label, model_name, n), n)
1107                     for n in unique
1108                 )
1109                 for unique in old_value
1110             } if old_value else set()
1111 
1112             new_value = new_model_state.options.get(option_name)
1113             new_value = set(new_value) if new_value else set()
1114 
1115             if old_value != new_value:
1116                 dependencies = []
1117                 for foo_togethers in new_value:
1118                     for field_name in foo_togethers:
1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1120                         if field.remote_field and field.remote_field.model:
1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1122 
1123                 self.add_operation(
1124                     app_label,
1125                     operation(
1126                         name=model_name,
1127                         **{option_name: new_value}
1128                     ),
1129                     dependencies=dependencies,
1130                 )
1131 
1132     def generate_altered_unique_together(self):
1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1134 
1135     def generate_altered_index_together(self):
1136         self._generate_altered_foo_together(operations.AlterIndexTogether)
1137 
1138     def generate_altered_db_table(self):
1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1140         for app_label, model_name in sorted(models_to_check):
1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1142             old_model_state = self.from_state.models[app_label, old_model_name]
1143             new_model_state = self.to_state.models[app_label, model_name]
1144             old_db_table_name = old_model_state.options.get('db_table')
1145             new_db_table_name = new_model_state.options.get('db_table')
1146             if old_db_table_name != new_db_table_name:
1147                 self.add_operation(
1148                     app_label,
1149                     operations.AlterModelTable(
1150                         name=model_name,
1151                         table=new_db_table_name,
1152                     )
1153                 )
1154 
1155     def generate_altered_options(self):
1156         """
1157         Work out if any non-schema-affecting options have changed and make an
1158         operation to represent them in state changes (in case Python code in
1159         migrations needs them).
1160         """
1161         models_to_check = self.kept_model_keys.union(
1162             self.kept_proxy_keys,
1163             self.kept_unmanaged_keys,
1164             # unmanaged converted to managed
1165             self.old_unmanaged_keys & self.new_model_keys,
1166             # managed converted to unmanaged
1167             self.old_model_keys & self.new_unmanaged_keys,
1168         )
1169 
1170         for app_label, model_name in sorted(models_to_check):
1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1172             old_model_state = self.from_state.models[app_label, old_model_name]
1173             new_model_state = self.to_state.models[app_label, model_name]
1174             old_options = {
1175                 key: value for key, value in old_model_state.options.items()
1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1177             }
1178             new_options = {
1179                 key: value for key, value in new_model_state.options.items()
1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1181             }
1182             if old_options != new_options:
1183                 self.add_operation(
1184                     app_label,
1185                     operations.AlterModelOptions(
1186                         name=model_name,
1187                         options=new_options,
1188                     )
1189                 )
1190 
1191     def generate_altered_order_with_respect_to(self):
1192         for app_label, model_name in sorted(self.kept_model_keys):
1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1194             old_model_state = self.from_state.models[app_label, old_model_name]
1195             new_model_state = self.to_state.models[app_label, model_name]
1196             if (old_model_state.options.get("order_with_respect_to") !=
1197                     new_model_state.options.get("order_with_respect_to")):
1198                 # Make sure it comes second if we're adding
1199                 # (removal dependency is part of RemoveField)
1200                 dependencies = []
1201                 if new_model_state.options.get("order_with_respect_to"):
1202                     dependencies.append((
1203                         app_label,
1204                         model_name,
1205                         new_model_state.options["order_with_respect_to"],
1206                         True,
1207                     ))
1208                 # Actually generate the operation
1209                 self.add_operation(
1210                     app_label,
1211                     operations.AlterOrderWithRespectTo(
1212                         name=model_name,
1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1214                     ),
1215                     dependencies=dependencies,
1216                 )
1217 
1218     def generate_altered_managers(self):
1219         for app_label, model_name in sorted(self.kept_model_keys):
1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1221             old_model_state = self.from_state.models[app_label, old_model_name]
1222             new_model_state = self.to_state.models[app_label, model_name]
1223             if old_model_state.managers != new_model_state.managers:
1224                 self.add_operation(
1225                     app_label,
1226                     operations.AlterModelManagers(
1227                         name=model_name,
1228                         managers=new_model_state.managers,
1229                     )
1230                 )
1231 
1232     def arrange_for_graph(self, changes, graph, migration_name=None):
1233         """
1234         Take a result from changes() and a MigrationGraph, and fix the names
1235         and dependencies of the changes so they extend the graph from the leaf
1236         nodes for each app.
1237         """
1238         leaves = graph.leaf_nodes()
1239         name_map = {}
1240         for app_label, migrations in list(changes.items()):
1241             if not migrations:
1242                 continue
1243             # Find the app label's current leaf node
1244             app_leaf = None
1245             for leaf in leaves:
1246                 if leaf[0] == app_label:
1247                     app_leaf = leaf
1248                     break
1249             # Do they want an initial migration for this app?
1250             if app_leaf is None and not self.questioner.ask_initial(app_label):
1251                 # They don't.
1252                 for migration in migrations:
1253                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1254                 del changes[app_label]
1255                 continue
1256             # Work out the next number in the sequence
1257             if app_leaf is None:
1258                 next_number = 1
1259             else:
1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1261             # Name each migration
1262             for i, migration in enumerate(migrations):
1263                 if i == 0 and app_leaf:
1264                     migration.dependencies.append(app_leaf)
1265                 new_name_parts = ['%04i' % next_number]
1266                 if migration_name:
1267                     new_name_parts.append(migration_name)
1268                 elif i == 0 and not app_leaf:
1269                     new_name_parts.append('initial')
1270                 else:
1271                     new_name_parts.append(migration.suggest_name()[:100])
1272                 new_name = '_'.join(new_name_parts)
1273                 name_map[(app_label, migration.name)] = (app_label, new_name)
1274                 next_number += 1
1275                 migration.name = new_name
1276         # Now fix dependencies
1277         for migrations in changes.values():
1278             for migration in migrations:
1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1280         return changes
1281 
1282     def _trim_to_apps(self, changes, app_labels):
1283         """
1284         Take changes from arrange_for_graph() and set of app labels, and return
1285         a modified set of changes which trims out as many migrations that are
1286         not in app_labels as possible. Note that some other migrations may
1287         still be present as they may be required dependencies.
1288         """
1289         # Gather other app dependencies in a first pass
1290         app_dependencies = {}
1291         for app_label, migrations in changes.items():
1292             for migration in migrations:
1293                 for dep_app_label, name in migration.dependencies:
1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1295         required_apps = set(app_labels)
1296         # Keep resolving till there's no change
1297         old_required_apps = None
1298         while old_required_apps != required_apps:
1299             old_required_apps = set(required_apps)
1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1301         # Remove all migrations that aren't needed
1302         for app_label in list(changes):
1303             if app_label not in required_apps:
1304                 del changes[app_label]
1305         return changes
1306 
1307     @classmethod
1308     def parse_number(cls, name):
1309         """
1310         Given a migration name, try to extract a number from the beginning of
1311         it. If no number is found, return None.
1312         """
1313         match = re.match(r'^\d+', name)
1314         if match:
1315             return int(match[0])
1316         return None

</code><intended_behavior>The autodetector should correctly handle models with identical names across different apps when they use ManyToManyField with related_name='+', preventing fields.E305 errors. This means: Properly recognizing and respecting the related_name='+' to avoid unnecessary related name conflict checks between models in different apps. Ensuring that migration operations do not flag false positives for conflicts in ManyToManyField relations just because models share names across different Django apps.</intended_behavior>, <file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from contextlib import contextmanager
3 
4 from django.apps import AppConfig
5 from django.apps.registry import Apps, apps as global_apps
6 from django.conf import settings
7 from django.db import models
8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
9 from django.db.models.options import DEFAULT_NAMES, normalize_together
10 from django.db.models.utils import make_model_tuple
11 from django.utils.functional import cached_property
12 from django.utils.module_loading import import_string
13 from django.utils.version import get_docs_version
14 
15 from .exceptions import InvalidBasesError
16 
17 
18 def _get_app_label_and_model_name(model, app_label=''):
19     if isinstance(model, str):
20         split = model.split('.', 1)
21         return tuple(split) if len(split) == 2 else (app_label, split[0])
22     else:
23         return model._meta.app_label, model._meta.model_name
24 
25 
26 def _get_related_models(m):
27     """Return all models that have a direct relationship to the given model."""
28     related_models = [
29         subclass for subclass in m.__subclasses__()
30         if issubclass(subclass, models.Model)
31     ]
32     related_fields_models = set()
33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):
35             related_fields_models.add(f.model)
36             related_models.append(f.related_model)
37     # Reverse accessors of foreign keys to proxy models are attached to their
38     # concrete proxied model.
39     opts = m._meta
40     if opts.proxy and m in related_fields_models:
41         related_models.append(opts.concrete_model)
42     return related_models
43 
44 
45 def get_related_models_tuples(model):
46     """
47     Return a list of typical (app_label, model_name) tuples for all related
48     models for the given model.
49     """
50     return {
51         (rel_mod._meta.app_label, rel_mod._meta.model_name)
52         for rel_mod in _get_related_models(model)
53     }
54 
55 
56 def get_related_models_recursive(model):
57     """
58     Return all models that have a direct or indirect relationship
59     to the given model.
60 
61     Relationships are either defined by explicit relational fields, like
62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
63     model (a superclass is related to its subclasses, but not vice versa). Note,
64     however, that a model inheriting from a concrete model is also related to
65     its superclass through the implicit *_ptr OneToOneField on the subclass.
66     """
67     seen = set()
68     queue = _get_related_models(model)
69     for rel_mod in queue:
70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name
71         if (rel_app_label, rel_model_name) in seen:
72             continue
73         seen.add((rel_app_label, rel_model_name))
74         queue.extend(_get_related_models(rel_mod))
75     return seen - {(model._meta.app_label, model._meta.model_name)}
76 
77 
78 class ProjectState:
79     """
80     Represent the entire project's overall state. This is the item that is
81     passed around - do it here rather than at the app level so that cross-app
82     FKs/etc. resolve properly.
83     """
84 
85     def __init__(self, models=None, real_apps=None):
86         self.models = models or {}
87         # Apps to include from main registry, usually unmigrated ones
88         self.real_apps = real_apps or []
89         self.is_delayed = False
90 
91     def add_model(self, model_state):
92         app_label, model_name = model_state.app_label, model_state.name_lower
93         self.models[(app_label, model_name)] = model_state
94         if 'apps' in self.__dict__:  # hasattr would cache the property
95             self.reload_model(app_label, model_name)
96 
97     def remove_model(self, app_label, model_name):
98         del self.models[app_label, model_name]
99         if 'apps' in self.__dict__:  # hasattr would cache the property
100             self.apps.unregister_model(app_label, model_name)
101             # Need to do this explicitly since unregister_model() doesn't clear
102             # the cache automatically (#24513)
103             self.apps.clear_cache()
104 
105     def _find_reload_model(self, app_label, model_name, delay=False):
106         if delay:
107             self.is_delayed = True
108 
109         related_models = set()
110 
111         try:
112             old_model = self.apps.get_model(app_label, model_name)
113         except LookupError:
114             pass
115         else:
116             # Get all relations to and from the old model before reloading,
117             # as _meta.apps may change
118             if delay:
119                 related_models = get_related_models_tuples(old_model)
120             else:
121                 related_models = get_related_models_recursive(old_model)
122 
123         # Get all outgoing references from the model to be rendered
124         model_state = self.models[(app_label, model_name)]
125         # Directly related models are the models pointed to by ForeignKeys,
126         # OneToOneFields, and ManyToManyFields.
127         direct_related_models = set()
128         for field in model_state.fields.values():
129             if field.is_relation:
130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
131                     continue
132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)
133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
134 
135         # For all direct related models recursively get all related models.
136         related_models.update(direct_related_models)
137         for rel_app_label, rel_model_name in direct_related_models:
138             try:
139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
140             except LookupError:
141                 pass
142             else:
143                 if delay:
144                     related_models.update(get_related_models_tuples(rel_model))
145                 else:
146                     related_models.update(get_related_models_recursive(rel_model))
147 
148         # Include the model itself
149         related_models.add((app_label, model_name))
150 
151         return related_models
152 
153     def reload_model(self, app_label, model_name, delay=False):
154         if 'apps' in self.__dict__:  # hasattr would cache the property
155             related_models = self._find_reload_model(app_label, model_name, delay)
156             self._reload(related_models)
157 
158     def reload_models(self, models, delay=True):
159         if 'apps' in self.__dict__:  # hasattr would cache the property
160             related_models = set()
161             for app_label, model_name in models:
162                 related_models.update(self._find_reload_model(app_label, model_name, delay))
163             self._reload(related_models)
164 
165     def _reload(self, related_models):
166         # Unregister all related models
167         with self.apps.bulk_update():
168             for rel_app_label, rel_model_name in related_models:
169                 self.apps.unregister_model(rel_app_label, rel_model_name)
170 
171         states_to_be_rendered = []
172         # Gather all models states of those models that will be rerendered.
173         # This includes:
174         # 1. All related models of unmigrated apps
175         for model_state in self.apps.real_models:
176             if (model_state.app_label, model_state.name_lower) in related_models:
177                 states_to_be_rendered.append(model_state)
178 
179         # 2. All related models of migrated apps
180         for rel_app_label, rel_model_name in related_models:
181             try:
182                 model_state = self.models[rel_app_label, rel_model_name]
183             except KeyError:
184                 pass
185             else:
186                 states_to_be_rendered.append(model_state)
187 
188         # Render all models
189         self.apps.render_multiple(states_to_be_rendered)
190 
191     def clone(self):
192         """Return an exact copy of this ProjectState."""
193         new_state = ProjectState(
194             models={k: v.clone() for k, v in self.models.items()},
195             real_apps=self.real_apps,
196         )
197         if 'apps' in self.__dict__:
198             new_state.apps = self.apps.clone()
199         new_state.is_delayed = self.is_delayed
200         return new_state
201 
202     def clear_delayed_apps_cache(self):
203         if self.is_delayed and 'apps' in self.__dict__:
204             del self.__dict__['apps']
205 
206     @cached_property
207     def apps(self):
208         return StateApps(self.real_apps, self.models)
209 
210     @property
211     def concrete_apps(self):
212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)
213         return self.apps
214 
215     @classmethod
216     def from_apps(cls, apps):
217         """Take an Apps and return a ProjectState matching it."""
218         app_models = {}
219         for model in apps.get_models(include_swapped=True):
220             model_state = ModelState.from_model(model)
221             app_models[(model_state.app_label, model_state.name_lower)] = model_state
222         return cls(app_models)
223 
224     def __eq__(self, other):
225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)
226 
227 
228 class AppConfigStub(AppConfig):
229     """Stub of an AppConfig. Only provides a label and a dict of models."""
230     def __init__(self, label):
231         self.apps = None
232         self.models = {}
233         # App-label and app-name are not the same thing, so technically passing
234         # in the label here is wrong. In practice, migrations don't care about
235         # the app name, but we need something unique, and the label works fine.
236         self.label = label
237         self.name = label
238 
239     def import_models(self):
240         self.models = self.apps.all_models[self.label]
241 
242 
243 class StateApps(Apps):
244     """
245     Subclass of the global Apps registry class to better handle dynamic model
246     additions and removals.
247     """
248     def __init__(self, real_apps, models, ignore_swappable=False):
249         # Any apps in self.real_apps should have all their models included
250         # in the render. We don't use the original model instances as there
251         # are some variables that refer to the Apps object.
252         # FKs/M2Ms from real apps are also not included as they just
253         # mess things up with partial states (due to lack of dependencies)
254         self.real_models = []
255         for app_label in real_apps:
256             app = global_apps.get_app_config(app_label)
257             for model in app.get_models():
258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
259         # Populate the app registry with a stub for each application.
260         app_labels = {model_state.app_label for model_state in models.values()}
261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]
262         super().__init__(app_configs)
263 
264         # These locks get in the way of copying as implemented in clone(),
265         # which is called whenever Django duplicates a StateApps before
266         # updating it.
267         self._lock = None
268         self.ready_event = None
269 
270         self.render_multiple([*models.values(), *self.real_models])
271 
272         # There shouldn't be any operations pending at this point.
273         from django.core.checks.model_checks import _check_lazy_references
274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
275         errors = _check_lazy_references(self, ignore=ignore)
276         if errors:
277             raise ValueError("\n".join(error.msg for error in errors))
278 
279     @contextmanager
280     def bulk_update(self):
281         # Avoid clearing each model's cache for each change. Instead, clear
282         # all caches when we're finished updating the model instances.
283         ready = self.ready
284         self.ready = False
285         try:
286             yield
287         finally:
288             self.ready = ready
289             self.clear_cache()
290 
291     def render_multiple(self, model_states):
292         # We keep trying to render the models in a loop, ignoring invalid
293         # base errors, until the size of the unrendered models doesn't
294         # decrease by at least one, meaning there's a base dependency loop/
295         # missing base.
296         if not model_states:
297             return
298         # Prevent that all model caches are expired for each render.
299         with self.bulk_update():
300             unrendered_models = model_states
301             while unrendered_models:
302                 new_unrendered_models = []
303                 for model in unrendered_models:
304                     try:
305                         model.render(self)
306                     except InvalidBasesError:
307                         new_unrendered_models.append(model)
308                 if len(new_unrendered_models) == len(unrendered_models):
309                     raise InvalidBasesError(
310                         "Cannot resolve bases for %r\nThis can happen if you are inheriting models from an "
311                         "app with migrations (e.g. contrib.auth)\n in an app with no migrations; see "
312                         "https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies "
313                         "for more" % (new_unrendered_models, get_docs_version())
314                     )
315                 unrendered_models = new_unrendered_models
316 
317     def clone(self):
318         """Return a clone of this registry."""
319         clone = StateApps([], {})
320         clone.all_models = copy.deepcopy(self.all_models)
321         clone.app_configs = copy.deepcopy(self.app_configs)
322         # Set the pointer to the correct app registry.
323         for app_config in clone.app_configs.values():
324             app_config.apps = clone
325         # No need to actually clone them, they'll never change
326         clone.real_models = self.real_models
327         return clone
328 
329     def register_model(self, app_label, model):
330         self.all_models[app_label][model._meta.model_name] = model
331         if app_label not in self.app_configs:
332             self.app_configs[app_label] = AppConfigStub(app_label)
333             self.app_configs[app_label].apps = self
334         self.app_configs[app_label].models[model._meta.model_name] = model
335         self.do_pending_operations(model)
336         self.clear_cache()
337 
338     def unregister_model(self, app_label, model_name):
339         try:
340             del self.all_models[app_label][model_name]
341             del self.app_configs[app_label].models[model_name]
342         except KeyError:
343             pass
344 
345 
346 class ModelState:
347     """
348     Represent a Django Model. Don't use the actual Model class as it's not
349     designed to have its options changed - instead, mutate this one and then
350     render it into a Model as required.
351 
352     Note that while you are allowed to mutate .fields, you are not allowed
353     to mutate the Field instances inside there themselves - you must instead
354     assign new ones, as these are not detached during a clone.
355     """
356 
357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):
358         self.app_label = app_label
359         self.name = name
360         self.fields = dict(fields)
361         self.options = options or {}
362         self.options.setdefault('indexes', [])
363         self.options.setdefault('constraints', [])
364         self.bases = bases or (models.Model,)
365         self.managers = managers or []
366         for name, field in self.fields.items():
367             # Sanity-check that fields are NOT already bound to a model.
368             if hasattr(field, 'model'):
369                 raise ValueError(
370                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
371                 )
372             # Sanity-check that relation fields are NOT referring to a model class.
373             if field.is_relation and hasattr(field.related_model, '_meta'):
374                 raise ValueError(
375                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
376                     'Use a string reference instead.' % name
377                 )
378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):
379                 raise ValueError(
380                     'ModelState.fields cannot refer to a model class - "%s.through" does. '
381                     'Use a string reference instead.' % name
382                 )
383         # Sanity-check that indexes have their name set.
384         for index in self.options['indexes']:
385             if not index.name:
386                 raise ValueError(
387                     "Indexes passed to ModelState require a name attribute. "
388                     "%r doesn't have one." % index
389                 )
390 
391     @cached_property
392     def name_lower(self):
393         return self.name.lower()
394 
395     @classmethod
396     def from_model(cls, model, exclude_rels=False):
397         """Given a model, return a ModelState representing it."""
398         # Deconstruct the fields
399         fields = []
400         for field in model._meta.local_fields:
401             if getattr(field, "remote_field", None) and exclude_rels:
402                 continue
403             if isinstance(field, models.OrderWrt):
404                 continue
405             name = field.name
406             try:
407                 fields.append((name, field.clone()))
408             except TypeError as e:
409                 raise TypeError("Couldn't reconstruct field %s on %s: %s" % (
410                     name,
411                     model._meta.label,
412                     e,
413                 ))
414         if not exclude_rels:
415             for field in model._meta.local_many_to_many:
416                 name = field.name
417                 try:
418                     fields.append((name, field.clone()))
419                 except TypeError as e:
420                     raise TypeError("Couldn't reconstruct m2m field %s on %s: %s" % (
421                         name,
422                         model._meta.object_name,
423                         e,
424                     ))
425         # Extract the options
426         options = {}
427         for name in DEFAULT_NAMES:
428             # Ignore some special options
429             if name in ["apps", "app_label"]:
430                 continue
431             elif name in model._meta.original_attrs:
432                 if name == "unique_together":
433                     ut = model._meta.original_attrs["unique_together"]
434                     options[name] = set(normalize_together(ut))
435                 elif name == "index_together":
436                     it = model._meta.original_attrs["index_together"]
437                     options[name] = set(normalize_together(it))
438                 elif name == "indexes":
439                     indexes = [idx.clone() for idx in model._meta.indexes]
440                     for index in indexes:
441                         if not index.name:
442                             index.set_name_with_model(model)
443                     options['indexes'] = indexes
444                 elif name == 'constraints':
445                     options['constraints'] = [con.clone() for con in model._meta.constraints]
446                 else:
447                     options[name] = model._meta.original_attrs[name]
448         # If we're ignoring relationships, remove all field-listing model
449         # options (that option basically just means "make a stub model")
450         if exclude_rels:
451             for key in ["unique_together", "index_together", "order_with_respect_to"]:
452                 if key in options:
453                     del options[key]
454         # Private fields are ignored, so remove options that refer to them.
455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:
456             del options['order_with_respect_to']
457 
458         def flatten_bases(model):
459             bases = []
460             for base in model.__bases__:
461                 if hasattr(base, "_meta") and base._meta.abstract:
462                     bases.extend(flatten_bases(base))
463                 else:
464                     bases.append(base)
465             return bases
466 
467         # We can't rely on __mro__ directly because we only want to flatten
468         # abstract models and not the whole tree. However by recursing on
469         # __bases__ we may end up with duplicates and ordering issues, we
470         # therefore discard any duplicates and reorder the bases according
471         # to their index in the MRO.
472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))
473 
474         # Make our record
475         bases = tuple(
476             (
477                 base._meta.label_lower
478                 if hasattr(base, "_meta") else
479                 base
480             )
481             for base in flattened_bases
482         )
483         # Ensure at least one base inherits from models.Model
484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):
485             bases = (models.Model,)
486 
487         managers = []
488         manager_names = set()
489         default_manager_shim = None
490         for manager in model._meta.managers:
491             if manager.name in manager_names:
492                 # Skip overridden managers.
493                 continue
494             elif manager.use_in_migrations:
495                 # Copy managers usable in migrations.
496                 new_manager = copy.copy(manager)
497                 new_manager._set_creation_counter()
498             elif manager is model._base_manager or manager is model._default_manager:
499                 # Shim custom managers used as default and base managers.
500                 new_manager = models.Manager()
501                 new_manager.model = manager.model
502                 new_manager.name = manager.name
503                 if manager is model._default_manager:
504                     default_manager_shim = new_manager
505             else:
506                 continue
507             manager_names.add(manager.name)
508             managers.append((manager.name, new_manager))
509 
510         # Ignore a shimmed default manager called objects if it's the only one.
511         if managers == [('objects', default_manager_shim)]:
512             managers = []
513 
514         # Construct the new ModelState
515         return cls(
516             model._meta.app_label,
517             model._meta.object_name,
518             fields,
519             options,
520             bases,
521             managers,
522         )
523 
524     def construct_managers(self):
525         """Deep-clone the managers using deconstruction."""
526         # Sort all managers by their creation counter
527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
528         for mgr_name, manager in sorted_managers:
529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
530             if as_manager:
531                 qs_class = import_string(qs_path)
532                 yield mgr_name, qs_class.as_manager()
533             else:
534                 manager_class = import_string(manager_path)
535                 yield mgr_name, manager_class(*args, **kwargs)
536 
537     def clone(self):
538         """Return an exact copy of this ModelState."""
539         return self.__class__(
540             app_label=self.app_label,
541             name=self.name,
542             fields=dict(self.fields),
543             # Since options are shallow-copied here, operations such as
544             # AddIndex must replace their option (e.g 'indexes') rather
545             # than mutating it.
546             options=dict(self.options),
547             bases=self.bases,
548             managers=list(self.managers),
549         )
550 
551     def render(self, apps):
552         """Create a Model object from our current state into the given apps."""
553         # First, make a Meta object
554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}
555         meta = type("Meta", (), meta_contents)
556         # Then, work out our bases
557         try:
558             bases = tuple(
559                 (apps.get_model(base) if isinstance(base, str) else base)
560                 for base in self.bases
561             )
562         except LookupError:
563             raise InvalidBasesError("Cannot resolve one or more bases from %r" % (self.bases,))
564         # Clone fields for the body, add other bits.
565         body = {name: field.clone() for name, field in self.fields.items()}
566         body['Meta'] = meta
567         body['__module__'] = "__fake__"
568 
569         # Restore managers
570         body.update(self.construct_managers())
571         # Then, make a Model object (apps.register_model is called in __new__)
572         return type(self.name, bases, body)
573 
574     def get_index_by_name(self, name):
575         for index in self.options['indexes']:
576             if index.name == name:
577                 return index
578         raise ValueError("No index named %s on model %s" % (name, self.name))
579 
580     def get_constraint_by_name(self, name):
581         for constraint in self.options['constraints']:
582             if constraint.name == name:
583                 return constraint
584         raise ValueError('No constraint named %s on model %s' % (name, self.name))
585 
586     def __repr__(self):
587         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
588 
589     def __eq__(self, other):
590         return (
591             (self.app_label == other.app_label) and
592             (self.name == other.name) and
593             (len(self.fields) == len(other.fields)) and
594             all(
595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
596                 for (k1, f1), (k2, f2) in zip(
597                     sorted(self.fields.items()),
598                     sorted(other.fields.items()),
599                 )
600             ) and
601             (self.options == other.options) and
602             (self.bases == other.bases) and
603             (self.managers == other.managers)
604         )

</code><intended_behavior>Ensure that the project state construction and validation logic properly scope model identifiers with app labels, thereby allowing models in different apps to share names without causing fields.E305 related to ManyToManyField relations. This could involve: Enhancing the logic that validates model names and related field attributes to consider the app label as part of the identity. This way, even if models share names (and have similar ManyToManyField configurations), they are treated as distinct as long as they reside in different apps.</intended_behavior>]
2025-10-15 18:43:21.717 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_order_with_respect_to()
186         self.generate_altered_unique_together()
187         self.generate_altered_index_together()
188         self.generate_added_indexes()
189         self.generate_added_constraints()
190         self.generate_altered_db_table()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             if order_with_respect_to:
617                 self.add_operation(
618                     app_label,
619                     operations.AlterOrderWithRespectTo(
620                         name=model_name,
621                         order_with_respect_to=order_with_respect_to,
622                     ),
623                     dependencies=[
624                         (app_label, model_name, order_with_respect_to, True),
625                         (app_label, model_name, None, True),
626                     ]
627                 )
628             related_dependencies = [
629                 (app_label, model_name, name, True)
630                 for name in sorted(related_fields)
631             ]
632             related_dependencies.append((app_label, model_name, None, True))
633             for index in indexes:
634                 self.add_operation(
635                     app_label,
636                     operations.AddIndex(
637                         model_name=model_name,
638                         index=index,
639                     ),
640                     dependencies=related_dependencies,
641                 )
642             for constraint in constraints:
643                 self.add_operation(
644                     app_label,
645                     operations.AddConstraint(
646                         model_name=model_name,
647                         constraint=constraint,
648                     ),
649                     dependencies=related_dependencies,
650                 )
651             if unique_together:
652                 self.add_operation(
653                     app_label,
654                     operations.AlterUniqueTogether(
655                         name=model_name,
656                         unique_together=unique_together,
657                     ),
658                     dependencies=related_dependencies
659                 )
660             if index_together:
661                 self.add_operation(
662                     app_label,
663                     operations.AlterIndexTogether(
664                         name=model_name,
665                         index_together=index_together,
666                     ),
667                     dependencies=related_dependencies
668                 )
669             # Fix relationships if the model changed from a proxy model to a
670             # concrete model.
671             if (app_label, model_name) in self.old_proxy_keys:
672                 for related_object in model_opts.related_objects:
673                     self.add_operation(
674                         related_object.related_model._meta.app_label,
675                         operations.AlterField(
676                             model_name=related_object.related_model._meta.object_name,
677                             name=related_object.field.name,
678                             field=related_object.field,
679                         ),
680                         dependencies=[(app_label, model_name, None, True)],
681                     )
682 
683     def generate_created_proxies(self):
684         """
685         Make CreateModel statements for proxy models. Use the same statements
686         as that way there's less code duplication, but for proxy models it's
687         safe to skip all the pointless field stuff and chuck out an operation.
688         """
689         added = self.new_proxy_keys - self.old_proxy_keys
690         for app_label, model_name in sorted(added):
691             model_state = self.to_state.models[app_label, model_name]
692             assert model_state.options.get("proxy")
693             # Depend on the deletion of any possible non-proxy version of us
694             dependencies = [
695                 (app_label, model_name, None, False),
696             ]
697             # Depend on all bases
698             for base in model_state.bases:
699                 if isinstance(base, str) and "." in base:
700                     base_app_label, base_name = base.split(".", 1)
701                     dependencies.append((base_app_label, base_name, None, True))
702             # Generate creation operation
703             self.add_operation(
704                 app_label,
705                 operations.CreateModel(
706                     name=model_state.name,
707                     fields=[],
708                     options=model_state.options,
709                     bases=model_state.bases,
710                     managers=model_state.managers,
711                 ),
712                 # Depend on the deletion of any possible non-proxy version of us
713                 dependencies=dependencies,
714             )
715 
716     def generate_deleted_models(self):
717         """
718         Find all deleted models (managed and unmanaged) and make delete
719         operations for them as well as separate operations to delete any
720         foreign key or M2M relationships (these are optimized later, if
721         possible).
722 
723         Also bring forward removal of any model options that refer to
724         collections of fields - the inverse of generate_created_models().
725         """
726         new_keys = self.new_model_keys | self.new_unmanaged_keys
727         deleted_models = self.old_model_keys - new_keys
728         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
729         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
730         for app_label, model_name in all_deleted_models:
731             model_state = self.from_state.models[app_label, model_name]
732             model = self.old_apps.get_model(app_label, model_name)
733             # Gather related fields
734             related_fields = {}
735             for field in model._meta.local_fields:
736                 if field.remote_field:
737                     if field.remote_field.model:
738                         related_fields[field.name] = field
739                     # through will be none on M2Ms on swapped-out models;
740                     # we can treat lack of through as auto_created=True, though.
741                     if (getattr(field.remote_field, "through", None) and
742                             not field.remote_field.through._meta.auto_created):
743                         related_fields[field.name] = field
744             for field in model._meta.local_many_to_many:
745                 if field.remote_field.model:
746                     related_fields[field.name] = field
747                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
748                     related_fields[field.name] = field
749             # Generate option removal first
750             unique_together = model_state.options.pop('unique_together', None)
751             index_together = model_state.options.pop('index_together', None)
752             if unique_together:
753                 self.add_operation(
754                     app_label,
755                     operations.AlterUniqueTogether(
756                         name=model_name,
757                         unique_together=None,
758                     )
759                 )
760             if index_together:
761                 self.add_operation(
762                     app_label,
763                     operations.AlterIndexTogether(
764                         name=model_name,
765                         index_together=None,
766                     )
767                 )
768             # Then remove each related field
769             for name in sorted(related_fields):
770                 self.add_operation(
771                     app_label,
772                     operations.RemoveField(
773                         model_name=model_name,
774                         name=name,
775                     )
776                 )
777             # Finally, remove the model.
778             # This depends on both the removal/alteration of all incoming fields
779             # and the removal of all its own related fields, and if it's
780             # a through model the field that references it.
781             dependencies = []
782             for related_object in model._meta.related_objects:
783                 related_object_app_label = related_object.related_model._meta.app_label
784                 object_name = related_object.related_model._meta.object_name
785                 field_name = related_object.field.name
786                 dependencies.append((related_object_app_label, object_name, field_name, False))
787                 if not related_object.many_to_many:
788                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
789 
790             for name in sorted(related_fields):
791                 dependencies.append((app_label, model_name, name, False))
792             # We're referenced in another field's through=
793             through_user = self.through_users.get((app_label, model_state.name_lower))
794             if through_user:
795                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
796             # Finally, make the operation, deduping any dependencies
797             self.add_operation(
798                 app_label,
799                 operations.DeleteModel(
800                     name=model_state.name,
801                 ),
802                 dependencies=list(set(dependencies)),
803             )
804 
805     def generate_deleted_proxies(self):
806         """Make DeleteModel options for proxy models."""
807         deleted = self.old_proxy_keys - self.new_proxy_keys
808         for app_label, model_name in sorted(deleted):
809             model_state = self.from_state.models[app_label, model_name]
810             assert model_state.options.get("proxy")
811             self.add_operation(
812                 app_label,
813                 operations.DeleteModel(
814                     name=model_state.name,
815                 ),
816             )
817 
818     def generate_renamed_fields(self):
819         """Work out renamed fields."""
820         self.renamed_fields = {}
821         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
822             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
823             old_model_state = self.from_state.models[app_label, old_model_name]
824             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
825             # Scan to see if this is actually a rename!
826             field_dec = self.deep_deconstruct(field)
827             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
828                 if rem_app_label == app_label and rem_model_name == model_name:
829                     old_field = old_model_state.fields[rem_field_name]
830                     old_field_dec = self.deep_deconstruct(old_field)
831                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
832                         old_rel_to = old_field_dec[2]['to']
833                         if old_rel_to in self.renamed_models_rel:
834                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
835                     old_field.set_attributes_from_name(rem_field_name)
836                     old_db_column = old_field.get_attname_column()[1]
837                     if (old_field_dec == field_dec or (
838                             # Was the field renamed and db_column equal to the
839                             # old field's column added?
840                             old_field_dec[0:2] == field_dec[0:2] and
841                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
842                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
843                             self.add_operation(
844                                 app_label,
845                                 operations.RenameField(
846                                     model_name=model_name,
847                                     old_name=rem_field_name,
848                                     new_name=field_name,
849                                 )
850                             )
851                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
852                             self.old_field_keys.add((app_label, model_name, field_name))
853                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
854                             break
855 
856     def generate_added_fields(self):
857         """Make AddField operations."""
858         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
859             self._generate_added_field(app_label, model_name, field_name)
860 
861     def _generate_added_field(self, app_label, model_name, field_name):
862         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
863         # Fields that are foreignkeys/m2ms depend on stuff
864         dependencies = []
865         if field.remote_field and field.remote_field.model:
866             dependencies.extend(self._get_dependencies_for_foreign_key(field))
867         # You can't just add NOT NULL fields with no default or fields
868         # which don't allow empty strings as default.
869         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
870         preserve_default = (
871             field.null or field.has_default() or field.many_to_many or
872             (field.blank and field.empty_strings_allowed) or
873             (isinstance(field, time_fields) and field.auto_now)
874         )
875         if not preserve_default:
876             field = field.clone()
877             if isinstance(field, time_fields) and field.auto_now_add:
878                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
879             else:
880                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
881         self.add_operation(
882             app_label,
883             operations.AddField(
884                 model_name=model_name,
885                 name=field_name,
886                 field=field,
887                 preserve_default=preserve_default,
888             ),
889             dependencies=dependencies,
890         )
891 
892     def generate_removed_fields(self):
893         """Make RemoveField operations."""
894         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
895             self._generate_removed_field(app_label, model_name, field_name)
896 
897     def _generate_removed_field(self, app_label, model_name, field_name):
898         self.add_operation(
899             app_label,
900             operations.RemoveField(
901                 model_name=model_name,
902                 name=field_name,
903             ),
904             # We might need to depend on the removal of an
905             # order_with_respect_to or index/unique_together operation;
906             # this is safely ignored if there isn't one
907             dependencies=[
908                 (app_label, model_name, field_name, "order_wrt_unset"),
909                 (app_label, model_name, field_name, "foo_together_change"),
910             ],
911         )
912 
913     def generate_altered_fields(self):
914         """
915         Make AlterField operations, or possibly RemovedField/AddField if alter
916         isn's possible.
917         """
918         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
919             # Did the field change?
920             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
921             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
922             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
923             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
924             dependencies = []
925             # Implement any model renames on relations; these are handled by RenameModel
926             # so we need to exclude them from the comparison
927             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
928                 rename_key = (
929                     new_field.remote_field.model._meta.app_label,
930                     new_field.remote_field.model._meta.model_name,
931                 )
932                 if rename_key in self.renamed_models:
933                     new_field.remote_field.model = old_field.remote_field.model
934                 # Handle ForeignKey which can only have a single to_field.
935                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
936                 if remote_field_name:
937                     to_field_rename_key = rename_key + (remote_field_name,)
938                     if to_field_rename_key in self.renamed_fields:
939                         # Repoint both model and field name because to_field
940                         # inclusion in ForeignKey.deconstruct() is based on
941                         # both.
942                         new_field.remote_field.model = old_field.remote_field.model
943                         new_field.remote_field.field_name = old_field.remote_field.field_name
944                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
945                 from_fields = getattr(new_field, 'from_fields', None)
946                 if from_fields:
947                     from_rename_key = (app_label, model_name)
948                     new_field.from_fields = tuple([
949                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
950                         for from_field in from_fields
951                     ])
952                     new_field.to_fields = tuple([
953                         self.renamed_fields.get(rename_key + (to_field,), to_field)
954                         for to_field in new_field.to_fields
955                     ])
956                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
957             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
958                 rename_key = (
959                     new_field.remote_field.through._meta.app_label,
960                     new_field.remote_field.through._meta.model_name,
961                 )
962                 if rename_key in self.renamed_models:
963                     new_field.remote_field.through = old_field.remote_field.through
964             old_field_dec = self.deep_deconstruct(old_field)
965             new_field_dec = self.deep_deconstruct(new_field)
966             if old_field_dec != new_field_dec:
967                 both_m2m = old_field.many_to_many and new_field.many_to_many
968                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
969                 if both_m2m or neither_m2m:
970                     # Either both fields are m2m or neither is
971                     preserve_default = True
972                     if (old_field.null and not new_field.null and not new_field.has_default() and
973                             not new_field.many_to_many):
974                         field = new_field.clone()
975                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
976                         if new_default is not models.NOT_PROVIDED:
977                             field.default = new_default
978                             preserve_default = False
979                     else:
980                         field = new_field
981                     self.add_operation(
982                         app_label,
983                         operations.AlterField(
984                             model_name=model_name,
985                             name=field_name,
986                             field=field,
987                             preserve_default=preserve_default,
988                         ),
989                         dependencies=dependencies,
990                     )
991                 else:
992                     # We cannot alter between m2m and concrete fields
993                     self._generate_removed_field(app_label, model_name, field_name)
994                     self._generate_added_field(app_label, model_name, field_name)
995 
996     def create_altered_indexes(self):
997         option_name = operations.AddIndex.option_name
998         for app_label, model_name in sorted(self.kept_model_keys):
999             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1000             old_model_state = self.from_state.models[app_label, old_model_name]
1001             new_model_state = self.to_state.models[app_label, model_name]
1002 
1003             old_indexes = old_model_state.options[option_name]
1004             new_indexes = new_model_state.options[option_name]
1005             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1006             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1007 
1008             self.altered_indexes.update({
1009                 (app_label, model_name): {
1010                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1011                 }
1012             })
1013 
1014     def generate_added_indexes(self):
1015         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1016             for index in alt_indexes['added_indexes']:
1017                 self.add_operation(
1018                     app_label,
1019                     operations.AddIndex(
1020                         model_name=model_name,
1021                         index=index,
1022                     )
1023                 )
1024 
1025     def generate_removed_indexes(self):
1026         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1027             for index in alt_indexes['removed_indexes']:
1028                 self.add_operation(
1029                     app_label,
1030                     operations.RemoveIndex(
1031                         model_name=model_name,
1032                         name=index.name,
1033                     )
1034                 )
1035 
1036     def create_altered_constraints(self):
1037         option_name = operations.AddConstraint.option_name
1038         for app_label, model_name in sorted(self.kept_model_keys):
1039             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1040             old_model_state = self.from_state.models[app_label, old_model_name]
1041             new_model_state = self.to_state.models[app_label, model_name]
1042 
1043             old_constraints = old_model_state.options[option_name]
1044             new_constraints = new_model_state.options[option_name]
1045             add_constraints = [c for c in new_constraints if c not in old_constraints]
1046             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1047 
1048             self.altered_constraints.update({
1049                 (app_label, model_name): {
1050                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1051                 }
1052             })
1053 
1054     def generate_added_constraints(self):
1055         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1056             for constraint in alt_constraints['added_constraints']:
1057                 self.add_operation(
1058                     app_label,
1059                     operations.AddConstraint(
1060                         model_name=model_name,
1061                         constraint=constraint,
1062                     )
1063                 )
1064 
1065     def generate_removed_constraints(self):
1066         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1067             for constraint in alt_constraints['removed_constraints']:
1068                 self.add_operation(
1069                     app_label,
1070                     operations.RemoveConstraint(
1071                         model_name=model_name,
1072                         name=constraint.name,
1073                     )
1074                 )
1075 
1076     def _get_dependencies_for_foreign_key(self, field):
1077         # Account for FKs to swappable models
1078         swappable_setting = getattr(field, 'swappable_setting', None)
1079         if swappable_setting is not None:
1080             dep_app_label = "__setting__"
1081             dep_object_name = swappable_setting
1082         else:
1083             dep_app_label = field.remote_field.model._meta.app_label
1084             dep_object_name = field.remote_field.model._meta.object_name
1085         dependencies = [(dep_app_label, dep_object_name, None, True)]
1086         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1087             dependencies.append((
1088                 field.remote_field.through._meta.app_label,
1089                 field.remote_field.through._meta.object_name,
1090                 None,
1091                 True,
1092             ))
1093         return dependencies
1094 
1095     def _generate_altered_foo_together(self, operation):
1096         option_name = operation.option_name
1097         for app_label, model_name in sorted(self.kept_model_keys):
1098             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1099             old_model_state = self.from_state.models[app_label, old_model_name]
1100             new_model_state = self.to_state.models[app_label, model_name]
1101 
1102             # We run the old version through the field renames to account for those
1103             old_value = old_model_state.options.get(option_name)
1104             old_value = {
1105                 tuple(
1106                     self.renamed_fields.get((app_label, model_name, n), n)
1107                     for n in unique
1108                 )
1109                 for unique in old_value
1110             } if old_value else set()
1111 
1112             new_value = new_model_state.options.get(option_name)
1113             new_value = set(new_value) if new_value else set()
1114 
1115             if old_value != new_value:
1116                 dependencies = []
1117                 for foo_togethers in new_value:
1118                     for field_name in foo_togethers:
1119                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1120                         if field.remote_field and field.remote_field.model:
1121                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1122 
1123                 self.add_operation(
1124                     app_label,
1125                     operation(
1126                         name=model_name,
1127                         **{option_name: new_value}
1128                     ),
1129                     dependencies=dependencies,
1130                 )
1131 
1132     def generate_altered_unique_together(self):
1133         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1134 
1135     def generate_altered_index_together(self):
1136         self._generate_altered_foo_together(operations.AlterIndexTogether)
1137 
1138     def generate_altered_db_table(self):
1139         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1140         for app_label, model_name in sorted(models_to_check):
1141             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1142             old_model_state = self.from_state.models[app_label, old_model_name]
1143             new_model_state = self.to_state.models[app_label, model_name]
1144             old_db_table_name = old_model_state.options.get('db_table')
1145             new_db_table_name = new_model_state.options.get('db_table')
1146             if old_db_table_name != new_db_table_name:
1147                 self.add_operation(
1148                     app_label,
1149                     operations.AlterModelTable(
1150                         name=model_name,
1151                         table=new_db_table_name,
1152                     )
1153                 )
1154 
1155     def generate_altered_options(self):
1156         """
1157         Work out if any non-schema-affecting options have changed and make an
1158         operation to represent them in state changes (in case Python code in
1159         migrations needs them).
1160         """
1161         models_to_check = self.kept_model_keys.union(
1162             self.kept_proxy_keys,
1163             self.kept_unmanaged_keys,
1164             # unmanaged converted to managed
1165             self.old_unmanaged_keys & self.new_model_keys,
1166             # managed converted to unmanaged
1167             self.old_model_keys & self.new_unmanaged_keys,
1168         )
1169 
1170         for app_label, model_name in sorted(models_to_check):
1171             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1172             old_model_state = self.from_state.models[app_label, old_model_name]
1173             new_model_state = self.to_state.models[app_label, model_name]
1174             old_options = {
1175                 key: value for key, value in old_model_state.options.items()
1176                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1177             }
1178             new_options = {
1179                 key: value for key, value in new_model_state.options.items()
1180                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1181             }
1182             if old_options != new_options:
1183                 self.add_operation(
1184                     app_label,
1185                     operations.AlterModelOptions(
1186                         name=model_name,
1187                         options=new_options,
1188                     )
1189                 )
1190 
1191     def generate_altered_order_with_respect_to(self):
1192         for app_label, model_name in sorted(self.kept_model_keys):
1193             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1194             old_model_state = self.from_state.models[app_label, old_model_name]
1195             new_model_state = self.to_state.models[app_label, model_name]
1196             if (old_model_state.options.get("order_with_respect_to") !=
1197                     new_model_state.options.get("order_with_respect_to")):
1198                 # Make sure it comes second if we're adding
1199                 # (removal dependency is part of RemoveField)
1200                 dependencies = []
1201                 if new_model_state.options.get("order_with_respect_to"):
1202                     dependencies.append((
1203                         app_label,
1204                         model_name,
1205                         new_model_state.options["order_with_respect_to"],
1206                         True,
1207                     ))
1208                 # Actually generate the operation
1209                 self.add_operation(
1210                     app_label,
1211                     operations.AlterOrderWithRespectTo(
1212                         name=model_name,
1213                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1214                     ),
1215                     dependencies=dependencies,
1216                 )
1217 
1218     def generate_altered_managers(self):
1219         for app_label, model_name in sorted(self.kept_model_keys):
1220             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1221             old_model_state = self.from_state.models[app_label, old_model_name]
1222             new_model_state = self.to_state.models[app_label, model_name]
1223             if old_model_state.managers != new_model_state.managers:
1224                 self.add_operation(
1225                     app_label,
1226                     operations.AlterModelManagers(
1227                         name=model_name,
1228                         managers=new_model_state.managers,
1229                     )
1230                 )
1231 
1232     def arrange_for_graph(self, changes, graph, migration_name=None):
1233         """
1234         Take a result from changes() and a MigrationGraph, and fix the names
1235         and dependencies of the changes so they extend the graph from the leaf
1236         nodes for each app.
1237         """
1238         leaves = graph.leaf_nodes()
1239         name_map = {}
1240         for app_label, migrations in list(changes.items()):
1241             if not migrations:
1242                 continue
1243             # Find the app label's current leaf node
1244             app_leaf = None
1245             for leaf in leaves:
1246                 if leaf[0] == app_label:
1247                     app_leaf = leaf
1248                     break
1249             # Do they want an initial migration for this app?
1250             if app_leaf is None and not self.questioner.ask_initial(app_label):
1251                 # They don't.
1252                 for migration in migrations:
1253                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1254                 del changes[app_label]
1255                 continue
1256             # Work out the next number in the sequence
1257             if app_leaf is None:
1258                 next_number = 1
1259             else:
1260                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1261             # Name each migration
1262             for i, migration in enumerate(migrations):
1263                 if i == 0 and app_leaf:
1264                     migration.dependencies.append(app_leaf)
1265                 new_name_parts = ['%04i' % next_number]
1266                 if migration_name:
1267                     new_name_parts.append(migration_name)
1268                 elif i == 0 and not app_leaf:
1269                     new_name_parts.append('initial')
1270                 else:
1271                     new_name_parts.append(migration.suggest_name()[:100])
1272                 new_name = '_'.join(new_name_parts)
1273                 name_map[(app_label, migration.name)] = (app_label, new_name)
1274                 next_number += 1
1275                 migration.name = new_name
1276         # Now fix dependencies
1277         for migrations in changes.values():
1278             for migration in migrations:
1279                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1280         return changes
1281 
1282     def _trim_to_apps(self, changes, app_labels):
1283         """
1284         Take changes from arrange_for_graph() and set of app labels, and return
1285         a modified set of changes which trims out as many migrations that are
1286         not in app_labels as possible. Note that some other migrations may
1287         still be present as they may be required dependencies.
1288         """
1289         # Gather other app dependencies in a first pass
1290         app_dependencies = {}
1291         for app_label, migrations in changes.items():
1292             for migration in migrations:
1293                 for dep_app_label, name in migration.dependencies:
1294                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1295         required_apps = set(app_labels)
1296         # Keep resolving till there's no change
1297         old_required_apps = None
1298         while old_required_apps != required_apps:
1299             old_required_apps = set(required_apps)
1300             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1301         # Remove all migrations that aren't needed
1302         for app_label in list(changes):
1303             if app_label not in required_apps:
1304                 del changes[app_label]
1305         return changes
1306 
1307     @classmethod
1308     def parse_number(cls, name):
1309         """
1310         Given a migration name, try to extract a number from the beginning of
1311         it. If no number is found, return None.
1312         """
1313         match = re.match(r'^\d+', name)
1314         if match:
1315             return int(match[0])
1316         return None

</code><intended_behavior>The autodetector should correctly handle models with identical names across different apps when they use ManyToManyField with related_name='+', preventing fields.E305 errors. This means: Properly recognizing and respecting the related_name='+' to avoid unnecessary related name conflict checks between models in different apps. Ensuring that migration operations do not flag false positives for conflicts in ManyToManyField relations just because models share names across different Django apps.</intended_behavior>, <file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from contextlib import contextmanager
3 
4 from django.apps import AppConfig
5 from django.apps.registry import Apps, apps as global_apps
6 from django.conf import settings
7 from django.db import models
8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
9 from django.db.models.options import DEFAULT_NAMES, normalize_together
10 from django.db.models.utils import make_model_tuple
11 from django.utils.functional import cached_property
12 from django.utils.module_loading import import_string
13 from django.utils.version import get_docs_version
14 
15 from .exceptions import InvalidBasesError
16 
17 
18 def _get_app_label_and_model_name(model, app_label=''):
19     if isinstance(model, str):
20         split = model.split('.', 1)
21         return tuple(split) if len(split) == 2 else (app_label, split[0])
22     else:
23         return model._meta.app_label, model._meta.model_name
24 
25 
26 def _get_related_models(m):
27     """Return all models that have a direct relationship to the given model."""
28     related_models = [
29         subclass for subclass in m.__subclasses__()
30         if issubclass(subclass, models.Model)
31     ]
32     related_fields_models = set()
33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):
35             related_fields_models.add(f.model)
36             related_models.append(f.related_model)
37     # Reverse accessors of foreign keys to proxy models are attached to their
38     # concrete proxied model.
39     opts = m._meta
40     if opts.proxy and m in related_fields_models:
41         related_models.append(opts.concrete_model)
42     return related_models
43 
44 
45 def get_related_models_tuples(model):
46     """
47     Return a list of typical (app_label, model_name) tuples for all related
48     models for the given model.
49     """
50     return {
51         (rel_mod._meta.app_label, rel_mod._meta.model_name)
52         for rel_mod in _get_related_models(model)
53     }
54 
55 
56 def get_related_models_recursive(model):
57     """
58     Return all models that have a direct or indirect relationship
59     to the given model.
60 
61     Relationships are either defined by explicit relational fields, like
62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
63     model (a superclass is related to its subclasses, but not vice versa). Note,
64     however, that a model inheriting from a concrete model is also related to
65     its superclass through the implicit *_ptr OneToOneField on the subclass.
66     """
67     seen = set()
68     queue = _get_related_models(model)
69     for rel_mod in queue:
70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name
71         if (rel_app_label, rel_model_name) in seen:
72             continue
73         seen.add((rel_app_label, rel_model_name))
74         queue.extend(_get_related_models(rel_mod))
75     return seen - {(model._meta.app_label, model._meta.model_name)}
76 
77 
78 class ProjectState:
79     """
80     Represent the entire project's overall state. This is the item that is
81     passed around - do it here rather than at the app level so that cross-app
82     FKs/etc. resolve properly.
83     """
84 
85     def __init__(self, models=None, real_apps=None):
86         self.models = models or {}
87         # Apps to include from main registry, usually unmigrated ones
88         self.real_apps = real_apps or []
89         self.is_delayed = False
90 
91     def add_model(self, model_state):
92         app_label, model_name = model_state.app_label, model_state.name_lower
93         self.models[(app_label, model_name)] = model_state
94         if 'apps' in self.__dict__:  # hasattr would cache the property
95             self.reload_model(app_label, model_name)
96 
97     def remove_model(self, app_label, model_name):
98         del self.models[app_label, model_name]
99         if 'apps' in self.__dict__:  # hasattr would cache the property
100             self.apps.unregister_model(app_label, model_name)
101             # Need to do this explicitly since unregister_model() doesn't clear
102             # the cache automatically (#24513)
103             self.apps.clear_cache()
104 
105     def _find_reload_model(self, app_label, model_name, delay=False):
106         if delay:
107             self.is_delayed = True
108 
109         related_models = set()
110 
111         try:
112             old_model = self.apps.get_model(app_label, model_name)
113         except LookupError:
114             pass
115         else:
116             # Get all relations to and from the old model before reloading,
117             # as _meta.apps may change
118             if delay:
119                 related_models = get_related_models_tuples(old_model)
120             else:
121                 related_models = get_related_models_recursive(old_model)
122 
123         # Get all outgoing references from the model to be rendered
124         model_state = self.models[(app_label, model_name)]
125         # Directly related models are the models pointed to by ForeignKeys,
126         # OneToOneFields, and ManyToManyFields.
127         direct_related_models = set()
128         for field in model_state.fields.values():
129             if field.is_relation:
130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
131                     continue
132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)
133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
134 
135         # For all direct related models recursively get all related models.
136         related_models.update(direct_related_models)
137         for rel_app_label, rel_model_name in direct_related_models:
138             try:
139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
140             except LookupError:
141                 pass
142             else:
143                 if delay:
144                     related_models.update(get_related_models_tuples(rel_model))
145                 else:
146                     related_models.update(get_related_models_recursive(rel_model))
147 
148         # Include the model itself
149         related_models.add((app_label, model_name))
150 
151         return related_models
152 
153     def reload_model(self, app_label, model_name, delay=False):
154         if 'apps' in self.__dict__:  # hasattr would cache the property
155             related_models = self._find_reload_model(app_label, model_name, delay)
156             self._reload(related_models)
157 
158     def reload_models(self, models, delay=True):
159         if 'apps' in self.__dict__:  # hasattr would cache the property
160             related_models = set()
161             for app_label, model_name in models:
162                 related_models.update(self._find_reload_model(app_label, model_name, delay))
163             self._reload(related_models)
164 
165     def _reload(self, related_models):
166         # Unregister all related models
167         with self.apps.bulk_update():
168             for rel_app_label, rel_model_name in related_models:
169                 self.apps.unregister_model(rel_app_label, rel_model_name)
170 
171         states_to_be_rendered = []
172         # Gather all models states of those models that will be rerendered.
173         # This includes:
174         # 1. All related models of unmigrated apps
175         for model_state in self.apps.real_models:
176             if (model_state.app_label, model_state.name_lower) in related_models:
177                 states_to_be_rendered.append(model_state)
178 
179         # 2. All related models of migrated apps
180         for rel_app_label, rel_model_name in related_models:
181             try:
182                 model_state = self.models[rel_app_label, rel_model_name]
183             except KeyError:
184                 pass
185             else:
186                 states_to_be_rendered.append(model_state)
187 
188         # Render all models
189         self.apps.render_multiple(states_to_be_rendered)
190 
191     def clone(self):
192         """Return an exact copy of this ProjectState."""
193         new_state = ProjectState(
194             models={k: v.clone() for k, v in self.models.items()},
195             real_apps=self.real_apps,
196         )
197         if 'apps' in self.__dict__:
198             new_state.apps = self.apps.clone()
199         new_state.is_delayed = self.is_delayed
200         return new_state
201 
202     def clear_delayed_apps_cache(self):
203         if self.is_delayed and 'apps' in self.__dict__:
204             del self.__dict__['apps']
205 
206     @cached_property
207     def apps(self):
208         return StateApps(self.real_apps, self.models)
209 
210     @property
211     def concrete_apps(self):
212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)
213         return self.apps
214 
215     @classmethod
216     def from_apps(cls, apps):
217         """Take an Apps and return a ProjectState matching it."""
218         app_models = {}
219         for model in apps.get_models(include_swapped=True):
220             model_state = ModelState.from_model(model)
221             app_models[(model_state.app_label, model_state.name_lower)] = model_state
222         return cls(app_models)
223 
224     def __eq__(self, other):
225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)
226 
227 
228 class AppConfigStub(AppConfig):
229     """Stub of an AppConfig. Only provides a label and a dict of models."""
230     def __init__(self, label):
231         self.apps = None
232         self.models = {}
233         # App-label and app-name are not the same thing, so technically passing
234         # in the label here is wrong. In practice, migrations don't care about
235         # the app name, but we need something unique, and the label works fine.
236         self.label = label
237         self.name = label
238 
239     def import_models(self):
240         self.models = self.apps.all_models[self.label]
241 
242 
243 class StateApps(Apps):
244     """
245     Subclass of the global Apps registry class to better handle dynamic model
246     additions and removals.
247     """
248     def __init__(self, real_apps, models, ignore_swappable=False):
249         # Any apps in self.real_apps should have all their models included
250         # in the render. We don't use the original model instances as there
251         # are some variables that refer to the Apps object.
252         # FKs/M2Ms from real apps are also not included as they just
253         # mess things up with partial states (due to lack of dependencies)
254         self.real_models = []
255         for app_label in real_apps:
256             app = global_apps.get_app_config(app_label)
257             for model in app.get_models():
258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
259         # Populate the app registry with a stub for each application.
260         app_labels = {model_state.app_label for model_state in models.values()}
261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]
262         super().__init__(app_configs)
263 
264         # These locks get in the way of copying as implemented in clone(),
265         # which is called whenever Django duplicates a StateApps before
266         # updating it.
267         self._lock = None
268         self.ready_event = None
269 
270         self.render_multiple([*models.values(), *self.real_models])
271 
272         # There shouldn't be any operations pending at this point.
273         from django.core.checks.model_checks import _check_lazy_references
274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
275         errors = _check_lazy_references(self, ignore=ignore)
276         if errors:
277             raise ValueError("\n".join(error.msg for error in errors))
278 
279     @contextmanager
280     def bulk_update(self):
281         # Avoid clearing each model's cache for each change. Instead, clear
282         # all caches when we're finished updating the model instances.
283         ready = self.ready
284         self.ready = False
285         try:
286             yield
287         finally:
288             self.ready = ready
289             self.clear_cache()
290 
291     def render_multiple(self, model_states):
292         # We keep trying to render the models in a loop, ignoring invalid
293         # base errors, until the size of the unrendered models doesn't
294         # decrease by at least one, meaning there's a base dependency loop/
295         # missing base.
296         if not model_states:
297             return
298         # Prevent that all model caches are expired for each render.
299         with self.bulk_update():
300             unrendered_models = model_states
301             while unrendered_models:
302                 new_unrendered_models = []
303                 for model in unrendered_models:
304                     try:
305                         model.render(self)
306                     except InvalidBasesError:
307                         new_unrendered_models.append(model)
308                 if len(new_unrendered_models) == len(unrendered_models):
309                     raise InvalidBasesError(
310                         "Cannot resolve bases for %r\nThis can happen if you are inheriting models from an "
311                         "app with migrations (e.g. contrib.auth)\n in an app with no migrations; see "
312                         "https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies "
313                         "for more" % (new_unrendered_models, get_docs_version())
314                     )
315                 unrendered_models = new_unrendered_models
316 
317     def clone(self):
318         """Return a clone of this registry."""
319         clone = StateApps([], {})
320         clone.all_models = copy.deepcopy(self.all_models)
321         clone.app_configs = copy.deepcopy(self.app_configs)
322         # Set the pointer to the correct app registry.
323         for app_config in clone.app_configs.values():
324             app_config.apps = clone
325         # No need to actually clone them, they'll never change
326         clone.real_models = self.real_models
327         return clone
328 
329     def register_model(self, app_label, model):
330         self.all_models[app_label][model._meta.model_name] = model
331         if app_label not in self.app_configs:
332             self.app_configs[app_label] = AppConfigStub(app_label)
333             self.app_configs[app_label].apps = self
334         self.app_configs[app_label].models[model._meta.model_name] = model
335         self.do_pending_operations(model)
336         self.clear_cache()
337 
338     def unregister_model(self, app_label, model_name):
339         try:
340             del self.all_models[app_label][model_name]
341             del self.app_configs[app_label].models[model_name]
342         except KeyError:
343             pass
344 
345 
346 class ModelState:
347     """
348     Represent a Django Model. Don't use the actual Model class as it's not
349     designed to have its options changed - instead, mutate this one and then
350     render it into a Model as required.
351 
352     Note that while you are allowed to mutate .fields, you are not allowed
353     to mutate the Field instances inside there themselves - you must instead
354     assign new ones, as these are not detached during a clone.
355     """
356 
357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):
358         self.app_label = app_label
359         self.name = name
360         self.fields = dict(fields)
361         self.options = options or {}
362         self.options.setdefault('indexes', [])
363         self.options.setdefault('constraints', [])
364         self.bases = bases or (models.Model,)
365         self.managers = managers or []
366         for name, field in self.fields.items():
367             # Sanity-check that fields are NOT already bound to a model.
368             if hasattr(field, 'model'):
369                 raise ValueError(
370                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
371                 )
372             # Sanity-check that relation fields are NOT referring to a model class.
373             if field.is_relation and hasattr(field.related_model, '_meta'):
374                 raise ValueError(
375                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
376                     'Use a string reference instead.' % name
377                 )
378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):
379                 raise ValueError(
380                     'ModelState.fields cannot refer to a model class - "%s.through" does. '
381                     'Use a string reference instead.' % name
382                 )
383         # Sanity-check that indexes have their name set.
384         for index in self.options['indexes']:
385             if not index.name:
386                 raise ValueError(
387                     "Indexes passed to ModelState require a name attribute. "
388                     "%r doesn't have one." % index
389                 )
390 
391     @cached_property
392     def name_lower(self):
393         return self.name.lower()
394 
395     @classmethod
396     def from_model(cls, model, exclude_rels=False):
397         """Given a model, return a ModelState representing it."""
398         # Deconstruct the fields
399         fields = []
400         for field in model._meta.local_fields:
401             if getattr(field, "remote_field", None) and exclude_rels:
402                 continue
403             if isinstance(field, models.OrderWrt):
404                 continue
405             name = field.name
406             try:
407                 fields.append((name, field.clone()))
408             except TypeError as e:
409                 raise TypeError("Couldn't reconstruct field %s on %s: %s" % (
410                     name,
411                     model._meta.label,
412                     e,
413                 ))
414         if not exclude_rels:
415             for field in model._meta.local_many_to_many:
416                 name = field.name
417                 try:
418                     fields.append((name, field.clone()))
419                 except TypeError as e:
420                     raise TypeError("Couldn't reconstruct m2m field %s on %s: %s" % (
421                         name,
422                         model._meta.object_name,
423                         e,
424                     ))
425         # Extract the options
426         options = {}
427         for name in DEFAULT_NAMES:
428             # Ignore some special options
429             if name in ["apps", "app_label"]:
430                 continue
431             elif name in model._meta.original_attrs:
432                 if name == "unique_together":
433                     ut = model._meta.original_attrs["unique_together"]
434                     options[name] = set(normalize_together(ut))
435                 elif name == "index_together":
436                     it = model._meta.original_attrs["index_together"]
437                     options[name] = set(normalize_together(it))
438                 elif name == "indexes":
439                     indexes = [idx.clone() for idx in model._meta.indexes]
440                     for index in indexes:
441                         if not index.name:
442                             index.set_name_with_model(model)
443                     options['indexes'] = indexes
444                 elif name == 'constraints':
445                     options['constraints'] = [con.clone() for con in model._meta.constraints]
446                 else:
447                     options[name] = model._meta.original_attrs[name]
448         # If we're ignoring relationships, remove all field-listing model
449         # options (that option basically just means "make a stub model")
450         if exclude_rels:
451             for key in ["unique_together", "index_together", "order_with_respect_to"]:
452                 if key in options:
453                     del options[key]
454         # Private fields are ignored, so remove options that refer to them.
455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:
456             del options['order_with_respect_to']
457 
458         def flatten_bases(model):
459             bases = []
460             for base in model.__bases__:
461                 if hasattr(base, "_meta") and base._meta.abstract:
462                     bases.extend(flatten_bases(base))
463                 else:
464                     bases.append(base)
465             return bases
466 
467         # We can't rely on __mro__ directly because we only want to flatten
468         # abstract models and not the whole tree. However by recursing on
469         # __bases__ we may end up with duplicates and ordering issues, we
470         # therefore discard any duplicates and reorder the bases according
471         # to their index in the MRO.
472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))
473 
474         # Make our record
475         bases = tuple(
476             (
477                 base._meta.label_lower
478                 if hasattr(base, "_meta") else
479                 base
480             )
481             for base in flattened_bases
482         )
483         # Ensure at least one base inherits from models.Model
484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):
485             bases = (models.Model,)
486 
487         managers = []
488         manager_names = set()
489         default_manager_shim = None
490         for manager in model._meta.managers:
491             if manager.name in manager_names:
492                 # Skip overridden managers.
493                 continue
494             elif manager.use_in_migrations:
495                 # Copy managers usable in migrations.
496                 new_manager = copy.copy(manager)
497                 new_manager._set_creation_counter()
498             elif manager is model._base_manager or manager is model._default_manager:
499                 # Shim custom managers used as default and base managers.
500                 new_manager = models.Manager()
501                 new_manager.model = manager.model
502                 new_manager.name = manager.name
503                 if manager is model._default_manager:
504                     default_manager_shim = new_manager
505             else:
506                 continue
507             manager_names.add(manager.name)
508             managers.append((manager.name, new_manager))
509 
510         # Ignore a shimmed default manager called objects if it's the only one.
511         if managers == [('objects', default_manager_shim)]:
512             managers = []
513 
514         # Construct the new ModelState
515         return cls(
516             model._meta.app_label,
517             model._meta.object_name,
518             fields,
519             options,
520             bases,
521             managers,
522         )
523 
524     def construct_managers(self):
525         """Deep-clone the managers using deconstruction."""
526         # Sort all managers by their creation counter
527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
528         for mgr_name, manager in sorted_managers:
529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
530             if as_manager:
531                 qs_class = import_string(qs_path)
532                 yield mgr_name, qs_class.as_manager()
533             else:
534                 manager_class = import_string(manager_path)
535                 yield mgr_name, manager_class(*args, **kwargs)
536 
537     def clone(self):
538         """Return an exact copy of this ModelState."""
539         return self.__class__(
540             app_label=self.app_label,
541             name=self.name,
542             fields=dict(self.fields),
543             # Since options are shallow-copied here, operations such as
544             # AddIndex must replace their option (e.g 'indexes') rather
545             # than mutating it.
546             options=dict(self.options),
547             bases=self.bases,
548             managers=list(self.managers),
549         )
550 
551     def render(self, apps):
552         """Create a Model object from our current state into the given apps."""
553         # First, make a Meta object
554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}
555         meta = type("Meta", (), meta_contents)
556         # Then, work out our bases
557         try:
558             bases = tuple(
559                 (apps.get_model(base) if isinstance(base, str) else base)
560                 for base in self.bases
561             )
562         except LookupError:
563             raise InvalidBasesError("Cannot resolve one or more bases from %r" % (self.bases,))
564         # Clone fields for the body, add other bits.
565         body = {name: field.clone() for name, field in self.fields.items()}
566         body['Meta'] = meta
567         body['__module__'] = "__fake__"
568 
569         # Restore managers
570         body.update(self.construct_managers())
571         # Then, make a Model object (apps.register_model is called in __new__)
572         return type(self.name, bases, body)
573 
574     def get_index_by_name(self, name):
575         for index in self.options['indexes']:
576             if index.name == name:
577                 return index
578         raise ValueError("No index named %s on model %s" % (name, self.name))
579 
580     def get_constraint_by_name(self, name):
581         for constraint in self.options['constraints']:
582             if constraint.name == name:
583                 return constraint
584         raise ValueError('No constraint named %s on model %s' % (name, self.name))
585 
586     def __repr__(self):
587         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
588 
589     def __eq__(self, other):
590         return (
591             (self.app_label == other.app_label) and
592             (self.name == other.name) and
593             (len(self.fields) == len(other.fields)) and
594             all(
595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
596                 for (k1, f1), (k2, f2) in zip(
597                     sorted(self.fields.items()),
598                     sorted(other.fields.items()),
599                 )
600             ) and
601             (self.options == other.options) and
602             (self.bases == other.bases) and
603             (self.managers == other.managers)
604         )

</code><intended_behavior>Ensure that the project state construction and validation logic properly scope model identifiers with app labels, thereby allowing models in different apps to share names without causing fields.E305 related to ManyToManyField relations. This could involve: Enhancing the logic that validates model names and related field attributes to consider the app label as part of the identity. This way, even if models share names (and have similar ManyToManyField configurations), they are treated as distinct as long as they reside in different apps.</intended_behavior>]
2025-10-15 18:43:21.717 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 18:43:21.718 | INFO     | Search-only: skipping patch selection
2025-10-15 18:43:21.855 | INFO     | Task django__django-13822 completed successfully.
2025-10-15 18:43:21.856 | INFO     | No patch generated. You can try running ACR again.
