2025-10-15 15:22:34.753 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:22:39.011 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=440, output_tokens=12, cost=0.004760
2025-10-15 15:22:39.012 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 15:22:39.016 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:22:49.186 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=546, output_tokens=399, cost=0.017430
2025-10-15 15:22:49.192 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:22:51.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=54, cost=0.009150
2025-10-15 15:22:51.308 | DEBUG    | Extracted a valid json.
2025-10-15 15:22:51.308 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Quantity\")",
        "search_method_in_class(\"mean\", \"Quantity\")",
        "search_code(\"np.mean\")",
        "search_code(\"kwargs\")"
    ],
    "bug_locations": []
}
2025-10-15 15:22:53.161 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:22:53.161 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:23:14.912 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5652, output_tokens=848, cost=0.081960
2025-10-15 15:23:14.921 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:23:22.489 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6716, output_tokens=223, cost=0.073850
2025-10-15 15:23:22.495 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:23:28.950 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=577, output_tokens=227, cost=0.012580
2025-10-15 15:23:28.951 | DEBUG    | Extracted a valid json.
2025-10-15 15:23:28.951 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/units/quantity.py",
            "class": "Quantity",
            "method": "mean",
            "intended_behavior": "The `mean` method needs to be updated to support the `where` keyword argument. This involves modifying its signature to either explicitly include `where=None` or to accept arbitrary keyword arguments via `**kwargs`. The method should then pass `where` (or `**kwargs` if this approach is chosen) to `np.mean` when called. This will ensure that when users of `astropy.units.Quantity` objects call the `mean` method with the `where` keyword argument, this argument effectively influences the computation as intended when passed along to the underlying `np.mean` function, without breaking backward compatibility. The modification should handle the `where` condition correctly by incorporating any necessary pre-processing to align with the units management in `Quantity`, thereby preserving the existing functionality while extending support for new uses enabled by the `where` argument in `numpy.mean`."
        }
    ]
}
2025-10-15 15:23:28.962 | DEBUG    | Bug location extracted successfully: [<file>astropy/units/quantity.py</file>
<class>Quantity</class>
<method>mean</method>
<code>
1801     def mean(self, axis=None, dtype=None, out=None, keepdims=False):
1802         return self._wrap_function(np.mean, axis, dtype, out=out,
1803                                    keepdims=keepdims)

</code><intended_behavior>The `mean` method needs to be updated to support the `where` keyword argument. This involves modifying its signature to either explicitly include `where=None` or to accept arbitrary keyword arguments via `**kwargs`. The method should then pass `where` (or `**kwargs` if this approach is chosen) to `np.mean` when called. This will ensure that when users of `astropy.units.Quantity` objects call the `mean` method with the `where` keyword argument, this argument effectively influences the computation as intended when passed along to the underlying `np.mean` function, without breaking backward compatibility. The modification should handle the `where` condition correctly by incorporating any necessary pre-processing to align with the units management in `Quantity`, thereby preserving the existing functionality while extending support for new uses enabled by the `where` argument in `numpy.mean`.</intended_behavior>, <file>astropy/units/quantity.py</file>
<class>Quantity</class>
<method>None</method>
<code>
238 class Quantity(np.ndarray):
239     """A `~astropy.units.Quantity` represents a number with some associated unit.
240 
241     See also: https://docs.astropy.org/en/stable/units/quantity.html
242 
243     Parameters
244     ----------
245     value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str
246         The numerical value of this quantity in the units given by unit.  If a
247         `Quantity` or sequence of them (or any other valid object with a
248         ``unit`` attribute), creates a new `Quantity` object, converting to
249         `unit` units as needed.  If a string, it is converted to a number or
250         `Quantity`, depending on whether a unit is present.
251 
252     unit : unit-like
253         An object that represents the unit associated with the input value.
254         Must be an `~astropy.units.UnitBase` object or a string parseable by
255         the :mod:`~astropy.units` package.
256 
257     dtype : ~numpy.dtype, optional
258         The dtype of the resulting Numpy array or scalar that will
259         hold the value.  If not provided, it is determined from the input,
260         except that any integer and (non-Quantity) object inputs are converted
261         to float by default.
262 
263     copy : bool, optional
264         If `True` (default), then the value is copied.  Otherwise, a copy will
265         only be made if ``__array__`` returns a copy, if value is a nested
266         sequence, or if a copy is needed to satisfy an explicitly given
267         ``dtype``.  (The `False` option is intended mostly for internal use,
268         to speed up initialization where a copy is known to have been made.
269         Use with care.)
270 
271     order : {'C', 'F', 'A'}, optional
272         Specify the order of the array.  As in `~numpy.array`.  This parameter
273         is ignored if the input is a `Quantity` and ``copy=False``.
274 
275     subok : bool, optional
276         If `False` (default), the returned array will be forced to be a
277         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,
278         or a subclass appropriate for the unit will be used (such as
279         `~astropy.units.Dex` for ``u.dex(u.AA)``).
280 
281     ndmin : int, optional
282         Specifies the minimum number of dimensions that the resulting array
283         should have.  Ones will be pre-pended to the shape as needed to meet
284         this requirement.  This parameter is ignored if the input is a
285         `Quantity` and ``copy=False``.
286 
287     Raises
288     ------
289     TypeError
290         If the value provided is not a Python numeric type.
291     TypeError
292         If the unit provided is not either a :class:`~astropy.units.Unit`
293         object or a parseable string unit.
294 
295     Notes
296     -----
297     Quantities can also be created by multiplying a number or array with a
298     :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/
299 
300     Unless the ``dtype`` argument is explicitly specified, integer
301     or (non-Quantity) object inputs are converted to `float` by default.
302     """
303     # Need to set a class-level default for _equivalencies, or
304     # Constants can not initialize properly
305     _equivalencies = []
306 
307     # Default unit for initialization; can be overridden by subclasses,
308     # possibly to `None` to indicate there is no default unit.
309     _default_unit = dimensionless_unscaled
310 
311     # Ensures views have an undefined unit.
312     _unit = None
313 
314     __array_priority__ = 10000
315 
316     def __class_getitem__(cls, unit_shape_dtype):
317         """Quantity Type Hints.
318 
319         Unit-aware type hints are ``Annotated`` objects that encode the class,
320         the unit, and possibly shape and dtype information, depending on the
321         python and :mod:`numpy` versions.
322 
323         Schematically, ``Annotated[cls[shape, dtype], unit]``
324 
325         As a classmethod, the type is the class, ie ``Quantity``
326         produces an ``Annotated[Quantity, ...]`` while a subclass
327         like :class:`~astropy.coordinates.Angle` returns
328         ``Annotated[Angle, ...]``.
329 
330         Parameters
331         ----------
332         unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple
333             Unit specification, can be the physical type (ie str or class).
334             If tuple, then the first element is the unit specification
335             and all other elements are for `numpy.ndarray` type annotations.
336             Whether they are included depends on the python and :mod:`numpy`
337             versions.
338 
339         Returns
340         -------
341         `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`
342             Return type in this preference order:
343             * if python v3.9+ : `typing.Annotated`
344             * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`
345             * `astropy.units.Unit` or `astropy.units.PhysicalType`
346 
347         Raises
348         ------
349         TypeError
350             If the unit/physical_type annotation is not Unit-like or
351             PhysicalType-like.
352 
353         Examples
354         --------
355         Create a unit-aware Quantity type annotation
356 
357             >>> Quantity[Unit("s")]
358             Annotated[Quantity, Unit("s")]
359 
360         See Also
361         --------
362         `~astropy.units.quantity_input`
363             Use annotations for unit checks on function arguments and results.
364 
365         Notes
366         -----
367         With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also
368         static-type compatible.
369         """
370         # LOCAL
371         from ._typing import HAS_ANNOTATED, Annotated
372 
373         # process whether [unit] or [unit, shape, ptype]
374         if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype
375             target = unit_shape_dtype[0]
376             shape_dtype = unit_shape_dtype[1:]
377         else:  # just unit
378             target = unit_shape_dtype
379             shape_dtype = ()
380 
381         # Allowed unit/physical types. Errors if neither.
382         try:
383             unit = Unit(target)
384         except (TypeError, ValueError):
385             from astropy.units.physical import get_physical_type
386 
387             try:
388                 unit = get_physical_type(target)
389             except (TypeError, ValueError, KeyError):  # KeyError for Enum
390                 raise TypeError("unit annotation is not a Unit or PhysicalType") from None
391 
392         # Allow to sort of work for python 3.8- / no typing_extensions
393         # instead of bailing out, return the unit for `quantity_input`
394         if not HAS_ANNOTATED:
395             warnings.warn("Quantity annotations are valid static type annotations only"
396                           " if Python is v3.9+ or `typing_extensions` is installed.")
397             return unit
398 
399         # Quantity does not (yet) properly extend the NumPy generics types,
400         # introduced in numpy v1.22+, instead just including the unit info as
401         # metadata using Annotated.
402         # TODO: ensure we do interact with NDArray.__class_getitem__.
403         return Annotated.__class_getitem__((cls, unit))
404 
405     def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,
406                 subok=False, ndmin=0):
407 
408         if unit is not None:
409             # convert unit first, to avoid multiple string->unit conversions
410             unit = Unit(unit)
411 
412         # optimize speed for Quantity with no dtype given, copy=False
413         if isinstance(value, Quantity):
414             if unit is not None and unit is not value.unit:
415                 value = value.to(unit)
416                 # the above already makes a copy (with float dtype)
417                 copy = False
418 
419             if type(value) is not cls and not (subok and
420                                                isinstance(value, cls)):
421                 value = value.view(cls)
422 
423             if dtype is None and value.dtype.kind in 'iu':
424                 dtype = float
425 
426             return np.array(value, dtype=dtype, copy=copy, order=order,
427                             subok=True, ndmin=ndmin)
428 
429         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.
430         # To ensure array remains fast, we short-circuit it.
431         value_unit = None
432         if not isinstance(value, np.ndarray):
433             if isinstance(value, str):
434                 # The first part of the regex string matches any integer/float;
435                 # the second parts adds possible trailing .+-, which will break
436                 # the float function below and ensure things like 1.2.3deg
437                 # will not work.
438                 pattern = (r'\s*[+-]?'
439                            r'((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|'
440                            r'([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))'
441                            r'([eE][+-]?\d+)?'
442                            r'[.+-]?')
443 
444                 v = re.match(pattern, value)
445                 unit_string = None
446                 try:
447                     value = float(v.group())
448 
449                 except Exception:
450                     raise TypeError('Cannot parse "{}" as a {}. It does not '
451                                     'start with a number.'
452                                     .format(value, cls.__name__))
453 
454                 unit_string = v.string[v.end():].strip()
455                 if unit_string:
456                     value_unit = Unit(unit_string)
457                     if unit is None:
458                         unit = value_unit  # signal no conversion needed below.
459 
460             elif isiterable(value) and len(value) > 0:
461                 # Iterables like lists and tuples.
462                 if all(isinstance(v, Quantity) for v in value):
463                     # If a list/tuple containing only quantities, convert all
464                     # to the same unit.
465                     if unit is None:
466                         unit = value[0].unit
467                     value = [q.to_value(unit) for q in value]
468                     value_unit = unit  # signal below that conversion has been done
469                 elif (dtype is None and not hasattr(value, 'dtype')
470                       and isinstance(unit, StructuredUnit)):
471                     # Special case for list/tuple of values and a structured unit:
472                     # ``np.array(value, dtype=None)`` would treat tuples as lower
473                     # levels of the array, rather than as elements of a structured
474                     # array, so we use the structure of the unit to help infer the
475                     # structured dtype of the value.
476                     dtype = unit._recursively_get_dtype(value)
477 
478         if value_unit is None:
479             # If the value has a `unit` attribute and if not None
480             # (for Columns with uninitialized unit), treat it like a quantity.
481             value_unit = getattr(value, 'unit', None)
482             if value_unit is None:
483                 # Default to dimensionless for no (initialized) unit attribute.
484                 if unit is None:
485                     unit = cls._default_unit
486                 value_unit = unit  # signal below that no conversion is needed
487             else:
488                 try:
489                     value_unit = Unit(value_unit)
490                 except Exception as exc:
491                     raise TypeError("The unit attribute {!r} of the input could "
492                                     "not be parsed as an astropy Unit, raising "
493                                     "the following exception:\n{}"
494                                     .format(value.unit, exc))
495 
496                 if unit is None:
497                     unit = value_unit
498                 elif unit is not value_unit:
499                     copy = False  # copy will be made in conversion at end
500 
501         value = np.array(value, dtype=dtype, copy=copy, order=order,
502                          subok=True, ndmin=ndmin)
503 
504         # check that array contains numbers or long int objects
505         if (value.dtype.kind in 'OSU' and
506             not (value.dtype.kind == 'O' and
507                  isinstance(value.item(0), numbers.Number))):
508             raise TypeError("The value must be a valid Python or "
509                             "Numpy numeric type.")
510 
511         # by default, cast any integer, boolean, etc., to float
512         if dtype is None and value.dtype.kind in 'iuO':
513             value = value.astype(float)
514 
515         # if we allow subclasses, allow a class from the unit.
516         if subok:
517             qcls = getattr(unit, '_quantity_class', cls)
518             if issubclass(qcls, cls):
519                 cls = qcls
520 
521         value = value.view(cls)
522         value._set_unit(value_unit)
523         if unit is value_unit:
524             return value
525         else:
526             # here we had non-Quantity input that had a "unit" attribute
527             # with a unit different from the desired one.  So, convert.
528             return value.to(unit)
529 
530     def __array_finalize__(self, obj):
531         # Check whether super().__array_finalize should be called
532         # (sadly, ndarray.__array_finalize__ is None; we cannot be sure
533         # what is above us).
534         super_array_finalize = super().__array_finalize__
535         if super_array_finalize is not None:
536             super_array_finalize(obj)
537 
538         # If we're a new object or viewing an ndarray, nothing has to be done.
539         if obj is None or obj.__class__ is np.ndarray:
540             return
541 
542         # If our unit is not set and obj has a valid one, use it.
543         if self._unit is None:
544             unit = getattr(obj, '_unit', None)
545             if unit is not None:
546                 self._set_unit(unit)
547 
548         # Copy info if the original had `info` defined.  Because of the way the
549         # DataInfo works, `'info' in obj.__dict__` is False until the
550         # `info` attribute is accessed or set.
551         if 'info' in obj.__dict__:
552             self.info = obj.info
553 
554     def __array_wrap__(self, obj, context=None):
555 
556         if context is None:
557             # Methods like .squeeze() created a new `ndarray` and then call
558             # __array_wrap__ to turn the array into self's subclass.
559             return self._new_view(obj)
560 
561         raise NotImplementedError('__array_wrap__ should not be used '
562                                   'with a context any more since all use '
563                                   'should go through array_function. '
564                                   'Please raise an issue on '
565                                   'https://github.com/astropy/astropy')
566 
567     def __array_ufunc__(self, function, method, *inputs, **kwargs):
568         """Wrap numpy ufuncs, taking care of units.
569 
570         Parameters
571         ----------
572         function : callable
573             ufunc to wrap.
574         method : str
575             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.
576         inputs : tuple
577             Input arrays.
578         kwargs : keyword arguments
579             As passed on, with ``out`` containing possible quantity output.
580 
581         Returns
582         -------
583         result : `~astropy.units.Quantity`
584             Results of the ufunc, with the unit set properly.
585         """
586         # Determine required conversion functions -- to bring the unit of the
587         # input to that expected (e.g., radian for np.sin), or to get
588         # consistent units between two inputs (e.g., in np.add) --
589         # and the unit of the result (or tuple of units for nout > 1).
590         converters, unit = converters_and_unit(function, method, *inputs)
591 
592         out = kwargs.get('out', None)
593         # Avoid loop back by turning any Quantity output into array views.
594         if out is not None:
595             # If pre-allocated output is used, check it is suitable.
596             # This also returns array view, to ensure we don't loop back.
597             if function.nout == 1:
598                 out = out[0]
599             out_array = check_output(out, unit, inputs, function=function)
600             # Ensure output argument remains a tuple.
601             kwargs['out'] = (out_array,) if function.nout == 1 else out_array
602 
603         # Same for inputs, but here also convert if necessary.
604         arrays = []
605         for input_, converter in zip(inputs, converters):
606             input_ = getattr(input_, 'value', input_)
607             arrays.append(converter(input_) if converter else input_)
608 
609         # Call our superclass's __array_ufunc__
610         result = super().__array_ufunc__(function, method, *arrays, **kwargs)
611         # If unit is None, a plain array is expected (e.g., comparisons), which
612         # means we're done.
613         # We're also done if the result was None (for method 'at') or
614         # NotImplemented, which can happen if other inputs/outputs override
615         # __array_ufunc__; hopefully, they can then deal with us.
616         if unit is None or result is None or result is NotImplemented:
617             return result
618 
619         return self._result_as_quantity(result, unit, out)
620 
621     def _result_as_quantity(self, result, unit, out):
622         """Turn result into a quantity with the given unit.
623 
624         If no output is given, it will take a view of the array as a quantity,
625         and set the unit.  If output is given, those should be quantity views
626         of the result arrays, and the function will just set the unit.
627 
628         Parameters
629         ----------
630         result : ndarray or tuple thereof
631             Array(s) which need to be turned into quantity.
632         unit : `~astropy.units.Unit`
633             Unit for the quantities to be returned (or `None` if the result
634             should not be a quantity).  Should be tuple if result is a tuple.
635         out : `~astropy.units.Quantity` or None
636             Possible output quantity. Should be `None` or a tuple if result
637             is a tuple.
638 
639         Returns
640         -------
641         out : `~astropy.units.Quantity`
642            With units set.
643         """
644         if isinstance(result, (tuple, list)):
645             if out is None:
646                 out = (None,) * len(result)
647             return result.__class__(
648                 self._result_as_quantity(result_, unit_, out_)
649                 for (result_, unit_, out_) in
650                 zip(result, unit, out))
651 
652         if out is None:
653             # View the result array as a Quantity with the proper unit.
654             return result if unit is None else self._new_view(result, unit)
655 
656         # For given output, just set the unit. We know the unit is not None and
657         # the output is of the correct Quantity subclass, as it was passed
658         # through check_output.
659         out._set_unit(unit)
660         return out
661 
662     def __quantity_subclass__(self, unit):
663         """
664         Overridden by subclasses to change what kind of view is
665         created based on the output unit of an operation.
666 
667         Parameters
668         ----------
669         unit : UnitBase
670             The unit for which the appropriate class should be returned
671 
672         Returns
673         -------
674         tuple :
675             - `~astropy.units.Quantity` subclass
676             - bool: True if subclasses of the given class are ok
677         """
678         return Quantity, True
679 
680     def _new_view(self, obj=None, unit=None):
681         """
682         Create a Quantity view of some array-like input, and set the unit
683 
684         By default, return a view of ``obj`` of the same class as ``self`` and
685         with the same unit.  Subclasses can override the type of class for a
686         given unit using ``__quantity_subclass__``, and can ensure properties
687         other than the unit are copied using ``__array_finalize__``.
688 
689         If the given unit defines a ``_quantity_class`` of which ``self``
690         is not an instance, a view using this class is taken.
691 
692         Parameters
693         ----------
694         obj : ndarray or scalar, optional
695             The array to create a view of.  If obj is a numpy or python scalar,
696             it will be converted to an array scalar.  By default, ``self``
697             is converted.
698 
699         unit : unit-like, optional
700             The unit of the resulting object.  It is used to select a
701             subclass, and explicitly assigned to the view if given.
702             If not given, the subclass and unit will be that of ``self``.
703 
704         Returns
705         -------
706         view : `~astropy.units.Quantity` subclass
707         """
708         # Determine the unit and quantity subclass that we need for the view.
709         if unit is None:
710             unit = self.unit
711             quantity_subclass = self.__class__
712         elif unit is self.unit and self.__class__ is Quantity:
713             # The second part is because we should not presume what other
714             # classes want to do for the same unit.  E.g., Constant will
715             # always want to fall back to Quantity, and relies on going
716             # through `__quantity_subclass__`.
717             quantity_subclass = Quantity
718         else:
719             unit = Unit(unit)
720             quantity_subclass = getattr(unit, '_quantity_class', Quantity)
721             if isinstance(self, quantity_subclass):
722                 quantity_subclass, subok = self.__quantity_subclass__(unit)
723                 if subok:
724                     quantity_subclass = self.__class__
725 
726         # We only want to propagate information from ``self`` to our new view,
727         # so obj should be a regular array.  By using ``np.array``, we also
728         # convert python and numpy scalars, which cannot be viewed as arrays
729         # and thus not as Quantity either, to zero-dimensional arrays.
730         # (These are turned back into scalar in `.value`)
731         # Note that for an ndarray input, the np.array call takes only double
732         # ``obj.__class is np.ndarray``. So, not worth special-casing.
733         if obj is None:
734             obj = self.view(np.ndarray)
735         else:
736             obj = np.array(obj, copy=False, subok=True)
737 
738         # Take the view, set the unit, and update possible other properties
739         # such as ``info``, ``wrap_angle`` in `Longitude`, etc.
740         view = obj.view(quantity_subclass)
741         view._set_unit(unit)
742         view.__array_finalize__(self)
743         return view
744 
745     def _set_unit(self, unit):
746         """Set the unit.
747 
748         This is used anywhere the unit is set or modified, i.e., in the
749         initilizer, in ``__imul__`` and ``__itruediv__`` for in-place
750         multiplication and division by another unit, as well as in
751         ``__array_finalize__`` for wrapping up views.  For Quantity, it just
752         sets the unit, but subclasses can override it to check that, e.g.,
753         a unit is consistent.
754         """
755         if not isinstance(unit, UnitBase):
756             if (isinstance(self._unit, StructuredUnit)
757                     or isinstance(unit, StructuredUnit)):
758                 unit = StructuredUnit(unit, self.dtype)
759             else:
760                 # Trying to go through a string ensures that, e.g., Magnitudes with
761                 # dimensionless physical unit become Quantity with units of mag.
762                 unit = Unit(str(unit), parse_strict='silent')
763                 if not isinstance(unit, (UnitBase, StructuredUnit)):
764                     raise UnitTypeError(
765                         "{} instances require normal units, not {} instances."
766                         .format(type(self).__name__, type(unit)))
767 
768         self._unit = unit
769 
770     def __deepcopy__(self, memo):
771         # If we don't define this, ``copy.deepcopy(quantity)`` will
772         # return a bare Numpy array.
773         return self.copy()
774 
775     def __reduce__(self):
776         # patch to pickle Quantity objects (ndarray subclasses), see
777         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
778 
779         object_state = list(super().__reduce__())
780         object_state[2] = (object_state[2], self.__dict__)
781         return tuple(object_state)
782 
783     def __setstate__(self, state):
784         # patch to unpickle Quantity objects (ndarray subclasses), see
785         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
786 
787         nd_state, own_state = state
788         super().__setstate__(nd_state)
789         self.__dict__.update(own_state)
790 
791     info = QuantityInfo()
792 
793     def _to_value(self, unit, equivalencies=[]):
794         """Helper method for to and to_value."""
795         if equivalencies == []:
796             equivalencies = self._equivalencies
797         if not self.dtype.names or isinstance(self.unit, StructuredUnit):
798             # Standard path, let unit to do work.
799             return self.unit.to(unit, self.view(np.ndarray),
800                                 equivalencies=equivalencies)
801 
802         else:
803             # The .to() method of a simple unit cannot convert a structured
804             # dtype, so we work around it, by recursing.
805             # TODO: deprecate this?
806             # Convert simple to Structured on initialization?
807             result = np.empty_like(self.view(np.ndarray))
808             for name in self.dtype.names:
809                 result[name] = self[name]._to_value(unit, equivalencies)
810             return result
811 
812     def to(self, unit, equivalencies=[], copy=True):
813         """
814         Return a new `~astropy.units.Quantity` object with the specified unit.
815 
816         Parameters
817         ----------
818         unit : unit-like
819             An object that represents the unit to convert to. Must be
820             an `~astropy.units.UnitBase` object or a string parseable
821             by the `~astropy.units` package.
822 
823         equivalencies : list of tuple
824             A list of equivalence pairs to try if the units are not
825             directly convertible.  See :ref:`astropy:unit_equivalencies`.
826             If not provided or ``[]``, class default equivalencies will be used
827             (none for `~astropy.units.Quantity`, but may be set for subclasses)
828             If `None`, no equivalencies will be applied at all, not even any
829             set globally or within a context.
830 
831         copy : bool, optional
832             If `True` (default), then the value is copied.  Otherwise, a copy
833             will only be made if necessary.
834 
835         See also
836         --------
837         to_value : get the numerical value in a given unit.
838         """
839         # We don't use `to_value` below since we always want to make a copy
840         # and don't want to slow down this method (esp. the scalar case).
841         unit = Unit(unit)
842         if copy:
843             # Avoid using to_value to ensure that we make a copy. We also
844             # don't want to slow down this method (esp. the scalar case).
845             value = self._to_value(unit, equivalencies)
846         else:
847             # to_value only copies if necessary
848             value = self.to_value(unit, equivalencies)
849         return self._new_view(value, unit)
850 
851     def to_value(self, unit=None, equivalencies=[]):
852         """
853         The numerical value, possibly in a different unit.
854 
855         Parameters
856         ----------
857         unit : unit-like, optional
858             The unit in which the value should be given. If not given or `None`,
859             use the current unit.
860 
861         equivalencies : list of tuple, optional
862             A list of equivalence pairs to try if the units are not directly
863             convertible (see :ref:`astropy:unit_equivalencies`). If not provided
864             or ``[]``, class default equivalencies will be used (none for
865             `~astropy.units.Quantity`, but may be set for subclasses).
866             If `None`, no equivalencies will be applied at all, not even any
867             set globally or within a context.
868 
869         Returns
870         -------
871         value : ndarray or scalar
872             The value in the units specified. For arrays, this will be a view
873             of the data if no unit conversion was necessary.
874 
875         See also
876         --------
877         to : Get a new instance in a different unit.
878         """
879         if unit is None or unit is self.unit:
880             value = self.view(np.ndarray)
881         elif not self.dtype.names:
882             # For non-structured, we attempt a short-cut, where we just get
883             # the scale.  If that is 1, we do not have to do anything.
884             unit = Unit(unit)
885             # We want a view if the unit does not change.  One could check
886             # with "==", but that calculates the scale that we need anyway.
887             # TODO: would be better for `unit.to` to have an in-place flag.
888             try:
889                 scale = self.unit._to(unit)
890             except Exception:
891                 # Short-cut failed; try default (maybe equivalencies help).
892                 value = self._to_value(unit, equivalencies)
893             else:
894                 value = self.view(np.ndarray)
895                 if not is_effectively_unity(scale):
896                     # not in-place!
897                     value = value * scale
898         else:
899             # For structured arrays, we go the default route.
900             value = self._to_value(unit, equivalencies)
901 
902         # Index with empty tuple to decay array scalars in to numpy scalars.
903         return value if value.shape else value[()]
904 
905     value = property(to_value,
906                      doc="""The numerical value of this instance.
907 
908     See also
909     --------
910     to_value : Get the numerical value in a given unit.
911     """)
912 
913     @property
914     def unit(self):
915         """
916         A `~astropy.units.UnitBase` object representing the unit of this
917         quantity.
918         """
919 
920         return self._unit
921 
922     @property
923     def equivalencies(self):
924         """
925         A list of equivalencies that will be applied by default during
926         unit conversions.
927         """
928 
929         return self._equivalencies
930 
931     def _recursively_apply(self, func):
932         """Apply function recursively to every field.
933 
934         Returns a copy with the result.
935         """
936         result = np.empty_like(self)
937         result_value = result.view(np.ndarray)
938         result_unit = ()
939         for name in self.dtype.names:
940             part = func(self[name])
941             result_value[name] = part.value
942             result_unit += (part.unit,)
943 
944         result._set_unit(result_unit)
945         return result
946 
947     @property
948     def si(self):
949         """
950         Returns a copy of the current `Quantity` instance with SI units. The
951         value of the resulting object will be scaled.
952         """
953         if self.dtype.names:
954             return self._recursively_apply(operator.attrgetter('si'))
955         si_unit = self.unit.si
956         return self._new_view(self.value * si_unit.scale,
957                               si_unit / si_unit.scale)
958 
959     @property
960     def cgs(self):
961         """
962         Returns a copy of the current `Quantity` instance with CGS units. The
963         value of the resulting object will be scaled.
964         """
965         if self.dtype.names:
966             return self._recursively_apply(operator.attrgetter('cgs'))
967         cgs_unit = self.unit.cgs
968         return self._new_view(self.value * cgs_unit.scale,
969                               cgs_unit / cgs_unit.scale)
970 
971     @property
972     def isscalar(self):
973         """
974         True if the `value` of this quantity is a scalar, or False if it
975         is an array-like object.
976 
977         .. note::
978             This is subtly different from `numpy.isscalar` in that
979             `numpy.isscalar` returns False for a zero-dimensional array
980             (e.g. ``np.array(1)``), while this is True for quantities,
981             since quantities cannot represent true numpy scalars.
982         """
983         return not self.shape
984 
985     # This flag controls whether convenience conversion members, such
986     # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is
987     # not turned on on Quantity itself, but is on some subclasses of
988     # Quantity, such as `astropy.coordinates.Angle`.
989     _include_easy_conversion_members = False
990 
991     @override__dir__
992     def __dir__(self):
993         """
994         Quantities are able to directly convert to other units that
995         have the same physical type.  This function is implemented in
996         order to make autocompletion still work correctly in IPython.
997         """
998         if not self._include_easy_conversion_members:
999             return []
1000         extra_members = set()
1001         equivalencies = Unit._normalize_equivalencies(self.equivalencies)
1002         for equivalent in self.unit._get_units_with_same_physical_type(
1003                 equivalencies):
1004             extra_members.update(equivalent.names)
1005         return extra_members
1006 
1007     def __getattr__(self, attr):
1008         """
1009         Quantities are able to directly convert to other units that
1010         have the same physical type.
1011         """
1012         if not self._include_easy_conversion_members:
1013             raise AttributeError(
1014                 f"'{self.__class__.__name__}' object has no '{attr}' member")
1015 
1016         def get_virtual_unit_attribute():
1017             registry = get_current_unit_registry().registry
1018             to_unit = registry.get(attr, None)
1019             if to_unit is None:
1020                 return None
1021 
1022             try:
1023                 return self.unit.to(
1024                     to_unit, self.value, equivalencies=self.equivalencies)
1025             except UnitsError:
1026                 return None
1027 
1028         value = get_virtual_unit_attribute()
1029 
1030         if value is None:
1031             raise AttributeError(
1032                 f"{self.__class__.__name__} instance has no attribute '{attr}'")
1033         else:
1034             return value
1035 
1036     # Equality needs to be handled explicitly as ndarray.__eq__ gives
1037     # DeprecationWarnings on any error, which is distracting, and does not
1038     # deal well with structured arrays (nor does the ufunc).
1039     def __eq__(self, other):
1040         try:
1041             other_value = self._to_own_unit(other)
1042         except UnitsError:
1043             return False
1044         except Exception:
1045             return NotImplemented
1046         return self.value.__eq__(other_value)
1047 
1048     def __ne__(self, other):
1049         try:
1050             other_value = self._to_own_unit(other)
1051         except UnitsError:
1052             return True
1053         except Exception:
1054             return NotImplemented
1055         return self.value.__ne__(other_value)
1056 
1057     # Unit conversion operator (<<).
1058     def __lshift__(self, other):
1059         try:
1060             other = Unit(other, parse_strict='silent')
1061         except UnitTypeError:
1062             return NotImplemented
1063 
1064         return self.__class__(self, other, copy=False, subok=True)
1065 
1066     def __ilshift__(self, other):
1067         try:
1068             other = Unit(other, parse_strict='silent')
1069         except UnitTypeError:
1070             return NotImplemented
1071 
1072         try:
1073             factor = self.unit._to(other)
1074         except Exception:
1075             # Maybe via equivalencies?  Now we do make a temporary copy.
1076             try:
1077                 value = self._to_value(other)
1078             except UnitConversionError:
1079                 return NotImplemented
1080 
1081             self.view(np.ndarray)[...] = value
1082 
1083         else:
1084             self.view(np.ndarray)[...] *= factor
1085 
1086         self._set_unit(other)
1087         return self
1088 
1089     def __rlshift__(self, other):
1090         if not self.isscalar:
1091             return NotImplemented
1092         return Unit(self).__rlshift__(other)
1093 
1094     # Give warning for other >> self, since probably other << self was meant.
1095     def __rrshift__(self, other):
1096         warnings.warn(">> is not implemented. Did you mean to convert "
1097                       "something to this quantity as a unit using '<<'?",
1098                       AstropyWarning)
1099         return NotImplemented
1100 
1101     # Also define __rshift__ and __irshift__ so we override default ndarray
1102     # behaviour, but instead of emitting a warning here, let it be done by
1103     # other (which likely is a unit if this was a mistake).
1104     def __rshift__(self, other):
1105         return NotImplemented
1106 
1107     def __irshift__(self, other):
1108         return NotImplemented
1109 
1110     # Arithmetic operations
1111     def __mul__(self, other):
1112         """ Multiplication between `Quantity` objects and other objects."""
1113 
1114         if isinstance(other, (UnitBase, str)):
1115             try:
1116                 return self._new_view(self.copy(), other * self.unit)
1117             except UnitsError:  # let other try to deal with it
1118                 return NotImplemented
1119 
1120         return super().__mul__(other)
1121 
1122     def __imul__(self, other):
1123         """In-place multiplication between `Quantity` objects and others."""
1124 
1125         if isinstance(other, (UnitBase, str)):
1126             self._set_unit(other * self.unit)
1127             return self
1128 
1129         return super().__imul__(other)
1130 
1131     def __rmul__(self, other):
1132         """ Right Multiplication between `Quantity` objects and other
1133         objects.
1134         """
1135 
1136         return self.__mul__(other)
1137 
1138     def __truediv__(self, other):
1139         """ Division between `Quantity` objects and other objects."""
1140 
1141         if isinstance(other, (UnitBase, str)):
1142             try:
1143                 return self._new_view(self.copy(), self.unit / other)
1144             except UnitsError:  # let other try to deal with it
1145                 return NotImplemented
1146 
1147         return super().__truediv__(other)
1148 
1149     def __itruediv__(self, other):
1150         """Inplace division between `Quantity` objects and other objects."""
1151 
1152         if isinstance(other, (UnitBase, str)):
1153             self._set_unit(self.unit / other)
1154             return self
1155 
1156         return super().__itruediv__(other)
1157 
1158     def __rtruediv__(self, other):
1159         """ Right Division between `Quantity` objects and other objects."""
1160 
1161         if isinstance(other, (UnitBase, str)):
1162             return self._new_view(1. / self.value, other / self.unit)
1163 
1164         return super().__rtruediv__(other)
1165 
1166     def __pow__(self, other):
1167         if isinstance(other, Fraction):
1168             # Avoid getting object arrays by raising the value to a Fraction.
1169             return self._new_view(self.value ** float(other),
1170                                   self.unit ** other)
1171 
1172         return super().__pow__(other)
1173 
1174     # other overrides of special functions
1175     def __hash__(self):
1176         return hash(self.value) ^ hash(self.unit)
1177 
1178     def __iter__(self):
1179         if self.isscalar:
1180             raise TypeError(
1181                 "'{cls}' object with a scalar value is not iterable"
1182                 .format(cls=self.__class__.__name__))
1183 
1184         # Otherwise return a generator
1185         def quantity_iter():
1186             for val in self.value:
1187                 yield self._new_view(val)
1188 
1189         return quantity_iter()
1190 
1191     def __getitem__(self, key):
1192         if isinstance(key, str) and isinstance(self.unit, StructuredUnit):
1193             return self._new_view(self.view(np.ndarray)[key], self.unit[key])
1194 
1195         try:
1196             out = super().__getitem__(key)
1197         except IndexError:
1198             # We want zero-dimensional Quantity objects to behave like scalars,
1199             # so they should raise a TypeError rather than an IndexError.
1200             if self.isscalar:
1201                 raise TypeError(
1202                     "'{cls}' object with a scalar value does not support "
1203                     "indexing".format(cls=self.__class__.__name__))
1204             else:
1205                 raise
1206         # For single elements, ndarray.__getitem__ returns scalars; these
1207         # need a new view as a Quantity.
1208         if not isinstance(out, np.ndarray):
1209             out = self._new_view(out)
1210         return out
1211 
1212     def __setitem__(self, i, value):
1213         if isinstance(i, str):
1214             # Indexing will cause a different unit, so by doing this in
1215             # two steps we effectively try with the right unit.
1216             self[i][...] = value
1217             return
1218 
1219         # update indices in info if the info property has been accessed
1220         # (in which case 'info' in self.__dict__ is True; this is guaranteed
1221         # to be the case if we're part of a table).
1222         if not self.isscalar and 'info' in self.__dict__:
1223             self.info.adjust_indices(i, value, len(self))
1224         self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
1225 
1226     # __contains__ is OK
1227 
1228     def __bool__(self):
1229         """Quantities should always be treated as non-False; there is too much
1230         potential for ambiguity otherwise.
1231         """
1232         warnings.warn('The truth value of a Quantity is ambiguous. '
1233                       'In the future this will raise a ValueError.',
1234                       AstropyDeprecationWarning)
1235         return True
1236 
1237     def __len__(self):
1238         if self.isscalar:
1239             raise TypeError("'{cls}' object with a scalar value has no "
1240                             "len()".format(cls=self.__class__.__name__))
1241         else:
1242             return len(self.value)
1243 
1244     # Numerical types
1245     def __float__(self):
1246         try:
1247             return float(self.to_value(dimensionless_unscaled))
1248         except (UnitsError, TypeError):
1249             raise TypeError('only dimensionless scalar quantities can be '
1250                             'converted to Python scalars')
1251 
1252     def __int__(self):
1253         try:
1254             return int(self.to_value(dimensionless_unscaled))
1255         except (UnitsError, TypeError):
1256             raise TypeError('only dimensionless scalar quantities can be '
1257                             'converted to Python scalars')
1258 
1259     def __index__(self):
1260         # for indices, we do not want to mess around with scaling at all,
1261         # so unlike for float, int, we insist here on unscaled dimensionless
1262         try:
1263             assert self.unit.is_unity()
1264             return self.value.__index__()
1265         except Exception:
1266             raise TypeError('only integer dimensionless scalar quantities '
1267                             'can be converted to a Python index')
1268 
1269     # TODO: we may want to add a hook for dimensionless quantities?
1270     @property
1271     def _unitstr(self):
1272         if self.unit is None:
1273             unitstr = _UNIT_NOT_INITIALISED
1274         else:
1275             unitstr = str(self.unit)
1276 
1277         if unitstr:
1278             unitstr = ' ' + unitstr
1279 
1280         return unitstr
1281 
1282     def to_string(self, unit=None, precision=None, format=None, subfmt=None):
1283         """
1284         Generate a string representation of the quantity and its unit.
1285 
1286         The behavior of this function can be altered via the
1287         `numpy.set_printoptions` function and its various keywords.  The
1288         exception to this is the ``threshold`` keyword, which is controlled via
1289         the ``[units.quantity]`` configuration item ``latex_array_threshold``.
1290         This is treated separately because the numpy default of 1000 is too big
1291         for most browsers to handle.
1292 
1293         Parameters
1294         ----------
1295         unit : unit-like, optional
1296             Specifies the unit.  If not provided,
1297             the unit used to initialize the quantity will be used.
1298 
1299         precision : number, optional
1300             The level of decimal precision. If `None`, or not provided,
1301             it will be determined from NumPy print options.
1302 
1303         format : str, optional
1304             The format of the result. If not provided, an unadorned
1305             string is returned. Supported values are:
1306 
1307             - 'latex': Return a LaTeX-formatted string
1308 
1309             - 'latex_inline': Return a LaTeX-formatted string that uses
1310               negative exponents instead of fractions
1311 
1312         subfmt : str, optional
1313             Subformat of the result. For the moment, only used for
1314             ``format='latex'`` and ``format='latex_inline'``. Supported
1315             values are:
1316 
1317             - 'inline': Use ``$ ... $`` as delimiters.
1318 
1319             - 'display': Use ``$\\displaystyle ... $`` as delimiters.
1320 
1321         Returns
1322         -------
1323         str
1324             A string with the contents of this Quantity
1325         """
1326         if unit is not None and unit != self.unit:
1327             return self.to(unit).to_string(
1328                 unit=None, precision=precision, format=format, subfmt=subfmt)
1329 
1330         formats = {
1331             None: None,
1332             "latex": {
1333                 None: ("$", "$"),
1334                 "inline": ("$", "$"),
1335                 "display": (r"$\displaystyle ", r"$"),
1336             },
1337         }
1338         formats['latex_inline'] = formats['latex']
1339 
1340         if format not in formats:
1341             raise ValueError(f"Unknown format '{format}'")
1342         elif format is None:
1343             if precision is None:
1344                 # Use default formatting settings
1345                 return f'{self.value}{self._unitstr:s}'
1346             else:
1347                 # np.array2string properly formats arrays as well as scalars
1348                 return np.array2string(self.value, precision=precision,
1349                                        floatmode="fixed") + self._unitstr
1350 
1351         # else, for the moment we assume format="latex" or "latex_inline".
1352 
1353         # Set the precision if set, otherwise use numpy default
1354         pops = np.get_printoptions()
1355         format_spec = f".{precision if precision is not None else pops['precision']}g"
1356 
1357         def float_formatter(value):
1358             return Latex.format_exponential_notation(value,
1359                                                      format_spec=format_spec)
1360 
1361         def complex_formatter(value):
1362             return '({}{}i)'.format(
1363                 Latex.format_exponential_notation(value.real,
1364                                                   format_spec=format_spec),
1365                 Latex.format_exponential_notation(value.imag,
1366                                                   format_spec='+' + format_spec))
1367 
1368         # The view is needed for the scalar case - self.value might be float.
1369         latex_value = np.array2string(
1370             self.view(np.ndarray),
1371             threshold=(conf.latex_array_threshold
1372                        if conf.latex_array_threshold > -1 else pops['threshold']),
1373             formatter={'float_kind': float_formatter,
1374                        'complex_kind': complex_formatter},
1375             max_line_width=np.inf,
1376             separator=',~')
1377 
1378         latex_value = latex_value.replace('...', r'\dots')
1379 
1380         # Format unit
1381         # [1:-1] strips the '$' on either side needed for math mode
1382         if self.unit is None:
1383             latex_unit = _UNIT_NOT_INITIALISED
1384         elif format == 'latex':
1385             latex_unit = self.unit._repr_latex_()[1:-1] # note this is unicode
1386         elif format == 'latex_inline':
1387             latex_unit = self.unit.to_string(format='latex_inline')[1:-1]
1388 
1389         delimiter_left, delimiter_right = formats[format][subfmt]
1390 
1391         return rf'{delimiter_left}{latex_value} \; {latex_unit}{delimiter_right}'
1392 
1393     def __str__(self):
1394         return self.to_string()
1395 
1396     def __repr__(self):
1397         prefixstr = '<' + self.__class__.__name__ + ' '
1398         arrstr = np.array2string(self.view(np.ndarray), separator=', ',
1399                                  prefix=prefixstr)
1400         return f'{prefixstr}{arrstr}{self._unitstr:s}>'
1401 
1402     def _repr_latex_(self):
1403         """
1404         Generate a latex representation of the quantity and its unit.
1405 
1406         Returns
1407         -------
1408         lstr
1409             A LaTeX string with the contents of this Quantity
1410         """
1411         # NOTE: This should change to display format in a future release
1412         return self.to_string(format='latex', subfmt='inline')
1413 
1414     def __format__(self, format_spec):
1415         """
1416         Format quantities using the new-style python formatting codes
1417         as specifiers for the number.
1418 
1419         If the format specifier correctly applies itself to the value,
1420         then it is used to format only the value. If it cannot be
1421         applied to the value, then it is applied to the whole string.
1422 
1423         """
1424         try:
1425             value = format(self.value, format_spec)
1426             full_format_spec = "s"
1427         except ValueError:
1428             value = self.value
1429             full_format_spec = format_spec
1430 
1431         return format(f"{value}{self._unitstr:s}",
1432                       full_format_spec)
1433 
1434     def decompose(self, bases=[]):
1435         """
1436         Generates a new `Quantity` with the units
1437         decomposed. Decomposed units have only irreducible units in
1438         them (see `astropy.units.UnitBase.decompose`).
1439 
1440         Parameters
1441         ----------
1442         bases : sequence of `~astropy.units.UnitBase`, optional
1443             The bases to decompose into.  When not provided,
1444             decomposes down to any irreducible units.  When provided,
1445             the decomposed result will only contain the given units.
1446             This will raises a `~astropy.units.UnitsError` if it's not possible
1447             to do so.
1448 
1449         Returns
1450         -------
1451         newq : `~astropy.units.Quantity`
1452             A new object equal to this quantity with units decomposed.
1453         """
1454         return self._decompose(False, bases=bases)
1455 
1456     def _decompose(self, allowscaledunits=False, bases=[]):
1457         """
1458         Generates a new `Quantity` with the units decomposed. Decomposed
1459         units have only irreducible units in them (see
1460         `astropy.units.UnitBase.decompose`).
1461 
1462         Parameters
1463         ----------
1464         allowscaledunits : bool
1465             If True, the resulting `Quantity` may have a scale factor
1466             associated with it.  If False, any scaling in the unit will
1467             be subsumed into the value of the resulting `Quantity`
1468 
1469         bases : sequence of UnitBase, optional
1470             The bases to decompose into.  When not provided,
1471             decomposes down to any irreducible units.  When provided,
1472             the decomposed result will only contain the given units.
1473             This will raises a `~astropy.units.UnitsError` if it's not possible
1474             to do so.
1475 
1476         Returns
1477         -------
1478         newq : `~astropy.units.Quantity`
1479             A new object equal to this quantity with units decomposed.
1480 
1481         """
1482 
1483         new_unit = self.unit.decompose(bases=bases)
1484 
1485         # Be careful here because self.value usually is a view of self;
1486         # be sure that the original value is not being modified.
1487         if not allowscaledunits and hasattr(new_unit, 'scale'):
1488             new_value = self.value * new_unit.scale
1489             new_unit = new_unit / new_unit.scale
1490             return self._new_view(new_value, new_unit)
1491         else:
1492             return self._new_view(self.copy(), new_unit)
1493 
1494     # These functions need to be overridden to take into account the units
1495     # Array conversion
1496     # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion
1497 
1498     def item(self, *args):
1499         """Copy an element of an array to a scalar Quantity and return it.
1500 
1501         Like :meth:`~numpy.ndarray.item` except that it always
1502         returns a `Quantity`, not a Python scalar.
1503 
1504         """
1505         return self._new_view(super().item(*args))
1506 
1507     def tolist(self):
1508         raise NotImplementedError("cannot make a list of Quantities.  Get "
1509                                   "list of values with q.value.tolist()")
1510 
1511     def _to_own_unit(self, value, check_precision=True):
1512         try:
1513             _value = value.to_value(self.unit)
1514         except AttributeError:
1515             # We're not a Quantity.
1516             # First remove two special cases (with a fast test):
1517             # 1) Maybe masked printing? MaskedArray with quantities does not
1518             # work very well, but no reason to break even repr and str.
1519             # 2) np.ma.masked? useful if we're a MaskedQuantity.
1520             if (value is np.ma.masked
1521                 or (value is np.ma.masked_print_option
1522                     and self.dtype.kind == 'O')):
1523                 return value
1524             # Now, let's try a more general conversion.
1525             # Plain arrays will be converted to dimensionless in the process,
1526             # but anything with a unit attribute will use that.
1527             try:
1528                 as_quantity = Quantity(value)
1529                 _value = as_quantity.to_value(self.unit)
1530             except UnitsError:
1531                 # last chance: if this was not something with a unit
1532                 # and is all 0, inf, or nan, we treat it as arbitrary unit.
1533                 if (not hasattr(value, 'unit') and
1534                         can_have_arbitrary_unit(as_quantity.value)):
1535                     _value = as_quantity.value
1536                 else:
1537                     raise
1538 
1539         if self.dtype.kind == 'i' and check_precision:
1540             # If, e.g., we are casting float to int, we want to fail if
1541             # precision is lost, but let things pass if it works.
1542             _value = np.array(_value, copy=False, subok=True)
1543             if not np.can_cast(_value.dtype, self.dtype):
1544                 self_dtype_array = np.array(_value, self.dtype, subok=True)
1545                 if not np.all(np.logical_or(self_dtype_array == _value,
1546                                             np.isnan(_value))):
1547                     raise TypeError("cannot convert value type to array type "
1548                                     "without precision loss")
1549 
1550         # Setting names to ensure things like equality work (note that
1551         # above will have failed already if units did not match).
1552         if self.dtype.names:
1553             _value.dtype.names = self.dtype.names
1554         return _value
1555 
1556     def itemset(self, *args):
1557         if len(args) == 0:
1558             raise ValueError("itemset must have at least one argument")
1559 
1560         self.view(np.ndarray).itemset(*(args[:-1] +
1561                                         (self._to_own_unit(args[-1]),)))
1562 
1563     def tostring(self, order='C'):
1564         raise NotImplementedError("cannot write Quantities to string.  Write "
1565                                   "array with q.value.tostring(...).")
1566 
1567     def tobytes(self, order='C'):
1568         raise NotImplementedError("cannot write Quantities to string.  Write "
1569                                   "array with q.value.tobytes(...).")
1570 
1571     def tofile(self, fid, sep="", format="%s"):
1572         raise NotImplementedError("cannot write Quantities to file.  Write "
1573                                   "array with q.value.tofile(...)")
1574 
1575     def dump(self, file):
1576         raise NotImplementedError("cannot dump Quantities to file.  Write "
1577                                   "array with q.value.dump()")
1578 
1579     def dumps(self):
1580         raise NotImplementedError("cannot dump Quantities to string.  Write "
1581                                   "array with q.value.dumps()")
1582 
1583     # astype, byteswap, copy, view, getfield, setflags OK as is
1584 
1585     def fill(self, value):
1586         self.view(np.ndarray).fill(self._to_own_unit(value))
1587 
1588     # Shape manipulation: resize cannot be done (does not own data), but
1589     # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only
1590     # the flat iterator needs to be overwritten, otherwise single items are
1591     # returned as numbers.
1592     @property
1593     def flat(self):
1594         """A 1-D iterator over the Quantity array.
1595 
1596         This returns a ``QuantityIterator`` instance, which behaves the same
1597         as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,
1598         and is similar to, but not a subclass of, Python's built-in iterator
1599         object.
1600         """
1601         return QuantityIterator(self)
1602 
1603     @flat.setter
1604     def flat(self, value):
1605         y = self.ravel()
1606         y[:] = value
1607 
1608     # Item selection and manipulation
1609     # repeat, sort, compress, diagonal OK
1610     def take(self, indices, axis=None, out=None, mode='raise'):
1611         out = super().take(indices, axis=axis, out=out, mode=mode)
1612         # For single elements, ndarray.take returns scalars; these
1613         # need a new view as a Quantity.
1614         if type(out) is not type(self):
1615             out = self._new_view(out)
1616         return out
1617 
1618     def put(self, indices, values, mode='raise'):
1619         self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)
1620 
1621     def choose(self, choices, out=None, mode='raise'):
1622         raise NotImplementedError("cannot choose based on quantity.  Choose "
1623                                   "using array with q.value.choose(...)")
1624 
1625     # ensure we do not return indices as quantities
1626     def argsort(self, axis=-1, kind='quicksort', order=None):
1627         return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)
1628 
1629     def searchsorted(self, v, *args, **kwargs):
1630         return np.searchsorted(np.array(self),
1631                                self._to_own_unit(v, check_precision=False),
1632                                *args, **kwargs)  # avoid numpy 1.6 problem
1633 
1634     def argmax(self, axis=None, out=None):
1635         return self.view(np.ndarray).argmax(axis, out=out)
1636 
1637     def argmin(self, axis=None, out=None):
1638         return self.view(np.ndarray).argmin(axis, out=out)
1639 
1640     def __array_function__(self, function, types, args, kwargs):
1641         """Wrap numpy functions, taking care of units.
1642 
1643         Parameters
1644         ----------
1645         function : callable
1646             Numpy function to wrap
1647         types : iterable of classes
1648             Classes that provide an ``__array_function__`` override. Can
1649             in principle be used to interact with other classes. Below,
1650             mostly passed on to `~numpy.ndarray`, which can only interact
1651             with subclasses.
1652         args : tuple
1653             Positional arguments provided in the function call.
1654         kwargs : dict
1655             Keyword arguments provided in the function call.
1656 
1657         Returns
1658         -------
1659         result: `~astropy.units.Quantity`, `~numpy.ndarray`
1660             As appropriate for the function.  If the function is not
1661             supported, `NotImplemented` is returned, which will lead to
1662             a `TypeError` unless another argument overrode the function.
1663 
1664         Raises
1665         ------
1666         ~astropy.units.UnitsError
1667             If operands have incompatible units.
1668         """
1669         # A function should be in one of the following sets or dicts:
1670         # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
1671         #    supports Quantity; we pass on to ndarray.__array_function__.
1672         # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
1673         #    after converting quantities to arrays with suitable units,
1674         #    and possibly setting units on the result.
1675         # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
1676         #    requires a Quantity-specific implementation.
1677         # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.
1678         # For now, since we may not yet have complete coverage, if a
1679         # function is in none of the above, we simply call the numpy
1680         # implementation.
1681         if function in SUBCLASS_SAFE_FUNCTIONS:
1682             return super().__array_function__(function, types, args, kwargs)
1683 
1684         elif function in FUNCTION_HELPERS:
1685             function_helper = FUNCTION_HELPERS[function]
1686             try:
1687                 args, kwargs, unit, out = function_helper(*args, **kwargs)
1688             except NotImplementedError:
1689                 return self._not_implemented_or_raise(function, types)
1690 
1691             result = super().__array_function__(function, types, args, kwargs)
1692             # Fall through to return section
1693 
1694         elif function in DISPATCHED_FUNCTIONS:
1695             dispatched_function = DISPATCHED_FUNCTIONS[function]
1696             try:
1697                 result, unit, out = dispatched_function(*args, **kwargs)
1698             except NotImplementedError:
1699                 return self._not_implemented_or_raise(function, types)
1700 
1701             # Fall through to return section
1702 
1703         elif function in UNSUPPORTED_FUNCTIONS:
1704             return NotImplemented
1705 
1706         else:
1707             warnings.warn("function '{}' is not known to astropy's Quantity. "
1708                           "Will run it anyway, hoping it will treat ndarray "
1709                           "subclasses correctly. Please raise an issue at "
1710                           "https://github.com/astropy/astropy/issues. "
1711                           .format(function.__name__), AstropyWarning)
1712 
1713             return super().__array_function__(function, types, args, kwargs)
1714 
1715         # If unit is None, a plain array is expected (e.g., boolean), which
1716         # means we're done.
1717         # We're also done if the result was NotImplemented, which can happen
1718         # if other inputs/outputs override __array_function__;
1719         # hopefully, they can then deal with us.
1720         if unit is None or result is NotImplemented:
1721             return result
1722 
1723         return self._result_as_quantity(result, unit, out=out)
1724 
1725     def _not_implemented_or_raise(self, function, types):
1726         # Our function helper or dispatcher found that the function does not
1727         # work with Quantity.  In principle, there may be another class that
1728         # knows what to do with us, for which we should return NotImplemented.
1729         # But if there is ndarray (or a non-Quantity subclass of it) around,
1730         # it quite likely coerces, so we should just break.
1731         if any(issubclass(t, np.ndarray) and not issubclass(t, Quantity)
1732                for t in types):
1733             raise TypeError("the Quantity implementation cannot handle {} "
1734                             "with the given arguments."
1735                             .format(function)) from None
1736         else:
1737             return NotImplemented
1738 
1739     # Calculation -- override ndarray methods to take into account units.
1740     # We use the corresponding numpy functions to evaluate the results, since
1741     # the methods do not always allow calling with keyword arguments.
1742     # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives
1743     # TypeError: 'a_max' is an invalid keyword argument for this function.
1744     def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):
1745         """Wrap a numpy function that processes self, returning a Quantity.
1746 
1747         Parameters
1748         ----------
1749         function : callable
1750             Numpy function to wrap.
1751         args : positional arguments
1752             Any positional arguments to the function beyond the first argument
1753             (which will be set to ``self``).
1754         kwargs : keyword arguments
1755             Keyword arguments to the function.
1756 
1757         If present, the following arguments are treated specially:
1758 
1759         unit : `~astropy.units.Unit`
1760             Unit of the output result.  If not given, the unit of ``self``.
1761         out : `~astropy.units.Quantity`
1762             A Quantity instance in which to store the output.
1763 
1764         Notes
1765         -----
1766         Output should always be assigned via a keyword argument, otherwise
1767         no proper account of the unit is taken.
1768 
1769         Returns
1770         -------
1771         out : `~astropy.units.Quantity`
1772             Result of the function call, with the unit set properly.
1773         """
1774         if unit is None:
1775             unit = self.unit
1776         # Ensure we don't loop back by turning any Quantity into array views.
1777         args = (self.value,) + tuple((arg.value if isinstance(arg, Quantity)
1778                                       else arg) for arg in args)
1779         if out is not None:
1780             # If pre-allocated output is used, check it is suitable.
1781             # This also returns array view, to ensure we don't loop back.
1782             arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))
1783             kwargs['out'] = check_output(out, unit, arrays, function=function)
1784         # Apply the function and turn it back into a Quantity.
1785         result = function(*args, **kwargs)
1786         return self._result_as_quantity(result, unit, out)
1787 
1788     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
1789         return self._wrap_function(np.trace, offset, axis1, axis2, dtype,
1790                                    out=out)
1791 
1792     def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
1793         return self._wrap_function(np.var, axis, dtype,
1794                                    out=out, ddof=ddof, keepdims=keepdims,
1795                                    unit=self.unit**2)
1796 
1797     def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
1798         return self._wrap_function(np.std, axis, dtype, out=out, ddof=ddof,
1799                                    keepdims=keepdims)
1800 
1801     def mean(self, axis=None, dtype=None, out=None, keepdims=False):
1802         return self._wrap_function(np.mean, axis, dtype, out=out,
1803                                    keepdims=keepdims)
1804 
1805     def round(self, decimals=0, out=None):
1806         return self._wrap_function(np.round, decimals, out=out)
1807 
1808     def dot(self, b, out=None):
1809         result_unit = self.unit * getattr(b, 'unit', dimensionless_unscaled)
1810         return self._wrap_function(np.dot, b, out=out, unit=result_unit)
1811 
1812     # Calculation: override methods that do not make sense.
1813 
1814     def all(self, axis=None, out=None):
1815         raise TypeError("cannot evaluate truth value of quantities. "
1816                         "Evaluate array with q.value.all(...)")
1817 
1818     def any(self, axis=None, out=None):
1819         raise TypeError("cannot evaluate truth value of quantities. "
1820                         "Evaluate array with q.value.any(...)")
1821 
1822     # Calculation: numpy functions that can be overridden with methods.
1823 
1824     def diff(self, n=1, axis=-1):
1825         return self._wrap_function(np.diff, n, axis)
1826 
1827     def ediff1d(self, to_end=None, to_begin=None):
1828         return self._wrap_function(np.ediff1d, to_end, to_begin)
1829 
1830     def nansum(self, axis=None, out=None, keepdims=False):
1831         return self._wrap_function(np.nansum, axis,
1832                                    out=out, keepdims=keepdims)
1833 
1834     def insert(self, obj, values, axis=None):
1835         """
1836         Insert values along the given axis before the given indices and return
1837         a new `~astropy.units.Quantity` object.
1838 
1839         This is a thin wrapper around the `numpy.insert` function.
1840 
1841         Parameters
1842         ----------
1843         obj : int, slice or sequence of int
1844             Object that defines the index or indices before which ``values`` is
1845             inserted.
1846         values : array-like
1847             Values to insert.  If the type of ``values`` is different
1848             from that of quantity, ``values`` is converted to the matching type.
1849             ``values`` should be shaped so that it can be broadcast appropriately
1850             The unit of ``values`` must be consistent with this quantity.
1851         axis : int, optional
1852             Axis along which to insert ``values``.  If ``axis`` is None then
1853             the quantity array is flattened before insertion.
1854 
1855         Returns
1856         -------
1857         out : `~astropy.units.Quantity`
1858             A copy of quantity with ``values`` inserted.  Note that the
1859             insertion does not occur in-place: a new quantity array is returned.
1860 
1861         Examples
1862         --------
1863         >>> import astropy.units as u
1864         >>> q = [1, 2] * u.m
1865         >>> q.insert(0, 50 * u.cm)
1866         <Quantity [ 0.5,  1.,  2.] m>
1867 
1868         >>> q = [[1, 2], [3, 4]] * u.m
1869         >>> q.insert(1, [10, 20] * u.m, axis=0)
1870         <Quantity [[  1.,  2.],
1871                    [ 10., 20.],
1872                    [  3.,  4.]] m>
1873 
1874         >>> q.insert(1, 10 * u.m, axis=1)
1875         <Quantity [[  1., 10.,  2.],
1876                    [  3., 10.,  4.]] m>
1877 
1878         """
1879         out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)
1880         return self._new_view(out_array)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 15:23:28.962 | INFO     | Search completed. Bug locations: [<file>astropy/units/quantity.py</file>
<class>Quantity</class>
<method>mean</method>
<code>
1801     def mean(self, axis=None, dtype=None, out=None, keepdims=False):
1802         return self._wrap_function(np.mean, axis, dtype, out=out,
1803                                    keepdims=keepdims)

</code><intended_behavior>The `mean` method needs to be updated to support the `where` keyword argument. This involves modifying its signature to either explicitly include `where=None` or to accept arbitrary keyword arguments via `**kwargs`. The method should then pass `where` (or `**kwargs` if this approach is chosen) to `np.mean` when called. This will ensure that when users of `astropy.units.Quantity` objects call the `mean` method with the `where` keyword argument, this argument effectively influences the computation as intended when passed along to the underlying `np.mean` function, without breaking backward compatibility. The modification should handle the `where` condition correctly by incorporating any necessary pre-processing to align with the units management in `Quantity`, thereby preserving the existing functionality while extending support for new uses enabled by the `where` argument in `numpy.mean`.</intended_behavior>, <file>astropy/units/quantity.py</file>
<class>Quantity</class>
<method>None</method>
<code>
238 class Quantity(np.ndarray):
239     """A `~astropy.units.Quantity` represents a number with some associated unit.
240 
241     See also: https://docs.astropy.org/en/stable/units/quantity.html
242 
243     Parameters
244     ----------
245     value : number, `~numpy.ndarray`, `~astropy.units.Quantity` (sequence), or str
246         The numerical value of this quantity in the units given by unit.  If a
247         `Quantity` or sequence of them (or any other valid object with a
248         ``unit`` attribute), creates a new `Quantity` object, converting to
249         `unit` units as needed.  If a string, it is converted to a number or
250         `Quantity`, depending on whether a unit is present.
251 
252     unit : unit-like
253         An object that represents the unit associated with the input value.
254         Must be an `~astropy.units.UnitBase` object or a string parseable by
255         the :mod:`~astropy.units` package.
256 
257     dtype : ~numpy.dtype, optional
258         The dtype of the resulting Numpy array or scalar that will
259         hold the value.  If not provided, it is determined from the input,
260         except that any integer and (non-Quantity) object inputs are converted
261         to float by default.
262 
263     copy : bool, optional
264         If `True` (default), then the value is copied.  Otherwise, a copy will
265         only be made if ``__array__`` returns a copy, if value is a nested
266         sequence, or if a copy is needed to satisfy an explicitly given
267         ``dtype``.  (The `False` option is intended mostly for internal use,
268         to speed up initialization where a copy is known to have been made.
269         Use with care.)
270 
271     order : {'C', 'F', 'A'}, optional
272         Specify the order of the array.  As in `~numpy.array`.  This parameter
273         is ignored if the input is a `Quantity` and ``copy=False``.
274 
275     subok : bool, optional
276         If `False` (default), the returned array will be forced to be a
277         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,
278         or a subclass appropriate for the unit will be used (such as
279         `~astropy.units.Dex` for ``u.dex(u.AA)``).
280 
281     ndmin : int, optional
282         Specifies the minimum number of dimensions that the resulting array
283         should have.  Ones will be pre-pended to the shape as needed to meet
284         this requirement.  This parameter is ignored if the input is a
285         `Quantity` and ``copy=False``.
286 
287     Raises
288     ------
289     TypeError
290         If the value provided is not a Python numeric type.
291     TypeError
292         If the unit provided is not either a :class:`~astropy.units.Unit`
293         object or a parseable string unit.
294 
295     Notes
296     -----
297     Quantities can also be created by multiplying a number or array with a
298     :class:`~astropy.units.Unit`. See https://docs.astropy.org/en/latest/units/
299 
300     Unless the ``dtype`` argument is explicitly specified, integer
301     or (non-Quantity) object inputs are converted to `float` by default.
302     """
303     # Need to set a class-level default for _equivalencies, or
304     # Constants can not initialize properly
305     _equivalencies = []
306 
307     # Default unit for initialization; can be overridden by subclasses,
308     # possibly to `None` to indicate there is no default unit.
309     _default_unit = dimensionless_unscaled
310 
311     # Ensures views have an undefined unit.
312     _unit = None
313 
314     __array_priority__ = 10000
315 
316     def __class_getitem__(cls, unit_shape_dtype):
317         """Quantity Type Hints.
318 
319         Unit-aware type hints are ``Annotated`` objects that encode the class,
320         the unit, and possibly shape and dtype information, depending on the
321         python and :mod:`numpy` versions.
322 
323         Schematically, ``Annotated[cls[shape, dtype], unit]``
324 
325         As a classmethod, the type is the class, ie ``Quantity``
326         produces an ``Annotated[Quantity, ...]`` while a subclass
327         like :class:`~astropy.coordinates.Angle` returns
328         ``Annotated[Angle, ...]``.
329 
330         Parameters
331         ----------
332         unit_shape_dtype : :class:`~astropy.units.UnitBase`, str, `~astropy.units.PhysicalType`, or tuple
333             Unit specification, can be the physical type (ie str or class).
334             If tuple, then the first element is the unit specification
335             and all other elements are for `numpy.ndarray` type annotations.
336             Whether they are included depends on the python and :mod:`numpy`
337             versions.
338 
339         Returns
340         -------
341         `typing.Annotated`, `typing_extensions.Annotated`, `astropy.units.Unit`, or `astropy.units.PhysicalType`
342             Return type in this preference order:
343             * if python v3.9+ : `typing.Annotated`
344             * if :mod:`typing_extensions` is installed : `typing_extensions.Annotated`
345             * `astropy.units.Unit` or `astropy.units.PhysicalType`
346 
347         Raises
348         ------
349         TypeError
350             If the unit/physical_type annotation is not Unit-like or
351             PhysicalType-like.
352 
353         Examples
354         --------
355         Create a unit-aware Quantity type annotation
356 
357             >>> Quantity[Unit("s")]
358             Annotated[Quantity, Unit("s")]
359 
360         See Also
361         --------
362         `~astropy.units.quantity_input`
363             Use annotations for unit checks on function arguments and results.
364 
365         Notes
366         -----
367         With Python 3.9+ or :mod:`typing_extensions`, |Quantity| types are also
368         static-type compatible.
369         """
370         # LOCAL
371         from ._typing import HAS_ANNOTATED, Annotated
372 
373         # process whether [unit] or [unit, shape, ptype]
374         if isinstance(unit_shape_dtype, tuple):  # unit, shape, dtype
375             target = unit_shape_dtype[0]
376             shape_dtype = unit_shape_dtype[1:]
377         else:  # just unit
378             target = unit_shape_dtype
379             shape_dtype = ()
380 
381         # Allowed unit/physical types. Errors if neither.
382         try:
383             unit = Unit(target)
384         except (TypeError, ValueError):
385             from astropy.units.physical import get_physical_type
386 
387             try:
388                 unit = get_physical_type(target)
389             except (TypeError, ValueError, KeyError):  # KeyError for Enum
390                 raise TypeError("unit annotation is not a Unit or PhysicalType") from None
391 
392         # Allow to sort of work for python 3.8- / no typing_extensions
393         # instead of bailing out, return the unit for `quantity_input`
394         if not HAS_ANNOTATED:
395             warnings.warn("Quantity annotations are valid static type annotations only"
396                           " if Python is v3.9+ or `typing_extensions` is installed.")
397             return unit
398 
399         # Quantity does not (yet) properly extend the NumPy generics types,
400         # introduced in numpy v1.22+, instead just including the unit info as
401         # metadata using Annotated.
402         # TODO: ensure we do interact with NDArray.__class_getitem__.
403         return Annotated.__class_getitem__((cls, unit))
404 
405     def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,
406                 subok=False, ndmin=0):
407 
408         if unit is not None:
409             # convert unit first, to avoid multiple string->unit conversions
410             unit = Unit(unit)
411 
412         # optimize speed for Quantity with no dtype given, copy=False
413         if isinstance(value, Quantity):
414             if unit is not None and unit is not value.unit:
415                 value = value.to(unit)
416                 # the above already makes a copy (with float dtype)
417                 copy = False
418 
419             if type(value) is not cls and not (subok and
420                                                isinstance(value, cls)):
421                 value = value.view(cls)
422 
423             if dtype is None and value.dtype.kind in 'iu':
424                 dtype = float
425 
426             return np.array(value, dtype=dtype, copy=copy, order=order,
427                             subok=True, ndmin=ndmin)
428 
429         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.
430         # To ensure array remains fast, we short-circuit it.
431         value_unit = None
432         if not isinstance(value, np.ndarray):
433             if isinstance(value, str):
434                 # The first part of the regex string matches any integer/float;
435                 # the second parts adds possible trailing .+-, which will break
436                 # the float function below and ensure things like 1.2.3deg
437                 # will not work.
438                 pattern = (r'\s*[+-]?'
439                            r'((\d+\.?\d*)|(\.\d+)|([nN][aA][nN])|'
440                            r'([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))'
441                            r'([eE][+-]?\d+)?'
442                            r'[.+-]?')
443 
444                 v = re.match(pattern, value)
445                 unit_string = None
446                 try:
447                     value = float(v.group())
448 
449                 except Exception:
450                     raise TypeError('Cannot parse "{}" as a {}. It does not '
451                                     'start with a number.'
452                                     .format(value, cls.__name__))
453 
454                 unit_string = v.string[v.end():].strip()
455                 if unit_string:
456                     value_unit = Unit(unit_string)
457                     if unit is None:
458                         unit = value_unit  # signal no conversion needed below.
459 
460             elif isiterable(value) and len(value) > 0:
461                 # Iterables like lists and tuples.
462                 if all(isinstance(v, Quantity) for v in value):
463                     # If a list/tuple containing only quantities, convert all
464                     # to the same unit.
465                     if unit is None:
466                         unit = value[0].unit
467                     value = [q.to_value(unit) for q in value]
468                     value_unit = unit  # signal below that conversion has been done
469                 elif (dtype is None and not hasattr(value, 'dtype')
470                       and isinstance(unit, StructuredUnit)):
471                     # Special case for list/tuple of values and a structured unit:
472                     # ``np.array(value, dtype=None)`` would treat tuples as lower
473                     # levels of the array, rather than as elements of a structured
474                     # array, so we use the structure of the unit to help infer the
475                     # structured dtype of the value.
476                     dtype = unit._recursively_get_dtype(value)
477 
478         if value_unit is None:
479             # If the value has a `unit` attribute and if not None
480             # (for Columns with uninitialized unit), treat it like a quantity.
481             value_unit = getattr(value, 'unit', None)
482             if value_unit is None:
483                 # Default to dimensionless for no (initialized) unit attribute.
484                 if unit is None:
485                     unit = cls._default_unit
486                 value_unit = unit  # signal below that no conversion is needed
487             else:
488                 try:
489                     value_unit = Unit(value_unit)
490                 except Exception as exc:
491                     raise TypeError("The unit attribute {!r} of the input could "
492                                     "not be parsed as an astropy Unit, raising "
493                                     "the following exception:\n{}"
494                                     .format(value.unit, exc))
495 
496                 if unit is None:
497                     unit = value_unit
498                 elif unit is not value_unit:
499                     copy = False  # copy will be made in conversion at end
500 
501         value = np.array(value, dtype=dtype, copy=copy, order=order,
502                          subok=True, ndmin=ndmin)
503 
504         # check that array contains numbers or long int objects
505         if (value.dtype.kind in 'OSU' and
506             not (value.dtype.kind == 'O' and
507                  isinstance(value.item(0), numbers.Number))):
508             raise TypeError("The value must be a valid Python or "
509                             "Numpy numeric type.")
510 
511         # by default, cast any integer, boolean, etc., to float
512         if dtype is None and value.dtype.kind in 'iuO':
513             value = value.astype(float)
514 
515         # if we allow subclasses, allow a class from the unit.
516         if subok:
517             qcls = getattr(unit, '_quantity_class', cls)
518             if issubclass(qcls, cls):
519                 cls = qcls
520 
521         value = value.view(cls)
522         value._set_unit(value_unit)
523         if unit is value_unit:
524             return value
525         else:
526             # here we had non-Quantity input that had a "unit" attribute
527             # with a unit different from the desired one.  So, convert.
528             return value.to(unit)
529 
530     def __array_finalize__(self, obj):
531         # Check whether super().__array_finalize should be called
532         # (sadly, ndarray.__array_finalize__ is None; we cannot be sure
533         # what is above us).
534         super_array_finalize = super().__array_finalize__
535         if super_array_finalize is not None:
536             super_array_finalize(obj)
537 
538         # If we're a new object or viewing an ndarray, nothing has to be done.
539         if obj is None or obj.__class__ is np.ndarray:
540             return
541 
542         # If our unit is not set and obj has a valid one, use it.
543         if self._unit is None:
544             unit = getattr(obj, '_unit', None)
545             if unit is not None:
546                 self._set_unit(unit)
547 
548         # Copy info if the original had `info` defined.  Because of the way the
549         # DataInfo works, `'info' in obj.__dict__` is False until the
550         # `info` attribute is accessed or set.
551         if 'info' in obj.__dict__:
552             self.info = obj.info
553 
554     def __array_wrap__(self, obj, context=None):
555 
556         if context is None:
557             # Methods like .squeeze() created a new `ndarray` and then call
558             # __array_wrap__ to turn the array into self's subclass.
559             return self._new_view(obj)
560 
561         raise NotImplementedError('__array_wrap__ should not be used '
562                                   'with a context any more since all use '
563                                   'should go through array_function. '
564                                   'Please raise an issue on '
565                                   'https://github.com/astropy/astropy')
566 
567     def __array_ufunc__(self, function, method, *inputs, **kwargs):
568         """Wrap numpy ufuncs, taking care of units.
569 
570         Parameters
571         ----------
572         function : callable
573             ufunc to wrap.
574         method : str
575             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.
576         inputs : tuple
577             Input arrays.
578         kwargs : keyword arguments
579             As passed on, with ``out`` containing possible quantity output.
580 
581         Returns
582         -------
583         result : `~astropy.units.Quantity`
584             Results of the ufunc, with the unit set properly.
585         """
586         # Determine required conversion functions -- to bring the unit of the
587         # input to that expected (e.g., radian for np.sin), or to get
588         # consistent units between two inputs (e.g., in np.add) --
589         # and the unit of the result (or tuple of units for nout > 1).
590         converters, unit = converters_and_unit(function, method, *inputs)
591 
592         out = kwargs.get('out', None)
593         # Avoid loop back by turning any Quantity output into array views.
594         if out is not None:
595             # If pre-allocated output is used, check it is suitable.
596             # This also returns array view, to ensure we don't loop back.
597             if function.nout == 1:
598                 out = out[0]
599             out_array = check_output(out, unit, inputs, function=function)
600             # Ensure output argument remains a tuple.
601             kwargs['out'] = (out_array,) if function.nout == 1 else out_array
602 
603         # Same for inputs, but here also convert if necessary.
604         arrays = []
605         for input_, converter in zip(inputs, converters):
606             input_ = getattr(input_, 'value', input_)
607             arrays.append(converter(input_) if converter else input_)
608 
609         # Call our superclass's __array_ufunc__
610         result = super().__array_ufunc__(function, method, *arrays, **kwargs)
611         # If unit is None, a plain array is expected (e.g., comparisons), which
612         # means we're done.
613         # We're also done if the result was None (for method 'at') or
614         # NotImplemented, which can happen if other inputs/outputs override
615         # __array_ufunc__; hopefully, they can then deal with us.
616         if unit is None or result is None or result is NotImplemented:
617             return result
618 
619         return self._result_as_quantity(result, unit, out)
620 
621     def _result_as_quantity(self, result, unit, out):
622         """Turn result into a quantity with the given unit.
623 
624         If no output is given, it will take a view of the array as a quantity,
625         and set the unit.  If output is given, those should be quantity views
626         of the result arrays, and the function will just set the unit.
627 
628         Parameters
629         ----------
630         result : ndarray or tuple thereof
631             Array(s) which need to be turned into quantity.
632         unit : `~astropy.units.Unit`
633             Unit for the quantities to be returned (or `None` if the result
634             should not be a quantity).  Should be tuple if result is a tuple.
635         out : `~astropy.units.Quantity` or None
636             Possible output quantity. Should be `None` or a tuple if result
637             is a tuple.
638 
639         Returns
640         -------
641         out : `~astropy.units.Quantity`
642            With units set.
643         """
644         if isinstance(result, (tuple, list)):
645             if out is None:
646                 out = (None,) * len(result)
647             return result.__class__(
648                 self._result_as_quantity(result_, unit_, out_)
649                 for (result_, unit_, out_) in
650                 zip(result, unit, out))
651 
652         if out is None:
653             # View the result array as a Quantity with the proper unit.
654             return result if unit is None else self._new_view(result, unit)
655 
656         # For given output, just set the unit. We know the unit is not None and
657         # the output is of the correct Quantity subclass, as it was passed
658         # through check_output.
659         out._set_unit(unit)
660         return out
661 
662     def __quantity_subclass__(self, unit):
663         """
664         Overridden by subclasses to change what kind of view is
665         created based on the output unit of an operation.
666 
667         Parameters
668         ----------
669         unit : UnitBase
670             The unit for which the appropriate class should be returned
671 
672         Returns
673         -------
674         tuple :
675             - `~astropy.units.Quantity` subclass
676             - bool: True if subclasses of the given class are ok
677         """
678         return Quantity, True
679 
680     def _new_view(self, obj=None, unit=None):
681         """
682         Create a Quantity view of some array-like input, and set the unit
683 
684         By default, return a view of ``obj`` of the same class as ``self`` and
685         with the same unit.  Subclasses can override the type of class for a
686         given unit using ``__quantity_subclass__``, and can ensure properties
687         other than the unit are copied using ``__array_finalize__``.
688 
689         If the given unit defines a ``_quantity_class`` of which ``self``
690         is not an instance, a view using this class is taken.
691 
692         Parameters
693         ----------
694         obj : ndarray or scalar, optional
695             The array to create a view of.  If obj is a numpy or python scalar,
696             it will be converted to an array scalar.  By default, ``self``
697             is converted.
698 
699         unit : unit-like, optional
700             The unit of the resulting object.  It is used to select a
701             subclass, and explicitly assigned to the view if given.
702             If not given, the subclass and unit will be that of ``self``.
703 
704         Returns
705         -------
706         view : `~astropy.units.Quantity` subclass
707         """
708         # Determine the unit and quantity subclass that we need for the view.
709         if unit is None:
710             unit = self.unit
711             quantity_subclass = self.__class__
712         elif unit is self.unit and self.__class__ is Quantity:
713             # The second part is because we should not presume what other
714             # classes want to do for the same unit.  E.g., Constant will
715             # always want to fall back to Quantity, and relies on going
716             # through `__quantity_subclass__`.
717             quantity_subclass = Quantity
718         else:
719             unit = Unit(unit)
720             quantity_subclass = getattr(unit, '_quantity_class', Quantity)
721             if isinstance(self, quantity_subclass):
722                 quantity_subclass, subok = self.__quantity_subclass__(unit)
723                 if subok:
724                     quantity_subclass = self.__class__
725 
726         # We only want to propagate information from ``self`` to our new view,
727         # so obj should be a regular array.  By using ``np.array``, we also
728         # convert python and numpy scalars, which cannot be viewed as arrays
729         # and thus not as Quantity either, to zero-dimensional arrays.
730         # (These are turned back into scalar in `.value`)
731         # Note that for an ndarray input, the np.array call takes only double
732         # ``obj.__class is np.ndarray``. So, not worth special-casing.
733         if obj is None:
734             obj = self.view(np.ndarray)
735         else:
736             obj = np.array(obj, copy=False, subok=True)
737 
738         # Take the view, set the unit, and update possible other properties
739         # such as ``info``, ``wrap_angle`` in `Longitude`, etc.
740         view = obj.view(quantity_subclass)
741         view._set_unit(unit)
742         view.__array_finalize__(self)
743         return view
744 
745     def _set_unit(self, unit):
746         """Set the unit.
747 
748         This is used anywhere the unit is set or modified, i.e., in the
749         initilizer, in ``__imul__`` and ``__itruediv__`` for in-place
750         multiplication and division by another unit, as well as in
751         ``__array_finalize__`` for wrapping up views.  For Quantity, it just
752         sets the unit, but subclasses can override it to check that, e.g.,
753         a unit is consistent.
754         """
755         if not isinstance(unit, UnitBase):
756             if (isinstance(self._unit, StructuredUnit)
757                     or isinstance(unit, StructuredUnit)):
758                 unit = StructuredUnit(unit, self.dtype)
759             else:
760                 # Trying to go through a string ensures that, e.g., Magnitudes with
761                 # dimensionless physical unit become Quantity with units of mag.
762                 unit = Unit(str(unit), parse_strict='silent')
763                 if not isinstance(unit, (UnitBase, StructuredUnit)):
764                     raise UnitTypeError(
765                         "{} instances require normal units, not {} instances."
766                         .format(type(self).__name__, type(unit)))
767 
768         self._unit = unit
769 
770     def __deepcopy__(self, memo):
771         # If we don't define this, ``copy.deepcopy(quantity)`` will
772         # return a bare Numpy array.
773         return self.copy()
774 
775     def __reduce__(self):
776         # patch to pickle Quantity objects (ndarray subclasses), see
777         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
778 
779         object_state = list(super().__reduce__())
780         object_state[2] = (object_state[2], self.__dict__)
781         return tuple(object_state)
782 
783     def __setstate__(self, state):
784         # patch to unpickle Quantity objects (ndarray subclasses), see
785         # http://www.mail-archive.com/numpy-discussion@scipy.org/msg02446.html
786 
787         nd_state, own_state = state
788         super().__setstate__(nd_state)
789         self.__dict__.update(own_state)
790 
791     info = QuantityInfo()
792 
793     def _to_value(self, unit, equivalencies=[]):
794         """Helper method for to and to_value."""
795         if equivalencies == []:
796             equivalencies = self._equivalencies
797         if not self.dtype.names or isinstance(self.unit, StructuredUnit):
798             # Standard path, let unit to do work.
799             return self.unit.to(unit, self.view(np.ndarray),
800                                 equivalencies=equivalencies)
801 
802         else:
803             # The .to() method of a simple unit cannot convert a structured
804             # dtype, so we work around it, by recursing.
805             # TODO: deprecate this?
806             # Convert simple to Structured on initialization?
807             result = np.empty_like(self.view(np.ndarray))
808             for name in self.dtype.names:
809                 result[name] = self[name]._to_value(unit, equivalencies)
810             return result
811 
812     def to(self, unit, equivalencies=[], copy=True):
813         """
814         Return a new `~astropy.units.Quantity` object with the specified unit.
815 
816         Parameters
817         ----------
818         unit : unit-like
819             An object that represents the unit to convert to. Must be
820             an `~astropy.units.UnitBase` object or a string parseable
821             by the `~astropy.units` package.
822 
823         equivalencies : list of tuple
824             A list of equivalence pairs to try if the units are not
825             directly convertible.  See :ref:`astropy:unit_equivalencies`.
826             If not provided or ``[]``, class default equivalencies will be used
827             (none for `~astropy.units.Quantity`, but may be set for subclasses)
828             If `None`, no equivalencies will be applied at all, not even any
829             set globally or within a context.
830 
831         copy : bool, optional
832             If `True` (default), then the value is copied.  Otherwise, a copy
833             will only be made if necessary.
834 
835         See also
836         --------
837         to_value : get the numerical value in a given unit.
838         """
839         # We don't use `to_value` below since we always want to make a copy
840         # and don't want to slow down this method (esp. the scalar case).
841         unit = Unit(unit)
842         if copy:
843             # Avoid using to_value to ensure that we make a copy. We also
844             # don't want to slow down this method (esp. the scalar case).
845             value = self._to_value(unit, equivalencies)
846         else:
847             # to_value only copies if necessary
848             value = self.to_value(unit, equivalencies)
849         return self._new_view(value, unit)
850 
851     def to_value(self, unit=None, equivalencies=[]):
852         """
853         The numerical value, possibly in a different unit.
854 
855         Parameters
856         ----------
857         unit : unit-like, optional
858             The unit in which the value should be given. If not given or `None`,
859             use the current unit.
860 
861         equivalencies : list of tuple, optional
862             A list of equivalence pairs to try if the units are not directly
863             convertible (see :ref:`astropy:unit_equivalencies`). If not provided
864             or ``[]``, class default equivalencies will be used (none for
865             `~astropy.units.Quantity`, but may be set for subclasses).
866             If `None`, no equivalencies will be applied at all, not even any
867             set globally or within a context.
868 
869         Returns
870         -------
871         value : ndarray or scalar
872             The value in the units specified. For arrays, this will be a view
873             of the data if no unit conversion was necessary.
874 
875         See also
876         --------
877         to : Get a new instance in a different unit.
878         """
879         if unit is None or unit is self.unit:
880             value = self.view(np.ndarray)
881         elif not self.dtype.names:
882             # For non-structured, we attempt a short-cut, where we just get
883             # the scale.  If that is 1, we do not have to do anything.
884             unit = Unit(unit)
885             # We want a view if the unit does not change.  One could check
886             # with "==", but that calculates the scale that we need anyway.
887             # TODO: would be better for `unit.to` to have an in-place flag.
888             try:
889                 scale = self.unit._to(unit)
890             except Exception:
891                 # Short-cut failed; try default (maybe equivalencies help).
892                 value = self._to_value(unit, equivalencies)
893             else:
894                 value = self.view(np.ndarray)
895                 if not is_effectively_unity(scale):
896                     # not in-place!
897                     value = value * scale
898         else:
899             # For structured arrays, we go the default route.
900             value = self._to_value(unit, equivalencies)
901 
902         # Index with empty tuple to decay array scalars in to numpy scalars.
903         return value if value.shape else value[()]
904 
905     value = property(to_value,
906                      doc="""The numerical value of this instance.
907 
908     See also
909     --------
910     to_value : Get the numerical value in a given unit.
911     """)
912 
913     @property
914     def unit(self):
915         """
916         A `~astropy.units.UnitBase` object representing the unit of this
917         quantity.
918         """
919 
920         return self._unit
921 
922     @property
923     def equivalencies(self):
924         """
925         A list of equivalencies that will be applied by default during
926         unit conversions.
927         """
928 
929         return self._equivalencies
930 
931     def _recursively_apply(self, func):
932         """Apply function recursively to every field.
933 
934         Returns a copy with the result.
935         """
936         result = np.empty_like(self)
937         result_value = result.view(np.ndarray)
938         result_unit = ()
939         for name in self.dtype.names:
940             part = func(self[name])
941             result_value[name] = part.value
942             result_unit += (part.unit,)
943 
944         result._set_unit(result_unit)
945         return result
946 
947     @property
948     def si(self):
949         """
950         Returns a copy of the current `Quantity` instance with SI units. The
951         value of the resulting object will be scaled.
952         """
953         if self.dtype.names:
954             return self._recursively_apply(operator.attrgetter('si'))
955         si_unit = self.unit.si
956         return self._new_view(self.value * si_unit.scale,
957                               si_unit / si_unit.scale)
958 
959     @property
960     def cgs(self):
961         """
962         Returns a copy of the current `Quantity` instance with CGS units. The
963         value of the resulting object will be scaled.
964         """
965         if self.dtype.names:
966             return self._recursively_apply(operator.attrgetter('cgs'))
967         cgs_unit = self.unit.cgs
968         return self._new_view(self.value * cgs_unit.scale,
969                               cgs_unit / cgs_unit.scale)
970 
971     @property
972     def isscalar(self):
973         """
974         True if the `value` of this quantity is a scalar, or False if it
975         is an array-like object.
976 
977         .. note::
978             This is subtly different from `numpy.isscalar` in that
979             `numpy.isscalar` returns False for a zero-dimensional array
980             (e.g. ``np.array(1)``), while this is True for quantities,
981             since quantities cannot represent true numpy scalars.
982         """
983         return not self.shape
984 
985     # This flag controls whether convenience conversion members, such
986     # as `q.m` equivalent to `q.to_value(u.m)` are available.  This is
987     # not turned on on Quantity itself, but is on some subclasses of
988     # Quantity, such as `astropy.coordinates.Angle`.
989     _include_easy_conversion_members = False
990 
991     @override__dir__
992     def __dir__(self):
993         """
994         Quantities are able to directly convert to other units that
995         have the same physical type.  This function is implemented in
996         order to make autocompletion still work correctly in IPython.
997         """
998         if not self._include_easy_conversion_members:
999             return []
1000         extra_members = set()
1001         equivalencies = Unit._normalize_equivalencies(self.equivalencies)
1002         for equivalent in self.unit._get_units_with_same_physical_type(
1003                 equivalencies):
1004             extra_members.update(equivalent.names)
1005         return extra_members
1006 
1007     def __getattr__(self, attr):
1008         """
1009         Quantities are able to directly convert to other units that
1010         have the same physical type.
1011         """
1012         if not self._include_easy_conversion_members:
1013             raise AttributeError(
1014                 f"'{self.__class__.__name__}' object has no '{attr}' member")
1015 
1016         def get_virtual_unit_attribute():
1017             registry = get_current_unit_registry().registry
1018             to_unit = registry.get(attr, None)
1019             if to_unit is None:
1020                 return None
1021 
1022             try:
1023                 return self.unit.to(
1024                     to_unit, self.value, equivalencies=self.equivalencies)
1025             except UnitsError:
1026                 return None
1027 
1028         value = get_virtual_unit_attribute()
1029 
1030         if value is None:
1031             raise AttributeError(
1032                 f"{self.__class__.__name__} instance has no attribute '{attr}'")
1033         else:
1034             return value
1035 
1036     # Equality needs to be handled explicitly as ndarray.__eq__ gives
1037     # DeprecationWarnings on any error, which is distracting, and does not
1038     # deal well with structured arrays (nor does the ufunc).
1039     def __eq__(self, other):
1040         try:
1041             other_value = self._to_own_unit(other)
1042         except UnitsError:
1043             return False
1044         except Exception:
1045             return NotImplemented
1046         return self.value.__eq__(other_value)
1047 
1048     def __ne__(self, other):
1049         try:
1050             other_value = self._to_own_unit(other)
1051         except UnitsError:
1052             return True
1053         except Exception:
1054             return NotImplemented
1055         return self.value.__ne__(other_value)
1056 
1057     # Unit conversion operator (<<).
1058     def __lshift__(self, other):
1059         try:
1060             other = Unit(other, parse_strict='silent')
1061         except UnitTypeError:
1062             return NotImplemented
1063 
1064         return self.__class__(self, other, copy=False, subok=True)
1065 
1066     def __ilshift__(self, other):
1067         try:
1068             other = Unit(other, parse_strict='silent')
1069         except UnitTypeError:
1070             return NotImplemented
1071 
1072         try:
1073             factor = self.unit._to(other)
1074         except Exception:
1075             # Maybe via equivalencies?  Now we do make a temporary copy.
1076             try:
1077                 value = self._to_value(other)
1078             except UnitConversionError:
1079                 return NotImplemented
1080 
1081             self.view(np.ndarray)[...] = value
1082 
1083         else:
1084             self.view(np.ndarray)[...] *= factor
1085 
1086         self._set_unit(other)
1087         return self
1088 
1089     def __rlshift__(self, other):
1090         if not self.isscalar:
1091             return NotImplemented
1092         return Unit(self).__rlshift__(other)
1093 
1094     # Give warning for other >> self, since probably other << self was meant.
1095     def __rrshift__(self, other):
1096         warnings.warn(">> is not implemented. Did you mean to convert "
1097                       "something to this quantity as a unit using '<<'?",
1098                       AstropyWarning)
1099         return NotImplemented
1100 
1101     # Also define __rshift__ and __irshift__ so we override default ndarray
1102     # behaviour, but instead of emitting a warning here, let it be done by
1103     # other (which likely is a unit if this was a mistake).
1104     def __rshift__(self, other):
1105         return NotImplemented
1106 
1107     def __irshift__(self, other):
1108         return NotImplemented
1109 
1110     # Arithmetic operations
1111     def __mul__(self, other):
1112         """ Multiplication between `Quantity` objects and other objects."""
1113 
1114         if isinstance(other, (UnitBase, str)):
1115             try:
1116                 return self._new_view(self.copy(), other * self.unit)
1117             except UnitsError:  # let other try to deal with it
1118                 return NotImplemented
1119 
1120         return super().__mul__(other)
1121 
1122     def __imul__(self, other):
1123         """In-place multiplication between `Quantity` objects and others."""
1124 
1125         if isinstance(other, (UnitBase, str)):
1126             self._set_unit(other * self.unit)
1127             return self
1128 
1129         return super().__imul__(other)
1130 
1131     def __rmul__(self, other):
1132         """ Right Multiplication between `Quantity` objects and other
1133         objects.
1134         """
1135 
1136         return self.__mul__(other)
1137 
1138     def __truediv__(self, other):
1139         """ Division between `Quantity` objects and other objects."""
1140 
1141         if isinstance(other, (UnitBase, str)):
1142             try:
1143                 return self._new_view(self.copy(), self.unit / other)
1144             except UnitsError:  # let other try to deal with it
1145                 return NotImplemented
1146 
1147         return super().__truediv__(other)
1148 
1149     def __itruediv__(self, other):
1150         """Inplace division between `Quantity` objects and other objects."""
1151 
1152         if isinstance(other, (UnitBase, str)):
1153             self._set_unit(self.unit / other)
1154             return self
1155 
1156         return super().__itruediv__(other)
1157 
1158     def __rtruediv__(self, other):
1159         """ Right Division between `Quantity` objects and other objects."""
1160 
1161         if isinstance(other, (UnitBase, str)):
1162             return self._new_view(1. / self.value, other / self.unit)
1163 
1164         return super().__rtruediv__(other)
1165 
1166     def __pow__(self, other):
1167         if isinstance(other, Fraction):
1168             # Avoid getting object arrays by raising the value to a Fraction.
1169             return self._new_view(self.value ** float(other),
1170                                   self.unit ** other)
1171 
1172         return super().__pow__(other)
1173 
1174     # other overrides of special functions
1175     def __hash__(self):
1176         return hash(self.value) ^ hash(self.unit)
1177 
1178     def __iter__(self):
1179         if self.isscalar:
1180             raise TypeError(
1181                 "'{cls}' object with a scalar value is not iterable"
1182                 .format(cls=self.__class__.__name__))
1183 
1184         # Otherwise return a generator
1185         def quantity_iter():
1186             for val in self.value:
1187                 yield self._new_view(val)
1188 
1189         return quantity_iter()
1190 
1191     def __getitem__(self, key):
1192         if isinstance(key, str) and isinstance(self.unit, StructuredUnit):
1193             return self._new_view(self.view(np.ndarray)[key], self.unit[key])
1194 
1195         try:
1196             out = super().__getitem__(key)
1197         except IndexError:
1198             # We want zero-dimensional Quantity objects to behave like scalars,
1199             # so they should raise a TypeError rather than an IndexError.
1200             if self.isscalar:
1201                 raise TypeError(
1202                     "'{cls}' object with a scalar value does not support "
1203                     "indexing".format(cls=self.__class__.__name__))
1204             else:
1205                 raise
1206         # For single elements, ndarray.__getitem__ returns scalars; these
1207         # need a new view as a Quantity.
1208         if not isinstance(out, np.ndarray):
1209             out = self._new_view(out)
1210         return out
1211 
1212     def __setitem__(self, i, value):
1213         if isinstance(i, str):
1214             # Indexing will cause a different unit, so by doing this in
1215             # two steps we effectively try with the right unit.
1216             self[i][...] = value
1217             return
1218 
1219         # update indices in info if the info property has been accessed
1220         # (in which case 'info' in self.__dict__ is True; this is guaranteed
1221         # to be the case if we're part of a table).
1222         if not self.isscalar and 'info' in self.__dict__:
1223             self.info.adjust_indices(i, value, len(self))
1224         self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
1225 
1226     # __contains__ is OK
1227 
1228     def __bool__(self):
1229         """Quantities should always be treated as non-False; there is too much
1230         potential for ambiguity otherwise.
1231         """
1232         warnings.warn('The truth value of a Quantity is ambiguous. '
1233                       'In the future this will raise a ValueError.',
1234                       AstropyDeprecationWarning)
1235         return True
1236 
1237     def __len__(self):
1238         if self.isscalar:
1239             raise TypeError("'{cls}' object with a scalar value has no "
1240                             "len()".format(cls=self.__class__.__name__))
1241         else:
1242             return len(self.value)
1243 
1244     # Numerical types
1245     def __float__(self):
1246         try:
1247             return float(self.to_value(dimensionless_unscaled))
1248         except (UnitsError, TypeError):
1249             raise TypeError('only dimensionless scalar quantities can be '
1250                             'converted to Python scalars')
1251 
1252     def __int__(self):
1253         try:
1254             return int(self.to_value(dimensionless_unscaled))
1255         except (UnitsError, TypeError):
1256             raise TypeError('only dimensionless scalar quantities can be '
1257                             'converted to Python scalars')
1258 
1259     def __index__(self):
1260         # for indices, we do not want to mess around with scaling at all,
1261         # so unlike for float, int, we insist here on unscaled dimensionless
1262         try:
1263             assert self.unit.is_unity()
1264             return self.value.__index__()
1265         except Exception:
1266             raise TypeError('only integer dimensionless scalar quantities '
1267                             'can be converted to a Python index')
1268 
1269     # TODO: we may want to add a hook for dimensionless quantities?
1270     @property
1271     def _unitstr(self):
1272         if self.unit is None:
1273             unitstr = _UNIT_NOT_INITIALISED
1274         else:
1275             unitstr = str(self.unit)
1276 
1277         if unitstr:
1278             unitstr = ' ' + unitstr
1279 
1280         return unitstr
1281 
1282     def to_string(self, unit=None, precision=None, format=None, subfmt=None):
1283         """
1284         Generate a string representation of the quantity and its unit.
1285 
1286         The behavior of this function can be altered via the
1287         `numpy.set_printoptions` function and its various keywords.  The
1288         exception to this is the ``threshold`` keyword, which is controlled via
1289         the ``[units.quantity]`` configuration item ``latex_array_threshold``.
1290         This is treated separately because the numpy default of 1000 is too big
1291         for most browsers to handle.
1292 
1293         Parameters
1294         ----------
1295         unit : unit-like, optional
1296             Specifies the unit.  If not provided,
1297             the unit used to initialize the quantity will be used.
1298 
1299         precision : number, optional
1300             The level of decimal precision. If `None`, or not provided,
1301             it will be determined from NumPy print options.
1302 
1303         format : str, optional
1304             The format of the result. If not provided, an unadorned
1305             string is returned. Supported values are:
1306 
1307             - 'latex': Return a LaTeX-formatted string
1308 
1309             - 'latex_inline': Return a LaTeX-formatted string that uses
1310               negative exponents instead of fractions
1311 
1312         subfmt : str, optional
1313             Subformat of the result. For the moment, only used for
1314             ``format='latex'`` and ``format='latex_inline'``. Supported
1315             values are:
1316 
1317             - 'inline': Use ``$ ... $`` as delimiters.
1318 
1319             - 'display': Use ``$\\displaystyle ... $`` as delimiters.
1320 
1321         Returns
1322         -------
1323         str
1324             A string with the contents of this Quantity
1325         """
1326         if unit is not None and unit != self.unit:
1327             return self.to(unit).to_string(
1328                 unit=None, precision=precision, format=format, subfmt=subfmt)
1329 
1330         formats = {
1331             None: None,
1332             "latex": {
1333                 None: ("$", "$"),
1334                 "inline": ("$", "$"),
1335                 "display": (r"$\displaystyle ", r"$"),
1336             },
1337         }
1338         formats['latex_inline'] = formats['latex']
1339 
1340         if format not in formats:
1341             raise ValueError(f"Unknown format '{format}'")
1342         elif format is None:
1343             if precision is None:
1344                 # Use default formatting settings
1345                 return f'{self.value}{self._unitstr:s}'
1346             else:
1347                 # np.array2string properly formats arrays as well as scalars
1348                 return np.array2string(self.value, precision=precision,
1349                                        floatmode="fixed") + self._unitstr
1350 
1351         # else, for the moment we assume format="latex" or "latex_inline".
1352 
1353         # Set the precision if set, otherwise use numpy default
1354         pops = np.get_printoptions()
1355         format_spec = f".{precision if precision is not None else pops['precision']}g"
1356 
1357         def float_formatter(value):
1358             return Latex.format_exponential_notation(value,
1359                                                      format_spec=format_spec)
1360 
1361         def complex_formatter(value):
1362             return '({}{}i)'.format(
1363                 Latex.format_exponential_notation(value.real,
1364                                                   format_spec=format_spec),
1365                 Latex.format_exponential_notation(value.imag,
1366                                                   format_spec='+' + format_spec))
1367 
1368         # The view is needed for the scalar case - self.value might be float.
1369         latex_value = np.array2string(
1370             self.view(np.ndarray),
1371             threshold=(conf.latex_array_threshold
1372                        if conf.latex_array_threshold > -1 else pops['threshold']),
1373             formatter={'float_kind': float_formatter,
1374                        'complex_kind': complex_formatter},
1375             max_line_width=np.inf,
1376             separator=',~')
1377 
1378         latex_value = latex_value.replace('...', r'\dots')
1379 
1380         # Format unit
1381         # [1:-1] strips the '$' on either side needed for math mode
1382         if self.unit is None:
1383             latex_unit = _UNIT_NOT_INITIALISED
1384         elif format == 'latex':
1385             latex_unit = self.unit._repr_latex_()[1:-1] # note this is unicode
1386         elif format == 'latex_inline':
1387             latex_unit = self.unit.to_string(format='latex_inline')[1:-1]
1388 
1389         delimiter_left, delimiter_right = formats[format][subfmt]
1390 
1391         return rf'{delimiter_left}{latex_value} \; {latex_unit}{delimiter_right}'
1392 
1393     def __str__(self):
1394         return self.to_string()
1395 
1396     def __repr__(self):
1397         prefixstr = '<' + self.__class__.__name__ + ' '
1398         arrstr = np.array2string(self.view(np.ndarray), separator=', ',
1399                                  prefix=prefixstr)
1400         return f'{prefixstr}{arrstr}{self._unitstr:s}>'
1401 
1402     def _repr_latex_(self):
1403         """
1404         Generate a latex representation of the quantity and its unit.
1405 
1406         Returns
1407         -------
1408         lstr
1409             A LaTeX string with the contents of this Quantity
1410         """
1411         # NOTE: This should change to display format in a future release
1412         return self.to_string(format='latex', subfmt='inline')
1413 
1414     def __format__(self, format_spec):
1415         """
1416         Format quantities using the new-style python formatting codes
1417         as specifiers for the number.
1418 
1419         If the format specifier correctly applies itself to the value,
1420         then it is used to format only the value. If it cannot be
1421         applied to the value, then it is applied to the whole string.
1422 
1423         """
1424         try:
1425             value = format(self.value, format_spec)
1426             full_format_spec = "s"
1427         except ValueError:
1428             value = self.value
1429             full_format_spec = format_spec
1430 
1431         return format(f"{value}{self._unitstr:s}",
1432                       full_format_spec)
1433 
1434     def decompose(self, bases=[]):
1435         """
1436         Generates a new `Quantity` with the units
1437         decomposed. Decomposed units have only irreducible units in
1438         them (see `astropy.units.UnitBase.decompose`).
1439 
1440         Parameters
1441         ----------
1442         bases : sequence of `~astropy.units.UnitBase`, optional
1443             The bases to decompose into.  When not provided,
1444             decomposes down to any irreducible units.  When provided,
1445             the decomposed result will only contain the given units.
1446             This will raises a `~astropy.units.UnitsError` if it's not possible
1447             to do so.
1448 
1449         Returns
1450         -------
1451         newq : `~astropy.units.Quantity`
1452             A new object equal to this quantity with units decomposed.
1453         """
1454         return self._decompose(False, bases=bases)
1455 
1456     def _decompose(self, allowscaledunits=False, bases=[]):
1457         """
1458         Generates a new `Quantity` with the units decomposed. Decomposed
1459         units have only irreducible units in them (see
1460         `astropy.units.UnitBase.decompose`).
1461 
1462         Parameters
1463         ----------
1464         allowscaledunits : bool
1465             If True, the resulting `Quantity` may have a scale factor
1466             associated with it.  If False, any scaling in the unit will
1467             be subsumed into the value of the resulting `Quantity`
1468 
1469         bases : sequence of UnitBase, optional
1470             The bases to decompose into.  When not provided,
1471             decomposes down to any irreducible units.  When provided,
1472             the decomposed result will only contain the given units.
1473             This will raises a `~astropy.units.UnitsError` if it's not possible
1474             to do so.
1475 
1476         Returns
1477         -------
1478         newq : `~astropy.units.Quantity`
1479             A new object equal to this quantity with units decomposed.
1480 
1481         """
1482 
1483         new_unit = self.unit.decompose(bases=bases)
1484 
1485         # Be careful here because self.value usually is a view of self;
1486         # be sure that the original value is not being modified.
1487         if not allowscaledunits and hasattr(new_unit, 'scale'):
1488             new_value = self.value * new_unit.scale
1489             new_unit = new_unit / new_unit.scale
1490             return self._new_view(new_value, new_unit)
1491         else:
1492             return self._new_view(self.copy(), new_unit)
1493 
1494     # These functions need to be overridden to take into account the units
1495     # Array conversion
1496     # https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-conversion
1497 
1498     def item(self, *args):
1499         """Copy an element of an array to a scalar Quantity and return it.
1500 
1501         Like :meth:`~numpy.ndarray.item` except that it always
1502         returns a `Quantity`, not a Python scalar.
1503 
1504         """
1505         return self._new_view(super().item(*args))
1506 
1507     def tolist(self):
1508         raise NotImplementedError("cannot make a list of Quantities.  Get "
1509                                   "list of values with q.value.tolist()")
1510 
1511     def _to_own_unit(self, value, check_precision=True):
1512         try:
1513             _value = value.to_value(self.unit)
1514         except AttributeError:
1515             # We're not a Quantity.
1516             # First remove two special cases (with a fast test):
1517             # 1) Maybe masked printing? MaskedArray with quantities does not
1518             # work very well, but no reason to break even repr and str.
1519             # 2) np.ma.masked? useful if we're a MaskedQuantity.
1520             if (value is np.ma.masked
1521                 or (value is np.ma.masked_print_option
1522                     and self.dtype.kind == 'O')):
1523                 return value
1524             # Now, let's try a more general conversion.
1525             # Plain arrays will be converted to dimensionless in the process,
1526             # but anything with a unit attribute will use that.
1527             try:
1528                 as_quantity = Quantity(value)
1529                 _value = as_quantity.to_value(self.unit)
1530             except UnitsError:
1531                 # last chance: if this was not something with a unit
1532                 # and is all 0, inf, or nan, we treat it as arbitrary unit.
1533                 if (not hasattr(value, 'unit') and
1534                         can_have_arbitrary_unit(as_quantity.value)):
1535                     _value = as_quantity.value
1536                 else:
1537                     raise
1538 
1539         if self.dtype.kind == 'i' and check_precision:
1540             # If, e.g., we are casting float to int, we want to fail if
1541             # precision is lost, but let things pass if it works.
1542             _value = np.array(_value, copy=False, subok=True)
1543             if not np.can_cast(_value.dtype, self.dtype):
1544                 self_dtype_array = np.array(_value, self.dtype, subok=True)
1545                 if not np.all(np.logical_or(self_dtype_array == _value,
1546                                             np.isnan(_value))):
1547                     raise TypeError("cannot convert value type to array type "
1548                                     "without precision loss")
1549 
1550         # Setting names to ensure things like equality work (note that
1551         # above will have failed already if units did not match).
1552         if self.dtype.names:
1553             _value.dtype.names = self.dtype.names
1554         return _value
1555 
1556     def itemset(self, *args):
1557         if len(args) == 0:
1558             raise ValueError("itemset must have at least one argument")
1559 
1560         self.view(np.ndarray).itemset(*(args[:-1] +
1561                                         (self._to_own_unit(args[-1]),)))
1562 
1563     def tostring(self, order='C'):
1564         raise NotImplementedError("cannot write Quantities to string.  Write "
1565                                   "array with q.value.tostring(...).")
1566 
1567     def tobytes(self, order='C'):
1568         raise NotImplementedError("cannot write Quantities to string.  Write "
1569                                   "array with q.value.tobytes(...).")
1570 
1571     def tofile(self, fid, sep="", format="%s"):
1572         raise NotImplementedError("cannot write Quantities to file.  Write "
1573                                   "array with q.value.tofile(...)")
1574 
1575     def dump(self, file):
1576         raise NotImplementedError("cannot dump Quantities to file.  Write "
1577                                   "array with q.value.dump()")
1578 
1579     def dumps(self):
1580         raise NotImplementedError("cannot dump Quantities to string.  Write "
1581                                   "array with q.value.dumps()")
1582 
1583     # astype, byteswap, copy, view, getfield, setflags OK as is
1584 
1585     def fill(self, value):
1586         self.view(np.ndarray).fill(self._to_own_unit(value))
1587 
1588     # Shape manipulation: resize cannot be done (does not own data), but
1589     # shape, transpose, swapaxes, flatten, ravel, squeeze all OK.  Only
1590     # the flat iterator needs to be overwritten, otherwise single items are
1591     # returned as numbers.
1592     @property
1593     def flat(self):
1594         """A 1-D iterator over the Quantity array.
1595 
1596         This returns a ``QuantityIterator`` instance, which behaves the same
1597         as the `~numpy.flatiter` instance returned by `~numpy.ndarray.flat`,
1598         and is similar to, but not a subclass of, Python's built-in iterator
1599         object.
1600         """
1601         return QuantityIterator(self)
1602 
1603     @flat.setter
1604     def flat(self, value):
1605         y = self.ravel()
1606         y[:] = value
1607 
1608     # Item selection and manipulation
1609     # repeat, sort, compress, diagonal OK
1610     def take(self, indices, axis=None, out=None, mode='raise'):
1611         out = super().take(indices, axis=axis, out=out, mode=mode)
1612         # For single elements, ndarray.take returns scalars; these
1613         # need a new view as a Quantity.
1614         if type(out) is not type(self):
1615             out = self._new_view(out)
1616         return out
1617 
1618     def put(self, indices, values, mode='raise'):
1619         self.view(np.ndarray).put(indices, self._to_own_unit(values), mode)
1620 
1621     def choose(self, choices, out=None, mode='raise'):
1622         raise NotImplementedError("cannot choose based on quantity.  Choose "
1623                                   "using array with q.value.choose(...)")
1624 
1625     # ensure we do not return indices as quantities
1626     def argsort(self, axis=-1, kind='quicksort', order=None):
1627         return self.view(np.ndarray).argsort(axis=axis, kind=kind, order=order)
1628 
1629     def searchsorted(self, v, *args, **kwargs):
1630         return np.searchsorted(np.array(self),
1631                                self._to_own_unit(v, check_precision=False),
1632                                *args, **kwargs)  # avoid numpy 1.6 problem
1633 
1634     def argmax(self, axis=None, out=None):
1635         return self.view(np.ndarray).argmax(axis, out=out)
1636 
1637     def argmin(self, axis=None, out=None):
1638         return self.view(np.ndarray).argmin(axis, out=out)
1639 
1640     def __array_function__(self, function, types, args, kwargs):
1641         """Wrap numpy functions, taking care of units.
1642 
1643         Parameters
1644         ----------
1645         function : callable
1646             Numpy function to wrap
1647         types : iterable of classes
1648             Classes that provide an ``__array_function__`` override. Can
1649             in principle be used to interact with other classes. Below,
1650             mostly passed on to `~numpy.ndarray`, which can only interact
1651             with subclasses.
1652         args : tuple
1653             Positional arguments provided in the function call.
1654         kwargs : dict
1655             Keyword arguments provided in the function call.
1656 
1657         Returns
1658         -------
1659         result: `~astropy.units.Quantity`, `~numpy.ndarray`
1660             As appropriate for the function.  If the function is not
1661             supported, `NotImplemented` is returned, which will lead to
1662             a `TypeError` unless another argument overrode the function.
1663 
1664         Raises
1665         ------
1666         ~astropy.units.UnitsError
1667             If operands have incompatible units.
1668         """
1669         # A function should be in one of the following sets or dicts:
1670         # 1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
1671         #    supports Quantity; we pass on to ndarray.__array_function__.
1672         # 2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
1673         #    after converting quantities to arrays with suitable units,
1674         #    and possibly setting units on the result.
1675         # 3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
1676         #    requires a Quantity-specific implementation.
1677         # 4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.
1678         # For now, since we may not yet have complete coverage, if a
1679         # function is in none of the above, we simply call the numpy
1680         # implementation.
1681         if function in SUBCLASS_SAFE_FUNCTIONS:
1682             return super().__array_function__(function, types, args, kwargs)
1683 
1684         elif function in FUNCTION_HELPERS:
1685             function_helper = FUNCTION_HELPERS[function]
1686             try:
1687                 args, kwargs, unit, out = function_helper(*args, **kwargs)
1688             except NotImplementedError:
1689                 return self._not_implemented_or_raise(function, types)
1690 
1691             result = super().__array_function__(function, types, args, kwargs)
1692             # Fall through to return section
1693 
1694         elif function in DISPATCHED_FUNCTIONS:
1695             dispatched_function = DISPATCHED_FUNCTIONS[function]
1696             try:
1697                 result, unit, out = dispatched_function(*args, **kwargs)
1698             except NotImplementedError:
1699                 return self._not_implemented_or_raise(function, types)
1700 
1701             # Fall through to return section
1702 
1703         elif function in UNSUPPORTED_FUNCTIONS:
1704             return NotImplemented
1705 
1706         else:
1707             warnings.warn("function '{}' is not known to astropy's Quantity. "
1708                           "Will run it anyway, hoping it will treat ndarray "
1709                           "subclasses correctly. Please raise an issue at "
1710                           "https://github.com/astropy/astropy/issues. "
1711                           .format(function.__name__), AstropyWarning)
1712 
1713             return super().__array_function__(function, types, args, kwargs)
1714 
1715         # If unit is None, a plain array is expected (e.g., boolean), which
1716         # means we're done.
1717         # We're also done if the result was NotImplemented, which can happen
1718         # if other inputs/outputs override __array_function__;
1719         # hopefully, they can then deal with us.
1720         if unit is None or result is NotImplemented:
1721             return result
1722 
1723         return self._result_as_quantity(result, unit, out=out)
1724 
1725     def _not_implemented_or_raise(self, function, types):
1726         # Our function helper or dispatcher found that the function does not
1727         # work with Quantity.  In principle, there may be another class that
1728         # knows what to do with us, for which we should return NotImplemented.
1729         # But if there is ndarray (or a non-Quantity subclass of it) around,
1730         # it quite likely coerces, so we should just break.
1731         if any(issubclass(t, np.ndarray) and not issubclass(t, Quantity)
1732                for t in types):
1733             raise TypeError("the Quantity implementation cannot handle {} "
1734                             "with the given arguments."
1735                             .format(function)) from None
1736         else:
1737             return NotImplemented
1738 
1739     # Calculation -- override ndarray methods to take into account units.
1740     # We use the corresponding numpy functions to evaluate the results, since
1741     # the methods do not always allow calling with keyword arguments.
1742     # For instance, np.array([0.,2.]).clip(a_min=0., a_max=1.) gives
1743     # TypeError: 'a_max' is an invalid keyword argument for this function.
1744     def _wrap_function(self, function, *args, unit=None, out=None, **kwargs):
1745         """Wrap a numpy function that processes self, returning a Quantity.
1746 
1747         Parameters
1748         ----------
1749         function : callable
1750             Numpy function to wrap.
1751         args : positional arguments
1752             Any positional arguments to the function beyond the first argument
1753             (which will be set to ``self``).
1754         kwargs : keyword arguments
1755             Keyword arguments to the function.
1756 
1757         If present, the following arguments are treated specially:
1758 
1759         unit : `~astropy.units.Unit`
1760             Unit of the output result.  If not given, the unit of ``self``.
1761         out : `~astropy.units.Quantity`
1762             A Quantity instance in which to store the output.
1763 
1764         Notes
1765         -----
1766         Output should always be assigned via a keyword argument, otherwise
1767         no proper account of the unit is taken.
1768 
1769         Returns
1770         -------
1771         out : `~astropy.units.Quantity`
1772             Result of the function call, with the unit set properly.
1773         """
1774         if unit is None:
1775             unit = self.unit
1776         # Ensure we don't loop back by turning any Quantity into array views.
1777         args = (self.value,) + tuple((arg.value if isinstance(arg, Quantity)
1778                                       else arg) for arg in args)
1779         if out is not None:
1780             # If pre-allocated output is used, check it is suitable.
1781             # This also returns array view, to ensure we don't loop back.
1782             arrays = tuple(arg for arg in args if isinstance(arg, np.ndarray))
1783             kwargs['out'] = check_output(out, unit, arrays, function=function)
1784         # Apply the function and turn it back into a Quantity.
1785         result = function(*args, **kwargs)
1786         return self._result_as_quantity(result, unit, out)
1787 
1788     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
1789         return self._wrap_function(np.trace, offset, axis1, axis2, dtype,
1790                                    out=out)
1791 
1792     def var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
1793         return self._wrap_function(np.var, axis, dtype,
1794                                    out=out, ddof=ddof, keepdims=keepdims,
1795                                    unit=self.unit**2)
1796 
1797     def std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
1798         return self._wrap_function(np.std, axis, dtype, out=out, ddof=ddof,
1799                                    keepdims=keepdims)
1800 
1801     def mean(self, axis=None, dtype=None, out=None, keepdims=False):
1802         return self._wrap_function(np.mean, axis, dtype, out=out,
1803                                    keepdims=keepdims)
1804 
1805     def round(self, decimals=0, out=None):
1806         return self._wrap_function(np.round, decimals, out=out)
1807 
1808     def dot(self, b, out=None):
1809         result_unit = self.unit * getattr(b, 'unit', dimensionless_unscaled)
1810         return self._wrap_function(np.dot, b, out=out, unit=result_unit)
1811 
1812     # Calculation: override methods that do not make sense.
1813 
1814     def all(self, axis=None, out=None):
1815         raise TypeError("cannot evaluate truth value of quantities. "
1816                         "Evaluate array with q.value.all(...)")
1817 
1818     def any(self, axis=None, out=None):
1819         raise TypeError("cannot evaluate truth value of quantities. "
1820                         "Evaluate array with q.value.any(...)")
1821 
1822     # Calculation: numpy functions that can be overridden with methods.
1823 
1824     def diff(self, n=1, axis=-1):
1825         return self._wrap_function(np.diff, n, axis)
1826 
1827     def ediff1d(self, to_end=None, to_begin=None):
1828         return self._wrap_function(np.ediff1d, to_end, to_begin)
1829 
1830     def nansum(self, axis=None, out=None, keepdims=False):
1831         return self._wrap_function(np.nansum, axis,
1832                                    out=out, keepdims=keepdims)
1833 
1834     def insert(self, obj, values, axis=None):
1835         """
1836         Insert values along the given axis before the given indices and return
1837         a new `~astropy.units.Quantity` object.
1838 
1839         This is a thin wrapper around the `numpy.insert` function.
1840 
1841         Parameters
1842         ----------
1843         obj : int, slice or sequence of int
1844             Object that defines the index or indices before which ``values`` is
1845             inserted.
1846         values : array-like
1847             Values to insert.  If the type of ``values`` is different
1848             from that of quantity, ``values`` is converted to the matching type.
1849             ``values`` should be shaped so that it can be broadcast appropriately
1850             The unit of ``values`` must be consistent with this quantity.
1851         axis : int, optional
1852             Axis along which to insert ``values``.  If ``axis`` is None then
1853             the quantity array is flattened before insertion.
1854 
1855         Returns
1856         -------
1857         out : `~astropy.units.Quantity`
1858             A copy of quantity with ``values`` inserted.  Note that the
1859             insertion does not occur in-place: a new quantity array is returned.
1860 
1861         Examples
1862         --------
1863         >>> import astropy.units as u
1864         >>> q = [1, 2] * u.m
1865         >>> q.insert(0, 50 * u.cm)
1866         <Quantity [ 0.5,  1.,  2.] m>
1867 
1868         >>> q = [[1, 2], [3, 4]] * u.m
1869         >>> q.insert(1, [10, 20] * u.m, axis=0)
1870         <Quantity [[  1.,  2.],
1871                    [ 10., 20.],
1872                    [  3.,  4.]] m>
1873 
1874         >>> q.insert(1, 10 * u.m, axis=1)
1875         <Quantity [[  1., 10.,  2.],
1876                    [  3., 10.,  4.]] m>
1877 
1878         """
1879         out_array = np.insert(self.value, obj, self._to_own_unit(values), axis)
1880         return self._new_view(out_array)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 15:23:28.963 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:23:28.963 | INFO     | Search-only: skipping patch selection
2025-10-15 15:23:29.129 | INFO     | Task astropy__astropy-12891 completed successfully.
2025-10-15 15:23:29.129 | INFO     | No patch generated. You can try running ACR again.
