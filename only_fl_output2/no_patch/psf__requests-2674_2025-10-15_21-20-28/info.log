2025-10-15 21:20:28.687 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 21:20:32.294 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=196, output_tokens=12, cost=0.002320
2025-10-15 21:20:32.295 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 21:20:32.299 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:20:39.372 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=505, output_tokens=290, cost=0.013750
2025-10-15 21:20:39.377 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:20:41.237 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=644, output_tokens=53, cost=0.008030
2025-10-15 21:20:41.239 | DEBUG    | Extracted a valid json.
2025-10-15 21:20:41.239 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"urllib3.exceptions\")",
        "search_code(\"urllib3.exceptions.DecodeError\")",
        "search_code(\"urllib3.exceptions.TimeoutError\")"
    ],
    "bug_locations": []
}
2025-10-15 21:20:41.260 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 21:20:41.261 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 21:20:59.803 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1100, output_tokens=733, cost=0.032990
2025-10-15 21:20:59.818 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:21:01.495 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2049, output_tokens=44, cost=0.021810
2025-10-15 21:21:01.498 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:21:03.538 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=398, output_tokens=54, cost=0.005600
2025-10-15 21:21:03.539 | DEBUG    | Extracted a valid json.
2025-10-15 21:21:03.539 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"urllib3.exceptions\", \"requests/exceptions.py\")",
        "search_code_in_file(\"urllib3.exceptions\", \"requests/adapters.py\")"
    ],
    "bug_locations": []
}
2025-10-15 21:21:03.551 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 21:21:03.552 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 21:21:19.470 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2368, output_tokens=705, cost=0.044830
2025-10-15 21:21:19.483 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 21:21:26.946 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3289, output_tokens=306, cost=0.042070
2025-10-15 21:21:26.954 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 21:21:34.215 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=660, output_tokens=271, cost=0.014730
2025-10-15 21:21:34.216 | DEBUG    | Extracted a valid json.
2025-10-15 21:21:34.216 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "requests/exceptions.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should include or extend its mechanisms to catch `urllib3.exceptions.DecodeError` and `urllib3.exceptions.TimeoutError`, wrapping them into more specific `requests` exceptions. For instance, introducing new exception classes like `RequestDecodeError` and `RequestTimeoutError` that inherit from a common requests exception class, or directly map these `urllib3` exceptions to existing `requests` exceptions that accurately describe the error scenario to the end-user. This would provide a consistent and user-friendly abstraction over `urllib3`."
        },
        {
            "file": "requests/adapters.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that any operations which might throw `urllib3` exceptions specifically catch `DecodeError` and `TimeoutError`, re-raising them as the corresponding `requests` exceptions defined or mapped in `requests/exceptions.py`. The adapter's method(s) handling HTTP operations and exceptions should meticulously inspect exceptions from `urllib3` and convert them accordingly, encapsulating `urllib3` details from `requests` users."
        }
    ]
}
2025-10-15 21:21:34.222 | DEBUG    | Bug location extracted successfully: [<file>requests/exceptions.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 """
4 requests.exceptions
5 ~~~~~~~~~~~~~~~~~~~
6 
7 This module contains the set of Requests' exceptions.
8 
9 """
10 from .packages.urllib3.exceptions import HTTPError as BaseHTTPError
11 
12 
13 class RequestException(IOError):
14     """There was an ambiguous exception that occurred while handling your
15     request."""
16 
17     def __init__(self, *args, **kwargs):
18         """
19         Initialize RequestException with `request` and `response` objects.
20         """
21         response = kwargs.pop('response', None)
22         self.response = response
23         self.request = kwargs.pop('request', None)
24         if (response is not None and not self.request and
25                 hasattr(response, 'request')):
26             self.request = self.response.request
27         super(RequestException, self).__init__(*args, **kwargs)
28 
29 
30 class HTTPError(RequestException):
31     """An HTTP error occurred."""
32 
33 
34 class ConnectionError(RequestException):
35     """A Connection error occurred."""
36 
37 
38 class ProxyError(ConnectionError):
39     """A proxy error occurred."""
40 
41 
42 class SSLError(ConnectionError):
43     """An SSL error occurred."""
44 
45 
46 class Timeout(RequestException):
47     """The request timed out.
48 
49     Catching this error will catch both
50     :exc:`~requests.exceptions.ConnectTimeout` and
51     :exc:`~requests.exceptions.ReadTimeout` errors.
52     """
53 
54 
55 class ConnectTimeout(ConnectionError, Timeout):
56     """The request timed out while trying to connect to the remote server.
57 
58     Requests that produced this error are safe to retry.
59     """
60 
61 
62 class ReadTimeout(Timeout):
63     """The server did not send any data in the allotted amount of time."""
64 
65 
66 class URLRequired(RequestException):
67     """A valid URL is required to make a request."""
68 
69 
70 class TooManyRedirects(RequestException):
71     """Too many redirects."""
72 
73 
74 class MissingSchema(RequestException, ValueError):
75     """The URL schema (e.g. http or https) is missing."""
76 
77 
78 class InvalidSchema(RequestException, ValueError):
79     """See defaults.py for valid schemas."""
80 
81 
82 class InvalidURL(RequestException, ValueError):
83     """ The URL provided was somehow invalid. """
84 
85 
86 class ChunkedEncodingError(RequestException):
87     """The server declared chunked encoding but sent an invalid chunk."""
88 
89 
90 class ContentDecodingError(RequestException, BaseHTTPError):
91     """Failed to decode response content"""
92 
93 
94 class StreamConsumedError(RequestException, TypeError):
95     """The content for this response was already consumed"""
96 
97 
98 class RetryError(RequestException):
99     """Custom retries logic failed"""

</code><intended_behavior>This file should include or extend its mechanisms to catch `urllib3.exceptions.DecodeError` and `urllib3.exceptions.TimeoutError`, wrapping them into more specific `requests` exceptions. For instance, introducing new exception classes like `RequestDecodeError` and `RequestTimeoutError` that inherit from a common requests exception class, or directly map these `urllib3` exceptions to existing `requests` exceptions that accurately describe the error scenario to the end-user. This would provide a consistent and user-friendly abstraction over `urllib3`.</intended_behavior>, <file>requests/adapters.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 """
4 requests.adapters
5 ~~~~~~~~~~~~~~~~~
6 
7 This module contains the transport adapters that Requests uses to define
8 and maintain connections.
9 """
10 
11 import socket
12 
13 from .models import Response
14 from .packages.urllib3.poolmanager import PoolManager, proxy_from_url
15 from .packages.urllib3.response import HTTPResponse
16 from .packages.urllib3.util import Timeout as TimeoutSauce
17 from .packages.urllib3.util.retry import Retry
18 from .compat import urlparse, basestring
19 from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,
20                     prepend_scheme_if_needed, get_auth_from_url, urldefragauth)
21 from .structures import CaseInsensitiveDict
22 from .packages.urllib3.exceptions import ConnectTimeoutError
23 from .packages.urllib3.exceptions import HTTPError as _HTTPError
24 from .packages.urllib3.exceptions import MaxRetryError
25 from .packages.urllib3.exceptions import ProxyError as _ProxyError
26 from .packages.urllib3.exceptions import ProtocolError
27 from .packages.urllib3.exceptions import ReadTimeoutError
28 from .packages.urllib3.exceptions import SSLError as _SSLError
29 from .packages.urllib3.exceptions import ResponseError
30 from .cookies import extract_cookies_to_jar
31 from .exceptions import (ConnectionError, ConnectTimeout, ReadTimeout, SSLError,
32                          ProxyError, RetryError)
33 from .auth import _basic_auth_str
34 
35 DEFAULT_POOLBLOCK = False
36 DEFAULT_POOLSIZE = 10
37 DEFAULT_RETRIES = 0
38 DEFAULT_POOL_TIMEOUT = None
39 
40 
41 class BaseAdapter(object):
42     """The Base Transport Adapter"""
43 
44     def __init__(self):
45         super(BaseAdapter, self).__init__()
46 
47     def send(self):
48         raise NotImplementedError
49 
50     def close(self):
51         raise NotImplementedError
52 
53 
54 class HTTPAdapter(BaseAdapter):
55     """The built-in HTTP Adapter for urllib3.
56 
57     Provides a general-case interface for Requests sessions to contact HTTP and
58     HTTPS urls by implementing the Transport Adapter interface. This class will
59     usually be created by the :class:`Session <Session>` class under the
60     covers.
61 
62     :param pool_connections: The number of urllib3 connection pools to cache.
63     :param pool_maxsize: The maximum number of connections to save in the pool.
64     :param int max_retries: The maximum number of retries each connection
65         should attempt. Note, this applies only to failed DNS lookups, socket
66         connections and connection timeouts, never to requests where data has
67         made it to the server. By default, Requests does not retry failed
68         connections. If you need granular control over the conditions under
69         which we retry a request, import urllib3's ``Retry`` class and pass
70         that instead.
71     :param pool_block: Whether the connection pool should block for connections.
72 
73     Usage::
74 
75       >>> import requests
76       >>> s = requests.Session()
77       >>> a = requests.adapters.HTTPAdapter(max_retries=3)
78       >>> s.mount('http://', a)
79     """
80     __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize',
81                  '_pool_block']
82 
83     def __init__(self, pool_connections=DEFAULT_POOLSIZE,
84                  pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,
85                  pool_block=DEFAULT_POOLBLOCK):
86         if max_retries == DEFAULT_RETRIES:
87             self.max_retries = Retry(0, read=False)
88         else:
89             self.max_retries = Retry.from_int(max_retries)
90         self.config = {}
91         self.proxy_manager = {}
92 
93         super(HTTPAdapter, self).__init__()
94 
95         self._pool_connections = pool_connections
96         self._pool_maxsize = pool_maxsize
97         self._pool_block = pool_block
98 
99         self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)
100 
101     def __getstate__(self):
102         return dict((attr, getattr(self, attr, None)) for attr in
103                     self.__attrs__)
104 
105     def __setstate__(self, state):
106         # Can't handle by adding 'proxy_manager' to self.__attrs__ because
107         # because self.poolmanager uses a lambda function, which isn't pickleable.
108         self.proxy_manager = {}
109         self.config = {}
110 
111         for attr, value in state.items():
112             setattr(self, attr, value)
113 
114         self.init_poolmanager(self._pool_connections, self._pool_maxsize,
115                               block=self._pool_block)
116 
117     def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):
118         """Initializes a urllib3 PoolManager.
119 
120         This method should not be called from user code, and is only
121         exposed for use when subclassing the
122         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
123 
124         :param connections: The number of urllib3 connection pools to cache.
125         :param maxsize: The maximum number of connections to save in the pool.
126         :param block: Block when no free connections are available.
127         :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
128         """
129         # save these values for pickling
130         self._pool_connections = connections
131         self._pool_maxsize = maxsize
132         self._pool_block = block
133 
134         self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,
135                                        block=block, strict=True, **pool_kwargs)
136 
137     def proxy_manager_for(self, proxy, **proxy_kwargs):
138         """Return urllib3 ProxyManager for the given proxy.
139 
140         This method should not be called from user code, and is only
141         exposed for use when subclassing the
142         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
143 
144         :param proxy: The proxy to return a urllib3 ProxyManager for.
145         :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.
146         :returns: ProxyManager
147         """
148         if not proxy in self.proxy_manager:
149             proxy_headers = self.proxy_headers(proxy)
150             self.proxy_manager[proxy] = proxy_from_url(
151                 proxy,
152                 proxy_headers=proxy_headers,
153                 num_pools=self._pool_connections,
154                 maxsize=self._pool_maxsize,
155                 block=self._pool_block,
156                 **proxy_kwargs)
157 
158         return self.proxy_manager[proxy]
159 
160     def cert_verify(self, conn, url, verify, cert):
161         """Verify a SSL certificate. This method should not be called from user
162         code, and is only exposed for use when subclassing the
163         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
164 
165         :param conn: The urllib3 connection object associated with the cert.
166         :param url: The requested URL.
167         :param verify: Whether we should actually verify the certificate.
168         :param cert: The SSL certificate to verify.
169         """
170         if url.lower().startswith('https') and verify:
171 
172             cert_loc = None
173 
174             # Allow self-specified cert location.
175             if verify is not True:
176                 cert_loc = verify
177 
178             if not cert_loc:
179                 cert_loc = DEFAULT_CA_BUNDLE_PATH
180 
181             if not cert_loc:
182                 raise Exception("Could not find a suitable SSL CA certificate bundle.")
183 
184             conn.cert_reqs = 'CERT_REQUIRED'
185             conn.ca_certs = cert_loc
186         else:
187             conn.cert_reqs = 'CERT_NONE'
188             conn.ca_certs = None
189 
190         if cert:
191             if not isinstance(cert, basestring):
192                 conn.cert_file = cert[0]
193                 conn.key_file = cert[1]
194             else:
195                 conn.cert_file = cert
196 
197     def build_response(self, req, resp):
198         """Builds a :class:`Response <requests.Response>` object from a urllib3
199         response. This should not be called from user code, and is only exposed
200         for use when subclassing the
201         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`
202 
203         :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.
204         :param resp: The urllib3 response object.
205         """
206         response = Response()
207 
208         # Fallback to None if there's no status_code, for whatever reason.
209         response.status_code = getattr(resp, 'status', None)
210 
211         # Make headers case-insensitive.
212         response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
213 
214         # Set encoding.
215         response.encoding = get_encoding_from_headers(response.headers)
216         response.raw = resp
217         response.reason = response.raw.reason
218 
219         if isinstance(req.url, bytes):
220             response.url = req.url.decode('utf-8')
221         else:
222             response.url = req.url
223 
224         # Add new cookies from the server.
225         extract_cookies_to_jar(response.cookies, req, resp)
226 
227         # Give the Response some context.
228         response.request = req
229         response.connection = self
230 
231         return response
232 
233     def get_connection(self, url, proxies=None):
234         """Returns a urllib3 connection for the given URL. This should not be
235         called from user code, and is only exposed for use when subclassing the
236         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
237 
238         :param url: The URL to connect to.
239         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
240         """
241         proxies = proxies or {}
242         proxy = proxies.get(urlparse(url.lower()).scheme)
243 
244         if proxy:
245             proxy = prepend_scheme_if_needed(proxy, 'http')
246             proxy_manager = self.proxy_manager_for(proxy)
247             conn = proxy_manager.connection_from_url(url)
248         else:
249             # Only scheme should be lower case
250             parsed = urlparse(url)
251             url = parsed.geturl()
252             conn = self.poolmanager.connection_from_url(url)
253 
254         return conn
255 
256     def close(self):
257         """Disposes of any internal state.
258 
259         Currently, this just closes the PoolManager, which closes pooled
260         connections.
261         """
262         self.poolmanager.clear()
263 
264     def request_url(self, request, proxies):
265         """Obtain the url to use when making the final request.
266 
267         If the message is being sent through a HTTP proxy, the full URL has to
268         be used. Otherwise, we should only use the path portion of the URL.
269 
270         This should not be called from user code, and is only exposed for use
271         when subclassing the
272         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
273 
274         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
275         :param proxies: A dictionary of schemes to proxy URLs.
276         """
277         proxies = proxies or {}
278         scheme = urlparse(request.url).scheme
279         proxy = proxies.get(scheme)
280 
281         if proxy and scheme != 'https':
282             url = urldefragauth(request.url)
283         else:
284             url = request.path_url
285 
286         return url
287 
288     def add_headers(self, request, **kwargs):
289         """Add any headers needed by the connection. As of v2.0 this does
290         nothing by default, but is left for overriding by users that subclass
291         the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
292 
293         This should not be called from user code, and is only exposed for use
294         when subclassing the
295         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
296 
297         :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
298         :param kwargs: The keyword arguments from the call to send().
299         """
300         pass
301 
302     def proxy_headers(self, proxy):
303         """Returns a dictionary of the headers to add to any request sent
304         through a proxy. This works with urllib3 magic to ensure that they are
305         correctly sent to the proxy, rather than in a tunnelled request if
306         CONNECT is being used.
307 
308         This should not be called from user code, and is only exposed for use
309         when subclassing the
310         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
311 
312         :param proxies: The url of the proxy being used for this request.
313         :param kwargs: Optional additional keyword arguments.
314         """
315         headers = {}
316         username, password = get_auth_from_url(proxy)
317 
318         if username and password:
319             headers['Proxy-Authorization'] = _basic_auth_str(username,
320                                                              password)
321 
322         return headers
323 
324     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
325         """Sends PreparedRequest object. Returns Response object.
326 
327         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
328         :param stream: (optional) Whether to stream the request content.
329         :param timeout: (optional) How long to wait for the server to send
330             data before giving up, as a float, or a (`connect timeout, read
331             timeout <user/advanced.html#timeouts>`_) tuple.
332         :type timeout: float or tuple
333         :param verify: (optional) Whether to verify SSL certificates.
334         :param cert: (optional) Any user-provided SSL certificate to be trusted.
335         :param proxies: (optional) The proxies dictionary to apply to the request.
336         """
337 
338         conn = self.get_connection(request.url, proxies)
339 
340         self.cert_verify(conn, request.url, verify, cert)
341         url = self.request_url(request, proxies)
342         self.add_headers(request)
343 
344         chunked = not (request.body is None or 'Content-Length' in request.headers)
345 
346         if isinstance(timeout, tuple):
347             try:
348                 connect, read = timeout
349                 timeout = TimeoutSauce(connect=connect, read=read)
350             except ValueError as e:
351                 # this may raise a string formatting error.
352                 err = ("Invalid timeout {0}. Pass a (connect, read) "
353                        "timeout tuple, or a single float to set "
354                        "both timeouts to the same value".format(timeout))
355                 raise ValueError(err)
356         else:
357             timeout = TimeoutSauce(connect=timeout, read=timeout)
358 
359         try:
360             if not chunked:
361                 resp = conn.urlopen(
362                     method=request.method,
363                     url=url,
364                     body=request.body,
365                     headers=request.headers,
366                     redirect=False,
367                     assert_same_host=False,
368                     preload_content=False,
369                     decode_content=False,
370                     retries=self.max_retries,
371                     timeout=timeout
372                 )
373 
374             # Send the request.
375             else:
376                 if hasattr(conn, 'proxy_pool'):
377                     conn = conn.proxy_pool
378 
379                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
380 
381                 try:
382                     low_conn.putrequest(request.method,
383                                         url,
384                                         skip_accept_encoding=True)
385 
386                     for header, value in request.headers.items():
387                         low_conn.putheader(header, value)
388 
389                     low_conn.endheaders()
390 
391                     for i in request.body:
392                         low_conn.send(hex(len(i))[2:].encode('utf-8'))
393                         low_conn.send(b'\r\n')
394                         low_conn.send(i)
395                         low_conn.send(b'\r\n')
396                     low_conn.send(b'0\r\n\r\n')
397 
398                     r = low_conn.getresponse()
399                     resp = HTTPResponse.from_httplib(
400                         r,
401                         pool=conn,
402                         connection=low_conn,
403                         preload_content=False,
404                         decode_content=False
405                     )
406                 except:
407                     # If we hit any problems here, clean up the connection.
408                     # Then, reraise so that we can handle the actual exception.
409                     low_conn.close()
410                     raise
411 
412         except (ProtocolError, socket.error) as err:
413             raise ConnectionError(err, request=request)
414 
415         except MaxRetryError as e:
416             if isinstance(e.reason, ConnectTimeoutError):
417                 raise ConnectTimeout(e, request=request)
418 
419             if isinstance(e.reason, ResponseError):
420                 raise RetryError(e, request=request)
421 
422             raise ConnectionError(e, request=request)
423 
424         except _ProxyError as e:
425             raise ProxyError(e)
426 
427         except (_SSLError, _HTTPError) as e:
428             if isinstance(e, _SSLError):
429                 raise SSLError(e, request=request)
430             elif isinstance(e, ReadTimeoutError):
431                 raise ReadTimeout(e, request=request)
432             else:
433                 raise
434 
435         return self.build_response(request, resp)

</code><intended_behavior>Ensure that any operations which might throw `urllib3` exceptions specifically catch `DecodeError` and `TimeoutError`, re-raising them as the corresponding `requests` exceptions defined or mapped in `requests/exceptions.py`. The adapter's method(s) handling HTTP operations and exceptions should meticulously inspect exceptions from `urllib3` and convert them accordingly, encapsulating `urllib3` details from `requests` users.</intended_behavior>]
2025-10-15 21:21:34.222 | INFO     | Search completed. Bug locations: [<file>requests/exceptions.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 """
4 requests.exceptions
5 ~~~~~~~~~~~~~~~~~~~
6 
7 This module contains the set of Requests' exceptions.
8 
9 """
10 from .packages.urllib3.exceptions import HTTPError as BaseHTTPError
11 
12 
13 class RequestException(IOError):
14     """There was an ambiguous exception that occurred while handling your
15     request."""
16 
17     def __init__(self, *args, **kwargs):
18         """
19         Initialize RequestException with `request` and `response` objects.
20         """
21         response = kwargs.pop('response', None)
22         self.response = response
23         self.request = kwargs.pop('request', None)
24         if (response is not None and not self.request and
25                 hasattr(response, 'request')):
26             self.request = self.response.request
27         super(RequestException, self).__init__(*args, **kwargs)
28 
29 
30 class HTTPError(RequestException):
31     """An HTTP error occurred."""
32 
33 
34 class ConnectionError(RequestException):
35     """A Connection error occurred."""
36 
37 
38 class ProxyError(ConnectionError):
39     """A proxy error occurred."""
40 
41 
42 class SSLError(ConnectionError):
43     """An SSL error occurred."""
44 
45 
46 class Timeout(RequestException):
47     """The request timed out.
48 
49     Catching this error will catch both
50     :exc:`~requests.exceptions.ConnectTimeout` and
51     :exc:`~requests.exceptions.ReadTimeout` errors.
52     """
53 
54 
55 class ConnectTimeout(ConnectionError, Timeout):
56     """The request timed out while trying to connect to the remote server.
57 
58     Requests that produced this error are safe to retry.
59     """
60 
61 
62 class ReadTimeout(Timeout):
63     """The server did not send any data in the allotted amount of time."""
64 
65 
66 class URLRequired(RequestException):
67     """A valid URL is required to make a request."""
68 
69 
70 class TooManyRedirects(RequestException):
71     """Too many redirects."""
72 
73 
74 class MissingSchema(RequestException, ValueError):
75     """The URL schema (e.g. http or https) is missing."""
76 
77 
78 class InvalidSchema(RequestException, ValueError):
79     """See defaults.py for valid schemas."""
80 
81 
82 class InvalidURL(RequestException, ValueError):
83     """ The URL provided was somehow invalid. """
84 
85 
86 class ChunkedEncodingError(RequestException):
87     """The server declared chunked encoding but sent an invalid chunk."""
88 
89 
90 class ContentDecodingError(RequestException, BaseHTTPError):
91     """Failed to decode response content"""
92 
93 
94 class StreamConsumedError(RequestException, TypeError):
95     """The content for this response was already consumed"""
96 
97 
98 class RetryError(RequestException):
99     """Custom retries logic failed"""

</code><intended_behavior>This file should include or extend its mechanisms to catch `urllib3.exceptions.DecodeError` and `urllib3.exceptions.TimeoutError`, wrapping them into more specific `requests` exceptions. For instance, introducing new exception classes like `RequestDecodeError` and `RequestTimeoutError` that inherit from a common requests exception class, or directly map these `urllib3` exceptions to existing `requests` exceptions that accurately describe the error scenario to the end-user. This would provide a consistent and user-friendly abstraction over `urllib3`.</intended_behavior>, <file>requests/adapters.py</file>
<class>None</class>
<method>None</method>
<code>
1 # -*- coding: utf-8 -*-
2 
3 """
4 requests.adapters
5 ~~~~~~~~~~~~~~~~~
6 
7 This module contains the transport adapters that Requests uses to define
8 and maintain connections.
9 """
10 
11 import socket
12 
13 from .models import Response
14 from .packages.urllib3.poolmanager import PoolManager, proxy_from_url
15 from .packages.urllib3.response import HTTPResponse
16 from .packages.urllib3.util import Timeout as TimeoutSauce
17 from .packages.urllib3.util.retry import Retry
18 from .compat import urlparse, basestring
19 from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,
20                     prepend_scheme_if_needed, get_auth_from_url, urldefragauth)
21 from .structures import CaseInsensitiveDict
22 from .packages.urllib3.exceptions import ConnectTimeoutError
23 from .packages.urllib3.exceptions import HTTPError as _HTTPError
24 from .packages.urllib3.exceptions import MaxRetryError
25 from .packages.urllib3.exceptions import ProxyError as _ProxyError
26 from .packages.urllib3.exceptions import ProtocolError
27 from .packages.urllib3.exceptions import ReadTimeoutError
28 from .packages.urllib3.exceptions import SSLError as _SSLError
29 from .packages.urllib3.exceptions import ResponseError
30 from .cookies import extract_cookies_to_jar
31 from .exceptions import (ConnectionError, ConnectTimeout, ReadTimeout, SSLError,
32                          ProxyError, RetryError)
33 from .auth import _basic_auth_str
34 
35 DEFAULT_POOLBLOCK = False
36 DEFAULT_POOLSIZE = 10
37 DEFAULT_RETRIES = 0
38 DEFAULT_POOL_TIMEOUT = None
39 
40 
41 class BaseAdapter(object):
42     """The Base Transport Adapter"""
43 
44     def __init__(self):
45         super(BaseAdapter, self).__init__()
46 
47     def send(self):
48         raise NotImplementedError
49 
50     def close(self):
51         raise NotImplementedError
52 
53 
54 class HTTPAdapter(BaseAdapter):
55     """The built-in HTTP Adapter for urllib3.
56 
57     Provides a general-case interface for Requests sessions to contact HTTP and
58     HTTPS urls by implementing the Transport Adapter interface. This class will
59     usually be created by the :class:`Session <Session>` class under the
60     covers.
61 
62     :param pool_connections: The number of urllib3 connection pools to cache.
63     :param pool_maxsize: The maximum number of connections to save in the pool.
64     :param int max_retries: The maximum number of retries each connection
65         should attempt. Note, this applies only to failed DNS lookups, socket
66         connections and connection timeouts, never to requests where data has
67         made it to the server. By default, Requests does not retry failed
68         connections. If you need granular control over the conditions under
69         which we retry a request, import urllib3's ``Retry`` class and pass
70         that instead.
71     :param pool_block: Whether the connection pool should block for connections.
72 
73     Usage::
74 
75       >>> import requests
76       >>> s = requests.Session()
77       >>> a = requests.adapters.HTTPAdapter(max_retries=3)
78       >>> s.mount('http://', a)
79     """
80     __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize',
81                  '_pool_block']
82 
83     def __init__(self, pool_connections=DEFAULT_POOLSIZE,
84                  pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,
85                  pool_block=DEFAULT_POOLBLOCK):
86         if max_retries == DEFAULT_RETRIES:
87             self.max_retries = Retry(0, read=False)
88         else:
89             self.max_retries = Retry.from_int(max_retries)
90         self.config = {}
91         self.proxy_manager = {}
92 
93         super(HTTPAdapter, self).__init__()
94 
95         self._pool_connections = pool_connections
96         self._pool_maxsize = pool_maxsize
97         self._pool_block = pool_block
98 
99         self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)
100 
101     def __getstate__(self):
102         return dict((attr, getattr(self, attr, None)) for attr in
103                     self.__attrs__)
104 
105     def __setstate__(self, state):
106         # Can't handle by adding 'proxy_manager' to self.__attrs__ because
107         # because self.poolmanager uses a lambda function, which isn't pickleable.
108         self.proxy_manager = {}
109         self.config = {}
110 
111         for attr, value in state.items():
112             setattr(self, attr, value)
113 
114         self.init_poolmanager(self._pool_connections, self._pool_maxsize,
115                               block=self._pool_block)
116 
117     def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs):
118         """Initializes a urllib3 PoolManager.
119 
120         This method should not be called from user code, and is only
121         exposed for use when subclassing the
122         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
123 
124         :param connections: The number of urllib3 connection pools to cache.
125         :param maxsize: The maximum number of connections to save in the pool.
126         :param block: Block when no free connections are available.
127         :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
128         """
129         # save these values for pickling
130         self._pool_connections = connections
131         self._pool_maxsize = maxsize
132         self._pool_block = block
133 
134         self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,
135                                        block=block, strict=True, **pool_kwargs)
136 
137     def proxy_manager_for(self, proxy, **proxy_kwargs):
138         """Return urllib3 ProxyManager for the given proxy.
139 
140         This method should not be called from user code, and is only
141         exposed for use when subclassing the
142         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
143 
144         :param proxy: The proxy to return a urllib3 ProxyManager for.
145         :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.
146         :returns: ProxyManager
147         """
148         if not proxy in self.proxy_manager:
149             proxy_headers = self.proxy_headers(proxy)
150             self.proxy_manager[proxy] = proxy_from_url(
151                 proxy,
152                 proxy_headers=proxy_headers,
153                 num_pools=self._pool_connections,
154                 maxsize=self._pool_maxsize,
155                 block=self._pool_block,
156                 **proxy_kwargs)
157 
158         return self.proxy_manager[proxy]
159 
160     def cert_verify(self, conn, url, verify, cert):
161         """Verify a SSL certificate. This method should not be called from user
162         code, and is only exposed for use when subclassing the
163         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
164 
165         :param conn: The urllib3 connection object associated with the cert.
166         :param url: The requested URL.
167         :param verify: Whether we should actually verify the certificate.
168         :param cert: The SSL certificate to verify.
169         """
170         if url.lower().startswith('https') and verify:
171 
172             cert_loc = None
173 
174             # Allow self-specified cert location.
175             if verify is not True:
176                 cert_loc = verify
177 
178             if not cert_loc:
179                 cert_loc = DEFAULT_CA_BUNDLE_PATH
180 
181             if not cert_loc:
182                 raise Exception("Could not find a suitable SSL CA certificate bundle.")
183 
184             conn.cert_reqs = 'CERT_REQUIRED'
185             conn.ca_certs = cert_loc
186         else:
187             conn.cert_reqs = 'CERT_NONE'
188             conn.ca_certs = None
189 
190         if cert:
191             if not isinstance(cert, basestring):
192                 conn.cert_file = cert[0]
193                 conn.key_file = cert[1]
194             else:
195                 conn.cert_file = cert
196 
197     def build_response(self, req, resp):
198         """Builds a :class:`Response <requests.Response>` object from a urllib3
199         response. This should not be called from user code, and is only exposed
200         for use when subclassing the
201         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`
202 
203         :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.
204         :param resp: The urllib3 response object.
205         """
206         response = Response()
207 
208         # Fallback to None if there's no status_code, for whatever reason.
209         response.status_code = getattr(resp, 'status', None)
210 
211         # Make headers case-insensitive.
212         response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
213 
214         # Set encoding.
215         response.encoding = get_encoding_from_headers(response.headers)
216         response.raw = resp
217         response.reason = response.raw.reason
218 
219         if isinstance(req.url, bytes):
220             response.url = req.url.decode('utf-8')
221         else:
222             response.url = req.url
223 
224         # Add new cookies from the server.
225         extract_cookies_to_jar(response.cookies, req, resp)
226 
227         # Give the Response some context.
228         response.request = req
229         response.connection = self
230 
231         return response
232 
233     def get_connection(self, url, proxies=None):
234         """Returns a urllib3 connection for the given URL. This should not be
235         called from user code, and is only exposed for use when subclassing the
236         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
237 
238         :param url: The URL to connect to.
239         :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
240         """
241         proxies = proxies or {}
242         proxy = proxies.get(urlparse(url.lower()).scheme)
243 
244         if proxy:
245             proxy = prepend_scheme_if_needed(proxy, 'http')
246             proxy_manager = self.proxy_manager_for(proxy)
247             conn = proxy_manager.connection_from_url(url)
248         else:
249             # Only scheme should be lower case
250             parsed = urlparse(url)
251             url = parsed.geturl()
252             conn = self.poolmanager.connection_from_url(url)
253 
254         return conn
255 
256     def close(self):
257         """Disposes of any internal state.
258 
259         Currently, this just closes the PoolManager, which closes pooled
260         connections.
261         """
262         self.poolmanager.clear()
263 
264     def request_url(self, request, proxies):
265         """Obtain the url to use when making the final request.
266 
267         If the message is being sent through a HTTP proxy, the full URL has to
268         be used. Otherwise, we should only use the path portion of the URL.
269 
270         This should not be called from user code, and is only exposed for use
271         when subclassing the
272         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
273 
274         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
275         :param proxies: A dictionary of schemes to proxy URLs.
276         """
277         proxies = proxies or {}
278         scheme = urlparse(request.url).scheme
279         proxy = proxies.get(scheme)
280 
281         if proxy and scheme != 'https':
282             url = urldefragauth(request.url)
283         else:
284             url = request.path_url
285 
286         return url
287 
288     def add_headers(self, request, **kwargs):
289         """Add any headers needed by the connection. As of v2.0 this does
290         nothing by default, but is left for overriding by users that subclass
291         the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
292 
293         This should not be called from user code, and is only exposed for use
294         when subclassing the
295         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
296 
297         :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
298         :param kwargs: The keyword arguments from the call to send().
299         """
300         pass
301 
302     def proxy_headers(self, proxy):
303         """Returns a dictionary of the headers to add to any request sent
304         through a proxy. This works with urllib3 magic to ensure that they are
305         correctly sent to the proxy, rather than in a tunnelled request if
306         CONNECT is being used.
307 
308         This should not be called from user code, and is only exposed for use
309         when subclassing the
310         :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.
311 
312         :param proxies: The url of the proxy being used for this request.
313         :param kwargs: Optional additional keyword arguments.
314         """
315         headers = {}
316         username, password = get_auth_from_url(proxy)
317 
318         if username and password:
319             headers['Proxy-Authorization'] = _basic_auth_str(username,
320                                                              password)
321 
322         return headers
323 
324     def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
325         """Sends PreparedRequest object. Returns Response object.
326 
327         :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
328         :param stream: (optional) Whether to stream the request content.
329         :param timeout: (optional) How long to wait for the server to send
330             data before giving up, as a float, or a (`connect timeout, read
331             timeout <user/advanced.html#timeouts>`_) tuple.
332         :type timeout: float or tuple
333         :param verify: (optional) Whether to verify SSL certificates.
334         :param cert: (optional) Any user-provided SSL certificate to be trusted.
335         :param proxies: (optional) The proxies dictionary to apply to the request.
336         """
337 
338         conn = self.get_connection(request.url, proxies)
339 
340         self.cert_verify(conn, request.url, verify, cert)
341         url = self.request_url(request, proxies)
342         self.add_headers(request)
343 
344         chunked = not (request.body is None or 'Content-Length' in request.headers)
345 
346         if isinstance(timeout, tuple):
347             try:
348                 connect, read = timeout
349                 timeout = TimeoutSauce(connect=connect, read=read)
350             except ValueError as e:
351                 # this may raise a string formatting error.
352                 err = ("Invalid timeout {0}. Pass a (connect, read) "
353                        "timeout tuple, or a single float to set "
354                        "both timeouts to the same value".format(timeout))
355                 raise ValueError(err)
356         else:
357             timeout = TimeoutSauce(connect=timeout, read=timeout)
358 
359         try:
360             if not chunked:
361                 resp = conn.urlopen(
362                     method=request.method,
363                     url=url,
364                     body=request.body,
365                     headers=request.headers,
366                     redirect=False,
367                     assert_same_host=False,
368                     preload_content=False,
369                     decode_content=False,
370                     retries=self.max_retries,
371                     timeout=timeout
372                 )
373 
374             # Send the request.
375             else:
376                 if hasattr(conn, 'proxy_pool'):
377                     conn = conn.proxy_pool
378 
379                 low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
380 
381                 try:
382                     low_conn.putrequest(request.method,
383                                         url,
384                                         skip_accept_encoding=True)
385 
386                     for header, value in request.headers.items():
387                         low_conn.putheader(header, value)
388 
389                     low_conn.endheaders()
390 
391                     for i in request.body:
392                         low_conn.send(hex(len(i))[2:].encode('utf-8'))
393                         low_conn.send(b'\r\n')
394                         low_conn.send(i)
395                         low_conn.send(b'\r\n')
396                     low_conn.send(b'0\r\n\r\n')
397 
398                     r = low_conn.getresponse()
399                     resp = HTTPResponse.from_httplib(
400                         r,
401                         pool=conn,
402                         connection=low_conn,
403                         preload_content=False,
404                         decode_content=False
405                     )
406                 except:
407                     # If we hit any problems here, clean up the connection.
408                     # Then, reraise so that we can handle the actual exception.
409                     low_conn.close()
410                     raise
411 
412         except (ProtocolError, socket.error) as err:
413             raise ConnectionError(err, request=request)
414 
415         except MaxRetryError as e:
416             if isinstance(e.reason, ConnectTimeoutError):
417                 raise ConnectTimeout(e, request=request)
418 
419             if isinstance(e.reason, ResponseError):
420                 raise RetryError(e, request=request)
421 
422             raise ConnectionError(e, request=request)
423 
424         except _ProxyError as e:
425             raise ProxyError(e)
426 
427         except (_SSLError, _HTTPError) as e:
428             if isinstance(e, _SSLError):
429                 raise SSLError(e, request=request)
430             elif isinstance(e, ReadTimeoutError):
431                 raise ReadTimeout(e, request=request)
432             else:
433                 raise
434 
435         return self.build_response(request, resp)

</code><intended_behavior>Ensure that any operations which might throw `urllib3` exceptions specifically catch `DecodeError` and `TimeoutError`, re-raising them as the corresponding `requests` exceptions defined or mapped in `requests/exceptions.py`. The adapter's method(s) handling HTTP operations and exceptions should meticulously inspect exceptions from `urllib3` and convert them accordingly, encapsulating `urllib3` details from `requests` users.</intended_behavior>]
2025-10-15 21:21:34.223 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 21:21:34.223 | INFO     | Search-only: skipping patch selection
2025-10-15 21:21:34.288 | INFO     | Task psf__requests-2674 completed successfully.
2025-10-15 21:21:34.289 | INFO     | No patch generated. You can try running ACR again.
