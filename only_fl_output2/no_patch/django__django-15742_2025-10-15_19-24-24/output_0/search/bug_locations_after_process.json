[
    {
        "rel_file_path": "django/template/defaulttags.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/template/defaulttags.py",
        "start": 1,
        "end": 1494,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Default tags used by the template system, available to all templates.\"\"\"\n2 import re\n3 import sys\n4 import warnings\n5 from collections import namedtuple\n6 from datetime import datetime\n7 from itertools import cycle as itertools_cycle\n8 from itertools import groupby\n9 \n10 from django.conf import settings\n11 from django.utils import timezone\n12 from django.utils.html import conditional_escape, escape, format_html\n13 from django.utils.lorem_ipsum import paragraphs, words\n14 from django.utils.safestring import mark_safe\n15 \n16 from .base import (\n17     BLOCK_TAG_END,\n18     BLOCK_TAG_START,\n19     COMMENT_TAG_END,\n20     COMMENT_TAG_START,\n21     FILTER_SEPARATOR,\n22     SINGLE_BRACE_END,\n23     SINGLE_BRACE_START,\n24     VARIABLE_ATTRIBUTE_SEPARATOR,\n25     VARIABLE_TAG_END,\n26     VARIABLE_TAG_START,\n27     Node,\n28     NodeList,\n29     TemplateSyntaxError,\n30     VariableDoesNotExist,\n31     kwarg_re,\n32     render_value_in_context,\n33     token_kwargs,\n34 )\n35 from .context import Context\n36 from .defaultfilters import date\n37 from .library import Library\n38 from .smartif import IfParser, Literal\n39 \n40 register = Library()\n41 \n42 \n43 class AutoEscapeControlNode(Node):\n44     \"\"\"Implement the actions of the autoescape tag.\"\"\"\n45 \n46     def __init__(self, setting, nodelist):\n47         self.setting, self.nodelist = setting, nodelist\n48 \n49     def render(self, context):\n50         old_setting = context.autoescape\n51         context.autoescape = self.setting\n52         output = self.nodelist.render(context)\n53         context.autoescape = old_setting\n54         if self.setting:\n55             return mark_safe(output)\n56         else:\n57             return output\n58 \n59 \n60 class CommentNode(Node):\n61     child_nodelists = ()\n62 \n63     def render(self, context):\n64         return \"\"\n65 \n66 \n67 class CsrfTokenNode(Node):\n68     child_nodelists = ()\n69 \n70     def render(self, context):\n71         csrf_token = context.get(\"csrf_token\")\n72         if csrf_token:\n73             if csrf_token == \"NOTPROVIDED\":\n74                 return format_html(\"\")\n75             else:\n76                 return format_html(\n77                     '<input type=\"hidden\" name=\"csrfmiddlewaretoken\" value=\"{}\">',\n78                     csrf_token,\n79                 )\n80         else:\n81             # It's very probable that the token is missing because of\n82             # misconfiguration, so we raise a warning\n83             if settings.DEBUG:\n84                 warnings.warn(\n85                     \"A {% csrf_token %} was used in a template, but the context \"\n86                     \"did not provide the value.  This is usually caused by not \"\n87                     \"using RequestContext.\"\n88                 )\n89             return \"\"\n90 \n91 \n92 class CycleNode(Node):\n93     def __init__(self, cyclevars, variable_name=None, silent=False):\n94         self.cyclevars = cyclevars\n95         self.variable_name = variable_name\n96         self.silent = silent\n97 \n98     def render(self, context):\n99         if self not in context.render_context:\n100             # First time the node is rendered in template\n101             context.render_context[self] = itertools_cycle(self.cyclevars)\n102         cycle_iter = context.render_context[self]\n103         value = next(cycle_iter).resolve(context)\n104         if self.variable_name:\n105             context.set_upward(self.variable_name, value)\n106         if self.silent:\n107             return \"\"\n108         return render_value_in_context(value, context)\n109 \n110     def reset(self, context):\n111         \"\"\"\n112         Reset the cycle iteration back to the beginning.\n113         \"\"\"\n114         context.render_context[self] = itertools_cycle(self.cyclevars)\n115 \n116 \n117 class DebugNode(Node):\n118     def render(self, context):\n119         if not settings.DEBUG:\n120             return \"\"\n121 \n122         from pprint import pformat\n123 \n124         output = [escape(pformat(val)) for val in context]\n125         output.append(\"\\n\\n\")\n126         output.append(escape(pformat(sys.modules)))\n127         return \"\".join(output)\n128 \n129 \n130 class FilterNode(Node):\n131     def __init__(self, filter_expr, nodelist):\n132         self.filter_expr, self.nodelist = filter_expr, nodelist\n133 \n134     def render(self, context):\n135         output = self.nodelist.render(context)\n136         # Apply filters.\n137         with context.push(var=output):\n138             return self.filter_expr.resolve(context)\n139 \n140 \n141 class FirstOfNode(Node):\n142     def __init__(self, variables, asvar=None):\n143         self.vars = variables\n144         self.asvar = asvar\n145 \n146     def render(self, context):\n147         first = \"\"\n148         for var in self.vars:\n149             value = var.resolve(context, ignore_failures=True)\n150             if value:\n151                 first = render_value_in_context(value, context)\n152                 break\n153         if self.asvar:\n154             context[self.asvar] = first\n155             return \"\"\n156         return first\n157 \n158 \n159 class ForNode(Node):\n160     child_nodelists = (\"nodelist_loop\", \"nodelist_empty\")\n161 \n162     def __init__(\n163         self, loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty=None\n164     ):\n165         self.loopvars, self.sequence = loopvars, sequence\n166         self.is_reversed = is_reversed\n167         self.nodelist_loop = nodelist_loop\n168         if nodelist_empty is None:\n169             self.nodelist_empty = NodeList()\n170         else:\n171             self.nodelist_empty = nodelist_empty\n172 \n173     def __repr__(self):\n174         reversed_text = \" reversed\" if self.is_reversed else \"\"\n175         return \"<%s: for %s in %s, tail_len: %d%s>\" % (\n176             self.__class__.__name__,\n177             \", \".join(self.loopvars),\n178             self.sequence,\n179             len(self.nodelist_loop),\n180             reversed_text,\n181         )\n182 \n183     def render(self, context):\n184         if \"forloop\" in context:\n185             parentloop = context[\"forloop\"]\n186         else:\n187             parentloop = {}\n188         with context.push():\n189             values = self.sequence.resolve(context, ignore_failures=True)\n190             if values is None:\n191                 values = []\n192             if not hasattr(values, \"__len__\"):\n193                 values = list(values)\n194             len_values = len(values)\n195             if len_values < 1:\n196                 return self.nodelist_empty.render(context)\n197             nodelist = []\n198             if self.is_reversed:\n199                 values = reversed(values)\n200             num_loopvars = len(self.loopvars)\n201             unpack = num_loopvars > 1\n202             # Create a forloop value in the context.  We'll update counters on each\n203             # iteration just below.\n204             loop_dict = context[\"forloop\"] = {\"parentloop\": parentloop}\n205             for i, item in enumerate(values):\n206                 # Shortcuts for current loop iteration number.\n207                 loop_dict[\"counter0\"] = i\n208                 loop_dict[\"counter\"] = i + 1\n209                 # Reverse counter iteration numbers.\n210                 loop_dict[\"revcounter\"] = len_values - i\n211                 loop_dict[\"revcounter0\"] = len_values - i - 1\n212                 # Boolean values designating first and last times through loop.\n213                 loop_dict[\"first\"] = i == 0\n214                 loop_dict[\"last\"] = i == len_values - 1\n215 \n216                 pop_context = False\n217                 if unpack:\n218                     # If there are multiple loop variables, unpack the item into\n219                     # them.\n220                     try:\n221                         len_item = len(item)\n222                     except TypeError:  # not an iterable\n223                         len_item = 1\n224                     # Check loop variable count before unpacking\n225                     if num_loopvars != len_item:\n226                         raise ValueError(\n227                             \"Need {} values to unpack in for loop; got {}. \".format(\n228                                 num_loopvars, len_item\n229                             ),\n230                         )\n231                     unpacked_vars = dict(zip(self.loopvars, item))\n232                     pop_context = True\n233                     context.update(unpacked_vars)\n234                 else:\n235                     context[self.loopvars[0]] = item\n236 \n237                 for node in self.nodelist_loop:\n238                     nodelist.append(node.render_annotated(context))\n239 \n240                 if pop_context:\n241                     # Pop the loop variables pushed on to the context to avoid\n242                     # the context ending up in an inconsistent state when other\n243                     # tags (e.g., include and with) push data to context.\n244                     context.pop()\n245         return mark_safe(\"\".join(nodelist))\n246 \n247 \n248 class IfChangedNode(Node):\n249     child_nodelists = (\"nodelist_true\", \"nodelist_false\")\n250 \n251     def __init__(self, nodelist_true, nodelist_false, *varlist):\n252         self.nodelist_true, self.nodelist_false = nodelist_true, nodelist_false\n253         self._varlist = varlist\n254 \n255     def render(self, context):\n256         # Init state storage\n257         state_frame = self._get_context_stack_frame(context)\n258         state_frame.setdefault(self)\n259 \n260         nodelist_true_output = None\n261         if self._varlist:\n262             # Consider multiple parameters. This behaves like an OR evaluation\n263             # of the multiple variables.\n264             compare_to = [\n265                 var.resolve(context, ignore_failures=True) for var in self._varlist\n266             ]\n267         else:\n268             # The \"{% ifchanged %}\" syntax (without any variables) compares\n269             # the rendered output.\n270             compare_to = nodelist_true_output = self.nodelist_true.render(context)\n271 \n272         if compare_to != state_frame[self]:\n273             state_frame[self] = compare_to\n274             # render true block if not already rendered\n275             return nodelist_true_output or self.nodelist_true.render(context)\n276         elif self.nodelist_false:\n277             return self.nodelist_false.render(context)\n278         return \"\"\n279 \n280     def _get_context_stack_frame(self, context):\n281         # The Context object behaves like a stack where each template tag can\n282         # create a new scope. Find the place where to store the state to detect\n283         # changes.\n284         if \"forloop\" in context:\n285             # Ifchanged is bound to the local for loop.\n286             # When there is a loop-in-loop, the state is bound to the inner loop,\n287             # so it resets when the outer loop continues.\n288             return context[\"forloop\"]\n289         else:\n290             # Using ifchanged outside loops. Effectively this is a no-op\n291             # because the state is associated with 'self'.\n292             return context.render_context\n293 \n294 \n295 class IfNode(Node):\n296     def __init__(self, conditions_nodelists):\n297         self.conditions_nodelists = conditions_nodelists\n298 \n299     def __repr__(self):\n300         return \"<%s>\" % self.__class__.__name__\n301 \n302     def __iter__(self):\n303         for _, nodelist in self.conditions_nodelists:\n304             yield from nodelist\n305 \n306     @property\n307     def nodelist(self):\n308         return NodeList(self)\n309 \n310     def render(self, context):\n311         for condition, nodelist in self.conditions_nodelists:\n312 \n313             if condition is not None:  # if / elif clause\n314                 try:\n315                     match = condition.eval(context)\n316                 except VariableDoesNotExist:\n317                     match = None\n318             else:  # else clause\n319                 match = True\n320 \n321             if match:\n322                 return nodelist.render(context)\n323 \n324         return \"\"\n325 \n326 \n327 class LoremNode(Node):\n328     def __init__(self, count, method, common):\n329         self.count, self.method, self.common = count, method, common\n330 \n331     def render(self, context):\n332         try:\n333             count = int(self.count.resolve(context))\n334         except (ValueError, TypeError):\n335             count = 1\n336         if self.method == \"w\":\n337             return words(count, common=self.common)\n338         else:\n339             paras = paragraphs(count, common=self.common)\n340         if self.method == \"p\":\n341             paras = [\"<p>%s</p>\" % p for p in paras]\n342         return \"\\n\\n\".join(paras)\n343 \n344 \n345 GroupedResult = namedtuple(\"GroupedResult\", [\"grouper\", \"list\"])\n346 \n347 \n348 class RegroupNode(Node):\n349     def __init__(self, target, expression, var_name):\n350         self.target, self.expression = target, expression\n351         self.var_name = var_name\n352 \n353     def resolve_expression(self, obj, context):\n354         # This method is called for each object in self.target. See regroup()\n355         # for the reason why we temporarily put the object in the context.\n356         context[self.var_name] = obj\n357         return self.expression.resolve(context, ignore_failures=True)\n358 \n359     def render(self, context):\n360         obj_list = self.target.resolve(context, ignore_failures=True)\n361         if obj_list is None:\n362             # target variable wasn't found in context; fail silently.\n363             context[self.var_name] = []\n364             return \"\"\n365         # List of dictionaries in the format:\n366         # {'grouper': 'key', 'list': [list of contents]}.\n367         context[self.var_name] = [\n368             GroupedResult(grouper=key, list=list(val))\n369             for key, val in groupby(\n370                 obj_list, lambda obj: self.resolve_expression(obj, context)\n371             )\n372         ]\n373         return \"\"\n374 \n375 \n376 class LoadNode(Node):\n377     child_nodelists = ()\n378 \n379     def render(self, context):\n380         return \"\"\n381 \n382 \n383 class NowNode(Node):\n384     def __init__(self, format_string, asvar=None):\n385         self.format_string = format_string\n386         self.asvar = asvar\n387 \n388     def render(self, context):\n389         tzinfo = timezone.get_current_timezone() if settings.USE_TZ else None\n390         formatted = date(datetime.now(tz=tzinfo), self.format_string)\n391 \n392         if self.asvar:\n393             context[self.asvar] = formatted\n394             return \"\"\n395         else:\n396             return formatted\n397 \n398 \n399 class ResetCycleNode(Node):\n400     def __init__(self, node):\n401         self.node = node\n402 \n403     def render(self, context):\n404         self.node.reset(context)\n405         return \"\"\n406 \n407 \n408 class SpacelessNode(Node):\n409     def __init__(self, nodelist):\n410         self.nodelist = nodelist\n411 \n412     def render(self, context):\n413         from django.utils.html import strip_spaces_between_tags\n414 \n415         return strip_spaces_between_tags(self.nodelist.render(context).strip())\n416 \n417 \n418 class TemplateTagNode(Node):\n419     mapping = {\n420         \"openblock\": BLOCK_TAG_START,\n421         \"closeblock\": BLOCK_TAG_END,\n422         \"openvariable\": VARIABLE_TAG_START,\n423         \"closevariable\": VARIABLE_TAG_END,\n424         \"openbrace\": SINGLE_BRACE_START,\n425         \"closebrace\": SINGLE_BRACE_END,\n426         \"opencomment\": COMMENT_TAG_START,\n427         \"closecomment\": COMMENT_TAG_END,\n428     }\n429 \n430     def __init__(self, tagtype):\n431         self.tagtype = tagtype\n432 \n433     def render(self, context):\n434         return self.mapping.get(self.tagtype, \"\")\n435 \n436 \n437 class URLNode(Node):\n438     child_nodelists = ()\n439 \n440     def __init__(self, view_name, args, kwargs, asvar):\n441         self.view_name = view_name\n442         self.args = args\n443         self.kwargs = kwargs\n444         self.asvar = asvar\n445 \n446     def __repr__(self):\n447         return \"<%s view_name='%s' args=%s kwargs=%s as=%s>\" % (\n448             self.__class__.__qualname__,\n449             self.view_name,\n450             repr(self.args),\n451             repr(self.kwargs),\n452             repr(self.asvar),\n453         )\n454 \n455     def render(self, context):\n456         from django.urls import NoReverseMatch, reverse\n457 \n458         args = [arg.resolve(context) for arg in self.args]\n459         kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}\n460         view_name = self.view_name.resolve(context)\n461         try:\n462             current_app = context.request.current_app\n463         except AttributeError:\n464             try:\n465                 current_app = context.request.resolver_match.namespace\n466             except AttributeError:\n467                 current_app = None\n468         # Try to look up the URL. If it fails, raise NoReverseMatch unless the\n469         # {% url ... as var %} construct is used, in which case return nothing.\n470         url = \"\"\n471         try:\n472             url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)\n473         except NoReverseMatch:\n474             if self.asvar is None:\n475                 raise\n476 \n477         if self.asvar:\n478             context[self.asvar] = url\n479             return \"\"\n480         else:\n481             if context.autoescape:\n482                 url = conditional_escape(url)\n483             return url\n484 \n485 \n486 class VerbatimNode(Node):\n487     def __init__(self, content):\n488         self.content = content\n489 \n490     def render(self, context):\n491         return self.content\n492 \n493 \n494 class WidthRatioNode(Node):\n495     def __init__(self, val_expr, max_expr, max_width, asvar=None):\n496         self.val_expr = val_expr\n497         self.max_expr = max_expr\n498         self.max_width = max_width\n499         self.asvar = asvar\n500 \n501     def render(self, context):\n502         try:\n503             value = self.val_expr.resolve(context)\n504             max_value = self.max_expr.resolve(context)\n505             max_width = int(self.max_width.resolve(context))\n506         except VariableDoesNotExist:\n507             return \"\"\n508         except (ValueError, TypeError):\n509             raise TemplateSyntaxError(\"widthratio final argument must be a number\")\n510         try:\n511             value = float(value)\n512             max_value = float(max_value)\n513             ratio = (value / max_value) * max_width\n514             result = str(round(ratio))\n515         except ZeroDivisionError:\n516             result = \"0\"\n517         except (ValueError, TypeError, OverflowError):\n518             result = \"\"\n519 \n520         if self.asvar:\n521             context[self.asvar] = result\n522             return \"\"\n523         else:\n524             return result\n525 \n526 \n527 class WithNode(Node):\n528     def __init__(self, var, name, nodelist, extra_context=None):\n529         self.nodelist = nodelist\n530         # var and name are legacy attributes, being left in case they are used\n531         # by third-party subclasses of this Node.\n532         self.extra_context = extra_context or {}\n533         if name:\n534             self.extra_context[name] = var\n535 \n536     def __repr__(self):\n537         return \"<%s>\" % self.__class__.__name__\n538 \n539     def render(self, context):\n540         values = {key: val.resolve(context) for key, val in self.extra_context.items()}\n541         with context.push(**values):\n542             return self.nodelist.render(context)\n543 \n544 \n545 @register.tag\n546 def autoescape(parser, token):\n547     \"\"\"\n548     Force autoescape behavior for this block.\n549     \"\"\"\n550     # token.split_contents() isn't useful here because this tag doesn't accept\n551     # variable as arguments.\n552     args = token.contents.split()\n553     if len(args) != 2:\n554         raise TemplateSyntaxError(\"'autoescape' tag requires exactly one argument.\")\n555     arg = args[1]\n556     if arg not in (\"on\", \"off\"):\n557         raise TemplateSyntaxError(\"'autoescape' argument should be 'on' or 'off'\")\n558     nodelist = parser.parse((\"endautoescape\",))\n559     parser.delete_first_token()\n560     return AutoEscapeControlNode((arg == \"on\"), nodelist)\n561 \n562 \n563 @register.tag\n564 def comment(parser, token):\n565     \"\"\"\n566     Ignore everything between ``{% comment %}`` and ``{% endcomment %}``.\n567     \"\"\"\n568     parser.skip_past(\"endcomment\")\n569     return CommentNode()\n570 \n571 \n572 @register.tag\n573 def cycle(parser, token):\n574     \"\"\"\n575     Cycle among the given strings each time this tag is encountered.\n576 \n577     Within a loop, cycles among the given strings each time through\n578     the loop::\n579 \n580         {% for o in some_list %}\n581             <tr class=\"{% cycle 'row1' 'row2' %}\">\n582                 ...\n583             </tr>\n584         {% endfor %}\n585 \n586     Outside of a loop, give the values a unique name the first time you call\n587     it, then use that name each successive time through::\n588 \n589             <tr class=\"{% cycle 'row1' 'row2' 'row3' as rowcolors %}\">...</tr>\n590             <tr class=\"{% cycle rowcolors %}\">...</tr>\n591             <tr class=\"{% cycle rowcolors %}\">...</tr>\n592 \n593     You can use any number of values, separated by spaces. Commas can also\n594     be used to separate values; if a comma is used, the cycle values are\n595     interpreted as literal strings.\n596 \n597     The optional flag \"silent\" can be used to prevent the cycle declaration\n598     from returning any value::\n599 \n600         {% for o in some_list %}\n601             {% cycle 'row1' 'row2' as rowcolors silent %}\n602             <tr class=\"{{ rowcolors }}\">{% include \"subtemplate.html \" %}</tr>\n603         {% endfor %}\n604     \"\"\"\n605     # Note: This returns the exact same node on each {% cycle name %} call;\n606     # that is, the node object returned from {% cycle a b c as name %} and the\n607     # one returned from {% cycle name %} are the exact same object. This\n608     # shouldn't cause problems (heh), but if it does, now you know.\n609     #\n610     # Ugly hack warning: This stuffs the named template dict into parser so\n611     # that names are only unique within each template (as opposed to using\n612     # a global variable, which would make cycle names have to be unique across\n613     # *all* templates.\n614     #\n615     # It keeps the last node in the parser to be able to reset it with\n616     # {% resetcycle %}.\n617 \n618     args = token.split_contents()\n619 \n620     if len(args) < 2:\n621         raise TemplateSyntaxError(\"'cycle' tag requires at least two arguments\")\n622 \n623     if len(args) == 2:\n624         # {% cycle foo %} case.\n625         name = args[1]\n626         if not hasattr(parser, \"_named_cycle_nodes\"):\n627             raise TemplateSyntaxError(\n628                 \"No named cycles in template. '%s' is not defined\" % name\n629             )\n630         if name not in parser._named_cycle_nodes:\n631             raise TemplateSyntaxError(\"Named cycle '%s' does not exist\" % name)\n632         return parser._named_cycle_nodes[name]\n633 \n634     as_form = False\n635 \n636     if len(args) > 4:\n637         # {% cycle ... as foo [silent] %} case.\n638         if args[-3] == \"as\":\n639             if args[-1] != \"silent\":\n640                 raise TemplateSyntaxError(\n641                     \"Only 'silent' flag is allowed after cycle's name, not '%s'.\"\n642                     % args[-1]\n643                 )\n644             as_form = True\n645             silent = True\n646             args = args[:-1]\n647         elif args[-2] == \"as\":\n648             as_form = True\n649             silent = False\n650 \n651     if as_form:\n652         name = args[-1]\n653         values = [parser.compile_filter(arg) for arg in args[1:-2]]\n654         node = CycleNode(values, name, silent=silent)\n655         if not hasattr(parser, \"_named_cycle_nodes\"):\n656             parser._named_cycle_nodes = {}\n657         parser._named_cycle_nodes[name] = node\n658     else:\n659         values = [parser.compile_filter(arg) for arg in args[1:]]\n660         node = CycleNode(values)\n661     parser._last_cycle_node = node\n662     return node\n663 \n664 \n665 @register.tag\n666 def csrf_token(parser, token):\n667     return CsrfTokenNode()\n668 \n669 \n670 @register.tag\n671 def debug(parser, token):\n672     \"\"\"\n673     Output a whole load of debugging information, including the current\n674     context and imported modules.\n675 \n676     Sample usage::\n677 \n678         <pre>\n679             {% debug %}\n680         </pre>\n681     \"\"\"\n682     return DebugNode()\n683 \n684 \n685 @register.tag(\"filter\")\n686 def do_filter(parser, token):\n687     \"\"\"\n688     Filter the contents of the block through variable filters.\n689 \n690     Filters can also be piped through each other, and they can have\n691     arguments -- just like in variable syntax.\n692 \n693     Sample usage::\n694 \n695         {% filter force_escape|lower %}\n696             This text will be HTML-escaped, and will appear in lowercase.\n697         {% endfilter %}\n698 \n699     Note that the ``escape`` and ``safe`` filters are not acceptable arguments.\n700     Instead, use the ``autoescape`` tag to manage autoescaping for blocks of\n701     template code.\n702     \"\"\"\n703     # token.split_contents() isn't useful here because this tag doesn't accept\n704     # variable as arguments.\n705     _, rest = token.contents.split(None, 1)\n706     filter_expr = parser.compile_filter(\"var|%s\" % (rest))\n707     for func, unused in filter_expr.filters:\n708         filter_name = getattr(func, \"_filter_name\", None)\n709         if filter_name in (\"escape\", \"safe\"):\n710             raise TemplateSyntaxError(\n711                 '\"filter %s\" is not permitted.  Use the \"autoescape\" tag instead.'\n712                 % filter_name\n713             )\n714     nodelist = parser.parse((\"endfilter\",))\n715     parser.delete_first_token()\n716     return FilterNode(filter_expr, nodelist)\n717 \n718 \n719 @register.tag\n720 def firstof(parser, token):\n721     \"\"\"\n722     Output the first variable passed that is not False.\n723 \n724     Output nothing if all the passed variables are False.\n725 \n726     Sample usage::\n727 \n728         {% firstof var1 var2 var3 as myvar %}\n729 \n730     This is equivalent to::\n731 \n732         {% if var1 %}\n733             {{ var1 }}\n734         {% elif var2 %}\n735             {{ var2 }}\n736         {% elif var3 %}\n737             {{ var3 }}\n738         {% endif %}\n739 \n740     but much cleaner!\n741 \n742     You can also use a literal string as a fallback value in case all\n743     passed variables are False::\n744 \n745         {% firstof var1 var2 var3 \"fallback value\" %}\n746 \n747     If you want to disable auto-escaping of variables you can use::\n748 \n749         {% autoescape off %}\n750             {% firstof var1 var2 var3 \"<strong>fallback value</strong>\" %}\n751         {% autoescape %}\n752 \n753     Or if only some variables should be escaped, you can use::\n754 \n755         {% firstof var1 var2|safe var3 \"<strong>fallback value</strong>\"|safe %}\n756     \"\"\"\n757     bits = token.split_contents()[1:]\n758     asvar = None\n759     if not bits:\n760         raise TemplateSyntaxError(\"'firstof' statement requires at least one argument\")\n761 \n762     if len(bits) >= 2 and bits[-2] == \"as\":\n763         asvar = bits[-1]\n764         bits = bits[:-2]\n765     return FirstOfNode([parser.compile_filter(bit) for bit in bits], asvar)\n766 \n767 \n768 @register.tag(\"for\")\n769 def do_for(parser, token):\n770     \"\"\"\n771     Loop over each item in an array.\n772 \n773     For example, to display a list of athletes given ``athlete_list``::\n774 \n775         <ul>\n776         {% for athlete in athlete_list %}\n777             <li>{{ athlete.name }}</li>\n778         {% endfor %}\n779         </ul>\n780 \n781     You can loop over a list in reverse by using\n782     ``{% for obj in list reversed %}``.\n783 \n784     You can also unpack multiple values from a two-dimensional array::\n785 \n786         {% for key,value in dict.items %}\n787             {{ key }}: {{ value }}\n788         {% endfor %}\n789 \n790     The ``for`` tag can take an optional ``{% empty %}`` clause that will\n791     be displayed if the given array is empty or could not be found::\n792 \n793         <ul>\n794           {% for athlete in athlete_list %}\n795             <li>{{ athlete.name }}</li>\n796           {% empty %}\n797             <li>Sorry, no athletes in this list.</li>\n798           {% endfor %}\n799         <ul>\n800 \n801     The above is equivalent to -- but shorter, cleaner, and possibly faster\n802     than -- the following::\n803 \n804         <ul>\n805           {% if athlete_list %}\n806             {% for athlete in athlete_list %}\n807               <li>{{ athlete.name }}</li>\n808             {% endfor %}\n809           {% else %}\n810             <li>Sorry, no athletes in this list.</li>\n811           {% endif %}\n812         </ul>\n813 \n814     The for loop sets a number of variables available within the loop:\n815 \n816         ==========================  ================================================\n817         Variable                    Description\n818         ==========================  ================================================\n819         ``forloop.counter``         The current iteration of the loop (1-indexed)\n820         ``forloop.counter0``        The current iteration of the loop (0-indexed)\n821         ``forloop.revcounter``      The number of iterations from the end of the\n822                                     loop (1-indexed)\n823         ``forloop.revcounter0``     The number of iterations from the end of the\n824                                     loop (0-indexed)\n825         ``forloop.first``           True if this is the first time through the loop\n826         ``forloop.last``            True if this is the last time through the loop\n827         ``forloop.parentloop``      For nested loops, this is the loop \"above\" the\n828                                     current one\n829         ==========================  ================================================\n830     \"\"\"\n831     bits = token.split_contents()\n832     if len(bits) < 4:\n833         raise TemplateSyntaxError(\n834             \"'for' statements should have at least four words: %s\" % token.contents\n835         )\n836 \n837     is_reversed = bits[-1] == \"reversed\"\n838     in_index = -3 if is_reversed else -2\n839     if bits[in_index] != \"in\":\n840         raise TemplateSyntaxError(\n841             \"'for' statements should use the format\"\n842             \" 'for x in y': %s\" % token.contents\n843         )\n844 \n845     invalid_chars = frozenset((\" \", '\"', \"'\", FILTER_SEPARATOR))\n846     loopvars = re.split(r\" *, *\", \" \".join(bits[1:in_index]))\n847     for var in loopvars:\n848         if not var or not invalid_chars.isdisjoint(var):\n849             raise TemplateSyntaxError(\n850                 \"'for' tag received an invalid argument: %s\" % token.contents\n851             )\n852 \n853     sequence = parser.compile_filter(bits[in_index + 1])\n854     nodelist_loop = parser.parse(\n855         (\n856             \"empty\",\n857             \"endfor\",\n858         )\n859     )\n860     token = parser.next_token()\n861     if token.contents == \"empty\":\n862         nodelist_empty = parser.parse((\"endfor\",))\n863         parser.delete_first_token()\n864     else:\n865         nodelist_empty = None\n866     return ForNode(loopvars, sequence, is_reversed, nodelist_loop, nodelist_empty)\n867 \n868 \n869 class TemplateLiteral(Literal):\n870     def __init__(self, value, text):\n871         self.value = value\n872         self.text = text  # for better error messages\n873 \n874     def display(self):\n875         return self.text\n876 \n877     def eval(self, context):\n878         return self.value.resolve(context, ignore_failures=True)\n879 \n880 \n881 class TemplateIfParser(IfParser):\n882     error_class = TemplateSyntaxError\n883 \n884     def __init__(self, parser, *args, **kwargs):\n885         self.template_parser = parser\n886         super().__init__(*args, **kwargs)\n887 \n888     def create_var(self, value):\n889         return TemplateLiteral(self.template_parser.compile_filter(value), value)\n890 \n891 \n892 @register.tag(\"if\")\n893 def do_if(parser, token):\n894     \"\"\"\n895     Evaluate a variable, and if that variable is \"true\" (i.e., exists, is not\n896     empty, and is not a false boolean value), output the contents of the block:\n897 \n898     ::\n899 \n900         {% if athlete_list %}\n901             Number of athletes: {{ athlete_list|count }}\n902         {% elif athlete_in_locker_room_list %}\n903             Athletes should be out of the locker room soon!\n904         {% else %}\n905             No athletes.\n906         {% endif %}\n907 \n908     In the above, if ``athlete_list`` is not empty, the number of athletes will\n909     be displayed by the ``{{ athlete_list|count }}`` variable.\n910 \n911     The ``if`` tag may take one or several `` {% elif %}`` clauses, as well as\n912     an ``{% else %}`` clause that will be displayed if all previous conditions\n913     fail. These clauses are optional.\n914 \n915     ``if`` tags may use ``or``, ``and`` or ``not`` to test a number of\n916     variables or to negate a given variable::\n917 \n918         {% if not athlete_list %}\n919             There are no athletes.\n920         {% endif %}\n921 \n922         {% if athlete_list or coach_list %}\n923             There are some athletes or some coaches.\n924         {% endif %}\n925 \n926         {% if athlete_list and coach_list %}\n927             Both athletes and coaches are available.\n928         {% endif %}\n929 \n930         {% if not athlete_list or coach_list %}\n931             There are no athletes, or there are some coaches.\n932         {% endif %}\n933 \n934         {% if athlete_list and not coach_list %}\n935             There are some athletes and absolutely no coaches.\n936         {% endif %}\n937 \n938     Comparison operators are also available, and the use of filters is also\n939     allowed, for example::\n940 \n941         {% if articles|length >= 5 %}...{% endif %}\n942 \n943     Arguments and operators _must_ have a space between them, so\n944     ``{% if 1>2 %}`` is not a valid if tag.\n945 \n946     All supported operators are: ``or``, ``and``, ``in``, ``not in``\n947     ``==``, ``!=``, ``>``, ``>=``, ``<`` and ``<=``.\n948 \n949     Operator precedence follows Python.\n950     \"\"\"\n951     # {% if ... %}\n952     bits = token.split_contents()[1:]\n953     condition = TemplateIfParser(parser, bits).parse()\n954     nodelist = parser.parse((\"elif\", \"else\", \"endif\"))\n955     conditions_nodelists = [(condition, nodelist)]\n956     token = parser.next_token()\n957 \n958     # {% elif ... %} (repeatable)\n959     while token.contents.startswith(\"elif\"):\n960         bits = token.split_contents()[1:]\n961         condition = TemplateIfParser(parser, bits).parse()\n962         nodelist = parser.parse((\"elif\", \"else\", \"endif\"))\n963         conditions_nodelists.append((condition, nodelist))\n964         token = parser.next_token()\n965 \n966     # {% else %} (optional)\n967     if token.contents == \"else\":\n968         nodelist = parser.parse((\"endif\",))\n969         conditions_nodelists.append((None, nodelist))\n970         token = parser.next_token()\n971 \n972     # {% endif %}\n973     if token.contents != \"endif\":\n974         raise TemplateSyntaxError(\n975             'Malformed template tag at line {}: \"{}\"'.format(\n976                 token.lineno, token.contents\n977             )\n978         )\n979 \n980     return IfNode(conditions_nodelists)\n981 \n982 \n983 @register.tag\n984 def ifchanged(parser, token):\n985     \"\"\"\n986     Check if a value has changed from the last iteration of a loop.\n987 \n988     The ``{% ifchanged %}`` block tag is used within a loop. It has two\n989     possible uses.\n990 \n991     1. Check its own rendered contents against its previous state and only\n992        displays the content if it has changed. For example, this displays a\n993        list of days, only displaying the month if it changes::\n994 \n995             <h1>Archive for {{ year }}</h1>\n996 \n997             {% for date in days %}\n998                 {% ifchanged %}<h3>{{ date|date:\"F\" }}</h3>{% endifchanged %}\n999                 <a href=\"{{ date|date:\"M/d\"|lower }}/\">{{ date|date:\"j\" }}</a>\n1000             {% endfor %}\n1001 \n1002     2. If given one or more variables, check whether any variable has changed.\n1003        For example, the following shows the date every time it changes, while\n1004        showing the hour if either the hour or the date has changed::\n1005 \n1006             {% for date in days %}\n1007                 {% ifchanged date.date %} {{ date.date }} {% endifchanged %}\n1008                 {% ifchanged date.hour date.date %}\n1009                     {{ date.hour }}\n1010                 {% endifchanged %}\n1011             {% endfor %}\n1012     \"\"\"\n1013     bits = token.split_contents()\n1014     nodelist_true = parser.parse((\"else\", \"endifchanged\"))\n1015     token = parser.next_token()\n1016     if token.contents == \"else\":\n1017         nodelist_false = parser.parse((\"endifchanged\",))\n1018         parser.delete_first_token()\n1019     else:\n1020         nodelist_false = NodeList()\n1021     values = [parser.compile_filter(bit) for bit in bits[1:]]\n1022     return IfChangedNode(nodelist_true, nodelist_false, *values)\n1023 \n1024 \n1025 def find_library(parser, name):\n1026     try:\n1027         return parser.libraries[name]\n1028     except KeyError:\n1029         raise TemplateSyntaxError(\n1030             \"'%s' is not a registered tag library. Must be one of:\\n%s\"\n1031             % (\n1032                 name,\n1033                 \"\\n\".join(sorted(parser.libraries)),\n1034             ),\n1035         )\n1036 \n1037 \n1038 def load_from_library(library, label, names):\n1039     \"\"\"\n1040     Return a subset of tags and filters from a library.\n1041     \"\"\"\n1042     subset = Library()\n1043     for name in names:\n1044         found = False\n1045         if name in library.tags:\n1046             found = True\n1047             subset.tags[name] = library.tags[name]\n1048         if name in library.filters:\n1049             found = True\n1050             subset.filters[name] = library.filters[name]\n1051         if found is False:\n1052             raise TemplateSyntaxError(\n1053                 \"'%s' is not a valid tag or filter in tag library '%s'\"\n1054                 % (\n1055                     name,\n1056                     label,\n1057                 ),\n1058             )\n1059     return subset\n1060 \n1061 \n1062 @register.tag\n1063 def load(parser, token):\n1064     \"\"\"\n1065     Load a custom template tag library into the parser.\n1066 \n1067     For example, to load the template tags in\n1068     ``django/templatetags/news/photos.py``::\n1069 \n1070         {% load news.photos %}\n1071 \n1072     Can also be used to load an individual tag/filter from\n1073     a library::\n1074 \n1075         {% load byline from news %}\n1076     \"\"\"\n1077     # token.split_contents() isn't useful here because this tag doesn't accept\n1078     # variable as arguments.\n1079     bits = token.contents.split()\n1080     if len(bits) >= 4 and bits[-2] == \"from\":\n1081         # from syntax is used; load individual tags from the library\n1082         name = bits[-1]\n1083         lib = find_library(parser, name)\n1084         subset = load_from_library(lib, name, bits[1:-2])\n1085         parser.add_library(subset)\n1086     else:\n1087         # one or more libraries are specified; load and add them to the parser\n1088         for name in bits[1:]:\n1089             lib = find_library(parser, name)\n1090             parser.add_library(lib)\n1091     return LoadNode()\n1092 \n1093 \n1094 @register.tag\n1095 def lorem(parser, token):\n1096     \"\"\"\n1097     Create random Latin text useful for providing test data in templates.\n1098 \n1099     Usage format::\n1100 \n1101         {% lorem [count] [method] [random] %}\n1102 \n1103     ``count`` is a number (or variable) containing the number of paragraphs or\n1104     words to generate (default is 1).\n1105 \n1106     ``method`` is either ``w`` for words, ``p`` for HTML paragraphs, ``b`` for\n1107     plain-text paragraph blocks (default is ``b``).\n1108 \n1109     ``random`` is the word ``random``, which if given, does not use the common\n1110     paragraph (starting \"Lorem ipsum dolor sit amet, consectetuer...\").\n1111 \n1112     Examples:\n1113 \n1114     * ``{% lorem %}`` outputs the common \"lorem ipsum\" paragraph\n1115     * ``{% lorem 3 p %}`` outputs the common \"lorem ipsum\" paragraph\n1116       and two random paragraphs each wrapped in HTML ``<p>`` tags\n1117     * ``{% lorem 2 w random %}`` outputs two random latin words\n1118     \"\"\"\n1119     bits = list(token.split_contents())\n1120     tagname = bits[0]\n1121     # Random bit\n1122     common = bits[-1] != \"random\"\n1123     if not common:\n1124         bits.pop()\n1125     # Method bit\n1126     if bits[-1] in (\"w\", \"p\", \"b\"):\n1127         method = bits.pop()\n1128     else:\n1129         method = \"b\"\n1130     # Count bit\n1131     if len(bits) > 1:\n1132         count = bits.pop()\n1133     else:\n1134         count = \"1\"\n1135     count = parser.compile_filter(count)\n1136     if len(bits) != 1:\n1137         raise TemplateSyntaxError(\"Incorrect format for %r tag\" % tagname)\n1138     return LoremNode(count, method, common)\n1139 \n1140 \n1141 @register.tag\n1142 def now(parser, token):\n1143     \"\"\"\n1144     Display the date, formatted according to the given string.\n1145 \n1146     Use the same format as PHP's ``date()`` function; see https://php.net/date\n1147     for all the possible values.\n1148 \n1149     Sample usage::\n1150 \n1151         It is {% now \"jS F Y H:i\" %}\n1152     \"\"\"\n1153     bits = token.split_contents()\n1154     asvar = None\n1155     if len(bits) == 4 and bits[-2] == \"as\":\n1156         asvar = bits[-1]\n1157         bits = bits[:-2]\n1158     if len(bits) != 2:\n1159         raise TemplateSyntaxError(\"'now' statement takes one argument\")\n1160     format_string = bits[1][1:-1]\n1161     return NowNode(format_string, asvar)\n1162 \n1163 \n1164 @register.tag\n1165 def regroup(parser, token):\n1166     \"\"\"\n1167     Regroup a list of alike objects by a common attribute.\n1168 \n1169     This complex tag is best illustrated by use of an example: say that\n1170     ``musicians`` is a list of ``Musician`` objects that have ``name`` and\n1171     ``instrument`` attributes, and you'd like to display a list that\n1172     looks like:\n1173 \n1174         * Guitar:\n1175             * Django Reinhardt\n1176             * Emily Remler\n1177         * Piano:\n1178             * Lovie Austin\n1179             * Bud Powell\n1180         * Trumpet:\n1181             * Duke Ellington\n1182 \n1183     The following snippet of template code would accomplish this dubious task::\n1184 \n1185         {% regroup musicians by instrument as grouped %}\n1186         <ul>\n1187         {% for group in grouped %}\n1188             <li>{{ group.grouper }}\n1189             <ul>\n1190                 {% for musician in group.list %}\n1191                 <li>{{ musician.name }}</li>\n1192                 {% endfor %}\n1193             </ul>\n1194         {% endfor %}\n1195         </ul>\n1196 \n1197     As you can see, ``{% regroup %}`` populates a variable with a list of\n1198     objects with ``grouper`` and ``list`` attributes. ``grouper`` contains the\n1199     item that was grouped by; ``list`` contains the list of objects that share\n1200     that ``grouper``. In this case, ``grouper`` would be ``Guitar``, ``Piano``\n1201     and ``Trumpet``, and ``list`` is the list of musicians who play this\n1202     instrument.\n1203 \n1204     Note that ``{% regroup %}`` does not work when the list to be grouped is not\n1205     sorted by the key you are grouping by! This means that if your list of\n1206     musicians was not sorted by instrument, you'd need to make sure it is sorted\n1207     before using it, i.e.::\n1208 \n1209         {% regroup musicians|dictsort:\"instrument\" by instrument as grouped %}\n1210     \"\"\"\n1211     bits = token.split_contents()\n1212     if len(bits) != 6:\n1213         raise TemplateSyntaxError(\"'regroup' tag takes five arguments\")\n1214     target = parser.compile_filter(bits[1])\n1215     if bits[2] != \"by\":\n1216         raise TemplateSyntaxError(\"second argument to 'regroup' tag must be 'by'\")\n1217     if bits[4] != \"as\":\n1218         raise TemplateSyntaxError(\"next-to-last argument to 'regroup' tag must be 'as'\")\n1219     var_name = bits[5]\n1220     # RegroupNode will take each item in 'target', put it in the context under\n1221     # 'var_name', evaluate 'var_name'.'expression' in the current context, and\n1222     # group by the resulting value. After all items are processed, it will\n1223     # save the final result in the context under 'var_name', thus clearing the\n1224     # temporary values. This hack is necessary because the template engine\n1225     # doesn't provide a context-aware equivalent of Python's getattr.\n1226     expression = parser.compile_filter(\n1227         var_name + VARIABLE_ATTRIBUTE_SEPARATOR + bits[3]\n1228     )\n1229     return RegroupNode(target, expression, var_name)\n1230 \n1231 \n1232 @register.tag\n1233 def resetcycle(parser, token):\n1234     \"\"\"\n1235     Reset a cycle tag.\n1236 \n1237     If an argument is given, reset the last rendered cycle tag whose name\n1238     matches the argument, else reset the last rendered cycle tag (named or\n1239     unnamed).\n1240     \"\"\"\n1241     args = token.split_contents()\n1242 \n1243     if len(args) > 2:\n1244         raise TemplateSyntaxError(\"%r tag accepts at most one argument.\" % args[0])\n1245 \n1246     if len(args) == 2:\n1247         name = args[1]\n1248         try:\n1249             return ResetCycleNode(parser._named_cycle_nodes[name])\n1250         except (AttributeError, KeyError):\n1251             raise TemplateSyntaxError(\"Named cycle '%s' does not exist.\" % name)\n1252     try:\n1253         return ResetCycleNode(parser._last_cycle_node)\n1254     except AttributeError:\n1255         raise TemplateSyntaxError(\"No cycles in template.\")\n1256 \n1257 \n1258 @register.tag\n1259 def spaceless(parser, token):\n1260     \"\"\"\n1261     Remove whitespace between HTML tags, including tab and newline characters.\n1262 \n1263     Example usage::\n1264 \n1265         {% spaceless %}\n1266             <p>\n1267                 <a href=\"foo/\">Foo</a>\n1268             </p>\n1269         {% endspaceless %}\n1270 \n1271     This example returns this HTML::\n1272 \n1273         <p><a href=\"foo/\">Foo</a></p>\n1274 \n1275     Only space between *tags* is normalized -- not space between tags and text.\n1276     In this example, the space around ``Hello`` isn't stripped::\n1277 \n1278         {% spaceless %}\n1279             <strong>\n1280                 Hello\n1281             </strong>\n1282         {% endspaceless %}\n1283     \"\"\"\n1284     nodelist = parser.parse((\"endspaceless\",))\n1285     parser.delete_first_token()\n1286     return SpacelessNode(nodelist)\n1287 \n1288 \n1289 @register.tag\n1290 def templatetag(parser, token):\n1291     \"\"\"\n1292     Output one of the bits used to compose template tags.\n1293 \n1294     Since the template system has no concept of \"escaping\", to display one of\n1295     the bits used in template tags, you must use the ``{% templatetag %}`` tag.\n1296 \n1297     The argument tells which template bit to output:\n1298 \n1299         ==================  =======\n1300         Argument            Outputs\n1301         ==================  =======\n1302         ``openblock``       ``{%``\n1303         ``closeblock``      ``%}``\n1304         ``openvariable``    ``{{``\n1305         ``closevariable``   ``}}``\n1306         ``openbrace``       ``{``\n1307         ``closebrace``      ``}``\n1308         ``opencomment``     ``{#``\n1309         ``closecomment``    ``#}``\n1310         ==================  =======\n1311     \"\"\"\n1312     # token.split_contents() isn't useful here because this tag doesn't accept\n1313     # variable as arguments.\n1314     bits = token.contents.split()\n1315     if len(bits) != 2:\n1316         raise TemplateSyntaxError(\"'templatetag' statement takes one argument\")\n1317     tag = bits[1]\n1318     if tag not in TemplateTagNode.mapping:\n1319         raise TemplateSyntaxError(\n1320             \"Invalid templatetag argument: '%s'.\"\n1321             \" Must be one of: %s\" % (tag, list(TemplateTagNode.mapping))\n1322         )\n1323     return TemplateTagNode(tag)\n1324 \n1325 \n1326 @register.tag\n1327 def url(parser, token):\n1328     r\"\"\"\n1329     Return an absolute URL matching the given view with its parameters.\n1330 \n1331     This is a way to define links that aren't tied to a particular URL\n1332     configuration::\n1333 \n1334         {% url \"url_name\" arg1 arg2 %}\n1335 \n1336         or\n1337 \n1338         {% url \"url_name\" name1=value1 name2=value2 %}\n1339 \n1340     The first argument is a URL pattern name. Other arguments are\n1341     space-separated values that will be filled in place of positional and\n1342     keyword arguments in the URL. Don't mix positional and keyword arguments.\n1343     All arguments for the URL must be present.\n1344 \n1345     For example, if you have a view ``app_name.views.client_details`` taking\n1346     the client's id and the corresponding line in a URLconf looks like this::\n1347 \n1348         path('client/<int:id>/', views.client_details, name='client-detail-view')\n1349 \n1350     and this app's URLconf is included into the project's URLconf under some\n1351     path::\n1352 \n1353         path('clients/', include('app_name.urls'))\n1354 \n1355     then in a template you can create a link for a certain client like this::\n1356 \n1357         {% url \"client-detail-view\" client.id %}\n1358 \n1359     The URL will look like ``/clients/client/123/``.\n1360 \n1361     The first argument may also be the name of a template variable that will be\n1362     evaluated to obtain the view name or the URL name, e.g.::\n1363 \n1364         {% with url_name=\"client-detail-view\" %}\n1365         {% url url_name client.id %}\n1366         {% endwith %}\n1367     \"\"\"\n1368     bits = token.split_contents()\n1369     if len(bits) < 2:\n1370         raise TemplateSyntaxError(\n1371             \"'%s' takes at least one argument, a URL pattern name.\" % bits[0]\n1372         )\n1373     viewname = parser.compile_filter(bits[1])\n1374     args = []\n1375     kwargs = {}\n1376     asvar = None\n1377     bits = bits[2:]\n1378     if len(bits) >= 2 and bits[-2] == \"as\":\n1379         asvar = bits[-1]\n1380         bits = bits[:-2]\n1381 \n1382     for bit in bits:\n1383         match = kwarg_re.match(bit)\n1384         if not match:\n1385             raise TemplateSyntaxError(\"Malformed arguments to url tag\")\n1386         name, value = match.groups()\n1387         if name:\n1388             kwargs[name] = parser.compile_filter(value)\n1389         else:\n1390             args.append(parser.compile_filter(value))\n1391 \n1392     return URLNode(viewname, args, kwargs, asvar)\n1393 \n1394 \n1395 @register.tag\n1396 def verbatim(parser, token):\n1397     \"\"\"\n1398     Stop the template engine from rendering the contents of this block tag.\n1399 \n1400     Usage::\n1401 \n1402         {% verbatim %}\n1403             {% don't process this %}\n1404         {% endverbatim %}\n1405 \n1406     You can also designate a specific closing tag block (allowing the\n1407     unrendered use of ``{% endverbatim %}``)::\n1408 \n1409         {% verbatim myblock %}\n1410             ...\n1411         {% endverbatim myblock %}\n1412     \"\"\"\n1413     nodelist = parser.parse((\"endverbatim\",))\n1414     parser.delete_first_token()\n1415     return VerbatimNode(nodelist.render(Context()))\n1416 \n1417 \n1418 @register.tag\n1419 def widthratio(parser, token):\n1420     \"\"\"\n1421     For creating bar charts and such. Calculate the ratio of a given value to a\n1422     maximum value, and then apply that ratio to a constant.\n1423 \n1424     For example::\n1425 \n1426         <img src=\"bar.png\" alt=\"Bar\"\n1427              height=\"10\" width=\"{% widthratio this_value max_value max_width %}\">\n1428 \n1429     If ``this_value`` is 175, ``max_value`` is 200, and ``max_width`` is 100,\n1430     the image in the above example will be 88 pixels wide\n1431     (because 175/200 = .875; .875 * 100 = 87.5 which is rounded up to 88).\n1432 \n1433     In some cases you might want to capture the result of widthratio in a\n1434     variable. It can be useful for instance in a blocktranslate like this::\n1435 \n1436         {% widthratio this_value max_value max_width as width %}\n1437         {% blocktranslate %}The width is: {{ width }}{% endblocktranslate %}\n1438     \"\"\"\n1439     bits = token.split_contents()\n1440     if len(bits) == 4:\n1441         tag, this_value_expr, max_value_expr, max_width = bits\n1442         asvar = None\n1443     elif len(bits) == 6:\n1444         tag, this_value_expr, max_value_expr, max_width, as_, asvar = bits\n1445         if as_ != \"as\":\n1446             raise TemplateSyntaxError(\n1447                 \"Invalid syntax in widthratio tag. Expecting 'as' keyword\"\n1448             )\n1449     else:\n1450         raise TemplateSyntaxError(\"widthratio takes at least three arguments\")\n1451 \n1452     return WidthRatioNode(\n1453         parser.compile_filter(this_value_expr),\n1454         parser.compile_filter(max_value_expr),\n1455         parser.compile_filter(max_width),\n1456         asvar=asvar,\n1457     )\n1458 \n1459 \n1460 @register.tag(\"with\")\n1461 def do_with(parser, token):\n1462     \"\"\"\n1463     Add one or more values to the context (inside of this block) for caching\n1464     and easy access.\n1465 \n1466     For example::\n1467 \n1468         {% with total=person.some_sql_method %}\n1469             {{ total }} object{{ total|pluralize }}\n1470         {% endwith %}\n1471 \n1472     Multiple values can be added to the context::\n1473 \n1474         {% with foo=1 bar=2 %}\n1475             ...\n1476         {% endwith %}\n1477 \n1478     The legacy format of ``{% with person.some_sql_method as total %}`` is\n1479     still accepted.\n1480     \"\"\"\n1481     bits = token.split_contents()\n1482     remaining_bits = bits[1:]\n1483     extra_context = token_kwargs(remaining_bits, parser, support_legacy=True)\n1484     if not extra_context:\n1485         raise TemplateSyntaxError(\n1486             \"%r expected at least one variable assignment\" % bits[0]\n1487         )\n1488     if remaining_bits:\n1489         raise TemplateSyntaxError(\n1490             \"%r received an invalid token: %r\" % (bits[0], remaining_bits[0])\n1491         )\n1492     nodelist = parser.parse((\"endwith\",))\n1493     parser.delete_first_token()\n1494     return WithNode(None, None, nodelist, extra_context=extra_context)\n",
        "intended_behavior": "The method handling the 'blocktranslate' tag should ensure that when 'asvar' is used, the output stored in the context is wrapped as a 'SafeString' if it has been auto-escaped, to prevent double escaping when the variable is used later in the template. This will require a check after the variable string is processed by 'blocktranslate' but before it's assigned to the context variable specified by 'asvar'."
    },
    {
        "rel_file_path": "django/templatetags/i18n.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/templatetags/i18n.py",
        "start": 1,
        "end": 616,
        "class_name": null,
        "method_name": null,
        "code": "1 from decimal import Decimal\n2 \n3 from django.conf import settings\n4 from django.template import Library, Node, TemplateSyntaxError, Variable\n5 from django.template.base import TokenType, render_value_in_context\n6 from django.template.defaulttags import token_kwargs\n7 from django.utils import translation\n8 from django.utils.safestring import SafeData, mark_safe\n9 \n10 register = Library()\n11 \n12 \n13 class GetAvailableLanguagesNode(Node):\n14     def __init__(self, variable):\n15         self.variable = variable\n16 \n17     def render(self, context):\n18         context[self.variable] = [\n19             (k, translation.gettext(v)) for k, v in settings.LANGUAGES\n20         ]\n21         return \"\"\n22 \n23 \n24 class GetLanguageInfoNode(Node):\n25     def __init__(self, lang_code, variable):\n26         self.lang_code = lang_code\n27         self.variable = variable\n28 \n29     def render(self, context):\n30         lang_code = self.lang_code.resolve(context)\n31         context[self.variable] = translation.get_language_info(lang_code)\n32         return \"\"\n33 \n34 \n35 class GetLanguageInfoListNode(Node):\n36     def __init__(self, languages, variable):\n37         self.languages = languages\n38         self.variable = variable\n39 \n40     def get_language_info(self, language):\n41         # ``language`` is either a language code string or a sequence\n42         # with the language code as its first item\n43         if len(language[0]) > 1:\n44             return translation.get_language_info(language[0])\n45         else:\n46             return translation.get_language_info(str(language))\n47 \n48     def render(self, context):\n49         langs = self.languages.resolve(context)\n50         context[self.variable] = [self.get_language_info(lang) for lang in langs]\n51         return \"\"\n52 \n53 \n54 class GetCurrentLanguageNode(Node):\n55     def __init__(self, variable):\n56         self.variable = variable\n57 \n58     def render(self, context):\n59         context[self.variable] = translation.get_language()\n60         return \"\"\n61 \n62 \n63 class GetCurrentLanguageBidiNode(Node):\n64     def __init__(self, variable):\n65         self.variable = variable\n66 \n67     def render(self, context):\n68         context[self.variable] = translation.get_language_bidi()\n69         return \"\"\n70 \n71 \n72 class TranslateNode(Node):\n73     child_nodelists = ()\n74 \n75     def __init__(self, filter_expression, noop, asvar=None, message_context=None):\n76         self.noop = noop\n77         self.asvar = asvar\n78         self.message_context = message_context\n79         self.filter_expression = filter_expression\n80         if isinstance(self.filter_expression.var, str):\n81             self.filter_expression.is_var = True\n82             self.filter_expression.var = Variable(\"'%s'\" % self.filter_expression.var)\n83 \n84     def render(self, context):\n85         self.filter_expression.var.translate = not self.noop\n86         if self.message_context:\n87             self.filter_expression.var.message_context = self.message_context.resolve(\n88                 context\n89             )\n90         output = self.filter_expression.resolve(context)\n91         value = render_value_in_context(output, context)\n92         # Restore percent signs. Percent signs in template text are doubled\n93         # so they are not interpreted as string format flags.\n94         is_safe = isinstance(value, SafeData)\n95         value = value.replace(\"%%\", \"%\")\n96         value = mark_safe(value) if is_safe else value\n97         if self.asvar:\n98             context[self.asvar] = value\n99             return \"\"\n100         else:\n101             return value\n102 \n103 \n104 class BlockTranslateNode(Node):\n105     def __init__(\n106         self,\n107         extra_context,\n108         singular,\n109         plural=None,\n110         countervar=None,\n111         counter=None,\n112         message_context=None,\n113         trimmed=False,\n114         asvar=None,\n115         tag_name=\"blocktranslate\",\n116     ):\n117         self.extra_context = extra_context\n118         self.singular = singular\n119         self.plural = plural\n120         self.countervar = countervar\n121         self.counter = counter\n122         self.message_context = message_context\n123         self.trimmed = trimmed\n124         self.asvar = asvar\n125         self.tag_name = tag_name\n126 \n127     def __repr__(self):\n128         return (\n129             f\"<{self.__class__.__qualname__}: \"\n130             f\"extra_context={self.extra_context!r} \"\n131             f\"singular={self.singular!r} plural={self.plural!r}>\"\n132         )\n133 \n134     def render_token_list(self, tokens):\n135         result = []\n136         vars = []\n137         for token in tokens:\n138             if token.token_type == TokenType.TEXT:\n139                 result.append(token.contents.replace(\"%\", \"%%\"))\n140             elif token.token_type == TokenType.VAR:\n141                 result.append(\"%%(%s)s\" % token.contents)\n142                 vars.append(token.contents)\n143         msg = \"\".join(result)\n144         if self.trimmed:\n145             msg = translation.trim_whitespace(msg)\n146         return msg, vars\n147 \n148     def render(self, context, nested=False):\n149         if self.message_context:\n150             message_context = self.message_context.resolve(context)\n151         else:\n152             message_context = None\n153         # Update() works like a push(), so corresponding context.pop() is at\n154         # the end of function\n155         context.update(\n156             {var: val.resolve(context) for var, val in self.extra_context.items()}\n157         )\n158         singular, vars = self.render_token_list(self.singular)\n159         if self.plural and self.countervar and self.counter:\n160             count = self.counter.resolve(context)\n161             if not isinstance(count, (Decimal, float, int)):\n162                 raise TemplateSyntaxError(\n163                     \"%r argument to %r tag must be a number.\"\n164                     % (self.countervar, self.tag_name)\n165                 )\n166             context[self.countervar] = count\n167             plural, plural_vars = self.render_token_list(self.plural)\n168             if message_context:\n169                 result = translation.npgettext(message_context, singular, plural, count)\n170             else:\n171                 result = translation.ngettext(singular, plural, count)\n172             vars.extend(plural_vars)\n173         else:\n174             if message_context:\n175                 result = translation.pgettext(message_context, singular)\n176             else:\n177                 result = translation.gettext(singular)\n178         default_value = context.template.engine.string_if_invalid\n179 \n180         def render_value(key):\n181             if key in context:\n182                 val = context[key]\n183             else:\n184                 val = default_value % key if \"%s\" in default_value else default_value\n185             return render_value_in_context(val, context)\n186 \n187         data = {v: render_value(v) for v in vars}\n188         context.pop()\n189         try:\n190             result = result % data\n191         except (KeyError, ValueError):\n192             if nested:\n193                 # Either string is malformed, or it's a bug\n194                 raise TemplateSyntaxError(\n195                     \"%r is unable to format string returned by gettext: %r \"\n196                     \"using %r\" % (self.tag_name, result, data)\n197                 )\n198             with translation.override(None):\n199                 result = self.render(context, nested=True)\n200         if self.asvar:\n201             context[self.asvar] = result\n202             return \"\"\n203         else:\n204             return result\n205 \n206 \n207 class LanguageNode(Node):\n208     def __init__(self, nodelist, language):\n209         self.nodelist = nodelist\n210         self.language = language\n211 \n212     def render(self, context):\n213         with translation.override(self.language.resolve(context)):\n214             output = self.nodelist.render(context)\n215         return output\n216 \n217 \n218 @register.tag(\"get_available_languages\")\n219 def do_get_available_languages(parser, token):\n220     \"\"\"\n221     Store a list of available languages in the context.\n222 \n223     Usage::\n224 \n225         {% get_available_languages as languages %}\n226         {% for language in languages %}\n227         ...\n228         {% endfor %}\n229 \n230     This puts settings.LANGUAGES into the named variable.\n231     \"\"\"\n232     # token.split_contents() isn't useful here because this tag doesn't accept\n233     # variable as arguments.\n234     args = token.contents.split()\n235     if len(args) != 3 or args[1] != \"as\":\n236         raise TemplateSyntaxError(\n237             \"'get_available_languages' requires 'as variable' (got %r)\" % args\n238         )\n239     return GetAvailableLanguagesNode(args[2])\n240 \n241 \n242 @register.tag(\"get_language_info\")\n243 def do_get_language_info(parser, token):\n244     \"\"\"\n245     Store the language information dictionary for the given language code in a\n246     context variable.\n247 \n248     Usage::\n249 \n250         {% get_language_info for LANGUAGE_CODE as l %}\n251         {{ l.code }}\n252         {{ l.name }}\n253         {{ l.name_translated }}\n254         {{ l.name_local }}\n255         {{ l.bidi|yesno:\"bi-directional,uni-directional\" }}\n256     \"\"\"\n257     args = token.split_contents()\n258     if len(args) != 5 or args[1] != \"for\" or args[3] != \"as\":\n259         raise TemplateSyntaxError(\n260             \"'%s' requires 'for string as variable' (got %r)\" % (args[0], args[1:])\n261         )\n262     return GetLanguageInfoNode(parser.compile_filter(args[2]), args[4])\n263 \n264 \n265 @register.tag(\"get_language_info_list\")\n266 def do_get_language_info_list(parser, token):\n267     \"\"\"\n268     Store a list of language information dictionaries for the given language\n269     codes in a context variable. The language codes can be specified either as\n270     a list of strings or a settings.LANGUAGES style list (or any sequence of\n271     sequences whose first items are language codes).\n272 \n273     Usage::\n274 \n275         {% get_language_info_list for LANGUAGES as langs %}\n276         {% for l in langs %}\n277           {{ l.code }}\n278           {{ l.name }}\n279           {{ l.name_translated }}\n280           {{ l.name_local }}\n281           {{ l.bidi|yesno:\"bi-directional,uni-directional\" }}\n282         {% endfor %}\n283     \"\"\"\n284     args = token.split_contents()\n285     if len(args) != 5 or args[1] != \"for\" or args[3] != \"as\":\n286         raise TemplateSyntaxError(\n287             \"'%s' requires 'for sequence as variable' (got %r)\" % (args[0], args[1:])\n288         )\n289     return GetLanguageInfoListNode(parser.compile_filter(args[2]), args[4])\n290 \n291 \n292 @register.filter\n293 def language_name(lang_code):\n294     return translation.get_language_info(lang_code)[\"name\"]\n295 \n296 \n297 @register.filter\n298 def language_name_translated(lang_code):\n299     english_name = translation.get_language_info(lang_code)[\"name\"]\n300     return translation.gettext(english_name)\n301 \n302 \n303 @register.filter\n304 def language_name_local(lang_code):\n305     return translation.get_language_info(lang_code)[\"name_local\"]\n306 \n307 \n308 @register.filter\n309 def language_bidi(lang_code):\n310     return translation.get_language_info(lang_code)[\"bidi\"]\n311 \n312 \n313 @register.tag(\"get_current_language\")\n314 def do_get_current_language(parser, token):\n315     \"\"\"\n316     Store the current language in the context.\n317 \n318     Usage::\n319 \n320         {% get_current_language as language %}\n321 \n322     This fetches the currently active language and puts its value into the\n323     ``language`` context variable.\n324     \"\"\"\n325     # token.split_contents() isn't useful here because this tag doesn't accept\n326     # variable as arguments.\n327     args = token.contents.split()\n328     if len(args) != 3 or args[1] != \"as\":\n329         raise TemplateSyntaxError(\n330             \"'get_current_language' requires 'as variable' (got %r)\" % args\n331         )\n332     return GetCurrentLanguageNode(args[2])\n333 \n334 \n335 @register.tag(\"get_current_language_bidi\")\n336 def do_get_current_language_bidi(parser, token):\n337     \"\"\"\n338     Store the current language layout in the context.\n339 \n340     Usage::\n341 \n342         {% get_current_language_bidi as bidi %}\n343 \n344     This fetches the currently active language's layout and puts its value into\n345     the ``bidi`` context variable. True indicates right-to-left layout,\n346     otherwise left-to-right.\n347     \"\"\"\n348     # token.split_contents() isn't useful here because this tag doesn't accept\n349     # variable as arguments.\n350     args = token.contents.split()\n351     if len(args) != 3 or args[1] != \"as\":\n352         raise TemplateSyntaxError(\n353             \"'get_current_language_bidi' requires 'as variable' (got %r)\" % args\n354         )\n355     return GetCurrentLanguageBidiNode(args[2])\n356 \n357 \n358 @register.tag(\"translate\")\n359 @register.tag(\"trans\")\n360 def do_translate(parser, token):\n361     \"\"\"\n362     Mark a string for translation and translate the string for the current\n363     language.\n364 \n365     Usage::\n366 \n367         {% translate \"this is a test\" %}\n368 \n369     This marks the string for translation so it will be pulled out by\n370     makemessages into the .po files and runs the string through the translation\n371     engine.\n372 \n373     There is a second form::\n374 \n375         {% translate \"this is a test\" noop %}\n376 \n377     This marks the string for translation, but returns the string unchanged.\n378     Use it when you need to store values into forms that should be translated\n379     later on.\n380 \n381     You can use variables instead of constant strings\n382     to translate stuff you marked somewhere else::\n383 \n384         {% translate variable %}\n385 \n386     This tries to translate the contents of the variable ``variable``. Make\n387     sure that the string in there is something that is in the .po file.\n388 \n389     It is possible to store the translated string into a variable::\n390 \n391         {% translate \"this is a test\" as var %}\n392         {{ var }}\n393 \n394     Contextual translations are also supported::\n395 \n396         {% translate \"this is a test\" context \"greeting\" %}\n397 \n398     This is equivalent to calling pgettext instead of (u)gettext.\n399     \"\"\"\n400     bits = token.split_contents()\n401     if len(bits) < 2:\n402         raise TemplateSyntaxError(\"'%s' takes at least one argument\" % bits[0])\n403     message_string = parser.compile_filter(bits[1])\n404     remaining = bits[2:]\n405 \n406     noop = False\n407     asvar = None\n408     message_context = None\n409     seen = set()\n410     invalid_context = {\"as\", \"noop\"}\n411 \n412     while remaining:\n413         option = remaining.pop(0)\n414         if option in seen:\n415             raise TemplateSyntaxError(\n416                 \"The '%s' option was specified more than once.\" % option,\n417             )\n418         elif option == \"noop\":\n419             noop = True\n420         elif option == \"context\":\n421             try:\n422                 value = remaining.pop(0)\n423             except IndexError:\n424                 raise TemplateSyntaxError(\n425                     \"No argument provided to the '%s' tag for the context option.\"\n426                     % bits[0]\n427                 )\n428             if value in invalid_context:\n429                 raise TemplateSyntaxError(\n430                     \"Invalid argument '%s' provided to the '%s' tag for the context \"\n431                     \"option\" % (value, bits[0]),\n432                 )\n433             message_context = parser.compile_filter(value)\n434         elif option == \"as\":\n435             try:\n436                 value = remaining.pop(0)\n437             except IndexError:\n438                 raise TemplateSyntaxError(\n439                     \"No argument provided to the '%s' tag for the as option.\" % bits[0]\n440                 )\n441             asvar = value\n442         else:\n443             raise TemplateSyntaxError(\n444                 \"Unknown argument for '%s' tag: '%s'. The only options \"\n445                 \"available are 'noop', 'context' \\\"xxx\\\", and 'as VAR'.\"\n446                 % (\n447                     bits[0],\n448                     option,\n449                 )\n450             )\n451         seen.add(option)\n452 \n453     return TranslateNode(message_string, noop, asvar, message_context)\n454 \n455 \n456 @register.tag(\"blocktranslate\")\n457 @register.tag(\"blocktrans\")\n458 def do_block_translate(parser, token):\n459     \"\"\"\n460     Translate a block of text with parameters.\n461 \n462     Usage::\n463 \n464         {% blocktranslate with bar=foo|filter boo=baz|filter %}\n465         This is {{ bar }} and {{ boo }}.\n466         {% endblocktranslate %}\n467 \n468     Additionally, this supports pluralization::\n469 \n470         {% blocktranslate count count=var|length %}\n471         There is {{ count }} object.\n472         {% plural %}\n473         There are {{ count }} objects.\n474         {% endblocktranslate %}\n475 \n476     This is much like ngettext, only in template syntax.\n477 \n478     The \"var as value\" legacy format is still supported::\n479 \n480         {% blocktranslate with foo|filter as bar and baz|filter as boo %}\n481         {% blocktranslate count var|length as count %}\n482 \n483     The translated string can be stored in a variable using `asvar`::\n484 \n485         {% blocktranslate with bar=foo|filter boo=baz|filter asvar var %}\n486         This is {{ bar }} and {{ boo }}.\n487         {% endblocktranslate %}\n488         {{ var }}\n489 \n490     Contextual translations are supported::\n491 \n492         {% blocktranslate with bar=foo|filter context \"greeting\" %}\n493             This is {{ bar }}.\n494         {% endblocktranslate %}\n495 \n496     This is equivalent to calling pgettext/npgettext instead of\n497     (u)gettext/(u)ngettext.\n498     \"\"\"\n499     bits = token.split_contents()\n500 \n501     options = {}\n502     remaining_bits = bits[1:]\n503     asvar = None\n504     while remaining_bits:\n505         option = remaining_bits.pop(0)\n506         if option in options:\n507             raise TemplateSyntaxError(\n508                 \"The %r option was specified more than once.\" % option\n509             )\n510         if option == \"with\":\n511             value = token_kwargs(remaining_bits, parser, support_legacy=True)\n512             if not value:\n513                 raise TemplateSyntaxError(\n514                     '\"with\" in %r tag needs at least one keyword argument.' % bits[0]\n515                 )\n516         elif option == \"count\":\n517             value = token_kwargs(remaining_bits, parser, support_legacy=True)\n518             if len(value) != 1:\n519                 raise TemplateSyntaxError(\n520                     '\"count\" in %r tag expected exactly '\n521                     \"one keyword argument.\" % bits[0]\n522                 )\n523         elif option == \"context\":\n524             try:\n525                 value = remaining_bits.pop(0)\n526                 value = parser.compile_filter(value)\n527             except Exception:\n528                 raise TemplateSyntaxError(\n529                     '\"context\" in %r tag expected exactly one argument.' % bits[0]\n530                 )\n531         elif option == \"trimmed\":\n532             value = True\n533         elif option == \"asvar\":\n534             try:\n535                 value = remaining_bits.pop(0)\n536             except IndexError:\n537                 raise TemplateSyntaxError(\n538                     \"No argument provided to the '%s' tag for the asvar option.\"\n539                     % bits[0]\n540                 )\n541             asvar = value\n542         else:\n543             raise TemplateSyntaxError(\n544                 \"Unknown argument for %r tag: %r.\" % (bits[0], option)\n545             )\n546         options[option] = value\n547 \n548     if \"count\" in options:\n549         countervar, counter = next(iter(options[\"count\"].items()))\n550     else:\n551         countervar, counter = None, None\n552     if \"context\" in options:\n553         message_context = options[\"context\"]\n554     else:\n555         message_context = None\n556     extra_context = options.get(\"with\", {})\n557 \n558     trimmed = options.get(\"trimmed\", False)\n559 \n560     singular = []\n561     plural = []\n562     while parser.tokens:\n563         token = parser.next_token()\n564         if token.token_type in (TokenType.VAR, TokenType.TEXT):\n565             singular.append(token)\n566         else:\n567             break\n568     if countervar and counter:\n569         if token.contents.strip() != \"plural\":\n570             raise TemplateSyntaxError(\n571                 \"%r doesn't allow other block tags inside it\" % bits[0]\n572             )\n573         while parser.tokens:\n574             token = parser.next_token()\n575             if token.token_type in (TokenType.VAR, TokenType.TEXT):\n576                 plural.append(token)\n577             else:\n578                 break\n579     end_tag_name = \"end%s\" % bits[0]\n580     if token.contents.strip() != end_tag_name:\n581         raise TemplateSyntaxError(\n582             \"%r doesn't allow other block tags (seen %r) inside it\"\n583             % (bits[0], token.contents)\n584         )\n585 \n586     return BlockTranslateNode(\n587         extra_context,\n588         singular,\n589         plural,\n590         countervar,\n591         counter,\n592         message_context,\n593         trimmed=trimmed,\n594         asvar=asvar,\n595         tag_name=bits[0],\n596     )\n597 \n598 \n599 @register.tag\n600 def language(parser, token):\n601     \"\"\"\n602     Enable the given language just for this block.\n603 \n604     Usage::\n605 \n606         {% language \"de\" %}\n607             This is {{ bar }} and {{ boo }}.\n608         {% endlanguage %}\n609     \"\"\"\n610     bits = token.split_contents()\n611     if len(bits) != 2:\n612         raise TemplateSyntaxError(\"'%s' takes one argument (language)\" % bits[0])\n613     language = parser.compile_filter(bits[1])\n614     nodelist = parser.parse((\"endlanguage\",))\n615     parser.delete_first_token()\n616     return LanguageNode(nodelist, language)\n",
        "intended_behavior": "The implementation must ensure that any text marked for output through the 'blocktranslate' tag into a template variable ('asvar') retains its mark of safety against further escaping. It could involve adjusting how the tag evaluates and stores its result, potentially making use of 'SafeData' or directly ensuring the result is a 'SafeString'."
    },
    {
        "rel_file_path": "django/utils/safestring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/utils/safestring.py",
        "start": 1,
        "end": 72,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Functions for working with \"safe strings\": strings that can be displayed safely\n3 without further escaping in HTML. Marking something as a \"safe string\" means\n4 that the producer of the string has already turned characters that should not\n5 be interpreted by the HTML engine (e.g. '<') into the appropriate entities.\n6 \"\"\"\n7 \n8 from functools import wraps\n9 \n10 from django.utils.functional import keep_lazy\n11 \n12 \n13 class SafeData:\n14     __slots__ = ()\n15 \n16     def __html__(self):\n17         \"\"\"\n18         Return the html representation of a string for interoperability.\n19 \n20         This allows other template engines to understand Django's SafeData.\n21         \"\"\"\n22         return self\n23 \n24 \n25 class SafeString(str, SafeData):\n26     \"\"\"\n27     A str subclass that has been specifically marked as \"safe\" for HTML output\n28     purposes.\n29     \"\"\"\n30 \n31     __slots__ = ()\n32 \n33     def __add__(self, rhs):\n34         \"\"\"\n35         Concatenating a safe string with another safe bytestring or\n36         safe string is safe. Otherwise, the result is no longer safe.\n37         \"\"\"\n38         t = super().__add__(rhs)\n39         if isinstance(rhs, SafeData):\n40             return SafeString(t)\n41         return t\n42 \n43     def __str__(self):\n44         return self\n45 \n46 \n47 SafeText = SafeString  # For backwards compatibility since Django 2.0.\n48 \n49 \n50 def _safety_decorator(safety_marker, func):\n51     @wraps(func)\n52     def wrapper(*args, **kwargs):\n53         return safety_marker(func(*args, **kwargs))\n54 \n55     return wrapper\n56 \n57 \n58 @keep_lazy(SafeString)\n59 def mark_safe(s):\n60     \"\"\"\n61     Explicitly mark a string as safe for (HTML) output purposes. The returned\n62     object can be used everywhere a string is appropriate.\n63 \n64     If used on a method as a decorator, mark the returned data as safe.\n65 \n66     Can be called multiple times on a single string.\n67     \"\"\"\n68     if hasattr(s, \"__html__\"):\n69         return s\n70     if callable(s):\n71         return _safety_decorator(mark_safe, s)\n72     return SafeString(s)\n",
        "intended_behavior": "Understanding how 'SafeData' marks data as safe and ensuring that the 'blocktranslate' process leverages this mechanism properly for variables meant to be output as HTML. Enhancements or checks might need to be added in the tag's processing to utilize these classes to wrap the output appropriately."
    }
]