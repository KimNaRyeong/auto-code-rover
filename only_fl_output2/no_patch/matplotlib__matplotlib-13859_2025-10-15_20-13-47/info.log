2025-10-15 20:13:47.978 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 20:13:53.108 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=306, output_tokens=12, cost=0.003420
2025-10-15 20:14:02.464 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=365, cost=0.015810
2025-10-15 20:14:03.473 | INFO     | registered non reproducing test 0
2025-10-15 20:14:18.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1199, output_tokens=584, cost=0.029510
2025-10-15 20:14:19.278 | INFO     | registered non reproducing test 1
2025-10-15 20:14:33.487 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1418, output_tokens=552, cost=0.030740
2025-10-15 20:14:34.474 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:14:43.581 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=594, output_tokens=362, cost=0.016800
2025-10-15 20:14:43.588 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:14:45.370 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=716, output_tokens=43, cost=0.008450
2025-10-15 20:14:45.371 | DEBUG    | Extracted a valid json.
2025-10-15 20:14:45.372 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"savefig\")",
        "search_code(\"figsize\")",
        "search_code(\"libpng\")"
    ],
    "bug_locations": []
}
2025-10-15 20:14:45.803 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 20:14:45.804 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 20:15:04.825 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4679, output_tokens=738, cost=0.068930
2025-10-15 20:15:04.833 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 20:15:14.191 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5633, output_tokens=334, cost=0.066350
2025-10-15 20:15:14.198 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 20:15:21.520 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=688, output_tokens=267, cost=0.014890
2025-10-15 20:15:21.521 | DEBUG    | Extracted a valid json.
2025-10-15 20:15:21.521 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "lib/matplotlib/figure.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Ensure that when the `figsize` parameter is processed, there is explicit validation to check that both width and height values are greater than zero. If a value of zero is encountered, raise a ValueError with a clear message indicating that figure dimensions must be positive. This preserves the functionality of figure creation and saving while preventing the situation that leads to a crash due to invalid dimensions."
        }, 
        {
            "file": "lib/matplotlib/pyplot.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "In the `savefig` function, add a pre-check for the figure size directly or ensure that any down-stream method from `pyplot.savefig` that eventually interacts with figure dimensions performs a check to prevent zero-width or zero-height figures from being passed to libpng. This check, similar to the one proposed in `figure.py`, should raise an informative exception if invalid dimensions are identified. This will warn users before an attempt is made to render or save the figure, thereby avoiding the runtime error from libpng."
        }
    ]
}
2025-10-15 20:15:21.538 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 The figure module provides the top-level
3 :class:`~matplotlib.artist.Artist`, the :class:`Figure`, which
4 contains all the plot elements.  The following classes are defined
5 
6 :class:`SubplotParams`
7     control the default spacing of the subplots
8 
9 :class:`Figure`
10     Top level container for all plot elements.
11 
12 """
13 
14 import logging
15 from numbers import Integral
16 
17 import numpy as np
18 
19 from matplotlib import rcParams
20 from matplotlib import backends, docstring, projections
21 from matplotlib import __version__ as _mpl_version
22 from matplotlib import get_backend
23 
24 import matplotlib.artist as martist
25 from matplotlib.artist import Artist, allow_rasterization
26 from matplotlib.backend_bases import FigureCanvasBase
27 import matplotlib.cbook as cbook
28 import matplotlib.colorbar as cbar
29 import matplotlib.image as mimage
30 
31 from matplotlib.axes import Axes, SubplotBase, subplot_class_factory
32 from matplotlib.blocking_input import BlockingMouseInput, BlockingKeyMouseInput
33 from matplotlib.gridspec import GridSpec
34 import matplotlib.legend as mlegend
35 from matplotlib.patches import Rectangle
36 from matplotlib.projections import (get_projection_names,
37                                     process_projection_requirements)
38 from matplotlib.text import Text, TextWithDash
39 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,
40                                    TransformedBbox)
41 import matplotlib._layoutbox as layoutbox
42 from matplotlib.backend_bases import NonGuiException
43 
44 _log = logging.getLogger(__name__)
45 
46 docstring.interpd.update(projection_names=get_projection_names())
47 
48 
49 def _stale_figure_callback(self, val):
50     if self.figure:
51         self.figure.stale = val
52 
53 
54 class AxesStack(cbook.Stack):
55     """
56     Specialization of the `.Stack` to handle all tracking of
57     `~matplotlib.axes.Axes` in a `.Figure`.
58     This stack stores ``key, (ind, axes)`` pairs, where:
59 
60         * **key** should be a hash of the args and kwargs
61           used in generating the Axes.
62         * **ind** is a serial number for tracking the order
63           in which axes were added.
64 
65     The AxesStack is a callable, where ``ax_stack()`` returns
66     the current axes. Alternatively the :meth:`current_key_axes` will
67     return the current key and associated axes.
68 
69     """
70     def __init__(self):
71         super().__init__()
72         self._ind = 0
73 
74     def as_list(self):
75         """
76         Return a list of the Axes instances that have been added to the figure.
77         """
78         ia_list = [a for k, a in self._elements]
79         ia_list.sort()
80         return [a for i, a in ia_list]
81 
82     def get(self, key):
83         """
84         Return the Axes instance that was added with *key*.
85         If it is not present, return *None*.
86         """
87         item = dict(self._elements).get(key)
88         if item is None:
89             return None
90         cbook.warn_deprecated(
91             "2.1",
92             message="Adding an axes using the same arguments as a previous "
93             "axes currently reuses the earlier instance.  In a future "
94             "version, a new instance will always be created and returned.  "
95             "Meanwhile, this warning can be suppressed, and the future "
96             "behavior ensured, by passing a unique label to each axes "
97             "instance.")
98         return item[1]
99 
100     def _entry_from_axes(self, e):
101         ind, k = {a: (ind, k) for k, (ind, a) in self._elements}[e]
102         return (k, (ind, e))
103 
104     def remove(self, a):
105         """Remove the axes from the stack."""
106         super().remove(self._entry_from_axes(a))
107 
108     def bubble(self, a):
109         """
110         Move the given axes, which must already exist in the
111         stack, to the top.
112         """
113         return super().bubble(self._entry_from_axes(a))
114 
115     def add(self, key, a):
116         """
117         Add Axes *a*, with key *key*, to the stack, and return the stack.
118 
119         If *key* is unhashable, replace it by a unique, arbitrary object.
120 
121         If *a* is already on the stack, don't add it again, but
122         return *None*.
123         """
124         # All the error checking may be unnecessary; but this method
125         # is called so seldom that the overhead is negligible.
126         if not isinstance(a, Axes):
127             raise ValueError("second argument, {!r}, is not an Axes".format(a))
128         try:
129             hash(key)
130         except TypeError:
131             key = object()
132 
133         a_existing = self.get(key)
134         if a_existing is not None:
135             super().remove((key, a_existing))
136             cbook._warn_external(
137                 "key {!r} already existed; Axes is being replaced".format(key))
138             # I don't think the above should ever happen.
139 
140         if a in self:
141             return None
142         self._ind += 1
143         return super().push((key, (self._ind, a)))
144 
145     def current_key_axes(self):
146         """
147         Return a tuple of ``(key, axes)`` for the active axes.
148 
149         If no axes exists on the stack, then returns ``(None, None)``.
150         """
151         if not len(self._elements):
152             return self._default, self._default
153         else:
154             key, (index, axes) = self._elements[self._pos]
155             return key, axes
156 
157     def __call__(self):
158         return self.current_key_axes()[1]
159 
160     def __contains__(self, a):
161         return a in self.as_list()
162 
163 
164 class SubplotParams(object):
165     """
166     A class to hold the parameters for a subplot.
167     """
168     def __init__(self, left=None, bottom=None, right=None, top=None,
169                  wspace=None, hspace=None):
170         """
171         All dimensions are fractions of the figure width or height.
172         Defaults are given by :rc:`figure.subplot.[name]`.
173 
174         Parameters
175         ----------
176         left : float
177             The left side of the subplots of the figure.
178 
179         right : float
180             The right side of the subplots of the figure.
181 
182         bottom : float
183             The bottom of the subplots of the figure.
184 
185         top : float
186             The top of the subplots of the figure.
187 
188         wspace : float
189             The amount of width reserved for space between subplots,
190             expressed as a fraction of the average axis width.
191 
192         hspace : float
193             The amount of height reserved for space between subplots,
194             expressed as a fraction of the average axis height.
195         """
196         self.validate = True
197         self.update(left, bottom, right, top, wspace, hspace)
198 
199     def update(self, left=None, bottom=None, right=None, top=None,
200                wspace=None, hspace=None):
201         """
202         Update the dimensions of the passed parameters. *None* means unchanged.
203         """
204         thisleft = getattr(self, 'left', None)
205         thisright = getattr(self, 'right', None)
206         thistop = getattr(self, 'top', None)
207         thisbottom = getattr(self, 'bottom', None)
208         thiswspace = getattr(self, 'wspace', None)
209         thishspace = getattr(self, 'hspace', None)
210 
211         self._update_this('left', left)
212         self._update_this('right', right)
213         self._update_this('bottom', bottom)
214         self._update_this('top', top)
215         self._update_this('wspace', wspace)
216         self._update_this('hspace', hspace)
217 
218         def reset():
219             self.left = thisleft
220             self.right = thisright
221             self.top = thistop
222             self.bottom = thisbottom
223             self.wspace = thiswspace
224             self.hspace = thishspace
225 
226         if self.validate:
227             if self.left >= self.right:
228                 reset()
229                 raise ValueError('left cannot be >= right')
230 
231             if self.bottom >= self.top:
232                 reset()
233                 raise ValueError('bottom cannot be >= top')
234 
235     def _update_this(self, s, val):
236         if val is None:
237             val = getattr(self, s, None)
238             if val is None:
239                 key = 'figure.subplot.' + s
240                 val = rcParams[key]
241 
242         setattr(self, s, val)
243 
244 
245 class Figure(Artist):
246     """
247     The top level container for all the plot elements.
248 
249     The Figure instance supports callbacks through a *callbacks* attribute
250     which is a `.CallbackRegistry` instance.  The events you can connect to
251     are 'dpi_changed', and the callback will be called with ``func(fig)`` where
252     fig is the `Figure` instance.
253 
254     Attributes
255     ----------
256     patch
257         The `.Rectangle` instance representing the figure background patch.
258 
259     suppressComposite
260         For multiple figure images, the figure will make composite images
261         depending on the renderer option_image_nocomposite function.  If
262         *suppressComposite* is a boolean, this will override the renderer.
263     """
264 
265     def __str__(self):
266         return "Figure(%gx%g)" % tuple(self.bbox.size)
267 
268     def __repr__(self):
269         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
270             clsname=self.__class__.__name__,
271             h=self.bbox.size[0], w=self.bbox.size[1],
272             naxes=len(self.axes),
273         )
274 
275     def __init__(self,
276                  figsize=None,
277                  dpi=None,
278                  facecolor=None,
279                  edgecolor=None,
280                  linewidth=0.0,
281                  frameon=None,
282                  subplotpars=None,  # default to rc
283                  tight_layout=None,  # default to rc figure.autolayout
284                  constrained_layout=None,  # default to rc
285                                           #figure.constrained_layout.use
286                  ):
287         """
288         Parameters
289         ----------
290         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
291             Figure dimension ``(width, height)`` in inches.
292 
293         dpi : float, default: :rc:`figure.dpi`
294             Dots per inch.
295 
296         facecolor : default: :rc:`figure.facecolor`
297             The figure patch facecolor.
298 
299         edgecolor : default: :rc:`figure.edgecolor`
300             The figure patch edge color.
301 
302         linewidth : float
303             The linewidth of the frame (i.e. the edge linewidth of the figure
304             patch).
305 
306         frameon : bool, default: :rc:`figure.frameon`
307             If ``False``, suppress drawing the figure background patch.
308 
309         subplotpars : :class:`SubplotParams`
310             Subplot parameters. If not given, the default subplot
311             parameters :rc:`figure.subplot.*` are used.
312 
313         tight_layout : bool or dict, default: :rc:`figure.autolayout`
314             If ``False`` use *subplotpars*. If ``True`` adjust subplot
315             parameters using `.tight_layout` with default padding.
316             When providing a dict containing the keys ``pad``, ``w_pad``,
317             ``h_pad``, and ``rect``, the default `.tight_layout` paddings
318             will be overridden.
319 
320         constrained_layout : bool
321             If ``True`` use constrained layout to adjust positioning of plot
322             elements.  Like ``tight_layout``, but designed to be more
323             flexible.  See
324             :doc:`/tutorials/intermediate/constrainedlayout_guide`
325             for examples.  (Note: does not work with :meth:`.subplot` or
326             :meth:`.subplot2grid`.)
327             Defaults to :rc:`figure.constrained_layout.use`.
328         """
329         super().__init__()
330         # remove the non-figure artist _axes property
331         # as it makes no sense for a figure to be _in_ an axes
332         # this is used by the property methods in the artist base class
333         # which are over-ridden in this class
334         del self._axes
335         self.callbacks = cbook.CallbackRegistry()
336 
337         if figsize is None:
338             figsize = rcParams['figure.figsize']
339         if dpi is None:
340             dpi = rcParams['figure.dpi']
341         if facecolor is None:
342             facecolor = rcParams['figure.facecolor']
343         if edgecolor is None:
344             edgecolor = rcParams['figure.edgecolor']
345         if frameon is None:
346             frameon = rcParams['figure.frameon']
347 
348         if not np.isfinite(figsize).all():
349             raise ValueError('figure size must be finite not '
350                              '{}'.format(figsize))
351         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
352 
353         self.dpi_scale_trans = Affine2D().scale(dpi, dpi)
354         # do not use property as it will trigger
355         self._dpi = dpi
356         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
357 
358         self.transFigure = BboxTransformTo(self.bbox)
359 
360         self.patch = Rectangle(
361             xy=(0, 0), width=1, height=1,
362             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
363             visible=frameon)
364         self._set_artist_props(self.patch)
365         self.patch.set_antialiased(False)
366 
367         FigureCanvasBase(self)  # Set self.canvas.
368         self._suptitle = None
369 
370         if subplotpars is None:
371             subplotpars = SubplotParams()
372 
373         self.subplotpars = subplotpars
374         # constrained_layout:
375         self._layoutbox = None
376         # set in set_constrained_layout_pads()
377         self.set_constrained_layout(constrained_layout)
378 
379         self.set_tight_layout(tight_layout)
380 
381         self._axstack = AxesStack()  # track all figure axes and current axes
382         self.clf()
383         self._cachedRenderer = None
384 
385         # groupers to keep track of x and y labels we want to align.
386         # see self.align_xlabels and self.align_ylabels and
387         # axis._get_tick_boxes_siblings
388         self._align_xlabel_grp = cbook.Grouper()
389         self._align_ylabel_grp = cbook.Grouper()
390 
391         # list of child gridspecs for this figure
392         self._gridspecs = []
393 
394     # TODO: I'd like to dynamically add the _repr_html_ method
395     # to the figure in the right context, but then IPython doesn't
396     # use it, for some reason.
397 
398     def _repr_html_(self):
399         # We can't use "isinstance" here, because then we'd end up importing
400         # webagg unconditionally.
401         if 'WebAgg' in type(self.canvas).__name__:
402             from matplotlib.backends import backend_webagg
403             return backend_webagg.ipython_inline_display(self)
404 
405     def show(self, warn=True):
406         """
407         If using a GUI backend with pyplot, display the figure window.
408 
409         If the figure was not created using
410         :func:`~matplotlib.pyplot.figure`, it will lack a
411         :class:`~matplotlib.backend_bases.FigureManagerBase`, and
412         will raise an AttributeError.
413 
414         .. warning::
415             This does not manage an GUI event loop. Consequently, the figure
416             may only be shown briefly or not shown at all if you or your
417             environment are not managing an event loop.
418 
419             Proper use cases for `.Figure.show` include running this from a
420             GUI application or an IPython shell.
421 
422             If you're running a pure python shell or executing a non-GUI
423             python script, you should use `matplotlib.pyplot.show` instead,
424             which takes care of managing the event loop for you.
425 
426         Parameters
427         ----------
428         warn : bool
429             If ``True`` and we are not running headless (i.e. on Linux with an
430             unset DISPLAY), issue warning when called on a non-GUI backend.
431         """
432         try:
433             manager = getattr(self.canvas, 'manager')
434         except AttributeError as err:
435             raise AttributeError("%s\n"
436                                  "Figure.show works only "
437                                  "for figures managed by pyplot, normally "
438                                  "created by pyplot.figure()." % err)
439 
440         if manager is not None:
441             try:
442                 manager.show()
443                 return
444             except NonGuiException:
445                 pass
446         if (backends._get_running_interactive_framework() != "headless"
447                 and warn):
448             cbook._warn_external('Matplotlib is currently using %s, which is '
449                                  'a non-GUI backend, so cannot show the '
450                                  'figure.' % get_backend())
451 
452     def _get_axes(self):
453         return self._axstack.as_list()
454 
455     axes = property(fget=_get_axes,
456                     doc="List of axes in the Figure. You can access the "
457                         "axes in the Figure through this list. "
458                         "Do not modify the list itself. Instead, use "
459                         "`~Figure.add_axes`, `~.Figure.subplot` or "
460                         "`~.Figure.delaxes` to add or remove an axes.")
461 
462     def _get_dpi(self):
463         return self._dpi
464 
465     def _set_dpi(self, dpi, forward=True):
466         """
467         Parameters
468         ----------
469         dpi : float
470 
471         forward : bool
472             Passed on to `~.Figure.set_size_inches`
473         """
474         self._dpi = dpi
475         self.dpi_scale_trans.clear().scale(dpi, dpi)
476         w, h = self.get_size_inches()
477         self.set_size_inches(w, h, forward=forward)
478         self.callbacks.process('dpi_changed', self)
479 
480     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
481 
482     def get_tight_layout(self):
483         """Return whether `.tight_layout` is called when drawing."""
484         return self._tight
485 
486     def set_tight_layout(self, tight):
487         """
488         Set whether and how `.tight_layout` is called when drawing.
489 
490         Parameters
491         ----------
492         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
493             If a bool, sets whether to call `.tight_layout` upon drawing.
494             If ``None``, use the ``figure.autolayout`` rcparam instead.
495             If a dict, pass it as kwargs to `.tight_layout`, overriding the
496             default paddings.
497         """
498         if tight is None:
499             tight = rcParams['figure.autolayout']
500         self._tight = bool(tight)
501         self._tight_parameters = tight if isinstance(tight, dict) else {}
502         self.stale = True
503 
504     def get_constrained_layout(self):
505         """
506         Return a boolean: True means constrained layout is being used.
507 
508         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
509         """
510         return self._constrained
511 
512     def set_constrained_layout(self, constrained):
513         """
514         Set whether ``constrained_layout`` is used upon drawing. If None,
515         the rcParams['figure.constrained_layout.use'] value will be used.
516 
517         When providing a dict containing the keys `w_pad`, `h_pad`
518         the default ``constrained_layout`` paddings will be
519         overridden.  These pads are in inches and default to 3.0/72.0.
520         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
521 
522         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
523 
524         Parameters
525         ----------
526         constrained : bool or dict or None
527         """
528         self._constrained_layout_pads = dict()
529         self._constrained_layout_pads['w_pad'] = None
530         self._constrained_layout_pads['h_pad'] = None
531         self._constrained_layout_pads['wspace'] = None
532         self._constrained_layout_pads['hspace'] = None
533         if constrained is None:
534             constrained = rcParams['figure.constrained_layout.use']
535         self._constrained = bool(constrained)
536         if isinstance(constrained, dict):
537             self.set_constrained_layout_pads(**constrained)
538         else:
539             self.set_constrained_layout_pads()
540 
541         self.stale = True
542 
543     def set_constrained_layout_pads(self, **kwargs):
544         """
545         Set padding for ``constrained_layout``.  Note the kwargs can be passed
546         as a dictionary ``fig.set_constrained_layout(**paddict)``.
547 
548         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
549 
550         Parameters
551         ----------
552 
553         w_pad : scalar
554             Width padding in inches.  This is the pad around axes
555             and is meant to make sure there is enough room for fonts to
556             look good.  Defaults to 3 pts = 0.04167 inches
557 
558         h_pad : scalar
559             Height padding in inches. Defaults to 3 pts.
560 
561         wspace : scalar
562             Width padding between subplots, expressed as a fraction of the
563             subplot width.  The total padding ends up being w_pad + wspace.
564 
565         hspace : scalar
566             Height padding between subplots, expressed as a fraction of the
567             subplot width. The total padding ends up being h_pad + hspace.
568 
569         """
570 
571         todo = ['w_pad', 'h_pad', 'wspace', 'hspace']
572         for td in todo:
573             if td in kwargs and kwargs[td] is not None:
574                 self._constrained_layout_pads[td] = kwargs[td]
575             else:
576                 self._constrained_layout_pads[td] = (
577                     rcParams['figure.constrained_layout.' + td])
578 
579     def get_constrained_layout_pads(self, relative=False):
580         """
581         Get padding for ``constrained_layout``.
582 
583         Returns a list of `w_pad, h_pad` in inches and
584         `wspace` and `hspace` as fractions of the subplot.
585 
586         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
587 
588         Parameters
589         ----------
590 
591         relative : boolean
592             If `True`, then convert from inches to figure relative.
593         """
594         w_pad = self._constrained_layout_pads['w_pad']
595         h_pad = self._constrained_layout_pads['h_pad']
596         wspace = self._constrained_layout_pads['wspace']
597         hspace = self._constrained_layout_pads['hspace']
598 
599         if relative and (w_pad is not None or h_pad is not None):
600             renderer0 = layoutbox.get_renderer(self)
601             dpi = renderer0.dpi
602             w_pad = w_pad * dpi / renderer0.width
603             h_pad = h_pad * dpi / renderer0.height
604 
605         return w_pad, h_pad, wspace, hspace
606 
607     def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which=None):
608         """
609         Date ticklabels often overlap, so it is useful to rotate them
610         and right align them.  Also, a common use case is a number of
611         subplots with shared xaxes where the x-axis is date data.  The
612         ticklabels are often long, and it helps to rotate them on the
613         bottom subplot and turn them off on other subplots, as well as
614         turn off xlabels.
615 
616         Parameters
617         ----------
618         bottom : scalar
619             The bottom of the subplots for :meth:`subplots_adjust`.
620 
621         rotation : angle in degrees
622             The rotation of the xtick labels.
623 
624         ha : string
625             The horizontal alignment of the xticklabels.
626 
627         which : {None, 'major', 'minor', 'both'}
628             Selects which ticklabels to rotate. Default is None which works
629             the same as major.
630         """
631         allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)
632         if len(self.axes) == 1:
633             for label in self.axes[0].get_xticklabels(which=which):
634                 label.set_ha(ha)
635                 label.set_rotation(rotation)
636         else:
637             if allsubplots:
638                 for ax in self.get_axes():
639                     if ax.is_last_row():
640                         for label in ax.get_xticklabels(which=which):
641                             label.set_ha(ha)
642                             label.set_rotation(rotation)
643                     else:
644                         for label in ax.get_xticklabels(which=which):
645                             label.set_visible(False)
646                         ax.set_xlabel('')
647 
648         if allsubplots:
649             self.subplots_adjust(bottom=bottom)
650         self.stale = True
651 
652     def get_children(self):
653         """Get a list of artists contained in the figure."""
654         return [self.patch,
655                 *self.artists,
656                 *self.axes,
657                 *self.lines,
658                 *self.patches,
659                 *self.texts,
660                 *self.images,
661                 *self.legends]
662 
663     def contains(self, mouseevent):
664         """
665         Test whether the mouse event occurred on the figure.
666 
667         Returns
668         -------
669             bool, {}
670         """
671         if self._contains is not None:
672             return self._contains(self, mouseevent)
673         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
674         return inside, {}
675 
676     def get_window_extent(self, *args, **kwargs):
677         """
678         Return the figure bounding box in display space. Arguments are ignored.
679         """
680         return self.bbox
681 
682     def suptitle(self, t, **kwargs):
683         """
684         Add a centered title to the figure.
685 
686         Parameters
687         ----------
688         t : str
689             The title text.
690 
691         x : float, default 0.5
692             The x location of the text in figure coordinates.
693 
694         y : float, default 0.98
695             The y location of the text in figure coordinates.
696 
697         horizontalalignment, ha : {'center', 'left', right'}, default: 'center'
698             The horizontal alignment of the text relative to (*x*, *y*).
699 
700         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
701 default: 'top'
702             The vertical alignment of the text relative to (*x*, *y*).
703 
704         fontsize, size : default: :rc:`figure.titlesize`
705             The font size of the text. See `.Text.set_size` for possible
706             values.
707 
708         fontweight, weight : default: :rc:`figure.titleweight`
709             The font weight of the text. See `.Text.set_weight` for possible
710             values.
711 
712 
713         Returns
714         -------
715             text
716                 The `.Text` instance of the title.
717 
718 
719         Other Parameters
720         ----------------
721         fontproperties : None or dict, optional
722             A dict of font properties. If *fontproperties* is given the
723             default values for font size and weight are taken from the
724             `FontProperties` defaults. :rc:`figure.titlesize` and
725             :rc:`figure.titleweight` are ignored in this case.
726 
727         **kwargs
728             Additional kwargs are :class:`matplotlib.text.Text` properties.
729 
730 
731         Examples
732         --------
733 
734         >>> fig.suptitle('This is the figure title', fontsize=12)
735         """
736         manual_position = ('x' in kwargs or 'y' in kwargs)
737 
738         x = kwargs.pop('x', 0.5)
739         y = kwargs.pop('y', 0.98)
740 
741         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
742             kwargs['horizontalalignment'] = 'center'
743         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
744             kwargs['verticalalignment'] = 'top'
745 
746         if 'fontproperties' not in kwargs:
747             if 'fontsize' not in kwargs and 'size' not in kwargs:
748                 kwargs['size'] = rcParams['figure.titlesize']
749             if 'fontweight' not in kwargs and 'weight' not in kwargs:
750                 kwargs['weight'] = rcParams['figure.titleweight']
751 
752         sup = self.text(x, y, t, **kwargs)
753         if self._suptitle is not None:
754             self._suptitle.set_text(t)
755             self._suptitle.set_position((x, y))
756             self._suptitle.update_from(sup)
757             sup.remove()
758         else:
759             self._suptitle = sup
760             self._suptitle._layoutbox = None
761             if self._layoutbox is not None and not manual_position:
762                 w_pad, h_pad, wspace, hspace =  \
763                         self.get_constrained_layout_pads(relative=True)
764                 figlb = self._layoutbox
765                 self._suptitle._layoutbox = layoutbox.LayoutBox(
766                         parent=figlb, artist=self._suptitle,
767                         name=figlb.name+'.suptitle')
768                 # stack the suptitle on top of all the children.
769                 # Some day this should be on top of all the children in the
770                 # gridspec only.
771                 for child in figlb.children:
772                     if child is not self._suptitle._layoutbox:
773                         layoutbox.vstack([self._suptitle._layoutbox,
774                                           child],
775                                          padding=h_pad*2., strength='required')
776         self.stale = True
777         return self._suptitle
778 
779     def set_canvas(self, canvas):
780         """
781         Set the canvas that contains the figure
782 
783         Parameters
784         ----------
785         canvas : FigureCanvas
786         """
787         self.canvas = canvas
788 
789     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
790                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
791         """
792         Add a non-resampled image to the figure.
793 
794         The image is attached to the lower or upper left corner depending on
795         *origin*.
796 
797         Parameters
798         ----------
799         X
800             The image data. This is an array of one of the following shapes:
801 
802             - MxN: luminance (grayscale) values
803             - MxNx3: RGB values
804             - MxNx4: RGBA values
805 
806         xo, yo : int
807             The *x*/*y* image offset in pixels.
808 
809         alpha : None or float
810             The alpha blending value.
811 
812         norm : :class:`matplotlib.colors.Normalize`
813             A :class:`.Normalize` instance to map the luminance to the
814             interval [0, 1].
815 
816         cmap : str or :class:`matplotlib.colors.Colormap`
817             The colormap to use. Default: :rc:`image.cmap`.
818 
819         vmin, vmax : scalar
820             If *norm* is not given, these values set the data limits for the
821             colormap.
822 
823         origin : {'upper', 'lower'}
824             Indicates where the [0, 0] index of the array is in the upper left
825             or lower left corner of the axes. Defaults to :rc:`image.origin`.
826 
827         resize : bool
828             If *True*, resize the figure to match the given image size.
829 
830         Returns
831         -------
832         :class:`matplotlib.image.FigureImage`
833 
834         Other Parameters
835         ----------------
836         **kwargs
837             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
838 
839         Notes
840         -----
841         figimage complements the axes image
842         (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
843         to fit the current axes.  If you want a resampled image to
844         fill the entire figure, you can define an
845         :class:`~matplotlib.axes.Axes` with extent [0,0,1,1].
846 
847 
848         Examples::
849 
850             f = plt.figure()
851             nx = int(f.get_figwidth() * f.dpi)
852             ny = int(f.get_figheight() * f.dpi)
853             data = np.random.random((ny, nx))
854             f.figimage(data)
855             plt.show()
856 
857         """
858         if resize:
859             dpi = self.get_dpi()
860             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
861             self.set_size_inches(figsize, forward=True)
862 
863         im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)
864         im.stale_callback = _stale_figure_callback
865 
866         im.set_array(X)
867         im.set_alpha(alpha)
868         if norm is None:
869             im.set_clim(vmin, vmax)
870         self.images.append(im)
871         im._remove_method = self.images.remove
872         self.stale = True
873         return im
874 
875     def set_size_inches(self, w, h=None, forward=True):
876         """Set the figure size in inches.
877 
878         Call signatures::
879 
880              fig.set_size_inches(w, h)  # OR
881              fig.set_size_inches((w, h))
882 
883         optional kwarg *forward=True* will cause the canvas size to be
884         automatically updated; e.g., you can resize the figure window
885         from the shell
886 
887         ACCEPTS: a (w, h) tuple with w, h in inches
888 
889         See Also
890         --------
891         matplotlib.Figure.get_size_inches
892         """
893 
894         # the width and height have been passed in as a tuple to the first
895         # argument, so unpack them
896         if h is None:
897             w, h = w
898         if not all(np.isfinite(_) for _ in (w, h)):
899             raise ValueError('figure size must be finite not '
900                              '({}, {})'.format(w, h))
901         self.bbox_inches.p1 = w, h
902 
903         if forward:
904             canvas = getattr(self, 'canvas')
905             if canvas is not None:
906                 ratio = getattr(self.canvas, '_dpi_ratio', 1)
907                 dpival = self.dpi / ratio
908                 canvasw = w * dpival
909                 canvash = h * dpival
910                 manager = getattr(self.canvas, 'manager', None)
911                 if manager is not None:
912                     manager.resize(int(canvasw), int(canvash))
913         self.stale = True
914 
915     def get_size_inches(self):
916         """
917         Returns the current size of the figure in inches.
918 
919         Returns
920         -------
921         size : ndarray
922            The size (width, height) of the figure in inches.
923 
924         See Also
925         --------
926         matplotlib.Figure.set_size_inches
927         """
928         return np.array(self.bbox_inches.p1)
929 
930     def get_edgecolor(self):
931         """Get the edge color of the Figure rectangle."""
932         return self.patch.get_edgecolor()
933 
934     def get_facecolor(self):
935         """Get the face color of the Figure rectangle."""
936         return self.patch.get_facecolor()
937 
938     def get_figwidth(self):
939         """Return the figure width as a float."""
940         return self.bbox_inches.width
941 
942     def get_figheight(self):
943         """Return the figure height as a float."""
944         return self.bbox_inches.height
945 
946     def get_dpi(self):
947         """Return the resolution in dots per inch as a float."""
948         return self.dpi
949 
950     def get_frameon(self):
951         """
952         Return the figure's background patch visibility, i.e.
953         whether the figure background will be drawn. Equivalent to
954         ``Figure.patch.get_visible()``.
955         """
956         return self.patch.get_visible()
957 
958     def set_edgecolor(self, color):
959         """
960         Set the edge color of the Figure rectangle.
961 
962         Parameters
963         ----------
964         color : color
965         """
966         self.patch.set_edgecolor(color)
967 
968     def set_facecolor(self, color):
969         """
970         Set the face color of the Figure rectangle.
971 
972         Parameters
973         ----------
974         color : color
975         """
976         self.patch.set_facecolor(color)
977 
978     def set_dpi(self, val):
979         """
980         Set the resolution of the figure in dots-per-inch.
981 
982         Parameters
983         ----------
984         val : float
985         """
986         self.dpi = val
987         self.stale = True
988 
989     def set_figwidth(self, val, forward=True):
990         """
991         Set the width of the figure in inches.
992 
993         Parameters
994         ----------
995         val : float
996         forward : bool
997         """
998         self.set_size_inches(val, self.get_figheight(), forward=forward)
999 
1000     def set_figheight(self, val, forward=True):
1001         """
1002         Set the height of the figure in inches.
1003 
1004         Parameters
1005         ----------
1006         val : float
1007         forward : bool
1008         """
1009         self.set_size_inches(self.get_figwidth(), val, forward=forward)
1010 
1011     def set_frameon(self, b):
1012         """
1013         Set the figure's background patch visibility, i.e.
1014         whether the figure background will be drawn. Equivalent to
1015         ``Figure.patch.set_visible()``.
1016 
1017         Parameters
1018         ----------
1019         b : bool
1020         """
1021         self.patch.set_visible(b)
1022         self.stale = True
1023 
1024     frameon = property(get_frameon, set_frameon)
1025 
1026     def delaxes(self, ax):
1027         """
1028         Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the
1029         current axes.
1030         """
1031         self._axstack.remove(ax)
1032         for func in self._axobservers:
1033             func(self)
1034         self.stale = True
1035 
1036     def add_artist(self, artist, clip=False):
1037         """
1038         Add any :class:`~matplotlib.artist.Artist` to the figure.
1039 
1040         Usually artists are added to axes objects using
1041         :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the
1042         rare cases that adding directly to the figure is necessary.
1043 
1044         Parameters
1045         ----------
1046         artist : `~matplotlib.artist.Artist`
1047             The artist to add to the figure. If the added artist has no
1048             transform previously set, its transform will be set to
1049             ``figure.transFigure``.
1050         clip : bool, optional, default ``False``
1051             An optional parameter ``clip`` determines whether the added artist
1052             should be clipped by the figure patch. Default is *False*,
1053             i.e. no clipping.
1054 
1055         Returns
1056         -------
1057         artist : The added `~matplotlib.artist.Artist`
1058         """
1059         artist.set_figure(self)
1060         self.artists.append(artist)
1061         artist._remove_method = self.artists.remove
1062 
1063         if not artist.is_transform_set():
1064             artist.set_transform(self.transFigure)
1065 
1066         if clip:
1067             artist.set_clip_path(self.patch)
1068 
1069         self.stale = True
1070         return artist
1071 
1072     def _make_key(self, *args, **kwargs):
1073         """Make a hashable key out of args and kwargs."""
1074 
1075         def fixitems(items):
1076             # items may have arrays and lists in them, so convert them
1077             # to tuples for the key
1078             ret = []
1079             for k, v in items:
1080                 # some objects can define __getitem__ without being
1081                 # iterable and in those cases the conversion to tuples
1082                 # will fail. So instead of using the np.iterable(v) function
1083                 # we simply try and convert to a tuple, and proceed if not.
1084                 try:
1085                     v = tuple(v)
1086                 except Exception:
1087                     pass
1088                 ret.append((k, v))
1089             return tuple(ret)
1090 
1091         def fixlist(args):
1092             ret = []
1093             for a in args:
1094                 if np.iterable(a):
1095                     a = tuple(a)
1096                 ret.append(a)
1097             return tuple(ret)
1098 
1099         key = fixlist(args), fixitems(kwargs.items())
1100         return key
1101 
1102     def _process_projection_requirements(
1103             self, *args, polar=False, projection=None, **kwargs):
1104         """
1105         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1106 
1107             (axes_proj_class, proj_class_kwargs, proj_stack_key)
1108 
1109         which can be used for new axes initialization/identification.
1110         """
1111         if polar:
1112             if projection is not None and projection != 'polar':
1113                 raise ValueError(
1114                     "polar=True, yet projection=%r. "
1115                     "Only one of these arguments should be supplied." %
1116                     projection)
1117             projection = 'polar'
1118 
1119         if isinstance(projection, str) or projection is None:
1120             projection_class = projections.get_projection_class(projection)
1121         elif hasattr(projection, '_as_mpl_axes'):
1122             projection_class, extra_kwargs = projection._as_mpl_axes()
1123             kwargs.update(**extra_kwargs)
1124         else:
1125             raise TypeError('projection must be a string, None or implement a '
1126                             '_as_mpl_axes method. Got %r' % projection)
1127 
1128         # Make the key without projection kwargs, this is used as a unique
1129         # lookup for axes instances
1130         key = self._make_key(*args, **kwargs)
1131 
1132         return projection_class, kwargs, key
1133 
1134     @docstring.dedent_interpd
1135     def add_axes(self, *args, **kwargs):
1136         """
1137         Add an axes to the figure.
1138 
1139         Call signatures::
1140 
1141             add_axes(rect, projection=None, polar=False, **kwargs)
1142             add_axes(ax)
1143 
1144         Parameters
1145         ----------
1146 
1147         rect : sequence of float
1148             The dimensions [left, bottom, width, height] of the new axes. All
1149             quantities are in fractions of figure width and height.
1150 
1151         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1152 'polar', 'rectilinear', str}, optional
1153             The projection type of the `~.axes.Axes`. *str* is the name of
1154             a custom projection, see `~matplotlib.projections`. The default
1155             None results in a 'rectilinear' projection.
1156 
1157         polar : boolean, optional
1158             If True, equivalent to projection='polar'.
1159 
1160         sharex, sharey : `~.axes.Axes`, optional
1161             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1162             The axis will have the same limits, ticks, and scale as the axis
1163             of the shared axes.
1164 
1165         label : str
1166             A label for the returned axes.
1167 
1168         Other Parameters
1169         ----------------
1170         **kwargs
1171             This method also takes the keyword arguments for
1172             the returned axes class. The keyword arguments for the
1173             rectilinear axes class `~.axes.Axes` can be found in
1174             the following table but there might also be other keyword
1175             arguments if another projection is used, see the actual axes
1176             class.
1177             %(Axes)s
1178 
1179         Returns
1180         -------
1181         axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
1182             The returned axes class depends on the projection used. It is
1183             `~.axes.Axes` if rectilinear projection are used and
1184             `.projections.polar.PolarAxes` if polar projection
1185             are used.
1186 
1187         Notes
1188         -----
1189         If the figure already has an axes with key (*args*,
1190         *kwargs*) then it will simply make that axes current and
1191         return it.  This behavior is deprecated. Meanwhile, if you do
1192         not want this behavior (i.e., you want to force the creation of a
1193         new axes), you must use a unique set of args and kwargs.  The axes
1194         *label* attribute has been exposed for this purpose: if you want
1195         two axes that are otherwise identical to be added to the figure,
1196         make sure you give them unique labels.
1197 
1198         In rare circumstances, `.add_axes` may be called with a single
1199         argument, a axes instance already created in the present figure but
1200         not in the figure's list of axes.
1201 
1202         See Also
1203         --------
1204         .Figure.add_subplot
1205         .pyplot.subplot
1206         .pyplot.axes
1207         .Figure.subplots
1208         .pyplot.subplots
1209 
1210         Examples
1211         --------
1212         Some simple examples::
1213 
1214             rect = l, b, w, h
1215             fig = plt.figure()
1216             fig.add_axes(rect,label=label1)
1217             fig.add_axes(rect,label=label2)
1218             fig.add_axes(rect, frameon=False, facecolor='g')
1219             fig.add_axes(rect, polar=True)
1220             ax=fig.add_axes(rect, projection='polar')
1221             fig.delaxes(ax)
1222             fig.add_axes(ax)
1223         """
1224 
1225         if not len(args):
1226             return
1227 
1228         # shortcut the projection "key" modifications later on, if an axes
1229         # with the exact args/kwargs exists, return it immediately.
1230         key = self._make_key(*args, **kwargs)
1231         ax = self._axstack.get(key)
1232         if ax is not None:
1233             self.sca(ax)
1234             return ax
1235 
1236         if isinstance(args[0], Axes):
1237             a = args[0]
1238             if a.get_figure() is not self:
1239                 raise ValueError(
1240                     "The Axes must have been created in the present figure")
1241         else:
1242             rect = args[0]
1243             if not np.isfinite(rect).all():
1244                 raise ValueError('all entries in rect must be finite '
1245                                  'not {}'.format(rect))
1246             projection_class, kwargs, key = \
1247                 self._process_projection_requirements(*args, **kwargs)
1248 
1249             # check that an axes of this type doesn't already exist, if it
1250             # does, set it as active and return it
1251             ax = self._axstack.get(key)
1252             if isinstance(ax, projection_class):
1253                 self.sca(ax)
1254                 return ax
1255 
1256             # create the new axes using the axes class given
1257             a = projection_class(self, rect, **kwargs)
1258 
1259         return self._add_axes_internal(key, a)
1260 
1261     @docstring.dedent_interpd
1262     def add_subplot(self, *args, **kwargs):
1263         """
1264         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
1265 
1266         Call signatures::
1267 
1268            add_subplot(nrows, ncols, index, **kwargs)
1269            add_subplot(pos, **kwargs)
1270            add_subplot(ax)
1271 
1272         Parameters
1273         ----------
1274         *args
1275             Either a 3-digit integer or three separate integers
1276             describing the position of the subplot. If the three
1277             integers are *nrows*, *ncols*, and *index* in order, the
1278             subplot will take the *index* position on a grid with *nrows*
1279             rows and *ncols* columns. *index* starts at 1 in the upper left
1280             corner and increases to the right.
1281 
1282             *pos* is a three digit integer, where the first digit is the
1283             number of rows, the second the number of columns, and the third
1284             the index of the subplot. i.e. fig.add_subplot(235) is the same as
1285             fig.add_subplot(2, 3, 5). Note that all integers must be less than
1286             10 for this form to work.
1287 
1288         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1289 'polar', 'rectilinear', str}, optional
1290             The projection type of the subplot (`~.axes.Axes`). *str* is the
1291             name of a custom projection, see `~matplotlib.projections`. The
1292             default None results in a 'rectilinear' projection.
1293 
1294         polar : boolean, optional
1295             If True, equivalent to projection='polar'.
1296 
1297         sharex, sharey : `~.axes.Axes`, optional
1298             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1299             The axis will have the same limits, ticks, and scale as the axis
1300             of the shared axes.
1301 
1302         label : str
1303             A label for the returned axes.
1304 
1305         Other Parameters
1306         ----------------
1307         **kwargs
1308             This method also takes the keyword arguments for
1309             the returned axes base class. The keyword arguments for the
1310             rectilinear base class `~.axes.Axes` can be found in
1311             the following table but there might also be other keyword
1312             arguments if another projection is used.
1313             %(Axes)s
1314 
1315         Returns
1316         -------
1317         axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a \
1318                subclass of `~.axes.Axes`)
1319 
1320             The axes of the subplot. The returned axes base class depends on
1321             the projection used. It is `~.axes.Axes` if rectilinear projection
1322             are used and `.projections.polar.PolarAxes` if polar projection
1323             are used. The returned axes is then a subplot subclass of the
1324             base class.
1325 
1326         Notes
1327         -----
1328         If the figure already has a subplot with key (*args*,
1329         *kwargs*) then it will simply make that subplot current and
1330         return it.  This behavior is deprecated. Meanwhile, if you do
1331         not want this behavior (i.e., you want to force the creation of a
1332         new subplot), you must use a unique set of args and kwargs.  The axes
1333         *label* attribute has been exposed for this purpose: if you want
1334         two subplots that are otherwise identical to be added to the figure,
1335         make sure you give them unique labels.
1336 
1337         In rare circumstances, `.add_subplot` may be called with a single
1338         argument, a subplot axes instance already created in the
1339         present figure but not in the figure's list of axes.
1340 
1341         See Also
1342         --------
1343         .Figure.add_axes
1344         .pyplot.subplot
1345         .pyplot.axes
1346         .Figure.subplots
1347         .pyplot.subplots
1348 
1349         Examples
1350         --------
1351         ::
1352 
1353             fig = plt.figure()
1354             fig.add_subplot(221)
1355 
1356             # equivalent but more general
1357             ax1 = fig.add_subplot(2, 2, 1)
1358 
1359             # add a subplot with no frame
1360             ax2 = fig.add_subplot(222, frameon=False)
1361 
1362             # add a polar subplot
1363             fig.add_subplot(223, projection='polar')
1364 
1365             # add a red subplot that share the x-axis with ax1
1366             fig.add_subplot(224, sharex=ax1, facecolor='red')
1367 
1368             #delete x2 from the figure
1369             fig.delaxes(ax2)
1370 
1371             #add x2 to the figure again
1372             fig.add_subplot(ax2)
1373         """
1374         if not len(args):
1375             args = (1, 1, 1)
1376 
1377         if len(args) == 1 and isinstance(args[0], Integral):
1378             if not 100 <= args[0] <= 999:
1379                 raise ValueError("Integer subplot specification must be a "
1380                                  "three-digit number, not {}".format(args[0]))
1381             args = tuple(map(int, str(args[0])))
1382 
1383         if isinstance(args[0], SubplotBase):
1384 
1385             a = args[0]
1386             if a.get_figure() is not self:
1387                 raise ValueError(
1388                     "The Subplot must have been created in the present figure")
1389             # make a key for the subplot (which includes the axes object id
1390             # in the hash)
1391             key = self._make_key(*args, **kwargs)
1392         else:
1393             projection_class, kwargs, key = \
1394                 self._process_projection_requirements(*args, **kwargs)
1395 
1396             # try to find the axes with this key in the stack
1397             ax = self._axstack.get(key)
1398 
1399             if ax is not None:
1400                 if isinstance(ax, projection_class):
1401                     # the axes already existed, so set it as active & return
1402                     self.sca(ax)
1403                     return ax
1404                 else:
1405                     # Undocumented convenience behavior:
1406                     # subplot(111); subplot(111, projection='polar')
1407                     # will replace the first with the second.
1408                     # Without this, add_subplot would be simpler and
1409                     # more similar to add_axes.
1410                     self._axstack.remove(ax)
1411 
1412             a = subplot_class_factory(projection_class)(self, *args, **kwargs)
1413 
1414         return self._add_axes_internal(key, a)
1415 
1416     def _add_axes_internal(self, key, ax):
1417         """Private helper for `add_axes` and `add_subplot`."""
1418         self._axstack.add(key, ax)
1419         self.sca(ax)
1420         ax._remove_method = self._remove_ax
1421         self.stale = True
1422         ax.stale_callback = _stale_figure_callback
1423         return ax
1424 
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr
1596 
1597     def _remove_ax(self, ax):
1598         def _reset_loc_form(axis):
1599             axis.set_major_formatter(axis.get_major_formatter())
1600             axis.set_major_locator(axis.get_major_locator())
1601             axis.set_minor_formatter(axis.get_minor_formatter())
1602             axis.set_minor_locator(axis.get_minor_locator())
1603 
1604         def _break_share_link(ax, grouper):
1605             siblings = grouper.get_siblings(ax)
1606             if len(siblings) > 1:
1607                 grouper.remove(ax)
1608                 for last_ax in siblings:
1609                     if ax is not last_ax:
1610                         return last_ax
1611             return None
1612 
1613         self.delaxes(ax)
1614         last_ax = _break_share_link(ax, ax._shared_y_axes)
1615         if last_ax is not None:
1616             _reset_loc_form(last_ax.yaxis)
1617 
1618         last_ax = _break_share_link(ax, ax._shared_x_axes)
1619         if last_ax is not None:
1620             _reset_loc_form(last_ax.xaxis)
1621 
1622     def clf(self, keep_observers=False):
1623         """
1624         Clear the figure.
1625 
1626         Set *keep_observers* to True if, for example,
1627         a gui widget is tracking the axes in the figure.
1628         """
1629         self.suppressComposite = None
1630         self.callbacks = cbook.CallbackRegistry()
1631 
1632         for ax in tuple(self.axes):  # Iterate over the copy.
1633             ax.cla()
1634             self.delaxes(ax)         # removes ax from self._axstack
1635 
1636         toolbar = getattr(self.canvas, 'toolbar', None)
1637         if toolbar is not None:
1638             toolbar.update()
1639         self._axstack.clear()
1640         self.artists = []
1641         self.lines = []
1642         self.patches = []
1643         self.texts = []
1644         self.images = []
1645         self.legends = []
1646         if not keep_observers:
1647             self._axobservers = []
1648         self._suptitle = None
1649         if self.get_constrained_layout():
1650             layoutbox.nonetree(self._layoutbox)
1651         self.stale = True
1652 
1653     def clear(self, keep_observers=False):
1654         """
1655         Clear the figure -- synonym for :meth:`clf`.
1656         """
1657         self.clf(keep_observers=keep_observers)
1658 
1659     @allow_rasterization
1660     def draw(self, renderer):
1661         """
1662         Render the figure using :class:`matplotlib.backend_bases.RendererBase`
1663         instance *renderer*.
1664         """
1665 
1666         # draw the figure bounding box, perhaps none for white figure
1667         if not self.get_visible():
1668             return
1669 
1670         artists = self.get_children()
1671         artists.remove(self.patch)
1672         artists = sorted(
1673             (artist for artist in artists if not artist.get_animated()),
1674             key=lambda artist: artist.get_zorder())
1675 
1676         for ax in self.axes:
1677             locator = ax.get_axes_locator()
1678             if locator:
1679                 pos = locator(ax, renderer)
1680                 ax.apply_aspect(pos)
1681             else:
1682                 ax.apply_aspect()
1683 
1684             for child in ax.get_children():
1685                 if hasattr(child, 'apply_aspect'):
1686                     locator = child.get_axes_locator()
1687                     if locator:
1688                         pos = locator(child, renderer)
1689                         child.apply_aspect(pos)
1690                     else:
1691                         child.apply_aspect()
1692 
1693         try:
1694             renderer.open_group('figure')
1695             if self.get_constrained_layout() and self.axes:
1696                 self.execute_constrained_layout(renderer)
1697             if self.get_tight_layout() and self.axes:
1698                 try:
1699                     self.tight_layout(renderer,
1700                                       **self._tight_parameters)
1701                 except ValueError:
1702                     pass
1703                     # ValueError can occur when resizing a window.
1704 
1705             self.patch.draw(renderer)
1706             mimage._draw_list_compositing_images(
1707                 renderer, self, artists, self.suppressComposite)
1708 
1709             renderer.close_group('figure')
1710         finally:
1711             self.stale = False
1712 
1713         self._cachedRenderer = renderer
1714         self.canvas.draw_event(renderer)
1715 
1716     def draw_artist(self, a):
1717         """
1718         Draw :class:`matplotlib.artist.Artist` instance *a* only.
1719         This is available only after the figure is drawn.
1720         """
1721         if self._cachedRenderer is None:
1722             raise AttributeError("draw_artist can only be used after an "
1723                                  "initial draw which caches the renderer")
1724         a.draw(self._cachedRenderer)
1725 
1726     def get_axes(self):
1727         """
1728         Return a list of axes in the Figure. You can access and modify the
1729         axes in the Figure through this list.
1730 
1731         Do not modify the list itself. Instead, use `~Figure.add_axes`,
1732         `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.
1733 
1734         Note: This is equivalent to the property `~.Figure.axes`.
1735         """
1736         return self.axes
1737 
1738     # Note: in the docstring below, the newlines in the examples after the
1739     # calls to legend() allow replacing it with figlegend() to generate the
1740     # docstring of pyplot.figlegend.
1741 
1742     @docstring.dedent_interpd
1743     def legend(self, *args, **kwargs):
1744         """
1745         Place a legend on the figure.
1746 
1747         To make a legend from existing artists on every axes::
1748 
1749           legend()
1750 
1751         To make a legend for a list of lines and labels::
1752 
1753           legend(
1754               (line1, line2, line3),
1755               ('label1', 'label2', 'label3'),
1756               loc='upper right')
1757 
1758         These can also be specified by keyword::
1759 
1760           legend(
1761               handles=(line1, line2, line3),
1762               labels=('label1', 'label2', 'label3'),
1763               loc='upper right')
1764 
1765         Parameters
1766         ----------
1767 
1768         handles : sequence of `.Artist`, optional
1769             A list of Artists (lines, patches) to be added to the legend.
1770             Use this together with *labels*, if you need full control on what
1771             is shown in the legend and the automatic mechanism described above
1772             is not sufficient.
1773 
1774             The length of handles and labels should be the same in this
1775             case. If they are not, they are truncated to the smaller length.
1776 
1777         labels : sequence of strings, optional
1778             A list of labels to show next to the artists.
1779             Use this together with *handles*, if you need full control on what
1780             is shown in the legend and the automatic mechanism described above
1781             is not sufficient.
1782 
1783         Other Parameters
1784         ----------------
1785 
1786         %(_legend_kw_doc)s
1787 
1788         Returns
1789         -------
1790         :class:`matplotlib.legend.Legend` instance
1791 
1792         Notes
1793         -----
1794         Not all kinds of artist are supported by the legend command. See
1795         :doc:`/tutorials/intermediate/legend_guide` for details.
1796         """
1797 
1798         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1799                 self.axes,
1800                 *args,
1801                 **kwargs)
1802         # check for third arg
1803         if len(extra_args):
1804             # cbook.warn_deprecated(
1805             #     "2.1",
1806             #     message="Figure.legend will accept no more than two "
1807             #     "positional arguments in the future.  Use "
1808             #     "'fig.legend(handles, labels, loc=location)' "
1809             #     "instead.")
1810             # kwargs['loc'] = extra_args[0]
1811             # extra_args = extra_args[1:]
1812             pass
1813         l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)
1814         self.legends.append(l)
1815         l._remove_method = self.legends.remove
1816         self.stale = True
1817         return l
1818 
1819     @cbook._delete_parameter("3.1", "withdash")
1820     @docstring.dedent_interpd
1821     def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):
1822         """
1823         Add text to figure.
1824 
1825         Parameters
1826         ----------
1827         x, y : float
1828             The position to place the text. By default, this is in figure
1829             coordinates, floats in [0, 1]. The coordinate system can be changed
1830             using the *transform* keyword.
1831 
1832         s : str
1833             The text string.
1834 
1835         fontdict : dictionary, optional, default: None
1836             A dictionary to override the default text properties. If fontdict
1837             is None, the defaults are determined by your rc parameters. A
1838             property in *kwargs* override the same property in fontdict.
1839 
1840         withdash : boolean, optional, default: False
1841             Creates a `~matplotlib.text.TextWithDash` instance instead of a
1842             `~matplotlib.text.Text` instance.
1843 
1844         Other Parameters
1845         ----------------
1846         **kwargs : `~matplotlib.text.Text` properties
1847             Other miscellaneous text parameters.
1848             %(Text)s
1849 
1850         Returns
1851         -------
1852         text : `~.text.Text`
1853 
1854         See Also
1855         --------
1856         .Axes.text
1857         .pyplot.text
1858         """
1859         default = dict(transform=self.transFigure)
1860 
1861         if withdash:
1862             text = TextWithDash(x=x, y=y, text=s)
1863         else:
1864             text = Text(x=x, y=y, text=s)
1865 
1866         text.update(default)
1867         if fontdict is not None:
1868             text.update(fontdict)
1869         text.update(kwargs)
1870 
1871         text.set_figure(self)
1872         text.stale_callback = _stale_figure_callback
1873 
1874         self.texts.append(text)
1875         text._remove_method = self.texts.remove
1876         self.stale = True
1877         return text
1878 
1879     def _set_artist_props(self, a):
1880         if a != self:
1881             a.set_figure(self)
1882         a.stale_callback = _stale_figure_callback
1883         a.set_transform(self.transFigure)
1884 
1885     @docstring.dedent_interpd
1886     def gca(self, **kwargs):
1887         """
1888         Get the current axes, creating one if necessary.
1889 
1890         The following kwargs are supported for ensuring the returned axes
1891         adheres to the given projection etc., and for axes creation if
1892         the active axes does not exist:
1893 
1894         %(Axes)s
1895 
1896         """
1897         ckey, cax = self._axstack.current_key_axes()
1898         # if there exists an axes on the stack see if it matches
1899         # the desired axes configuration
1900         if cax is not None:
1901 
1902             # if no kwargs are given just return the current axes
1903             # this is a convenience for gca() on axes such as polar etc.
1904             if not kwargs:
1905                 return cax
1906 
1907             # if the user has specified particular projection detail
1908             # then build up a key which can represent this
1909             else:
1910                 projection_class, _, key = \
1911                     self._process_projection_requirements(**kwargs)
1912 
1913                 # let the returned axes have any gridspec by removing it from
1914                 # the key
1915                 ckey = ckey[1:]
1916                 key = key[1:]
1917 
1918                 # if the cax matches this key then return the axes, otherwise
1919                 # continue and a new axes will be created
1920                 if key == ckey and isinstance(cax, projection_class):
1921                     return cax
1922                 else:
1923                     cbook._warn_external('Requested projection is different '
1924                                          'from current axis projection, '
1925                                          'creating new axis with requested '
1926                                          'projection.')
1927 
1928         # no axes found, so create one which spans the figure
1929         return self.add_subplot(1, 1, 1, **kwargs)
1930 
1931     def sca(self, a):
1932         """Set the current axes to be a and return a."""
1933         self._axstack.bubble(a)
1934         for func in self._axobservers:
1935             func(self)
1936         return a
1937 
1938     def _gci(self):
1939         """
1940         Helper for :func:`~matplotlib.pyplot.gci`. Do not use elsewhere.
1941         """
1942         # Look first for an image in the current Axes:
1943         cax = self._axstack.current_key_axes()[1]
1944         if cax is None:
1945             return None
1946         im = cax._gci()
1947         if im is not None:
1948             return im
1949 
1950         # If there is no image in the current Axes, search for
1951         # one in a previously created Axes.  Whether this makes
1952         # sense is debatable, but it is the documented behavior.
1953         for ax in reversed(self.axes):
1954             im = ax._gci()
1955             if im is not None:
1956                 return im
1957         return None
1958 
1959     def __getstate__(self):
1960         state = super().__getstate__()
1961 
1962         # the axobservers cannot currently be pickled.
1963         # Additionally, the canvas cannot currently be pickled, but this has
1964         # the benefit of meaning that a figure can be detached from one canvas,
1965         # and re-attached to another.
1966         for attr_to_pop in ('_axobservers', 'show',
1967                             'canvas', '_cachedRenderer'):
1968             state.pop(attr_to_pop, None)
1969 
1970         # add version information to the state
1971         state['__mpl_version__'] = _mpl_version
1972 
1973         # check whether the figure manager (if any) is registered with pyplot
1974         from matplotlib import _pylab_helpers
1975         if getattr(self.canvas, 'manager', None) \
1976                 in _pylab_helpers.Gcf.figs.values():
1977             state['_restore_to_pylab'] = True
1978 
1979         # set all the layoutbox information to None.  kiwisolver objects can't
1980         # be pickled, so we lose the layout options at this point.
1981         state.pop('_layoutbox', None)
1982         # suptitle:
1983         if self._suptitle is not None:
1984             self._suptitle._layoutbox = None
1985 
1986         return state
1987 
1988     def __setstate__(self, state):
1989         version = state.pop('__mpl_version__')
1990         restore_to_pylab = state.pop('_restore_to_pylab', False)
1991 
1992         if version != _mpl_version:
1993             cbook._warn_external(
1994                 f"This figure was saved with matplotlib version {version} and "
1995                 f"is unlikely to function correctly.")
1996 
1997         self.__dict__ = state
1998 
1999         # re-initialise some of the unstored state information
2000         self._axobservers = []
2001         self.canvas = None
2002         self._layoutbox = None
2003 
2004         if restore_to_pylab:
2005             # lazy import to avoid circularity
2006             import matplotlib.pyplot as plt
2007             import matplotlib._pylab_helpers as pylab_helpers
2008             allnums = plt.get_fignums()
2009             num = max(allnums) + 1 if allnums else 1
2010             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)
2011 
2012             # XXX The following is a copy and paste from pyplot. Consider
2013             # factoring to pylab_helpers
2014 
2015             if self.get_label():
2016                 mgr.set_window_title(self.get_label())
2017 
2018             # make this figure current on button press event
2019             def make_active(event):
2020                 pylab_helpers.Gcf.set_active(mgr)
2021 
2022             mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',
2023                                                  make_active)
2024 
2025             pylab_helpers.Gcf.set_active(mgr)
2026             self.number = num
2027 
2028             plt.draw_if_interactive()
2029         self.stale = True
2030 
2031     def add_axobserver(self, func):
2032         """Whenever the axes state change, ``func(self)`` will be called."""
2033         self._axobservers.append(func)
2034 
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])
2186 
2187     @docstring.dedent_interpd
2188     def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):
2189         """
2190         Create a colorbar for a ScalarMappable instance, *mappable*.
2191 
2192         Documentation for the pyplot thin wrapper:
2193         %(colorbar_doc)s
2194         """
2195         if ax is None:
2196             ax = self.gca()
2197 
2198         # Store the value of gca so that we can set it back later on.
2199         current_ax = self.gca()
2200 
2201         if cax is None:
2202             if use_gridspec and isinstance(ax, SubplotBase)  \
2203                      and (not self.get_constrained_layout()):
2204                 cax, kw = cbar.make_axes_gridspec(ax, **kw)
2205             else:
2206                 cax, kw = cbar.make_axes(ax, **kw)
2207 
2208         # need to remove kws that cannot be passed to Colorbar
2209         NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',
2210                              'panchor']
2211         cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}
2212         cb = cbar.colorbar_factory(cax, mappable, **cb_kw)
2213 
2214         self.sca(current_ax)
2215         self.stale = True
2216         return cb
2217 
2218     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
2219                         wspace=None, hspace=None):
2220         """
2221         Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when
2222         *None*) and update the subplot locations.
2223 
2224         """
2225         if self.get_constrained_layout():
2226             self.set_constrained_layout(False)
2227             cbook._warn_external("This figure was using "
2228                                  "constrained_layout==True, but that is "
2229                                  "incompatible with subplots_adjust and or "
2230                                  "tight_layout: setting "
2231                                  "constrained_layout==False. ")
2232         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
2233         for ax in self.axes:
2234             if not isinstance(ax, SubplotBase):
2235                 # Check if sharing a subplots axis
2236                 if isinstance(ax._sharex, SubplotBase):
2237                     ax._sharex.update_params()
2238                     ax.set_position(ax._sharex.figbox)
2239                 elif isinstance(ax._sharey, SubplotBase):
2240                     ax._sharey.update_params()
2241                     ax.set_position(ax._sharey.figbox)
2242             else:
2243                 ax.update_params()
2244                 ax.set_position(ax.figbox)
2245         self.stale = True
2246 
2247     def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,
2248                mouse_pop=3, mouse_stop=2):
2249         """
2250         Blocking call to interact with a figure.
2251 
2252         Wait until the user clicks *n* times on the figure, and return the
2253         coordinates of each click in a list.
2254 
2255         There are three possible interactions:
2256 
2257         - Add a point.
2258         - Remove the most recently added point.
2259         - Stop the interaction and return the points added so far.
2260 
2261         The actions are assigned to mouse buttons via the arguments
2262         *mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined
2263         by the numbers:
2264 
2265         - 1: left mouse button
2266         - 2: middle mouse button
2267         - 3: right mouse button
2268         - None: no mouse button
2269 
2270         Parameters
2271         ----------
2272         n : int, optional, default: 1
2273             Number of mouse clicks to accumulate. If negative, accumulate
2274             clicks until the input is terminated manually.
2275         timeout : scalar, optional, default: 30
2276             Number of seconds to wait before timing out. If zero or negative
2277             will never timeout.
2278         show_clicks : bool, optional, default: False
2279             If True, show a red cross at the location of each click.
2280         mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)
2281             Mouse button used to add points.
2282         mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)
2283             Mouse button used to remove the most recently added point.
2284         mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)
2285             Mouse button used to stop input.
2286 
2287         Returns
2288         -------
2289         points : list of tuples
2290             A list of the clicked (x, y) coordinates.
2291 
2292         Notes
2293         -----
2294         The keyboard can also be used to select points in case your mouse
2295         does not have one or more of the buttons.  The delete and backspace
2296         keys act like right clicking (i.e., remove last point), the enter key
2297         terminates input and any other key (not already used by the window
2298         manager) selects a point.
2299         """
2300         blocking_mouse_input = BlockingMouseInput(self,
2301                                                   mouse_add=mouse_add,
2302                                                   mouse_pop=mouse_pop,
2303                                                   mouse_stop=mouse_stop)
2304         return blocking_mouse_input(n=n, timeout=timeout,
2305                                     show_clicks=show_clicks)
2306 
2307     def waitforbuttonpress(self, timeout=-1):
2308         """
2309         Blocking call to interact with the figure.
2310 
2311         This will return True is a key was pressed, False if a mouse
2312         button was pressed and None if *timeout* was reached without
2313         either being pressed.
2314 
2315         If *timeout* is negative, does not timeout.
2316         """
2317         blocking_input = BlockingKeyMouseInput(self)
2318         return blocking_input(timeout=timeout)
2319 
2320     def get_default_bbox_extra_artists(self):
2321         bbox_artists = [artist for artist in self.get_children()
2322                         if (artist.get_visible() and artist.get_in_layout())]
2323         for ax in self.axes:
2324             if ax.get_visible():
2325                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
2326         # we don't want the figure's patch to influence the bbox calculation
2327         bbox_artists.remove(self.patch)
2328         return bbox_artists
2329 
2330     def get_tightbbox(self, renderer, bbox_extra_artists=None):
2331         """
2332         Return a (tight) bounding box of the figure in inches.
2333 
2334         Artists that have ``artist.set_in_layout(False)`` are not included
2335         in the bbox.
2336 
2337         Parameters
2338         ----------
2339         renderer : `.RendererBase` instance
2340             renderer that will be used to draw the figures (i.e.
2341             ``fig.canvas.get_renderer()``)
2342 
2343         bbox_extra_artists : list of `.Artist` or ``None``
2344             List of artists to include in the tight bounding box.  If
2345             ``None`` (default), then all artist children of each axes are
2346             included in the tight bounding box.
2347 
2348         Returns
2349         -------
2350         bbox : `.BboxBase`
2351             containing the bounding box (in figure inches).
2352         """
2353 
2354         bb = []
2355         if bbox_extra_artists is None:
2356             artists = self.get_default_bbox_extra_artists()
2357         else:
2358             artists = bbox_extra_artists
2359 
2360         for a in artists:
2361             bbox = a.get_tightbbox(renderer)
2362             if bbox is not None and (bbox.width != 0 or bbox.height != 0):
2363                 bb.append(bbox)
2364 
2365         for ax in self.axes:
2366             if ax.get_visible():
2367                 # some axes don't take the bbox_extra_artists kwarg so we
2368                 # need this conditional....
2369                 try:
2370                     bbox = ax.get_tightbbox(renderer,
2371                             bbox_extra_artists=bbox_extra_artists)
2372                 except TypeError:
2373                     bbox = ax.get_tightbbox(renderer)
2374                 bb.append(bbox)
2375         bb = [b for b in bb
2376               if (np.isfinite(b.width) and np.isfinite(b.height)
2377                   and (b.width != 0 or b.height != 0))]
2378 
2379         if len(bb) == 0:
2380             return self.bbox_inches
2381 
2382         _bbox = Bbox.union(bb)
2383 
2384         bbox_inches = TransformedBbox(_bbox,
2385                                       Affine2D().scale(1. / self.dpi))
2386 
2387         return bbox_inches
2388 
2389     def init_layoutbox(self):
2390         """Initialize the layoutbox for use in constrained_layout."""
2391         if self._layoutbox is None:
2392             self._layoutbox = layoutbox.LayoutBox(parent=None,
2393                                      name='figlb',
2394                                      artist=self)
2395             self._layoutbox.constrain_geometry(0., 0., 1., 1.)
2396 
2397     def execute_constrained_layout(self, renderer=None):
2398         """
2399         Use ``layoutbox`` to determine pos positions within axes.
2400 
2401         See also `.set_constrained_layout_pads`.
2402         """
2403 
2404         from matplotlib._constrained_layout import do_constrained_layout
2405 
2406         _log.debug('Executing constrainedlayout')
2407         if self._layoutbox is None:
2408             cbook._warn_external("Calling figure.constrained_layout, but "
2409                                  "figure not setup to do constrained layout. "
2410                                  " You either called GridSpec without the "
2411                                  "fig keyword, you are using plt.subplot, "
2412                                  "or you need to call figure or subplots "
2413                                  "with the constrained_layout=True kwarg.")
2414             return
2415         w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()
2416         # convert to unit-relative lengths
2417         fig = self
2418         width, height = fig.get_size_inches()
2419         w_pad = w_pad / width
2420         h_pad = h_pad / height
2421         if renderer is None:
2422             renderer = layoutbox.get_renderer(fig)
2423         do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)
2424 
2425     def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,
2426                      rect=None):
2427         """
2428         Automatically adjust subplot parameters to give specified padding.
2429 
2430         To exclude an artist on the axes from the bounding box calculation
2431         that determines the subplot parameters (i.e. legend, or annotation),
2432         then set `a.set_in_layout(False)` for that artist.
2433 
2434         Parameters
2435         ----------
2436         renderer : subclass of `~.backend_bases.RendererBase`, optional
2437             Defaults to the renderer for the figure.
2438 
2439         pad : float, optional
2440             Padding between the figure edge and the edges of subplots,
2441             as a fraction of the font size.
2442         h_pad, w_pad : float, optional
2443             Padding (height/width) between edges of adjacent subplots,
2444             as a fraction of the font size.  Defaults to *pad*.
2445         rect : tuple (left, bottom, right, top), optional
2446             A rectangle (left, bottom, right, top) in the normalized
2447             figure coordinate that the whole subplots area (including
2448             labels) will fit into. Default is (0, 0, 1, 1).
2449 
2450         See Also
2451         --------
2452         .Figure.set_tight_layout
2453         .pyplot.tight_layout
2454         """
2455 
2456         from .tight_layout import (
2457             get_renderer, get_subplotspec_list, get_tight_layout_figure)
2458 
2459         subplotspec_list = get_subplotspec_list(self.axes)
2460         if None in subplotspec_list:
2461             cbook._warn_external("This figure includes Axes that are not "
2462                                  "compatible with tight_layout, so results "
2463                                  "might be incorrect.")
2464 
2465         if renderer is None:
2466             renderer = get_renderer(self)
2467 
2468         kwargs = get_tight_layout_figure(
2469             self, self.axes, subplotspec_list, renderer,
2470             pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2471         if kwargs:
2472             self.subplots_adjust(**kwargs)
2473 
2474     def align_xlabels(self, axs=None):
2475         """
2476         Align the ylabels of subplots in the same subplot column if label
2477         alignment is being done automatically (i.e. the label position is
2478         not manually set).
2479 
2480         Alignment persists for draw events after this is called.
2481 
2482         If a label is on the bottom, it is aligned with labels on axes that
2483         also have their label on the bottom and that have the same
2484         bottom-most subplot row.  If the label is on the top,
2485         it is aligned with labels on axes with the same top-most row.
2486 
2487         Parameters
2488         ----------
2489         axs : list of `~matplotlib.axes.Axes`
2490             Optional list of (or ndarray) `~matplotlib.axes.Axes`
2491             to align the xlabels.
2492             Default is to align all axes on the figure.
2493 
2494         See Also
2495         --------
2496         matplotlib.figure.Figure.align_ylabels
2497 
2498         matplotlib.figure.Figure.align_labels
2499 
2500         Notes
2501         -----
2502         This assumes that ``axs`` are from the same `.GridSpec`, so that
2503         their `.SubplotSpec` positions correspond to figure positions.
2504 
2505         Examples
2506         --------
2507         Example with rotated xtick labels::
2508 
2509             fig, axs = plt.subplots(1, 2)
2510             for tick in axs[0].get_xticklabels():
2511                 tick.set_rotation(55)
2512             axs[0].set_xlabel('XLabel 0')
2513             axs[1].set_xlabel('XLabel 1')
2514             fig.align_xlabels()
2515 
2516         """
2517 
2518         if axs is None:
2519             axs = self.axes
2520         axs = np.asarray(axs).ravel()
2521         for ax in axs:
2522             _log.debug(' Working on: %s', ax.get_xlabel())
2523             ss = ax.get_subplotspec()
2524             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2525             labpo = ax.xaxis.get_label_position()  # top or bottom
2526 
2527             # loop through other axes, and search for label positions
2528             # that are same as this one, and that share the appropriate
2529             # row number.
2530             #  Add to a grouper associated with each axes of sibblings.
2531             # This list is inspected in `axis.draw` by
2532             # `axis._update_label_position`.
2533             for axc in axs:
2534                 if axc.xaxis.get_label_position() == labpo:
2535                     ss = axc.get_subplotspec()
2536                     nrows, ncols, rowc0, rowc1, colc, col1 = \
2537                             ss.get_rows_columns()
2538                     if (labpo == 'bottom' and rowc1 == row1 or
2539                         labpo == 'top' and rowc0 == row0):
2540                         # grouper for groups of xlabels to align
2541                         self._align_xlabel_grp.join(ax, axc)
2542 
2543     def align_ylabels(self, axs=None):
2544         """
2545         Align the ylabels of subplots in the same subplot column if label
2546         alignment is being done automatically (i.e. the label position is
2547         not manually set).
2548 
2549         Alignment persists for draw events after this is called.
2550 
2551         If a label is on the left, it is aligned with labels on axes that
2552         also have their label on the left and that have the same
2553         left-most subplot column.  If the label is on the right,
2554         it is aligned with labels on axes with the same right-most column.
2555 
2556         Parameters
2557         ----------
2558         axs : list of `~matplotlib.axes.Axes`
2559             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2560             to align the ylabels.
2561             Default is to align all axes on the figure.
2562 
2563         See Also
2564         --------
2565         matplotlib.figure.Figure.align_xlabels
2566 
2567         matplotlib.figure.Figure.align_labels
2568 
2569         Notes
2570         -----
2571         This assumes that ``axs`` are from the same `.GridSpec`, so that
2572         their `.SubplotSpec` positions correspond to figure positions.
2573 
2574         Examples
2575         --------
2576         Example with large yticks labels::
2577 
2578             fig, axs = plt.subplots(2, 1)
2579             axs[0].plot(np.arange(0, 1000, 50))
2580             axs[0].set_ylabel('YLabel 0')
2581             axs[1].set_ylabel('YLabel 1')
2582             fig.align_ylabels()
2583 
2584         """
2585 
2586         if axs is None:
2587             axs = self.axes
2588         axs = np.asarray(axs).ravel()
2589         for ax in axs:
2590             _log.debug(' Working on: %s', ax.get_ylabel())
2591             ss = ax.get_subplotspec()
2592             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2593             labpo = ax.yaxis.get_label_position()  # left or right
2594             # loop through other axes, and search for label positions
2595             # that are same as this one, and that share the appropriate
2596             # column number.
2597             # Add to a list associated with each axes of sibblings.
2598             # This list is inspected in `axis.draw` by
2599             # `axis._update_label_position`.
2600             for axc in axs:
2601                 if axc != ax:
2602                     if axc.yaxis.get_label_position() == labpo:
2603                         ss = axc.get_subplotspec()
2604                         nrows, ncols, row0, row1, colc0, colc1 = \
2605                                 ss.get_rows_columns()
2606                         if (labpo == 'left' and colc0 == col0 or
2607                             labpo == 'right' and colc1 == col1):
2608                             # grouper for groups of ylabels to align
2609                             self._align_ylabel_grp.join(ax, axc)
2610 
2611     def align_labels(self, axs=None):
2612         """
2613         Align the xlabels and ylabels of subplots with the same subplots
2614         row or column (respectively) if label alignment is being
2615         done automatically (i.e. the label position is not manually set).
2616 
2617         Alignment persists for draw events after this is called.
2618 
2619         Parameters
2620         ----------
2621         axs : list of `~matplotlib.axes.Axes`
2622             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2623             to align the labels.
2624             Default is to align all axes on the figure.
2625 
2626         See Also
2627         --------
2628         matplotlib.figure.Figure.align_xlabels
2629 
2630         matplotlib.figure.Figure.align_ylabels
2631         """
2632         self.align_xlabels(axs=axs)
2633         self.align_ylabels(axs=axs)
2634 
2635     def add_gridspec(self, nrows, ncols, **kwargs):
2636         """
2637         Return a `.GridSpec` that has this figure as a parent.  This allows
2638         complex layout of axes in the figure.
2639 
2640         Parameters
2641         ----------
2642         nrows : int
2643             Number of rows in grid.
2644 
2645         ncols : int
2646             Number or columns in grid.
2647 
2648         Returns
2649         -------
2650         gridspec : `.GridSpec`
2651 
2652         Other Parameters
2653         ----------------
2654         **kwargs
2655             Keyword arguments are passed to `.GridSpec`.
2656 
2657         See Also
2658         --------
2659         matplotlib.pyplot.subplots
2660 
2661         Examples
2662         --------
2663         Adding a subplot that spans two rows::
2664 
2665             fig = plt.figure()
2666             gs = fig.add_gridspec(2, 2)
2667             ax1 = fig.add_subplot(gs[0, 0])
2668             ax2 = fig.add_subplot(gs[1, 0])
2669             # spans two rows:
2670             ax3 = fig.add_subplot(gs[:, 1])
2671 
2672         """
2673 
2674         _ = kwargs.pop('figure', None)  # pop in case user has added this...
2675         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
2676         self._gridspecs.append(gs)
2677         return gs
2678 
2679 
2680 def figaspect(arg):
2681     """
2682     Calculate the width and height for a figure with a specified aspect ratio.
2683 
2684     While the height is taken from :rc:`figure.figsize`, the width is
2685     adjusted to match the desired aspect ratio. Additionally, it is ensured
2686     that the width is in the range [4., 16.] and the height is in the range
2687     [2., 16.]. If necessary, the default height is adjusted to ensure this.
2688 
2689     Parameters
2690     ----------
2691     arg : scalar or 2d array
2692         If a scalar, this defines the aspect ratio (i.e. the ratio height /
2693         width).
2694         In case of an array the aspect ratio is number of rows / number of
2695         columns, so that the array could be fitted in the figure undistorted.
2696 
2697     Returns
2698     -------
2699     width, height
2700         The figure size in inches.
2701 
2702     Notes
2703     -----
2704     If you want to create an axes within the figure, that still preserves the
2705     aspect ratio, be sure to create it with equal width and height. See
2706     examples below.
2707 
2708     Thanks to Fernando Perez for this function.
2709 
2710     Examples
2711     --------
2712     Make a figure twice as tall as it is wide::
2713 
2714         w, h = figaspect(2.)
2715         fig = Figure(figsize=(w, h))
2716         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
2717         ax.imshow(A, **kwargs)
2718 
2719     Make a figure with the proper aspect for an array::
2720 
2721         A = rand(5,3)
2722         w, h = figaspect(A)
2723         fig = Figure(figsize=(w, h))
2724         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
2725         ax.imshow(A, **kwargs)
2726     """
2727 
2728     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)
2729 
2730     # min/max sizes to respect when autoscaling.  If John likes the idea, they
2731     # could become rc parameters, for now they're hardwired.
2732     figsize_min = np.array((4.0, 2.0))  # min length for width/height
2733     figsize_max = np.array((16.0, 16.0))  # max length for width/height
2734 
2735     # Extract the aspect ratio of the array
2736     if isarray:
2737         nr, nc = arg.shape[:2]
2738         arr_ratio = nr / nc
2739     else:
2740         arr_ratio = arg
2741 
2742     # Height of user figure defaults
2743     fig_height = rcParams['figure.figsize'][1]
2744 
2745     # New size for the figure, keeping the aspect ratio of the caller
2746     newsize = np.array((fig_height / arr_ratio, fig_height))
2747 
2748     # Sanity checks, don't drop either dimension below figsize_min
2749     newsize /= min(1.0, *(newsize / figsize_min))
2750 
2751     # Avoid humongous windows as well
2752     newsize /= max(1.0, *(newsize / figsize_max))
2753 
2754     # Finally, if we have a really funky aspect ratio, break it but respect
2755     # the min/max dimensions (we don't want figures 10 feet tall!)
2756     newsize = np.clip(newsize, figsize_min, figsize_max)
2757     return newsize
2758 
2759 docstring.interpd.update(Figure=martist.kwdoc(Figure))

</code><intended_behavior>Ensure that when the `figsize` parameter is processed, there is explicit validation to check that both width and height values are greater than zero. If a value of zero is encountered, raise a ValueError with a clear message indicating that figure dimensions must be positive. This preserves the functionality of figure creation and saving while preventing the situation that leads to a crash due to invalid dimensions.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 a MATLAB-like way of plotting.
7 
8 pyplot is mainly intended for interactive plots and simple cases of
9 programmatic plot generation::
10 
11     import numpy as np
12     import matplotlib.pyplot as plt
13 
14     x = np.arange(0, 5, 0.1)
15     y = np.sin(x)
16     plt.plot(x, y)
17 
18 The object-oriented API is recommended for more complex plots.
19 """
20 
21 import functools
22 import importlib
23 import inspect
24 import logging
25 from numbers import Number
26 import re
27 import sys
28 import time
29 
30 from cycler import cycler
31 import matplotlib
32 import matplotlib.colorbar
33 import matplotlib.image
34 from matplotlib import rcsetup, style
35 from matplotlib import _pylab_helpers, interactive
36 from matplotlib import cbook
37 from matplotlib.cbook import dedent, deprecated, silent_list, warn_deprecated
38 from matplotlib import docstring
39 from matplotlib.backend_bases import FigureCanvasBase
40 from matplotlib.figure import Figure, figaspect
41 from matplotlib.gridspec import GridSpec
42 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
43 from matplotlib import rc_context
44 from matplotlib.rcsetup import interactive_bk as _interactive_bk
45 from matplotlib.artist import getp, get, Artist
46 from matplotlib.artist import setp as _setp
47 from matplotlib.axes import Axes, Subplot
48 from matplotlib.projections import PolarAxes
49 from matplotlib import mlab  # for _csv2rec, detrend_none, window_hanning
50 from matplotlib.scale import get_scale_docs, get_scale_names
51 
52 from matplotlib import cm
53 from matplotlib.cm import get_cmap, register_cmap
54 
55 import numpy as np
56 
57 # We may not need the following imports here:
58 from matplotlib.colors import Normalize
59 from matplotlib.lines import Line2D
60 from matplotlib.text import Text, Annotation
61 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
62 from matplotlib.widgets import SubplotTool, Button, Slider, Widget
63 
64 from .ticker import TickHelper, Formatter, FixedFormatter, NullFormatter,\
65            FuncFormatter, FormatStrFormatter, ScalarFormatter,\
66            LogFormatter, LogFormatterExponent, LogFormatterMathtext,\
67            Locator, IndexLocator, FixedLocator, NullLocator,\
68            LinearLocator, LogLocator, AutoLocator, MultipleLocator,\
69            MaxNLocator
70 from matplotlib.backends import pylab_setup, _get_running_interactive_framework
71 
72 _log = logging.getLogger(__name__)
73 
74 
75 ## Global ##
76 
77 
78 _IP_REGISTERED = None
79 _INSTALL_FIG_OBSERVER = False
80 
81 
82 def install_repl_displayhook():
83     """
84     Install a repl display hook so that any stale figure are automatically
85     redrawn when control is returned to the repl.
86 
87     This works both with IPython and with vanilla python shells.
88     """
89     global _IP_REGISTERED
90     global _INSTALL_FIG_OBSERVER
91 
92     class _NotIPython(Exception):
93         pass
94 
95     # see if we have IPython hooks around, if use them
96 
97     try:
98         if 'IPython' in sys.modules:
99             from IPython import get_ipython
100             ip = get_ipython()
101             if ip is None:
102                 raise _NotIPython()
103 
104             if _IP_REGISTERED:
105                 return
106 
107             def post_execute():
108                 if matplotlib.is_interactive():
109                     draw_all()
110 
111             # IPython >= 2
112             try:
113                 ip.events.register('post_execute', post_execute)
114             except AttributeError:
115                 # IPython 1.x
116                 ip.register_post_execute(post_execute)
117 
118             _IP_REGISTERED = post_execute
119             _INSTALL_FIG_OBSERVER = False
120 
121             # trigger IPython's eventloop integration, if available
122             from IPython.core.pylabtools import backend2gui
123 
124             ipython_gui_name = backend2gui.get(get_backend())
125             if ipython_gui_name:
126                 ip.enable_gui(ipython_gui_name)
127         else:
128             _INSTALL_FIG_OBSERVER = True
129 
130     # import failed or ipython is not running
131     except (ImportError, _NotIPython):
132         _INSTALL_FIG_OBSERVER = True
133 
134 
135 def uninstall_repl_displayhook():
136     """
137     Uninstall the matplotlib display hook.
138 
139     .. warning
140 
141        Need IPython >= 2 for this to work.  For IPython < 2 will raise a
142        ``NotImplementedError``
143 
144     .. warning
145 
146        If you are using vanilla python and have installed another
147        display hook this will reset ``sys.displayhook`` to what ever
148        function was there when matplotlib installed it's displayhook,
149        possibly discarding your changes.
150     """
151     global _IP_REGISTERED
152     global _INSTALL_FIG_OBSERVER
153     if _IP_REGISTERED:
154         from IPython import get_ipython
155         ip = get_ipython()
156         try:
157             ip.events.unregister('post_execute', _IP_REGISTERED)
158         except AttributeError:
159             raise NotImplementedError("Can not unregister events "
160                                       "in IPython < 2.0")
161         _IP_REGISTERED = None
162 
163     if _INSTALL_FIG_OBSERVER:
164         _INSTALL_FIG_OBSERVER = False
165 
166 
167 draw_all = _pylab_helpers.Gcf.draw_all
168 
169 
170 @functools.wraps(matplotlib.set_loglevel)
171 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
172     return matplotlib.set_loglevel(*args, **kwargs)
173 
174 
175 @docstring.copy(Artist.findobj)
176 def findobj(o=None, match=None, include_self=True):
177     if o is None:
178         o = gcf()
179     return o.findobj(match, include_self=include_self)
180 
181 
182 def switch_backend(newbackend):
183     """
184     Close all open figures and set the Matplotlib backend.
185 
186     The argument is case-insensitive.  Switching to an interactive backend is
187     possible only if no event loop for another interactive backend has started.
188     Switching to and from non-interactive backends is always possible.
189 
190     Parameters
191     ----------
192     newbackend : str
193         The name of the backend to use.
194     """
195     close("all")
196 
197     if newbackend is rcsetup._auto_backend_sentinel:
198         # Don't try to fallback on the cairo-based backends as they each have
199         # an additional dependency (pycairo) over the agg-based backend, and
200         # are of worse quality.
201         for candidate in ["macosx", "qt5agg", "qt4agg", "gtk3agg", "tkagg",
202                           "wxagg", "agg"]:
203             try:
204                 switch_backend(candidate)
205             except ImportError:
206                 continue
207             else:
208                 rcParamsOrig['backend'] = candidate
209                 return
210 
211     backend_name = (
212         newbackend[9:] if newbackend.startswith("module://")
213         else "matplotlib.backends.backend_{}".format(newbackend.lower()))
214 
215     backend_mod = importlib.import_module(backend_name)
216     Backend = type(
217         "Backend", (matplotlib.backends._Backend,), vars(backend_mod))
218     _log.debug("Loaded backend %s version %s.",
219                newbackend, Backend.backend_version)
220 
221     required_framework = Backend.required_interactive_framework
222     if required_framework is not None:
223         current_framework = \
224             matplotlib.backends._get_running_interactive_framework()
225         if (current_framework and required_framework
226                 and current_framework != required_framework):
227             raise ImportError(
228                 "Cannot load backend {!r} which requires the {!r} interactive "
229                 "framework, as {!r} is currently running".format(
230                     newbackend, required_framework, current_framework))
231 
232     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
233 
234     global _backend_mod, new_figure_manager, draw_if_interactive, _show
235     _backend_mod = backend_mod
236     new_figure_manager = Backend.new_figure_manager
237     draw_if_interactive = Backend.draw_if_interactive
238     _show = Backend.show
239 
240     # Need to keep a global reference to the backend for compatibility reasons.
241     # See https://github.com/matplotlib/matplotlib/issues/6092
242     matplotlib.backends.backend = newbackend
243 
244 
245 def show(*args, **kw):
246     """
247     Display a figure.
248     When running in ipython with its pylab mode, display all
249     figures and return to the ipython prompt.
250 
251     In non-interactive mode, display all figures and block until
252     the figures have been closed; in interactive mode it has no
253     effect unless figures were created prior to a change from
254     non-interactive to interactive mode (not recommended).  In
255     that case it displays the figures but does not block.
256 
257     A single experimental keyword argument, *block*, may be
258     set to True or False to override the blocking behavior
259     described above.
260     """
261     global _show
262     return _show(*args, **kw)
263 
264 
265 def isinteractive():
266     """Return the status of interactive mode."""
267     return matplotlib.is_interactive()
268 
269 
270 def ioff():
271     """Turn the interactive mode off."""
272     matplotlib.interactive(False)
273     uninstall_repl_displayhook()
274 
275 
276 def ion():
277     """Turn the interactive mode on."""
278     matplotlib.interactive(True)
279     install_repl_displayhook()
280 
281 
282 def pause(interval):
283     """
284     Pause for *interval* seconds.
285 
286     If there is an active figure, it will be updated and displayed before the
287     pause, and the GUI event loop (if any) will run during the pause.
288 
289     This can be used for crude animation.  For more complex animation, see
290     :mod:`matplotlib.animation`.
291 
292     Notes
293     -----
294     This function is experimental; its behavior may be changed or extended in a
295     future release.
296     """
297     manager = _pylab_helpers.Gcf.get_active()
298     if manager is not None:
299         canvas = manager.canvas
300         if canvas.figure.stale:
301             canvas.draw_idle()
302         show(block=False)
303         canvas.start_event_loop(interval)
304     else:
305         time.sleep(interval)
306 
307 
308 @docstring.copy(matplotlib.rc)
309 def rc(group, **kwargs):
310     matplotlib.rc(group, **kwargs)
311 
312 
313 @docstring.copy(matplotlib.rc_context)
314 def rc_context(rc=None, fname=None):
315     return matplotlib.rc_context(rc, fname)
316 
317 
318 @docstring.copy(matplotlib.rcdefaults)
319 def rcdefaults():
320     matplotlib.rcdefaults()
321     if matplotlib.is_interactive():
322         draw_all()
323 
324 
325 ## Current image ##
326 
327 
328 def gci():
329     """
330     Get the current colorable artist.  Specifically, returns the
331     current :class:`~matplotlib.cm.ScalarMappable` instance (image or
332     patch collection), or *None* if no images or patch collections
333     have been defined.  The commands :func:`~matplotlib.pyplot.imshow`
334     and :func:`~matplotlib.pyplot.figimage` create
335     :class:`~matplotlib.image.Image` instances, and the commands
336     :func:`~matplotlib.pyplot.pcolor` and
337     :func:`~matplotlib.pyplot.scatter` create
338     :class:`~matplotlib.collections.Collection` instances.  The
339     current image is an attribute of the current axes, or the nearest
340     earlier axes in the current figure that contains an image.
341     """
342     return gcf()._gci()
343 
344 
345 ## Any Artist ##
346 
347 
348 # (getp is simply imported)
349 @docstring.copy(_setp)
350 def setp(obj, *args, **kwargs):
351     return _setp(obj, *args, **kwargs)
352 
353 
354 def xkcd(scale=1, length=100, randomness=2):
355     """
356     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.
357     This will only have effect on things drawn after this function is
358     called.
359 
360     For best results, the "Humor Sans" font should be installed: it is
361     not included with matplotlib.
362 
363     Parameters
364     ----------
365     scale : float, optional
366         The amplitude of the wiggle perpendicular to the source line.
367     length : float, optional
368         The length of the wiggle along the line.
369     randomness : float, optional
370         The scale factor by which the length is shrunken or expanded.
371 
372     Notes
373     -----
374     This function works by a number of rcParams, so it will probably
375     override others you have set before.
376 
377     If you want the effects of this function to be temporary, it can
378     be used as a context manager, for example::
379 
380         with plt.xkcd():
381             # This figure will be in XKCD-style
382             fig1 = plt.figure()
383             # ...
384 
385         # This figure will be in regular style
386         fig2 = plt.figure()
387     """
388     if rcParams['text.usetex']:
389         raise RuntimeError(
390             "xkcd mode is not compatible with text.usetex = True")
391 
392     from matplotlib import patheffects
393     return rc_context({
394         'font.family': ['xkcd', 'Humor Sans', 'Comic Sans MS'],
395         'font.size': 14.0,
396         'path.sketch': (scale, length, randomness),
397         'path.effects': [patheffects.withStroke(linewidth=4, foreground="w")],
398         'axes.linewidth': 1.5,
399         'lines.linewidth': 2.0,
400         'figure.facecolor': 'white',
401         'grid.linewidth': 0.0,
402         'axes.grid': False,
403         'axes.unicode_minus': False,
404         'axes.edgecolor': 'black',
405         'xtick.major.size': 8,
406         'xtick.major.width': 3,
407         'ytick.major.size': 8,
408         'ytick.major.width': 3,
409     })
410 
411 
412 ## Figures ##
413 
414 def figure(num=None,  # autoincrement if None, else integer from 1-N
415            figsize=None,  # defaults to rc figure.figsize
416            dpi=None,  # defaults to rc figure.dpi
417            facecolor=None,  # defaults to rc figure.facecolor
418            edgecolor=None,  # defaults to rc figure.edgecolor
419            frameon=True,
420            FigureClass=Figure,
421            clear=False,
422            **kwargs
423            ):
424     """
425     Create a new figure.
426 
427     Parameters
428     ----------
429 
430     num : integer or string, optional, default: None
431         If not provided, a new figure will be created, and the figure number
432         will be incremented. The figure objects holds this number in a `number`
433         attribute.
434         If num is provided, and a figure with this id already exists, make
435         it active, and returns a reference to it. If this figure does not
436         exists, create it and returns it.
437         If num is a string, the window title will be set to this figure's
438         `num`.
439 
440     figsize : (float, float), optional, default: None
441         width, height in inches. If not provided, defaults to
442         :rc:`figure.figsize` = ``[6.4, 4.8]``.
443 
444     dpi : integer, optional, default: None
445         resolution of the figure. If not provided, defaults to
446         :rc:`figure.dpi` = ``100``.
447 
448     facecolor : color spec
449         the background color. If not provided, defaults to
450         :rc:`figure.facecolor` = ``'w'``.
451 
452     edgecolor : color spec
453         the border color. If not provided, defaults to
454         :rc:`figure.edgecolor` = ``'w'``.
455 
456     frameon : bool, optional, default: True
457         If False, suppress drawing the figure frame.
458 
459     FigureClass : subclass of `~matplotlib.figure.Figure`
460         Optionally use a custom `.Figure` instance.
461 
462     clear : bool, optional, default: False
463         If True and the figure already exists, then it is cleared.
464 
465     Returns
466     -------
467     figure : `~matplotlib.figure.Figure`
468         The `.Figure` instance returned will also be passed to
469         new_figure_manager in the backends, which allows to hook custom
470         `.Figure` classes into the pyplot interface. Additional kwargs will be
471         passed to the `.Figure` init function.
472 
473     Notes
474     -----
475     If you are creating many figures, make sure you explicitly call
476     :func:`.pyplot.close` on the figures you are not using, because this will
477     enable pyplot to properly clean up the memory.
478 
479     `~matplotlib.rcParams` defines the default values, which can be modified
480     in the matplotlibrc file.
481     """
482 
483     if figsize is None:
484         figsize = rcParams['figure.figsize']
485     if dpi is None:
486         dpi = rcParams['figure.dpi']
487     if facecolor is None:
488         facecolor = rcParams['figure.facecolor']
489     if edgecolor is None:
490         edgecolor = rcParams['figure.edgecolor']
491 
492     allnums = get_fignums()
493     next_num = max(allnums) + 1 if allnums else 1
494     figLabel = ''
495     if num is None:
496         num = next_num
497     elif isinstance(num, str):
498         figLabel = num
499         allLabels = get_figlabels()
500         if figLabel not in allLabels:
501             if figLabel == 'all':
502                 cbook._warn_external(
503                     "close('all') closes all existing figures")
504             num = next_num
505         else:
506             inum = allLabels.index(figLabel)
507             num = allnums[inum]
508     else:
509         num = int(num)  # crude validation of num argument
510 
511     figManager = _pylab_helpers.Gcf.get_fig_manager(num)
512     if figManager is None:
513         max_open_warning = rcParams['figure.max_open_warning']
514 
515         if len(allnums) >= max_open_warning >= 1:
516             cbook._warn_external(
517                 "More than %d figures have been opened. Figures "
518                 "created through the pyplot interface "
519                 "(`matplotlib.pyplot.figure`) are retained until "
520                 "explicitly closed and may consume too much memory. "
521                 "(To control this warning, see the rcParam "
522                 "`figure.max_open_warning`)." %
523                 max_open_warning, RuntimeWarning)
524 
525         if get_backend().lower() == 'ps':
526             dpi = 72
527 
528         figManager = new_figure_manager(num, figsize=figsize,
529                                         dpi=dpi,
530                                         facecolor=facecolor,
531                                         edgecolor=edgecolor,
532                                         frameon=frameon,
533                                         FigureClass=FigureClass,
534                                         **kwargs)
535 
536         if figLabel:
537             figManager.set_window_title(figLabel)
538             figManager.canvas.figure.set_label(figLabel)
539 
540         # make this figure current on button press event
541         def make_active(event):
542             _pylab_helpers.Gcf.set_active(figManager)
543 
544         cid = figManager.canvas.mpl_connect('button_press_event', make_active)
545         figManager._cidgcf = cid
546 
547         _pylab_helpers.Gcf.set_active(figManager)
548         fig = figManager.canvas.figure
549         fig.number = num
550 
551         # make sure backends (inline) that we don't ship that expect this
552         # to be called in plotting commands to make the figure call show
553         # still work.  There is probably a better way to do this in the
554         # FigureManager base class.
555         if matplotlib.is_interactive():
556             draw_if_interactive()
557 
558         if _INSTALL_FIG_OBSERVER:
559             fig.stale_callback = _auto_draw_if_interactive
560 
561     if clear:
562         figManager.canvas.figure.clear()
563 
564     return figManager.canvas.figure
565 
566 
567 def _auto_draw_if_interactive(fig, val):
568     """
569     This is an internal helper function for making sure that auto-redrawing
570     works as intended in the plain python repl.
571 
572     Parameters
573     ----------
574     fig : Figure
575         A figure object which is assumed to be associated with a canvas
576     """
577     if val and matplotlib.is_interactive() and not fig.canvas.is_saving():
578         fig.canvas.draw_idle()
579 
580 
581 def gcf():
582     """Get a reference to the current figure."""
583     figManager = _pylab_helpers.Gcf.get_active()
584     if figManager is not None:
585         return figManager.canvas.figure
586     else:
587         return figure()
588 
589 
590 def fignum_exists(num):
591     """Return whether the figure with the given id exists."""
592     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
593 
594 
595 def get_fignums():
596     """Return a list of existing figure numbers."""
597     return sorted(_pylab_helpers.Gcf.figs)
598 
599 
600 def get_figlabels():
601     """Return a list of existing figure labels."""
602     figManagers = _pylab_helpers.Gcf.get_all_fig_managers()
603     figManagers.sort(key=lambda m: m.num)
604     return [m.canvas.figure.get_label() for m in figManagers]
605 
606 
607 def get_current_fig_manager():
608     """
609     Return the figure manager of the active figure.
610 
611     If there is currently no active figure, a new one is created.
612     """
613     figManager = _pylab_helpers.Gcf.get_active()
614     if figManager is None:
615         gcf()  # creates an active figure as a side effect
616         figManager = _pylab_helpers.Gcf.get_active()
617     return figManager
618 
619 
620 @docstring.copy(FigureCanvasBase.mpl_connect)
621 def connect(s, func):
622     return get_current_fig_manager().canvas.mpl_connect(s, func)
623 
624 
625 @docstring.copy(FigureCanvasBase.mpl_disconnect)
626 def disconnect(cid):
627     return get_current_fig_manager().canvas.mpl_disconnect(cid)
628 
629 
630 def close(fig=None):
631     """
632     Close a figure window.
633 
634     Parameters
635     ----------
636     fig : None or int or str or `.Figure`
637         The figure to close. There are a number of ways to specify this:
638 
639         - *None*: the current figure
640         - `.Figure`: the given `.Figure` instance
641         - ``int``: a figure number
642         - ``str``: a figure name
643         - 'all': all figures
644 
645     """
646     if fig is None:
647         figManager = _pylab_helpers.Gcf.get_active()
648         if figManager is None:
649             return
650         else:
651             _pylab_helpers.Gcf.destroy(figManager.num)
652     elif fig == 'all':
653         _pylab_helpers.Gcf.destroy_all()
654     elif isinstance(fig, int):
655         _pylab_helpers.Gcf.destroy(fig)
656     elif hasattr(fig, 'int'):
657         # if we are dealing with a type UUID, we
658         # can use its integer representation
659         _pylab_helpers.Gcf.destroy(fig.int)
660     elif isinstance(fig, str):
661         allLabels = get_figlabels()
662         if fig in allLabels:
663             num = get_fignums()[allLabels.index(fig)]
664             _pylab_helpers.Gcf.destroy(num)
665     elif isinstance(fig, Figure):
666         _pylab_helpers.Gcf.destroy_fig(fig)
667     else:
668         raise TypeError("close() argument must be a Figure, an int, a string, "
669                         "or None, not '%s'")
670 
671 
672 def clf():
673     """Clear the current figure."""
674     gcf().clf()
675 
676 
677 def draw():
678     """Redraw the current figure.
679 
680     This is used to update a figure that has been altered, but not
681     automatically re-drawn.  If interactive mode is on (:func:`.ion()`), this
682     should be only rarely needed, but there may be ways to modify the state of
683     a figure without marking it as `stale`.  Please report these cases as
684     bugs.
685 
686     A more object-oriented alternative, given any
687     :class:`~matplotlib.figure.Figure` instance, :attr:`fig`, that
688     was created using a :mod:`~matplotlib.pyplot` function, is::
689 
690         fig.canvas.draw_idle()
691     """
692     get_current_fig_manager().canvas.draw_idle()
693 
694 
695 @docstring.copy(Figure.savefig)
696 def savefig(*args, **kwargs):
697     fig = gcf()
698     res = fig.savefig(*args, **kwargs)
699     fig.canvas.draw_idle()   # need this if 'transparent=True' to reset colors
700     return res
701 
702 
703 ## Putting things in figures ##
704 
705 
706 def figlegend(*args, **kwargs):
707     return gcf().legend(*args, **kwargs)
708 if Figure.legend.__doc__:
709     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
710 
711 
712 ## Axes ##
713 
714 @docstring.dedent_interpd
715 def axes(arg=None, **kwargs):
716     """
717     Add an axes to the current figure and make it the current axes.
718 
719     Call signatures::
720 
721         plt.axes()
722         plt.axes(rect, projection=None, polar=False, **kwargs)
723         plt.axes(ax)
724 
725     Parameters
726     ----------
727     arg : { None, 4-tuple, Axes }
728         The exact behavior of this function depends on the type:
729 
730         - *None*: A new full window axes is added using
731           ``subplot(111, **kwargs)``
732         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
733           A new axes is added with dimensions *rect* in normalized
734           (0, 1) units using `~.Figure.add_axes` on the current figure.
735         - `~.axes.Axes`: This is equivalent to `.pyplot.sca`.
736           It sets the current axes to *arg*. Note: This implicitly
737           changes the current figure to the parent of *arg*.
738 
739           .. note:: The use of an `.axes.Axes` as an argument is deprecated
740                     and will be removed in v3.0. Please use `.pyplot.sca`
741                     instead.
742 
743     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
744 'polar', 'rectilinear', str}, optional
745         The projection type of the `~.axes.Axes`. *str* is the name of
746         a costum projection, see `~matplotlib.projections`. The default
747         None results in a 'rectilinear' projection.
748 
749     polar : boolean, optional
750         If True, equivalent to projection='polar'.
751 
752     sharex, sharey : `~.axes.Axes`, optional
753         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
754         The axis will have the same limits, ticks, and scale as the axis
755         of the shared axes.
756 
757 
758     label : str
759         A label for the returned axes.
760 
761     Other Parameters
762     ----------------
763     **kwargs
764         This method also takes the keyword arguments for
765         the returned axes class. The keyword arguments for the
766         rectilinear axes class `~.axes.Axes` can be found in
767         the following table but there might also be other keyword
768         arguments if another projection is used, see the actual axes
769         class.
770         %(Axes)s
771 
772     Returns
773     -------
774     axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
775         The returned axes class depends on the projection used. It is
776         `~.axes.Axes` if rectilinear projection are used and
777         `.projections.polar.PolarAxes` if polar projection
778         are used.
779 
780     Notes
781     -----
782     If the figure already has a axes with key (*args*,
783     *kwargs*) then it will simply make that axes current and
784     return it.  This behavior is deprecated. Meanwhile, if you do
785     not want this behavior (i.e., you want to force the creation of a
786     new axes), you must use a unique set of args and kwargs.  The axes
787     *label* attribute has been exposed for this purpose: if you want
788     two axes that are otherwise identical to be added to the figure,
789     make sure you give them unique labels.
790 
791     See Also
792     --------
793     .Figure.add_axes
794     .pyplot.subplot
795     .Figure.add_subplot
796     .Figure.subplots
797     .pyplot.subplots
798 
799     Examples
800     --------
801     ::
802 
803         # Creating a new full window axes
804         plt.axes()
805 
806         # Creating a new axes with specified dimensions and some kwargs
807         plt.axes((left, bottom, width, height), facecolor='w')
808     """
809 
810     if arg is None:
811         return subplot(111, **kwargs)
812     else:
813         return gcf().add_axes(arg, **kwargs)
814 
815 
816 def delaxes(ax=None):
817     """
818     Remove the `Axes` *ax* (defaulting to the current axes) from its figure.
819 
820     A KeyError is raised if the axes doesn't exist.
821     """
822     if ax is None:
823         ax = gca()
824     ax.figure.delaxes(ax)
825 
826 
827 def sca(ax):
828     """
829     Set the current Axes instance to *ax*.
830 
831     The current Figure is updated to the parent of *ax*.
832     """
833     managers = _pylab_helpers.Gcf.get_all_fig_managers()
834     for m in managers:
835         if ax in m.canvas.figure.axes:
836             _pylab_helpers.Gcf.set_active(m)
837             m.canvas.figure.sca(ax)
838             return
839     raise ValueError("Axes instance argument was not found in a figure")
840 
841 
842 def gca(**kwargs):
843     """
844     Get the current :class:`~matplotlib.axes.Axes` instance on the
845     current figure matching the given keyword args, or create one.
846 
847     Examples
848     --------
849     To get the current polar axes on the current figure::
850 
851         plt.gca(projection='polar')
852 
853     If the current axes doesn't exist, or isn't a polar one, the appropriate
854     axes will be created and then returned.
855 
856     See Also
857     --------
858     matplotlib.figure.Figure.gca : The figure's gca method.
859     """
860     return gcf().gca(**kwargs)
861 
862 
863 ## More ways of creating axes ##
864 
865 @docstring.dedent_interpd
866 def subplot(*args, **kwargs):
867     """
868     Add a subplot to the current figure.
869 
870     Wrapper of `.Figure.add_subplot` with a difference in behavior
871     explained in the notes section.
872 
873     Call signatures::
874 
875        subplot(nrows, ncols, index, **kwargs)
876        subplot(pos, **kwargs)
877        subplot(ax)
878 
879     Parameters
880     ----------
881     *args
882         Either a 3-digit integer or three separate integers
883         describing the position of the subplot. If the three
884         integers are *nrows*, *ncols*, and *index* in order, the
885         subplot will take the *index* position on a grid with *nrows*
886         rows and *ncols* columns. *index* starts at 1 in the upper left
887         corner and increases to the right.
888 
889         *pos* is a three digit integer, where the first digit is the
890         number of rows, the second the number of columns, and the third
891         the index of the subplot. i.e. fig.add_subplot(235) is the same as
892         fig.add_subplot(2, 3, 5). Note that all integers must be less than
893         10 for this form to work.
894 
895     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
896 'polar', 'rectilinear', str}, optional
897         The projection type of the subplot (`~.axes.Axes`). *str* is the name
898         of a costum projection, see `~matplotlib.projections`. The default
899         None results in a 'rectilinear' projection.
900 
901     polar : boolean, optional
902         If True, equivalent to projection='polar'.
903 
904     sharex, sharey : `~.axes.Axes`, optional
905         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
906         axis will have the same limits, ticks, and scale as the axis of the
907         shared axes.
908 
909     label : str
910         A label for the returned axes.
911 
912     Other Parameters
913     ----------------
914     **kwargs
915         This method also takes the keyword arguments for
916         the returned axes base class. The keyword arguments for the
917         rectilinear base class `~.axes.Axes` can be found in
918         the following table but there might also be other keyword
919         arguments if another projection is used.
920         %(Axes)s
921 
922     Returns
923     -------
924     axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass \
925     of `~.axes.Axes`)
926 
927         The axes of the subplot. The returned axes base class depends on
928         the projection used. It is `~.axes.Axes` if rectilinear projection
929         are used and `.projections.polar.PolarAxes` if polar projection
930         are used. The returned axes is then a subplot subclass of the
931         base class.
932 
933     Notes
934     -----
935     Creating a subplot will delete any pre-existing subplot that overlaps
936     with it beyond sharing a boundary::
937 
938         import matplotlib.pyplot as plt
939         # plot a line, implicitly creating a subplot(111)
940         plt.plot([1,2,3])
941         # now create a subplot which represents the top plot of a grid
942         # with 2 rows and 1 column. Since this subplot will overlap the
943         # first, the plot (and its axes) previously created, will be removed
944         plt.subplot(211)
945 
946     If you do not want this behavior, use the `.Figure.add_subplot` method
947     or the `.pyplot.axes` function instead.
948 
949     If the figure already has a subplot with key (*args*,
950     *kwargs*) then it will simply make that subplot current and
951     return it.  This behavior is deprecated. Meanwhile, if you do
952     not want this behavior (i.e., you want to force the creation of a
953     new subplot), you must use a unique set of args and kwargs.  The axes
954     *label* attribute has been exposed for this purpose: if you want
955     two subplots that are otherwise identical to be added to the figure,
956     make sure you give them unique labels.
957 
958     In rare circumstances, `.add_subplot` may be called with a single
959     argument, a subplot axes instance already created in the
960     present figure but not in the figure's list of axes.
961 
962     See Also
963     --------
964     .Figure.add_subplot
965     .pyplot.subplots
966     .pyplot.axes
967     .Figure.subplots
968 
969     Examples
970     --------
971     ::
972 
973         plt.subplot(221)
974 
975         # equivalent but more general
976         ax1=plt.subplot(2, 2, 1)
977 
978         # add a subplot with no frame
979         ax2=plt.subplot(222, frameon=False)
980 
981         # add a polar subplot
982         plt.subplot(223, projection='polar')
983 
984         # add a red subplot that shares the x-axis with ax1
985         plt.subplot(224, sharex=ax1, facecolor='red')
986 
987         # delete ax2 from the figure
988         plt.delaxes(ax2)
989 
990         # add ax2 to the figure again
991         plt.subplot(ax2)
992         """
993 
994     # if subplot called without arguments, create subplot(1,1,1)
995     if len(args) == 0:
996         args = (1, 1, 1)
997 
998     # This check was added because it is very easy to type
999     # subplot(1, 2, False) when subplots(1, 2, False) was intended
1000     # (sharex=False, that is). In most cases, no error will
1001     # ever occur, but mysterious behavior can result because what was
1002     # intended to be the sharex argument is instead treated as a
1003     # subplot index for subplot()
1004     if len(args) >= 3 and isinstance(args[2], bool):
1005         cbook._warn_external("The subplot index argument to subplot() appears "
1006                              "to be a boolean. Did you intend to use "
1007                              "subplots()?")
1008 
1009     fig = gcf()
1010     a = fig.add_subplot(*args, **kwargs)
1011     bbox = a.bbox
1012     byebye = []
1013     for other in fig.axes:
1014         if other == a:
1015             continue
1016         if bbox.fully_overlaps(other.bbox):
1017             byebye.append(other)
1018     for ax in byebye:
1019         delaxes(ax)
1020 
1021     return a
1022 
1023 
1024 def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,
1025              subplot_kw=None, gridspec_kw=None, **fig_kw):
1026     """
1027     Create a figure and a set of subplots.
1028 
1029     This utility wrapper makes it convenient to create common layouts of
1030     subplots, including the enclosing figure object, in a single call.
1031 
1032     Parameters
1033     ----------
1034     nrows, ncols : int, optional, default: 1
1035         Number of rows/columns of the subplot grid.
1036 
1037     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1038         Controls sharing of properties among x (`sharex`) or y (`sharey`)
1039         axes:
1040 
1041             - True or 'all': x- or y-axis will be shared among all
1042               subplots.
1043             - False or 'none': each subplot x- or y-axis will be
1044               independent.
1045             - 'row': each subplot row will share an x- or y-axis.
1046             - 'col': each subplot column will share an x- or y-axis.
1047 
1048         When subplots have a shared x-axis along a column, only the x tick
1049         labels of the bottom subplot are created. Similarly, when subplots
1050         have a shared y-axis along a row, only the y tick labels of the first
1051         column subplot are created. To later turn other subplots' ticklabels
1052         on, use `~matplotlib.axes.Axes.tick_params`.
1053 
1054     squeeze : bool, optional, default: True
1055         - If True, extra dimensions are squeezed out from the returned
1056           array of `~matplotlib.axes.Axes`:
1057 
1058             - if only one subplot is constructed (nrows=ncols=1), the
1059               resulting single Axes object is returned as a scalar.
1060             - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1061               object array of Axes objects.
1062             - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1063 
1064         - If False, no squeezing at all is done: the returned Axes object is
1065           always a 2D array containing Axes instances, even if it ends up
1066           being 1x1.
1067 
1068     num : integer or string, optional, default: None
1069         A `.pyplot.figure` keyword that sets the figure number or label.
1070 
1071     subplot_kw : dict, optional
1072         Dict with keywords passed to the
1073         `~matplotlib.figure.Figure.add_subplot` call used to create each
1074         subplot.
1075 
1076     gridspec_kw : dict, optional
1077         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1078         constructor used to create the grid the subplots are placed on.
1079 
1080     **fig_kw
1081         All additional keyword arguments are passed to the
1082         `.pyplot.figure` call.
1083 
1084     Returns
1085     -------
1086     fig : `~.figure.Figure`
1087 
1088     ax : `.axes.Axes` object or array of Axes objects.
1089         *ax* can be either a single `~matplotlib.axes.Axes` object or an
1090         array of Axes objects if more than one subplot was created.  The
1091         dimensions of the resulting array can be controlled with the squeeze
1092         keyword, see above.
1093 
1094     Examples
1095     --------
1096     ::
1097 
1098         # First create some toy data:
1099         x = np.linspace(0, 2*np.pi, 400)
1100         y = np.sin(x**2)
1101 
1102         # Creates just a figure and only one subplot
1103         fig, ax = plt.subplots()
1104         ax.plot(x, y)
1105         ax.set_title('Simple plot')
1106 
1107         # Creates two subplots and unpacks the output array immediately
1108         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1109         ax1.plot(x, y)
1110         ax1.set_title('Sharing Y axis')
1111         ax2.scatter(x, y)
1112 
1113         # Creates four polar axes, and accesses them through the returned array
1114         fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))
1115         axes[0, 0].plot(x, y)
1116         axes[1, 1].scatter(x, y)
1117 
1118         # Share a X axis with each column of subplots
1119         plt.subplots(2, 2, sharex='col')
1120 
1121         # Share a Y axis with each row of subplots
1122         plt.subplots(2, 2, sharey='row')
1123 
1124         # Share both X and Y axes with all subplots
1125         plt.subplots(2, 2, sharex='all', sharey='all')
1126 
1127         # Note that this is the same as
1128         plt.subplots(2, 2, sharex=True, sharey=True)
1129 
1130         # Creates figure number 10 with a single subplot
1131         # and clears it if it already exists.
1132         fig, ax=plt.subplots(num=10, clear=True)
1133 
1134     See Also
1135     --------
1136     .pyplot.figure
1137     .pyplot.subplot
1138     .pyplot.axes
1139     .Figure.subplots
1140     .Figure.add_subplot
1141 
1142     """
1143     fig = figure(**fig_kw)
1144     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1145                        squeeze=squeeze, subplot_kw=subplot_kw,
1146                        gridspec_kw=gridspec_kw)
1147     return fig, axs
1148 
1149 
1150 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1151     """
1152     Create an axis at specific location inside a regular grid.
1153 
1154     Parameters
1155     ----------
1156     shape : sequence of 2 ints
1157         Shape of grid in which to place axis.
1158         First entry is number of rows, second entry is number of columns.
1159 
1160     loc : sequence of 2 ints
1161         Location to place axis within grid.
1162         First entry is row number, second entry is column number.
1163 
1164     rowspan : int
1165         Number of rows for the axis to span to the right.
1166 
1167     colspan : int
1168         Number of columns for the axis to span downwards.
1169 
1170     fig : `Figure`, optional
1171         Figure to place axis in. Defaults to current figure.
1172 
1173     **kwargs
1174         Additional keyword arguments are handed to `add_subplot`.
1175 
1176 
1177     Notes
1178     -----
1179     The following call ::
1180 
1181         subplot2grid(shape, loc, rowspan=1, colspan=1)
1182 
1183     is identical to ::
1184 
1185         gridspec=GridSpec(shape[0], shape[1])
1186         subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)
1187         subplot(subplotspec)
1188     """
1189 
1190     if fig is None:
1191         fig = gcf()
1192 
1193     s1, s2 = shape
1194     subplotspec = GridSpec(s1, s2).new_subplotspec(loc,
1195                                                    rowspan=rowspan,
1196                                                    colspan=colspan)
1197     a = fig.add_subplot(subplotspec, **kwargs)
1198     bbox = a.bbox
1199     byebye = []
1200     for other in fig.axes:
1201         if other == a:
1202             continue
1203         if bbox.fully_overlaps(other.bbox):
1204             byebye.append(other)
1205     for ax in byebye:
1206         delaxes(ax)
1207 
1208     return a
1209 
1210 
1211 def twinx(ax=None):
1212     """
1213     Make a second axes that shares the *x*-axis.  The new axes will
1214     overlay *ax* (or the current axes if *ax* is *None*).  The ticks
1215     for *ax2* will be placed on the right, and the *ax2* instance is
1216     returned.
1217 
1218     .. seealso::
1219 
1220        :doc:`/gallery/subplots_axes_and_figures/two_scales`
1221 
1222     """
1223     if ax is None:
1224         ax = gca()
1225     ax1 = ax.twinx()
1226     return ax1
1227 
1228 
1229 def twiny(ax=None):
1230     """
1231     Make a second axes that shares the *y*-axis.  The new axis will
1232     overlay *ax* (or the current axes if *ax* is *None*).  The ticks
1233     for *ax2* will be placed on the top, and the *ax2* instance is
1234     returned.
1235     """
1236     if ax is None:
1237         ax = gca()
1238     ax1 = ax.twiny()
1239     return ax1
1240 
1241 
1242 def subplots_adjust(left=None, bottom=None, right=None, top=None,
1243                     wspace=None, hspace=None):
1244     """
1245     Tune the subplot layout.
1246 
1247     The parameter meanings (and suggested defaults) are::
1248 
1249       left = 0.125  # the left side of the subplots of the figure
1250       right = 0.9   # the right side of the subplots of the figure
1251       bottom = 0.1  # the bottom of the subplots of the figure
1252       top = 0.9     # the top of the subplots of the figure
1253       wspace = 0.2  # the amount of width reserved for space between subplots,
1254                     # expressed as a fraction of the average axis width
1255       hspace = 0.2  # the amount of height reserved for space between subplots,
1256                     # expressed as a fraction of the average axis height
1257 
1258     The actual defaults are controlled by the rc file
1259     """
1260     fig = gcf()
1261     fig.subplots_adjust(left, bottom, right, top, wspace, hspace)
1262 
1263 
1264 def subplot_tool(targetfig=None):
1265     """
1266     Launch a subplot tool window for a figure.
1267 
1268     A :class:`matplotlib.widgets.SubplotTool` instance is returned.
1269     """
1270     tbar = rcParams['toolbar']  # turn off navigation toolbar for the toolfig
1271     rcParams['toolbar'] = 'None'
1272     if targetfig is None:
1273         manager = get_current_fig_manager()
1274         targetfig = manager.canvas.figure
1275     else:
1276         # find the manager for this figure
1277         for manager in _pylab_helpers.Gcf._activeQue:
1278             if manager.canvas.figure == targetfig:
1279                 break
1280         else:
1281             raise RuntimeError('Could not find manager for targetfig')
1282 
1283     toolfig = figure(figsize=(6, 3))
1284     toolfig.subplots_adjust(top=0.9)
1285     ret = SubplotTool(targetfig, toolfig)
1286     rcParams['toolbar'] = tbar
1287     _pylab_helpers.Gcf.set_active(manager)  # restore the current figure
1288     return ret
1289 
1290 
1291 def tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None):
1292     """
1293     Automatically adjust subplot parameters to give specified padding.
1294 
1295     Parameters
1296     ----------
1297     pad : float
1298         Padding between the figure edge and the edges of subplots,
1299         as a fraction of the font size.
1300     h_pad, w_pad : float, optional
1301         Padding (height/width) between edges of adjacent subplots,
1302         as a fraction of the font size.  Defaults to *pad*.
1303     rect : tuple (left, bottom, right, top), optional
1304         A rectangle (left, bottom, right, top) in the normalized
1305         figure coordinate that the whole subplots area (including
1306         labels) will fit into. Default is (0, 0, 1, 1).
1307     """
1308     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
1309 
1310 
1311 def box(on=None):
1312     """
1313     Turn the axes box on or off on the current axes.
1314 
1315     Parameters
1316     ----------
1317     on : bool or None
1318         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1319         the state.
1320 
1321     See Also
1322     --------
1323     :meth:`matplotlib.axes.Axes.set_frame_on`
1324     :meth:`matplotlib.axes.Axes.get_frame_on`
1325     """
1326     ax = gca()
1327     if on is None:
1328         on = not ax.get_frame_on()
1329     ax.set_frame_on(on)
1330 
1331 ## Axis ##
1332 
1333 
1334 def xlim(*args, **kwargs):
1335     """
1336     Get or set the x limits of the current axes.
1337 
1338     Call signatures::
1339 
1340         left, right = xlim()  # return the current xlim
1341         xlim((left, right))   # set the xlim to left, right
1342         xlim(left, right)     # set the xlim to left, right
1343 
1344     If you do not specify args, you can pass *left* or *right* as kwargs,
1345     i.e.::
1346 
1347         xlim(right=3)  # adjust the right leaving left unchanged
1348         xlim(left=1)  # adjust the left leaving right unchanged
1349 
1350     Setting limits turns autoscaling off for the x-axis.
1351 
1352     Returns
1353     -------
1354     left, right
1355         A tuple of the new x-axis limits.
1356 
1357     Notes
1358     -----
1359     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1360     equivalent of calling `~.Axes.get_xlim` on the current axes.
1361     Calling this function with arguments is the pyplot equivalent of calling
1362     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1363     """
1364     ax = gca()
1365     if not args and not kwargs:
1366         return ax.get_xlim()
1367     ret = ax.set_xlim(*args, **kwargs)
1368     return ret
1369 
1370 
1371 def ylim(*args, **kwargs):
1372     """
1373     Get or set the y-limits of the current axes.
1374 
1375     Call signatures::
1376 
1377         bottom, top = ylim()  # return the current ylim
1378         ylim((bottom, top))   # set the ylim to bottom, top
1379         ylim(bottom, top)     # set the ylim to bottom, top
1380 
1381     If you do not specify args, you can alternatively pass *bottom* or
1382     *top* as kwargs, i.e.::
1383 
1384         ylim(top=3)  # adjust the top leaving bottom unchanged
1385         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1386 
1387     Setting limits turns autoscaling off for the y-axis.
1388 
1389     Returns
1390     -------
1391     bottom, top
1392         A tuple of the new y-axis limits.
1393 
1394     Notes
1395     -----
1396     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1397     equivalent of calling `~.Axes.get_ylim` on the current axes.
1398     Calling this function with arguments is the pyplot equivalent of calling
1399     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1400     """
1401     ax = gca()
1402     if not args and not kwargs:
1403         return ax.get_ylim()
1404     ret = ax.set_ylim(*args, **kwargs)
1405     return ret
1406 
1407 
1408 def xticks(ticks=None, labels=None, **kwargs):
1409     """
1410     Get or set the current tick locations and labels of the x-axis.
1411 
1412     Call signatures::
1413 
1414         locs, labels = xticks()            # Get locations and labels
1415         xticks(ticks, [labels], **kwargs)  # Set locations and labels
1416 
1417     Parameters
1418     ----------
1419     ticks : array_like
1420         A list of positions at which ticks should be placed. You can pass an
1421         empty list to disable xticks.
1422 
1423     labels : array_like, optional
1424         A list of explicit labels to place at the given *locs*.
1425 
1426     **kwargs
1427         :class:`.Text` properties can be used to control the appearance of
1428         the labels.
1429 
1430     Returns
1431     -------
1432     locs
1433         An array of label locations.
1434     labels
1435         A list of `.Text` objects.
1436 
1437     Notes
1438     -----
1439     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1440     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1441     the current axes.
1442     Calling this function with arguments is the pyplot equivalent of calling
1443     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1444 
1445     Examples
1446     --------
1447     Get the current locations and labels:
1448 
1449         >>> locs, labels = xticks()
1450 
1451     Set label locations:
1452 
1453         >>> xticks(np.arange(0, 1, step=0.2))
1454 
1455     Set text labels:
1456 
1457         >>> xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
1458 
1459     Set text labels and properties:
1460 
1461         >>> xticks(np.arange(12), calendar.month_name[1:13], rotation=20)
1462 
1463     Disable xticks:
1464 
1465         >>> xticks([])
1466     """
1467     ax = gca()
1468 
1469     if ticks is None and labels is None:
1470         locs = ax.get_xticks()
1471         labels = ax.get_xticklabels()
1472     elif labels is None:
1473         locs = ax.set_xticks(ticks)
1474         labels = ax.get_xticklabels()
1475     else:
1476         locs = ax.set_xticks(ticks)
1477         labels = ax.set_xticklabels(labels, **kwargs)
1478     for l in labels:
1479         l.update(kwargs)
1480 
1481     return locs, silent_list('Text xticklabel', labels)
1482 
1483 
1484 def yticks(ticks=None, labels=None, **kwargs):
1485     """
1486     Get or set the current tick locations and labels of the y-axis.
1487 
1488     Call signatures::
1489 
1490         locs, labels = yticks()            # Get locations and labels
1491         yticks(ticks, [labels], **kwargs)  # Set locations and labels
1492 
1493     Parameters
1494     ----------
1495     ticks : array_like
1496         A list of positions at which ticks should be placed. You can pass an
1497         empty list to disable yticks.
1498 
1499     labels : array_like, optional
1500         A list of explicit labels to place at the given *locs*.
1501 
1502     **kwargs
1503         :class:`.Text` properties can be used to control the appearance of
1504         the labels.
1505 
1506     Returns
1507     -------
1508     locs
1509         An array of label locations.
1510     labels
1511         A list of `.Text` objects.
1512 
1513     Notes
1514     -----
1515     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1516     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1517     the current axes.
1518     Calling this function with arguments is the pyplot equivalent of calling
1519     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1520 
1521     Examples
1522     --------
1523     Get the current locations and labels:
1524 
1525         >>> locs, labels = yticks()
1526 
1527     Set label locations:
1528 
1529         >>> yticks(np.arange(0, 1, step=0.2))
1530 
1531     Set text labels:
1532 
1533         >>> yticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
1534 
1535     Set text labels and properties:
1536 
1537         >>> yticks(np.arange(12), calendar.month_name[1:13], rotation=45)
1538 
1539     Disable yticks:
1540 
1541         >>> yticks([])
1542     """
1543     ax = gca()
1544 
1545     if ticks is None and labels is None:
1546         locs = ax.get_yticks()
1547         labels = ax.get_yticklabels()
1548     elif labels is None:
1549         locs = ax.set_yticks(ticks)
1550         labels = ax.get_yticklabels()
1551     else:
1552         locs = ax.set_yticks(ticks)
1553         labels = ax.set_yticklabels(labels, **kwargs)
1554     for l in labels:
1555         l.update(kwargs)
1556 
1557     return locs, silent_list('Text yticklabel', labels)
1558 
1559 
1560 def rgrids(*args, **kwargs):
1561     """
1562     Get or set the radial gridlines on the current polar plot.
1563 
1564     Call signatures::
1565 
1566      lines, labels = rgrids()
1567      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1568 
1569     When called with no arguments, `.rgrids` simply returns the tuple
1570     (*lines*, *labels*). When called with arguments, the labels will
1571     appear at the specified radial distances and angle.
1572 
1573     Parameters
1574     ----------
1575     radii : tuple with floats
1576         The radii for the radial gridlines
1577 
1578     labels : tuple with strings or None
1579         The labels to use at each radial gridline. The
1580         `matplotlib.ticker.ScalarFormatter` will be used if None.
1581 
1582     angle : float
1583         The angular position of the radius labels in degrees.
1584 
1585     fmt : str or None
1586         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1587         For example '%f'.
1588 
1589     Returns
1590     -------
1591     lines, labels : list of `.lines.Line2D`, list of `.text.Text`
1592         *lines* are the radial gridlines and *labels* are the tick labels.
1593 
1594     Other Parameters
1595     ----------------
1596     **kwargs
1597         *kwargs* are optional `~.Text` properties for the labels.
1598 
1599     Examples
1600     --------
1601     ::
1602 
1603       # set the locations of the radial gridlines
1604       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1605 
1606       # set the locations and labels of the radial gridlines
1607       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1608 
1609     See Also
1610     --------
1611     .pyplot.thetagrids
1612     .projections.polar.PolarAxes.set_rgrids
1613     .Axis.get_gridlines
1614     .Axis.get_ticklabels
1615     """
1616     ax = gca()
1617     if not isinstance(ax, PolarAxes):
1618         raise RuntimeError('rgrids only defined for polar axes')
1619     if len(args) == 0:
1620         lines = ax.yaxis.get_gridlines()
1621         labels = ax.yaxis.get_ticklabels()
1622     else:
1623         lines, labels = ax.set_rgrids(*args, **kwargs)
1624     return (silent_list('Line2D rgridline', lines),
1625             silent_list('Text rgridlabel', labels))
1626 
1627 
1628 def thetagrids(*args, **kwargs):
1629     """
1630     Get or set the theta gridlines on the current polar plot.
1631 
1632     Call signatures::
1633 
1634      lines, labels = thetagrids()
1635      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1636 
1637     When called with no arguments, `.thetagrids` simply returns the tuple
1638     (*lines*, *labels*). When called with arguments, the labels will
1639     appear at the specified angles.
1640 
1641     Parameters
1642     ----------
1643     angles : tuple with floats, degrees
1644         The angles of the theta gridlines.
1645 
1646     labels : tuple with strings or None
1647         The labels to use at each radial gridline. The
1648         `.projections.polar.ThetaFormatter` will be used if None.
1649 
1650     fmt : str or None
1651         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1652         For example '%f'. Note that the angle in radians will be used.
1653 
1654     Returns
1655     -------
1656     lines, labels : list of `.lines.Line2D`, list of `.text.Text`
1657         *lines* are the theta gridlines and *labels* are the tick labels.
1658 
1659     Other Parameters
1660     ----------------
1661     **kwargs
1662         *kwargs* are optional `~.Text` properties for the labels.
1663 
1664     Examples
1665     --------
1666     ::
1667 
1668       # set the locations of the angular gridlines
1669       lines, labels = thetagrids( range(45,360,90) )
1670 
1671       # set the locations and labels of the angular gridlines
1672       lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )
1673 
1674     See Also
1675     --------
1676     .pyplot.rgrids
1677     .projections.polar.PolarAxes.set_thetagrids
1678     .Axis.get_gridlines
1679     .Axis.get_ticklabels
1680     """
1681     ax = gca()
1682     if not isinstance(ax, PolarAxes):
1683         raise RuntimeError('thetagrids only defined for polar axes')
1684     if len(args) == 0:
1685         lines = ax.xaxis.get_ticklines()
1686         labels = ax.xaxis.get_ticklabels()
1687     else:
1688         lines, labels = ax.set_thetagrids(*args, **kwargs)
1689     return (silent_list('Line2D thetagridline', lines),
1690             silent_list('Text thetagridlabel', labels))
1691 
1692 
1693 ## Plotting Info ##
1694 
1695 
1696 def plotting():
1697     pass
1698 
1699 
1700 def get_plot_commands():
1701     """
1702     Get a sorted list of all of the plotting commands.
1703     """
1704     # This works by searching for all functions in this module and removing
1705     # a few hard-coded exclusions, as well as all of the colormap-setting
1706     # functions, and anything marked as private with a preceding underscore.
1707     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
1708                'get_plot_commands', 'get_current_fig_manager', 'ginput',
1709                'plotting', 'waitforbuttonpress'}
1710     exclude |= set(colormaps())
1711     this_module = inspect.getmodule(get_plot_commands)
1712     return sorted(
1713         name for name, obj in globals().items()
1714         if not name.startswith('_') and name not in exclude
1715            and inspect.isfunction(obj)
1716            and inspect.getmodule(obj) is this_module)
1717 
1718 
1719 def colormaps():
1720     """
1721     Matplotlib provides a number of colormaps, and others can be added using
1722     :func:`~matplotlib.cm.register_cmap`.  This function documents the built-in
1723     colormaps, and will also return a list of all registered colormaps if
1724     called.
1725 
1726     You can set the colormap for an image, pcolor, scatter, etc,
1727     using a keyword argument::
1728 
1729       imshow(X, cmap=cm.hot)
1730 
1731     or using the :func:`set_cmap` function::
1732 
1733       imshow(X)
1734       pyplot.set_cmap('hot')
1735       pyplot.set_cmap('jet')
1736 
1737     In interactive mode, :func:`set_cmap` will update the colormap post-hoc,
1738     allowing you to see which one works best for your data.
1739 
1740     All built-in colormaps can be reversed by appending ``_r``: For instance,
1741     ``gray_r`` is the reverse of ``gray``.
1742 
1743     There are several common color schemes used in visualization:
1744 
1745     Sequential schemes
1746       for unipolar data that progresses from low to high
1747     Diverging schemes
1748       for bipolar data that emphasizes positive or negative deviations from a
1749       central value
1750     Cyclic schemes
1751       for plotting values that wrap around at the endpoints, such as phase
1752       angle, wind direction, or time of day
1753     Qualitative schemes
1754       for nominal data that has no inherent ordering, where color is used
1755       only to distinguish categories
1756 
1757     Matplotlib ships with 4 perceptually uniform color maps which are
1758     the recommended color maps for sequential data:
1759 
1760       =========   ===================================================
1761       Colormap    Description
1762       =========   ===================================================
1763       inferno     perceptually uniform shades of black-red-yellow
1764       magma       perceptually uniform shades of black-red-white
1765       plasma      perceptually uniform shades of blue-red-yellow
1766       viridis     perceptually uniform shades of blue-green-yellow
1767       =========   ===================================================
1768 
1769     The following colormaps are based on the `ColorBrewer
1770     <http://colorbrewer2.org>`_ color specifications and designs developed by
1771     Cynthia Brewer:
1772 
1773     ColorBrewer Diverging (luminance is highest at the midpoint, and
1774     decreases towards differently-colored endpoints):
1775 
1776       ========  ===================================
1777       Colormap  Description
1778       ========  ===================================
1779       BrBG      brown, white, blue-green
1780       PiYG      pink, white, yellow-green
1781       PRGn      purple, white, green
1782       PuOr      orange, white, purple
1783       RdBu      red, white, blue
1784       RdGy      red, white, gray
1785       RdYlBu    red, yellow, blue
1786       RdYlGn    red, yellow, green
1787       Spectral  red, orange, yellow, green, blue
1788       ========  ===================================
1789 
1790     ColorBrewer Sequential (luminance decreases monotonically):
1791 
1792       ========  ====================================
1793       Colormap  Description
1794       ========  ====================================
1795       Blues     white to dark blue
1796       BuGn      white, light blue, dark green
1797       BuPu      white, light blue, dark purple
1798       GnBu      white, light green, dark blue
1799       Greens    white to dark green
1800       Greys     white to black (not linear)
1801       Oranges   white, orange, dark brown
1802       OrRd      white, orange, dark red
1803       PuBu      white, light purple, dark blue
1804       PuBuGn    white, light purple, dark green
1805       PuRd      white, light purple, dark red
1806       Purples   white to dark purple
1807       RdPu      white, pink, dark purple
1808       Reds      white to dark red
1809       YlGn      light yellow, dark green
1810       YlGnBu    light yellow, light green, dark blue
1811       YlOrBr    light yellow, orange, dark brown
1812       YlOrRd    light yellow, orange, dark red
1813       ========  ====================================
1814 
1815     ColorBrewer Qualitative:
1816 
1817     (For plotting nominal data, :class:`ListedColormap` is used,
1818     not :class:`LinearSegmentedColormap`.  Different sets of colors are
1819     recommended for different numbers of categories.)
1820 
1821     * Accent
1822     * Dark2
1823     * Paired
1824     * Pastel1
1825     * Pastel2
1826     * Set1
1827     * Set2
1828     * Set3
1829 
1830     A set of colormaps derived from those of the same name provided
1831     with Matlab are also included:
1832 
1833       =========   =======================================================
1834       Colormap    Description
1835       =========   =======================================================
1836       autumn      sequential linearly-increasing shades of red-orange-yellow
1837       bone        sequential increasing black-white color map with
1838                   a tinge of blue, to emulate X-ray film
1839       cool        linearly-decreasing shades of cyan-magenta
1840       copper      sequential increasing shades of black-copper
1841       flag        repetitive red-white-blue-black pattern (not cyclic at
1842                   endpoints)
1843       gray        sequential linearly-increasing black-to-white
1844                   grayscale
1845       hot         sequential black-red-yellow-white, to emulate blackbody
1846                   radiation from an object at increasing temperatures
1847       jet         a spectral map with dark endpoints, blue-cyan-yellow-red;
1848                   based on a fluid-jet simulation by NCSA [#]_
1849       pink        sequential increasing pastel black-pink-white, meant
1850                   for sepia tone colorization of photographs
1851       prism       repetitive red-yellow-green-blue-purple-...-green pattern
1852                   (not cyclic at endpoints)
1853       spring      linearly-increasing shades of magenta-yellow
1854       summer      sequential linearly-increasing shades of green-yellow
1855       winter      linearly-increasing shades of blue-green
1856       =========   =======================================================
1857 
1858     A set of palettes from the `Yorick scientific visualisation
1859     package <https://dhmunro.github.io/yorick-doc/>`_, an evolution of
1860     the GIST package, both by David H. Munro are included:
1861 
1862       ============  =======================================================
1863       Colormap      Description
1864       ============  =======================================================
1865       gist_earth    mapmaker's colors from dark blue deep ocean to green
1866                     lowlands to brown highlands to white mountains
1867       gist_heat     sequential increasing black-red-orange-white, to emulate
1868                     blackbody radiation from an iron bar as it grows hotter
1869       gist_ncar     pseudo-spectral black-blue-green-yellow-red-purple-white
1870                     colormap from National Center for Atmospheric
1871                     Research [#]_
1872       gist_rainbow  runs through the colors in spectral order from red to
1873                     violet at full saturation (like *hsv* but not cyclic)
1874       gist_stern    "Stern special" color table from Interactive Data
1875                     Language software
1876       ============  =======================================================
1877 
1878     A set of cyclic color maps:
1879 
1880       ================  =================================================
1881       Colormap          Description
1882       ================  =================================================
1883       hsv               red-yellow-green-cyan-blue-magenta-red, formed by
1884                         changing the hue component in the HSV color space
1885       twilight          perceptually uniform shades of
1886                         white-blue-black-red-white
1887       twilight_shifted  perceptually uniform shades of
1888                         black-blue-white-red-black
1889       ================  =================================================
1890 
1891 
1892     Other miscellaneous schemes:
1893 
1894       ============= =======================================================
1895       Colormap      Description
1896       ============= =======================================================
1897       afmhot        sequential black-orange-yellow-white blackbody
1898                     spectrum, commonly used in atomic force microscopy
1899       brg           blue-red-green
1900       bwr           diverging blue-white-red
1901       coolwarm      diverging blue-gray-red, meant to avoid issues with 3D
1902                     shading, color blindness, and ordering of colors [#]_
1903       CMRmap        "Default colormaps on color images often reproduce to
1904                     confusing grayscale images. The proposed colormap
1905                     maintains an aesthetically pleasing color image that
1906                     automatically reproduces to a monotonic grayscale with
1907                     discrete, quantifiable saturation levels." [#]_
1908       cubehelix     Unlike most other color schemes cubehelix was designed
1909                     by D.A. Green to be monotonically increasing in terms
1910                     of perceived brightness. Also, when printed on a black
1911                     and white postscript printer, the scheme results in a
1912                     greyscale with monotonically increasing brightness.
1913                     This color scheme is named cubehelix because the r,g,b
1914                     values produced can be visualised as a squashed helix
1915                     around the diagonal in the r,g,b color cube.
1916       gnuplot       gnuplot's traditional pm3d scheme
1917                     (black-blue-red-yellow)
1918       gnuplot2      sequential color printable as gray
1919                     (black-blue-violet-yellow-white)
1920       ocean         green-blue-white
1921       rainbow       spectral purple-blue-green-yellow-orange-red colormap
1922                     with diverging luminance
1923       seismic       diverging blue-white-red
1924       nipy_spectral black-purple-blue-green-yellow-red-white spectrum,
1925                     originally from the Neuroimaging in Python project
1926       terrain       mapmaker's colors, blue-green-yellow-brown-white,
1927                     originally from IGOR Pro
1928       ============= =======================================================
1929 
1930     The following colormaps are redundant and may be removed in future
1931     versions.  It's recommended to use the names in the descriptions
1932     instead, which produce identical output:
1933 
1934       =========  =======================================================
1935       Colormap   Description
1936       =========  =======================================================
1937       gist_gray  identical to *gray*
1938       gist_yarg  identical to *gray_r*
1939       binary     identical to *gray_r*
1940       =========  =======================================================
1941 
1942     .. rubric:: Footnotes
1943 
1944     .. [#] Rainbow colormaps, ``jet`` in particular, are considered a poor
1945       choice for scientific visualization by many researchers: `Rainbow Color
1946       Map (Still) Considered Harmful
1947       <http://ieeexplore.ieee.org/document/4118486/?arnumber=4118486>`_
1948 
1949     .. [#] Resembles "BkBlAqGrYeOrReViWh200" from NCAR Command
1950       Language. See `Color Table Gallery
1951       <https://www.ncl.ucar.edu/Document/Graphics/color_table_gallery.shtml>`_
1952 
1953     .. [#] See `Diverging Color Maps for Scientific Visualization
1954       <http://www.kennethmoreland.com/color-maps/>`_ by Kenneth Moreland.
1955 
1956     .. [#] See `A Color Map for Effective Black-and-White Rendering of
1957       Color-Scale Images
1958       <https://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m>`_
1959       by Carey Rappaport
1960     """
1961     return sorted(cm.cmap_d)
1962 
1963 
1964 def _setup_pyplot_info_docstrings():
1965     """
1966     Generates the plotting docstring.
1967 
1968     These must be done after the entire module is imported, so it is
1969     called from the end of this module, which is generated by
1970     boilerplate.py.
1971     """
1972     commands = get_plot_commands()
1973 
1974     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
1975 
1976     # Collect the first sentence of the docstring for all of the
1977     # plotting commands.
1978     rows = []
1979     max_name = len("Function")
1980     max_summary = len("Description")
1981     for name in commands:
1982         doc = globals()[name].__doc__
1983         summary = ''
1984         if doc is not None:
1985             match = first_sentence.match(doc)
1986             if match is not None:
1987                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
1988         name = '`%s`' % name
1989         rows.append([name, summary])
1990         max_name = max(max_name, len(name))
1991         max_summary = max(max_summary, len(summary))
1992 
1993     separator = '=' * max_name + ' ' + '=' * max_summary
1994     lines = [
1995         separator,
1996         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
1997         separator,
1998     ] + [
1999         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2000         for name, summary in rows
2001     ] + [
2002         separator,
2003     ]
2004     plotting.__doc__ = '\n'.join(lines)
2005 
2006 
2007 ## Plotting part 1: manually generated functions and wrappers ##
2008 
2009 
2010 def colorbar(mappable=None, cax=None, ax=None, **kw):
2011     if mappable is None:
2012         mappable = gci()
2013         if mappable is None:
2014             raise RuntimeError('No mappable was found to use for colorbar '
2015                                'creation. First define a mappable such as '
2016                                'an image (with imshow) or a contour set ('
2017                                'with contourf).')
2018     if ax is None:
2019         ax = gca()
2020     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kw)
2021     return ret
2022 colorbar.__doc__ = matplotlib.colorbar.colorbar_doc
2023 
2024 
2025 def clim(vmin=None, vmax=None):
2026     """
2027     Set the color limits of the current image.
2028 
2029     To apply clim to all axes images do::
2030 
2031       clim(0, 0.5)
2032 
2033     If either *vmin* or *vmax* is None, the image min/max respectively
2034     will be used for color scaling.
2035 
2036     If you want to set the clim of multiple images,
2037     use, for example::
2038 
2039       for im in gca().get_images():
2040           im.set_clim(0, 0.05)
2041 
2042     """
2043     im = gci()
2044     if im is None:
2045         raise RuntimeError('You must first define an image, e.g., with imshow')
2046 
2047     im.set_clim(vmin, vmax)
2048 
2049 
2050 def set_cmap(cmap):
2051     """
2052     Set the default colormap.  Applies to the current image if any.
2053     See help(colormaps) for more information.
2054 
2055     *cmap* must be a :class:`~matplotlib.colors.Colormap` instance, or
2056     the name of a registered colormap.
2057 
2058     See :func:`matplotlib.cm.register_cmap` and
2059     :func:`matplotlib.cm.get_cmap`.
2060     """
2061     cmap = cm.get_cmap(cmap)
2062 
2063     rc('image', cmap=cmap.name)
2064     im = gci()
2065 
2066     if im is not None:
2067         im.set_cmap(cmap)
2068 
2069 
2070 @docstring.copy(matplotlib.image.imread)
2071 def imread(fname, format=None):
2072     return matplotlib.image.imread(fname, format)
2073 
2074 
2075 @docstring.copy(matplotlib.image.imsave)
2076 def imsave(fname, arr, **kwargs):
2077     return matplotlib.image.imsave(fname, arr, **kwargs)
2078 
2079 
2080 def matshow(A, fignum=None, **kwargs):
2081     """
2082     Display an array as a matrix in a new figure window.
2083 
2084     The origin is set at the upper left hand corner and rows (first
2085     dimension of the array) are displayed horizontally.  The aspect
2086     ratio of the figure window is that of the array, unless this would
2087     make an excessively short or narrow figure.
2088 
2089     Tick labels for the xaxis are placed on top.
2090 
2091     Parameters
2092     ----------
2093     A : array-like(M, N)
2094         The matrix to be displayed.
2095 
2096     fignum : None or int or False
2097         If *None*, create a new figure window with automatic numbering.
2098 
2099         If a nonzero integer, draw into the figure with the given number
2100         (create it if it does not exist).
2101 
2102         If 0, use the current axes (or create one if it does not exist).
2103 
2104         .. note::
2105 
2106            Because of how `.Axes.matshow` tries to set the figure aspect
2107            ratio to be the one of the array, strange things may happen if you
2108            reuse an existing figure.
2109 
2110     Returns
2111     -------
2112     image : `~matplotlib.image.AxesImage`
2113 
2114     Other Parameters
2115     ----------------
2116     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2117 
2118     """
2119     A = np.asanyarray(A)
2120     if fignum == 0:
2121         ax = gca()
2122     else:
2123         # Extract actual aspect ratio of array and make appropriately sized
2124         # figure.
2125         fig = figure(fignum, figsize=figaspect(A))
2126         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2127     im = ax.matshow(A, **kwargs)
2128     sci(im)
2129     return im
2130 
2131 
2132 def polar(*args, **kwargs):
2133     """
2134     Make a polar plot.
2135 
2136     call signature::
2137 
2138       polar(theta, r, **kwargs)
2139 
2140     Multiple *theta*, *r* arguments are supported, with format
2141     strings, as in :func:`~matplotlib.pyplot.plot`.
2142 
2143     """
2144     # If an axis already exists, check if it has a polar projection
2145     if gcf().get_axes():
2146         if not isinstance(gca(), PolarAxes):
2147             cbook._warn_external('Trying to create polar plot on an axis '
2148                                  'that does not have a polar projection.')
2149     ax = gca(polar=True)
2150     ret = ax.plot(*args, **kwargs)
2151     return ret
2152 
2153 
2154 def plotfile(fname, cols=(0,), plotfuncs=None,
2155              comments='#', skiprows=0, checkrows=5, delimiter=',',
2156              names=None, subplots=True, newfig=True, **kwargs):
2157     """
2158     Plot the data in a file.
2159 
2160     *cols* is a sequence of column identifiers to plot.  An identifier
2161     is either an int or a string.  If it is an int, it indicates the
2162     column number.  If it is a string, it indicates the column header.
2163     matplotlib will make column headers lower case, replace spaces with
2164     underscores, and remove all illegal characters; so ``'Adj Close*'``
2165     will have name ``'adj_close'``.
2166 
2167     - If len(*cols*) == 1, only that column will be plotted on the *y* axis.
2168 
2169     - If len(*cols*) > 1, the first element will be an identifier for
2170       data for the *x* axis and the remaining elements will be the
2171       column indexes for multiple subplots if *subplots* is *True*
2172       (the default), or for lines in a single subplot if *subplots*
2173       is *False*.
2174 
2175     *plotfuncs*, if not *None*, is a dictionary mapping identifier to
2176     an :class:`~matplotlib.axes.Axes` plotting function as a string.
2177     Default is 'plot', other choices are 'semilogy', 'fill', 'bar',
2178     etc.  You must use the same type of identifier in the *cols*
2179     vector as you use in the *plotfuncs* dictionary, e.g., integer
2180     column numbers in both or column names in both. If *subplots*
2181     is *False*, then including any function such as 'semilogy'
2182     that changes the axis scaling will set the scaling for all
2183     columns.
2184 
2185     - *comments*: the character used to indicate the start of a comment
2186       in the file, or *None* to switch off the removal of comments
2187 
2188     - *skiprows*: is the number of rows from the top to skip
2189 
2190     - *checkrows*: is the number of rows to check to validate the column
2191       data type.  When set to zero all rows are validated.
2192 
2193     - *delimiter*: is the character(s) separating row items
2194 
2195     - *names*: if not None, is a list of header names.  In this case, no
2196       header will be read from the file
2197 
2198     If *newfig* is *True*, the plot always will be made in a new figure;
2199     if *False*, it will be made in the current figure if one exists,
2200     else in a new figure.
2201 
2202     kwargs are passed on to plotting functions.
2203 
2204     Example usage::
2205 
2206       # plot the 2nd and 4th column against the 1st in two subplots
2207       plotfile(fname, (0,1,3))
2208 
2209       # plot using column names; specify an alternate plot type for volume
2210       plotfile(fname, ('date', 'volume', 'adj_close'),
2211                                     plotfuncs={'volume': 'semilogy'})
2212 
2213     Note: plotfile is intended as a convenience for quickly plotting
2214     data from flat files; it is not intended as an alternative
2215     interface to general plotting with pyplot or matplotlib.
2216     """
2217 
2218     if newfig:
2219         fig = figure()
2220     else:
2221         fig = gcf()
2222 
2223     if len(cols) < 1:
2224         raise ValueError('must have at least one column of data')
2225 
2226     if plotfuncs is None:
2227         plotfuncs = {}
2228     with cbook._suppress_matplotlib_deprecation_warning():
2229         r = mlab._csv2rec(fname, comments=comments, skiprows=skiprows,
2230                           checkrows=checkrows, delimiter=delimiter,
2231                           names=names)
2232 
2233     def getname_val(identifier):
2234         'return the name and column data for identifier'
2235         if isinstance(identifier, str):
2236             return identifier, r[identifier]
2237         elif isinstance(identifier, Number):
2238             name = r.dtype.names[int(identifier)]
2239             return name, r[name]
2240         else:
2241             raise TypeError('identifier must be a string or integer')
2242 
2243     xname, x = getname_val(cols[0])
2244     ynamelist = []
2245 
2246     if len(cols) == 1:
2247         ax1 = fig.add_subplot(1, 1, 1)
2248         funcname = plotfuncs.get(cols[0], 'plot')
2249         func = getattr(ax1, funcname)
2250         func(x, **kwargs)
2251         ax1.set_ylabel(xname)
2252     else:
2253         N = len(cols)
2254         for i in range(1, N):
2255             if subplots:
2256                 if i == 1:
2257                     ax = ax1 = fig.add_subplot(N - 1, 1, i)
2258                 else:
2259                     ax = fig.add_subplot(N - 1, 1, i, sharex=ax1)
2260             elif i == 1:
2261                 ax = fig.add_subplot(1, 1, 1)
2262 
2263             yname, y = getname_val(cols[i])
2264             ynamelist.append(yname)
2265 
2266             funcname = plotfuncs.get(cols[i], 'plot')
2267             func = getattr(ax, funcname)
2268 
2269             func(x, y, **kwargs)
2270             if subplots:
2271                 ax.set_ylabel(yname)
2272             if ax.is_last_row():
2273                 ax.set_xlabel(xname)
2274             else:
2275                 ax.set_xlabel('')
2276 
2277     if not subplots:
2278         ax.legend(ynamelist)
2279 
2280     if xname == 'date':
2281         fig.autofmt_xdate()
2282 
2283 
2284 # If rcParams['backend_fallback'] is true, and an interactive backend is
2285 # requested, ignore rcParams['backend'] and force selection of a backend that
2286 # is compatible with the current running interactive framework.
2287 if (rcParams["backend_fallback"]
2288         and dict.__getitem__(rcParams, "backend") in _interactive_bk
2289         and _get_running_interactive_framework()):
2290     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2291 # Set up the backend.
2292 switch_backend(rcParams["backend"])
2293 
2294 # Just to be safe.  Interactive mode can be turned on without
2295 # calling `plt.ion()` so register it again here.
2296 # This is safe because multiple calls to `install_repl_displayhook`
2297 # are no-ops and the registered function respect `mpl.is_interactive()`
2298 # to determine if they should trigger a draw.
2299 install_repl_displayhook()
2300 
2301 
2302 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2303 
2304 
2305 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2306 @docstring.copy(Figure.figimage)
2307 def figimage(
2308         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2309         vmax=None, origin=None, resize=False, **kwargs):
2310     return gcf().figimage(
2311         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2312         vmax=vmax, origin=origin, resize=resize, **kwargs)
2313 
2314 
2315 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2316 @docstring.copy(Figure.text)
2317 def figtext(
2318         x, y, s, fontdict=None,
2319         withdash=cbook.deprecation._deprecated_parameter, **kwargs):
2320     return gcf().text(
2321         x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)
2322 
2323 
2324 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2325 @docstring.copy(Figure.ginput)
2326 def ginput(
2327         n=1, timeout=30, show_clicks=True, mouse_add=1, mouse_pop=3,
2328         mouse_stop=2):
2329     return gcf().ginput(
2330         n=n, timeout=timeout, show_clicks=show_clicks,
2331         mouse_add=mouse_add, mouse_pop=mouse_pop,
2332         mouse_stop=mouse_stop)
2333 
2334 
2335 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2336 @docstring.copy(Figure.suptitle)
2337 def suptitle(t, **kwargs):
2338     return gcf().suptitle(t, **kwargs)
2339 
2340 
2341 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2342 @docstring.copy(Figure.waitforbuttonpress)
2343 def waitforbuttonpress(timeout=-1):
2344     return gcf().waitforbuttonpress(timeout=timeout)
2345 
2346 
2347 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2348 @docstring.copy(Axes.acorr)
2349 def acorr(x, *, data=None, **kwargs):
2350     return gca().acorr(
2351         x, **({"data": data} if data is not None else {}), **kwargs)
2352 
2353 
2354 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2355 @docstring.copy(Axes.angle_spectrum)
2356 def angle_spectrum(
2357         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2358         data=None, **kwargs):
2359     return gca().angle_spectrum(
2360         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2361         **({"data": data} if data is not None else {}), **kwargs)
2362 
2363 
2364 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2365 @docstring.copy(Axes.annotate)
2366 def annotate(s, xy, *args, **kwargs):
2367     return gca().annotate(s, xy, *args, **kwargs)
2368 
2369 
2370 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2371 @docstring.copy(Axes.arrow)
2372 def arrow(x, y, dx, dy, **kwargs):
2373     return gca().arrow(x, y, dx, dy, **kwargs)
2374 
2375 
2376 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2377 @docstring.copy(Axes.autoscale)
2378 def autoscale(enable=True, axis='both', tight=None):
2379     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2380 
2381 
2382 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2383 @docstring.copy(Axes.axhline)
2384 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2385     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2386 
2387 
2388 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2389 @docstring.copy(Axes.axhspan)
2390 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2391     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2392 
2393 
2394 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2395 @docstring.copy(Axes.axis)
2396 def axis(*args, **kwargs):
2397     return gca().axis(*args, **kwargs)
2398 
2399 
2400 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2401 @docstring.copy(Axes.axvline)
2402 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2403     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2404 
2405 
2406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2407 @docstring.copy(Axes.axvspan)
2408 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2409     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2410 
2411 
2412 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2413 @docstring.copy(Axes.bar)
2414 def bar(
2415         x, height, width=0.8, bottom=None, *, align='center',
2416         data=None, **kwargs):
2417     return gca().bar(
2418         x, height, width=width, bottom=bottom, align=align,
2419         **({"data": data} if data is not None else {}), **kwargs)
2420 
2421 
2422 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2423 @docstring.copy(Axes.barbs)
2424 def barbs(*args, data=None, **kw):
2425     return gca().barbs(
2426         *args, **({"data": data} if data is not None else {}), **kw)
2427 
2428 
2429 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2430 @docstring.copy(Axes.barh)
2431 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2432     return gca().barh(
2433         y, width, height=height, left=left, align=align, **kwargs)
2434 
2435 
2436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2437 @docstring.copy(Axes.boxplot)
2438 def boxplot(
2439         x, notch=None, sym=None, vert=None, whis=None,
2440         positions=None, widths=None, patch_artist=None,
2441         bootstrap=None, usermedians=None, conf_intervals=None,
2442         meanline=None, showmeans=None, showcaps=None, showbox=None,
2443         showfliers=None, boxprops=None, labels=None, flierprops=None,
2444         medianprops=None, meanprops=None, capprops=None,
2445         whiskerprops=None, manage_ticks=True, autorange=False,
2446         zorder=None, *, data=None):
2447     return gca().boxplot(
2448         x, notch=notch, sym=sym, vert=vert, whis=whis,
2449         positions=positions, widths=widths, patch_artist=patch_artist,
2450         bootstrap=bootstrap, usermedians=usermedians,
2451         conf_intervals=conf_intervals, meanline=meanline,
2452         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2453         showfliers=showfliers, boxprops=boxprops, labels=labels,
2454         flierprops=flierprops, medianprops=medianprops,
2455         meanprops=meanprops, capprops=capprops,
2456         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2457         autorange=autorange, zorder=zorder, **({"data": data} if data
2458         is not None else {}))
2459 
2460 
2461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2462 @docstring.copy(Axes.broken_barh)
2463 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2464     return gca().broken_barh(
2465         xranges, yrange, **({"data": data} if data is not None else
2466         {}), **kwargs)
2467 
2468 
2469 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2470 @docstring.copy(Axes.cla)
2471 def cla():
2472     return gca().cla()
2473 
2474 
2475 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2476 @docstring.copy(Axes.clabel)
2477 def clabel(CS, *args, **kwargs):
2478     return gca().clabel(CS, *args, **kwargs)
2479 
2480 
2481 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2482 @docstring.copy(Axes.cohere)
2483 def cohere(
2484         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2485         window=mlab.window_hanning, noverlap=0, pad_to=None,
2486         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2487     return gca().cohere(
2488         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2489         noverlap=noverlap, pad_to=pad_to, sides=sides,
2490         scale_by_freq=scale_by_freq, **({"data": data} if data is not
2491         None else {}), **kwargs)
2492 
2493 
2494 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2495 @docstring.copy(Axes.contour)
2496 def contour(*args, data=None, **kwargs):
2497     __ret = gca().contour(
2498         *args, **({"data": data} if data is not None else {}),
2499         **kwargs)
2500     if __ret._A is not None: sci(__ret)  # noqa
2501     return __ret
2502 
2503 
2504 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2505 @docstring.copy(Axes.contourf)
2506 def contourf(*args, data=None, **kwargs):
2507     __ret = gca().contourf(
2508         *args, **({"data": data} if data is not None else {}),
2509         **kwargs)
2510     if __ret._A is not None: sci(__ret)  # noqa
2511     return __ret
2512 
2513 
2514 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2515 @docstring.copy(Axes.csd)
2516 def csd(
2517         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2518         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2519         return_line=None, *, data=None, **kwargs):
2520     return gca().csd(
2521         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2522         noverlap=noverlap, pad_to=pad_to, sides=sides,
2523         scale_by_freq=scale_by_freq, return_line=return_line,
2524         **({"data": data} if data is not None else {}), **kwargs)
2525 
2526 
2527 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2528 @docstring.copy(Axes.errorbar)
2529 def errorbar(
2530         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2531         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2532         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2533         capthick=None, *, data=None, **kwargs):
2534     return gca().errorbar(
2535         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2536         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2537         lolims=lolims, uplims=uplims, xlolims=xlolims,
2538         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2539         **({"data": data} if data is not None else {}), **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @docstring.copy(Axes.eventplot)
2544 def eventplot(
2545         positions, orientation='horizontal', lineoffsets=1,
2546         linelengths=1, linewidths=None, colors=None,
2547         linestyles='solid', *, data=None, **kwargs):
2548     return gca().eventplot(
2549         positions, orientation=orientation, lineoffsets=lineoffsets,
2550         linelengths=linelengths, linewidths=linewidths, colors=colors,
2551         linestyles=linestyles, **({"data": data} if data is not None
2552         else {}), **kwargs)
2553 
2554 
2555 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2556 @docstring.copy(Axes.fill)
2557 def fill(*args, data=None, **kwargs):
2558     return gca().fill(
2559         *args, **({"data": data} if data is not None else {}),
2560         **kwargs)
2561 
2562 
2563 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2564 @docstring.copy(Axes.fill_between)
2565 def fill_between(
2566         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2567         data=None, **kwargs):
2568     return gca().fill_between(
2569         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2570         **({"data": data} if data is not None else {}), **kwargs)
2571 
2572 
2573 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2574 @docstring.copy(Axes.fill_betweenx)
2575 def fill_betweenx(
2576         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2577         data=None, **kwargs):
2578     return gca().fill_betweenx(
2579         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2580         **({"data": data} if data is not None else {}), **kwargs)
2581 
2582 
2583 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2584 @docstring.copy(Axes.grid)
2585 def grid(b=None, which='major', axis='both', **kwargs):
2586     return gca().grid(b=b, which=which, axis=axis, **kwargs)
2587 
2588 
2589 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2590 @docstring.copy(Axes.hexbin)
2591 def hexbin(
2592         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2593         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2594         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2595         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2596         data=None, **kwargs):
2597     __ret = gca().hexbin(
2598         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2599         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2600         vmax=vmax, alpha=alpha, linewidths=linewidths,
2601         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2602         mincnt=mincnt, marginals=marginals, **({"data": data} if data
2603         is not None else {}), **kwargs)
2604     sci(__ret)
2605     return __ret
2606 
2607 
2608 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2609 @docstring.copy(Axes.hist)
2610 def hist(
2611         x, bins=None, range=None, density=None, weights=None,
2612         cumulative=False, bottom=None, histtype='bar', align='mid',
2613         orientation='vertical', rwidth=None, log=False, color=None,
2614         label=None, stacked=False, normed=None, *, data=None,
2615         **kwargs):
2616     return gca().hist(
2617         x, bins=bins, range=range, density=density, weights=weights,
2618         cumulative=cumulative, bottom=bottom, histtype=histtype,
2619         align=align, orientation=orientation, rwidth=rwidth, log=log,
2620         color=color, label=label, stacked=stacked, normed=normed,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622 
2623 
2624 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2625 @docstring.copy(Axes.hist2d)
2626 def hist2d(
2627         x, y, bins=10, range=None, density=False, weights=None,
2628         cmin=None, cmax=None, *, data=None, **kwargs):
2629     __ret = gca().hist2d(
2630         x, y, bins=bins, range=range, density=density,
2631         weights=weights, cmin=cmin, cmax=cmax, **({"data": data} if
2632         data is not None else {}), **kwargs)
2633     sci(__ret[-1])
2634     return __ret
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @docstring.copy(Axes.hlines)
2639 def hlines(
2640         y, xmin, xmax, colors='k', linestyles='solid', label='', *,
2641         data=None, **kwargs):
2642     return gca().hlines(
2643         y, xmin, xmax, colors=colors, linestyles=linestyles,
2644         label=label, **({"data": data} if data is not None else {}),
2645         **kwargs)
2646 
2647 
2648 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2649 @docstring.copy(Axes.imshow)
2650 def imshow(
2651         X, cmap=None, norm=None, aspect=None, interpolation=None,
2652         alpha=None, vmin=None, vmax=None, origin=None, extent=None,
2653         shape=cbook.deprecation._deprecated_parameter, filternorm=1,
2654         filterrad=4.0, imlim=cbook.deprecation._deprecated_parameter,
2655         resample=None, url=None, *, data=None, **kwargs):
2656     __ret = gca().imshow(
2657         X, cmap=cmap, norm=norm, aspect=aspect,
2658         interpolation=interpolation, alpha=alpha, vmin=vmin,
2659         vmax=vmax, origin=origin, extent=extent, shape=shape,
2660         filternorm=filternorm, filterrad=filterrad, imlim=imlim,
2661         resample=resample, url=url, **({"data": data} if data is not
2662         None else {}), **kwargs)
2663     sci(__ret)
2664     return __ret
2665 
2666 
2667 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2668 @docstring.copy(Axes.legend)
2669 def legend(*args, **kwargs):
2670     return gca().legend(*args, **kwargs)
2671 
2672 
2673 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2674 @docstring.copy(Axes.locator_params)
2675 def locator_params(axis='both', tight=None, **kwargs):
2676     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2677 
2678 
2679 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2680 @docstring.copy(Axes.loglog)
2681 def loglog(*args, **kwargs):
2682     return gca().loglog(*args, **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @docstring.copy(Axes.magnitude_spectrum)
2687 def magnitude_spectrum(
2688         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2689         scale=None, *, data=None, **kwargs):
2690     return gca().magnitude_spectrum(
2691         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2692         scale=scale, **({"data": data} if data is not None else {}),
2693         **kwargs)
2694 
2695 
2696 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2697 @docstring.copy(Axes.margins)
2698 def margins(*margins, x=None, y=None, tight=True):
2699     return gca().margins(*margins, x=x, y=y, tight=tight)
2700 
2701 
2702 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2703 @docstring.copy(Axes.minorticks_off)
2704 def minorticks_off():
2705     return gca().minorticks_off()
2706 
2707 
2708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2709 @docstring.copy(Axes.minorticks_on)
2710 def minorticks_on():
2711     return gca().minorticks_on()
2712 
2713 
2714 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2715 @docstring.copy(Axes.pcolor)
2716 def pcolor(
2717         *args, alpha=None, norm=None, cmap=None, vmin=None,
2718         vmax=None, data=None, **kwargs):
2719     __ret = gca().pcolor(
2720         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2721         vmax=vmax, **({"data": data} if data is not None else {}),
2722         **kwargs)
2723     sci(__ret)
2724     return __ret
2725 
2726 
2727 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2728 @docstring.copy(Axes.pcolormesh)
2729 def pcolormesh(
2730         *args, alpha=None, norm=None, cmap=None, vmin=None,
2731         vmax=None, shading='flat', antialiased=False, data=None,
2732         **kwargs):
2733     __ret = gca().pcolormesh(
2734         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2735         vmax=vmax, shading=shading, antialiased=antialiased,
2736         **({"data": data} if data is not None else {}), **kwargs)
2737     sci(__ret)
2738     return __ret
2739 
2740 
2741 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2742 @docstring.copy(Axes.phase_spectrum)
2743 def phase_spectrum(
2744         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2745         data=None, **kwargs):
2746     return gca().phase_spectrum(
2747         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2748         **({"data": data} if data is not None else {}), **kwargs)
2749 
2750 
2751 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2752 @docstring.copy(Axes.pie)
2753 def pie(
2754         x, explode=None, labels=None, colors=None, autopct=None,
2755         pctdistance=0.6, shadow=False, labeldistance=1.1,
2756         startangle=None, radius=None, counterclock=True,
2757         wedgeprops=None, textprops=None, center=(0, 0), frame=False,
2758         rotatelabels=False, *, data=None):
2759     return gca().pie(
2760         x, explode=explode, labels=labels, colors=colors,
2761         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2762         labeldistance=labeldistance, startangle=startangle,
2763         radius=radius, counterclock=counterclock,
2764         wedgeprops=wedgeprops, textprops=textprops, center=center,
2765         frame=frame, rotatelabels=rotatelabels, **({"data": data} if
2766         data is not None else {}))
2767 
2768 
2769 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2770 @docstring.copy(Axes.plot)
2771 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2772     return gca().plot(
2773         *args, scalex=scalex, scaley=scaley, **({"data": data} if data
2774         is not None else {}), **kwargs)
2775 
2776 
2777 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2778 @docstring.copy(Axes.plot_date)
2779 def plot_date(
2780         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2781         data=None, **kwargs):
2782     return gca().plot_date(
2783         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate, **({"data":
2784         data} if data is not None else {}), **kwargs)
2785 
2786 
2787 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2788 @docstring.copy(Axes.psd)
2789 def psd(
2790         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2791         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2792         return_line=None, *, data=None, **kwargs):
2793     return gca().psd(
2794         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2795         noverlap=noverlap, pad_to=pad_to, sides=sides,
2796         scale_by_freq=scale_by_freq, return_line=return_line,
2797         **({"data": data} if data is not None else {}), **kwargs)
2798 
2799 
2800 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2801 @docstring.copy(Axes.quiver)
2802 def quiver(*args, data=None, **kw):
2803     __ret = gca().quiver(
2804         *args, **({"data": data} if data is not None else {}), **kw)
2805     sci(__ret)
2806     return __ret
2807 
2808 
2809 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2810 @docstring.copy(Axes.quiverkey)
2811 def quiverkey(Q, X, Y, U, label, **kw):
2812     return gca().quiverkey(Q, X, Y, U, label, **kw)
2813 
2814 
2815 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2816 @docstring.copy(Axes.scatter)
2817 def scatter(
2818         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2819         vmin=None, vmax=None, alpha=None, linewidths=None, verts=None,
2820         edgecolors=None, *, plotnonfinite=False, data=None, **kwargs):
2821     __ret = gca().scatter(
2822         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2823         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2824         verts=verts, edgecolors=edgecolors,
2825         plotnonfinite=plotnonfinite, **({"data": data} if data is not
2826         None else {}), **kwargs)
2827     sci(__ret)
2828     return __ret
2829 
2830 
2831 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2832 @docstring.copy(Axes.semilogx)
2833 def semilogx(*args, **kwargs):
2834     return gca().semilogx(*args, **kwargs)
2835 
2836 
2837 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2838 @docstring.copy(Axes.semilogy)
2839 def semilogy(*args, **kwargs):
2840     return gca().semilogy(*args, **kwargs)
2841 
2842 
2843 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2844 @docstring.copy(Axes.specgram)
2845 def specgram(
2846         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2847         noverlap=None, cmap=None, xextent=None, pad_to=None,
2848         sides=None, scale_by_freq=None, mode=None, scale=None,
2849         vmin=None, vmax=None, *, data=None, **kwargs):
2850     __ret = gca().specgram(
2851         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2852         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2853         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2854         scale=scale, vmin=vmin, vmax=vmax, **({"data": data} if data
2855         is not None else {}), **kwargs)
2856     sci(__ret[-1])
2857     return __ret
2858 
2859 
2860 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2861 @docstring.copy(Axes.spy)
2862 def spy(
2863         Z, precision=0, marker=None, markersize=None, aspect='equal',
2864         origin='upper', **kwargs):
2865     __ret = gca().spy(
2866         Z, precision=precision, marker=marker, markersize=markersize,
2867         aspect=aspect, origin=origin, **kwargs)
2868     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2869     return __ret
2870 
2871 
2872 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2873 @docstring.copy(Axes.stackplot)
2874 def stackplot(
2875         x, *args, labels=(), colors=None, baseline='zero', data=None,
2876         **kwargs):
2877     return gca().stackplot(
2878         x, *args, labels=labels, colors=colors, baseline=baseline,
2879         **({"data": data} if data is not None else {}), **kwargs)
2880 
2881 
2882 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2883 @docstring.copy(Axes.stem)
2884 def stem(
2885         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2886         label=None, use_line_collection=False, data=None):
2887     return gca().stem(
2888         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2889         bottom=bottom, label=label,
2890         use_line_collection=use_line_collection, **({"data": data} if
2891         data is not None else {}))
2892 
2893 
2894 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2895 @docstring.copy(Axes.step)
2896 def step(x, y, *args, where='pre', data=None, **kwargs):
2897     return gca().step(
2898         x, y, *args, where=where, **({"data": data} if data is not
2899         None else {}), **kwargs)
2900 
2901 
2902 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2903 @docstring.copy(Axes.streamplot)
2904 def streamplot(
2905         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2906         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2907         transform=None, zorder=None, start_points=None, maxlength=4.0,
2908         integration_direction='both', *, data=None):
2909     __ret = gca().streamplot(
2910         x, y, u, v, density=density, linewidth=linewidth, color=color,
2911         cmap=cmap, norm=norm, arrowsize=arrowsize,
2912         arrowstyle=arrowstyle, minlength=minlength,
2913         transform=transform, zorder=zorder, start_points=start_points,
2914         maxlength=maxlength,
2915         integration_direction=integration_direction, **({"data": data}
2916         if data is not None else {}))
2917     sci(__ret.lines)
2918     return __ret
2919 
2920 
2921 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2922 @docstring.copy(Axes.table)
2923 def table(
2924         cellText=None, cellColours=None, cellLoc='right',
2925         colWidths=None, rowLabels=None, rowColours=None,
2926         rowLoc='left', colLabels=None, colColours=None,
2927         colLoc='center', loc='bottom', bbox=None, edges='closed',
2928         **kwargs):
2929     return gca().table(
2930         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2931         colWidths=colWidths, rowLabels=rowLabels,
2932         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2933         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2934         edges=edges, **kwargs)
2935 
2936 
2937 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2938 @docstring.copy(Axes.text)
2939 def text(
2940         x, y, s, fontdict=None,
2941         withdash=cbook.deprecation._deprecated_parameter, **kwargs):
2942     return gca().text(x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)
2943 
2944 
2945 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2946 @docstring.copy(Axes.tick_params)
2947 def tick_params(axis='both', **kwargs):
2948     return gca().tick_params(axis=axis, **kwargs)
2949 
2950 
2951 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2952 @docstring.copy(Axes.ticklabel_format)
2953 def ticklabel_format(
2954         *, axis='both', style='', scilimits=None, useOffset=None,
2955         useLocale=None, useMathText=None):
2956     return gca().ticklabel_format(
2957         axis=axis, style=style, scilimits=scilimits,
2958         useOffset=useOffset, useLocale=useLocale,
2959         useMathText=useMathText)
2960 
2961 
2962 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2963 @docstring.copy(Axes.tricontour)
2964 def tricontour(*args, **kwargs):
2965     __ret = gca().tricontour(*args, **kwargs)
2966     if __ret._A is not None: sci(__ret)  # noqa
2967     return __ret
2968 
2969 
2970 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2971 @docstring.copy(Axes.tricontourf)
2972 def tricontourf(*args, **kwargs):
2973     __ret = gca().tricontourf(*args, **kwargs)
2974     if __ret._A is not None: sci(__ret)  # noqa
2975     return __ret
2976 
2977 
2978 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2979 @docstring.copy(Axes.tripcolor)
2980 def tripcolor(
2981         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2982         shading='flat', facecolors=None, **kwargs):
2983     __ret = gca().tripcolor(
2984         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2985         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2986     sci(__ret)
2987     return __ret
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @docstring.copy(Axes.triplot)
2992 def triplot(*args, **kwargs):
2993     return gca().triplot(*args, **kwargs)
2994 
2995 
2996 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2997 @docstring.copy(Axes.violinplot)
2998 def violinplot(
2999         dataset, positions=None, vert=True, widths=0.5,
3000         showmeans=False, showextrema=True, showmedians=False,
3001         points=100, bw_method=None, *, data=None):
3002     return gca().violinplot(
3003         dataset, positions=positions, vert=vert, widths=widths,
3004         showmeans=showmeans, showextrema=showextrema,
3005         showmedians=showmedians, points=points, bw_method=bw_method,
3006         **({"data": data} if data is not None else {}))
3007 
3008 
3009 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3010 @docstring.copy(Axes.vlines)
3011 def vlines(
3012         x, ymin, ymax, colors='k', linestyles='solid', label='', *,
3013         data=None, **kwargs):
3014     return gca().vlines(
3015         x, ymin, ymax, colors=colors, linestyles=linestyles,
3016         label=label, **({"data": data} if data is not None else {}),
3017         **kwargs)
3018 
3019 
3020 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3021 @docstring.copy(Axes.xcorr)
3022 def xcorr(
3023         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3024         maxlags=10, *, data=None, **kwargs):
3025     return gca().xcorr(
3026         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3027         maxlags=maxlags, **({"data": data} if data is not None else
3028         {}), **kwargs)
3029 
3030 
3031 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3032 @docstring.copy(Axes._sci)
3033 def sci(im):
3034     return gca()._sci(im)
3035 
3036 
3037 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3038 @docstring.copy(Axes.set_title)
3039 def title(label, fontdict=None, loc='center', pad=None, **kwargs):
3040     return gca().set_title(
3041         label, fontdict=fontdict, loc=loc, pad=pad, **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @docstring.copy(Axes.set_xlabel)
3046 def xlabel(xlabel, fontdict=None, labelpad=None, **kwargs):
3047     return gca().set_xlabel(
3048         xlabel, fontdict=fontdict, labelpad=labelpad, **kwargs)
3049 
3050 
3051 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3052 @docstring.copy(Axes.set_ylabel)
3053 def ylabel(ylabel, fontdict=None, labelpad=None, **kwargs):
3054     return gca().set_ylabel(
3055         ylabel, fontdict=fontdict, labelpad=labelpad, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @docstring.copy(Axes.set_xscale)
3060 def xscale(value, **kwargs):
3061     return gca().set_xscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 @docstring.copy(Axes.set_yscale)
3066 def yscale(value, **kwargs):
3067     return gca().set_yscale(value, **kwargs)
3068 
3069 
3070 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3071 def autumn():
3072     """
3073     Set the colormap to "autumn".
3074 
3075     This changes the default colormap as well as the colormap of the current
3076     image if there is one. See ``help(colormaps)`` for more information.
3077     """
3078     set_cmap("autumn")
3079 
3080 
3081 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3082 def bone():
3083     """
3084     Set the colormap to "bone".
3085 
3086     This changes the default colormap as well as the colormap of the current
3087     image if there is one. See ``help(colormaps)`` for more information.
3088     """
3089     set_cmap("bone")
3090 
3091 
3092 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3093 def cool():
3094     """
3095     Set the colormap to "cool".
3096 
3097     This changes the default colormap as well as the colormap of the current
3098     image if there is one. See ``help(colormaps)`` for more information.
3099     """
3100     set_cmap("cool")
3101 
3102 
3103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3104 def copper():
3105     """
3106     Set the colormap to "copper".
3107 
3108     This changes the default colormap as well as the colormap of the current
3109     image if there is one. See ``help(colormaps)`` for more information.
3110     """
3111     set_cmap("copper")
3112 
3113 
3114 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3115 def flag():
3116     """
3117     Set the colormap to "flag".
3118 
3119     This changes the default colormap as well as the colormap of the current
3120     image if there is one. See ``help(colormaps)`` for more information.
3121     """
3122     set_cmap("flag")
3123 
3124 
3125 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3126 def gray():
3127     """
3128     Set the colormap to "gray".
3129 
3130     This changes the default colormap as well as the colormap of the current
3131     image if there is one. See ``help(colormaps)`` for more information.
3132     """
3133     set_cmap("gray")
3134 
3135 
3136 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3137 def hot():
3138     """
3139     Set the colormap to "hot".
3140 
3141     This changes the default colormap as well as the colormap of the current
3142     image if there is one. See ``help(colormaps)`` for more information.
3143     """
3144     set_cmap("hot")
3145 
3146 
3147 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3148 def hsv():
3149     """
3150     Set the colormap to "hsv".
3151 
3152     This changes the default colormap as well as the colormap of the current
3153     image if there is one. See ``help(colormaps)`` for more information.
3154     """
3155     set_cmap("hsv")
3156 
3157 
3158 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3159 def jet():
3160     """
3161     Set the colormap to "jet".
3162 
3163     This changes the default colormap as well as the colormap of the current
3164     image if there is one. See ``help(colormaps)`` for more information.
3165     """
3166     set_cmap("jet")
3167 
3168 
3169 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3170 def pink():
3171     """
3172     Set the colormap to "pink".
3173 
3174     This changes the default colormap as well as the colormap of the current
3175     image if there is one. See ``help(colormaps)`` for more information.
3176     """
3177     set_cmap("pink")
3178 
3179 
3180 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3181 def prism():
3182     """
3183     Set the colormap to "prism".
3184 
3185     This changes the default colormap as well as the colormap of the current
3186     image if there is one. See ``help(colormaps)`` for more information.
3187     """
3188     set_cmap("prism")
3189 
3190 
3191 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3192 def spring():
3193     """
3194     Set the colormap to "spring".
3195 
3196     This changes the default colormap as well as the colormap of the current
3197     image if there is one. See ``help(colormaps)`` for more information.
3198     """
3199     set_cmap("spring")
3200 
3201 
3202 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3203 def summer():
3204     """
3205     Set the colormap to "summer".
3206 
3207     This changes the default colormap as well as the colormap of the current
3208     image if there is one. See ``help(colormaps)`` for more information.
3209     """
3210     set_cmap("summer")
3211 
3212 
3213 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3214 def winter():
3215     """
3216     Set the colormap to "winter".
3217 
3218     This changes the default colormap as well as the colormap of the current
3219     image if there is one. See ``help(colormaps)`` for more information.
3220     """
3221     set_cmap("winter")
3222 
3223 
3224 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3225 def magma():
3226     """
3227     Set the colormap to "magma".
3228 
3229     This changes the default colormap as well as the colormap of the current
3230     image if there is one. See ``help(colormaps)`` for more information.
3231     """
3232     set_cmap("magma")
3233 
3234 
3235 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3236 def inferno():
3237     """
3238     Set the colormap to "inferno".
3239 
3240     This changes the default colormap as well as the colormap of the current
3241     image if there is one. See ``help(colormaps)`` for more information.
3242     """
3243     set_cmap("inferno")
3244 
3245 
3246 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3247 def plasma():
3248     """
3249     Set the colormap to "plasma".
3250 
3251     This changes the default colormap as well as the colormap of the current
3252     image if there is one. See ``help(colormaps)`` for more information.
3253     """
3254     set_cmap("plasma")
3255 
3256 
3257 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3258 def viridis():
3259     """
3260     Set the colormap to "viridis".
3261 
3262     This changes the default colormap as well as the colormap of the current
3263     image if there is one. See ``help(colormaps)`` for more information.
3264     """
3265     set_cmap("viridis")
3266 
3267 
3268 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3269 def nipy_spectral():
3270     """
3271     Set the colormap to "nipy_spectral".
3272 
3273     This changes the default colormap as well as the colormap of the current
3274     image if there is one. See ``help(colormaps)`` for more information.
3275     """
3276     set_cmap("nipy_spectral")
3277 
3278 _setup_pyplot_info_docstrings()

</code><intended_behavior>In the `savefig` function, add a pre-check for the figure size directly or ensure that any down-stream method from `pyplot.savefig` that eventually interacts with figure dimensions performs a check to prevent zero-width or zero-height figures from being passed to libpng. This check, similar to the one proposed in `figure.py`, should raise an informative exception if invalid dimensions are identified. This will warn users before an attempt is made to render or save the figure, thereby avoiding the runtime error from libpng.</intended_behavior>]
2025-10-15 20:15:21.539 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 The figure module provides the top-level
3 :class:`~matplotlib.artist.Artist`, the :class:`Figure`, which
4 contains all the plot elements.  The following classes are defined
5 
6 :class:`SubplotParams`
7     control the default spacing of the subplots
8 
9 :class:`Figure`
10     Top level container for all plot elements.
11 
12 """
13 
14 import logging
15 from numbers import Integral
16 
17 import numpy as np
18 
19 from matplotlib import rcParams
20 from matplotlib import backends, docstring, projections
21 from matplotlib import __version__ as _mpl_version
22 from matplotlib import get_backend
23 
24 import matplotlib.artist as martist
25 from matplotlib.artist import Artist, allow_rasterization
26 from matplotlib.backend_bases import FigureCanvasBase
27 import matplotlib.cbook as cbook
28 import matplotlib.colorbar as cbar
29 import matplotlib.image as mimage
30 
31 from matplotlib.axes import Axes, SubplotBase, subplot_class_factory
32 from matplotlib.blocking_input import BlockingMouseInput, BlockingKeyMouseInput
33 from matplotlib.gridspec import GridSpec
34 import matplotlib.legend as mlegend
35 from matplotlib.patches import Rectangle
36 from matplotlib.projections import (get_projection_names,
37                                     process_projection_requirements)
38 from matplotlib.text import Text, TextWithDash
39 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,
40                                    TransformedBbox)
41 import matplotlib._layoutbox as layoutbox
42 from matplotlib.backend_bases import NonGuiException
43 
44 _log = logging.getLogger(__name__)
45 
46 docstring.interpd.update(projection_names=get_projection_names())
47 
48 
49 def _stale_figure_callback(self, val):
50     if self.figure:
51         self.figure.stale = val
52 
53 
54 class AxesStack(cbook.Stack):
55     """
56     Specialization of the `.Stack` to handle all tracking of
57     `~matplotlib.axes.Axes` in a `.Figure`.
58     This stack stores ``key, (ind, axes)`` pairs, where:
59 
60         * **key** should be a hash of the args and kwargs
61           used in generating the Axes.
62         * **ind** is a serial number for tracking the order
63           in which axes were added.
64 
65     The AxesStack is a callable, where ``ax_stack()`` returns
66     the current axes. Alternatively the :meth:`current_key_axes` will
67     return the current key and associated axes.
68 
69     """
70     def __init__(self):
71         super().__init__()
72         self._ind = 0
73 
74     def as_list(self):
75         """
76         Return a list of the Axes instances that have been added to the figure.
77         """
78         ia_list = [a for k, a in self._elements]
79         ia_list.sort()
80         return [a for i, a in ia_list]
81 
82     def get(self, key):
83         """
84         Return the Axes instance that was added with *key*.
85         If it is not present, return *None*.
86         """
87         item = dict(self._elements).get(key)
88         if item is None:
89             return None
90         cbook.warn_deprecated(
91             "2.1",
92             message="Adding an axes using the same arguments as a previous "
93             "axes currently reuses the earlier instance.  In a future "
94             "version, a new instance will always be created and returned.  "
95             "Meanwhile, this warning can be suppressed, and the future "
96             "behavior ensured, by passing a unique label to each axes "
97             "instance.")
98         return item[1]
99 
100     def _entry_from_axes(self, e):
101         ind, k = {a: (ind, k) for k, (ind, a) in self._elements}[e]
102         return (k, (ind, e))
103 
104     def remove(self, a):
105         """Remove the axes from the stack."""
106         super().remove(self._entry_from_axes(a))
107 
108     def bubble(self, a):
109         """
110         Move the given axes, which must already exist in the
111         stack, to the top.
112         """
113         return super().bubble(self._entry_from_axes(a))
114 
115     def add(self, key, a):
116         """
117         Add Axes *a*, with key *key*, to the stack, and return the stack.
118 
119         If *key* is unhashable, replace it by a unique, arbitrary object.
120 
121         If *a* is already on the stack, don't add it again, but
122         return *None*.
123         """
124         # All the error checking may be unnecessary; but this method
125         # is called so seldom that the overhead is negligible.
126         if not isinstance(a, Axes):
127             raise ValueError("second argument, {!r}, is not an Axes".format(a))
128         try:
129             hash(key)
130         except TypeError:
131             key = object()
132 
133         a_existing = self.get(key)
134         if a_existing is not None:
135             super().remove((key, a_existing))
136             cbook._warn_external(
137                 "key {!r} already existed; Axes is being replaced".format(key))
138             # I don't think the above should ever happen.
139 
140         if a in self:
141             return None
142         self._ind += 1
143         return super().push((key, (self._ind, a)))
144 
145     def current_key_axes(self):
146         """
147         Return a tuple of ``(key, axes)`` for the active axes.
148 
149         If no axes exists on the stack, then returns ``(None, None)``.
150         """
151         if not len(self._elements):
152             return self._default, self._default
153         else:
154             key, (index, axes) = self._elements[self._pos]
155             return key, axes
156 
157     def __call__(self):
158         return self.current_key_axes()[1]
159 
160     def __contains__(self, a):
161         return a in self.as_list()
162 
163 
164 class SubplotParams(object):
165     """
166     A class to hold the parameters for a subplot.
167     """
168     def __init__(self, left=None, bottom=None, right=None, top=None,
169                  wspace=None, hspace=None):
170         """
171         All dimensions are fractions of the figure width or height.
172         Defaults are given by :rc:`figure.subplot.[name]`.
173 
174         Parameters
175         ----------
176         left : float
177             The left side of the subplots of the figure.
178 
179         right : float
180             The right side of the subplots of the figure.
181 
182         bottom : float
183             The bottom of the subplots of the figure.
184 
185         top : float
186             The top of the subplots of the figure.
187 
188         wspace : float
189             The amount of width reserved for space between subplots,
190             expressed as a fraction of the average axis width.
191 
192         hspace : float
193             The amount of height reserved for space between subplots,
194             expressed as a fraction of the average axis height.
195         """
196         self.validate = True
197         self.update(left, bottom, right, top, wspace, hspace)
198 
199     def update(self, left=None, bottom=None, right=None, top=None,
200                wspace=None, hspace=None):
201         """
202         Update the dimensions of the passed parameters. *None* means unchanged.
203         """
204         thisleft = getattr(self, 'left', None)
205         thisright = getattr(self, 'right', None)
206         thistop = getattr(self, 'top', None)
207         thisbottom = getattr(self, 'bottom', None)
208         thiswspace = getattr(self, 'wspace', None)
209         thishspace = getattr(self, 'hspace', None)
210 
211         self._update_this('left', left)
212         self._update_this('right', right)
213         self._update_this('bottom', bottom)
214         self._update_this('top', top)
215         self._update_this('wspace', wspace)
216         self._update_this('hspace', hspace)
217 
218         def reset():
219             self.left = thisleft
220             self.right = thisright
221             self.top = thistop
222             self.bottom = thisbottom
223             self.wspace = thiswspace
224             self.hspace = thishspace
225 
226         if self.validate:
227             if self.left >= self.right:
228                 reset()
229                 raise ValueError('left cannot be >= right')
230 
231             if self.bottom >= self.top:
232                 reset()
233                 raise ValueError('bottom cannot be >= top')
234 
235     def _update_this(self, s, val):
236         if val is None:
237             val = getattr(self, s, None)
238             if val is None:
239                 key = 'figure.subplot.' + s
240                 val = rcParams[key]
241 
242         setattr(self, s, val)
243 
244 
245 class Figure(Artist):
246     """
247     The top level container for all the plot elements.
248 
249     The Figure instance supports callbacks through a *callbacks* attribute
250     which is a `.CallbackRegistry` instance.  The events you can connect to
251     are 'dpi_changed', and the callback will be called with ``func(fig)`` where
252     fig is the `Figure` instance.
253 
254     Attributes
255     ----------
256     patch
257         The `.Rectangle` instance representing the figure background patch.
258 
259     suppressComposite
260         For multiple figure images, the figure will make composite images
261         depending on the renderer option_image_nocomposite function.  If
262         *suppressComposite* is a boolean, this will override the renderer.
263     """
264 
265     def __str__(self):
266         return "Figure(%gx%g)" % tuple(self.bbox.size)
267 
268     def __repr__(self):
269         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
270             clsname=self.__class__.__name__,
271             h=self.bbox.size[0], w=self.bbox.size[1],
272             naxes=len(self.axes),
273         )
274 
275     def __init__(self,
276                  figsize=None,
277                  dpi=None,
278                  facecolor=None,
279                  edgecolor=None,
280                  linewidth=0.0,
281                  frameon=None,
282                  subplotpars=None,  # default to rc
283                  tight_layout=None,  # default to rc figure.autolayout
284                  constrained_layout=None,  # default to rc
285                                           #figure.constrained_layout.use
286                  ):
287         """
288         Parameters
289         ----------
290         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
291             Figure dimension ``(width, height)`` in inches.
292 
293         dpi : float, default: :rc:`figure.dpi`
294             Dots per inch.
295 
296         facecolor : default: :rc:`figure.facecolor`
297             The figure patch facecolor.
298 
299         edgecolor : default: :rc:`figure.edgecolor`
300             The figure patch edge color.
301 
302         linewidth : float
303             The linewidth of the frame (i.e. the edge linewidth of the figure
304             patch).
305 
306         frameon : bool, default: :rc:`figure.frameon`
307             If ``False``, suppress drawing the figure background patch.
308 
309         subplotpars : :class:`SubplotParams`
310             Subplot parameters. If not given, the default subplot
311             parameters :rc:`figure.subplot.*` are used.
312 
313         tight_layout : bool or dict, default: :rc:`figure.autolayout`
314             If ``False`` use *subplotpars*. If ``True`` adjust subplot
315             parameters using `.tight_layout` with default padding.
316             When providing a dict containing the keys ``pad``, ``w_pad``,
317             ``h_pad``, and ``rect``, the default `.tight_layout` paddings
318             will be overridden.
319 
320         constrained_layout : bool
321             If ``True`` use constrained layout to adjust positioning of plot
322             elements.  Like ``tight_layout``, but designed to be more
323             flexible.  See
324             :doc:`/tutorials/intermediate/constrainedlayout_guide`
325             for examples.  (Note: does not work with :meth:`.subplot` or
326             :meth:`.subplot2grid`.)
327             Defaults to :rc:`figure.constrained_layout.use`.
328         """
329         super().__init__()
330         # remove the non-figure artist _axes property
331         # as it makes no sense for a figure to be _in_ an axes
332         # this is used by the property methods in the artist base class
333         # which are over-ridden in this class
334         del self._axes
335         self.callbacks = cbook.CallbackRegistry()
336 
337         if figsize is None:
338             figsize = rcParams['figure.figsize']
339         if dpi is None:
340             dpi = rcParams['figure.dpi']
341         if facecolor is None:
342             facecolor = rcParams['figure.facecolor']
343         if edgecolor is None:
344             edgecolor = rcParams['figure.edgecolor']
345         if frameon is None:
346             frameon = rcParams['figure.frameon']
347 
348         if not np.isfinite(figsize).all():
349             raise ValueError('figure size must be finite not '
350                              '{}'.format(figsize))
351         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
352 
353         self.dpi_scale_trans = Affine2D().scale(dpi, dpi)
354         # do not use property as it will trigger
355         self._dpi = dpi
356         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
357 
358         self.transFigure = BboxTransformTo(self.bbox)
359 
360         self.patch = Rectangle(
361             xy=(0, 0), width=1, height=1,
362             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
363             visible=frameon)
364         self._set_artist_props(self.patch)
365         self.patch.set_antialiased(False)
366 
367         FigureCanvasBase(self)  # Set self.canvas.
368         self._suptitle = None
369 
370         if subplotpars is None:
371             subplotpars = SubplotParams()
372 
373         self.subplotpars = subplotpars
374         # constrained_layout:
375         self._layoutbox = None
376         # set in set_constrained_layout_pads()
377         self.set_constrained_layout(constrained_layout)
378 
379         self.set_tight_layout(tight_layout)
380 
381         self._axstack = AxesStack()  # track all figure axes and current axes
382         self.clf()
383         self._cachedRenderer = None
384 
385         # groupers to keep track of x and y labels we want to align.
386         # see self.align_xlabels and self.align_ylabels and
387         # axis._get_tick_boxes_siblings
388         self._align_xlabel_grp = cbook.Grouper()
389         self._align_ylabel_grp = cbook.Grouper()
390 
391         # list of child gridspecs for this figure
392         self._gridspecs = []
393 
394     # TODO: I'd like to dynamically add the _repr_html_ method
395     # to the figure in the right context, but then IPython doesn't
396     # use it, for some reason.
397 
398     def _repr_html_(self):
399         # We can't use "isinstance" here, because then we'd end up importing
400         # webagg unconditionally.
401         if 'WebAgg' in type(self.canvas).__name__:
402             from matplotlib.backends import backend_webagg
403             return backend_webagg.ipython_inline_display(self)
404 
405     def show(self, warn=True):
406         """
407         If using a GUI backend with pyplot, display the figure window.
408 
409         If the figure was not created using
410         :func:`~matplotlib.pyplot.figure`, it will lack a
411         :class:`~matplotlib.backend_bases.FigureManagerBase`, and
412         will raise an AttributeError.
413 
414         .. warning::
415             This does not manage an GUI event loop. Consequently, the figure
416             may only be shown briefly or not shown at all if you or your
417             environment are not managing an event loop.
418 
419             Proper use cases for `.Figure.show` include running this from a
420             GUI application or an IPython shell.
421 
422             If you're running a pure python shell or executing a non-GUI
423             python script, you should use `matplotlib.pyplot.show` instead,
424             which takes care of managing the event loop for you.
425 
426         Parameters
427         ----------
428         warn : bool
429             If ``True`` and we are not running headless (i.e. on Linux with an
430             unset DISPLAY), issue warning when called on a non-GUI backend.
431         """
432         try:
433             manager = getattr(self.canvas, 'manager')
434         except AttributeError as err:
435             raise AttributeError("%s\n"
436                                  "Figure.show works only "
437                                  "for figures managed by pyplot, normally "
438                                  "created by pyplot.figure()." % err)
439 
440         if manager is not None:
441             try:
442                 manager.show()
443                 return
444             except NonGuiException:
445                 pass
446         if (backends._get_running_interactive_framework() != "headless"
447                 and warn):
448             cbook._warn_external('Matplotlib is currently using %s, which is '
449                                  'a non-GUI backend, so cannot show the '
450                                  'figure.' % get_backend())
451 
452     def _get_axes(self):
453         return self._axstack.as_list()
454 
455     axes = property(fget=_get_axes,
456                     doc="List of axes in the Figure. You can access the "
457                         "axes in the Figure through this list. "
458                         "Do not modify the list itself. Instead, use "
459                         "`~Figure.add_axes`, `~.Figure.subplot` or "
460                         "`~.Figure.delaxes` to add or remove an axes.")
461 
462     def _get_dpi(self):
463         return self._dpi
464 
465     def _set_dpi(self, dpi, forward=True):
466         """
467         Parameters
468         ----------
469         dpi : float
470 
471         forward : bool
472             Passed on to `~.Figure.set_size_inches`
473         """
474         self._dpi = dpi
475         self.dpi_scale_trans.clear().scale(dpi, dpi)
476         w, h = self.get_size_inches()
477         self.set_size_inches(w, h, forward=forward)
478         self.callbacks.process('dpi_changed', self)
479 
480     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
481 
482     def get_tight_layout(self):
483         """Return whether `.tight_layout` is called when drawing."""
484         return self._tight
485 
486     def set_tight_layout(self, tight):
487         """
488         Set whether and how `.tight_layout` is called when drawing.
489 
490         Parameters
491         ----------
492         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
493             If a bool, sets whether to call `.tight_layout` upon drawing.
494             If ``None``, use the ``figure.autolayout`` rcparam instead.
495             If a dict, pass it as kwargs to `.tight_layout`, overriding the
496             default paddings.
497         """
498         if tight is None:
499             tight = rcParams['figure.autolayout']
500         self._tight = bool(tight)
501         self._tight_parameters = tight if isinstance(tight, dict) else {}
502         self.stale = True
503 
504     def get_constrained_layout(self):
505         """
506         Return a boolean: True means constrained layout is being used.
507 
508         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
509         """
510         return self._constrained
511 
512     def set_constrained_layout(self, constrained):
513         """
514         Set whether ``constrained_layout`` is used upon drawing. If None,
515         the rcParams['figure.constrained_layout.use'] value will be used.
516 
517         When providing a dict containing the keys `w_pad`, `h_pad`
518         the default ``constrained_layout`` paddings will be
519         overridden.  These pads are in inches and default to 3.0/72.0.
520         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
521 
522         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
523 
524         Parameters
525         ----------
526         constrained : bool or dict or None
527         """
528         self._constrained_layout_pads = dict()
529         self._constrained_layout_pads['w_pad'] = None
530         self._constrained_layout_pads['h_pad'] = None
531         self._constrained_layout_pads['wspace'] = None
532         self._constrained_layout_pads['hspace'] = None
533         if constrained is None:
534             constrained = rcParams['figure.constrained_layout.use']
535         self._constrained = bool(constrained)
536         if isinstance(constrained, dict):
537             self.set_constrained_layout_pads(**constrained)
538         else:
539             self.set_constrained_layout_pads()
540 
541         self.stale = True
542 
543     def set_constrained_layout_pads(self, **kwargs):
544         """
545         Set padding for ``constrained_layout``.  Note the kwargs can be passed
546         as a dictionary ``fig.set_constrained_layout(**paddict)``.
547 
548         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
549 
550         Parameters
551         ----------
552 
553         w_pad : scalar
554             Width padding in inches.  This is the pad around axes
555             and is meant to make sure there is enough room for fonts to
556             look good.  Defaults to 3 pts = 0.04167 inches
557 
558         h_pad : scalar
559             Height padding in inches. Defaults to 3 pts.
560 
561         wspace : scalar
562             Width padding between subplots, expressed as a fraction of the
563             subplot width.  The total padding ends up being w_pad + wspace.
564 
565         hspace : scalar
566             Height padding between subplots, expressed as a fraction of the
567             subplot width. The total padding ends up being h_pad + hspace.
568 
569         """
570 
571         todo = ['w_pad', 'h_pad', 'wspace', 'hspace']
572         for td in todo:
573             if td in kwargs and kwargs[td] is not None:
574                 self._constrained_layout_pads[td] = kwargs[td]
575             else:
576                 self._constrained_layout_pads[td] = (
577                     rcParams['figure.constrained_layout.' + td])
578 
579     def get_constrained_layout_pads(self, relative=False):
580         """
581         Get padding for ``constrained_layout``.
582 
583         Returns a list of `w_pad, h_pad` in inches and
584         `wspace` and `hspace` as fractions of the subplot.
585 
586         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
587 
588         Parameters
589         ----------
590 
591         relative : boolean
592             If `True`, then convert from inches to figure relative.
593         """
594         w_pad = self._constrained_layout_pads['w_pad']
595         h_pad = self._constrained_layout_pads['h_pad']
596         wspace = self._constrained_layout_pads['wspace']
597         hspace = self._constrained_layout_pads['hspace']
598 
599         if relative and (w_pad is not None or h_pad is not None):
600             renderer0 = layoutbox.get_renderer(self)
601             dpi = renderer0.dpi
602             w_pad = w_pad * dpi / renderer0.width
603             h_pad = h_pad * dpi / renderer0.height
604 
605         return w_pad, h_pad, wspace, hspace
606 
607     def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which=None):
608         """
609         Date ticklabels often overlap, so it is useful to rotate them
610         and right align them.  Also, a common use case is a number of
611         subplots with shared xaxes where the x-axis is date data.  The
612         ticklabels are often long, and it helps to rotate them on the
613         bottom subplot and turn them off on other subplots, as well as
614         turn off xlabels.
615 
616         Parameters
617         ----------
618         bottom : scalar
619             The bottom of the subplots for :meth:`subplots_adjust`.
620 
621         rotation : angle in degrees
622             The rotation of the xtick labels.
623 
624         ha : string
625             The horizontal alignment of the xticklabels.
626 
627         which : {None, 'major', 'minor', 'both'}
628             Selects which ticklabels to rotate. Default is None which works
629             the same as major.
630         """
631         allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)
632         if len(self.axes) == 1:
633             for label in self.axes[0].get_xticklabels(which=which):
634                 label.set_ha(ha)
635                 label.set_rotation(rotation)
636         else:
637             if allsubplots:
638                 for ax in self.get_axes():
639                     if ax.is_last_row():
640                         for label in ax.get_xticklabels(which=which):
641                             label.set_ha(ha)
642                             label.set_rotation(rotation)
643                     else:
644                         for label in ax.get_xticklabels(which=which):
645                             label.set_visible(False)
646                         ax.set_xlabel('')
647 
648         if allsubplots:
649             self.subplots_adjust(bottom=bottom)
650         self.stale = True
651 
652     def get_children(self):
653         """Get a list of artists contained in the figure."""
654         return [self.patch,
655                 *self.artists,
656                 *self.axes,
657                 *self.lines,
658                 *self.patches,
659                 *self.texts,
660                 *self.images,
661                 *self.legends]
662 
663     def contains(self, mouseevent):
664         """
665         Test whether the mouse event occurred on the figure.
666 
667         Returns
668         -------
669             bool, {}
670         """
671         if self._contains is not None:
672             return self._contains(self, mouseevent)
673         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
674         return inside, {}
675 
676     def get_window_extent(self, *args, **kwargs):
677         """
678         Return the figure bounding box in display space. Arguments are ignored.
679         """
680         return self.bbox
681 
682     def suptitle(self, t, **kwargs):
683         """
684         Add a centered title to the figure.
685 
686         Parameters
687         ----------
688         t : str
689             The title text.
690 
691         x : float, default 0.5
692             The x location of the text in figure coordinates.
693 
694         y : float, default 0.98
695             The y location of the text in figure coordinates.
696 
697         horizontalalignment, ha : {'center', 'left', right'}, default: 'center'
698             The horizontal alignment of the text relative to (*x*, *y*).
699 
700         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
701 default: 'top'
702             The vertical alignment of the text relative to (*x*, *y*).
703 
704         fontsize, size : default: :rc:`figure.titlesize`
705             The font size of the text. See `.Text.set_size` for possible
706             values.
707 
708         fontweight, weight : default: :rc:`figure.titleweight`
709             The font weight of the text. See `.Text.set_weight` for possible
710             values.
711 
712 
713         Returns
714         -------
715             text
716                 The `.Text` instance of the title.
717 
718 
719         Other Parameters
720         ----------------
721         fontproperties : None or dict, optional
722             A dict of font properties. If *fontproperties* is given the
723             default values for font size and weight are taken from the
724             `FontProperties` defaults. :rc:`figure.titlesize` and
725             :rc:`figure.titleweight` are ignored in this case.
726 
727         **kwargs
728             Additional kwargs are :class:`matplotlib.text.Text` properties.
729 
730 
731         Examples
732         --------
733 
734         >>> fig.suptitle('This is the figure title', fontsize=12)
735         """
736         manual_position = ('x' in kwargs or 'y' in kwargs)
737 
738         x = kwargs.pop('x', 0.5)
739         y = kwargs.pop('y', 0.98)
740 
741         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
742             kwargs['horizontalalignment'] = 'center'
743         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
744             kwargs['verticalalignment'] = 'top'
745 
746         if 'fontproperties' not in kwargs:
747             if 'fontsize' not in kwargs and 'size' not in kwargs:
748                 kwargs['size'] = rcParams['figure.titlesize']
749             if 'fontweight' not in kwargs and 'weight' not in kwargs:
750                 kwargs['weight'] = rcParams['figure.titleweight']
751 
752         sup = self.text(x, y, t, **kwargs)
753         if self._suptitle is not None:
754             self._suptitle.set_text(t)
755             self._suptitle.set_position((x, y))
756             self._suptitle.update_from(sup)
757             sup.remove()
758         else:
759             self._suptitle = sup
760             self._suptitle._layoutbox = None
761             if self._layoutbox is not None and not manual_position:
762                 w_pad, h_pad, wspace, hspace =  \
763                         self.get_constrained_layout_pads(relative=True)
764                 figlb = self._layoutbox
765                 self._suptitle._layoutbox = layoutbox.LayoutBox(
766                         parent=figlb, artist=self._suptitle,
767                         name=figlb.name+'.suptitle')
768                 # stack the suptitle on top of all the children.
769                 # Some day this should be on top of all the children in the
770                 # gridspec only.
771                 for child in figlb.children:
772                     if child is not self._suptitle._layoutbox:
773                         layoutbox.vstack([self._suptitle._layoutbox,
774                                           child],
775                                          padding=h_pad*2., strength='required')
776         self.stale = True
777         return self._suptitle
778 
779     def set_canvas(self, canvas):
780         """
781         Set the canvas that contains the figure
782 
783         Parameters
784         ----------
785         canvas : FigureCanvas
786         """
787         self.canvas = canvas
788 
789     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
790                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
791         """
792         Add a non-resampled image to the figure.
793 
794         The image is attached to the lower or upper left corner depending on
795         *origin*.
796 
797         Parameters
798         ----------
799         X
800             The image data. This is an array of one of the following shapes:
801 
802             - MxN: luminance (grayscale) values
803             - MxNx3: RGB values
804             - MxNx4: RGBA values
805 
806         xo, yo : int
807             The *x*/*y* image offset in pixels.
808 
809         alpha : None or float
810             The alpha blending value.
811 
812         norm : :class:`matplotlib.colors.Normalize`
813             A :class:`.Normalize` instance to map the luminance to the
814             interval [0, 1].
815 
816         cmap : str or :class:`matplotlib.colors.Colormap`
817             The colormap to use. Default: :rc:`image.cmap`.
818 
819         vmin, vmax : scalar
820             If *norm* is not given, these values set the data limits for the
821             colormap.
822 
823         origin : {'upper', 'lower'}
824             Indicates where the [0, 0] index of the array is in the upper left
825             or lower left corner of the axes. Defaults to :rc:`image.origin`.
826 
827         resize : bool
828             If *True*, resize the figure to match the given image size.
829 
830         Returns
831         -------
832         :class:`matplotlib.image.FigureImage`
833 
834         Other Parameters
835         ----------------
836         **kwargs
837             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
838 
839         Notes
840         -----
841         figimage complements the axes image
842         (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled
843         to fit the current axes.  If you want a resampled image to
844         fill the entire figure, you can define an
845         :class:`~matplotlib.axes.Axes` with extent [0,0,1,1].
846 
847 
848         Examples::
849 
850             f = plt.figure()
851             nx = int(f.get_figwidth() * f.dpi)
852             ny = int(f.get_figheight() * f.dpi)
853             data = np.random.random((ny, nx))
854             f.figimage(data)
855             plt.show()
856 
857         """
858         if resize:
859             dpi = self.get_dpi()
860             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
861             self.set_size_inches(figsize, forward=True)
862 
863         im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)
864         im.stale_callback = _stale_figure_callback
865 
866         im.set_array(X)
867         im.set_alpha(alpha)
868         if norm is None:
869             im.set_clim(vmin, vmax)
870         self.images.append(im)
871         im._remove_method = self.images.remove
872         self.stale = True
873         return im
874 
875     def set_size_inches(self, w, h=None, forward=True):
876         """Set the figure size in inches.
877 
878         Call signatures::
879 
880              fig.set_size_inches(w, h)  # OR
881              fig.set_size_inches((w, h))
882 
883         optional kwarg *forward=True* will cause the canvas size to be
884         automatically updated; e.g., you can resize the figure window
885         from the shell
886 
887         ACCEPTS: a (w, h) tuple with w, h in inches
888 
889         See Also
890         --------
891         matplotlib.Figure.get_size_inches
892         """
893 
894         # the width and height have been passed in as a tuple to the first
895         # argument, so unpack them
896         if h is None:
897             w, h = w
898         if not all(np.isfinite(_) for _ in (w, h)):
899             raise ValueError('figure size must be finite not '
900                              '({}, {})'.format(w, h))
901         self.bbox_inches.p1 = w, h
902 
903         if forward:
904             canvas = getattr(self, 'canvas')
905             if canvas is not None:
906                 ratio = getattr(self.canvas, '_dpi_ratio', 1)
907                 dpival = self.dpi / ratio
908                 canvasw = w * dpival
909                 canvash = h * dpival
910                 manager = getattr(self.canvas, 'manager', None)
911                 if manager is not None:
912                     manager.resize(int(canvasw), int(canvash))
913         self.stale = True
914 
915     def get_size_inches(self):
916         """
917         Returns the current size of the figure in inches.
918 
919         Returns
920         -------
921         size : ndarray
922            The size (width, height) of the figure in inches.
923 
924         See Also
925         --------
926         matplotlib.Figure.set_size_inches
927         """
928         return np.array(self.bbox_inches.p1)
929 
930     def get_edgecolor(self):
931         """Get the edge color of the Figure rectangle."""
932         return self.patch.get_edgecolor()
933 
934     def get_facecolor(self):
935         """Get the face color of the Figure rectangle."""
936         return self.patch.get_facecolor()
937 
938     def get_figwidth(self):
939         """Return the figure width as a float."""
940         return self.bbox_inches.width
941 
942     def get_figheight(self):
943         """Return the figure height as a float."""
944         return self.bbox_inches.height
945 
946     def get_dpi(self):
947         """Return the resolution in dots per inch as a float."""
948         return self.dpi
949 
950     def get_frameon(self):
951         """
952         Return the figure's background patch visibility, i.e.
953         whether the figure background will be drawn. Equivalent to
954         ``Figure.patch.get_visible()``.
955         """
956         return self.patch.get_visible()
957 
958     def set_edgecolor(self, color):
959         """
960         Set the edge color of the Figure rectangle.
961 
962         Parameters
963         ----------
964         color : color
965         """
966         self.patch.set_edgecolor(color)
967 
968     def set_facecolor(self, color):
969         """
970         Set the face color of the Figure rectangle.
971 
972         Parameters
973         ----------
974         color : color
975         """
976         self.patch.set_facecolor(color)
977 
978     def set_dpi(self, val):
979         """
980         Set the resolution of the figure in dots-per-inch.
981 
982         Parameters
983         ----------
984         val : float
985         """
986         self.dpi = val
987         self.stale = True
988 
989     def set_figwidth(self, val, forward=True):
990         """
991         Set the width of the figure in inches.
992 
993         Parameters
994         ----------
995         val : float
996         forward : bool
997         """
998         self.set_size_inches(val, self.get_figheight(), forward=forward)
999 
1000     def set_figheight(self, val, forward=True):
1001         """
1002         Set the height of the figure in inches.
1003 
1004         Parameters
1005         ----------
1006         val : float
1007         forward : bool
1008         """
1009         self.set_size_inches(self.get_figwidth(), val, forward=forward)
1010 
1011     def set_frameon(self, b):
1012         """
1013         Set the figure's background patch visibility, i.e.
1014         whether the figure background will be drawn. Equivalent to
1015         ``Figure.patch.set_visible()``.
1016 
1017         Parameters
1018         ----------
1019         b : bool
1020         """
1021         self.patch.set_visible(b)
1022         self.stale = True
1023 
1024     frameon = property(get_frameon, set_frameon)
1025 
1026     def delaxes(self, ax):
1027         """
1028         Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the
1029         current axes.
1030         """
1031         self._axstack.remove(ax)
1032         for func in self._axobservers:
1033             func(self)
1034         self.stale = True
1035 
1036     def add_artist(self, artist, clip=False):
1037         """
1038         Add any :class:`~matplotlib.artist.Artist` to the figure.
1039 
1040         Usually artists are added to axes objects using
1041         :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the
1042         rare cases that adding directly to the figure is necessary.
1043 
1044         Parameters
1045         ----------
1046         artist : `~matplotlib.artist.Artist`
1047             The artist to add to the figure. If the added artist has no
1048             transform previously set, its transform will be set to
1049             ``figure.transFigure``.
1050         clip : bool, optional, default ``False``
1051             An optional parameter ``clip`` determines whether the added artist
1052             should be clipped by the figure patch. Default is *False*,
1053             i.e. no clipping.
1054 
1055         Returns
1056         -------
1057         artist : The added `~matplotlib.artist.Artist`
1058         """
1059         artist.set_figure(self)
1060         self.artists.append(artist)
1061         artist._remove_method = self.artists.remove
1062 
1063         if not artist.is_transform_set():
1064             artist.set_transform(self.transFigure)
1065 
1066         if clip:
1067             artist.set_clip_path(self.patch)
1068 
1069         self.stale = True
1070         return artist
1071 
1072     def _make_key(self, *args, **kwargs):
1073         """Make a hashable key out of args and kwargs."""
1074 
1075         def fixitems(items):
1076             # items may have arrays and lists in them, so convert them
1077             # to tuples for the key
1078             ret = []
1079             for k, v in items:
1080                 # some objects can define __getitem__ without being
1081                 # iterable and in those cases the conversion to tuples
1082                 # will fail. So instead of using the np.iterable(v) function
1083                 # we simply try and convert to a tuple, and proceed if not.
1084                 try:
1085                     v = tuple(v)
1086                 except Exception:
1087                     pass
1088                 ret.append((k, v))
1089             return tuple(ret)
1090 
1091         def fixlist(args):
1092             ret = []
1093             for a in args:
1094                 if np.iterable(a):
1095                     a = tuple(a)
1096                 ret.append(a)
1097             return tuple(ret)
1098 
1099         key = fixlist(args), fixitems(kwargs.items())
1100         return key
1101 
1102     def _process_projection_requirements(
1103             self, *args, polar=False, projection=None, **kwargs):
1104         """
1105         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1106 
1107             (axes_proj_class, proj_class_kwargs, proj_stack_key)
1108 
1109         which can be used for new axes initialization/identification.
1110         """
1111         if polar:
1112             if projection is not None and projection != 'polar':
1113                 raise ValueError(
1114                     "polar=True, yet projection=%r. "
1115                     "Only one of these arguments should be supplied." %
1116                     projection)
1117             projection = 'polar'
1118 
1119         if isinstance(projection, str) or projection is None:
1120             projection_class = projections.get_projection_class(projection)
1121         elif hasattr(projection, '_as_mpl_axes'):
1122             projection_class, extra_kwargs = projection._as_mpl_axes()
1123             kwargs.update(**extra_kwargs)
1124         else:
1125             raise TypeError('projection must be a string, None or implement a '
1126                             '_as_mpl_axes method. Got %r' % projection)
1127 
1128         # Make the key without projection kwargs, this is used as a unique
1129         # lookup for axes instances
1130         key = self._make_key(*args, **kwargs)
1131 
1132         return projection_class, kwargs, key
1133 
1134     @docstring.dedent_interpd
1135     def add_axes(self, *args, **kwargs):
1136         """
1137         Add an axes to the figure.
1138 
1139         Call signatures::
1140 
1141             add_axes(rect, projection=None, polar=False, **kwargs)
1142             add_axes(ax)
1143 
1144         Parameters
1145         ----------
1146 
1147         rect : sequence of float
1148             The dimensions [left, bottom, width, height] of the new axes. All
1149             quantities are in fractions of figure width and height.
1150 
1151         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1152 'polar', 'rectilinear', str}, optional
1153             The projection type of the `~.axes.Axes`. *str* is the name of
1154             a custom projection, see `~matplotlib.projections`. The default
1155             None results in a 'rectilinear' projection.
1156 
1157         polar : boolean, optional
1158             If True, equivalent to projection='polar'.
1159 
1160         sharex, sharey : `~.axes.Axes`, optional
1161             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1162             The axis will have the same limits, ticks, and scale as the axis
1163             of the shared axes.
1164 
1165         label : str
1166             A label for the returned axes.
1167 
1168         Other Parameters
1169         ----------------
1170         **kwargs
1171             This method also takes the keyword arguments for
1172             the returned axes class. The keyword arguments for the
1173             rectilinear axes class `~.axes.Axes` can be found in
1174             the following table but there might also be other keyword
1175             arguments if another projection is used, see the actual axes
1176             class.
1177             %(Axes)s
1178 
1179         Returns
1180         -------
1181         axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
1182             The returned axes class depends on the projection used. It is
1183             `~.axes.Axes` if rectilinear projection are used and
1184             `.projections.polar.PolarAxes` if polar projection
1185             are used.
1186 
1187         Notes
1188         -----
1189         If the figure already has an axes with key (*args*,
1190         *kwargs*) then it will simply make that axes current and
1191         return it.  This behavior is deprecated. Meanwhile, if you do
1192         not want this behavior (i.e., you want to force the creation of a
1193         new axes), you must use a unique set of args and kwargs.  The axes
1194         *label* attribute has been exposed for this purpose: if you want
1195         two axes that are otherwise identical to be added to the figure,
1196         make sure you give them unique labels.
1197 
1198         In rare circumstances, `.add_axes` may be called with a single
1199         argument, a axes instance already created in the present figure but
1200         not in the figure's list of axes.
1201 
1202         See Also
1203         --------
1204         .Figure.add_subplot
1205         .pyplot.subplot
1206         .pyplot.axes
1207         .Figure.subplots
1208         .pyplot.subplots
1209 
1210         Examples
1211         --------
1212         Some simple examples::
1213 
1214             rect = l, b, w, h
1215             fig = plt.figure()
1216             fig.add_axes(rect,label=label1)
1217             fig.add_axes(rect,label=label2)
1218             fig.add_axes(rect, frameon=False, facecolor='g')
1219             fig.add_axes(rect, polar=True)
1220             ax=fig.add_axes(rect, projection='polar')
1221             fig.delaxes(ax)
1222             fig.add_axes(ax)
1223         """
1224 
1225         if not len(args):
1226             return
1227 
1228         # shortcut the projection "key" modifications later on, if an axes
1229         # with the exact args/kwargs exists, return it immediately.
1230         key = self._make_key(*args, **kwargs)
1231         ax = self._axstack.get(key)
1232         if ax is not None:
1233             self.sca(ax)
1234             return ax
1235 
1236         if isinstance(args[0], Axes):
1237             a = args[0]
1238             if a.get_figure() is not self:
1239                 raise ValueError(
1240                     "The Axes must have been created in the present figure")
1241         else:
1242             rect = args[0]
1243             if not np.isfinite(rect).all():
1244                 raise ValueError('all entries in rect must be finite '
1245                                  'not {}'.format(rect))
1246             projection_class, kwargs, key = \
1247                 self._process_projection_requirements(*args, **kwargs)
1248 
1249             # check that an axes of this type doesn't already exist, if it
1250             # does, set it as active and return it
1251             ax = self._axstack.get(key)
1252             if isinstance(ax, projection_class):
1253                 self.sca(ax)
1254                 return ax
1255 
1256             # create the new axes using the axes class given
1257             a = projection_class(self, rect, **kwargs)
1258 
1259         return self._add_axes_internal(key, a)
1260 
1261     @docstring.dedent_interpd
1262     def add_subplot(self, *args, **kwargs):
1263         """
1264         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
1265 
1266         Call signatures::
1267 
1268            add_subplot(nrows, ncols, index, **kwargs)
1269            add_subplot(pos, **kwargs)
1270            add_subplot(ax)
1271 
1272         Parameters
1273         ----------
1274         *args
1275             Either a 3-digit integer or three separate integers
1276             describing the position of the subplot. If the three
1277             integers are *nrows*, *ncols*, and *index* in order, the
1278             subplot will take the *index* position on a grid with *nrows*
1279             rows and *ncols* columns. *index* starts at 1 in the upper left
1280             corner and increases to the right.
1281 
1282             *pos* is a three digit integer, where the first digit is the
1283             number of rows, the second the number of columns, and the third
1284             the index of the subplot. i.e. fig.add_subplot(235) is the same as
1285             fig.add_subplot(2, 3, 5). Note that all integers must be less than
1286             10 for this form to work.
1287 
1288         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1289 'polar', 'rectilinear', str}, optional
1290             The projection type of the subplot (`~.axes.Axes`). *str* is the
1291             name of a custom projection, see `~matplotlib.projections`. The
1292             default None results in a 'rectilinear' projection.
1293 
1294         polar : boolean, optional
1295             If True, equivalent to projection='polar'.
1296 
1297         sharex, sharey : `~.axes.Axes`, optional
1298             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1299             The axis will have the same limits, ticks, and scale as the axis
1300             of the shared axes.
1301 
1302         label : str
1303             A label for the returned axes.
1304 
1305         Other Parameters
1306         ----------------
1307         **kwargs
1308             This method also takes the keyword arguments for
1309             the returned axes base class. The keyword arguments for the
1310             rectilinear base class `~.axes.Axes` can be found in
1311             the following table but there might also be other keyword
1312             arguments if another projection is used.
1313             %(Axes)s
1314 
1315         Returns
1316         -------
1317         axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a \
1318                subclass of `~.axes.Axes`)
1319 
1320             The axes of the subplot. The returned axes base class depends on
1321             the projection used. It is `~.axes.Axes` if rectilinear projection
1322             are used and `.projections.polar.PolarAxes` if polar projection
1323             are used. The returned axes is then a subplot subclass of the
1324             base class.
1325 
1326         Notes
1327         -----
1328         If the figure already has a subplot with key (*args*,
1329         *kwargs*) then it will simply make that subplot current and
1330         return it.  This behavior is deprecated. Meanwhile, if you do
1331         not want this behavior (i.e., you want to force the creation of a
1332         new subplot), you must use a unique set of args and kwargs.  The axes
1333         *label* attribute has been exposed for this purpose: if you want
1334         two subplots that are otherwise identical to be added to the figure,
1335         make sure you give them unique labels.
1336 
1337         In rare circumstances, `.add_subplot` may be called with a single
1338         argument, a subplot axes instance already created in the
1339         present figure but not in the figure's list of axes.
1340 
1341         See Also
1342         --------
1343         .Figure.add_axes
1344         .pyplot.subplot
1345         .pyplot.axes
1346         .Figure.subplots
1347         .pyplot.subplots
1348 
1349         Examples
1350         --------
1351         ::
1352 
1353             fig = plt.figure()
1354             fig.add_subplot(221)
1355 
1356             # equivalent but more general
1357             ax1 = fig.add_subplot(2, 2, 1)
1358 
1359             # add a subplot with no frame
1360             ax2 = fig.add_subplot(222, frameon=False)
1361 
1362             # add a polar subplot
1363             fig.add_subplot(223, projection='polar')
1364 
1365             # add a red subplot that share the x-axis with ax1
1366             fig.add_subplot(224, sharex=ax1, facecolor='red')
1367 
1368             #delete x2 from the figure
1369             fig.delaxes(ax2)
1370 
1371             #add x2 to the figure again
1372             fig.add_subplot(ax2)
1373         """
1374         if not len(args):
1375             args = (1, 1, 1)
1376 
1377         if len(args) == 1 and isinstance(args[0], Integral):
1378             if not 100 <= args[0] <= 999:
1379                 raise ValueError("Integer subplot specification must be a "
1380                                  "three-digit number, not {}".format(args[0]))
1381             args = tuple(map(int, str(args[0])))
1382 
1383         if isinstance(args[0], SubplotBase):
1384 
1385             a = args[0]
1386             if a.get_figure() is not self:
1387                 raise ValueError(
1388                     "The Subplot must have been created in the present figure")
1389             # make a key for the subplot (which includes the axes object id
1390             # in the hash)
1391             key = self._make_key(*args, **kwargs)
1392         else:
1393             projection_class, kwargs, key = \
1394                 self._process_projection_requirements(*args, **kwargs)
1395 
1396             # try to find the axes with this key in the stack
1397             ax = self._axstack.get(key)
1398 
1399             if ax is not None:
1400                 if isinstance(ax, projection_class):
1401                     # the axes already existed, so set it as active & return
1402                     self.sca(ax)
1403                     return ax
1404                 else:
1405                     # Undocumented convenience behavior:
1406                     # subplot(111); subplot(111, projection='polar')
1407                     # will replace the first with the second.
1408                     # Without this, add_subplot would be simpler and
1409                     # more similar to add_axes.
1410                     self._axstack.remove(ax)
1411 
1412             a = subplot_class_factory(projection_class)(self, *args, **kwargs)
1413 
1414         return self._add_axes_internal(key, a)
1415 
1416     def _add_axes_internal(self, key, ax):
1417         """Private helper for `add_axes` and `add_subplot`."""
1418         self._axstack.add(key, ax)
1419         self.sca(ax)
1420         ax._remove_method = self._remove_ax
1421         self.stale = True
1422         ax.stale_callback = _stale_figure_callback
1423         return ax
1424 
1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,
1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):
1427         """
1428         Add a set of subplots to this figure.
1429 
1430         This utility wrapper makes it convenient to create common layouts of
1431         subplots in a single call.
1432 
1433         Parameters
1434         ----------
1435         nrows, ncols : int, optional, default: 1
1436             Number of rows/columns of the subplot grid.
1437 
1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)
1440             axes:
1441 
1442                 - True or 'all': x- or y-axis will be shared among all
1443                   subplots.
1444                 - False or 'none': each subplot x- or y-axis will be
1445                   independent.
1446                 - 'row': each subplot row will share an x- or y-axis.
1447                 - 'col': each subplot column will share an x- or y-axis.
1448 
1449             When subplots have a shared x-axis along a column, only the x tick
1450             labels of the bottom subplot are created. Similarly, when subplots
1451             have a shared y-axis along a row, only the y tick labels of the
1452             first column subplot are created. To later turn other subplots'
1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
1454 
1455         squeeze : bool, optional, default: True
1456             - If True, extra dimensions are squeezed out from the returned
1457               array of Axes:
1458 
1459                 - if only one subplot is constructed (nrows=ncols=1), the
1460                   resulting single Axes object is returned as a scalar.
1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1462                   object array of Axes objects.
1463                 - for NxM, subplots with N>1 and M>1 are returned
1464                   as a 2D array.
1465 
1466             - If False, no squeezing at all is done: the returned Axes object
1467               is always a 2D array containing Axes instances, even if it ends
1468               up being 1x1.
1469 
1470         subplot_kw : dict, optional
1471             Dict with keywords passed to the
1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create
1473             each subplot.
1474 
1475         gridspec_kw : dict, optional
1476             Dict with keywords passed to the
1477             `~matplotlib.gridspec.GridSpec` constructor used to create
1478             the grid the subplots are placed on.
1479 
1480         Returns
1481         -------
1482         ax : `~.axes.Axes` object or array of Axes objects.
1483             *ax* can be either a single `~matplotlib.axes.Axes` object or
1484             an array of Axes objects if more than one subplot was created. The
1485             dimensions of the resulting array can be controlled with the
1486             squeeze keyword, see above.
1487 
1488         Examples
1489         --------
1490         ::
1491 
1492             # First create some toy data:
1493             x = np.linspace(0, 2*np.pi, 400)
1494             y = np.sin(x**2)
1495 
1496             # Create a figure
1497             plt.figure()
1498 
1499             # Creates a subplot
1500             ax = fig.subplots()
1501             ax.plot(x, y)
1502             ax.set_title('Simple plot')
1503 
1504             # Creates two subplots and unpacks the output array immediately
1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)
1506             ax1.plot(x, y)
1507             ax1.set_title('Sharing Y axis')
1508             ax2.scatter(x, y)
1509 
1510             # Creates four polar axes, and accesses them through the
1511             # returned array
1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))
1513             axes[0, 0].plot(x, y)
1514             axes[1, 1].scatter(x, y)
1515 
1516             # Share a X axis with each column of subplots
1517             fig.subplots(2, 2, sharex='col')
1518 
1519             # Share a Y axis with each row of subplots
1520             fig.subplots(2, 2, sharey='row')
1521 
1522             # Share both X and Y axes with all subplots
1523             fig.subplots(2, 2, sharex='all', sharey='all')
1524 
1525             # Note that this is the same as
1526             fig.subplots(2, 2, sharex=True, sharey=True)
1527 
1528             See Also
1529             --------
1530             .pyplot.subplots
1531             .Figure.add_subplot
1532             .pyplot.subplot
1533             """
1534 
1535         if isinstance(sharex, bool):
1536             sharex = "all" if sharex else "none"
1537         if isinstance(sharey, bool):
1538             sharey = "all" if sharey else "none"
1539         # This check was added because it is very easy to type
1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.
1541         # In most cases, no error will ever occur, but mysterious behavior
1542         # will result because what was intended to be the subplot index is
1543         # instead treated as a bool for sharex.
1544         if isinstance(sharex, Integral):
1545             cbook._warn_external(
1546                 "sharex argument to subplots() was an integer.  Did you "
1547                 "intend to use subplot() (without 's')?")
1548         cbook._check_in_list(["all", "row", "col", "none"],
1549                              sharex=sharex, sharey=sharey)
1550         if subplot_kw is None:
1551             subplot_kw = {}
1552         if gridspec_kw is None:
1553             gridspec_kw = {}
1554         # don't mutate kwargs passed by user...
1555         subplot_kw = subplot_kw.copy()
1556         gridspec_kw = gridspec_kw.copy()
1557 
1558         if self.get_constrained_layout():
1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)
1560         else:
1561             # this should turn constrained_layout off if we don't want it
1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)
1563         self._gridspecs.append(gs)
1564 
1565         # Create array to hold all axes.
1566         axarr = np.empty((nrows, ncols), dtype=object)
1567         for row in range(nrows):
1568             for col in range(ncols):
1569                 shared_with = {"none": None, "all": axarr[0, 0],
1570                                "row": axarr[row, 0], "col": axarr[0, col]}
1571                 subplot_kw["sharex"] = shared_with[sharex]
1572                 subplot_kw["sharey"] = shared_with[sharey]
1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)
1574 
1575         # turn off redundant tick labeling
1576         if sharex in ["col", "all"]:
1577             # turn off all but the bottom row
1578             for ax in axarr[:-1, :].flat:
1579                 ax.xaxis.set_tick_params(which='both',
1580                                          labelbottom=False, labeltop=False)
1581                 ax.xaxis.offsetText.set_visible(False)
1582         if sharey in ["row", "all"]:
1583             # turn off all but the first column
1584             for ax in axarr[:, 1:].flat:
1585                 ax.yaxis.set_tick_params(which='both',
1586                                          labelleft=False, labelright=False)
1587                 ax.yaxis.offsetText.set_visible(False)
1588 
1589         if squeeze:
1590             # Discarding unneeded dimensions that equal 1.  If we only have one
1591             # subplot, just return it instead of a 1-element array.
1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()
1593         else:
1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1595             return axarr
1596 
1597     def _remove_ax(self, ax):
1598         def _reset_loc_form(axis):
1599             axis.set_major_formatter(axis.get_major_formatter())
1600             axis.set_major_locator(axis.get_major_locator())
1601             axis.set_minor_formatter(axis.get_minor_formatter())
1602             axis.set_minor_locator(axis.get_minor_locator())
1603 
1604         def _break_share_link(ax, grouper):
1605             siblings = grouper.get_siblings(ax)
1606             if len(siblings) > 1:
1607                 grouper.remove(ax)
1608                 for last_ax in siblings:
1609                     if ax is not last_ax:
1610                         return last_ax
1611             return None
1612 
1613         self.delaxes(ax)
1614         last_ax = _break_share_link(ax, ax._shared_y_axes)
1615         if last_ax is not None:
1616             _reset_loc_form(last_ax.yaxis)
1617 
1618         last_ax = _break_share_link(ax, ax._shared_x_axes)
1619         if last_ax is not None:
1620             _reset_loc_form(last_ax.xaxis)
1621 
1622     def clf(self, keep_observers=False):
1623         """
1624         Clear the figure.
1625 
1626         Set *keep_observers* to True if, for example,
1627         a gui widget is tracking the axes in the figure.
1628         """
1629         self.suppressComposite = None
1630         self.callbacks = cbook.CallbackRegistry()
1631 
1632         for ax in tuple(self.axes):  # Iterate over the copy.
1633             ax.cla()
1634             self.delaxes(ax)         # removes ax from self._axstack
1635 
1636         toolbar = getattr(self.canvas, 'toolbar', None)
1637         if toolbar is not None:
1638             toolbar.update()
1639         self._axstack.clear()
1640         self.artists = []
1641         self.lines = []
1642         self.patches = []
1643         self.texts = []
1644         self.images = []
1645         self.legends = []
1646         if not keep_observers:
1647             self._axobservers = []
1648         self._suptitle = None
1649         if self.get_constrained_layout():
1650             layoutbox.nonetree(self._layoutbox)
1651         self.stale = True
1652 
1653     def clear(self, keep_observers=False):
1654         """
1655         Clear the figure -- synonym for :meth:`clf`.
1656         """
1657         self.clf(keep_observers=keep_observers)
1658 
1659     @allow_rasterization
1660     def draw(self, renderer):
1661         """
1662         Render the figure using :class:`matplotlib.backend_bases.RendererBase`
1663         instance *renderer*.
1664         """
1665 
1666         # draw the figure bounding box, perhaps none for white figure
1667         if not self.get_visible():
1668             return
1669 
1670         artists = self.get_children()
1671         artists.remove(self.patch)
1672         artists = sorted(
1673             (artist for artist in artists if not artist.get_animated()),
1674             key=lambda artist: artist.get_zorder())
1675 
1676         for ax in self.axes:
1677             locator = ax.get_axes_locator()
1678             if locator:
1679                 pos = locator(ax, renderer)
1680                 ax.apply_aspect(pos)
1681             else:
1682                 ax.apply_aspect()
1683 
1684             for child in ax.get_children():
1685                 if hasattr(child, 'apply_aspect'):
1686                     locator = child.get_axes_locator()
1687                     if locator:
1688                         pos = locator(child, renderer)
1689                         child.apply_aspect(pos)
1690                     else:
1691                         child.apply_aspect()
1692 
1693         try:
1694             renderer.open_group('figure')
1695             if self.get_constrained_layout() and self.axes:
1696                 self.execute_constrained_layout(renderer)
1697             if self.get_tight_layout() and self.axes:
1698                 try:
1699                     self.tight_layout(renderer,
1700                                       **self._tight_parameters)
1701                 except ValueError:
1702                     pass
1703                     # ValueError can occur when resizing a window.
1704 
1705             self.patch.draw(renderer)
1706             mimage._draw_list_compositing_images(
1707                 renderer, self, artists, self.suppressComposite)
1708 
1709             renderer.close_group('figure')
1710         finally:
1711             self.stale = False
1712 
1713         self._cachedRenderer = renderer
1714         self.canvas.draw_event(renderer)
1715 
1716     def draw_artist(self, a):
1717         """
1718         Draw :class:`matplotlib.artist.Artist` instance *a* only.
1719         This is available only after the figure is drawn.
1720         """
1721         if self._cachedRenderer is None:
1722             raise AttributeError("draw_artist can only be used after an "
1723                                  "initial draw which caches the renderer")
1724         a.draw(self._cachedRenderer)
1725 
1726     def get_axes(self):
1727         """
1728         Return a list of axes in the Figure. You can access and modify the
1729         axes in the Figure through this list.
1730 
1731         Do not modify the list itself. Instead, use `~Figure.add_axes`,
1732         `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.
1733 
1734         Note: This is equivalent to the property `~.Figure.axes`.
1735         """
1736         return self.axes
1737 
1738     # Note: in the docstring below, the newlines in the examples after the
1739     # calls to legend() allow replacing it with figlegend() to generate the
1740     # docstring of pyplot.figlegend.
1741 
1742     @docstring.dedent_interpd
1743     def legend(self, *args, **kwargs):
1744         """
1745         Place a legend on the figure.
1746 
1747         To make a legend from existing artists on every axes::
1748 
1749           legend()
1750 
1751         To make a legend for a list of lines and labels::
1752 
1753           legend(
1754               (line1, line2, line3),
1755               ('label1', 'label2', 'label3'),
1756               loc='upper right')
1757 
1758         These can also be specified by keyword::
1759 
1760           legend(
1761               handles=(line1, line2, line3),
1762               labels=('label1', 'label2', 'label3'),
1763               loc='upper right')
1764 
1765         Parameters
1766         ----------
1767 
1768         handles : sequence of `.Artist`, optional
1769             A list of Artists (lines, patches) to be added to the legend.
1770             Use this together with *labels*, if you need full control on what
1771             is shown in the legend and the automatic mechanism described above
1772             is not sufficient.
1773 
1774             The length of handles and labels should be the same in this
1775             case. If they are not, they are truncated to the smaller length.
1776 
1777         labels : sequence of strings, optional
1778             A list of labels to show next to the artists.
1779             Use this together with *handles*, if you need full control on what
1780             is shown in the legend and the automatic mechanism described above
1781             is not sufficient.
1782 
1783         Other Parameters
1784         ----------------
1785 
1786         %(_legend_kw_doc)s
1787 
1788         Returns
1789         -------
1790         :class:`matplotlib.legend.Legend` instance
1791 
1792         Notes
1793         -----
1794         Not all kinds of artist are supported by the legend command. See
1795         :doc:`/tutorials/intermediate/legend_guide` for details.
1796         """
1797 
1798         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1799                 self.axes,
1800                 *args,
1801                 **kwargs)
1802         # check for third arg
1803         if len(extra_args):
1804             # cbook.warn_deprecated(
1805             #     "2.1",
1806             #     message="Figure.legend will accept no more than two "
1807             #     "positional arguments in the future.  Use "
1808             #     "'fig.legend(handles, labels, loc=location)' "
1809             #     "instead.")
1810             # kwargs['loc'] = extra_args[0]
1811             # extra_args = extra_args[1:]
1812             pass
1813         l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)
1814         self.legends.append(l)
1815         l._remove_method = self.legends.remove
1816         self.stale = True
1817         return l
1818 
1819     @cbook._delete_parameter("3.1", "withdash")
1820     @docstring.dedent_interpd
1821     def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):
1822         """
1823         Add text to figure.
1824 
1825         Parameters
1826         ----------
1827         x, y : float
1828             The position to place the text. By default, this is in figure
1829             coordinates, floats in [0, 1]. The coordinate system can be changed
1830             using the *transform* keyword.
1831 
1832         s : str
1833             The text string.
1834 
1835         fontdict : dictionary, optional, default: None
1836             A dictionary to override the default text properties. If fontdict
1837             is None, the defaults are determined by your rc parameters. A
1838             property in *kwargs* override the same property in fontdict.
1839 
1840         withdash : boolean, optional, default: False
1841             Creates a `~matplotlib.text.TextWithDash` instance instead of a
1842             `~matplotlib.text.Text` instance.
1843 
1844         Other Parameters
1845         ----------------
1846         **kwargs : `~matplotlib.text.Text` properties
1847             Other miscellaneous text parameters.
1848             %(Text)s
1849 
1850         Returns
1851         -------
1852         text : `~.text.Text`
1853 
1854         See Also
1855         --------
1856         .Axes.text
1857         .pyplot.text
1858         """
1859         default = dict(transform=self.transFigure)
1860 
1861         if withdash:
1862             text = TextWithDash(x=x, y=y, text=s)
1863         else:
1864             text = Text(x=x, y=y, text=s)
1865 
1866         text.update(default)
1867         if fontdict is not None:
1868             text.update(fontdict)
1869         text.update(kwargs)
1870 
1871         text.set_figure(self)
1872         text.stale_callback = _stale_figure_callback
1873 
1874         self.texts.append(text)
1875         text._remove_method = self.texts.remove
1876         self.stale = True
1877         return text
1878 
1879     def _set_artist_props(self, a):
1880         if a != self:
1881             a.set_figure(self)
1882         a.stale_callback = _stale_figure_callback
1883         a.set_transform(self.transFigure)
1884 
1885     @docstring.dedent_interpd
1886     def gca(self, **kwargs):
1887         """
1888         Get the current axes, creating one if necessary.
1889 
1890         The following kwargs are supported for ensuring the returned axes
1891         adheres to the given projection etc., and for axes creation if
1892         the active axes does not exist:
1893 
1894         %(Axes)s
1895 
1896         """
1897         ckey, cax = self._axstack.current_key_axes()
1898         # if there exists an axes on the stack see if it matches
1899         # the desired axes configuration
1900         if cax is not None:
1901 
1902             # if no kwargs are given just return the current axes
1903             # this is a convenience for gca() on axes such as polar etc.
1904             if not kwargs:
1905                 return cax
1906 
1907             # if the user has specified particular projection detail
1908             # then build up a key which can represent this
1909             else:
1910                 projection_class, _, key = \
1911                     self._process_projection_requirements(**kwargs)
1912 
1913                 # let the returned axes have any gridspec by removing it from
1914                 # the key
1915                 ckey = ckey[1:]
1916                 key = key[1:]
1917 
1918                 # if the cax matches this key then return the axes, otherwise
1919                 # continue and a new axes will be created
1920                 if key == ckey and isinstance(cax, projection_class):
1921                     return cax
1922                 else:
1923                     cbook._warn_external('Requested projection is different '
1924                                          'from current axis projection, '
1925                                          'creating new axis with requested '
1926                                          'projection.')
1927 
1928         # no axes found, so create one which spans the figure
1929         return self.add_subplot(1, 1, 1, **kwargs)
1930 
1931     def sca(self, a):
1932         """Set the current axes to be a and return a."""
1933         self._axstack.bubble(a)
1934         for func in self._axobservers:
1935             func(self)
1936         return a
1937 
1938     def _gci(self):
1939         """
1940         Helper for :func:`~matplotlib.pyplot.gci`. Do not use elsewhere.
1941         """
1942         # Look first for an image in the current Axes:
1943         cax = self._axstack.current_key_axes()[1]
1944         if cax is None:
1945             return None
1946         im = cax._gci()
1947         if im is not None:
1948             return im
1949 
1950         # If there is no image in the current Axes, search for
1951         # one in a previously created Axes.  Whether this makes
1952         # sense is debatable, but it is the documented behavior.
1953         for ax in reversed(self.axes):
1954             im = ax._gci()
1955             if im is not None:
1956                 return im
1957         return None
1958 
1959     def __getstate__(self):
1960         state = super().__getstate__()
1961 
1962         # the axobservers cannot currently be pickled.
1963         # Additionally, the canvas cannot currently be pickled, but this has
1964         # the benefit of meaning that a figure can be detached from one canvas,
1965         # and re-attached to another.
1966         for attr_to_pop in ('_axobservers', 'show',
1967                             'canvas', '_cachedRenderer'):
1968             state.pop(attr_to_pop, None)
1969 
1970         # add version information to the state
1971         state['__mpl_version__'] = _mpl_version
1972 
1973         # check whether the figure manager (if any) is registered with pyplot
1974         from matplotlib import _pylab_helpers
1975         if getattr(self.canvas, 'manager', None) \
1976                 in _pylab_helpers.Gcf.figs.values():
1977             state['_restore_to_pylab'] = True
1978 
1979         # set all the layoutbox information to None.  kiwisolver objects can't
1980         # be pickled, so we lose the layout options at this point.
1981         state.pop('_layoutbox', None)
1982         # suptitle:
1983         if self._suptitle is not None:
1984             self._suptitle._layoutbox = None
1985 
1986         return state
1987 
1988     def __setstate__(self, state):
1989         version = state.pop('__mpl_version__')
1990         restore_to_pylab = state.pop('_restore_to_pylab', False)
1991 
1992         if version != _mpl_version:
1993             cbook._warn_external(
1994                 f"This figure was saved with matplotlib version {version} and "
1995                 f"is unlikely to function correctly.")
1996 
1997         self.__dict__ = state
1998 
1999         # re-initialise some of the unstored state information
2000         self._axobservers = []
2001         self.canvas = None
2002         self._layoutbox = None
2003 
2004         if restore_to_pylab:
2005             # lazy import to avoid circularity
2006             import matplotlib.pyplot as plt
2007             import matplotlib._pylab_helpers as pylab_helpers
2008             allnums = plt.get_fignums()
2009             num = max(allnums) + 1 if allnums else 1
2010             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)
2011 
2012             # XXX The following is a copy and paste from pyplot. Consider
2013             # factoring to pylab_helpers
2014 
2015             if self.get_label():
2016                 mgr.set_window_title(self.get_label())
2017 
2018             # make this figure current on button press event
2019             def make_active(event):
2020                 pylab_helpers.Gcf.set_active(mgr)
2021 
2022             mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',
2023                                                  make_active)
2024 
2025             pylab_helpers.Gcf.set_active(mgr)
2026             self.number = num
2027 
2028             plt.draw_if_interactive()
2029         self.stale = True
2030 
2031     def add_axobserver(self, func):
2032         """Whenever the axes state change, ``func(self)`` will be called."""
2033         self._axobservers.append(func)
2034 
2035     def savefig(self, fname, *, transparent=None, **kwargs):
2036         """
2037         Save the current figure.
2038 
2039         Call signature::
2040 
2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',
2042                   orientation='portrait', papertype=None, format=None,
2043                   transparent=False, bbox_inches=None, pad_inches=0.1,
2044                   frameon=None, metadata=None)
2045 
2046         The output formats available depend on the backend being used.
2047 
2048         Parameters
2049         ----------
2050 
2051         fname : str or PathLike or file-like object
2052             A path, or a Python file-like object, or
2053             possibly some backend-dependent object such as
2054             `matplotlib.backends.backend_pdf.PdfPages`.
2055 
2056             If *format* is not set, then the output format is inferred from
2057             the extension of *fname*, if any, and from :rc:`savefig.format`
2058             otherwise.  If *format* is set, it determines the output format.
2059 
2060             Hence, if *fname* is not a path or has no extension, remember to
2061             specify *format* to ensure that the correct backend is used.
2062 
2063         Other Parameters
2064         ----------------
2065 
2066         dpi : [ *None* | scalar > 0 | 'figure' ]
2067             The resolution in dots per inch.  If *None*, defaults to
2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.
2069 
2070         quality : [ *None* | 1 <= scalar <= 100 ]
2071             The image quality, on a scale from 1 (worst) to 95 (best).
2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).
2074             Values above 95 should be avoided; 100 completely disables the
2075             JPEG quantization stage.
2076 
2077         optimize : bool
2078             If *True*, indicates that the JPEG encoder should make an extra
2079             pass over the image in order to select optimal encoder settings.
2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.
2081             Is *False* by default.
2082 
2083         progressive : bool
2084             If *True*, indicates that this image should be stored as a
2085             progressive JPEG file. Applicable only if *format* is jpg or
2086             jpeg, ignored otherwise. Is *False* by default.
2087 
2088         facecolor : color spec or None, optional
2089             The facecolor of the figure; if *None*, defaults to
2090             :rc:`savefig.facecolor`.
2091 
2092         edgecolor : color spec or None, optional
2093             The edgecolor of the figure; if *None*, defaults to
2094             :rc:`savefig.edgecolor`
2095 
2096         orientation : {'landscape', 'portrait'}
2097             Currently only supported by the postscript backend.
2098 
2099         papertype : str
2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
2101             'a10', 'b0' through 'b10'. Only supported for postscript
2102             output.
2103 
2104         format : str
2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
2106             this is unset is documented under *fname*.
2107 
2108         transparent : bool
2109             If *True*, the axes patches will all be transparent; the
2110             figure patch will also be transparent unless facecolor
2111             and/or edgecolor are specified via kwargs.
2112             This is useful, for example, for displaying
2113             a plot on top of a colored background on a web page.  The
2114             transparency of these patches will be restored to their
2115             original values upon exit of this function.
2116 
2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional
2118             Bbox in inches. Only the given portion of the figure is
2119             saved. If 'tight', try to figure out the tight bbox of
2120             the figure. If None, use savefig.bbox
2121 
2122         pad_inches : scalar, optional
2123             Amount of padding around the figure when bbox_inches is
2124             'tight'. If None, use savefig.pad_inches
2125 
2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
2127             A list of extra artists that will be considered when the
2128             tight bbox is calculated.
2129 
2130         metadata : dict, optional
2131             Key/value pairs to store in the image metadata. The supported keys
2132             and defaults depend on the image format and backend:
2133 
2134             - 'png' with Agg backend: See the parameter ``metadata`` of
2135               `~.FigureCanvasAgg.print_png`.
2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of
2137               `~.backend_pdf.PdfPages`.
2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
2139 
2140         pil_kwargs : dict, optional
2141             Additional keyword arguments that are passed to `PIL.Image.save`
2142             when saving the figure.  Only applicable for formats that are saved
2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a
2144             non-None value) PNG.
2145         """
2146 
2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])
2148         if "frameon" in kwargs:
2149             cbook.warn_deprecated("3.1", name="frameon", obj_type="kwarg",
2150                                   alternative="facecolor")
2151             frameon = kwargs.pop("frameon")
2152             if frameon is None:
2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')
2154         else:
2155             frameon = False  # Won't pass "if frameon:" below.
2156         if transparent is None:
2157             transparent = rcParams['savefig.transparent']
2158 
2159         if transparent:
2160             kwargs.setdefault('facecolor', 'none')
2161             kwargs.setdefault('edgecolor', 'none')
2162             original_axes_colors = []
2163             for ax in self.axes:
2164                 patch = ax.patch
2165                 original_axes_colors.append((patch.get_facecolor(),
2166                                              patch.get_edgecolor()))
2167                 patch.set_facecolor('none')
2168                 patch.set_edgecolor('none')
2169         else:
2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])
2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])
2172 
2173         if frameon:
2174             original_frameon = self.patch.get_visible()
2175             self.patch.set_visible(frameon)
2176 
2177         self.canvas.print_figure(fname, **kwargs)
2178 
2179         if frameon:
2180             self.patch.set_visible(original_frameon)
2181 
2182         if transparent:
2183             for ax, cc in zip(self.axes, original_axes_colors):
2184                 ax.patch.set_facecolor(cc[0])
2185                 ax.patch.set_edgecolor(cc[1])
2186 
2187     @docstring.dedent_interpd
2188     def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):
2189         """
2190         Create a colorbar for a ScalarMappable instance, *mappable*.
2191 
2192         Documentation for the pyplot thin wrapper:
2193         %(colorbar_doc)s
2194         """
2195         if ax is None:
2196             ax = self.gca()
2197 
2198         # Store the value of gca so that we can set it back later on.
2199         current_ax = self.gca()
2200 
2201         if cax is None:
2202             if use_gridspec and isinstance(ax, SubplotBase)  \
2203                      and (not self.get_constrained_layout()):
2204                 cax, kw = cbar.make_axes_gridspec(ax, **kw)
2205             else:
2206                 cax, kw = cbar.make_axes(ax, **kw)
2207 
2208         # need to remove kws that cannot be passed to Colorbar
2209         NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',
2210                              'panchor']
2211         cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}
2212         cb = cbar.colorbar_factory(cax, mappable, **cb_kw)
2213 
2214         self.sca(current_ax)
2215         self.stale = True
2216         return cb
2217 
2218     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
2219                         wspace=None, hspace=None):
2220         """
2221         Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when
2222         *None*) and update the subplot locations.
2223 
2224         """
2225         if self.get_constrained_layout():
2226             self.set_constrained_layout(False)
2227             cbook._warn_external("This figure was using "
2228                                  "constrained_layout==True, but that is "
2229                                  "incompatible with subplots_adjust and or "
2230                                  "tight_layout: setting "
2231                                  "constrained_layout==False. ")
2232         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
2233         for ax in self.axes:
2234             if not isinstance(ax, SubplotBase):
2235                 # Check if sharing a subplots axis
2236                 if isinstance(ax._sharex, SubplotBase):
2237                     ax._sharex.update_params()
2238                     ax.set_position(ax._sharex.figbox)
2239                 elif isinstance(ax._sharey, SubplotBase):
2240                     ax._sharey.update_params()
2241                     ax.set_position(ax._sharey.figbox)
2242             else:
2243                 ax.update_params()
2244                 ax.set_position(ax.figbox)
2245         self.stale = True
2246 
2247     def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,
2248                mouse_pop=3, mouse_stop=2):
2249         """
2250         Blocking call to interact with a figure.
2251 
2252         Wait until the user clicks *n* times on the figure, and return the
2253         coordinates of each click in a list.
2254 
2255         There are three possible interactions:
2256 
2257         - Add a point.
2258         - Remove the most recently added point.
2259         - Stop the interaction and return the points added so far.
2260 
2261         The actions are assigned to mouse buttons via the arguments
2262         *mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined
2263         by the numbers:
2264 
2265         - 1: left mouse button
2266         - 2: middle mouse button
2267         - 3: right mouse button
2268         - None: no mouse button
2269 
2270         Parameters
2271         ----------
2272         n : int, optional, default: 1
2273             Number of mouse clicks to accumulate. If negative, accumulate
2274             clicks until the input is terminated manually.
2275         timeout : scalar, optional, default: 30
2276             Number of seconds to wait before timing out. If zero or negative
2277             will never timeout.
2278         show_clicks : bool, optional, default: False
2279             If True, show a red cross at the location of each click.
2280         mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)
2281             Mouse button used to add points.
2282         mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)
2283             Mouse button used to remove the most recently added point.
2284         mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)
2285             Mouse button used to stop input.
2286 
2287         Returns
2288         -------
2289         points : list of tuples
2290             A list of the clicked (x, y) coordinates.
2291 
2292         Notes
2293         -----
2294         The keyboard can also be used to select points in case your mouse
2295         does not have one or more of the buttons.  The delete and backspace
2296         keys act like right clicking (i.e., remove last point), the enter key
2297         terminates input and any other key (not already used by the window
2298         manager) selects a point.
2299         """
2300         blocking_mouse_input = BlockingMouseInput(self,
2301                                                   mouse_add=mouse_add,
2302                                                   mouse_pop=mouse_pop,
2303                                                   mouse_stop=mouse_stop)
2304         return blocking_mouse_input(n=n, timeout=timeout,
2305                                     show_clicks=show_clicks)
2306 
2307     def waitforbuttonpress(self, timeout=-1):
2308         """
2309         Blocking call to interact with the figure.
2310 
2311         This will return True is a key was pressed, False if a mouse
2312         button was pressed and None if *timeout* was reached without
2313         either being pressed.
2314 
2315         If *timeout* is negative, does not timeout.
2316         """
2317         blocking_input = BlockingKeyMouseInput(self)
2318         return blocking_input(timeout=timeout)
2319 
2320     def get_default_bbox_extra_artists(self):
2321         bbox_artists = [artist for artist in self.get_children()
2322                         if (artist.get_visible() and artist.get_in_layout())]
2323         for ax in self.axes:
2324             if ax.get_visible():
2325                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
2326         # we don't want the figure's patch to influence the bbox calculation
2327         bbox_artists.remove(self.patch)
2328         return bbox_artists
2329 
2330     def get_tightbbox(self, renderer, bbox_extra_artists=None):
2331         """
2332         Return a (tight) bounding box of the figure in inches.
2333 
2334         Artists that have ``artist.set_in_layout(False)`` are not included
2335         in the bbox.
2336 
2337         Parameters
2338         ----------
2339         renderer : `.RendererBase` instance
2340             renderer that will be used to draw the figures (i.e.
2341             ``fig.canvas.get_renderer()``)
2342 
2343         bbox_extra_artists : list of `.Artist` or ``None``
2344             List of artists to include in the tight bounding box.  If
2345             ``None`` (default), then all artist children of each axes are
2346             included in the tight bounding box.
2347 
2348         Returns
2349         -------
2350         bbox : `.BboxBase`
2351             containing the bounding box (in figure inches).
2352         """
2353 
2354         bb = []
2355         if bbox_extra_artists is None:
2356             artists = self.get_default_bbox_extra_artists()
2357         else:
2358             artists = bbox_extra_artists
2359 
2360         for a in artists:
2361             bbox = a.get_tightbbox(renderer)
2362             if bbox is not None and (bbox.width != 0 or bbox.height != 0):
2363                 bb.append(bbox)
2364 
2365         for ax in self.axes:
2366             if ax.get_visible():
2367                 # some axes don't take the bbox_extra_artists kwarg so we
2368                 # need this conditional....
2369                 try:
2370                     bbox = ax.get_tightbbox(renderer,
2371                             bbox_extra_artists=bbox_extra_artists)
2372                 except TypeError:
2373                     bbox = ax.get_tightbbox(renderer)
2374                 bb.append(bbox)
2375         bb = [b for b in bb
2376               if (np.isfinite(b.width) and np.isfinite(b.height)
2377                   and (b.width != 0 or b.height != 0))]
2378 
2379         if len(bb) == 0:
2380             return self.bbox_inches
2381 
2382         _bbox = Bbox.union(bb)
2383 
2384         bbox_inches = TransformedBbox(_bbox,
2385                                       Affine2D().scale(1. / self.dpi))
2386 
2387         return bbox_inches
2388 
2389     def init_layoutbox(self):
2390         """Initialize the layoutbox for use in constrained_layout."""
2391         if self._layoutbox is None:
2392             self._layoutbox = layoutbox.LayoutBox(parent=None,
2393                                      name='figlb',
2394                                      artist=self)
2395             self._layoutbox.constrain_geometry(0., 0., 1., 1.)
2396 
2397     def execute_constrained_layout(self, renderer=None):
2398         """
2399         Use ``layoutbox`` to determine pos positions within axes.
2400 
2401         See also `.set_constrained_layout_pads`.
2402         """
2403 
2404         from matplotlib._constrained_layout import do_constrained_layout
2405 
2406         _log.debug('Executing constrainedlayout')
2407         if self._layoutbox is None:
2408             cbook._warn_external("Calling figure.constrained_layout, but "
2409                                  "figure not setup to do constrained layout. "
2410                                  " You either called GridSpec without the "
2411                                  "fig keyword, you are using plt.subplot, "
2412                                  "or you need to call figure or subplots "
2413                                  "with the constrained_layout=True kwarg.")
2414             return
2415         w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()
2416         # convert to unit-relative lengths
2417         fig = self
2418         width, height = fig.get_size_inches()
2419         w_pad = w_pad / width
2420         h_pad = h_pad / height
2421         if renderer is None:
2422             renderer = layoutbox.get_renderer(fig)
2423         do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)
2424 
2425     def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,
2426                      rect=None):
2427         """
2428         Automatically adjust subplot parameters to give specified padding.
2429 
2430         To exclude an artist on the axes from the bounding box calculation
2431         that determines the subplot parameters (i.e. legend, or annotation),
2432         then set `a.set_in_layout(False)` for that artist.
2433 
2434         Parameters
2435         ----------
2436         renderer : subclass of `~.backend_bases.RendererBase`, optional
2437             Defaults to the renderer for the figure.
2438 
2439         pad : float, optional
2440             Padding between the figure edge and the edges of subplots,
2441             as a fraction of the font size.
2442         h_pad, w_pad : float, optional
2443             Padding (height/width) between edges of adjacent subplots,
2444             as a fraction of the font size.  Defaults to *pad*.
2445         rect : tuple (left, bottom, right, top), optional
2446             A rectangle (left, bottom, right, top) in the normalized
2447             figure coordinate that the whole subplots area (including
2448             labels) will fit into. Default is (0, 0, 1, 1).
2449 
2450         See Also
2451         --------
2452         .Figure.set_tight_layout
2453         .pyplot.tight_layout
2454         """
2455 
2456         from .tight_layout import (
2457             get_renderer, get_subplotspec_list, get_tight_layout_figure)
2458 
2459         subplotspec_list = get_subplotspec_list(self.axes)
2460         if None in subplotspec_list:
2461             cbook._warn_external("This figure includes Axes that are not "
2462                                  "compatible with tight_layout, so results "
2463                                  "might be incorrect.")
2464 
2465         if renderer is None:
2466             renderer = get_renderer(self)
2467 
2468         kwargs = get_tight_layout_figure(
2469             self, self.axes, subplotspec_list, renderer,
2470             pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2471         if kwargs:
2472             self.subplots_adjust(**kwargs)
2473 
2474     def align_xlabels(self, axs=None):
2475         """
2476         Align the ylabels of subplots in the same subplot column if label
2477         alignment is being done automatically (i.e. the label position is
2478         not manually set).
2479 
2480         Alignment persists for draw events after this is called.
2481 
2482         If a label is on the bottom, it is aligned with labels on axes that
2483         also have their label on the bottom and that have the same
2484         bottom-most subplot row.  If the label is on the top,
2485         it is aligned with labels on axes with the same top-most row.
2486 
2487         Parameters
2488         ----------
2489         axs : list of `~matplotlib.axes.Axes`
2490             Optional list of (or ndarray) `~matplotlib.axes.Axes`
2491             to align the xlabels.
2492             Default is to align all axes on the figure.
2493 
2494         See Also
2495         --------
2496         matplotlib.figure.Figure.align_ylabels
2497 
2498         matplotlib.figure.Figure.align_labels
2499 
2500         Notes
2501         -----
2502         This assumes that ``axs`` are from the same `.GridSpec`, so that
2503         their `.SubplotSpec` positions correspond to figure positions.
2504 
2505         Examples
2506         --------
2507         Example with rotated xtick labels::
2508 
2509             fig, axs = plt.subplots(1, 2)
2510             for tick in axs[0].get_xticklabels():
2511                 tick.set_rotation(55)
2512             axs[0].set_xlabel('XLabel 0')
2513             axs[1].set_xlabel('XLabel 1')
2514             fig.align_xlabels()
2515 
2516         """
2517 
2518         if axs is None:
2519             axs = self.axes
2520         axs = np.asarray(axs).ravel()
2521         for ax in axs:
2522             _log.debug(' Working on: %s', ax.get_xlabel())
2523             ss = ax.get_subplotspec()
2524             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2525             labpo = ax.xaxis.get_label_position()  # top or bottom
2526 
2527             # loop through other axes, and search for label positions
2528             # that are same as this one, and that share the appropriate
2529             # row number.
2530             #  Add to a grouper associated with each axes of sibblings.
2531             # This list is inspected in `axis.draw` by
2532             # `axis._update_label_position`.
2533             for axc in axs:
2534                 if axc.xaxis.get_label_position() == labpo:
2535                     ss = axc.get_subplotspec()
2536                     nrows, ncols, rowc0, rowc1, colc, col1 = \
2537                             ss.get_rows_columns()
2538                     if (labpo == 'bottom' and rowc1 == row1 or
2539                         labpo == 'top' and rowc0 == row0):
2540                         # grouper for groups of xlabels to align
2541                         self._align_xlabel_grp.join(ax, axc)
2542 
2543     def align_ylabels(self, axs=None):
2544         """
2545         Align the ylabels of subplots in the same subplot column if label
2546         alignment is being done automatically (i.e. the label position is
2547         not manually set).
2548 
2549         Alignment persists for draw events after this is called.
2550 
2551         If a label is on the left, it is aligned with labels on axes that
2552         also have their label on the left and that have the same
2553         left-most subplot column.  If the label is on the right,
2554         it is aligned with labels on axes with the same right-most column.
2555 
2556         Parameters
2557         ----------
2558         axs : list of `~matplotlib.axes.Axes`
2559             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2560             to align the ylabels.
2561             Default is to align all axes on the figure.
2562 
2563         See Also
2564         --------
2565         matplotlib.figure.Figure.align_xlabels
2566 
2567         matplotlib.figure.Figure.align_labels
2568 
2569         Notes
2570         -----
2571         This assumes that ``axs`` are from the same `.GridSpec`, so that
2572         their `.SubplotSpec` positions correspond to figure positions.
2573 
2574         Examples
2575         --------
2576         Example with large yticks labels::
2577 
2578             fig, axs = plt.subplots(2, 1)
2579             axs[0].plot(np.arange(0, 1000, 50))
2580             axs[0].set_ylabel('YLabel 0')
2581             axs[1].set_ylabel('YLabel 1')
2582             fig.align_ylabels()
2583 
2584         """
2585 
2586         if axs is None:
2587             axs = self.axes
2588         axs = np.asarray(axs).ravel()
2589         for ax in axs:
2590             _log.debug(' Working on: %s', ax.get_ylabel())
2591             ss = ax.get_subplotspec()
2592             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()
2593             labpo = ax.yaxis.get_label_position()  # left or right
2594             # loop through other axes, and search for label positions
2595             # that are same as this one, and that share the appropriate
2596             # column number.
2597             # Add to a list associated with each axes of sibblings.
2598             # This list is inspected in `axis.draw` by
2599             # `axis._update_label_position`.
2600             for axc in axs:
2601                 if axc != ax:
2602                     if axc.yaxis.get_label_position() == labpo:
2603                         ss = axc.get_subplotspec()
2604                         nrows, ncols, row0, row1, colc0, colc1 = \
2605                                 ss.get_rows_columns()
2606                         if (labpo == 'left' and colc0 == col0 or
2607                             labpo == 'right' and colc1 == col1):
2608                             # grouper for groups of ylabels to align
2609                             self._align_ylabel_grp.join(ax, axc)
2610 
2611     def align_labels(self, axs=None):
2612         """
2613         Align the xlabels and ylabels of subplots with the same subplots
2614         row or column (respectively) if label alignment is being
2615         done automatically (i.e. the label position is not manually set).
2616 
2617         Alignment persists for draw events after this is called.
2618 
2619         Parameters
2620         ----------
2621         axs : list of `~matplotlib.axes.Axes`
2622             Optional list (or ndarray) of `~matplotlib.axes.Axes`
2623             to align the labels.
2624             Default is to align all axes on the figure.
2625 
2626         See Also
2627         --------
2628         matplotlib.figure.Figure.align_xlabels
2629 
2630         matplotlib.figure.Figure.align_ylabels
2631         """
2632         self.align_xlabels(axs=axs)
2633         self.align_ylabels(axs=axs)
2634 
2635     def add_gridspec(self, nrows, ncols, **kwargs):
2636         """
2637         Return a `.GridSpec` that has this figure as a parent.  This allows
2638         complex layout of axes in the figure.
2639 
2640         Parameters
2641         ----------
2642         nrows : int
2643             Number of rows in grid.
2644 
2645         ncols : int
2646             Number or columns in grid.
2647 
2648         Returns
2649         -------
2650         gridspec : `.GridSpec`
2651 
2652         Other Parameters
2653         ----------------
2654         **kwargs
2655             Keyword arguments are passed to `.GridSpec`.
2656 
2657         See Also
2658         --------
2659         matplotlib.pyplot.subplots
2660 
2661         Examples
2662         --------
2663         Adding a subplot that spans two rows::
2664 
2665             fig = plt.figure()
2666             gs = fig.add_gridspec(2, 2)
2667             ax1 = fig.add_subplot(gs[0, 0])
2668             ax2 = fig.add_subplot(gs[1, 0])
2669             # spans two rows:
2670             ax3 = fig.add_subplot(gs[:, 1])
2671 
2672         """
2673 
2674         _ = kwargs.pop('figure', None)  # pop in case user has added this...
2675         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
2676         self._gridspecs.append(gs)
2677         return gs
2678 
2679 
2680 def figaspect(arg):
2681     """
2682     Calculate the width and height for a figure with a specified aspect ratio.
2683 
2684     While the height is taken from :rc:`figure.figsize`, the width is
2685     adjusted to match the desired aspect ratio. Additionally, it is ensured
2686     that the width is in the range [4., 16.] and the height is in the range
2687     [2., 16.]. If necessary, the default height is adjusted to ensure this.
2688 
2689     Parameters
2690     ----------
2691     arg : scalar or 2d array
2692         If a scalar, this defines the aspect ratio (i.e. the ratio height /
2693         width).
2694         In case of an array the aspect ratio is number of rows / number of
2695         columns, so that the array could be fitted in the figure undistorted.
2696 
2697     Returns
2698     -------
2699     width, height
2700         The figure size in inches.
2701 
2702     Notes
2703     -----
2704     If you want to create an axes within the figure, that still preserves the
2705     aspect ratio, be sure to create it with equal width and height. See
2706     examples below.
2707 
2708     Thanks to Fernando Perez for this function.
2709 
2710     Examples
2711     --------
2712     Make a figure twice as tall as it is wide::
2713 
2714         w, h = figaspect(2.)
2715         fig = Figure(figsize=(w, h))
2716         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
2717         ax.imshow(A, **kwargs)
2718 
2719     Make a figure with the proper aspect for an array::
2720 
2721         A = rand(5,3)
2722         w, h = figaspect(A)
2723         fig = Figure(figsize=(w, h))
2724         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
2725         ax.imshow(A, **kwargs)
2726     """
2727 
2728     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)
2729 
2730     # min/max sizes to respect when autoscaling.  If John likes the idea, they
2731     # could become rc parameters, for now they're hardwired.
2732     figsize_min = np.array((4.0, 2.0))  # min length for width/height
2733     figsize_max = np.array((16.0, 16.0))  # max length for width/height
2734 
2735     # Extract the aspect ratio of the array
2736     if isarray:
2737         nr, nc = arg.shape[:2]
2738         arr_ratio = nr / nc
2739     else:
2740         arr_ratio = arg
2741 
2742     # Height of user figure defaults
2743     fig_height = rcParams['figure.figsize'][1]
2744 
2745     # New size for the figure, keeping the aspect ratio of the caller
2746     newsize = np.array((fig_height / arr_ratio, fig_height))
2747 
2748     # Sanity checks, don't drop either dimension below figsize_min
2749     newsize /= min(1.0, *(newsize / figsize_min))
2750 
2751     # Avoid humongous windows as well
2752     newsize /= max(1.0, *(newsize / figsize_max))
2753 
2754     # Finally, if we have a really funky aspect ratio, break it but respect
2755     # the min/max dimensions (we don't want figures 10 feet tall!)
2756     newsize = np.clip(newsize, figsize_min, figsize_max)
2757     return newsize
2758 
2759 docstring.interpd.update(Figure=martist.kwdoc(Figure))

</code><intended_behavior>Ensure that when the `figsize` parameter is processed, there is explicit validation to check that both width and height values are greater than zero. If a value of zero is encountered, raise a ValueError with a clear message indicating that figure dimensions must be positive. This preserves the functionality of figure creation and saving while preventing the situation that leads to a crash due to invalid dimensions.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 a MATLAB-like way of plotting.
7 
8 pyplot is mainly intended for interactive plots and simple cases of
9 programmatic plot generation::
10 
11     import numpy as np
12     import matplotlib.pyplot as plt
13 
14     x = np.arange(0, 5, 0.1)
15     y = np.sin(x)
16     plt.plot(x, y)
17 
18 The object-oriented API is recommended for more complex plots.
19 """
20 
21 import functools
22 import importlib
23 import inspect
24 import logging
25 from numbers import Number
26 import re
27 import sys
28 import time
29 
30 from cycler import cycler
31 import matplotlib
32 import matplotlib.colorbar
33 import matplotlib.image
34 from matplotlib import rcsetup, style
35 from matplotlib import _pylab_helpers, interactive
36 from matplotlib import cbook
37 from matplotlib.cbook import dedent, deprecated, silent_list, warn_deprecated
38 from matplotlib import docstring
39 from matplotlib.backend_bases import FigureCanvasBase
40 from matplotlib.figure import Figure, figaspect
41 from matplotlib.gridspec import GridSpec
42 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig
43 from matplotlib import rc_context
44 from matplotlib.rcsetup import interactive_bk as _interactive_bk
45 from matplotlib.artist import getp, get, Artist
46 from matplotlib.artist import setp as _setp
47 from matplotlib.axes import Axes, Subplot
48 from matplotlib.projections import PolarAxes
49 from matplotlib import mlab  # for _csv2rec, detrend_none, window_hanning
50 from matplotlib.scale import get_scale_docs, get_scale_names
51 
52 from matplotlib import cm
53 from matplotlib.cm import get_cmap, register_cmap
54 
55 import numpy as np
56 
57 # We may not need the following imports here:
58 from matplotlib.colors import Normalize
59 from matplotlib.lines import Line2D
60 from matplotlib.text import Text, Annotation
61 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
62 from matplotlib.widgets import SubplotTool, Button, Slider, Widget
63 
64 from .ticker import TickHelper, Formatter, FixedFormatter, NullFormatter,\
65            FuncFormatter, FormatStrFormatter, ScalarFormatter,\
66            LogFormatter, LogFormatterExponent, LogFormatterMathtext,\
67            Locator, IndexLocator, FixedLocator, NullLocator,\
68            LinearLocator, LogLocator, AutoLocator, MultipleLocator,\
69            MaxNLocator
70 from matplotlib.backends import pylab_setup, _get_running_interactive_framework
71 
72 _log = logging.getLogger(__name__)
73 
74 
75 ## Global ##
76 
77 
78 _IP_REGISTERED = None
79 _INSTALL_FIG_OBSERVER = False
80 
81 
82 def install_repl_displayhook():
83     """
84     Install a repl display hook so that any stale figure are automatically
85     redrawn when control is returned to the repl.
86 
87     This works both with IPython and with vanilla python shells.
88     """
89     global _IP_REGISTERED
90     global _INSTALL_FIG_OBSERVER
91 
92     class _NotIPython(Exception):
93         pass
94 
95     # see if we have IPython hooks around, if use them
96 
97     try:
98         if 'IPython' in sys.modules:
99             from IPython import get_ipython
100             ip = get_ipython()
101             if ip is None:
102                 raise _NotIPython()
103 
104             if _IP_REGISTERED:
105                 return
106 
107             def post_execute():
108                 if matplotlib.is_interactive():
109                     draw_all()
110 
111             # IPython >= 2
112             try:
113                 ip.events.register('post_execute', post_execute)
114             except AttributeError:
115                 # IPython 1.x
116                 ip.register_post_execute(post_execute)
117 
118             _IP_REGISTERED = post_execute
119             _INSTALL_FIG_OBSERVER = False
120 
121             # trigger IPython's eventloop integration, if available
122             from IPython.core.pylabtools import backend2gui
123 
124             ipython_gui_name = backend2gui.get(get_backend())
125             if ipython_gui_name:
126                 ip.enable_gui(ipython_gui_name)
127         else:
128             _INSTALL_FIG_OBSERVER = True
129 
130     # import failed or ipython is not running
131     except (ImportError, _NotIPython):
132         _INSTALL_FIG_OBSERVER = True
133 
134 
135 def uninstall_repl_displayhook():
136     """
137     Uninstall the matplotlib display hook.
138 
139     .. warning
140 
141        Need IPython >= 2 for this to work.  For IPython < 2 will raise a
142        ``NotImplementedError``
143 
144     .. warning
145 
146        If you are using vanilla python and have installed another
147        display hook this will reset ``sys.displayhook`` to what ever
148        function was there when matplotlib installed it's displayhook,
149        possibly discarding your changes.
150     """
151     global _IP_REGISTERED
152     global _INSTALL_FIG_OBSERVER
153     if _IP_REGISTERED:
154         from IPython import get_ipython
155         ip = get_ipython()
156         try:
157             ip.events.unregister('post_execute', _IP_REGISTERED)
158         except AttributeError:
159             raise NotImplementedError("Can not unregister events "
160                                       "in IPython < 2.0")
161         _IP_REGISTERED = None
162 
163     if _INSTALL_FIG_OBSERVER:
164         _INSTALL_FIG_OBSERVER = False
165 
166 
167 draw_all = _pylab_helpers.Gcf.draw_all
168 
169 
170 @functools.wraps(matplotlib.set_loglevel)
171 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.
172     return matplotlib.set_loglevel(*args, **kwargs)
173 
174 
175 @docstring.copy(Artist.findobj)
176 def findobj(o=None, match=None, include_self=True):
177     if o is None:
178         o = gcf()
179     return o.findobj(match, include_self=include_self)
180 
181 
182 def switch_backend(newbackend):
183     """
184     Close all open figures and set the Matplotlib backend.
185 
186     The argument is case-insensitive.  Switching to an interactive backend is
187     possible only if no event loop for another interactive backend has started.
188     Switching to and from non-interactive backends is always possible.
189 
190     Parameters
191     ----------
192     newbackend : str
193         The name of the backend to use.
194     """
195     close("all")
196 
197     if newbackend is rcsetup._auto_backend_sentinel:
198         # Don't try to fallback on the cairo-based backends as they each have
199         # an additional dependency (pycairo) over the agg-based backend, and
200         # are of worse quality.
201         for candidate in ["macosx", "qt5agg", "qt4agg", "gtk3agg", "tkagg",
202                           "wxagg", "agg"]:
203             try:
204                 switch_backend(candidate)
205             except ImportError:
206                 continue
207             else:
208                 rcParamsOrig['backend'] = candidate
209                 return
210 
211     backend_name = (
212         newbackend[9:] if newbackend.startswith("module://")
213         else "matplotlib.backends.backend_{}".format(newbackend.lower()))
214 
215     backend_mod = importlib.import_module(backend_name)
216     Backend = type(
217         "Backend", (matplotlib.backends._Backend,), vars(backend_mod))
218     _log.debug("Loaded backend %s version %s.",
219                newbackend, Backend.backend_version)
220 
221     required_framework = Backend.required_interactive_framework
222     if required_framework is not None:
223         current_framework = \
224             matplotlib.backends._get_running_interactive_framework()
225         if (current_framework and required_framework
226                 and current_framework != required_framework):
227             raise ImportError(
228                 "Cannot load backend {!r} which requires the {!r} interactive "
229                 "framework, as {!r} is currently running".format(
230                     newbackend, required_framework, current_framework))
231 
232     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
233 
234     global _backend_mod, new_figure_manager, draw_if_interactive, _show
235     _backend_mod = backend_mod
236     new_figure_manager = Backend.new_figure_manager
237     draw_if_interactive = Backend.draw_if_interactive
238     _show = Backend.show
239 
240     # Need to keep a global reference to the backend for compatibility reasons.
241     # See https://github.com/matplotlib/matplotlib/issues/6092
242     matplotlib.backends.backend = newbackend
243 
244 
245 def show(*args, **kw):
246     """
247     Display a figure.
248     When running in ipython with its pylab mode, display all
249     figures and return to the ipython prompt.
250 
251     In non-interactive mode, display all figures and block until
252     the figures have been closed; in interactive mode it has no
253     effect unless figures were created prior to a change from
254     non-interactive to interactive mode (not recommended).  In
255     that case it displays the figures but does not block.
256 
257     A single experimental keyword argument, *block*, may be
258     set to True or False to override the blocking behavior
259     described above.
260     """
261     global _show
262     return _show(*args, **kw)
263 
264 
265 def isinteractive():
266     """Return the status of interactive mode."""
267     return matplotlib.is_interactive()
268 
269 
270 def ioff():
271     """Turn the interactive mode off."""
272     matplotlib.interactive(False)
273     uninstall_repl_displayhook()
274 
275 
276 def ion():
277     """Turn the interactive mode on."""
278     matplotlib.interactive(True)
279     install_repl_displayhook()
280 
281 
282 def pause(interval):
283     """
284     Pause for *interval* seconds.
285 
286     If there is an active figure, it will be updated and displayed before the
287     pause, and the GUI event loop (if any) will run during the pause.
288 
289     This can be used for crude animation.  For more complex animation, see
290     :mod:`matplotlib.animation`.
291 
292     Notes
293     -----
294     This function is experimental; its behavior may be changed or extended in a
295     future release.
296     """
297     manager = _pylab_helpers.Gcf.get_active()
298     if manager is not None:
299         canvas = manager.canvas
300         if canvas.figure.stale:
301             canvas.draw_idle()
302         show(block=False)
303         canvas.start_event_loop(interval)
304     else:
305         time.sleep(interval)
306 
307 
308 @docstring.copy(matplotlib.rc)
309 def rc(group, **kwargs):
310     matplotlib.rc(group, **kwargs)
311 
312 
313 @docstring.copy(matplotlib.rc_context)
314 def rc_context(rc=None, fname=None):
315     return matplotlib.rc_context(rc, fname)
316 
317 
318 @docstring.copy(matplotlib.rcdefaults)
319 def rcdefaults():
320     matplotlib.rcdefaults()
321     if matplotlib.is_interactive():
322         draw_all()
323 
324 
325 ## Current image ##
326 
327 
328 def gci():
329     """
330     Get the current colorable artist.  Specifically, returns the
331     current :class:`~matplotlib.cm.ScalarMappable` instance (image or
332     patch collection), or *None* if no images or patch collections
333     have been defined.  The commands :func:`~matplotlib.pyplot.imshow`
334     and :func:`~matplotlib.pyplot.figimage` create
335     :class:`~matplotlib.image.Image` instances, and the commands
336     :func:`~matplotlib.pyplot.pcolor` and
337     :func:`~matplotlib.pyplot.scatter` create
338     :class:`~matplotlib.collections.Collection` instances.  The
339     current image is an attribute of the current axes, or the nearest
340     earlier axes in the current figure that contains an image.
341     """
342     return gcf()._gci()
343 
344 
345 ## Any Artist ##
346 
347 
348 # (getp is simply imported)
349 @docstring.copy(_setp)
350 def setp(obj, *args, **kwargs):
351     return _setp(obj, *args, **kwargs)
352 
353 
354 def xkcd(scale=1, length=100, randomness=2):
355     """
356     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.
357     This will only have effect on things drawn after this function is
358     called.
359 
360     For best results, the "Humor Sans" font should be installed: it is
361     not included with matplotlib.
362 
363     Parameters
364     ----------
365     scale : float, optional
366         The amplitude of the wiggle perpendicular to the source line.
367     length : float, optional
368         The length of the wiggle along the line.
369     randomness : float, optional
370         The scale factor by which the length is shrunken or expanded.
371 
372     Notes
373     -----
374     This function works by a number of rcParams, so it will probably
375     override others you have set before.
376 
377     If you want the effects of this function to be temporary, it can
378     be used as a context manager, for example::
379 
380         with plt.xkcd():
381             # This figure will be in XKCD-style
382             fig1 = plt.figure()
383             # ...
384 
385         # This figure will be in regular style
386         fig2 = plt.figure()
387     """
388     if rcParams['text.usetex']:
389         raise RuntimeError(
390             "xkcd mode is not compatible with text.usetex = True")
391 
392     from matplotlib import patheffects
393     return rc_context({
394         'font.family': ['xkcd', 'Humor Sans', 'Comic Sans MS'],
395         'font.size': 14.0,
396         'path.sketch': (scale, length, randomness),
397         'path.effects': [patheffects.withStroke(linewidth=4, foreground="w")],
398         'axes.linewidth': 1.5,
399         'lines.linewidth': 2.0,
400         'figure.facecolor': 'white',
401         'grid.linewidth': 0.0,
402         'axes.grid': False,
403         'axes.unicode_minus': False,
404         'axes.edgecolor': 'black',
405         'xtick.major.size': 8,
406         'xtick.major.width': 3,
407         'ytick.major.size': 8,
408         'ytick.major.width': 3,
409     })
410 
411 
412 ## Figures ##
413 
414 def figure(num=None,  # autoincrement if None, else integer from 1-N
415            figsize=None,  # defaults to rc figure.figsize
416            dpi=None,  # defaults to rc figure.dpi
417            facecolor=None,  # defaults to rc figure.facecolor
418            edgecolor=None,  # defaults to rc figure.edgecolor
419            frameon=True,
420            FigureClass=Figure,
421            clear=False,
422            **kwargs
423            ):
424     """
425     Create a new figure.
426 
427     Parameters
428     ----------
429 
430     num : integer or string, optional, default: None
431         If not provided, a new figure will be created, and the figure number
432         will be incremented. The figure objects holds this number in a `number`
433         attribute.
434         If num is provided, and a figure with this id already exists, make
435         it active, and returns a reference to it. If this figure does not
436         exists, create it and returns it.
437         If num is a string, the window title will be set to this figure's
438         `num`.
439 
440     figsize : (float, float), optional, default: None
441         width, height in inches. If not provided, defaults to
442         :rc:`figure.figsize` = ``[6.4, 4.8]``.
443 
444     dpi : integer, optional, default: None
445         resolution of the figure. If not provided, defaults to
446         :rc:`figure.dpi` = ``100``.
447 
448     facecolor : color spec
449         the background color. If not provided, defaults to
450         :rc:`figure.facecolor` = ``'w'``.
451 
452     edgecolor : color spec
453         the border color. If not provided, defaults to
454         :rc:`figure.edgecolor` = ``'w'``.
455 
456     frameon : bool, optional, default: True
457         If False, suppress drawing the figure frame.
458 
459     FigureClass : subclass of `~matplotlib.figure.Figure`
460         Optionally use a custom `.Figure` instance.
461 
462     clear : bool, optional, default: False
463         If True and the figure already exists, then it is cleared.
464 
465     Returns
466     -------
467     figure : `~matplotlib.figure.Figure`
468         The `.Figure` instance returned will also be passed to
469         new_figure_manager in the backends, which allows to hook custom
470         `.Figure` classes into the pyplot interface. Additional kwargs will be
471         passed to the `.Figure` init function.
472 
473     Notes
474     -----
475     If you are creating many figures, make sure you explicitly call
476     :func:`.pyplot.close` on the figures you are not using, because this will
477     enable pyplot to properly clean up the memory.
478 
479     `~matplotlib.rcParams` defines the default values, which can be modified
480     in the matplotlibrc file.
481     """
482 
483     if figsize is None:
484         figsize = rcParams['figure.figsize']
485     if dpi is None:
486         dpi = rcParams['figure.dpi']
487     if facecolor is None:
488         facecolor = rcParams['figure.facecolor']
489     if edgecolor is None:
490         edgecolor = rcParams['figure.edgecolor']
491 
492     allnums = get_fignums()
493     next_num = max(allnums) + 1 if allnums else 1
494     figLabel = ''
495     if num is None:
496         num = next_num
497     elif isinstance(num, str):
498         figLabel = num
499         allLabels = get_figlabels()
500         if figLabel not in allLabels:
501             if figLabel == 'all':
502                 cbook._warn_external(
503                     "close('all') closes all existing figures")
504             num = next_num
505         else:
506             inum = allLabels.index(figLabel)
507             num = allnums[inum]
508     else:
509         num = int(num)  # crude validation of num argument
510 
511     figManager = _pylab_helpers.Gcf.get_fig_manager(num)
512     if figManager is None:
513         max_open_warning = rcParams['figure.max_open_warning']
514 
515         if len(allnums) >= max_open_warning >= 1:
516             cbook._warn_external(
517                 "More than %d figures have been opened. Figures "
518                 "created through the pyplot interface "
519                 "(`matplotlib.pyplot.figure`) are retained until "
520                 "explicitly closed and may consume too much memory. "
521                 "(To control this warning, see the rcParam "
522                 "`figure.max_open_warning`)." %
523                 max_open_warning, RuntimeWarning)
524 
525         if get_backend().lower() == 'ps':
526             dpi = 72
527 
528         figManager = new_figure_manager(num, figsize=figsize,
529                                         dpi=dpi,
530                                         facecolor=facecolor,
531                                         edgecolor=edgecolor,
532                                         frameon=frameon,
533                                         FigureClass=FigureClass,
534                                         **kwargs)
535 
536         if figLabel:
537             figManager.set_window_title(figLabel)
538             figManager.canvas.figure.set_label(figLabel)
539 
540         # make this figure current on button press event
541         def make_active(event):
542             _pylab_helpers.Gcf.set_active(figManager)
543 
544         cid = figManager.canvas.mpl_connect('button_press_event', make_active)
545         figManager._cidgcf = cid
546 
547         _pylab_helpers.Gcf.set_active(figManager)
548         fig = figManager.canvas.figure
549         fig.number = num
550 
551         # make sure backends (inline) that we don't ship that expect this
552         # to be called in plotting commands to make the figure call show
553         # still work.  There is probably a better way to do this in the
554         # FigureManager base class.
555         if matplotlib.is_interactive():
556             draw_if_interactive()
557 
558         if _INSTALL_FIG_OBSERVER:
559             fig.stale_callback = _auto_draw_if_interactive
560 
561     if clear:
562         figManager.canvas.figure.clear()
563 
564     return figManager.canvas.figure
565 
566 
567 def _auto_draw_if_interactive(fig, val):
568     """
569     This is an internal helper function for making sure that auto-redrawing
570     works as intended in the plain python repl.
571 
572     Parameters
573     ----------
574     fig : Figure
575         A figure object which is assumed to be associated with a canvas
576     """
577     if val and matplotlib.is_interactive() and not fig.canvas.is_saving():
578         fig.canvas.draw_idle()
579 
580 
581 def gcf():
582     """Get a reference to the current figure."""
583     figManager = _pylab_helpers.Gcf.get_active()
584     if figManager is not None:
585         return figManager.canvas.figure
586     else:
587         return figure()
588 
589 
590 def fignum_exists(num):
591     """Return whether the figure with the given id exists."""
592     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
593 
594 
595 def get_fignums():
596     """Return a list of existing figure numbers."""
597     return sorted(_pylab_helpers.Gcf.figs)
598 
599 
600 def get_figlabels():
601     """Return a list of existing figure labels."""
602     figManagers = _pylab_helpers.Gcf.get_all_fig_managers()
603     figManagers.sort(key=lambda m: m.num)
604     return [m.canvas.figure.get_label() for m in figManagers]
605 
606 
607 def get_current_fig_manager():
608     """
609     Return the figure manager of the active figure.
610 
611     If there is currently no active figure, a new one is created.
612     """
613     figManager = _pylab_helpers.Gcf.get_active()
614     if figManager is None:
615         gcf()  # creates an active figure as a side effect
616         figManager = _pylab_helpers.Gcf.get_active()
617     return figManager
618 
619 
620 @docstring.copy(FigureCanvasBase.mpl_connect)
621 def connect(s, func):
622     return get_current_fig_manager().canvas.mpl_connect(s, func)
623 
624 
625 @docstring.copy(FigureCanvasBase.mpl_disconnect)
626 def disconnect(cid):
627     return get_current_fig_manager().canvas.mpl_disconnect(cid)
628 
629 
630 def close(fig=None):
631     """
632     Close a figure window.
633 
634     Parameters
635     ----------
636     fig : None or int or str or `.Figure`
637         The figure to close. There are a number of ways to specify this:
638 
639         - *None*: the current figure
640         - `.Figure`: the given `.Figure` instance
641         - ``int``: a figure number
642         - ``str``: a figure name
643         - 'all': all figures
644 
645     """
646     if fig is None:
647         figManager = _pylab_helpers.Gcf.get_active()
648         if figManager is None:
649             return
650         else:
651             _pylab_helpers.Gcf.destroy(figManager.num)
652     elif fig == 'all':
653         _pylab_helpers.Gcf.destroy_all()
654     elif isinstance(fig, int):
655         _pylab_helpers.Gcf.destroy(fig)
656     elif hasattr(fig, 'int'):
657         # if we are dealing with a type UUID, we
658         # can use its integer representation
659         _pylab_helpers.Gcf.destroy(fig.int)
660     elif isinstance(fig, str):
661         allLabels = get_figlabels()
662         if fig in allLabels:
663             num = get_fignums()[allLabels.index(fig)]
664             _pylab_helpers.Gcf.destroy(num)
665     elif isinstance(fig, Figure):
666         _pylab_helpers.Gcf.destroy_fig(fig)
667     else:
668         raise TypeError("close() argument must be a Figure, an int, a string, "
669                         "or None, not '%s'")
670 
671 
672 def clf():
673     """Clear the current figure."""
674     gcf().clf()
675 
676 
677 def draw():
678     """Redraw the current figure.
679 
680     This is used to update a figure that has been altered, but not
681     automatically re-drawn.  If interactive mode is on (:func:`.ion()`), this
682     should be only rarely needed, but there may be ways to modify the state of
683     a figure without marking it as `stale`.  Please report these cases as
684     bugs.
685 
686     A more object-oriented alternative, given any
687     :class:`~matplotlib.figure.Figure` instance, :attr:`fig`, that
688     was created using a :mod:`~matplotlib.pyplot` function, is::
689 
690         fig.canvas.draw_idle()
691     """
692     get_current_fig_manager().canvas.draw_idle()
693 
694 
695 @docstring.copy(Figure.savefig)
696 def savefig(*args, **kwargs):
697     fig = gcf()
698     res = fig.savefig(*args, **kwargs)
699     fig.canvas.draw_idle()   # need this if 'transparent=True' to reset colors
700     return res
701 
702 
703 ## Putting things in figures ##
704 
705 
706 def figlegend(*args, **kwargs):
707     return gcf().legend(*args, **kwargs)
708 if Figure.legend.__doc__:
709     figlegend.__doc__ = Figure.legend.__doc__.replace("legend(", "figlegend(")
710 
711 
712 ## Axes ##
713 
714 @docstring.dedent_interpd
715 def axes(arg=None, **kwargs):
716     """
717     Add an axes to the current figure and make it the current axes.
718 
719     Call signatures::
720 
721         plt.axes()
722         plt.axes(rect, projection=None, polar=False, **kwargs)
723         plt.axes(ax)
724 
725     Parameters
726     ----------
727     arg : { None, 4-tuple, Axes }
728         The exact behavior of this function depends on the type:
729 
730         - *None*: A new full window axes is added using
731           ``subplot(111, **kwargs)``
732         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
733           A new axes is added with dimensions *rect* in normalized
734           (0, 1) units using `~.Figure.add_axes` on the current figure.
735         - `~.axes.Axes`: This is equivalent to `.pyplot.sca`.
736           It sets the current axes to *arg*. Note: This implicitly
737           changes the current figure to the parent of *arg*.
738 
739           .. note:: The use of an `.axes.Axes` as an argument is deprecated
740                     and will be removed in v3.0. Please use `.pyplot.sca`
741                     instead.
742 
743     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
744 'polar', 'rectilinear', str}, optional
745         The projection type of the `~.axes.Axes`. *str* is the name of
746         a costum projection, see `~matplotlib.projections`. The default
747         None results in a 'rectilinear' projection.
748 
749     polar : boolean, optional
750         If True, equivalent to projection='polar'.
751 
752     sharex, sharey : `~.axes.Axes`, optional
753         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
754         The axis will have the same limits, ticks, and scale as the axis
755         of the shared axes.
756 
757 
758     label : str
759         A label for the returned axes.
760 
761     Other Parameters
762     ----------------
763     **kwargs
764         This method also takes the keyword arguments for
765         the returned axes class. The keyword arguments for the
766         rectilinear axes class `~.axes.Axes` can be found in
767         the following table but there might also be other keyword
768         arguments if another projection is used, see the actual axes
769         class.
770         %(Axes)s
771 
772     Returns
773     -------
774     axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)
775         The returned axes class depends on the projection used. It is
776         `~.axes.Axes` if rectilinear projection are used and
777         `.projections.polar.PolarAxes` if polar projection
778         are used.
779 
780     Notes
781     -----
782     If the figure already has a axes with key (*args*,
783     *kwargs*) then it will simply make that axes current and
784     return it.  This behavior is deprecated. Meanwhile, if you do
785     not want this behavior (i.e., you want to force the creation of a
786     new axes), you must use a unique set of args and kwargs.  The axes
787     *label* attribute has been exposed for this purpose: if you want
788     two axes that are otherwise identical to be added to the figure,
789     make sure you give them unique labels.
790 
791     See Also
792     --------
793     .Figure.add_axes
794     .pyplot.subplot
795     .Figure.add_subplot
796     .Figure.subplots
797     .pyplot.subplots
798 
799     Examples
800     --------
801     ::
802 
803         # Creating a new full window axes
804         plt.axes()
805 
806         # Creating a new axes with specified dimensions and some kwargs
807         plt.axes((left, bottom, width, height), facecolor='w')
808     """
809 
810     if arg is None:
811         return subplot(111, **kwargs)
812     else:
813         return gcf().add_axes(arg, **kwargs)
814 
815 
816 def delaxes(ax=None):
817     """
818     Remove the `Axes` *ax* (defaulting to the current axes) from its figure.
819 
820     A KeyError is raised if the axes doesn't exist.
821     """
822     if ax is None:
823         ax = gca()
824     ax.figure.delaxes(ax)
825 
826 
827 def sca(ax):
828     """
829     Set the current Axes instance to *ax*.
830 
831     The current Figure is updated to the parent of *ax*.
832     """
833     managers = _pylab_helpers.Gcf.get_all_fig_managers()
834     for m in managers:
835         if ax in m.canvas.figure.axes:
836             _pylab_helpers.Gcf.set_active(m)
837             m.canvas.figure.sca(ax)
838             return
839     raise ValueError("Axes instance argument was not found in a figure")
840 
841 
842 def gca(**kwargs):
843     """
844     Get the current :class:`~matplotlib.axes.Axes` instance on the
845     current figure matching the given keyword args, or create one.
846 
847     Examples
848     --------
849     To get the current polar axes on the current figure::
850 
851         plt.gca(projection='polar')
852 
853     If the current axes doesn't exist, or isn't a polar one, the appropriate
854     axes will be created and then returned.
855 
856     See Also
857     --------
858     matplotlib.figure.Figure.gca : The figure's gca method.
859     """
860     return gcf().gca(**kwargs)
861 
862 
863 ## More ways of creating axes ##
864 
865 @docstring.dedent_interpd
866 def subplot(*args, **kwargs):
867     """
868     Add a subplot to the current figure.
869 
870     Wrapper of `.Figure.add_subplot` with a difference in behavior
871     explained in the notes section.
872 
873     Call signatures::
874 
875        subplot(nrows, ncols, index, **kwargs)
876        subplot(pos, **kwargs)
877        subplot(ax)
878 
879     Parameters
880     ----------
881     *args
882         Either a 3-digit integer or three separate integers
883         describing the position of the subplot. If the three
884         integers are *nrows*, *ncols*, and *index* in order, the
885         subplot will take the *index* position on a grid with *nrows*
886         rows and *ncols* columns. *index* starts at 1 in the upper left
887         corner and increases to the right.
888 
889         *pos* is a three digit integer, where the first digit is the
890         number of rows, the second the number of columns, and the third
891         the index of the subplot. i.e. fig.add_subplot(235) is the same as
892         fig.add_subplot(2, 3, 5). Note that all integers must be less than
893         10 for this form to work.
894 
895     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
896 'polar', 'rectilinear', str}, optional
897         The projection type of the subplot (`~.axes.Axes`). *str* is the name
898         of a costum projection, see `~matplotlib.projections`. The default
899         None results in a 'rectilinear' projection.
900 
901     polar : boolean, optional
902         If True, equivalent to projection='polar'.
903 
904     sharex, sharey : `~.axes.Axes`, optional
905         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
906         axis will have the same limits, ticks, and scale as the axis of the
907         shared axes.
908 
909     label : str
910         A label for the returned axes.
911 
912     Other Parameters
913     ----------------
914     **kwargs
915         This method also takes the keyword arguments for
916         the returned axes base class. The keyword arguments for the
917         rectilinear base class `~.axes.Axes` can be found in
918         the following table but there might also be other keyword
919         arguments if another projection is used.
920         %(Axes)s
921 
922     Returns
923     -------
924     axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass \
925     of `~.axes.Axes`)
926 
927         The axes of the subplot. The returned axes base class depends on
928         the projection used. It is `~.axes.Axes` if rectilinear projection
929         are used and `.projections.polar.PolarAxes` if polar projection
930         are used. The returned axes is then a subplot subclass of the
931         base class.
932 
933     Notes
934     -----
935     Creating a subplot will delete any pre-existing subplot that overlaps
936     with it beyond sharing a boundary::
937 
938         import matplotlib.pyplot as plt
939         # plot a line, implicitly creating a subplot(111)
940         plt.plot([1,2,3])
941         # now create a subplot which represents the top plot of a grid
942         # with 2 rows and 1 column. Since this subplot will overlap the
943         # first, the plot (and its axes) previously created, will be removed
944         plt.subplot(211)
945 
946     If you do not want this behavior, use the `.Figure.add_subplot` method
947     or the `.pyplot.axes` function instead.
948 
949     If the figure already has a subplot with key (*args*,
950     *kwargs*) then it will simply make that subplot current and
951     return it.  This behavior is deprecated. Meanwhile, if you do
952     not want this behavior (i.e., you want to force the creation of a
953     new subplot), you must use a unique set of args and kwargs.  The axes
954     *label* attribute has been exposed for this purpose: if you want
955     two subplots that are otherwise identical to be added to the figure,
956     make sure you give them unique labels.
957 
958     In rare circumstances, `.add_subplot` may be called with a single
959     argument, a subplot axes instance already created in the
960     present figure but not in the figure's list of axes.
961 
962     See Also
963     --------
964     .Figure.add_subplot
965     .pyplot.subplots
966     .pyplot.axes
967     .Figure.subplots
968 
969     Examples
970     --------
971     ::
972 
973         plt.subplot(221)
974 
975         # equivalent but more general
976         ax1=plt.subplot(2, 2, 1)
977 
978         # add a subplot with no frame
979         ax2=plt.subplot(222, frameon=False)
980 
981         # add a polar subplot
982         plt.subplot(223, projection='polar')
983 
984         # add a red subplot that shares the x-axis with ax1
985         plt.subplot(224, sharex=ax1, facecolor='red')
986 
987         # delete ax2 from the figure
988         plt.delaxes(ax2)
989 
990         # add ax2 to the figure again
991         plt.subplot(ax2)
992         """
993 
994     # if subplot called without arguments, create subplot(1,1,1)
995     if len(args) == 0:
996         args = (1, 1, 1)
997 
998     # This check was added because it is very easy to type
999     # subplot(1, 2, False) when subplots(1, 2, False) was intended
1000     # (sharex=False, that is). In most cases, no error will
1001     # ever occur, but mysterious behavior can result because what was
1002     # intended to be the sharex argument is instead treated as a
1003     # subplot index for subplot()
1004     if len(args) >= 3 and isinstance(args[2], bool):
1005         cbook._warn_external("The subplot index argument to subplot() appears "
1006                              "to be a boolean. Did you intend to use "
1007                              "subplots()?")
1008 
1009     fig = gcf()
1010     a = fig.add_subplot(*args, **kwargs)
1011     bbox = a.bbox
1012     byebye = []
1013     for other in fig.axes:
1014         if other == a:
1015             continue
1016         if bbox.fully_overlaps(other.bbox):
1017             byebye.append(other)
1018     for ax in byebye:
1019         delaxes(ax)
1020 
1021     return a
1022 
1023 
1024 def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,
1025              subplot_kw=None, gridspec_kw=None, **fig_kw):
1026     """
1027     Create a figure and a set of subplots.
1028 
1029     This utility wrapper makes it convenient to create common layouts of
1030     subplots, including the enclosing figure object, in a single call.
1031 
1032     Parameters
1033     ----------
1034     nrows, ncols : int, optional, default: 1
1035         Number of rows/columns of the subplot grid.
1036 
1037     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1038         Controls sharing of properties among x (`sharex`) or y (`sharey`)
1039         axes:
1040 
1041             - True or 'all': x- or y-axis will be shared among all
1042               subplots.
1043             - False or 'none': each subplot x- or y-axis will be
1044               independent.
1045             - 'row': each subplot row will share an x- or y-axis.
1046             - 'col': each subplot column will share an x- or y-axis.
1047 
1048         When subplots have a shared x-axis along a column, only the x tick
1049         labels of the bottom subplot are created. Similarly, when subplots
1050         have a shared y-axis along a row, only the y tick labels of the first
1051         column subplot are created. To later turn other subplots' ticklabels
1052         on, use `~matplotlib.axes.Axes.tick_params`.
1053 
1054     squeeze : bool, optional, default: True
1055         - If True, extra dimensions are squeezed out from the returned
1056           array of `~matplotlib.axes.Axes`:
1057 
1058             - if only one subplot is constructed (nrows=ncols=1), the
1059               resulting single Axes object is returned as a scalar.
1060             - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1061               object array of Axes objects.
1062             - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1063 
1064         - If False, no squeezing at all is done: the returned Axes object is
1065           always a 2D array containing Axes instances, even if it ends up
1066           being 1x1.
1067 
1068     num : integer or string, optional, default: None
1069         A `.pyplot.figure` keyword that sets the figure number or label.
1070 
1071     subplot_kw : dict, optional
1072         Dict with keywords passed to the
1073         `~matplotlib.figure.Figure.add_subplot` call used to create each
1074         subplot.
1075 
1076     gridspec_kw : dict, optional
1077         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1078         constructor used to create the grid the subplots are placed on.
1079 
1080     **fig_kw
1081         All additional keyword arguments are passed to the
1082         `.pyplot.figure` call.
1083 
1084     Returns
1085     -------
1086     fig : `~.figure.Figure`
1087 
1088     ax : `.axes.Axes` object or array of Axes objects.
1089         *ax* can be either a single `~matplotlib.axes.Axes` object or an
1090         array of Axes objects if more than one subplot was created.  The
1091         dimensions of the resulting array can be controlled with the squeeze
1092         keyword, see above.
1093 
1094     Examples
1095     --------
1096     ::
1097 
1098         # First create some toy data:
1099         x = np.linspace(0, 2*np.pi, 400)
1100         y = np.sin(x**2)
1101 
1102         # Creates just a figure and only one subplot
1103         fig, ax = plt.subplots()
1104         ax.plot(x, y)
1105         ax.set_title('Simple plot')
1106 
1107         # Creates two subplots and unpacks the output array immediately
1108         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1109         ax1.plot(x, y)
1110         ax1.set_title('Sharing Y axis')
1111         ax2.scatter(x, y)
1112 
1113         # Creates four polar axes, and accesses them through the returned array
1114         fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))
1115         axes[0, 0].plot(x, y)
1116         axes[1, 1].scatter(x, y)
1117 
1118         # Share a X axis with each column of subplots
1119         plt.subplots(2, 2, sharex='col')
1120 
1121         # Share a Y axis with each row of subplots
1122         plt.subplots(2, 2, sharey='row')
1123 
1124         # Share both X and Y axes with all subplots
1125         plt.subplots(2, 2, sharex='all', sharey='all')
1126 
1127         # Note that this is the same as
1128         plt.subplots(2, 2, sharex=True, sharey=True)
1129 
1130         # Creates figure number 10 with a single subplot
1131         # and clears it if it already exists.
1132         fig, ax=plt.subplots(num=10, clear=True)
1133 
1134     See Also
1135     --------
1136     .pyplot.figure
1137     .pyplot.subplot
1138     .pyplot.axes
1139     .Figure.subplots
1140     .Figure.add_subplot
1141 
1142     """
1143     fig = figure(**fig_kw)
1144     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1145                        squeeze=squeeze, subplot_kw=subplot_kw,
1146                        gridspec_kw=gridspec_kw)
1147     return fig, axs
1148 
1149 
1150 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):
1151     """
1152     Create an axis at specific location inside a regular grid.
1153 
1154     Parameters
1155     ----------
1156     shape : sequence of 2 ints
1157         Shape of grid in which to place axis.
1158         First entry is number of rows, second entry is number of columns.
1159 
1160     loc : sequence of 2 ints
1161         Location to place axis within grid.
1162         First entry is row number, second entry is column number.
1163 
1164     rowspan : int
1165         Number of rows for the axis to span to the right.
1166 
1167     colspan : int
1168         Number of columns for the axis to span downwards.
1169 
1170     fig : `Figure`, optional
1171         Figure to place axis in. Defaults to current figure.
1172 
1173     **kwargs
1174         Additional keyword arguments are handed to `add_subplot`.
1175 
1176 
1177     Notes
1178     -----
1179     The following call ::
1180 
1181         subplot2grid(shape, loc, rowspan=1, colspan=1)
1182 
1183     is identical to ::
1184 
1185         gridspec=GridSpec(shape[0], shape[1])
1186         subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)
1187         subplot(subplotspec)
1188     """
1189 
1190     if fig is None:
1191         fig = gcf()
1192 
1193     s1, s2 = shape
1194     subplotspec = GridSpec(s1, s2).new_subplotspec(loc,
1195                                                    rowspan=rowspan,
1196                                                    colspan=colspan)
1197     a = fig.add_subplot(subplotspec, **kwargs)
1198     bbox = a.bbox
1199     byebye = []
1200     for other in fig.axes:
1201         if other == a:
1202             continue
1203         if bbox.fully_overlaps(other.bbox):
1204             byebye.append(other)
1205     for ax in byebye:
1206         delaxes(ax)
1207 
1208     return a
1209 
1210 
1211 def twinx(ax=None):
1212     """
1213     Make a second axes that shares the *x*-axis.  The new axes will
1214     overlay *ax* (or the current axes if *ax* is *None*).  The ticks
1215     for *ax2* will be placed on the right, and the *ax2* instance is
1216     returned.
1217 
1218     .. seealso::
1219 
1220        :doc:`/gallery/subplots_axes_and_figures/two_scales`
1221 
1222     """
1223     if ax is None:
1224         ax = gca()
1225     ax1 = ax.twinx()
1226     return ax1
1227 
1228 
1229 def twiny(ax=None):
1230     """
1231     Make a second axes that shares the *y*-axis.  The new axis will
1232     overlay *ax* (or the current axes if *ax* is *None*).  The ticks
1233     for *ax2* will be placed on the top, and the *ax2* instance is
1234     returned.
1235     """
1236     if ax is None:
1237         ax = gca()
1238     ax1 = ax.twiny()
1239     return ax1
1240 
1241 
1242 def subplots_adjust(left=None, bottom=None, right=None, top=None,
1243                     wspace=None, hspace=None):
1244     """
1245     Tune the subplot layout.
1246 
1247     The parameter meanings (and suggested defaults) are::
1248 
1249       left = 0.125  # the left side of the subplots of the figure
1250       right = 0.9   # the right side of the subplots of the figure
1251       bottom = 0.1  # the bottom of the subplots of the figure
1252       top = 0.9     # the top of the subplots of the figure
1253       wspace = 0.2  # the amount of width reserved for space between subplots,
1254                     # expressed as a fraction of the average axis width
1255       hspace = 0.2  # the amount of height reserved for space between subplots,
1256                     # expressed as a fraction of the average axis height
1257 
1258     The actual defaults are controlled by the rc file
1259     """
1260     fig = gcf()
1261     fig.subplots_adjust(left, bottom, right, top, wspace, hspace)
1262 
1263 
1264 def subplot_tool(targetfig=None):
1265     """
1266     Launch a subplot tool window for a figure.
1267 
1268     A :class:`matplotlib.widgets.SubplotTool` instance is returned.
1269     """
1270     tbar = rcParams['toolbar']  # turn off navigation toolbar for the toolfig
1271     rcParams['toolbar'] = 'None'
1272     if targetfig is None:
1273         manager = get_current_fig_manager()
1274         targetfig = manager.canvas.figure
1275     else:
1276         # find the manager for this figure
1277         for manager in _pylab_helpers.Gcf._activeQue:
1278             if manager.canvas.figure == targetfig:
1279                 break
1280         else:
1281             raise RuntimeError('Could not find manager for targetfig')
1282 
1283     toolfig = figure(figsize=(6, 3))
1284     toolfig.subplots_adjust(top=0.9)
1285     ret = SubplotTool(targetfig, toolfig)
1286     rcParams['toolbar'] = tbar
1287     _pylab_helpers.Gcf.set_active(manager)  # restore the current figure
1288     return ret
1289 
1290 
1291 def tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None):
1292     """
1293     Automatically adjust subplot parameters to give specified padding.
1294 
1295     Parameters
1296     ----------
1297     pad : float
1298         Padding between the figure edge and the edges of subplots,
1299         as a fraction of the font size.
1300     h_pad, w_pad : float, optional
1301         Padding (height/width) between edges of adjacent subplots,
1302         as a fraction of the font size.  Defaults to *pad*.
1303     rect : tuple (left, bottom, right, top), optional
1304         A rectangle (left, bottom, right, top) in the normalized
1305         figure coordinate that the whole subplots area (including
1306         labels) will fit into. Default is (0, 0, 1, 1).
1307     """
1308     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
1309 
1310 
1311 def box(on=None):
1312     """
1313     Turn the axes box on or off on the current axes.
1314 
1315     Parameters
1316     ----------
1317     on : bool or None
1318         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1319         the state.
1320 
1321     See Also
1322     --------
1323     :meth:`matplotlib.axes.Axes.set_frame_on`
1324     :meth:`matplotlib.axes.Axes.get_frame_on`
1325     """
1326     ax = gca()
1327     if on is None:
1328         on = not ax.get_frame_on()
1329     ax.set_frame_on(on)
1330 
1331 ## Axis ##
1332 
1333 
1334 def xlim(*args, **kwargs):
1335     """
1336     Get or set the x limits of the current axes.
1337 
1338     Call signatures::
1339 
1340         left, right = xlim()  # return the current xlim
1341         xlim((left, right))   # set the xlim to left, right
1342         xlim(left, right)     # set the xlim to left, right
1343 
1344     If you do not specify args, you can pass *left* or *right* as kwargs,
1345     i.e.::
1346 
1347         xlim(right=3)  # adjust the right leaving left unchanged
1348         xlim(left=1)  # adjust the left leaving right unchanged
1349 
1350     Setting limits turns autoscaling off for the x-axis.
1351 
1352     Returns
1353     -------
1354     left, right
1355         A tuple of the new x-axis limits.
1356 
1357     Notes
1358     -----
1359     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1360     equivalent of calling `~.Axes.get_xlim` on the current axes.
1361     Calling this function with arguments is the pyplot equivalent of calling
1362     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1363     """
1364     ax = gca()
1365     if not args and not kwargs:
1366         return ax.get_xlim()
1367     ret = ax.set_xlim(*args, **kwargs)
1368     return ret
1369 
1370 
1371 def ylim(*args, **kwargs):
1372     """
1373     Get or set the y-limits of the current axes.
1374 
1375     Call signatures::
1376 
1377         bottom, top = ylim()  # return the current ylim
1378         ylim((bottom, top))   # set the ylim to bottom, top
1379         ylim(bottom, top)     # set the ylim to bottom, top
1380 
1381     If you do not specify args, you can alternatively pass *bottom* or
1382     *top* as kwargs, i.e.::
1383 
1384         ylim(top=3)  # adjust the top leaving bottom unchanged
1385         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1386 
1387     Setting limits turns autoscaling off for the y-axis.
1388 
1389     Returns
1390     -------
1391     bottom, top
1392         A tuple of the new y-axis limits.
1393 
1394     Notes
1395     -----
1396     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1397     equivalent of calling `~.Axes.get_ylim` on the current axes.
1398     Calling this function with arguments is the pyplot equivalent of calling
1399     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1400     """
1401     ax = gca()
1402     if not args and not kwargs:
1403         return ax.get_ylim()
1404     ret = ax.set_ylim(*args, **kwargs)
1405     return ret
1406 
1407 
1408 def xticks(ticks=None, labels=None, **kwargs):
1409     """
1410     Get or set the current tick locations and labels of the x-axis.
1411 
1412     Call signatures::
1413 
1414         locs, labels = xticks()            # Get locations and labels
1415         xticks(ticks, [labels], **kwargs)  # Set locations and labels
1416 
1417     Parameters
1418     ----------
1419     ticks : array_like
1420         A list of positions at which ticks should be placed. You can pass an
1421         empty list to disable xticks.
1422 
1423     labels : array_like, optional
1424         A list of explicit labels to place at the given *locs*.
1425 
1426     **kwargs
1427         :class:`.Text` properties can be used to control the appearance of
1428         the labels.
1429 
1430     Returns
1431     -------
1432     locs
1433         An array of label locations.
1434     labels
1435         A list of `.Text` objects.
1436 
1437     Notes
1438     -----
1439     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1440     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1441     the current axes.
1442     Calling this function with arguments is the pyplot equivalent of calling
1443     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1444 
1445     Examples
1446     --------
1447     Get the current locations and labels:
1448 
1449         >>> locs, labels = xticks()
1450 
1451     Set label locations:
1452 
1453         >>> xticks(np.arange(0, 1, step=0.2))
1454 
1455     Set text labels:
1456 
1457         >>> xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
1458 
1459     Set text labels and properties:
1460 
1461         >>> xticks(np.arange(12), calendar.month_name[1:13], rotation=20)
1462 
1463     Disable xticks:
1464 
1465         >>> xticks([])
1466     """
1467     ax = gca()
1468 
1469     if ticks is None and labels is None:
1470         locs = ax.get_xticks()
1471         labels = ax.get_xticklabels()
1472     elif labels is None:
1473         locs = ax.set_xticks(ticks)
1474         labels = ax.get_xticklabels()
1475     else:
1476         locs = ax.set_xticks(ticks)
1477         labels = ax.set_xticklabels(labels, **kwargs)
1478     for l in labels:
1479         l.update(kwargs)
1480 
1481     return locs, silent_list('Text xticklabel', labels)
1482 
1483 
1484 def yticks(ticks=None, labels=None, **kwargs):
1485     """
1486     Get or set the current tick locations and labels of the y-axis.
1487 
1488     Call signatures::
1489 
1490         locs, labels = yticks()            # Get locations and labels
1491         yticks(ticks, [labels], **kwargs)  # Set locations and labels
1492 
1493     Parameters
1494     ----------
1495     ticks : array_like
1496         A list of positions at which ticks should be placed. You can pass an
1497         empty list to disable yticks.
1498 
1499     labels : array_like, optional
1500         A list of explicit labels to place at the given *locs*.
1501 
1502     **kwargs
1503         :class:`.Text` properties can be used to control the appearance of
1504         the labels.
1505 
1506     Returns
1507     -------
1508     locs
1509         An array of label locations.
1510     labels
1511         A list of `.Text` objects.
1512 
1513     Notes
1514     -----
1515     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
1516     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
1517     the current axes.
1518     Calling this function with arguments is the pyplot equivalent of calling
1519     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
1520 
1521     Examples
1522     --------
1523     Get the current locations and labels:
1524 
1525         >>> locs, labels = yticks()
1526 
1527     Set label locations:
1528 
1529         >>> yticks(np.arange(0, 1, step=0.2))
1530 
1531     Set text labels:
1532 
1533         >>> yticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))
1534 
1535     Set text labels and properties:
1536 
1537         >>> yticks(np.arange(12), calendar.month_name[1:13], rotation=45)
1538 
1539     Disable yticks:
1540 
1541         >>> yticks([])
1542     """
1543     ax = gca()
1544 
1545     if ticks is None and labels is None:
1546         locs = ax.get_yticks()
1547         labels = ax.get_yticklabels()
1548     elif labels is None:
1549         locs = ax.set_yticks(ticks)
1550         labels = ax.get_yticklabels()
1551     else:
1552         locs = ax.set_yticks(ticks)
1553         labels = ax.set_yticklabels(labels, **kwargs)
1554     for l in labels:
1555         l.update(kwargs)
1556 
1557     return locs, silent_list('Text yticklabel', labels)
1558 
1559 
1560 def rgrids(*args, **kwargs):
1561     """
1562     Get or set the radial gridlines on the current polar plot.
1563 
1564     Call signatures::
1565 
1566      lines, labels = rgrids()
1567      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
1568 
1569     When called with no arguments, `.rgrids` simply returns the tuple
1570     (*lines*, *labels*). When called with arguments, the labels will
1571     appear at the specified radial distances and angle.
1572 
1573     Parameters
1574     ----------
1575     radii : tuple with floats
1576         The radii for the radial gridlines
1577 
1578     labels : tuple with strings or None
1579         The labels to use at each radial gridline. The
1580         `matplotlib.ticker.ScalarFormatter` will be used if None.
1581 
1582     angle : float
1583         The angular position of the radius labels in degrees.
1584 
1585     fmt : str or None
1586         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1587         For example '%f'.
1588 
1589     Returns
1590     -------
1591     lines, labels : list of `.lines.Line2D`, list of `.text.Text`
1592         *lines* are the radial gridlines and *labels* are the tick labels.
1593 
1594     Other Parameters
1595     ----------------
1596     **kwargs
1597         *kwargs* are optional `~.Text` properties for the labels.
1598 
1599     Examples
1600     --------
1601     ::
1602 
1603       # set the locations of the radial gridlines
1604       lines, labels = rgrids( (0.25, 0.5, 1.0) )
1605 
1606       # set the locations and labels of the radial gridlines
1607       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
1608 
1609     See Also
1610     --------
1611     .pyplot.thetagrids
1612     .projections.polar.PolarAxes.set_rgrids
1613     .Axis.get_gridlines
1614     .Axis.get_ticklabels
1615     """
1616     ax = gca()
1617     if not isinstance(ax, PolarAxes):
1618         raise RuntimeError('rgrids only defined for polar axes')
1619     if len(args) == 0:
1620         lines = ax.yaxis.get_gridlines()
1621         labels = ax.yaxis.get_ticklabels()
1622     else:
1623         lines, labels = ax.set_rgrids(*args, **kwargs)
1624     return (silent_list('Line2D rgridline', lines),
1625             silent_list('Text rgridlabel', labels))
1626 
1627 
1628 def thetagrids(*args, **kwargs):
1629     """
1630     Get or set the theta gridlines on the current polar plot.
1631 
1632     Call signatures::
1633 
1634      lines, labels = thetagrids()
1635      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
1636 
1637     When called with no arguments, `.thetagrids` simply returns the tuple
1638     (*lines*, *labels*). When called with arguments, the labels will
1639     appear at the specified angles.
1640 
1641     Parameters
1642     ----------
1643     angles : tuple with floats, degrees
1644         The angles of the theta gridlines.
1645 
1646     labels : tuple with strings or None
1647         The labels to use at each radial gridline. The
1648         `.projections.polar.ThetaFormatter` will be used if None.
1649 
1650     fmt : str or None
1651         Format string used in `matplotlib.ticker.FormatStrFormatter`.
1652         For example '%f'. Note that the angle in radians will be used.
1653 
1654     Returns
1655     -------
1656     lines, labels : list of `.lines.Line2D`, list of `.text.Text`
1657         *lines* are the theta gridlines and *labels* are the tick labels.
1658 
1659     Other Parameters
1660     ----------------
1661     **kwargs
1662         *kwargs* are optional `~.Text` properties for the labels.
1663 
1664     Examples
1665     --------
1666     ::
1667 
1668       # set the locations of the angular gridlines
1669       lines, labels = thetagrids( range(45,360,90) )
1670 
1671       # set the locations and labels of the angular gridlines
1672       lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )
1673 
1674     See Also
1675     --------
1676     .pyplot.rgrids
1677     .projections.polar.PolarAxes.set_thetagrids
1678     .Axis.get_gridlines
1679     .Axis.get_ticklabels
1680     """
1681     ax = gca()
1682     if not isinstance(ax, PolarAxes):
1683         raise RuntimeError('thetagrids only defined for polar axes')
1684     if len(args) == 0:
1685         lines = ax.xaxis.get_ticklines()
1686         labels = ax.xaxis.get_ticklabels()
1687     else:
1688         lines, labels = ax.set_thetagrids(*args, **kwargs)
1689     return (silent_list('Line2D thetagridline', lines),
1690             silent_list('Text thetagridlabel', labels))
1691 
1692 
1693 ## Plotting Info ##
1694 
1695 
1696 def plotting():
1697     pass
1698 
1699 
1700 def get_plot_commands():
1701     """
1702     Get a sorted list of all of the plotting commands.
1703     """
1704     # This works by searching for all functions in this module and removing
1705     # a few hard-coded exclusions, as well as all of the colormap-setting
1706     # functions, and anything marked as private with a preceding underscore.
1707     exclude = {'colormaps', 'colors', 'connect', 'disconnect',
1708                'get_plot_commands', 'get_current_fig_manager', 'ginput',
1709                'plotting', 'waitforbuttonpress'}
1710     exclude |= set(colormaps())
1711     this_module = inspect.getmodule(get_plot_commands)
1712     return sorted(
1713         name for name, obj in globals().items()
1714         if not name.startswith('_') and name not in exclude
1715            and inspect.isfunction(obj)
1716            and inspect.getmodule(obj) is this_module)
1717 
1718 
1719 def colormaps():
1720     """
1721     Matplotlib provides a number of colormaps, and others can be added using
1722     :func:`~matplotlib.cm.register_cmap`.  This function documents the built-in
1723     colormaps, and will also return a list of all registered colormaps if
1724     called.
1725 
1726     You can set the colormap for an image, pcolor, scatter, etc,
1727     using a keyword argument::
1728 
1729       imshow(X, cmap=cm.hot)
1730 
1731     or using the :func:`set_cmap` function::
1732 
1733       imshow(X)
1734       pyplot.set_cmap('hot')
1735       pyplot.set_cmap('jet')
1736 
1737     In interactive mode, :func:`set_cmap` will update the colormap post-hoc,
1738     allowing you to see which one works best for your data.
1739 
1740     All built-in colormaps can be reversed by appending ``_r``: For instance,
1741     ``gray_r`` is the reverse of ``gray``.
1742 
1743     There are several common color schemes used in visualization:
1744 
1745     Sequential schemes
1746       for unipolar data that progresses from low to high
1747     Diverging schemes
1748       for bipolar data that emphasizes positive or negative deviations from a
1749       central value
1750     Cyclic schemes
1751       for plotting values that wrap around at the endpoints, such as phase
1752       angle, wind direction, or time of day
1753     Qualitative schemes
1754       for nominal data that has no inherent ordering, where color is used
1755       only to distinguish categories
1756 
1757     Matplotlib ships with 4 perceptually uniform color maps which are
1758     the recommended color maps for sequential data:
1759 
1760       =========   ===================================================
1761       Colormap    Description
1762       =========   ===================================================
1763       inferno     perceptually uniform shades of black-red-yellow
1764       magma       perceptually uniform shades of black-red-white
1765       plasma      perceptually uniform shades of blue-red-yellow
1766       viridis     perceptually uniform shades of blue-green-yellow
1767       =========   ===================================================
1768 
1769     The following colormaps are based on the `ColorBrewer
1770     <http://colorbrewer2.org>`_ color specifications and designs developed by
1771     Cynthia Brewer:
1772 
1773     ColorBrewer Diverging (luminance is highest at the midpoint, and
1774     decreases towards differently-colored endpoints):
1775 
1776       ========  ===================================
1777       Colormap  Description
1778       ========  ===================================
1779       BrBG      brown, white, blue-green
1780       PiYG      pink, white, yellow-green
1781       PRGn      purple, white, green
1782       PuOr      orange, white, purple
1783       RdBu      red, white, blue
1784       RdGy      red, white, gray
1785       RdYlBu    red, yellow, blue
1786       RdYlGn    red, yellow, green
1787       Spectral  red, orange, yellow, green, blue
1788       ========  ===================================
1789 
1790     ColorBrewer Sequential (luminance decreases monotonically):
1791 
1792       ========  ====================================
1793       Colormap  Description
1794       ========  ====================================
1795       Blues     white to dark blue
1796       BuGn      white, light blue, dark green
1797       BuPu      white, light blue, dark purple
1798       GnBu      white, light green, dark blue
1799       Greens    white to dark green
1800       Greys     white to black (not linear)
1801       Oranges   white, orange, dark brown
1802       OrRd      white, orange, dark red
1803       PuBu      white, light purple, dark blue
1804       PuBuGn    white, light purple, dark green
1805       PuRd      white, light purple, dark red
1806       Purples   white to dark purple
1807       RdPu      white, pink, dark purple
1808       Reds      white to dark red
1809       YlGn      light yellow, dark green
1810       YlGnBu    light yellow, light green, dark blue
1811       YlOrBr    light yellow, orange, dark brown
1812       YlOrRd    light yellow, orange, dark red
1813       ========  ====================================
1814 
1815     ColorBrewer Qualitative:
1816 
1817     (For plotting nominal data, :class:`ListedColormap` is used,
1818     not :class:`LinearSegmentedColormap`.  Different sets of colors are
1819     recommended for different numbers of categories.)
1820 
1821     * Accent
1822     * Dark2
1823     * Paired
1824     * Pastel1
1825     * Pastel2
1826     * Set1
1827     * Set2
1828     * Set3
1829 
1830     A set of colormaps derived from those of the same name provided
1831     with Matlab are also included:
1832 
1833       =========   =======================================================
1834       Colormap    Description
1835       =========   =======================================================
1836       autumn      sequential linearly-increasing shades of red-orange-yellow
1837       bone        sequential increasing black-white color map with
1838                   a tinge of blue, to emulate X-ray film
1839       cool        linearly-decreasing shades of cyan-magenta
1840       copper      sequential increasing shades of black-copper
1841       flag        repetitive red-white-blue-black pattern (not cyclic at
1842                   endpoints)
1843       gray        sequential linearly-increasing black-to-white
1844                   grayscale
1845       hot         sequential black-red-yellow-white, to emulate blackbody
1846                   radiation from an object at increasing temperatures
1847       jet         a spectral map with dark endpoints, blue-cyan-yellow-red;
1848                   based on a fluid-jet simulation by NCSA [#]_
1849       pink        sequential increasing pastel black-pink-white, meant
1850                   for sepia tone colorization of photographs
1851       prism       repetitive red-yellow-green-blue-purple-...-green pattern
1852                   (not cyclic at endpoints)
1853       spring      linearly-increasing shades of magenta-yellow
1854       summer      sequential linearly-increasing shades of green-yellow
1855       winter      linearly-increasing shades of blue-green
1856       =========   =======================================================
1857 
1858     A set of palettes from the `Yorick scientific visualisation
1859     package <https://dhmunro.github.io/yorick-doc/>`_, an evolution of
1860     the GIST package, both by David H. Munro are included:
1861 
1862       ============  =======================================================
1863       Colormap      Description
1864       ============  =======================================================
1865       gist_earth    mapmaker's colors from dark blue deep ocean to green
1866                     lowlands to brown highlands to white mountains
1867       gist_heat     sequential increasing black-red-orange-white, to emulate
1868                     blackbody radiation from an iron bar as it grows hotter
1869       gist_ncar     pseudo-spectral black-blue-green-yellow-red-purple-white
1870                     colormap from National Center for Atmospheric
1871                     Research [#]_
1872       gist_rainbow  runs through the colors in spectral order from red to
1873                     violet at full saturation (like *hsv* but not cyclic)
1874       gist_stern    "Stern special" color table from Interactive Data
1875                     Language software
1876       ============  =======================================================
1877 
1878     A set of cyclic color maps:
1879 
1880       ================  =================================================
1881       Colormap          Description
1882       ================  =================================================
1883       hsv               red-yellow-green-cyan-blue-magenta-red, formed by
1884                         changing the hue component in the HSV color space
1885       twilight          perceptually uniform shades of
1886                         white-blue-black-red-white
1887       twilight_shifted  perceptually uniform shades of
1888                         black-blue-white-red-black
1889       ================  =================================================
1890 
1891 
1892     Other miscellaneous schemes:
1893 
1894       ============= =======================================================
1895       Colormap      Description
1896       ============= =======================================================
1897       afmhot        sequential black-orange-yellow-white blackbody
1898                     spectrum, commonly used in atomic force microscopy
1899       brg           blue-red-green
1900       bwr           diverging blue-white-red
1901       coolwarm      diverging blue-gray-red, meant to avoid issues with 3D
1902                     shading, color blindness, and ordering of colors [#]_
1903       CMRmap        "Default colormaps on color images often reproduce to
1904                     confusing grayscale images. The proposed colormap
1905                     maintains an aesthetically pleasing color image that
1906                     automatically reproduces to a monotonic grayscale with
1907                     discrete, quantifiable saturation levels." [#]_
1908       cubehelix     Unlike most other color schemes cubehelix was designed
1909                     by D.A. Green to be monotonically increasing in terms
1910                     of perceived brightness. Also, when printed on a black
1911                     and white postscript printer, the scheme results in a
1912                     greyscale with monotonically increasing brightness.
1913                     This color scheme is named cubehelix because the r,g,b
1914                     values produced can be visualised as a squashed helix
1915                     around the diagonal in the r,g,b color cube.
1916       gnuplot       gnuplot's traditional pm3d scheme
1917                     (black-blue-red-yellow)
1918       gnuplot2      sequential color printable as gray
1919                     (black-blue-violet-yellow-white)
1920       ocean         green-blue-white
1921       rainbow       spectral purple-blue-green-yellow-orange-red colormap
1922                     with diverging luminance
1923       seismic       diverging blue-white-red
1924       nipy_spectral black-purple-blue-green-yellow-red-white spectrum,
1925                     originally from the Neuroimaging in Python project
1926       terrain       mapmaker's colors, blue-green-yellow-brown-white,
1927                     originally from IGOR Pro
1928       ============= =======================================================
1929 
1930     The following colormaps are redundant and may be removed in future
1931     versions.  It's recommended to use the names in the descriptions
1932     instead, which produce identical output:
1933 
1934       =========  =======================================================
1935       Colormap   Description
1936       =========  =======================================================
1937       gist_gray  identical to *gray*
1938       gist_yarg  identical to *gray_r*
1939       binary     identical to *gray_r*
1940       =========  =======================================================
1941 
1942     .. rubric:: Footnotes
1943 
1944     .. [#] Rainbow colormaps, ``jet`` in particular, are considered a poor
1945       choice for scientific visualization by many researchers: `Rainbow Color
1946       Map (Still) Considered Harmful
1947       <http://ieeexplore.ieee.org/document/4118486/?arnumber=4118486>`_
1948 
1949     .. [#] Resembles "BkBlAqGrYeOrReViWh200" from NCAR Command
1950       Language. See `Color Table Gallery
1951       <https://www.ncl.ucar.edu/Document/Graphics/color_table_gallery.shtml>`_
1952 
1953     .. [#] See `Diverging Color Maps for Scientific Visualization
1954       <http://www.kennethmoreland.com/color-maps/>`_ by Kenneth Moreland.
1955 
1956     .. [#] See `A Color Map for Effective Black-and-White Rendering of
1957       Color-Scale Images
1958       <https://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m>`_
1959       by Carey Rappaport
1960     """
1961     return sorted(cm.cmap_d)
1962 
1963 
1964 def _setup_pyplot_info_docstrings():
1965     """
1966     Generates the plotting docstring.
1967 
1968     These must be done after the entire module is imported, so it is
1969     called from the end of this module, which is generated by
1970     boilerplate.py.
1971     """
1972     commands = get_plot_commands()
1973 
1974     first_sentence = re.compile(r"(?:\s*).+?\.(?:\s+|$)", flags=re.DOTALL)
1975 
1976     # Collect the first sentence of the docstring for all of the
1977     # plotting commands.
1978     rows = []
1979     max_name = len("Function")
1980     max_summary = len("Description")
1981     for name in commands:
1982         doc = globals()[name].__doc__
1983         summary = ''
1984         if doc is not None:
1985             match = first_sentence.match(doc)
1986             if match is not None:
1987                 summary = inspect.cleandoc(match.group(0)).replace('\n', ' ')
1988         name = '`%s`' % name
1989         rows.append([name, summary])
1990         max_name = max(max_name, len(name))
1991         max_summary = max(max_summary, len(summary))
1992 
1993     separator = '=' * max_name + ' ' + '=' * max_summary
1994     lines = [
1995         separator,
1996         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),
1997         separator,
1998     ] + [
1999         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)
2000         for name, summary in rows
2001     ] + [
2002         separator,
2003     ]
2004     plotting.__doc__ = '\n'.join(lines)
2005 
2006 
2007 ## Plotting part 1: manually generated functions and wrappers ##
2008 
2009 
2010 def colorbar(mappable=None, cax=None, ax=None, **kw):
2011     if mappable is None:
2012         mappable = gci()
2013         if mappable is None:
2014             raise RuntimeError('No mappable was found to use for colorbar '
2015                                'creation. First define a mappable such as '
2016                                'an image (with imshow) or a contour set ('
2017                                'with contourf).')
2018     if ax is None:
2019         ax = gca()
2020     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kw)
2021     return ret
2022 colorbar.__doc__ = matplotlib.colorbar.colorbar_doc
2023 
2024 
2025 def clim(vmin=None, vmax=None):
2026     """
2027     Set the color limits of the current image.
2028 
2029     To apply clim to all axes images do::
2030 
2031       clim(0, 0.5)
2032 
2033     If either *vmin* or *vmax* is None, the image min/max respectively
2034     will be used for color scaling.
2035 
2036     If you want to set the clim of multiple images,
2037     use, for example::
2038 
2039       for im in gca().get_images():
2040           im.set_clim(0, 0.05)
2041 
2042     """
2043     im = gci()
2044     if im is None:
2045         raise RuntimeError('You must first define an image, e.g., with imshow')
2046 
2047     im.set_clim(vmin, vmax)
2048 
2049 
2050 def set_cmap(cmap):
2051     """
2052     Set the default colormap.  Applies to the current image if any.
2053     See help(colormaps) for more information.
2054 
2055     *cmap* must be a :class:`~matplotlib.colors.Colormap` instance, or
2056     the name of a registered colormap.
2057 
2058     See :func:`matplotlib.cm.register_cmap` and
2059     :func:`matplotlib.cm.get_cmap`.
2060     """
2061     cmap = cm.get_cmap(cmap)
2062 
2063     rc('image', cmap=cmap.name)
2064     im = gci()
2065 
2066     if im is not None:
2067         im.set_cmap(cmap)
2068 
2069 
2070 @docstring.copy(matplotlib.image.imread)
2071 def imread(fname, format=None):
2072     return matplotlib.image.imread(fname, format)
2073 
2074 
2075 @docstring.copy(matplotlib.image.imsave)
2076 def imsave(fname, arr, **kwargs):
2077     return matplotlib.image.imsave(fname, arr, **kwargs)
2078 
2079 
2080 def matshow(A, fignum=None, **kwargs):
2081     """
2082     Display an array as a matrix in a new figure window.
2083 
2084     The origin is set at the upper left hand corner and rows (first
2085     dimension of the array) are displayed horizontally.  The aspect
2086     ratio of the figure window is that of the array, unless this would
2087     make an excessively short or narrow figure.
2088 
2089     Tick labels for the xaxis are placed on top.
2090 
2091     Parameters
2092     ----------
2093     A : array-like(M, N)
2094         The matrix to be displayed.
2095 
2096     fignum : None or int or False
2097         If *None*, create a new figure window with automatic numbering.
2098 
2099         If a nonzero integer, draw into the figure with the given number
2100         (create it if it does not exist).
2101 
2102         If 0, use the current axes (or create one if it does not exist).
2103 
2104         .. note::
2105 
2106            Because of how `.Axes.matshow` tries to set the figure aspect
2107            ratio to be the one of the array, strange things may happen if you
2108            reuse an existing figure.
2109 
2110     Returns
2111     -------
2112     image : `~matplotlib.image.AxesImage`
2113 
2114     Other Parameters
2115     ----------------
2116     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2117 
2118     """
2119     A = np.asanyarray(A)
2120     if fignum == 0:
2121         ax = gca()
2122     else:
2123         # Extract actual aspect ratio of array and make appropriately sized
2124         # figure.
2125         fig = figure(fignum, figsize=figaspect(A))
2126         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])
2127     im = ax.matshow(A, **kwargs)
2128     sci(im)
2129     return im
2130 
2131 
2132 def polar(*args, **kwargs):
2133     """
2134     Make a polar plot.
2135 
2136     call signature::
2137 
2138       polar(theta, r, **kwargs)
2139 
2140     Multiple *theta*, *r* arguments are supported, with format
2141     strings, as in :func:`~matplotlib.pyplot.plot`.
2142 
2143     """
2144     # If an axis already exists, check if it has a polar projection
2145     if gcf().get_axes():
2146         if not isinstance(gca(), PolarAxes):
2147             cbook._warn_external('Trying to create polar plot on an axis '
2148                                  'that does not have a polar projection.')
2149     ax = gca(polar=True)
2150     ret = ax.plot(*args, **kwargs)
2151     return ret
2152 
2153 
2154 def plotfile(fname, cols=(0,), plotfuncs=None,
2155              comments='#', skiprows=0, checkrows=5, delimiter=',',
2156              names=None, subplots=True, newfig=True, **kwargs):
2157     """
2158     Plot the data in a file.
2159 
2160     *cols* is a sequence of column identifiers to plot.  An identifier
2161     is either an int or a string.  If it is an int, it indicates the
2162     column number.  If it is a string, it indicates the column header.
2163     matplotlib will make column headers lower case, replace spaces with
2164     underscores, and remove all illegal characters; so ``'Adj Close*'``
2165     will have name ``'adj_close'``.
2166 
2167     - If len(*cols*) == 1, only that column will be plotted on the *y* axis.
2168 
2169     - If len(*cols*) > 1, the first element will be an identifier for
2170       data for the *x* axis and the remaining elements will be the
2171       column indexes for multiple subplots if *subplots* is *True*
2172       (the default), or for lines in a single subplot if *subplots*
2173       is *False*.
2174 
2175     *plotfuncs*, if not *None*, is a dictionary mapping identifier to
2176     an :class:`~matplotlib.axes.Axes` plotting function as a string.
2177     Default is 'plot', other choices are 'semilogy', 'fill', 'bar',
2178     etc.  You must use the same type of identifier in the *cols*
2179     vector as you use in the *plotfuncs* dictionary, e.g., integer
2180     column numbers in both or column names in both. If *subplots*
2181     is *False*, then including any function such as 'semilogy'
2182     that changes the axis scaling will set the scaling for all
2183     columns.
2184 
2185     - *comments*: the character used to indicate the start of a comment
2186       in the file, or *None* to switch off the removal of comments
2187 
2188     - *skiprows*: is the number of rows from the top to skip
2189 
2190     - *checkrows*: is the number of rows to check to validate the column
2191       data type.  When set to zero all rows are validated.
2192 
2193     - *delimiter*: is the character(s) separating row items
2194 
2195     - *names*: if not None, is a list of header names.  In this case, no
2196       header will be read from the file
2197 
2198     If *newfig* is *True*, the plot always will be made in a new figure;
2199     if *False*, it will be made in the current figure if one exists,
2200     else in a new figure.
2201 
2202     kwargs are passed on to plotting functions.
2203 
2204     Example usage::
2205 
2206       # plot the 2nd and 4th column against the 1st in two subplots
2207       plotfile(fname, (0,1,3))
2208 
2209       # plot using column names; specify an alternate plot type for volume
2210       plotfile(fname, ('date', 'volume', 'adj_close'),
2211                                     plotfuncs={'volume': 'semilogy'})
2212 
2213     Note: plotfile is intended as a convenience for quickly plotting
2214     data from flat files; it is not intended as an alternative
2215     interface to general plotting with pyplot or matplotlib.
2216     """
2217 
2218     if newfig:
2219         fig = figure()
2220     else:
2221         fig = gcf()
2222 
2223     if len(cols) < 1:
2224         raise ValueError('must have at least one column of data')
2225 
2226     if plotfuncs is None:
2227         plotfuncs = {}
2228     with cbook._suppress_matplotlib_deprecation_warning():
2229         r = mlab._csv2rec(fname, comments=comments, skiprows=skiprows,
2230                           checkrows=checkrows, delimiter=delimiter,
2231                           names=names)
2232 
2233     def getname_val(identifier):
2234         'return the name and column data for identifier'
2235         if isinstance(identifier, str):
2236             return identifier, r[identifier]
2237         elif isinstance(identifier, Number):
2238             name = r.dtype.names[int(identifier)]
2239             return name, r[name]
2240         else:
2241             raise TypeError('identifier must be a string or integer')
2242 
2243     xname, x = getname_val(cols[0])
2244     ynamelist = []
2245 
2246     if len(cols) == 1:
2247         ax1 = fig.add_subplot(1, 1, 1)
2248         funcname = plotfuncs.get(cols[0], 'plot')
2249         func = getattr(ax1, funcname)
2250         func(x, **kwargs)
2251         ax1.set_ylabel(xname)
2252     else:
2253         N = len(cols)
2254         for i in range(1, N):
2255             if subplots:
2256                 if i == 1:
2257                     ax = ax1 = fig.add_subplot(N - 1, 1, i)
2258                 else:
2259                     ax = fig.add_subplot(N - 1, 1, i, sharex=ax1)
2260             elif i == 1:
2261                 ax = fig.add_subplot(1, 1, 1)
2262 
2263             yname, y = getname_val(cols[i])
2264             ynamelist.append(yname)
2265 
2266             funcname = plotfuncs.get(cols[i], 'plot')
2267             func = getattr(ax, funcname)
2268 
2269             func(x, y, **kwargs)
2270             if subplots:
2271                 ax.set_ylabel(yname)
2272             if ax.is_last_row():
2273                 ax.set_xlabel(xname)
2274             else:
2275                 ax.set_xlabel('')
2276 
2277     if not subplots:
2278         ax.legend(ynamelist)
2279 
2280     if xname == 'date':
2281         fig.autofmt_xdate()
2282 
2283 
2284 # If rcParams['backend_fallback'] is true, and an interactive backend is
2285 # requested, ignore rcParams['backend'] and force selection of a backend that
2286 # is compatible with the current running interactive framework.
2287 if (rcParams["backend_fallback"]
2288         and dict.__getitem__(rcParams, "backend") in _interactive_bk
2289         and _get_running_interactive_framework()):
2290     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
2291 # Set up the backend.
2292 switch_backend(rcParams["backend"])
2293 
2294 # Just to be safe.  Interactive mode can be turned on without
2295 # calling `plt.ion()` so register it again here.
2296 # This is safe because multiple calls to `install_repl_displayhook`
2297 # are no-ops and the registered function respect `mpl.is_interactive()`
2298 # to determine if they should trigger a draw.
2299 install_repl_displayhook()
2300 
2301 
2302 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2303 
2304 
2305 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2306 @docstring.copy(Figure.figimage)
2307 def figimage(
2308         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,
2309         vmax=None, origin=None, resize=False, **kwargs):
2310     return gcf().figimage(
2311         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2312         vmax=vmax, origin=origin, resize=resize, **kwargs)
2313 
2314 
2315 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2316 @docstring.copy(Figure.text)
2317 def figtext(
2318         x, y, s, fontdict=None,
2319         withdash=cbook.deprecation._deprecated_parameter, **kwargs):
2320     return gcf().text(
2321         x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)
2322 
2323 
2324 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2325 @docstring.copy(Figure.ginput)
2326 def ginput(
2327         n=1, timeout=30, show_clicks=True, mouse_add=1, mouse_pop=3,
2328         mouse_stop=2):
2329     return gcf().ginput(
2330         n=n, timeout=timeout, show_clicks=show_clicks,
2331         mouse_add=mouse_add, mouse_pop=mouse_pop,
2332         mouse_stop=mouse_stop)
2333 
2334 
2335 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2336 @docstring.copy(Figure.suptitle)
2337 def suptitle(t, **kwargs):
2338     return gcf().suptitle(t, **kwargs)
2339 
2340 
2341 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2342 @docstring.copy(Figure.waitforbuttonpress)
2343 def waitforbuttonpress(timeout=-1):
2344     return gcf().waitforbuttonpress(timeout=timeout)
2345 
2346 
2347 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2348 @docstring.copy(Axes.acorr)
2349 def acorr(x, *, data=None, **kwargs):
2350     return gca().acorr(
2351         x, **({"data": data} if data is not None else {}), **kwargs)
2352 
2353 
2354 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2355 @docstring.copy(Axes.angle_spectrum)
2356 def angle_spectrum(
2357         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2358         data=None, **kwargs):
2359     return gca().angle_spectrum(
2360         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2361         **({"data": data} if data is not None else {}), **kwargs)
2362 
2363 
2364 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2365 @docstring.copy(Axes.annotate)
2366 def annotate(s, xy, *args, **kwargs):
2367     return gca().annotate(s, xy, *args, **kwargs)
2368 
2369 
2370 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2371 @docstring.copy(Axes.arrow)
2372 def arrow(x, y, dx, dy, **kwargs):
2373     return gca().arrow(x, y, dx, dy, **kwargs)
2374 
2375 
2376 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2377 @docstring.copy(Axes.autoscale)
2378 def autoscale(enable=True, axis='both', tight=None):
2379     return gca().autoscale(enable=enable, axis=axis, tight=tight)
2380 
2381 
2382 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2383 @docstring.copy(Axes.axhline)
2384 def axhline(y=0, xmin=0, xmax=1, **kwargs):
2385     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2386 
2387 
2388 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2389 @docstring.copy(Axes.axhspan)
2390 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
2391     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2392 
2393 
2394 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2395 @docstring.copy(Axes.axis)
2396 def axis(*args, **kwargs):
2397     return gca().axis(*args, **kwargs)
2398 
2399 
2400 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2401 @docstring.copy(Axes.axvline)
2402 def axvline(x=0, ymin=0, ymax=1, **kwargs):
2403     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2404 
2405 
2406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2407 @docstring.copy(Axes.axvspan)
2408 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
2409     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2410 
2411 
2412 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2413 @docstring.copy(Axes.bar)
2414 def bar(
2415         x, height, width=0.8, bottom=None, *, align='center',
2416         data=None, **kwargs):
2417     return gca().bar(
2418         x, height, width=width, bottom=bottom, align=align,
2419         **({"data": data} if data is not None else {}), **kwargs)
2420 
2421 
2422 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2423 @docstring.copy(Axes.barbs)
2424 def barbs(*args, data=None, **kw):
2425     return gca().barbs(
2426         *args, **({"data": data} if data is not None else {}), **kw)
2427 
2428 
2429 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2430 @docstring.copy(Axes.barh)
2431 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):
2432     return gca().barh(
2433         y, width, height=height, left=left, align=align, **kwargs)
2434 
2435 
2436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2437 @docstring.copy(Axes.boxplot)
2438 def boxplot(
2439         x, notch=None, sym=None, vert=None, whis=None,
2440         positions=None, widths=None, patch_artist=None,
2441         bootstrap=None, usermedians=None, conf_intervals=None,
2442         meanline=None, showmeans=None, showcaps=None, showbox=None,
2443         showfliers=None, boxprops=None, labels=None, flierprops=None,
2444         medianprops=None, meanprops=None, capprops=None,
2445         whiskerprops=None, manage_ticks=True, autorange=False,
2446         zorder=None, *, data=None):
2447     return gca().boxplot(
2448         x, notch=notch, sym=sym, vert=vert, whis=whis,
2449         positions=positions, widths=widths, patch_artist=patch_artist,
2450         bootstrap=bootstrap, usermedians=usermedians,
2451         conf_intervals=conf_intervals, meanline=meanline,
2452         showmeans=showmeans, showcaps=showcaps, showbox=showbox,
2453         showfliers=showfliers, boxprops=boxprops, labels=labels,
2454         flierprops=flierprops, medianprops=medianprops,
2455         meanprops=meanprops, capprops=capprops,
2456         whiskerprops=whiskerprops, manage_ticks=manage_ticks,
2457         autorange=autorange, zorder=zorder, **({"data": data} if data
2458         is not None else {}))
2459 
2460 
2461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2462 @docstring.copy(Axes.broken_barh)
2463 def broken_barh(xranges, yrange, *, data=None, **kwargs):
2464     return gca().broken_barh(
2465         xranges, yrange, **({"data": data} if data is not None else
2466         {}), **kwargs)
2467 
2468 
2469 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2470 @docstring.copy(Axes.cla)
2471 def cla():
2472     return gca().cla()
2473 
2474 
2475 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2476 @docstring.copy(Axes.clabel)
2477 def clabel(CS, *args, **kwargs):
2478     return gca().clabel(CS, *args, **kwargs)
2479 
2480 
2481 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2482 @docstring.copy(Axes.cohere)
2483 def cohere(
2484         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
2485         window=mlab.window_hanning, noverlap=0, pad_to=None,
2486         sides='default', scale_by_freq=None, *, data=None, **kwargs):
2487     return gca().cohere(
2488         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2489         noverlap=noverlap, pad_to=pad_to, sides=sides,
2490         scale_by_freq=scale_by_freq, **({"data": data} if data is not
2491         None else {}), **kwargs)
2492 
2493 
2494 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2495 @docstring.copy(Axes.contour)
2496 def contour(*args, data=None, **kwargs):
2497     __ret = gca().contour(
2498         *args, **({"data": data} if data is not None else {}),
2499         **kwargs)
2500     if __ret._A is not None: sci(__ret)  # noqa
2501     return __ret
2502 
2503 
2504 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2505 @docstring.copy(Axes.contourf)
2506 def contourf(*args, data=None, **kwargs):
2507     __ret = gca().contourf(
2508         *args, **({"data": data} if data is not None else {}),
2509         **kwargs)
2510     if __ret._A is not None: sci(__ret)  # noqa
2511     return __ret
2512 
2513 
2514 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2515 @docstring.copy(Axes.csd)
2516 def csd(
2517         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2518         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2519         return_line=None, *, data=None, **kwargs):
2520     return gca().csd(
2521         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2522         noverlap=noverlap, pad_to=pad_to, sides=sides,
2523         scale_by_freq=scale_by_freq, return_line=return_line,
2524         **({"data": data} if data is not None else {}), **kwargs)
2525 
2526 
2527 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2528 @docstring.copy(Axes.errorbar)
2529 def errorbar(
2530         x, y, yerr=None, xerr=None, fmt='', ecolor=None,
2531         elinewidth=None, capsize=None, barsabove=False, lolims=False,
2532         uplims=False, xlolims=False, xuplims=False, errorevery=1,
2533         capthick=None, *, data=None, **kwargs):
2534     return gca().errorbar(
2535         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,
2536         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,
2537         lolims=lolims, uplims=uplims, xlolims=xlolims,
2538         xuplims=xuplims, errorevery=errorevery, capthick=capthick,
2539         **({"data": data} if data is not None else {}), **kwargs)
2540 
2541 
2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2543 @docstring.copy(Axes.eventplot)
2544 def eventplot(
2545         positions, orientation='horizontal', lineoffsets=1,
2546         linelengths=1, linewidths=None, colors=None,
2547         linestyles='solid', *, data=None, **kwargs):
2548     return gca().eventplot(
2549         positions, orientation=orientation, lineoffsets=lineoffsets,
2550         linelengths=linelengths, linewidths=linewidths, colors=colors,
2551         linestyles=linestyles, **({"data": data} if data is not None
2552         else {}), **kwargs)
2553 
2554 
2555 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2556 @docstring.copy(Axes.fill)
2557 def fill(*args, data=None, **kwargs):
2558     return gca().fill(
2559         *args, **({"data": data} if data is not None else {}),
2560         **kwargs)
2561 
2562 
2563 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2564 @docstring.copy(Axes.fill_between)
2565 def fill_between(
2566         x, y1, y2=0, where=None, interpolate=False, step=None, *,
2567         data=None, **kwargs):
2568     return gca().fill_between(
2569         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,
2570         **({"data": data} if data is not None else {}), **kwargs)
2571 
2572 
2573 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2574 @docstring.copy(Axes.fill_betweenx)
2575 def fill_betweenx(
2576         y, x1, x2=0, where=None, step=None, interpolate=False, *,
2577         data=None, **kwargs):
2578     return gca().fill_betweenx(
2579         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,
2580         **({"data": data} if data is not None else {}), **kwargs)
2581 
2582 
2583 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2584 @docstring.copy(Axes.grid)
2585 def grid(b=None, which='major', axis='both', **kwargs):
2586     return gca().grid(b=b, which=which, axis=axis, **kwargs)
2587 
2588 
2589 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2590 @docstring.copy(Axes.hexbin)
2591 def hexbin(
2592         x, y, C=None, gridsize=100, bins=None, xscale='linear',
2593         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,
2594         vmax=None, alpha=None, linewidths=None, edgecolors='face',
2595         reduce_C_function=np.mean, mincnt=None, marginals=False, *,
2596         data=None, **kwargs):
2597     __ret = gca().hexbin(
2598         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,
2599         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,
2600         vmax=vmax, alpha=alpha, linewidths=linewidths,
2601         edgecolors=edgecolors, reduce_C_function=reduce_C_function,
2602         mincnt=mincnt, marginals=marginals, **({"data": data} if data
2603         is not None else {}), **kwargs)
2604     sci(__ret)
2605     return __ret
2606 
2607 
2608 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2609 @docstring.copy(Axes.hist)
2610 def hist(
2611         x, bins=None, range=None, density=None, weights=None,
2612         cumulative=False, bottom=None, histtype='bar', align='mid',
2613         orientation='vertical', rwidth=None, log=False, color=None,
2614         label=None, stacked=False, normed=None, *, data=None,
2615         **kwargs):
2616     return gca().hist(
2617         x, bins=bins, range=range, density=density, weights=weights,
2618         cumulative=cumulative, bottom=bottom, histtype=histtype,
2619         align=align, orientation=orientation, rwidth=rwidth, log=log,
2620         color=color, label=label, stacked=stacked, normed=normed,
2621         **({"data": data} if data is not None else {}), **kwargs)
2622 
2623 
2624 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2625 @docstring.copy(Axes.hist2d)
2626 def hist2d(
2627         x, y, bins=10, range=None, density=False, weights=None,
2628         cmin=None, cmax=None, *, data=None, **kwargs):
2629     __ret = gca().hist2d(
2630         x, y, bins=bins, range=range, density=density,
2631         weights=weights, cmin=cmin, cmax=cmax, **({"data": data} if
2632         data is not None else {}), **kwargs)
2633     sci(__ret[-1])
2634     return __ret
2635 
2636 
2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2638 @docstring.copy(Axes.hlines)
2639 def hlines(
2640         y, xmin, xmax, colors='k', linestyles='solid', label='', *,
2641         data=None, **kwargs):
2642     return gca().hlines(
2643         y, xmin, xmax, colors=colors, linestyles=linestyles,
2644         label=label, **({"data": data} if data is not None else {}),
2645         **kwargs)
2646 
2647 
2648 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2649 @docstring.copy(Axes.imshow)
2650 def imshow(
2651         X, cmap=None, norm=None, aspect=None, interpolation=None,
2652         alpha=None, vmin=None, vmax=None, origin=None, extent=None,
2653         shape=cbook.deprecation._deprecated_parameter, filternorm=1,
2654         filterrad=4.0, imlim=cbook.deprecation._deprecated_parameter,
2655         resample=None, url=None, *, data=None, **kwargs):
2656     __ret = gca().imshow(
2657         X, cmap=cmap, norm=norm, aspect=aspect,
2658         interpolation=interpolation, alpha=alpha, vmin=vmin,
2659         vmax=vmax, origin=origin, extent=extent, shape=shape,
2660         filternorm=filternorm, filterrad=filterrad, imlim=imlim,
2661         resample=resample, url=url, **({"data": data} if data is not
2662         None else {}), **kwargs)
2663     sci(__ret)
2664     return __ret
2665 
2666 
2667 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2668 @docstring.copy(Axes.legend)
2669 def legend(*args, **kwargs):
2670     return gca().legend(*args, **kwargs)
2671 
2672 
2673 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2674 @docstring.copy(Axes.locator_params)
2675 def locator_params(axis='both', tight=None, **kwargs):
2676     return gca().locator_params(axis=axis, tight=tight, **kwargs)
2677 
2678 
2679 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2680 @docstring.copy(Axes.loglog)
2681 def loglog(*args, **kwargs):
2682     return gca().loglog(*args, **kwargs)
2683 
2684 
2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2686 @docstring.copy(Axes.magnitude_spectrum)
2687 def magnitude_spectrum(
2688         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,
2689         scale=None, *, data=None, **kwargs):
2690     return gca().magnitude_spectrum(
2691         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2692         scale=scale, **({"data": data} if data is not None else {}),
2693         **kwargs)
2694 
2695 
2696 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2697 @docstring.copy(Axes.margins)
2698 def margins(*margins, x=None, y=None, tight=True):
2699     return gca().margins(*margins, x=x, y=y, tight=tight)
2700 
2701 
2702 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2703 @docstring.copy(Axes.minorticks_off)
2704 def minorticks_off():
2705     return gca().minorticks_off()
2706 
2707 
2708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2709 @docstring.copy(Axes.minorticks_on)
2710 def minorticks_on():
2711     return gca().minorticks_on()
2712 
2713 
2714 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2715 @docstring.copy(Axes.pcolor)
2716 def pcolor(
2717         *args, alpha=None, norm=None, cmap=None, vmin=None,
2718         vmax=None, data=None, **kwargs):
2719     __ret = gca().pcolor(
2720         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2721         vmax=vmax, **({"data": data} if data is not None else {}),
2722         **kwargs)
2723     sci(__ret)
2724     return __ret
2725 
2726 
2727 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2728 @docstring.copy(Axes.pcolormesh)
2729 def pcolormesh(
2730         *args, alpha=None, norm=None, cmap=None, vmin=None,
2731         vmax=None, shading='flat', antialiased=False, data=None,
2732         **kwargs):
2733     __ret = gca().pcolormesh(
2734         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2735         vmax=vmax, shading=shading, antialiased=antialiased,
2736         **({"data": data} if data is not None else {}), **kwargs)
2737     sci(__ret)
2738     return __ret
2739 
2740 
2741 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2742 @docstring.copy(Axes.phase_spectrum)
2743 def phase_spectrum(
2744         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,
2745         data=None, **kwargs):
2746     return gca().phase_spectrum(
2747         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,
2748         **({"data": data} if data is not None else {}), **kwargs)
2749 
2750 
2751 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2752 @docstring.copy(Axes.pie)
2753 def pie(
2754         x, explode=None, labels=None, colors=None, autopct=None,
2755         pctdistance=0.6, shadow=False, labeldistance=1.1,
2756         startangle=None, radius=None, counterclock=True,
2757         wedgeprops=None, textprops=None, center=(0, 0), frame=False,
2758         rotatelabels=False, *, data=None):
2759     return gca().pie(
2760         x, explode=explode, labels=labels, colors=colors,
2761         autopct=autopct, pctdistance=pctdistance, shadow=shadow,
2762         labeldistance=labeldistance, startangle=startangle,
2763         radius=radius, counterclock=counterclock,
2764         wedgeprops=wedgeprops, textprops=textprops, center=center,
2765         frame=frame, rotatelabels=rotatelabels, **({"data": data} if
2766         data is not None else {}))
2767 
2768 
2769 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2770 @docstring.copy(Axes.plot)
2771 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):
2772     return gca().plot(
2773         *args, scalex=scalex, scaley=scaley, **({"data": data} if data
2774         is not None else {}), **kwargs)
2775 
2776 
2777 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2778 @docstring.copy(Axes.plot_date)
2779 def plot_date(
2780         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,
2781         data=None, **kwargs):
2782     return gca().plot_date(
2783         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate, **({"data":
2784         data} if data is not None else {}), **kwargs)
2785 
2786 
2787 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2788 @docstring.copy(Axes.psd)
2789 def psd(
2790         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2791         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,
2792         return_line=None, *, data=None, **kwargs):
2793     return gca().psd(
2794         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2795         noverlap=noverlap, pad_to=pad_to, sides=sides,
2796         scale_by_freq=scale_by_freq, return_line=return_line,
2797         **({"data": data} if data is not None else {}), **kwargs)
2798 
2799 
2800 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2801 @docstring.copy(Axes.quiver)
2802 def quiver(*args, data=None, **kw):
2803     __ret = gca().quiver(
2804         *args, **({"data": data} if data is not None else {}), **kw)
2805     sci(__ret)
2806     return __ret
2807 
2808 
2809 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2810 @docstring.copy(Axes.quiverkey)
2811 def quiverkey(Q, X, Y, U, label, **kw):
2812     return gca().quiverkey(Q, X, Y, U, label, **kw)
2813 
2814 
2815 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2816 @docstring.copy(Axes.scatter)
2817 def scatter(
2818         x, y, s=None, c=None, marker=None, cmap=None, norm=None,
2819         vmin=None, vmax=None, alpha=None, linewidths=None, verts=None,
2820         edgecolors=None, *, plotnonfinite=False, data=None, **kwargs):
2821     __ret = gca().scatter(
2822         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,
2823         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,
2824         verts=verts, edgecolors=edgecolors,
2825         plotnonfinite=plotnonfinite, **({"data": data} if data is not
2826         None else {}), **kwargs)
2827     sci(__ret)
2828     return __ret
2829 
2830 
2831 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2832 @docstring.copy(Axes.semilogx)
2833 def semilogx(*args, **kwargs):
2834     return gca().semilogx(*args, **kwargs)
2835 
2836 
2837 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2838 @docstring.copy(Axes.semilogy)
2839 def semilogy(*args, **kwargs):
2840     return gca().semilogy(*args, **kwargs)
2841 
2842 
2843 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2844 @docstring.copy(Axes.specgram)
2845 def specgram(
2846         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,
2847         noverlap=None, cmap=None, xextent=None, pad_to=None,
2848         sides=None, scale_by_freq=None, mode=None, scale=None,
2849         vmin=None, vmax=None, *, data=None, **kwargs):
2850     __ret = gca().specgram(
2851         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,
2852         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,
2853         sides=sides, scale_by_freq=scale_by_freq, mode=mode,
2854         scale=scale, vmin=vmin, vmax=vmax, **({"data": data} if data
2855         is not None else {}), **kwargs)
2856     sci(__ret[-1])
2857     return __ret
2858 
2859 
2860 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2861 @docstring.copy(Axes.spy)
2862 def spy(
2863         Z, precision=0, marker=None, markersize=None, aspect='equal',
2864         origin='upper', **kwargs):
2865     __ret = gca().spy(
2866         Z, precision=precision, marker=marker, markersize=markersize,
2867         aspect=aspect, origin=origin, **kwargs)
2868     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa
2869     return __ret
2870 
2871 
2872 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2873 @docstring.copy(Axes.stackplot)
2874 def stackplot(
2875         x, *args, labels=(), colors=None, baseline='zero', data=None,
2876         **kwargs):
2877     return gca().stackplot(
2878         x, *args, labels=labels, colors=colors, baseline=baseline,
2879         **({"data": data} if data is not None else {}), **kwargs)
2880 
2881 
2882 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2883 @docstring.copy(Axes.stem)
2884 def stem(
2885         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2886         label=None, use_line_collection=False, data=None):
2887     return gca().stem(
2888         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,
2889         bottom=bottom, label=label,
2890         use_line_collection=use_line_collection, **({"data": data} if
2891         data is not None else {}))
2892 
2893 
2894 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2895 @docstring.copy(Axes.step)
2896 def step(x, y, *args, where='pre', data=None, **kwargs):
2897     return gca().step(
2898         x, y, *args, where=where, **({"data": data} if data is not
2899         None else {}), **kwargs)
2900 
2901 
2902 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2903 @docstring.copy(Axes.streamplot)
2904 def streamplot(
2905         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,
2906         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,
2907         transform=None, zorder=None, start_points=None, maxlength=4.0,
2908         integration_direction='both', *, data=None):
2909     __ret = gca().streamplot(
2910         x, y, u, v, density=density, linewidth=linewidth, color=color,
2911         cmap=cmap, norm=norm, arrowsize=arrowsize,
2912         arrowstyle=arrowstyle, minlength=minlength,
2913         transform=transform, zorder=zorder, start_points=start_points,
2914         maxlength=maxlength,
2915         integration_direction=integration_direction, **({"data": data}
2916         if data is not None else {}))
2917     sci(__ret.lines)
2918     return __ret
2919 
2920 
2921 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2922 @docstring.copy(Axes.table)
2923 def table(
2924         cellText=None, cellColours=None, cellLoc='right',
2925         colWidths=None, rowLabels=None, rowColours=None,
2926         rowLoc='left', colLabels=None, colColours=None,
2927         colLoc='center', loc='bottom', bbox=None, edges='closed',
2928         **kwargs):
2929     return gca().table(
2930         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,
2931         colWidths=colWidths, rowLabels=rowLabels,
2932         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,
2933         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,
2934         edges=edges, **kwargs)
2935 
2936 
2937 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2938 @docstring.copy(Axes.text)
2939 def text(
2940         x, y, s, fontdict=None,
2941         withdash=cbook.deprecation._deprecated_parameter, **kwargs):
2942     return gca().text(x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)
2943 
2944 
2945 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2946 @docstring.copy(Axes.tick_params)
2947 def tick_params(axis='both', **kwargs):
2948     return gca().tick_params(axis=axis, **kwargs)
2949 
2950 
2951 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2952 @docstring.copy(Axes.ticklabel_format)
2953 def ticklabel_format(
2954         *, axis='both', style='', scilimits=None, useOffset=None,
2955         useLocale=None, useMathText=None):
2956     return gca().ticklabel_format(
2957         axis=axis, style=style, scilimits=scilimits,
2958         useOffset=useOffset, useLocale=useLocale,
2959         useMathText=useMathText)
2960 
2961 
2962 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2963 @docstring.copy(Axes.tricontour)
2964 def tricontour(*args, **kwargs):
2965     __ret = gca().tricontour(*args, **kwargs)
2966     if __ret._A is not None: sci(__ret)  # noqa
2967     return __ret
2968 
2969 
2970 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2971 @docstring.copy(Axes.tricontourf)
2972 def tricontourf(*args, **kwargs):
2973     __ret = gca().tricontourf(*args, **kwargs)
2974     if __ret._A is not None: sci(__ret)  # noqa
2975     return __ret
2976 
2977 
2978 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2979 @docstring.copy(Axes.tripcolor)
2980 def tripcolor(
2981         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,
2982         shading='flat', facecolors=None, **kwargs):
2983     __ret = gca().tripcolor(
2984         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,
2985         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)
2986     sci(__ret)
2987     return __ret
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @docstring.copy(Axes.triplot)
2992 def triplot(*args, **kwargs):
2993     return gca().triplot(*args, **kwargs)
2994 
2995 
2996 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2997 @docstring.copy(Axes.violinplot)
2998 def violinplot(
2999         dataset, positions=None, vert=True, widths=0.5,
3000         showmeans=False, showextrema=True, showmedians=False,
3001         points=100, bw_method=None, *, data=None):
3002     return gca().violinplot(
3003         dataset, positions=positions, vert=vert, widths=widths,
3004         showmeans=showmeans, showextrema=showextrema,
3005         showmedians=showmedians, points=points, bw_method=bw_method,
3006         **({"data": data} if data is not None else {}))
3007 
3008 
3009 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3010 @docstring.copy(Axes.vlines)
3011 def vlines(
3012         x, ymin, ymax, colors='k', linestyles='solid', label='', *,
3013         data=None, **kwargs):
3014     return gca().vlines(
3015         x, ymin, ymax, colors=colors, linestyles=linestyles,
3016         label=label, **({"data": data} if data is not None else {}),
3017         **kwargs)
3018 
3019 
3020 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3021 @docstring.copy(Axes.xcorr)
3022 def xcorr(
3023         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,
3024         maxlags=10, *, data=None, **kwargs):
3025     return gca().xcorr(
3026         x, y, normed=normed, detrend=detrend, usevlines=usevlines,
3027         maxlags=maxlags, **({"data": data} if data is not None else
3028         {}), **kwargs)
3029 
3030 
3031 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3032 @docstring.copy(Axes._sci)
3033 def sci(im):
3034     return gca()._sci(im)
3035 
3036 
3037 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3038 @docstring.copy(Axes.set_title)
3039 def title(label, fontdict=None, loc='center', pad=None, **kwargs):
3040     return gca().set_title(
3041         label, fontdict=fontdict, loc=loc, pad=pad, **kwargs)
3042 
3043 
3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3045 @docstring.copy(Axes.set_xlabel)
3046 def xlabel(xlabel, fontdict=None, labelpad=None, **kwargs):
3047     return gca().set_xlabel(
3048         xlabel, fontdict=fontdict, labelpad=labelpad, **kwargs)
3049 
3050 
3051 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3052 @docstring.copy(Axes.set_ylabel)
3053 def ylabel(ylabel, fontdict=None, labelpad=None, **kwargs):
3054     return gca().set_ylabel(
3055         ylabel, fontdict=fontdict, labelpad=labelpad, **kwargs)
3056 
3057 
3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3059 @docstring.copy(Axes.set_xscale)
3060 def xscale(value, **kwargs):
3061     return gca().set_xscale(value, **kwargs)
3062 
3063 
3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3065 @docstring.copy(Axes.set_yscale)
3066 def yscale(value, **kwargs):
3067     return gca().set_yscale(value, **kwargs)
3068 
3069 
3070 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3071 def autumn():
3072     """
3073     Set the colormap to "autumn".
3074 
3075     This changes the default colormap as well as the colormap of the current
3076     image if there is one. See ``help(colormaps)`` for more information.
3077     """
3078     set_cmap("autumn")
3079 
3080 
3081 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3082 def bone():
3083     """
3084     Set the colormap to "bone".
3085 
3086     This changes the default colormap as well as the colormap of the current
3087     image if there is one. See ``help(colormaps)`` for more information.
3088     """
3089     set_cmap("bone")
3090 
3091 
3092 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3093 def cool():
3094     """
3095     Set the colormap to "cool".
3096 
3097     This changes the default colormap as well as the colormap of the current
3098     image if there is one. See ``help(colormaps)`` for more information.
3099     """
3100     set_cmap("cool")
3101 
3102 
3103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3104 def copper():
3105     """
3106     Set the colormap to "copper".
3107 
3108     This changes the default colormap as well as the colormap of the current
3109     image if there is one. See ``help(colormaps)`` for more information.
3110     """
3111     set_cmap("copper")
3112 
3113 
3114 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3115 def flag():
3116     """
3117     Set the colormap to "flag".
3118 
3119     This changes the default colormap as well as the colormap of the current
3120     image if there is one. See ``help(colormaps)`` for more information.
3121     """
3122     set_cmap("flag")
3123 
3124 
3125 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3126 def gray():
3127     """
3128     Set the colormap to "gray".
3129 
3130     This changes the default colormap as well as the colormap of the current
3131     image if there is one. See ``help(colormaps)`` for more information.
3132     """
3133     set_cmap("gray")
3134 
3135 
3136 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3137 def hot():
3138     """
3139     Set the colormap to "hot".
3140 
3141     This changes the default colormap as well as the colormap of the current
3142     image if there is one. See ``help(colormaps)`` for more information.
3143     """
3144     set_cmap("hot")
3145 
3146 
3147 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3148 def hsv():
3149     """
3150     Set the colormap to "hsv".
3151 
3152     This changes the default colormap as well as the colormap of the current
3153     image if there is one. See ``help(colormaps)`` for more information.
3154     """
3155     set_cmap("hsv")
3156 
3157 
3158 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3159 def jet():
3160     """
3161     Set the colormap to "jet".
3162 
3163     This changes the default colormap as well as the colormap of the current
3164     image if there is one. See ``help(colormaps)`` for more information.
3165     """
3166     set_cmap("jet")
3167 
3168 
3169 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3170 def pink():
3171     """
3172     Set the colormap to "pink".
3173 
3174     This changes the default colormap as well as the colormap of the current
3175     image if there is one. See ``help(colormaps)`` for more information.
3176     """
3177     set_cmap("pink")
3178 
3179 
3180 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3181 def prism():
3182     """
3183     Set the colormap to "prism".
3184 
3185     This changes the default colormap as well as the colormap of the current
3186     image if there is one. See ``help(colormaps)`` for more information.
3187     """
3188     set_cmap("prism")
3189 
3190 
3191 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3192 def spring():
3193     """
3194     Set the colormap to "spring".
3195 
3196     This changes the default colormap as well as the colormap of the current
3197     image if there is one. See ``help(colormaps)`` for more information.
3198     """
3199     set_cmap("spring")
3200 
3201 
3202 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3203 def summer():
3204     """
3205     Set the colormap to "summer".
3206 
3207     This changes the default colormap as well as the colormap of the current
3208     image if there is one. See ``help(colormaps)`` for more information.
3209     """
3210     set_cmap("summer")
3211 
3212 
3213 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3214 def winter():
3215     """
3216     Set the colormap to "winter".
3217 
3218     This changes the default colormap as well as the colormap of the current
3219     image if there is one. See ``help(colormaps)`` for more information.
3220     """
3221     set_cmap("winter")
3222 
3223 
3224 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3225 def magma():
3226     """
3227     Set the colormap to "magma".
3228 
3229     This changes the default colormap as well as the colormap of the current
3230     image if there is one. See ``help(colormaps)`` for more information.
3231     """
3232     set_cmap("magma")
3233 
3234 
3235 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3236 def inferno():
3237     """
3238     Set the colormap to "inferno".
3239 
3240     This changes the default colormap as well as the colormap of the current
3241     image if there is one. See ``help(colormaps)`` for more information.
3242     """
3243     set_cmap("inferno")
3244 
3245 
3246 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3247 def plasma():
3248     """
3249     Set the colormap to "plasma".
3250 
3251     This changes the default colormap as well as the colormap of the current
3252     image if there is one. See ``help(colormaps)`` for more information.
3253     """
3254     set_cmap("plasma")
3255 
3256 
3257 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3258 def viridis():
3259     """
3260     Set the colormap to "viridis".
3261 
3262     This changes the default colormap as well as the colormap of the current
3263     image if there is one. See ``help(colormaps)`` for more information.
3264     """
3265     set_cmap("viridis")
3266 
3267 
3268 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3269 def nipy_spectral():
3270     """
3271     Set the colormap to "nipy_spectral".
3272 
3273     This changes the default colormap as well as the colormap of the current
3274     image if there is one. See ``help(colormaps)`` for more information.
3275     """
3276     set_cmap("nipy_spectral")
3277 
3278 _setup_pyplot_info_docstrings()

</code><intended_behavior>In the `savefig` function, add a pre-check for the figure size directly or ensure that any down-stream method from `pyplot.savefig` that eventually interacts with figure dimensions performs a check to prevent zero-width or zero-height figures from being passed to libpng. This check, similar to the one proposed in `figure.py`, should raise an informative exception if invalid dimensions are identified. This will warn users before an attempt is made to render or save the figure, thereby avoiding the runtime error from libpng.</intended_behavior>]
2025-10-15 20:15:21.539 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 20:15:21.540 | INFO     | Search-only: skipping patch selection
2025-10-15 20:15:21.625 | INFO     | Task matplotlib__matplotlib-13859 completed successfully.
2025-10-15 20:15:21.626 | INFO     | No patch generated. You can try running ACR again.
