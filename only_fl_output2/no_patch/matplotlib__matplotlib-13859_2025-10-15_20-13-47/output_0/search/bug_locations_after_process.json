[
    {
        "rel_file_path": "lib/matplotlib/figure.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.0/lib/matplotlib/figure.py",
        "start": 1,
        "end": 2759,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 The figure module provides the top-level\n3 :class:`~matplotlib.artist.Artist`, the :class:`Figure`, which\n4 contains all the plot elements.  The following classes are defined\n5 \n6 :class:`SubplotParams`\n7     control the default spacing of the subplots\n8 \n9 :class:`Figure`\n10     Top level container for all plot elements.\n11 \n12 \"\"\"\n13 \n14 import logging\n15 from numbers import Integral\n16 \n17 import numpy as np\n18 \n19 from matplotlib import rcParams\n20 from matplotlib import backends, docstring, projections\n21 from matplotlib import __version__ as _mpl_version\n22 from matplotlib import get_backend\n23 \n24 import matplotlib.artist as martist\n25 from matplotlib.artist import Artist, allow_rasterization\n26 from matplotlib.backend_bases import FigureCanvasBase\n27 import matplotlib.cbook as cbook\n28 import matplotlib.colorbar as cbar\n29 import matplotlib.image as mimage\n30 \n31 from matplotlib.axes import Axes, SubplotBase, subplot_class_factory\n32 from matplotlib.blocking_input import BlockingMouseInput, BlockingKeyMouseInput\n33 from matplotlib.gridspec import GridSpec\n34 import matplotlib.legend as mlegend\n35 from matplotlib.patches import Rectangle\n36 from matplotlib.projections import (get_projection_names,\n37                                     process_projection_requirements)\n38 from matplotlib.text import Text, TextWithDash\n39 from matplotlib.transforms import (Affine2D, Bbox, BboxTransformTo,\n40                                    TransformedBbox)\n41 import matplotlib._layoutbox as layoutbox\n42 from matplotlib.backend_bases import NonGuiException\n43 \n44 _log = logging.getLogger(__name__)\n45 \n46 docstring.interpd.update(projection_names=get_projection_names())\n47 \n48 \n49 def _stale_figure_callback(self, val):\n50     if self.figure:\n51         self.figure.stale = val\n52 \n53 \n54 class AxesStack(cbook.Stack):\n55     \"\"\"\n56     Specialization of the `.Stack` to handle all tracking of\n57     `~matplotlib.axes.Axes` in a `.Figure`.\n58     This stack stores ``key, (ind, axes)`` pairs, where:\n59 \n60         * **key** should be a hash of the args and kwargs\n61           used in generating the Axes.\n62         * **ind** is a serial number for tracking the order\n63           in which axes were added.\n64 \n65     The AxesStack is a callable, where ``ax_stack()`` returns\n66     the current axes. Alternatively the :meth:`current_key_axes` will\n67     return the current key and associated axes.\n68 \n69     \"\"\"\n70     def __init__(self):\n71         super().__init__()\n72         self._ind = 0\n73 \n74     def as_list(self):\n75         \"\"\"\n76         Return a list of the Axes instances that have been added to the figure.\n77         \"\"\"\n78         ia_list = [a for k, a in self._elements]\n79         ia_list.sort()\n80         return [a for i, a in ia_list]\n81 \n82     def get(self, key):\n83         \"\"\"\n84         Return the Axes instance that was added with *key*.\n85         If it is not present, return *None*.\n86         \"\"\"\n87         item = dict(self._elements).get(key)\n88         if item is None:\n89             return None\n90         cbook.warn_deprecated(\n91             \"2.1\",\n92             message=\"Adding an axes using the same arguments as a previous \"\n93             \"axes currently reuses the earlier instance.  In a future \"\n94             \"version, a new instance will always be created and returned.  \"\n95             \"Meanwhile, this warning can be suppressed, and the future \"\n96             \"behavior ensured, by passing a unique label to each axes \"\n97             \"instance.\")\n98         return item[1]\n99 \n100     def _entry_from_axes(self, e):\n101         ind, k = {a: (ind, k) for k, (ind, a) in self._elements}[e]\n102         return (k, (ind, e))\n103 \n104     def remove(self, a):\n105         \"\"\"Remove the axes from the stack.\"\"\"\n106         super().remove(self._entry_from_axes(a))\n107 \n108     def bubble(self, a):\n109         \"\"\"\n110         Move the given axes, which must already exist in the\n111         stack, to the top.\n112         \"\"\"\n113         return super().bubble(self._entry_from_axes(a))\n114 \n115     def add(self, key, a):\n116         \"\"\"\n117         Add Axes *a*, with key *key*, to the stack, and return the stack.\n118 \n119         If *key* is unhashable, replace it by a unique, arbitrary object.\n120 \n121         If *a* is already on the stack, don't add it again, but\n122         return *None*.\n123         \"\"\"\n124         # All the error checking may be unnecessary; but this method\n125         # is called so seldom that the overhead is negligible.\n126         if not isinstance(a, Axes):\n127             raise ValueError(\"second argument, {!r}, is not an Axes\".format(a))\n128         try:\n129             hash(key)\n130         except TypeError:\n131             key = object()\n132 \n133         a_existing = self.get(key)\n134         if a_existing is not None:\n135             super().remove((key, a_existing))\n136             cbook._warn_external(\n137                 \"key {!r} already existed; Axes is being replaced\".format(key))\n138             # I don't think the above should ever happen.\n139 \n140         if a in self:\n141             return None\n142         self._ind += 1\n143         return super().push((key, (self._ind, a)))\n144 \n145     def current_key_axes(self):\n146         \"\"\"\n147         Return a tuple of ``(key, axes)`` for the active axes.\n148 \n149         If no axes exists on the stack, then returns ``(None, None)``.\n150         \"\"\"\n151         if not len(self._elements):\n152             return self._default, self._default\n153         else:\n154             key, (index, axes) = self._elements[self._pos]\n155             return key, axes\n156 \n157     def __call__(self):\n158         return self.current_key_axes()[1]\n159 \n160     def __contains__(self, a):\n161         return a in self.as_list()\n162 \n163 \n164 class SubplotParams(object):\n165     \"\"\"\n166     A class to hold the parameters for a subplot.\n167     \"\"\"\n168     def __init__(self, left=None, bottom=None, right=None, top=None,\n169                  wspace=None, hspace=None):\n170         \"\"\"\n171         All dimensions are fractions of the figure width or height.\n172         Defaults are given by :rc:`figure.subplot.[name]`.\n173 \n174         Parameters\n175         ----------\n176         left : float\n177             The left side of the subplots of the figure.\n178 \n179         right : float\n180             The right side of the subplots of the figure.\n181 \n182         bottom : float\n183             The bottom of the subplots of the figure.\n184 \n185         top : float\n186             The top of the subplots of the figure.\n187 \n188         wspace : float\n189             The amount of width reserved for space between subplots,\n190             expressed as a fraction of the average axis width.\n191 \n192         hspace : float\n193             The amount of height reserved for space between subplots,\n194             expressed as a fraction of the average axis height.\n195         \"\"\"\n196         self.validate = True\n197         self.update(left, bottom, right, top, wspace, hspace)\n198 \n199     def update(self, left=None, bottom=None, right=None, top=None,\n200                wspace=None, hspace=None):\n201         \"\"\"\n202         Update the dimensions of the passed parameters. *None* means unchanged.\n203         \"\"\"\n204         thisleft = getattr(self, 'left', None)\n205         thisright = getattr(self, 'right', None)\n206         thistop = getattr(self, 'top', None)\n207         thisbottom = getattr(self, 'bottom', None)\n208         thiswspace = getattr(self, 'wspace', None)\n209         thishspace = getattr(self, 'hspace', None)\n210 \n211         self._update_this('left', left)\n212         self._update_this('right', right)\n213         self._update_this('bottom', bottom)\n214         self._update_this('top', top)\n215         self._update_this('wspace', wspace)\n216         self._update_this('hspace', hspace)\n217 \n218         def reset():\n219             self.left = thisleft\n220             self.right = thisright\n221             self.top = thistop\n222             self.bottom = thisbottom\n223             self.wspace = thiswspace\n224             self.hspace = thishspace\n225 \n226         if self.validate:\n227             if self.left >= self.right:\n228                 reset()\n229                 raise ValueError('left cannot be >= right')\n230 \n231             if self.bottom >= self.top:\n232                 reset()\n233                 raise ValueError('bottom cannot be >= top')\n234 \n235     def _update_this(self, s, val):\n236         if val is None:\n237             val = getattr(self, s, None)\n238             if val is None:\n239                 key = 'figure.subplot.' + s\n240                 val = rcParams[key]\n241 \n242         setattr(self, s, val)\n243 \n244 \n245 class Figure(Artist):\n246     \"\"\"\n247     The top level container for all the plot elements.\n248 \n249     The Figure instance supports callbacks through a *callbacks* attribute\n250     which is a `.CallbackRegistry` instance.  The events you can connect to\n251     are 'dpi_changed', and the callback will be called with ``func(fig)`` where\n252     fig is the `Figure` instance.\n253 \n254     Attributes\n255     ----------\n256     patch\n257         The `.Rectangle` instance representing the figure background patch.\n258 \n259     suppressComposite\n260         For multiple figure images, the figure will make composite images\n261         depending on the renderer option_image_nocomposite function.  If\n262         *suppressComposite* is a boolean, this will override the renderer.\n263     \"\"\"\n264 \n265     def __str__(self):\n266         return \"Figure(%gx%g)\" % tuple(self.bbox.size)\n267 \n268     def __repr__(self):\n269         return \"<{clsname} size {h:g}x{w:g} with {naxes} Axes>\".format(\n270             clsname=self.__class__.__name__,\n271             h=self.bbox.size[0], w=self.bbox.size[1],\n272             naxes=len(self.axes),\n273         )\n274 \n275     def __init__(self,\n276                  figsize=None,\n277                  dpi=None,\n278                  facecolor=None,\n279                  edgecolor=None,\n280                  linewidth=0.0,\n281                  frameon=None,\n282                  subplotpars=None,  # default to rc\n283                  tight_layout=None,  # default to rc figure.autolayout\n284                  constrained_layout=None,  # default to rc\n285                                           #figure.constrained_layout.use\n286                  ):\n287         \"\"\"\n288         Parameters\n289         ----------\n290         figsize : 2-tuple of floats, default: :rc:`figure.figsize`\n291             Figure dimension ``(width, height)`` in inches.\n292 \n293         dpi : float, default: :rc:`figure.dpi`\n294             Dots per inch.\n295 \n296         facecolor : default: :rc:`figure.facecolor`\n297             The figure patch facecolor.\n298 \n299         edgecolor : default: :rc:`figure.edgecolor`\n300             The figure patch edge color.\n301 \n302         linewidth : float\n303             The linewidth of the frame (i.e. the edge linewidth of the figure\n304             patch).\n305 \n306         frameon : bool, default: :rc:`figure.frameon`\n307             If ``False``, suppress drawing the figure background patch.\n308 \n309         subplotpars : :class:`SubplotParams`\n310             Subplot parameters. If not given, the default subplot\n311             parameters :rc:`figure.subplot.*` are used.\n312 \n313         tight_layout : bool or dict, default: :rc:`figure.autolayout`\n314             If ``False`` use *subplotpars*. If ``True`` adjust subplot\n315             parameters using `.tight_layout` with default padding.\n316             When providing a dict containing the keys ``pad``, ``w_pad``,\n317             ``h_pad``, and ``rect``, the default `.tight_layout` paddings\n318             will be overridden.\n319 \n320         constrained_layout : bool\n321             If ``True`` use constrained layout to adjust positioning of plot\n322             elements.  Like ``tight_layout``, but designed to be more\n323             flexible.  See\n324             :doc:`/tutorials/intermediate/constrainedlayout_guide`\n325             for examples.  (Note: does not work with :meth:`.subplot` or\n326             :meth:`.subplot2grid`.)\n327             Defaults to :rc:`figure.constrained_layout.use`.\n328         \"\"\"\n329         super().__init__()\n330         # remove the non-figure artist _axes property\n331         # as it makes no sense for a figure to be _in_ an axes\n332         # this is used by the property methods in the artist base class\n333         # which are over-ridden in this class\n334         del self._axes\n335         self.callbacks = cbook.CallbackRegistry()\n336 \n337         if figsize is None:\n338             figsize = rcParams['figure.figsize']\n339         if dpi is None:\n340             dpi = rcParams['figure.dpi']\n341         if facecolor is None:\n342             facecolor = rcParams['figure.facecolor']\n343         if edgecolor is None:\n344             edgecolor = rcParams['figure.edgecolor']\n345         if frameon is None:\n346             frameon = rcParams['figure.frameon']\n347 \n348         if not np.isfinite(figsize).all():\n349             raise ValueError('figure size must be finite not '\n350                              '{}'.format(figsize))\n351         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)\n352 \n353         self.dpi_scale_trans = Affine2D().scale(dpi, dpi)\n354         # do not use property as it will trigger\n355         self._dpi = dpi\n356         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)\n357 \n358         self.transFigure = BboxTransformTo(self.bbox)\n359 \n360         self.patch = Rectangle(\n361             xy=(0, 0), width=1, height=1,\n362             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,\n363             visible=frameon)\n364         self._set_artist_props(self.patch)\n365         self.patch.set_antialiased(False)\n366 \n367         FigureCanvasBase(self)  # Set self.canvas.\n368         self._suptitle = None\n369 \n370         if subplotpars is None:\n371             subplotpars = SubplotParams()\n372 \n373         self.subplotpars = subplotpars\n374         # constrained_layout:\n375         self._layoutbox = None\n376         # set in set_constrained_layout_pads()\n377         self.set_constrained_layout(constrained_layout)\n378 \n379         self.set_tight_layout(tight_layout)\n380 \n381         self._axstack = AxesStack()  # track all figure axes and current axes\n382         self.clf()\n383         self._cachedRenderer = None\n384 \n385         # groupers to keep track of x and y labels we want to align.\n386         # see self.align_xlabels and self.align_ylabels and\n387         # axis._get_tick_boxes_siblings\n388         self._align_xlabel_grp = cbook.Grouper()\n389         self._align_ylabel_grp = cbook.Grouper()\n390 \n391         # list of child gridspecs for this figure\n392         self._gridspecs = []\n393 \n394     # TODO: I'd like to dynamically add the _repr_html_ method\n395     # to the figure in the right context, but then IPython doesn't\n396     # use it, for some reason.\n397 \n398     def _repr_html_(self):\n399         # We can't use \"isinstance\" here, because then we'd end up importing\n400         # webagg unconditionally.\n401         if 'WebAgg' in type(self.canvas).__name__:\n402             from matplotlib.backends import backend_webagg\n403             return backend_webagg.ipython_inline_display(self)\n404 \n405     def show(self, warn=True):\n406         \"\"\"\n407         If using a GUI backend with pyplot, display the figure window.\n408 \n409         If the figure was not created using\n410         :func:`~matplotlib.pyplot.figure`, it will lack a\n411         :class:`~matplotlib.backend_bases.FigureManagerBase`, and\n412         will raise an AttributeError.\n413 \n414         .. warning::\n415             This does not manage an GUI event loop. Consequently, the figure\n416             may only be shown briefly or not shown at all if you or your\n417             environment are not managing an event loop.\n418 \n419             Proper use cases for `.Figure.show` include running this from a\n420             GUI application or an IPython shell.\n421 \n422             If you're running a pure python shell or executing a non-GUI\n423             python script, you should use `matplotlib.pyplot.show` instead,\n424             which takes care of managing the event loop for you.\n425 \n426         Parameters\n427         ----------\n428         warn : bool\n429             If ``True`` and we are not running headless (i.e. on Linux with an\n430             unset DISPLAY), issue warning when called on a non-GUI backend.\n431         \"\"\"\n432         try:\n433             manager = getattr(self.canvas, 'manager')\n434         except AttributeError as err:\n435             raise AttributeError(\"%s\\n\"\n436                                  \"Figure.show works only \"\n437                                  \"for figures managed by pyplot, normally \"\n438                                  \"created by pyplot.figure().\" % err)\n439 \n440         if manager is not None:\n441             try:\n442                 manager.show()\n443                 return\n444             except NonGuiException:\n445                 pass\n446         if (backends._get_running_interactive_framework() != \"headless\"\n447                 and warn):\n448             cbook._warn_external('Matplotlib is currently using %s, which is '\n449                                  'a non-GUI backend, so cannot show the '\n450                                  'figure.' % get_backend())\n451 \n452     def _get_axes(self):\n453         return self._axstack.as_list()\n454 \n455     axes = property(fget=_get_axes,\n456                     doc=\"List of axes in the Figure. You can access the \"\n457                         \"axes in the Figure through this list. \"\n458                         \"Do not modify the list itself. Instead, use \"\n459                         \"`~Figure.add_axes`, `~.Figure.subplot` or \"\n460                         \"`~.Figure.delaxes` to add or remove an axes.\")\n461 \n462     def _get_dpi(self):\n463         return self._dpi\n464 \n465     def _set_dpi(self, dpi, forward=True):\n466         \"\"\"\n467         Parameters\n468         ----------\n469         dpi : float\n470 \n471         forward : bool\n472             Passed on to `~.Figure.set_size_inches`\n473         \"\"\"\n474         self._dpi = dpi\n475         self.dpi_scale_trans.clear().scale(dpi, dpi)\n476         w, h = self.get_size_inches()\n477         self.set_size_inches(w, h, forward=forward)\n478         self.callbacks.process('dpi_changed', self)\n479 \n480     dpi = property(_get_dpi, _set_dpi, doc=\"The resolution in dots per inch.\")\n481 \n482     def get_tight_layout(self):\n483         \"\"\"Return whether `.tight_layout` is called when drawing.\"\"\"\n484         return self._tight\n485 \n486     def set_tight_layout(self, tight):\n487         \"\"\"\n488         Set whether and how `.tight_layout` is called when drawing.\n489 \n490         Parameters\n491         ----------\n492         tight : bool or dict with keys \"pad\", \"w_pad\", \"h_pad\", \"rect\" or None\n493             If a bool, sets whether to call `.tight_layout` upon drawing.\n494             If ``None``, use the ``figure.autolayout`` rcparam instead.\n495             If a dict, pass it as kwargs to `.tight_layout`, overriding the\n496             default paddings.\n497         \"\"\"\n498         if tight is None:\n499             tight = rcParams['figure.autolayout']\n500         self._tight = bool(tight)\n501         self._tight_parameters = tight if isinstance(tight, dict) else {}\n502         self.stale = True\n503 \n504     def get_constrained_layout(self):\n505         \"\"\"\n506         Return a boolean: True means constrained layout is being used.\n507 \n508         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n509         \"\"\"\n510         return self._constrained\n511 \n512     def set_constrained_layout(self, constrained):\n513         \"\"\"\n514         Set whether ``constrained_layout`` is used upon drawing. If None,\n515         the rcParams['figure.constrained_layout.use'] value will be used.\n516 \n517         When providing a dict containing the keys `w_pad`, `h_pad`\n518         the default ``constrained_layout`` paddings will be\n519         overridden.  These pads are in inches and default to 3.0/72.0.\n520         ``w_pad`` is the width padding and ``h_pad`` is the height padding.\n521 \n522         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n523 \n524         Parameters\n525         ----------\n526         constrained : bool or dict or None\n527         \"\"\"\n528         self._constrained_layout_pads = dict()\n529         self._constrained_layout_pads['w_pad'] = None\n530         self._constrained_layout_pads['h_pad'] = None\n531         self._constrained_layout_pads['wspace'] = None\n532         self._constrained_layout_pads['hspace'] = None\n533         if constrained is None:\n534             constrained = rcParams['figure.constrained_layout.use']\n535         self._constrained = bool(constrained)\n536         if isinstance(constrained, dict):\n537             self.set_constrained_layout_pads(**constrained)\n538         else:\n539             self.set_constrained_layout_pads()\n540 \n541         self.stale = True\n542 \n543     def set_constrained_layout_pads(self, **kwargs):\n544         \"\"\"\n545         Set padding for ``constrained_layout``.  Note the kwargs can be passed\n546         as a dictionary ``fig.set_constrained_layout(**paddict)``.\n547 \n548         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n549 \n550         Parameters\n551         ----------\n552 \n553         w_pad : scalar\n554             Width padding in inches.  This is the pad around axes\n555             and is meant to make sure there is enough room for fonts to\n556             look good.  Defaults to 3 pts = 0.04167 inches\n557 \n558         h_pad : scalar\n559             Height padding in inches. Defaults to 3 pts.\n560 \n561         wspace : scalar\n562             Width padding between subplots, expressed as a fraction of the\n563             subplot width.  The total padding ends up being w_pad + wspace.\n564 \n565         hspace : scalar\n566             Height padding between subplots, expressed as a fraction of the\n567             subplot width. The total padding ends up being h_pad + hspace.\n568 \n569         \"\"\"\n570 \n571         todo = ['w_pad', 'h_pad', 'wspace', 'hspace']\n572         for td in todo:\n573             if td in kwargs and kwargs[td] is not None:\n574                 self._constrained_layout_pads[td] = kwargs[td]\n575             else:\n576                 self._constrained_layout_pads[td] = (\n577                     rcParams['figure.constrained_layout.' + td])\n578 \n579     def get_constrained_layout_pads(self, relative=False):\n580         \"\"\"\n581         Get padding for ``constrained_layout``.\n582 \n583         Returns a list of `w_pad, h_pad` in inches and\n584         `wspace` and `hspace` as fractions of the subplot.\n585 \n586         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.\n587 \n588         Parameters\n589         ----------\n590 \n591         relative : boolean\n592             If `True`, then convert from inches to figure relative.\n593         \"\"\"\n594         w_pad = self._constrained_layout_pads['w_pad']\n595         h_pad = self._constrained_layout_pads['h_pad']\n596         wspace = self._constrained_layout_pads['wspace']\n597         hspace = self._constrained_layout_pads['hspace']\n598 \n599         if relative and (w_pad is not None or h_pad is not None):\n600             renderer0 = layoutbox.get_renderer(self)\n601             dpi = renderer0.dpi\n602             w_pad = w_pad * dpi / renderer0.width\n603             h_pad = h_pad * dpi / renderer0.height\n604 \n605         return w_pad, h_pad, wspace, hspace\n606 \n607     def autofmt_xdate(self, bottom=0.2, rotation=30, ha='right', which=None):\n608         \"\"\"\n609         Date ticklabels often overlap, so it is useful to rotate them\n610         and right align them.  Also, a common use case is a number of\n611         subplots with shared xaxes where the x-axis is date data.  The\n612         ticklabels are often long, and it helps to rotate them on the\n613         bottom subplot and turn them off on other subplots, as well as\n614         turn off xlabels.\n615 \n616         Parameters\n617         ----------\n618         bottom : scalar\n619             The bottom of the subplots for :meth:`subplots_adjust`.\n620 \n621         rotation : angle in degrees\n622             The rotation of the xtick labels.\n623 \n624         ha : string\n625             The horizontal alignment of the xticklabels.\n626 \n627         which : {None, 'major', 'minor', 'both'}\n628             Selects which ticklabels to rotate. Default is None which works\n629             the same as major.\n630         \"\"\"\n631         allsubplots = all(hasattr(ax, 'is_last_row') for ax in self.axes)\n632         if len(self.axes) == 1:\n633             for label in self.axes[0].get_xticklabels(which=which):\n634                 label.set_ha(ha)\n635                 label.set_rotation(rotation)\n636         else:\n637             if allsubplots:\n638                 for ax in self.get_axes():\n639                     if ax.is_last_row():\n640                         for label in ax.get_xticklabels(which=which):\n641                             label.set_ha(ha)\n642                             label.set_rotation(rotation)\n643                     else:\n644                         for label in ax.get_xticklabels(which=which):\n645                             label.set_visible(False)\n646                         ax.set_xlabel('')\n647 \n648         if allsubplots:\n649             self.subplots_adjust(bottom=bottom)\n650         self.stale = True\n651 \n652     def get_children(self):\n653         \"\"\"Get a list of artists contained in the figure.\"\"\"\n654         return [self.patch,\n655                 *self.artists,\n656                 *self.axes,\n657                 *self.lines,\n658                 *self.patches,\n659                 *self.texts,\n660                 *self.images,\n661                 *self.legends]\n662 \n663     def contains(self, mouseevent):\n664         \"\"\"\n665         Test whether the mouse event occurred on the figure.\n666 \n667         Returns\n668         -------\n669             bool, {}\n670         \"\"\"\n671         if self._contains is not None:\n672             return self._contains(self, mouseevent)\n673         inside = self.bbox.contains(mouseevent.x, mouseevent.y)\n674         return inside, {}\n675 \n676     def get_window_extent(self, *args, **kwargs):\n677         \"\"\"\n678         Return the figure bounding box in display space. Arguments are ignored.\n679         \"\"\"\n680         return self.bbox\n681 \n682     def suptitle(self, t, **kwargs):\n683         \"\"\"\n684         Add a centered title to the figure.\n685 \n686         Parameters\n687         ----------\n688         t : str\n689             The title text.\n690 \n691         x : float, default 0.5\n692             The x location of the text in figure coordinates.\n693 \n694         y : float, default 0.98\n695             The y location of the text in figure coordinates.\n696 \n697         horizontalalignment, ha : {'center', 'left', right'}, default: 'center'\n698             The horizontal alignment of the text relative to (*x*, *y*).\n699 \n700         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \\\n701 default: 'top'\n702             The vertical alignment of the text relative to (*x*, *y*).\n703 \n704         fontsize, size : default: :rc:`figure.titlesize`\n705             The font size of the text. See `.Text.set_size` for possible\n706             values.\n707 \n708         fontweight, weight : default: :rc:`figure.titleweight`\n709             The font weight of the text. See `.Text.set_weight` for possible\n710             values.\n711 \n712 \n713         Returns\n714         -------\n715             text\n716                 The `.Text` instance of the title.\n717 \n718 \n719         Other Parameters\n720         ----------------\n721         fontproperties : None or dict, optional\n722             A dict of font properties. If *fontproperties* is given the\n723             default values for font size and weight are taken from the\n724             `FontProperties` defaults. :rc:`figure.titlesize` and\n725             :rc:`figure.titleweight` are ignored in this case.\n726 \n727         **kwargs\n728             Additional kwargs are :class:`matplotlib.text.Text` properties.\n729 \n730 \n731         Examples\n732         --------\n733 \n734         >>> fig.suptitle('This is the figure title', fontsize=12)\n735         \"\"\"\n736         manual_position = ('x' in kwargs or 'y' in kwargs)\n737 \n738         x = kwargs.pop('x', 0.5)\n739         y = kwargs.pop('y', 0.98)\n740 \n741         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:\n742             kwargs['horizontalalignment'] = 'center'\n743         if 'verticalalignment' not in kwargs and 'va' not in kwargs:\n744             kwargs['verticalalignment'] = 'top'\n745 \n746         if 'fontproperties' not in kwargs:\n747             if 'fontsize' not in kwargs and 'size' not in kwargs:\n748                 kwargs['size'] = rcParams['figure.titlesize']\n749             if 'fontweight' not in kwargs and 'weight' not in kwargs:\n750                 kwargs['weight'] = rcParams['figure.titleweight']\n751 \n752         sup = self.text(x, y, t, **kwargs)\n753         if self._suptitle is not None:\n754             self._suptitle.set_text(t)\n755             self._suptitle.set_position((x, y))\n756             self._suptitle.update_from(sup)\n757             sup.remove()\n758         else:\n759             self._suptitle = sup\n760             self._suptitle._layoutbox = None\n761             if self._layoutbox is not None and not manual_position:\n762                 w_pad, h_pad, wspace, hspace =  \\\n763                         self.get_constrained_layout_pads(relative=True)\n764                 figlb = self._layoutbox\n765                 self._suptitle._layoutbox = layoutbox.LayoutBox(\n766                         parent=figlb, artist=self._suptitle,\n767                         name=figlb.name+'.suptitle')\n768                 # stack the suptitle on top of all the children.\n769                 # Some day this should be on top of all the children in the\n770                 # gridspec only.\n771                 for child in figlb.children:\n772                     if child is not self._suptitle._layoutbox:\n773                         layoutbox.vstack([self._suptitle._layoutbox,\n774                                           child],\n775                                          padding=h_pad*2., strength='required')\n776         self.stale = True\n777         return self._suptitle\n778 \n779     def set_canvas(self, canvas):\n780         \"\"\"\n781         Set the canvas that contains the figure\n782 \n783         Parameters\n784         ----------\n785         canvas : FigureCanvas\n786         \"\"\"\n787         self.canvas = canvas\n788 \n789     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,\n790                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):\n791         \"\"\"\n792         Add a non-resampled image to the figure.\n793 \n794         The image is attached to the lower or upper left corner depending on\n795         *origin*.\n796 \n797         Parameters\n798         ----------\n799         X\n800             The image data. This is an array of one of the following shapes:\n801 \n802             - MxN: luminance (grayscale) values\n803             - MxNx3: RGB values\n804             - MxNx4: RGBA values\n805 \n806         xo, yo : int\n807             The *x*/*y* image offset in pixels.\n808 \n809         alpha : None or float\n810             The alpha blending value.\n811 \n812         norm : :class:`matplotlib.colors.Normalize`\n813             A :class:`.Normalize` instance to map the luminance to the\n814             interval [0, 1].\n815 \n816         cmap : str or :class:`matplotlib.colors.Colormap`\n817             The colormap to use. Default: :rc:`image.cmap`.\n818 \n819         vmin, vmax : scalar\n820             If *norm* is not given, these values set the data limits for the\n821             colormap.\n822 \n823         origin : {'upper', 'lower'}\n824             Indicates where the [0, 0] index of the array is in the upper left\n825             or lower left corner of the axes. Defaults to :rc:`image.origin`.\n826 \n827         resize : bool\n828             If *True*, resize the figure to match the given image size.\n829 \n830         Returns\n831         -------\n832         :class:`matplotlib.image.FigureImage`\n833 \n834         Other Parameters\n835         ----------------\n836         **kwargs\n837             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.\n838 \n839         Notes\n840         -----\n841         figimage complements the axes image\n842         (:meth:`~matplotlib.axes.Axes.imshow`) which will be resampled\n843         to fit the current axes.  If you want a resampled image to\n844         fill the entire figure, you can define an\n845         :class:`~matplotlib.axes.Axes` with extent [0,0,1,1].\n846 \n847 \n848         Examples::\n849 \n850             f = plt.figure()\n851             nx = int(f.get_figwidth() * f.dpi)\n852             ny = int(f.get_figheight() * f.dpi)\n853             data = np.random.random((ny, nx))\n854             f.figimage(data)\n855             plt.show()\n856 \n857         \"\"\"\n858         if resize:\n859             dpi = self.get_dpi()\n860             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]\n861             self.set_size_inches(figsize, forward=True)\n862 \n863         im = mimage.FigureImage(self, cmap, norm, xo, yo, origin, **kwargs)\n864         im.stale_callback = _stale_figure_callback\n865 \n866         im.set_array(X)\n867         im.set_alpha(alpha)\n868         if norm is None:\n869             im.set_clim(vmin, vmax)\n870         self.images.append(im)\n871         im._remove_method = self.images.remove\n872         self.stale = True\n873         return im\n874 \n875     def set_size_inches(self, w, h=None, forward=True):\n876         \"\"\"Set the figure size in inches.\n877 \n878         Call signatures::\n879 \n880              fig.set_size_inches(w, h)  # OR\n881              fig.set_size_inches((w, h))\n882 \n883         optional kwarg *forward=True* will cause the canvas size to be\n884         automatically updated; e.g., you can resize the figure window\n885         from the shell\n886 \n887         ACCEPTS: a (w, h) tuple with w, h in inches\n888 \n889         See Also\n890         --------\n891         matplotlib.Figure.get_size_inches\n892         \"\"\"\n893 \n894         # the width and height have been passed in as a tuple to the first\n895         # argument, so unpack them\n896         if h is None:\n897             w, h = w\n898         if not all(np.isfinite(_) for _ in (w, h)):\n899             raise ValueError('figure size must be finite not '\n900                              '({}, {})'.format(w, h))\n901         self.bbox_inches.p1 = w, h\n902 \n903         if forward:\n904             canvas = getattr(self, 'canvas')\n905             if canvas is not None:\n906                 ratio = getattr(self.canvas, '_dpi_ratio', 1)\n907                 dpival = self.dpi / ratio\n908                 canvasw = w * dpival\n909                 canvash = h * dpival\n910                 manager = getattr(self.canvas, 'manager', None)\n911                 if manager is not None:\n912                     manager.resize(int(canvasw), int(canvash))\n913         self.stale = True\n914 \n915     def get_size_inches(self):\n916         \"\"\"\n917         Returns the current size of the figure in inches.\n918 \n919         Returns\n920         -------\n921         size : ndarray\n922            The size (width, height) of the figure in inches.\n923 \n924         See Also\n925         --------\n926         matplotlib.Figure.set_size_inches\n927         \"\"\"\n928         return np.array(self.bbox_inches.p1)\n929 \n930     def get_edgecolor(self):\n931         \"\"\"Get the edge color of the Figure rectangle.\"\"\"\n932         return self.patch.get_edgecolor()\n933 \n934     def get_facecolor(self):\n935         \"\"\"Get the face color of the Figure rectangle.\"\"\"\n936         return self.patch.get_facecolor()\n937 \n938     def get_figwidth(self):\n939         \"\"\"Return the figure width as a float.\"\"\"\n940         return self.bbox_inches.width\n941 \n942     def get_figheight(self):\n943         \"\"\"Return the figure height as a float.\"\"\"\n944         return self.bbox_inches.height\n945 \n946     def get_dpi(self):\n947         \"\"\"Return the resolution in dots per inch as a float.\"\"\"\n948         return self.dpi\n949 \n950     def get_frameon(self):\n951         \"\"\"\n952         Return the figure's background patch visibility, i.e.\n953         whether the figure background will be drawn. Equivalent to\n954         ``Figure.patch.get_visible()``.\n955         \"\"\"\n956         return self.patch.get_visible()\n957 \n958     def set_edgecolor(self, color):\n959         \"\"\"\n960         Set the edge color of the Figure rectangle.\n961 \n962         Parameters\n963         ----------\n964         color : color\n965         \"\"\"\n966         self.patch.set_edgecolor(color)\n967 \n968     def set_facecolor(self, color):\n969         \"\"\"\n970         Set the face color of the Figure rectangle.\n971 \n972         Parameters\n973         ----------\n974         color : color\n975         \"\"\"\n976         self.patch.set_facecolor(color)\n977 \n978     def set_dpi(self, val):\n979         \"\"\"\n980         Set the resolution of the figure in dots-per-inch.\n981 \n982         Parameters\n983         ----------\n984         val : float\n985         \"\"\"\n986         self.dpi = val\n987         self.stale = True\n988 \n989     def set_figwidth(self, val, forward=True):\n990         \"\"\"\n991         Set the width of the figure in inches.\n992 \n993         Parameters\n994         ----------\n995         val : float\n996         forward : bool\n997         \"\"\"\n998         self.set_size_inches(val, self.get_figheight(), forward=forward)\n999 \n1000     def set_figheight(self, val, forward=True):\n1001         \"\"\"\n1002         Set the height of the figure in inches.\n1003 \n1004         Parameters\n1005         ----------\n1006         val : float\n1007         forward : bool\n1008         \"\"\"\n1009         self.set_size_inches(self.get_figwidth(), val, forward=forward)\n1010 \n1011     def set_frameon(self, b):\n1012         \"\"\"\n1013         Set the figure's background patch visibility, i.e.\n1014         whether the figure background will be drawn. Equivalent to\n1015         ``Figure.patch.set_visible()``.\n1016 \n1017         Parameters\n1018         ----------\n1019         b : bool\n1020         \"\"\"\n1021         self.patch.set_visible(b)\n1022         self.stale = True\n1023 \n1024     frameon = property(get_frameon, set_frameon)\n1025 \n1026     def delaxes(self, ax):\n1027         \"\"\"\n1028         Remove the `~matplotlib.axes.Axes` *ax* from the figure and update the\n1029         current axes.\n1030         \"\"\"\n1031         self._axstack.remove(ax)\n1032         for func in self._axobservers:\n1033             func(self)\n1034         self.stale = True\n1035 \n1036     def add_artist(self, artist, clip=False):\n1037         \"\"\"\n1038         Add any :class:`~matplotlib.artist.Artist` to the figure.\n1039 \n1040         Usually artists are added to axes objects using\n1041         :meth:`matplotlib.axes.Axes.add_artist`, but use this method in the\n1042         rare cases that adding directly to the figure is necessary.\n1043 \n1044         Parameters\n1045         ----------\n1046         artist : `~matplotlib.artist.Artist`\n1047             The artist to add to the figure. If the added artist has no\n1048             transform previously set, its transform will be set to\n1049             ``figure.transFigure``.\n1050         clip : bool, optional, default ``False``\n1051             An optional parameter ``clip`` determines whether the added artist\n1052             should be clipped by the figure patch. Default is *False*,\n1053             i.e. no clipping.\n1054 \n1055         Returns\n1056         -------\n1057         artist : The added `~matplotlib.artist.Artist`\n1058         \"\"\"\n1059         artist.set_figure(self)\n1060         self.artists.append(artist)\n1061         artist._remove_method = self.artists.remove\n1062 \n1063         if not artist.is_transform_set():\n1064             artist.set_transform(self.transFigure)\n1065 \n1066         if clip:\n1067             artist.set_clip_path(self.patch)\n1068 \n1069         self.stale = True\n1070         return artist\n1071 \n1072     def _make_key(self, *args, **kwargs):\n1073         \"\"\"Make a hashable key out of args and kwargs.\"\"\"\n1074 \n1075         def fixitems(items):\n1076             # items may have arrays and lists in them, so convert them\n1077             # to tuples for the key\n1078             ret = []\n1079             for k, v in items:\n1080                 # some objects can define __getitem__ without being\n1081                 # iterable and in those cases the conversion to tuples\n1082                 # will fail. So instead of using the np.iterable(v) function\n1083                 # we simply try and convert to a tuple, and proceed if not.\n1084                 try:\n1085                     v = tuple(v)\n1086                 except Exception:\n1087                     pass\n1088                 ret.append((k, v))\n1089             return tuple(ret)\n1090 \n1091         def fixlist(args):\n1092             ret = []\n1093             for a in args:\n1094                 if np.iterable(a):\n1095                     a = tuple(a)\n1096                 ret.append(a)\n1097             return tuple(ret)\n1098 \n1099         key = fixlist(args), fixitems(kwargs.items())\n1100         return key\n1101 \n1102     def _process_projection_requirements(\n1103             self, *args, polar=False, projection=None, **kwargs):\n1104         \"\"\"\n1105         Handle the args/kwargs to add_axes/add_subplot/gca, returning::\n1106 \n1107             (axes_proj_class, proj_class_kwargs, proj_stack_key)\n1108 \n1109         which can be used for new axes initialization/identification.\n1110         \"\"\"\n1111         if polar:\n1112             if projection is not None and projection != 'polar':\n1113                 raise ValueError(\n1114                     \"polar=True, yet projection=%r. \"\n1115                     \"Only one of these arguments should be supplied.\" %\n1116                     projection)\n1117             projection = 'polar'\n1118 \n1119         if isinstance(projection, str) or projection is None:\n1120             projection_class = projections.get_projection_class(projection)\n1121         elif hasattr(projection, '_as_mpl_axes'):\n1122             projection_class, extra_kwargs = projection._as_mpl_axes()\n1123             kwargs.update(**extra_kwargs)\n1124         else:\n1125             raise TypeError('projection must be a string, None or implement a '\n1126                             '_as_mpl_axes method. Got %r' % projection)\n1127 \n1128         # Make the key without projection kwargs, this is used as a unique\n1129         # lookup for axes instances\n1130         key = self._make_key(*args, **kwargs)\n1131 \n1132         return projection_class, kwargs, key\n1133 \n1134     @docstring.dedent_interpd\n1135     def add_axes(self, *args, **kwargs):\n1136         \"\"\"\n1137         Add an axes to the figure.\n1138 \n1139         Call signatures::\n1140 \n1141             add_axes(rect, projection=None, polar=False, **kwargs)\n1142             add_axes(ax)\n1143 \n1144         Parameters\n1145         ----------\n1146 \n1147         rect : sequence of float\n1148             The dimensions [left, bottom, width, height] of the new axes. All\n1149             quantities are in fractions of figure width and height.\n1150 \n1151         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1152 'polar', 'rectilinear', str}, optional\n1153             The projection type of the `~.axes.Axes`. *str* is the name of\n1154             a custom projection, see `~matplotlib.projections`. The default\n1155             None results in a 'rectilinear' projection.\n1156 \n1157         polar : boolean, optional\n1158             If True, equivalent to projection='polar'.\n1159 \n1160         sharex, sharey : `~.axes.Axes`, optional\n1161             Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n1162             The axis will have the same limits, ticks, and scale as the axis\n1163             of the shared axes.\n1164 \n1165         label : str\n1166             A label for the returned axes.\n1167 \n1168         Other Parameters\n1169         ----------------\n1170         **kwargs\n1171             This method also takes the keyword arguments for\n1172             the returned axes class. The keyword arguments for the\n1173             rectilinear axes class `~.axes.Axes` can be found in\n1174             the following table but there might also be other keyword\n1175             arguments if another projection is used, see the actual axes\n1176             class.\n1177             %(Axes)s\n1178 \n1179         Returns\n1180         -------\n1181         axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)\n1182             The returned axes class depends on the projection used. It is\n1183             `~.axes.Axes` if rectilinear projection are used and\n1184             `.projections.polar.PolarAxes` if polar projection\n1185             are used.\n1186 \n1187         Notes\n1188         -----\n1189         If the figure already has an axes with key (*args*,\n1190         *kwargs*) then it will simply make that axes current and\n1191         return it.  This behavior is deprecated. Meanwhile, if you do\n1192         not want this behavior (i.e., you want to force the creation of a\n1193         new axes), you must use a unique set of args and kwargs.  The axes\n1194         *label* attribute has been exposed for this purpose: if you want\n1195         two axes that are otherwise identical to be added to the figure,\n1196         make sure you give them unique labels.\n1197 \n1198         In rare circumstances, `.add_axes` may be called with a single\n1199         argument, a axes instance already created in the present figure but\n1200         not in the figure's list of axes.\n1201 \n1202         See Also\n1203         --------\n1204         .Figure.add_subplot\n1205         .pyplot.subplot\n1206         .pyplot.axes\n1207         .Figure.subplots\n1208         .pyplot.subplots\n1209 \n1210         Examples\n1211         --------\n1212         Some simple examples::\n1213 \n1214             rect = l, b, w, h\n1215             fig = plt.figure()\n1216             fig.add_axes(rect,label=label1)\n1217             fig.add_axes(rect,label=label2)\n1218             fig.add_axes(rect, frameon=False, facecolor='g')\n1219             fig.add_axes(rect, polar=True)\n1220             ax=fig.add_axes(rect, projection='polar')\n1221             fig.delaxes(ax)\n1222             fig.add_axes(ax)\n1223         \"\"\"\n1224 \n1225         if not len(args):\n1226             return\n1227 \n1228         # shortcut the projection \"key\" modifications later on, if an axes\n1229         # with the exact args/kwargs exists, return it immediately.\n1230         key = self._make_key(*args, **kwargs)\n1231         ax = self._axstack.get(key)\n1232         if ax is not None:\n1233             self.sca(ax)\n1234             return ax\n1235 \n1236         if isinstance(args[0], Axes):\n1237             a = args[0]\n1238             if a.get_figure() is not self:\n1239                 raise ValueError(\n1240                     \"The Axes must have been created in the present figure\")\n1241         else:\n1242             rect = args[0]\n1243             if not np.isfinite(rect).all():\n1244                 raise ValueError('all entries in rect must be finite '\n1245                                  'not {}'.format(rect))\n1246             projection_class, kwargs, key = \\\n1247                 self._process_projection_requirements(*args, **kwargs)\n1248 \n1249             # check that an axes of this type doesn't already exist, if it\n1250             # does, set it as active and return it\n1251             ax = self._axstack.get(key)\n1252             if isinstance(ax, projection_class):\n1253                 self.sca(ax)\n1254                 return ax\n1255 \n1256             # create the new axes using the axes class given\n1257             a = projection_class(self, rect, **kwargs)\n1258 \n1259         return self._add_axes_internal(key, a)\n1260 \n1261     @docstring.dedent_interpd\n1262     def add_subplot(self, *args, **kwargs):\n1263         \"\"\"\n1264         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.\n1265 \n1266         Call signatures::\n1267 \n1268            add_subplot(nrows, ncols, index, **kwargs)\n1269            add_subplot(pos, **kwargs)\n1270            add_subplot(ax)\n1271 \n1272         Parameters\n1273         ----------\n1274         *args\n1275             Either a 3-digit integer or three separate integers\n1276             describing the position of the subplot. If the three\n1277             integers are *nrows*, *ncols*, and *index* in order, the\n1278             subplot will take the *index* position on a grid with *nrows*\n1279             rows and *ncols* columns. *index* starts at 1 in the upper left\n1280             corner and increases to the right.\n1281 \n1282             *pos* is a three digit integer, where the first digit is the\n1283             number of rows, the second the number of columns, and the third\n1284             the index of the subplot. i.e. fig.add_subplot(235) is the same as\n1285             fig.add_subplot(2, 3, 5). Note that all integers must be less than\n1286             10 for this form to work.\n1287 \n1288         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n1289 'polar', 'rectilinear', str}, optional\n1290             The projection type of the subplot (`~.axes.Axes`). *str* is the\n1291             name of a custom projection, see `~matplotlib.projections`. The\n1292             default None results in a 'rectilinear' projection.\n1293 \n1294         polar : boolean, optional\n1295             If True, equivalent to projection='polar'.\n1296 \n1297         sharex, sharey : `~.axes.Axes`, optional\n1298             Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n1299             The axis will have the same limits, ticks, and scale as the axis\n1300             of the shared axes.\n1301 \n1302         label : str\n1303             A label for the returned axes.\n1304 \n1305         Other Parameters\n1306         ----------------\n1307         **kwargs\n1308             This method also takes the keyword arguments for\n1309             the returned axes base class. The keyword arguments for the\n1310             rectilinear base class `~.axes.Axes` can be found in\n1311             the following table but there might also be other keyword\n1312             arguments if another projection is used.\n1313             %(Axes)s\n1314 \n1315         Returns\n1316         -------\n1317         axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a \\\n1318                subclass of `~.axes.Axes`)\n1319 \n1320             The axes of the subplot. The returned axes base class depends on\n1321             the projection used. It is `~.axes.Axes` if rectilinear projection\n1322             are used and `.projections.polar.PolarAxes` if polar projection\n1323             are used. The returned axes is then a subplot subclass of the\n1324             base class.\n1325 \n1326         Notes\n1327         -----\n1328         If the figure already has a subplot with key (*args*,\n1329         *kwargs*) then it will simply make that subplot current and\n1330         return it.  This behavior is deprecated. Meanwhile, if you do\n1331         not want this behavior (i.e., you want to force the creation of a\n1332         new subplot), you must use a unique set of args and kwargs.  The axes\n1333         *label* attribute has been exposed for this purpose: if you want\n1334         two subplots that are otherwise identical to be added to the figure,\n1335         make sure you give them unique labels.\n1336 \n1337         In rare circumstances, `.add_subplot` may be called with a single\n1338         argument, a subplot axes instance already created in the\n1339         present figure but not in the figure's list of axes.\n1340 \n1341         See Also\n1342         --------\n1343         .Figure.add_axes\n1344         .pyplot.subplot\n1345         .pyplot.axes\n1346         .Figure.subplots\n1347         .pyplot.subplots\n1348 \n1349         Examples\n1350         --------\n1351         ::\n1352 \n1353             fig = plt.figure()\n1354             fig.add_subplot(221)\n1355 \n1356             # equivalent but more general\n1357             ax1 = fig.add_subplot(2, 2, 1)\n1358 \n1359             # add a subplot with no frame\n1360             ax2 = fig.add_subplot(222, frameon=False)\n1361 \n1362             # add a polar subplot\n1363             fig.add_subplot(223, projection='polar')\n1364 \n1365             # add a red subplot that share the x-axis with ax1\n1366             fig.add_subplot(224, sharex=ax1, facecolor='red')\n1367 \n1368             #delete x2 from the figure\n1369             fig.delaxes(ax2)\n1370 \n1371             #add x2 to the figure again\n1372             fig.add_subplot(ax2)\n1373         \"\"\"\n1374         if not len(args):\n1375             args = (1, 1, 1)\n1376 \n1377         if len(args) == 1 and isinstance(args[0], Integral):\n1378             if not 100 <= args[0] <= 999:\n1379                 raise ValueError(\"Integer subplot specification must be a \"\n1380                                  \"three-digit number, not {}\".format(args[0]))\n1381             args = tuple(map(int, str(args[0])))\n1382 \n1383         if isinstance(args[0], SubplotBase):\n1384 \n1385             a = args[0]\n1386             if a.get_figure() is not self:\n1387                 raise ValueError(\n1388                     \"The Subplot must have been created in the present figure\")\n1389             # make a key for the subplot (which includes the axes object id\n1390             # in the hash)\n1391             key = self._make_key(*args, **kwargs)\n1392         else:\n1393             projection_class, kwargs, key = \\\n1394                 self._process_projection_requirements(*args, **kwargs)\n1395 \n1396             # try to find the axes with this key in the stack\n1397             ax = self._axstack.get(key)\n1398 \n1399             if ax is not None:\n1400                 if isinstance(ax, projection_class):\n1401                     # the axes already existed, so set it as active & return\n1402                     self.sca(ax)\n1403                     return ax\n1404                 else:\n1405                     # Undocumented convenience behavior:\n1406                     # subplot(111); subplot(111, projection='polar')\n1407                     # will replace the first with the second.\n1408                     # Without this, add_subplot would be simpler and\n1409                     # more similar to add_axes.\n1410                     self._axstack.remove(ax)\n1411 \n1412             a = subplot_class_factory(projection_class)(self, *args, **kwargs)\n1413 \n1414         return self._add_axes_internal(key, a)\n1415 \n1416     def _add_axes_internal(self, key, ax):\n1417         \"\"\"Private helper for `add_axes` and `add_subplot`.\"\"\"\n1418         self._axstack.add(key, ax)\n1419         self.sca(ax)\n1420         ax._remove_method = self._remove_ax\n1421         self.stale = True\n1422         ax.stale_callback = _stale_figure_callback\n1423         return ax\n1424 \n1425     def subplots(self, nrows=1, ncols=1, sharex=False, sharey=False,\n1426                  squeeze=True, subplot_kw=None, gridspec_kw=None):\n1427         \"\"\"\n1428         Add a set of subplots to this figure.\n1429 \n1430         This utility wrapper makes it convenient to create common layouts of\n1431         subplots in a single call.\n1432 \n1433         Parameters\n1434         ----------\n1435         nrows, ncols : int, optional, default: 1\n1436             Number of rows/columns of the subplot grid.\n1437 \n1438         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n1439             Controls sharing of properties among x (`sharex`) or y (`sharey`)\n1440             axes:\n1441 \n1442                 - True or 'all': x- or y-axis will be shared among all\n1443                   subplots.\n1444                 - False or 'none': each subplot x- or y-axis will be\n1445                   independent.\n1446                 - 'row': each subplot row will share an x- or y-axis.\n1447                 - 'col': each subplot column will share an x- or y-axis.\n1448 \n1449             When subplots have a shared x-axis along a column, only the x tick\n1450             labels of the bottom subplot are created. Similarly, when subplots\n1451             have a shared y-axis along a row, only the y tick labels of the\n1452             first column subplot are created. To later turn other subplots'\n1453             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.\n1454 \n1455         squeeze : bool, optional, default: True\n1456             - If True, extra dimensions are squeezed out from the returned\n1457               array of Axes:\n1458 \n1459                 - if only one subplot is constructed (nrows=ncols=1), the\n1460                   resulting single Axes object is returned as a scalar.\n1461                 - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n1462                   object array of Axes objects.\n1463                 - for NxM, subplots with N>1 and M>1 are returned\n1464                   as a 2D array.\n1465 \n1466             - If False, no squeezing at all is done: the returned Axes object\n1467               is always a 2D array containing Axes instances, even if it ends\n1468               up being 1x1.\n1469 \n1470         subplot_kw : dict, optional\n1471             Dict with keywords passed to the\n1472             :meth:`~matplotlib.figure.Figure.add_subplot` call used to create\n1473             each subplot.\n1474 \n1475         gridspec_kw : dict, optional\n1476             Dict with keywords passed to the\n1477             `~matplotlib.gridspec.GridSpec` constructor used to create\n1478             the grid the subplots are placed on.\n1479 \n1480         Returns\n1481         -------\n1482         ax : `~.axes.Axes` object or array of Axes objects.\n1483             *ax* can be either a single `~matplotlib.axes.Axes` object or\n1484             an array of Axes objects if more than one subplot was created. The\n1485             dimensions of the resulting array can be controlled with the\n1486             squeeze keyword, see above.\n1487 \n1488         Examples\n1489         --------\n1490         ::\n1491 \n1492             # First create some toy data:\n1493             x = np.linspace(0, 2*np.pi, 400)\n1494             y = np.sin(x**2)\n1495 \n1496             # Create a figure\n1497             plt.figure()\n1498 \n1499             # Creates a subplot\n1500             ax = fig.subplots()\n1501             ax.plot(x, y)\n1502             ax.set_title('Simple plot')\n1503 \n1504             # Creates two subplots and unpacks the output array immediately\n1505             ax1, ax2 = fig.subplots(1, 2, sharey=True)\n1506             ax1.plot(x, y)\n1507             ax1.set_title('Sharing Y axis')\n1508             ax2.scatter(x, y)\n1509 \n1510             # Creates four polar axes, and accesses them through the\n1511             # returned array\n1512             axes = fig.subplots(2, 2, subplot_kw=dict(polar=True))\n1513             axes[0, 0].plot(x, y)\n1514             axes[1, 1].scatter(x, y)\n1515 \n1516             # Share a X axis with each column of subplots\n1517             fig.subplots(2, 2, sharex='col')\n1518 \n1519             # Share a Y axis with each row of subplots\n1520             fig.subplots(2, 2, sharey='row')\n1521 \n1522             # Share both X and Y axes with all subplots\n1523             fig.subplots(2, 2, sharex='all', sharey='all')\n1524 \n1525             # Note that this is the same as\n1526             fig.subplots(2, 2, sharex=True, sharey=True)\n1527 \n1528             See Also\n1529             --------\n1530             .pyplot.subplots\n1531             .Figure.add_subplot\n1532             .pyplot.subplot\n1533             \"\"\"\n1534 \n1535         if isinstance(sharex, bool):\n1536             sharex = \"all\" if sharex else \"none\"\n1537         if isinstance(sharey, bool):\n1538             sharey = \"all\" if sharey else \"none\"\n1539         # This check was added because it is very easy to type\n1540         # `subplots(1, 2, 1)` when `subplot(1, 2, 1)` was intended.\n1541         # In most cases, no error will ever occur, but mysterious behavior\n1542         # will result because what was intended to be the subplot index is\n1543         # instead treated as a bool for sharex.\n1544         if isinstance(sharex, Integral):\n1545             cbook._warn_external(\n1546                 \"sharex argument to subplots() was an integer.  Did you \"\n1547                 \"intend to use subplot() (without 's')?\")\n1548         cbook._check_in_list([\"all\", \"row\", \"col\", \"none\"],\n1549                              sharex=sharex, sharey=sharey)\n1550         if subplot_kw is None:\n1551             subplot_kw = {}\n1552         if gridspec_kw is None:\n1553             gridspec_kw = {}\n1554         # don't mutate kwargs passed by user...\n1555         subplot_kw = subplot_kw.copy()\n1556         gridspec_kw = gridspec_kw.copy()\n1557 \n1558         if self.get_constrained_layout():\n1559             gs = GridSpec(nrows, ncols, figure=self, **gridspec_kw)\n1560         else:\n1561             # this should turn constrained_layout off if we don't want it\n1562             gs = GridSpec(nrows, ncols, figure=None, **gridspec_kw)\n1563         self._gridspecs.append(gs)\n1564 \n1565         # Create array to hold all axes.\n1566         axarr = np.empty((nrows, ncols), dtype=object)\n1567         for row in range(nrows):\n1568             for col in range(ncols):\n1569                 shared_with = {\"none\": None, \"all\": axarr[0, 0],\n1570                                \"row\": axarr[row, 0], \"col\": axarr[0, col]}\n1571                 subplot_kw[\"sharex\"] = shared_with[sharex]\n1572                 subplot_kw[\"sharey\"] = shared_with[sharey]\n1573                 axarr[row, col] = self.add_subplot(gs[row, col], **subplot_kw)\n1574 \n1575         # turn off redundant tick labeling\n1576         if sharex in [\"col\", \"all\"]:\n1577             # turn off all but the bottom row\n1578             for ax in axarr[:-1, :].flat:\n1579                 ax.xaxis.set_tick_params(which='both',\n1580                                          labelbottom=False, labeltop=False)\n1581                 ax.xaxis.offsetText.set_visible(False)\n1582         if sharey in [\"row\", \"all\"]:\n1583             # turn off all but the first column\n1584             for ax in axarr[:, 1:].flat:\n1585                 ax.yaxis.set_tick_params(which='both',\n1586                                          labelleft=False, labelright=False)\n1587                 ax.yaxis.offsetText.set_visible(False)\n1588 \n1589         if squeeze:\n1590             # Discarding unneeded dimensions that equal 1.  If we only have one\n1591             # subplot, just return it instead of a 1-element array.\n1592             return axarr.item() if axarr.size == 1 else axarr.squeeze()\n1593         else:\n1594             # Returned axis array will be always 2-d, even if nrows=ncols=1.\n1595             return axarr\n1596 \n1597     def _remove_ax(self, ax):\n1598         def _reset_loc_form(axis):\n1599             axis.set_major_formatter(axis.get_major_formatter())\n1600             axis.set_major_locator(axis.get_major_locator())\n1601             axis.set_minor_formatter(axis.get_minor_formatter())\n1602             axis.set_minor_locator(axis.get_minor_locator())\n1603 \n1604         def _break_share_link(ax, grouper):\n1605             siblings = grouper.get_siblings(ax)\n1606             if len(siblings) > 1:\n1607                 grouper.remove(ax)\n1608                 for last_ax in siblings:\n1609                     if ax is not last_ax:\n1610                         return last_ax\n1611             return None\n1612 \n1613         self.delaxes(ax)\n1614         last_ax = _break_share_link(ax, ax._shared_y_axes)\n1615         if last_ax is not None:\n1616             _reset_loc_form(last_ax.yaxis)\n1617 \n1618         last_ax = _break_share_link(ax, ax._shared_x_axes)\n1619         if last_ax is not None:\n1620             _reset_loc_form(last_ax.xaxis)\n1621 \n1622     def clf(self, keep_observers=False):\n1623         \"\"\"\n1624         Clear the figure.\n1625 \n1626         Set *keep_observers* to True if, for example,\n1627         a gui widget is tracking the axes in the figure.\n1628         \"\"\"\n1629         self.suppressComposite = None\n1630         self.callbacks = cbook.CallbackRegistry()\n1631 \n1632         for ax in tuple(self.axes):  # Iterate over the copy.\n1633             ax.cla()\n1634             self.delaxes(ax)         # removes ax from self._axstack\n1635 \n1636         toolbar = getattr(self.canvas, 'toolbar', None)\n1637         if toolbar is not None:\n1638             toolbar.update()\n1639         self._axstack.clear()\n1640         self.artists = []\n1641         self.lines = []\n1642         self.patches = []\n1643         self.texts = []\n1644         self.images = []\n1645         self.legends = []\n1646         if not keep_observers:\n1647             self._axobservers = []\n1648         self._suptitle = None\n1649         if self.get_constrained_layout():\n1650             layoutbox.nonetree(self._layoutbox)\n1651         self.stale = True\n1652 \n1653     def clear(self, keep_observers=False):\n1654         \"\"\"\n1655         Clear the figure -- synonym for :meth:`clf`.\n1656         \"\"\"\n1657         self.clf(keep_observers=keep_observers)\n1658 \n1659     @allow_rasterization\n1660     def draw(self, renderer):\n1661         \"\"\"\n1662         Render the figure using :class:`matplotlib.backend_bases.RendererBase`\n1663         instance *renderer*.\n1664         \"\"\"\n1665 \n1666         # draw the figure bounding box, perhaps none for white figure\n1667         if not self.get_visible():\n1668             return\n1669 \n1670         artists = self.get_children()\n1671         artists.remove(self.patch)\n1672         artists = sorted(\n1673             (artist for artist in artists if not artist.get_animated()),\n1674             key=lambda artist: artist.get_zorder())\n1675 \n1676         for ax in self.axes:\n1677             locator = ax.get_axes_locator()\n1678             if locator:\n1679                 pos = locator(ax, renderer)\n1680                 ax.apply_aspect(pos)\n1681             else:\n1682                 ax.apply_aspect()\n1683 \n1684             for child in ax.get_children():\n1685                 if hasattr(child, 'apply_aspect'):\n1686                     locator = child.get_axes_locator()\n1687                     if locator:\n1688                         pos = locator(child, renderer)\n1689                         child.apply_aspect(pos)\n1690                     else:\n1691                         child.apply_aspect()\n1692 \n1693         try:\n1694             renderer.open_group('figure')\n1695             if self.get_constrained_layout() and self.axes:\n1696                 self.execute_constrained_layout(renderer)\n1697             if self.get_tight_layout() and self.axes:\n1698                 try:\n1699                     self.tight_layout(renderer,\n1700                                       **self._tight_parameters)\n1701                 except ValueError:\n1702                     pass\n1703                     # ValueError can occur when resizing a window.\n1704 \n1705             self.patch.draw(renderer)\n1706             mimage._draw_list_compositing_images(\n1707                 renderer, self, artists, self.suppressComposite)\n1708 \n1709             renderer.close_group('figure')\n1710         finally:\n1711             self.stale = False\n1712 \n1713         self._cachedRenderer = renderer\n1714         self.canvas.draw_event(renderer)\n1715 \n1716     def draw_artist(self, a):\n1717         \"\"\"\n1718         Draw :class:`matplotlib.artist.Artist` instance *a* only.\n1719         This is available only after the figure is drawn.\n1720         \"\"\"\n1721         if self._cachedRenderer is None:\n1722             raise AttributeError(\"draw_artist can only be used after an \"\n1723                                  \"initial draw which caches the renderer\")\n1724         a.draw(self._cachedRenderer)\n1725 \n1726     def get_axes(self):\n1727         \"\"\"\n1728         Return a list of axes in the Figure. You can access and modify the\n1729         axes in the Figure through this list.\n1730 \n1731         Do not modify the list itself. Instead, use `~Figure.add_axes`,\n1732         `~.Figure.subplot` or `~.Figure.delaxes` to add or remove an axes.\n1733 \n1734         Note: This is equivalent to the property `~.Figure.axes`.\n1735         \"\"\"\n1736         return self.axes\n1737 \n1738     # Note: in the docstring below, the newlines in the examples after the\n1739     # calls to legend() allow replacing it with figlegend() to generate the\n1740     # docstring of pyplot.figlegend.\n1741 \n1742     @docstring.dedent_interpd\n1743     def legend(self, *args, **kwargs):\n1744         \"\"\"\n1745         Place a legend on the figure.\n1746 \n1747         To make a legend from existing artists on every axes::\n1748 \n1749           legend()\n1750 \n1751         To make a legend for a list of lines and labels::\n1752 \n1753           legend(\n1754               (line1, line2, line3),\n1755               ('label1', 'label2', 'label3'),\n1756               loc='upper right')\n1757 \n1758         These can also be specified by keyword::\n1759 \n1760           legend(\n1761               handles=(line1, line2, line3),\n1762               labels=('label1', 'label2', 'label3'),\n1763               loc='upper right')\n1764 \n1765         Parameters\n1766         ----------\n1767 \n1768         handles : sequence of `.Artist`, optional\n1769             A list of Artists (lines, patches) to be added to the legend.\n1770             Use this together with *labels*, if you need full control on what\n1771             is shown in the legend and the automatic mechanism described above\n1772             is not sufficient.\n1773 \n1774             The length of handles and labels should be the same in this\n1775             case. If they are not, they are truncated to the smaller length.\n1776 \n1777         labels : sequence of strings, optional\n1778             A list of labels to show next to the artists.\n1779             Use this together with *handles*, if you need full control on what\n1780             is shown in the legend and the automatic mechanism described above\n1781             is not sufficient.\n1782 \n1783         Other Parameters\n1784         ----------------\n1785 \n1786         %(_legend_kw_doc)s\n1787 \n1788         Returns\n1789         -------\n1790         :class:`matplotlib.legend.Legend` instance\n1791 \n1792         Notes\n1793         -----\n1794         Not all kinds of artist are supported by the legend command. See\n1795         :doc:`/tutorials/intermediate/legend_guide` for details.\n1796         \"\"\"\n1797 \n1798         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(\n1799                 self.axes,\n1800                 *args,\n1801                 **kwargs)\n1802         # check for third arg\n1803         if len(extra_args):\n1804             # cbook.warn_deprecated(\n1805             #     \"2.1\",\n1806             #     message=\"Figure.legend will accept no more than two \"\n1807             #     \"positional arguments in the future.  Use \"\n1808             #     \"'fig.legend(handles, labels, loc=location)' \"\n1809             #     \"instead.\")\n1810             # kwargs['loc'] = extra_args[0]\n1811             # extra_args = extra_args[1:]\n1812             pass\n1813         l = mlegend.Legend(self, handles, labels, *extra_args, **kwargs)\n1814         self.legends.append(l)\n1815         l._remove_method = self.legends.remove\n1816         self.stale = True\n1817         return l\n1818 \n1819     @cbook._delete_parameter(\"3.1\", \"withdash\")\n1820     @docstring.dedent_interpd\n1821     def text(self, x, y, s, fontdict=None, withdash=False, **kwargs):\n1822         \"\"\"\n1823         Add text to figure.\n1824 \n1825         Parameters\n1826         ----------\n1827         x, y : float\n1828             The position to place the text. By default, this is in figure\n1829             coordinates, floats in [0, 1]. The coordinate system can be changed\n1830             using the *transform* keyword.\n1831 \n1832         s : str\n1833             The text string.\n1834 \n1835         fontdict : dictionary, optional, default: None\n1836             A dictionary to override the default text properties. If fontdict\n1837             is None, the defaults are determined by your rc parameters. A\n1838             property in *kwargs* override the same property in fontdict.\n1839 \n1840         withdash : boolean, optional, default: False\n1841             Creates a `~matplotlib.text.TextWithDash` instance instead of a\n1842             `~matplotlib.text.Text` instance.\n1843 \n1844         Other Parameters\n1845         ----------------\n1846         **kwargs : `~matplotlib.text.Text` properties\n1847             Other miscellaneous text parameters.\n1848             %(Text)s\n1849 \n1850         Returns\n1851         -------\n1852         text : `~.text.Text`\n1853 \n1854         See Also\n1855         --------\n1856         .Axes.text\n1857         .pyplot.text\n1858         \"\"\"\n1859         default = dict(transform=self.transFigure)\n1860 \n1861         if withdash:\n1862             text = TextWithDash(x=x, y=y, text=s)\n1863         else:\n1864             text = Text(x=x, y=y, text=s)\n1865 \n1866         text.update(default)\n1867         if fontdict is not None:\n1868             text.update(fontdict)\n1869         text.update(kwargs)\n1870 \n1871         text.set_figure(self)\n1872         text.stale_callback = _stale_figure_callback\n1873 \n1874         self.texts.append(text)\n1875         text._remove_method = self.texts.remove\n1876         self.stale = True\n1877         return text\n1878 \n1879     def _set_artist_props(self, a):\n1880         if a != self:\n1881             a.set_figure(self)\n1882         a.stale_callback = _stale_figure_callback\n1883         a.set_transform(self.transFigure)\n1884 \n1885     @docstring.dedent_interpd\n1886     def gca(self, **kwargs):\n1887         \"\"\"\n1888         Get the current axes, creating one if necessary.\n1889 \n1890         The following kwargs are supported for ensuring the returned axes\n1891         adheres to the given projection etc., and for axes creation if\n1892         the active axes does not exist:\n1893 \n1894         %(Axes)s\n1895 \n1896         \"\"\"\n1897         ckey, cax = self._axstack.current_key_axes()\n1898         # if there exists an axes on the stack see if it matches\n1899         # the desired axes configuration\n1900         if cax is not None:\n1901 \n1902             # if no kwargs are given just return the current axes\n1903             # this is a convenience for gca() on axes such as polar etc.\n1904             if not kwargs:\n1905                 return cax\n1906 \n1907             # if the user has specified particular projection detail\n1908             # then build up a key which can represent this\n1909             else:\n1910                 projection_class, _, key = \\\n1911                     self._process_projection_requirements(**kwargs)\n1912 \n1913                 # let the returned axes have any gridspec by removing it from\n1914                 # the key\n1915                 ckey = ckey[1:]\n1916                 key = key[1:]\n1917 \n1918                 # if the cax matches this key then return the axes, otherwise\n1919                 # continue and a new axes will be created\n1920                 if key == ckey and isinstance(cax, projection_class):\n1921                     return cax\n1922                 else:\n1923                     cbook._warn_external('Requested projection is different '\n1924                                          'from current axis projection, '\n1925                                          'creating new axis with requested '\n1926                                          'projection.')\n1927 \n1928         # no axes found, so create one which spans the figure\n1929         return self.add_subplot(1, 1, 1, **kwargs)\n1930 \n1931     def sca(self, a):\n1932         \"\"\"Set the current axes to be a and return a.\"\"\"\n1933         self._axstack.bubble(a)\n1934         for func in self._axobservers:\n1935             func(self)\n1936         return a\n1937 \n1938     def _gci(self):\n1939         \"\"\"\n1940         Helper for :func:`~matplotlib.pyplot.gci`. Do not use elsewhere.\n1941         \"\"\"\n1942         # Look first for an image in the current Axes:\n1943         cax = self._axstack.current_key_axes()[1]\n1944         if cax is None:\n1945             return None\n1946         im = cax._gci()\n1947         if im is not None:\n1948             return im\n1949 \n1950         # If there is no image in the current Axes, search for\n1951         # one in a previously created Axes.  Whether this makes\n1952         # sense is debatable, but it is the documented behavior.\n1953         for ax in reversed(self.axes):\n1954             im = ax._gci()\n1955             if im is not None:\n1956                 return im\n1957         return None\n1958 \n1959     def __getstate__(self):\n1960         state = super().__getstate__()\n1961 \n1962         # the axobservers cannot currently be pickled.\n1963         # Additionally, the canvas cannot currently be pickled, but this has\n1964         # the benefit of meaning that a figure can be detached from one canvas,\n1965         # and re-attached to another.\n1966         for attr_to_pop in ('_axobservers', 'show',\n1967                             'canvas', '_cachedRenderer'):\n1968             state.pop(attr_to_pop, None)\n1969 \n1970         # add version information to the state\n1971         state['__mpl_version__'] = _mpl_version\n1972 \n1973         # check whether the figure manager (if any) is registered with pyplot\n1974         from matplotlib import _pylab_helpers\n1975         if getattr(self.canvas, 'manager', None) \\\n1976                 in _pylab_helpers.Gcf.figs.values():\n1977             state['_restore_to_pylab'] = True\n1978 \n1979         # set all the layoutbox information to None.  kiwisolver objects can't\n1980         # be pickled, so we lose the layout options at this point.\n1981         state.pop('_layoutbox', None)\n1982         # suptitle:\n1983         if self._suptitle is not None:\n1984             self._suptitle._layoutbox = None\n1985 \n1986         return state\n1987 \n1988     def __setstate__(self, state):\n1989         version = state.pop('__mpl_version__')\n1990         restore_to_pylab = state.pop('_restore_to_pylab', False)\n1991 \n1992         if version != _mpl_version:\n1993             cbook._warn_external(\n1994                 f\"This figure was saved with matplotlib version {version} and \"\n1995                 f\"is unlikely to function correctly.\")\n1996 \n1997         self.__dict__ = state\n1998 \n1999         # re-initialise some of the unstored state information\n2000         self._axobservers = []\n2001         self.canvas = None\n2002         self._layoutbox = None\n2003 \n2004         if restore_to_pylab:\n2005             # lazy import to avoid circularity\n2006             import matplotlib.pyplot as plt\n2007             import matplotlib._pylab_helpers as pylab_helpers\n2008             allnums = plt.get_fignums()\n2009             num = max(allnums) + 1 if allnums else 1\n2010             mgr = plt._backend_mod.new_figure_manager_given_figure(num, self)\n2011 \n2012             # XXX The following is a copy and paste from pyplot. Consider\n2013             # factoring to pylab_helpers\n2014 \n2015             if self.get_label():\n2016                 mgr.set_window_title(self.get_label())\n2017 \n2018             # make this figure current on button press event\n2019             def make_active(event):\n2020                 pylab_helpers.Gcf.set_active(mgr)\n2021 \n2022             mgr._cidgcf = mgr.canvas.mpl_connect('button_press_event',\n2023                                                  make_active)\n2024 \n2025             pylab_helpers.Gcf.set_active(mgr)\n2026             self.number = num\n2027 \n2028             plt.draw_if_interactive()\n2029         self.stale = True\n2030 \n2031     def add_axobserver(self, func):\n2032         \"\"\"Whenever the axes state change, ``func(self)`` will be called.\"\"\"\n2033         self._axobservers.append(func)\n2034 \n2035     def savefig(self, fname, *, transparent=None, **kwargs):\n2036         \"\"\"\n2037         Save the current figure.\n2038 \n2039         Call signature::\n2040 \n2041           savefig(fname, dpi=None, facecolor='w', edgecolor='w',\n2042                   orientation='portrait', papertype=None, format=None,\n2043                   transparent=False, bbox_inches=None, pad_inches=0.1,\n2044                   frameon=None, metadata=None)\n2045 \n2046         The output formats available depend on the backend being used.\n2047 \n2048         Parameters\n2049         ----------\n2050 \n2051         fname : str or PathLike or file-like object\n2052             A path, or a Python file-like object, or\n2053             possibly some backend-dependent object such as\n2054             `matplotlib.backends.backend_pdf.PdfPages`.\n2055 \n2056             If *format* is not set, then the output format is inferred from\n2057             the extension of *fname*, if any, and from :rc:`savefig.format`\n2058             otherwise.  If *format* is set, it determines the output format.\n2059 \n2060             Hence, if *fname* is not a path or has no extension, remember to\n2061             specify *format* to ensure that the correct backend is used.\n2062 \n2063         Other Parameters\n2064         ----------------\n2065 \n2066         dpi : [ *None* | scalar > 0 | 'figure' ]\n2067             The resolution in dots per inch.  If *None*, defaults to\n2068             :rc:`savefig.dpi`.  If 'figure', uses the figure's dpi value.\n2069 \n2070         quality : [ *None* | 1 <= scalar <= 100 ]\n2071             The image quality, on a scale from 1 (worst) to 95 (best).\n2072             Applicable only if *format* is jpg or jpeg, ignored otherwise.\n2073             If *None*, defaults to :rc:`savefig.jpeg_quality` (95 by default).\n2074             Values above 95 should be avoided; 100 completely disables the\n2075             JPEG quantization stage.\n2076 \n2077         optimize : bool\n2078             If *True*, indicates that the JPEG encoder should make an extra\n2079             pass over the image in order to select optimal encoder settings.\n2080             Applicable only if *format* is jpg or jpeg, ignored otherwise.\n2081             Is *False* by default.\n2082 \n2083         progressive : bool\n2084             If *True*, indicates that this image should be stored as a\n2085             progressive JPEG file. Applicable only if *format* is jpg or\n2086             jpeg, ignored otherwise. Is *False* by default.\n2087 \n2088         facecolor : color spec or None, optional\n2089             The facecolor of the figure; if *None*, defaults to\n2090             :rc:`savefig.facecolor`.\n2091 \n2092         edgecolor : color spec or None, optional\n2093             The edgecolor of the figure; if *None*, defaults to\n2094             :rc:`savefig.edgecolor`\n2095 \n2096         orientation : {'landscape', 'portrait'}\n2097             Currently only supported by the postscript backend.\n2098 \n2099         papertype : str\n2100             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through\n2101             'a10', 'b0' through 'b10'. Only supported for postscript\n2102             output.\n2103 \n2104         format : str\n2105             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when\n2106             this is unset is documented under *fname*.\n2107 \n2108         transparent : bool\n2109             If *True*, the axes patches will all be transparent; the\n2110             figure patch will also be transparent unless facecolor\n2111             and/or edgecolor are specified via kwargs.\n2112             This is useful, for example, for displaying\n2113             a plot on top of a colored background on a web page.  The\n2114             transparency of these patches will be restored to their\n2115             original values upon exit of this function.\n2116 \n2117         bbox_inches : str or `~matplotlib.transforms.Bbox`, optional\n2118             Bbox in inches. Only the given portion of the figure is\n2119             saved. If 'tight', try to figure out the tight bbox of\n2120             the figure. If None, use savefig.bbox\n2121 \n2122         pad_inches : scalar, optional\n2123             Amount of padding around the figure when bbox_inches is\n2124             'tight'. If None, use savefig.pad_inches\n2125 \n2126         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional\n2127             A list of extra artists that will be considered when the\n2128             tight bbox is calculated.\n2129 \n2130         metadata : dict, optional\n2131             Key/value pairs to store in the image metadata. The supported keys\n2132             and defaults depend on the image format and backend:\n2133 \n2134             - 'png' with Agg backend: See the parameter ``metadata`` of\n2135               `~.FigureCanvasAgg.print_png`.\n2136             - 'pdf' with pdf backend: See the parameter ``metadata`` of\n2137               `~.backend_pdf.PdfPages`.\n2138             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.\n2139 \n2140         pil_kwargs : dict, optional\n2141             Additional keyword arguments that are passed to `PIL.Image.save`\n2142             when saving the figure.  Only applicable for formats that are saved\n2143             using Pillow, i.e. JPEG, TIFF, and (if the keyword is set to a\n2144             non-None value) PNG.\n2145         \"\"\"\n2146 \n2147         kwargs.setdefault('dpi', rcParams['savefig.dpi'])\n2148         if \"frameon\" in kwargs:\n2149             cbook.warn_deprecated(\"3.1\", name=\"frameon\", obj_type=\"kwarg\",\n2150                                   alternative=\"facecolor\")\n2151             frameon = kwargs.pop(\"frameon\")\n2152             if frameon is None:\n2153                 frameon = dict.__getitem__(rcParams, 'savefig.frameon')\n2154         else:\n2155             frameon = False  # Won't pass \"if frameon:\" below.\n2156         if transparent is None:\n2157             transparent = rcParams['savefig.transparent']\n2158 \n2159         if transparent:\n2160             kwargs.setdefault('facecolor', 'none')\n2161             kwargs.setdefault('edgecolor', 'none')\n2162             original_axes_colors = []\n2163             for ax in self.axes:\n2164                 patch = ax.patch\n2165                 original_axes_colors.append((patch.get_facecolor(),\n2166                                              patch.get_edgecolor()))\n2167                 patch.set_facecolor('none')\n2168                 patch.set_edgecolor('none')\n2169         else:\n2170             kwargs.setdefault('facecolor', rcParams['savefig.facecolor'])\n2171             kwargs.setdefault('edgecolor', rcParams['savefig.edgecolor'])\n2172 \n2173         if frameon:\n2174             original_frameon = self.patch.get_visible()\n2175             self.patch.set_visible(frameon)\n2176 \n2177         self.canvas.print_figure(fname, **kwargs)\n2178 \n2179         if frameon:\n2180             self.patch.set_visible(original_frameon)\n2181 \n2182         if transparent:\n2183             for ax, cc in zip(self.axes, original_axes_colors):\n2184                 ax.patch.set_facecolor(cc[0])\n2185                 ax.patch.set_edgecolor(cc[1])\n2186 \n2187     @docstring.dedent_interpd\n2188     def colorbar(self, mappable, cax=None, ax=None, use_gridspec=True, **kw):\n2189         \"\"\"\n2190         Create a colorbar for a ScalarMappable instance, *mappable*.\n2191 \n2192         Documentation for the pyplot thin wrapper:\n2193         %(colorbar_doc)s\n2194         \"\"\"\n2195         if ax is None:\n2196             ax = self.gca()\n2197 \n2198         # Store the value of gca so that we can set it back later on.\n2199         current_ax = self.gca()\n2200 \n2201         if cax is None:\n2202             if use_gridspec and isinstance(ax, SubplotBase)  \\\n2203                      and (not self.get_constrained_layout()):\n2204                 cax, kw = cbar.make_axes_gridspec(ax, **kw)\n2205             else:\n2206                 cax, kw = cbar.make_axes(ax, **kw)\n2207 \n2208         # need to remove kws that cannot be passed to Colorbar\n2209         NON_COLORBAR_KEYS = ['fraction', 'pad', 'shrink', 'aspect', 'anchor',\n2210                              'panchor']\n2211         cb_kw = {k: v for k, v in kw.items() if k not in NON_COLORBAR_KEYS}\n2212         cb = cbar.colorbar_factory(cax, mappable, **cb_kw)\n2213 \n2214         self.sca(current_ax)\n2215         self.stale = True\n2216         return cb\n2217 \n2218     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,\n2219                         wspace=None, hspace=None):\n2220         \"\"\"\n2221         Update the :class:`SubplotParams` with *kwargs* (defaulting to rc when\n2222         *None*) and update the subplot locations.\n2223 \n2224         \"\"\"\n2225         if self.get_constrained_layout():\n2226             self.set_constrained_layout(False)\n2227             cbook._warn_external(\"This figure was using \"\n2228                                  \"constrained_layout==True, but that is \"\n2229                                  \"incompatible with subplots_adjust and or \"\n2230                                  \"tight_layout: setting \"\n2231                                  \"constrained_layout==False. \")\n2232         self.subplotpars.update(left, bottom, right, top, wspace, hspace)\n2233         for ax in self.axes:\n2234             if not isinstance(ax, SubplotBase):\n2235                 # Check if sharing a subplots axis\n2236                 if isinstance(ax._sharex, SubplotBase):\n2237                     ax._sharex.update_params()\n2238                     ax.set_position(ax._sharex.figbox)\n2239                 elif isinstance(ax._sharey, SubplotBase):\n2240                     ax._sharey.update_params()\n2241                     ax.set_position(ax._sharey.figbox)\n2242             else:\n2243                 ax.update_params()\n2244                 ax.set_position(ax.figbox)\n2245         self.stale = True\n2246 \n2247     def ginput(self, n=1, timeout=30, show_clicks=True, mouse_add=1,\n2248                mouse_pop=3, mouse_stop=2):\n2249         \"\"\"\n2250         Blocking call to interact with a figure.\n2251 \n2252         Wait until the user clicks *n* times on the figure, and return the\n2253         coordinates of each click in a list.\n2254 \n2255         There are three possible interactions:\n2256 \n2257         - Add a point.\n2258         - Remove the most recently added point.\n2259         - Stop the interaction and return the points added so far.\n2260 \n2261         The actions are assigned to mouse buttons via the arguments\n2262         *mouse_add*, *mouse_pop* and *mouse_stop*. Mouse buttons are defined\n2263         by the numbers:\n2264 \n2265         - 1: left mouse button\n2266         - 2: middle mouse button\n2267         - 3: right mouse button\n2268         - None: no mouse button\n2269 \n2270         Parameters\n2271         ----------\n2272         n : int, optional, default: 1\n2273             Number of mouse clicks to accumulate. If negative, accumulate\n2274             clicks until the input is terminated manually.\n2275         timeout : scalar, optional, default: 30\n2276             Number of seconds to wait before timing out. If zero or negative\n2277             will never timeout.\n2278         show_clicks : bool, optional, default: False\n2279             If True, show a red cross at the location of each click.\n2280         mouse_add : {1, 2, 3, None}, optional, default: 1 (left click)\n2281             Mouse button used to add points.\n2282         mouse_pop : {1, 2, 3, None}, optional, default: 3 (right click)\n2283             Mouse button used to remove the most recently added point.\n2284         mouse_stop : {1, 2, 3, None}, optional, default: 2 (middle click)\n2285             Mouse button used to stop input.\n2286 \n2287         Returns\n2288         -------\n2289         points : list of tuples\n2290             A list of the clicked (x, y) coordinates.\n2291 \n2292         Notes\n2293         -----\n2294         The keyboard can also be used to select points in case your mouse\n2295         does not have one or more of the buttons.  The delete and backspace\n2296         keys act like right clicking (i.e., remove last point), the enter key\n2297         terminates input and any other key (not already used by the window\n2298         manager) selects a point.\n2299         \"\"\"\n2300         blocking_mouse_input = BlockingMouseInput(self,\n2301                                                   mouse_add=mouse_add,\n2302                                                   mouse_pop=mouse_pop,\n2303                                                   mouse_stop=mouse_stop)\n2304         return blocking_mouse_input(n=n, timeout=timeout,\n2305                                     show_clicks=show_clicks)\n2306 \n2307     def waitforbuttonpress(self, timeout=-1):\n2308         \"\"\"\n2309         Blocking call to interact with the figure.\n2310 \n2311         This will return True is a key was pressed, False if a mouse\n2312         button was pressed and None if *timeout* was reached without\n2313         either being pressed.\n2314 \n2315         If *timeout* is negative, does not timeout.\n2316         \"\"\"\n2317         blocking_input = BlockingKeyMouseInput(self)\n2318         return blocking_input(timeout=timeout)\n2319 \n2320     def get_default_bbox_extra_artists(self):\n2321         bbox_artists = [artist for artist in self.get_children()\n2322                         if (artist.get_visible() and artist.get_in_layout())]\n2323         for ax in self.axes:\n2324             if ax.get_visible():\n2325                 bbox_artists.extend(ax.get_default_bbox_extra_artists())\n2326         # we don't want the figure's patch to influence the bbox calculation\n2327         bbox_artists.remove(self.patch)\n2328         return bbox_artists\n2329 \n2330     def get_tightbbox(self, renderer, bbox_extra_artists=None):\n2331         \"\"\"\n2332         Return a (tight) bounding box of the figure in inches.\n2333 \n2334         Artists that have ``artist.set_in_layout(False)`` are not included\n2335         in the bbox.\n2336 \n2337         Parameters\n2338         ----------\n2339         renderer : `.RendererBase` instance\n2340             renderer that will be used to draw the figures (i.e.\n2341             ``fig.canvas.get_renderer()``)\n2342 \n2343         bbox_extra_artists : list of `.Artist` or ``None``\n2344             List of artists to include in the tight bounding box.  If\n2345             ``None`` (default), then all artist children of each axes are\n2346             included in the tight bounding box.\n2347 \n2348         Returns\n2349         -------\n2350         bbox : `.BboxBase`\n2351             containing the bounding box (in figure inches).\n2352         \"\"\"\n2353 \n2354         bb = []\n2355         if bbox_extra_artists is None:\n2356             artists = self.get_default_bbox_extra_artists()\n2357         else:\n2358             artists = bbox_extra_artists\n2359 \n2360         for a in artists:\n2361             bbox = a.get_tightbbox(renderer)\n2362             if bbox is not None and (bbox.width != 0 or bbox.height != 0):\n2363                 bb.append(bbox)\n2364 \n2365         for ax in self.axes:\n2366             if ax.get_visible():\n2367                 # some axes don't take the bbox_extra_artists kwarg so we\n2368                 # need this conditional....\n2369                 try:\n2370                     bbox = ax.get_tightbbox(renderer,\n2371                             bbox_extra_artists=bbox_extra_artists)\n2372                 except TypeError:\n2373                     bbox = ax.get_tightbbox(renderer)\n2374                 bb.append(bbox)\n2375         bb = [b for b in bb\n2376               if (np.isfinite(b.width) and np.isfinite(b.height)\n2377                   and (b.width != 0 or b.height != 0))]\n2378 \n2379         if len(bb) == 0:\n2380             return self.bbox_inches\n2381 \n2382         _bbox = Bbox.union(bb)\n2383 \n2384         bbox_inches = TransformedBbox(_bbox,\n2385                                       Affine2D().scale(1. / self.dpi))\n2386 \n2387         return bbox_inches\n2388 \n2389     def init_layoutbox(self):\n2390         \"\"\"Initialize the layoutbox for use in constrained_layout.\"\"\"\n2391         if self._layoutbox is None:\n2392             self._layoutbox = layoutbox.LayoutBox(parent=None,\n2393                                      name='figlb',\n2394                                      artist=self)\n2395             self._layoutbox.constrain_geometry(0., 0., 1., 1.)\n2396 \n2397     def execute_constrained_layout(self, renderer=None):\n2398         \"\"\"\n2399         Use ``layoutbox`` to determine pos positions within axes.\n2400 \n2401         See also `.set_constrained_layout_pads`.\n2402         \"\"\"\n2403 \n2404         from matplotlib._constrained_layout import do_constrained_layout\n2405 \n2406         _log.debug('Executing constrainedlayout')\n2407         if self._layoutbox is None:\n2408             cbook._warn_external(\"Calling figure.constrained_layout, but \"\n2409                                  \"figure not setup to do constrained layout. \"\n2410                                  \" You either called GridSpec without the \"\n2411                                  \"fig keyword, you are using plt.subplot, \"\n2412                                  \"or you need to call figure or subplots \"\n2413                                  \"with the constrained_layout=True kwarg.\")\n2414             return\n2415         w_pad, h_pad, wspace, hspace = self.get_constrained_layout_pads()\n2416         # convert to unit-relative lengths\n2417         fig = self\n2418         width, height = fig.get_size_inches()\n2419         w_pad = w_pad / width\n2420         h_pad = h_pad / height\n2421         if renderer is None:\n2422             renderer = layoutbox.get_renderer(fig)\n2423         do_constrained_layout(fig, renderer, h_pad, w_pad, hspace, wspace)\n2424 \n2425     def tight_layout(self, renderer=None, pad=1.08, h_pad=None, w_pad=None,\n2426                      rect=None):\n2427         \"\"\"\n2428         Automatically adjust subplot parameters to give specified padding.\n2429 \n2430         To exclude an artist on the axes from the bounding box calculation\n2431         that determines the subplot parameters (i.e. legend, or annotation),\n2432         then set `a.set_in_layout(False)` for that artist.\n2433 \n2434         Parameters\n2435         ----------\n2436         renderer : subclass of `~.backend_bases.RendererBase`, optional\n2437             Defaults to the renderer for the figure.\n2438 \n2439         pad : float, optional\n2440             Padding between the figure edge and the edges of subplots,\n2441             as a fraction of the font size.\n2442         h_pad, w_pad : float, optional\n2443             Padding (height/width) between edges of adjacent subplots,\n2444             as a fraction of the font size.  Defaults to *pad*.\n2445         rect : tuple (left, bottom, right, top), optional\n2446             A rectangle (left, bottom, right, top) in the normalized\n2447             figure coordinate that the whole subplots area (including\n2448             labels) will fit into. Default is (0, 0, 1, 1).\n2449 \n2450         See Also\n2451         --------\n2452         .Figure.set_tight_layout\n2453         .pyplot.tight_layout\n2454         \"\"\"\n2455 \n2456         from .tight_layout import (\n2457             get_renderer, get_subplotspec_list, get_tight_layout_figure)\n2458 \n2459         subplotspec_list = get_subplotspec_list(self.axes)\n2460         if None in subplotspec_list:\n2461             cbook._warn_external(\"This figure includes Axes that are not \"\n2462                                  \"compatible with tight_layout, so results \"\n2463                                  \"might be incorrect.\")\n2464 \n2465         if renderer is None:\n2466             renderer = get_renderer(self)\n2467 \n2468         kwargs = get_tight_layout_figure(\n2469             self, self.axes, subplotspec_list, renderer,\n2470             pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n2471         if kwargs:\n2472             self.subplots_adjust(**kwargs)\n2473 \n2474     def align_xlabels(self, axs=None):\n2475         \"\"\"\n2476         Align the ylabels of subplots in the same subplot column if label\n2477         alignment is being done automatically (i.e. the label position is\n2478         not manually set).\n2479 \n2480         Alignment persists for draw events after this is called.\n2481 \n2482         If a label is on the bottom, it is aligned with labels on axes that\n2483         also have their label on the bottom and that have the same\n2484         bottom-most subplot row.  If the label is on the top,\n2485         it is aligned with labels on axes with the same top-most row.\n2486 \n2487         Parameters\n2488         ----------\n2489         axs : list of `~matplotlib.axes.Axes`\n2490             Optional list of (or ndarray) `~matplotlib.axes.Axes`\n2491             to align the xlabels.\n2492             Default is to align all axes on the figure.\n2493 \n2494         See Also\n2495         --------\n2496         matplotlib.figure.Figure.align_ylabels\n2497 \n2498         matplotlib.figure.Figure.align_labels\n2499 \n2500         Notes\n2501         -----\n2502         This assumes that ``axs`` are from the same `.GridSpec`, so that\n2503         their `.SubplotSpec` positions correspond to figure positions.\n2504 \n2505         Examples\n2506         --------\n2507         Example with rotated xtick labels::\n2508 \n2509             fig, axs = plt.subplots(1, 2)\n2510             for tick in axs[0].get_xticklabels():\n2511                 tick.set_rotation(55)\n2512             axs[0].set_xlabel('XLabel 0')\n2513             axs[1].set_xlabel('XLabel 1')\n2514             fig.align_xlabels()\n2515 \n2516         \"\"\"\n2517 \n2518         if axs is None:\n2519             axs = self.axes\n2520         axs = np.asarray(axs).ravel()\n2521         for ax in axs:\n2522             _log.debug(' Working on: %s', ax.get_xlabel())\n2523             ss = ax.get_subplotspec()\n2524             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n2525             labpo = ax.xaxis.get_label_position()  # top or bottom\n2526 \n2527             # loop through other axes, and search for label positions\n2528             # that are same as this one, and that share the appropriate\n2529             # row number.\n2530             #  Add to a grouper associated with each axes of sibblings.\n2531             # This list is inspected in `axis.draw` by\n2532             # `axis._update_label_position`.\n2533             for axc in axs:\n2534                 if axc.xaxis.get_label_position() == labpo:\n2535                     ss = axc.get_subplotspec()\n2536                     nrows, ncols, rowc0, rowc1, colc, col1 = \\\n2537                             ss.get_rows_columns()\n2538                     if (labpo == 'bottom' and rowc1 == row1 or\n2539                         labpo == 'top' and rowc0 == row0):\n2540                         # grouper for groups of xlabels to align\n2541                         self._align_xlabel_grp.join(ax, axc)\n2542 \n2543     def align_ylabels(self, axs=None):\n2544         \"\"\"\n2545         Align the ylabels of subplots in the same subplot column if label\n2546         alignment is being done automatically (i.e. the label position is\n2547         not manually set).\n2548 \n2549         Alignment persists for draw events after this is called.\n2550 \n2551         If a label is on the left, it is aligned with labels on axes that\n2552         also have their label on the left and that have the same\n2553         left-most subplot column.  If the label is on the right,\n2554         it is aligned with labels on axes with the same right-most column.\n2555 \n2556         Parameters\n2557         ----------\n2558         axs : list of `~matplotlib.axes.Axes`\n2559             Optional list (or ndarray) of `~matplotlib.axes.Axes`\n2560             to align the ylabels.\n2561             Default is to align all axes on the figure.\n2562 \n2563         See Also\n2564         --------\n2565         matplotlib.figure.Figure.align_xlabels\n2566 \n2567         matplotlib.figure.Figure.align_labels\n2568 \n2569         Notes\n2570         -----\n2571         This assumes that ``axs`` are from the same `.GridSpec`, so that\n2572         their `.SubplotSpec` positions correspond to figure positions.\n2573 \n2574         Examples\n2575         --------\n2576         Example with large yticks labels::\n2577 \n2578             fig, axs = plt.subplots(2, 1)\n2579             axs[0].plot(np.arange(0, 1000, 50))\n2580             axs[0].set_ylabel('YLabel 0')\n2581             axs[1].set_ylabel('YLabel 1')\n2582             fig.align_ylabels()\n2583 \n2584         \"\"\"\n2585 \n2586         if axs is None:\n2587             axs = self.axes\n2588         axs = np.asarray(axs).ravel()\n2589         for ax in axs:\n2590             _log.debug(' Working on: %s', ax.get_ylabel())\n2591             ss = ax.get_subplotspec()\n2592             nrows, ncols, row0, row1, col0, col1 = ss.get_rows_columns()\n2593             labpo = ax.yaxis.get_label_position()  # left or right\n2594             # loop through other axes, and search for label positions\n2595             # that are same as this one, and that share the appropriate\n2596             # column number.\n2597             # Add to a list associated with each axes of sibblings.\n2598             # This list is inspected in `axis.draw` by\n2599             # `axis._update_label_position`.\n2600             for axc in axs:\n2601                 if axc != ax:\n2602                     if axc.yaxis.get_label_position() == labpo:\n2603                         ss = axc.get_subplotspec()\n2604                         nrows, ncols, row0, row1, colc0, colc1 = \\\n2605                                 ss.get_rows_columns()\n2606                         if (labpo == 'left' and colc0 == col0 or\n2607                             labpo == 'right' and colc1 == col1):\n2608                             # grouper for groups of ylabels to align\n2609                             self._align_ylabel_grp.join(ax, axc)\n2610 \n2611     def align_labels(self, axs=None):\n2612         \"\"\"\n2613         Align the xlabels and ylabels of subplots with the same subplots\n2614         row or column (respectively) if label alignment is being\n2615         done automatically (i.e. the label position is not manually set).\n2616 \n2617         Alignment persists for draw events after this is called.\n2618 \n2619         Parameters\n2620         ----------\n2621         axs : list of `~matplotlib.axes.Axes`\n2622             Optional list (or ndarray) of `~matplotlib.axes.Axes`\n2623             to align the labels.\n2624             Default is to align all axes on the figure.\n2625 \n2626         See Also\n2627         --------\n2628         matplotlib.figure.Figure.align_xlabels\n2629 \n2630         matplotlib.figure.Figure.align_ylabels\n2631         \"\"\"\n2632         self.align_xlabels(axs=axs)\n2633         self.align_ylabels(axs=axs)\n2634 \n2635     def add_gridspec(self, nrows, ncols, **kwargs):\n2636         \"\"\"\n2637         Return a `.GridSpec` that has this figure as a parent.  This allows\n2638         complex layout of axes in the figure.\n2639 \n2640         Parameters\n2641         ----------\n2642         nrows : int\n2643             Number of rows in grid.\n2644 \n2645         ncols : int\n2646             Number or columns in grid.\n2647 \n2648         Returns\n2649         -------\n2650         gridspec : `.GridSpec`\n2651 \n2652         Other Parameters\n2653         ----------------\n2654         **kwargs\n2655             Keyword arguments are passed to `.GridSpec`.\n2656 \n2657         See Also\n2658         --------\n2659         matplotlib.pyplot.subplots\n2660 \n2661         Examples\n2662         --------\n2663         Adding a subplot that spans two rows::\n2664 \n2665             fig = plt.figure()\n2666             gs = fig.add_gridspec(2, 2)\n2667             ax1 = fig.add_subplot(gs[0, 0])\n2668             ax2 = fig.add_subplot(gs[1, 0])\n2669             # spans two rows:\n2670             ax3 = fig.add_subplot(gs[:, 1])\n2671 \n2672         \"\"\"\n2673 \n2674         _ = kwargs.pop('figure', None)  # pop in case user has added this...\n2675         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)\n2676         self._gridspecs.append(gs)\n2677         return gs\n2678 \n2679 \n2680 def figaspect(arg):\n2681     \"\"\"\n2682     Calculate the width and height for a figure with a specified aspect ratio.\n2683 \n2684     While the height is taken from :rc:`figure.figsize`, the width is\n2685     adjusted to match the desired aspect ratio. Additionally, it is ensured\n2686     that the width is in the range [4., 16.] and the height is in the range\n2687     [2., 16.]. If necessary, the default height is adjusted to ensure this.\n2688 \n2689     Parameters\n2690     ----------\n2691     arg : scalar or 2d array\n2692         If a scalar, this defines the aspect ratio (i.e. the ratio height /\n2693         width).\n2694         In case of an array the aspect ratio is number of rows / number of\n2695         columns, so that the array could be fitted in the figure undistorted.\n2696 \n2697     Returns\n2698     -------\n2699     width, height\n2700         The figure size in inches.\n2701 \n2702     Notes\n2703     -----\n2704     If you want to create an axes within the figure, that still preserves the\n2705     aspect ratio, be sure to create it with equal width and height. See\n2706     examples below.\n2707 \n2708     Thanks to Fernando Perez for this function.\n2709 \n2710     Examples\n2711     --------\n2712     Make a figure twice as tall as it is wide::\n2713 \n2714         w, h = figaspect(2.)\n2715         fig = Figure(figsize=(w, h))\n2716         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n2717         ax.imshow(A, **kwargs)\n2718 \n2719     Make a figure with the proper aspect for an array::\n2720 \n2721         A = rand(5,3)\n2722         w, h = figaspect(A)\n2723         fig = Figure(figsize=(w, h))\n2724         ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])\n2725         ax.imshow(A, **kwargs)\n2726     \"\"\"\n2727 \n2728     isarray = hasattr(arg, 'shape') and not np.isscalar(arg)\n2729 \n2730     # min/max sizes to respect when autoscaling.  If John likes the idea, they\n2731     # could become rc parameters, for now they're hardwired.\n2732     figsize_min = np.array((4.0, 2.0))  # min length for width/height\n2733     figsize_max = np.array((16.0, 16.0))  # max length for width/height\n2734 \n2735     # Extract the aspect ratio of the array\n2736     if isarray:\n2737         nr, nc = arg.shape[:2]\n2738         arr_ratio = nr / nc\n2739     else:\n2740         arr_ratio = arg\n2741 \n2742     # Height of user figure defaults\n2743     fig_height = rcParams['figure.figsize'][1]\n2744 \n2745     # New size for the figure, keeping the aspect ratio of the caller\n2746     newsize = np.array((fig_height / arr_ratio, fig_height))\n2747 \n2748     # Sanity checks, don't drop either dimension below figsize_min\n2749     newsize /= min(1.0, *(newsize / figsize_min))\n2750 \n2751     # Avoid humongous windows as well\n2752     newsize /= max(1.0, *(newsize / figsize_max))\n2753 \n2754     # Finally, if we have a really funky aspect ratio, break it but respect\n2755     # the min/max dimensions (we don't want figures 10 feet tall!)\n2756     newsize = np.clip(newsize, figsize_min, figsize_max)\n2757     return newsize\n2758 \n2759 docstring.interpd.update(Figure=martist.kwdoc(Figure))\n",
        "intended_behavior": "Ensure that when the `figsize` parameter is processed, there is explicit validation to check that both width and height values are greater than zero. If a value of zero is encountered, raise a ValueError with a clear message indicating that figure dimensions must be positive. This preserves the functionality of figure creation and saving while preventing the situation that leads to a crash due to invalid dimensions."
    },
    {
        "rel_file_path": "lib/matplotlib/pyplot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.0/lib/matplotlib/pyplot.py",
        "start": 1,
        "end": 3278,
        "class_name": null,
        "method_name": null,
        "code": "1 # Note: The first part of this file can be modified in place, but the latter\n2 # part is autogenerated by the boilerplate.py script.\n3 \n4 \"\"\"\n5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides\n6 a MATLAB-like way of plotting.\n7 \n8 pyplot is mainly intended for interactive plots and simple cases of\n9 programmatic plot generation::\n10 \n11     import numpy as np\n12     import matplotlib.pyplot as plt\n13 \n14     x = np.arange(0, 5, 0.1)\n15     y = np.sin(x)\n16     plt.plot(x, y)\n17 \n18 The object-oriented API is recommended for more complex plots.\n19 \"\"\"\n20 \n21 import functools\n22 import importlib\n23 import inspect\n24 import logging\n25 from numbers import Number\n26 import re\n27 import sys\n28 import time\n29 \n30 from cycler import cycler\n31 import matplotlib\n32 import matplotlib.colorbar\n33 import matplotlib.image\n34 from matplotlib import rcsetup, style\n35 from matplotlib import _pylab_helpers, interactive\n36 from matplotlib import cbook\n37 from matplotlib.cbook import dedent, deprecated, silent_list, warn_deprecated\n38 from matplotlib import docstring\n39 from matplotlib.backend_bases import FigureCanvasBase\n40 from matplotlib.figure import Figure, figaspect\n41 from matplotlib.gridspec import GridSpec\n42 from matplotlib import rcParams, rcParamsDefault, get_backend, rcParamsOrig\n43 from matplotlib import rc_context\n44 from matplotlib.rcsetup import interactive_bk as _interactive_bk\n45 from matplotlib.artist import getp, get, Artist\n46 from matplotlib.artist import setp as _setp\n47 from matplotlib.axes import Axes, Subplot\n48 from matplotlib.projections import PolarAxes\n49 from matplotlib import mlab  # for _csv2rec, detrend_none, window_hanning\n50 from matplotlib.scale import get_scale_docs, get_scale_names\n51 \n52 from matplotlib import cm\n53 from matplotlib.cm import get_cmap, register_cmap\n54 \n55 import numpy as np\n56 \n57 # We may not need the following imports here:\n58 from matplotlib.colors import Normalize\n59 from matplotlib.lines import Line2D\n60 from matplotlib.text import Text, Annotation\n61 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow\n62 from matplotlib.widgets import SubplotTool, Button, Slider, Widget\n63 \n64 from .ticker import TickHelper, Formatter, FixedFormatter, NullFormatter,\\\n65            FuncFormatter, FormatStrFormatter, ScalarFormatter,\\\n66            LogFormatter, LogFormatterExponent, LogFormatterMathtext,\\\n67            Locator, IndexLocator, FixedLocator, NullLocator,\\\n68            LinearLocator, LogLocator, AutoLocator, MultipleLocator,\\\n69            MaxNLocator\n70 from matplotlib.backends import pylab_setup, _get_running_interactive_framework\n71 \n72 _log = logging.getLogger(__name__)\n73 \n74 \n75 ## Global ##\n76 \n77 \n78 _IP_REGISTERED = None\n79 _INSTALL_FIG_OBSERVER = False\n80 \n81 \n82 def install_repl_displayhook():\n83     \"\"\"\n84     Install a repl display hook so that any stale figure are automatically\n85     redrawn when control is returned to the repl.\n86 \n87     This works both with IPython and with vanilla python shells.\n88     \"\"\"\n89     global _IP_REGISTERED\n90     global _INSTALL_FIG_OBSERVER\n91 \n92     class _NotIPython(Exception):\n93         pass\n94 \n95     # see if we have IPython hooks around, if use them\n96 \n97     try:\n98         if 'IPython' in sys.modules:\n99             from IPython import get_ipython\n100             ip = get_ipython()\n101             if ip is None:\n102                 raise _NotIPython()\n103 \n104             if _IP_REGISTERED:\n105                 return\n106 \n107             def post_execute():\n108                 if matplotlib.is_interactive():\n109                     draw_all()\n110 \n111             # IPython >= 2\n112             try:\n113                 ip.events.register('post_execute', post_execute)\n114             except AttributeError:\n115                 # IPython 1.x\n116                 ip.register_post_execute(post_execute)\n117 \n118             _IP_REGISTERED = post_execute\n119             _INSTALL_FIG_OBSERVER = False\n120 \n121             # trigger IPython's eventloop integration, if available\n122             from IPython.core.pylabtools import backend2gui\n123 \n124             ipython_gui_name = backend2gui.get(get_backend())\n125             if ipython_gui_name:\n126                 ip.enable_gui(ipython_gui_name)\n127         else:\n128             _INSTALL_FIG_OBSERVER = True\n129 \n130     # import failed or ipython is not running\n131     except (ImportError, _NotIPython):\n132         _INSTALL_FIG_OBSERVER = True\n133 \n134 \n135 def uninstall_repl_displayhook():\n136     \"\"\"\n137     Uninstall the matplotlib display hook.\n138 \n139     .. warning\n140 \n141        Need IPython >= 2 for this to work.  For IPython < 2 will raise a\n142        ``NotImplementedError``\n143 \n144     .. warning\n145 \n146        If you are using vanilla python and have installed another\n147        display hook this will reset ``sys.displayhook`` to what ever\n148        function was there when matplotlib installed it's displayhook,\n149        possibly discarding your changes.\n150     \"\"\"\n151     global _IP_REGISTERED\n152     global _INSTALL_FIG_OBSERVER\n153     if _IP_REGISTERED:\n154         from IPython import get_ipython\n155         ip = get_ipython()\n156         try:\n157             ip.events.unregister('post_execute', _IP_REGISTERED)\n158         except AttributeError:\n159             raise NotImplementedError(\"Can not unregister events \"\n160                                       \"in IPython < 2.0\")\n161         _IP_REGISTERED = None\n162 \n163     if _INSTALL_FIG_OBSERVER:\n164         _INSTALL_FIG_OBSERVER = False\n165 \n166 \n167 draw_all = _pylab_helpers.Gcf.draw_all\n168 \n169 \n170 @functools.wraps(matplotlib.set_loglevel)\n171 def set_loglevel(*args, **kwargs):  # Ensure this appears in the pyplot docs.\n172     return matplotlib.set_loglevel(*args, **kwargs)\n173 \n174 \n175 @docstring.copy(Artist.findobj)\n176 def findobj(o=None, match=None, include_self=True):\n177     if o is None:\n178         o = gcf()\n179     return o.findobj(match, include_self=include_self)\n180 \n181 \n182 def switch_backend(newbackend):\n183     \"\"\"\n184     Close all open figures and set the Matplotlib backend.\n185 \n186     The argument is case-insensitive.  Switching to an interactive backend is\n187     possible only if no event loop for another interactive backend has started.\n188     Switching to and from non-interactive backends is always possible.\n189 \n190     Parameters\n191     ----------\n192     newbackend : str\n193         The name of the backend to use.\n194     \"\"\"\n195     close(\"all\")\n196 \n197     if newbackend is rcsetup._auto_backend_sentinel:\n198         # Don't try to fallback on the cairo-based backends as they each have\n199         # an additional dependency (pycairo) over the agg-based backend, and\n200         # are of worse quality.\n201         for candidate in [\"macosx\", \"qt5agg\", \"qt4agg\", \"gtk3agg\", \"tkagg\",\n202                           \"wxagg\", \"agg\"]:\n203             try:\n204                 switch_backend(candidate)\n205             except ImportError:\n206                 continue\n207             else:\n208                 rcParamsOrig['backend'] = candidate\n209                 return\n210 \n211     backend_name = (\n212         newbackend[9:] if newbackend.startswith(\"module://\")\n213         else \"matplotlib.backends.backend_{}\".format(newbackend.lower()))\n214 \n215     backend_mod = importlib.import_module(backend_name)\n216     Backend = type(\n217         \"Backend\", (matplotlib.backends._Backend,), vars(backend_mod))\n218     _log.debug(\"Loaded backend %s version %s.\",\n219                newbackend, Backend.backend_version)\n220 \n221     required_framework = Backend.required_interactive_framework\n222     if required_framework is not None:\n223         current_framework = \\\n224             matplotlib.backends._get_running_interactive_framework()\n225         if (current_framework and required_framework\n226                 and current_framework != required_framework):\n227             raise ImportError(\n228                 \"Cannot load backend {!r} which requires the {!r} interactive \"\n229                 \"framework, as {!r} is currently running\".format(\n230                     newbackend, required_framework, current_framework))\n231 \n232     rcParams['backend'] = rcParamsDefault['backend'] = newbackend\n233 \n234     global _backend_mod, new_figure_manager, draw_if_interactive, _show\n235     _backend_mod = backend_mod\n236     new_figure_manager = Backend.new_figure_manager\n237     draw_if_interactive = Backend.draw_if_interactive\n238     _show = Backend.show\n239 \n240     # Need to keep a global reference to the backend for compatibility reasons.\n241     # See https://github.com/matplotlib/matplotlib/issues/6092\n242     matplotlib.backends.backend = newbackend\n243 \n244 \n245 def show(*args, **kw):\n246     \"\"\"\n247     Display a figure.\n248     When running in ipython with its pylab mode, display all\n249     figures and return to the ipython prompt.\n250 \n251     In non-interactive mode, display all figures and block until\n252     the figures have been closed; in interactive mode it has no\n253     effect unless figures were created prior to a change from\n254     non-interactive to interactive mode (not recommended).  In\n255     that case it displays the figures but does not block.\n256 \n257     A single experimental keyword argument, *block*, may be\n258     set to True or False to override the blocking behavior\n259     described above.\n260     \"\"\"\n261     global _show\n262     return _show(*args, **kw)\n263 \n264 \n265 def isinteractive():\n266     \"\"\"Return the status of interactive mode.\"\"\"\n267     return matplotlib.is_interactive()\n268 \n269 \n270 def ioff():\n271     \"\"\"Turn the interactive mode off.\"\"\"\n272     matplotlib.interactive(False)\n273     uninstall_repl_displayhook()\n274 \n275 \n276 def ion():\n277     \"\"\"Turn the interactive mode on.\"\"\"\n278     matplotlib.interactive(True)\n279     install_repl_displayhook()\n280 \n281 \n282 def pause(interval):\n283     \"\"\"\n284     Pause for *interval* seconds.\n285 \n286     If there is an active figure, it will be updated and displayed before the\n287     pause, and the GUI event loop (if any) will run during the pause.\n288 \n289     This can be used for crude animation.  For more complex animation, see\n290     :mod:`matplotlib.animation`.\n291 \n292     Notes\n293     -----\n294     This function is experimental; its behavior may be changed or extended in a\n295     future release.\n296     \"\"\"\n297     manager = _pylab_helpers.Gcf.get_active()\n298     if manager is not None:\n299         canvas = manager.canvas\n300         if canvas.figure.stale:\n301             canvas.draw_idle()\n302         show(block=False)\n303         canvas.start_event_loop(interval)\n304     else:\n305         time.sleep(interval)\n306 \n307 \n308 @docstring.copy(matplotlib.rc)\n309 def rc(group, **kwargs):\n310     matplotlib.rc(group, **kwargs)\n311 \n312 \n313 @docstring.copy(matplotlib.rc_context)\n314 def rc_context(rc=None, fname=None):\n315     return matplotlib.rc_context(rc, fname)\n316 \n317 \n318 @docstring.copy(matplotlib.rcdefaults)\n319 def rcdefaults():\n320     matplotlib.rcdefaults()\n321     if matplotlib.is_interactive():\n322         draw_all()\n323 \n324 \n325 ## Current image ##\n326 \n327 \n328 def gci():\n329     \"\"\"\n330     Get the current colorable artist.  Specifically, returns the\n331     current :class:`~matplotlib.cm.ScalarMappable` instance (image or\n332     patch collection), or *None* if no images or patch collections\n333     have been defined.  The commands :func:`~matplotlib.pyplot.imshow`\n334     and :func:`~matplotlib.pyplot.figimage` create\n335     :class:`~matplotlib.image.Image` instances, and the commands\n336     :func:`~matplotlib.pyplot.pcolor` and\n337     :func:`~matplotlib.pyplot.scatter` create\n338     :class:`~matplotlib.collections.Collection` instances.  The\n339     current image is an attribute of the current axes, or the nearest\n340     earlier axes in the current figure that contains an image.\n341     \"\"\"\n342     return gcf()._gci()\n343 \n344 \n345 ## Any Artist ##\n346 \n347 \n348 # (getp is simply imported)\n349 @docstring.copy(_setp)\n350 def setp(obj, *args, **kwargs):\n351     return _setp(obj, *args, **kwargs)\n352 \n353 \n354 def xkcd(scale=1, length=100, randomness=2):\n355     \"\"\"\n356     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.\n357     This will only have effect on things drawn after this function is\n358     called.\n359 \n360     For best results, the \"Humor Sans\" font should be installed: it is\n361     not included with matplotlib.\n362 \n363     Parameters\n364     ----------\n365     scale : float, optional\n366         The amplitude of the wiggle perpendicular to the source line.\n367     length : float, optional\n368         The length of the wiggle along the line.\n369     randomness : float, optional\n370         The scale factor by which the length is shrunken or expanded.\n371 \n372     Notes\n373     -----\n374     This function works by a number of rcParams, so it will probably\n375     override others you have set before.\n376 \n377     If you want the effects of this function to be temporary, it can\n378     be used as a context manager, for example::\n379 \n380         with plt.xkcd():\n381             # This figure will be in XKCD-style\n382             fig1 = plt.figure()\n383             # ...\n384 \n385         # This figure will be in regular style\n386         fig2 = plt.figure()\n387     \"\"\"\n388     if rcParams['text.usetex']:\n389         raise RuntimeError(\n390             \"xkcd mode is not compatible with text.usetex = True\")\n391 \n392     from matplotlib import patheffects\n393     return rc_context({\n394         'font.family': ['xkcd', 'Humor Sans', 'Comic Sans MS'],\n395         'font.size': 14.0,\n396         'path.sketch': (scale, length, randomness),\n397         'path.effects': [patheffects.withStroke(linewidth=4, foreground=\"w\")],\n398         'axes.linewidth': 1.5,\n399         'lines.linewidth': 2.0,\n400         'figure.facecolor': 'white',\n401         'grid.linewidth': 0.0,\n402         'axes.grid': False,\n403         'axes.unicode_minus': False,\n404         'axes.edgecolor': 'black',\n405         'xtick.major.size': 8,\n406         'xtick.major.width': 3,\n407         'ytick.major.size': 8,\n408         'ytick.major.width': 3,\n409     })\n410 \n411 \n412 ## Figures ##\n413 \n414 def figure(num=None,  # autoincrement if None, else integer from 1-N\n415            figsize=None,  # defaults to rc figure.figsize\n416            dpi=None,  # defaults to rc figure.dpi\n417            facecolor=None,  # defaults to rc figure.facecolor\n418            edgecolor=None,  # defaults to rc figure.edgecolor\n419            frameon=True,\n420            FigureClass=Figure,\n421            clear=False,\n422            **kwargs\n423            ):\n424     \"\"\"\n425     Create a new figure.\n426 \n427     Parameters\n428     ----------\n429 \n430     num : integer or string, optional, default: None\n431         If not provided, a new figure will be created, and the figure number\n432         will be incremented. The figure objects holds this number in a `number`\n433         attribute.\n434         If num is provided, and a figure with this id already exists, make\n435         it active, and returns a reference to it. If this figure does not\n436         exists, create it and returns it.\n437         If num is a string, the window title will be set to this figure's\n438         `num`.\n439 \n440     figsize : (float, float), optional, default: None\n441         width, height in inches. If not provided, defaults to\n442         :rc:`figure.figsize` = ``[6.4, 4.8]``.\n443 \n444     dpi : integer, optional, default: None\n445         resolution of the figure. If not provided, defaults to\n446         :rc:`figure.dpi` = ``100``.\n447 \n448     facecolor : color spec\n449         the background color. If not provided, defaults to\n450         :rc:`figure.facecolor` = ``'w'``.\n451 \n452     edgecolor : color spec\n453         the border color. If not provided, defaults to\n454         :rc:`figure.edgecolor` = ``'w'``.\n455 \n456     frameon : bool, optional, default: True\n457         If False, suppress drawing the figure frame.\n458 \n459     FigureClass : subclass of `~matplotlib.figure.Figure`\n460         Optionally use a custom `.Figure` instance.\n461 \n462     clear : bool, optional, default: False\n463         If True and the figure already exists, then it is cleared.\n464 \n465     Returns\n466     -------\n467     figure : `~matplotlib.figure.Figure`\n468         The `.Figure` instance returned will also be passed to\n469         new_figure_manager in the backends, which allows to hook custom\n470         `.Figure` classes into the pyplot interface. Additional kwargs will be\n471         passed to the `.Figure` init function.\n472 \n473     Notes\n474     -----\n475     If you are creating many figures, make sure you explicitly call\n476     :func:`.pyplot.close` on the figures you are not using, because this will\n477     enable pyplot to properly clean up the memory.\n478 \n479     `~matplotlib.rcParams` defines the default values, which can be modified\n480     in the matplotlibrc file.\n481     \"\"\"\n482 \n483     if figsize is None:\n484         figsize = rcParams['figure.figsize']\n485     if dpi is None:\n486         dpi = rcParams['figure.dpi']\n487     if facecolor is None:\n488         facecolor = rcParams['figure.facecolor']\n489     if edgecolor is None:\n490         edgecolor = rcParams['figure.edgecolor']\n491 \n492     allnums = get_fignums()\n493     next_num = max(allnums) + 1 if allnums else 1\n494     figLabel = ''\n495     if num is None:\n496         num = next_num\n497     elif isinstance(num, str):\n498         figLabel = num\n499         allLabels = get_figlabels()\n500         if figLabel not in allLabels:\n501             if figLabel == 'all':\n502                 cbook._warn_external(\n503                     \"close('all') closes all existing figures\")\n504             num = next_num\n505         else:\n506             inum = allLabels.index(figLabel)\n507             num = allnums[inum]\n508     else:\n509         num = int(num)  # crude validation of num argument\n510 \n511     figManager = _pylab_helpers.Gcf.get_fig_manager(num)\n512     if figManager is None:\n513         max_open_warning = rcParams['figure.max_open_warning']\n514 \n515         if len(allnums) >= max_open_warning >= 1:\n516             cbook._warn_external(\n517                 \"More than %d figures have been opened. Figures \"\n518                 \"created through the pyplot interface \"\n519                 \"(`matplotlib.pyplot.figure`) are retained until \"\n520                 \"explicitly closed and may consume too much memory. \"\n521                 \"(To control this warning, see the rcParam \"\n522                 \"`figure.max_open_warning`).\" %\n523                 max_open_warning, RuntimeWarning)\n524 \n525         if get_backend().lower() == 'ps':\n526             dpi = 72\n527 \n528         figManager = new_figure_manager(num, figsize=figsize,\n529                                         dpi=dpi,\n530                                         facecolor=facecolor,\n531                                         edgecolor=edgecolor,\n532                                         frameon=frameon,\n533                                         FigureClass=FigureClass,\n534                                         **kwargs)\n535 \n536         if figLabel:\n537             figManager.set_window_title(figLabel)\n538             figManager.canvas.figure.set_label(figLabel)\n539 \n540         # make this figure current on button press event\n541         def make_active(event):\n542             _pylab_helpers.Gcf.set_active(figManager)\n543 \n544         cid = figManager.canvas.mpl_connect('button_press_event', make_active)\n545         figManager._cidgcf = cid\n546 \n547         _pylab_helpers.Gcf.set_active(figManager)\n548         fig = figManager.canvas.figure\n549         fig.number = num\n550 \n551         # make sure backends (inline) that we don't ship that expect this\n552         # to be called in plotting commands to make the figure call show\n553         # still work.  There is probably a better way to do this in the\n554         # FigureManager base class.\n555         if matplotlib.is_interactive():\n556             draw_if_interactive()\n557 \n558         if _INSTALL_FIG_OBSERVER:\n559             fig.stale_callback = _auto_draw_if_interactive\n560 \n561     if clear:\n562         figManager.canvas.figure.clear()\n563 \n564     return figManager.canvas.figure\n565 \n566 \n567 def _auto_draw_if_interactive(fig, val):\n568     \"\"\"\n569     This is an internal helper function for making sure that auto-redrawing\n570     works as intended in the plain python repl.\n571 \n572     Parameters\n573     ----------\n574     fig : Figure\n575         A figure object which is assumed to be associated with a canvas\n576     \"\"\"\n577     if val and matplotlib.is_interactive() and not fig.canvas.is_saving():\n578         fig.canvas.draw_idle()\n579 \n580 \n581 def gcf():\n582     \"\"\"Get a reference to the current figure.\"\"\"\n583     figManager = _pylab_helpers.Gcf.get_active()\n584     if figManager is not None:\n585         return figManager.canvas.figure\n586     else:\n587         return figure()\n588 \n589 \n590 def fignum_exists(num):\n591     \"\"\"Return whether the figure with the given id exists.\"\"\"\n592     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()\n593 \n594 \n595 def get_fignums():\n596     \"\"\"Return a list of existing figure numbers.\"\"\"\n597     return sorted(_pylab_helpers.Gcf.figs)\n598 \n599 \n600 def get_figlabels():\n601     \"\"\"Return a list of existing figure labels.\"\"\"\n602     figManagers = _pylab_helpers.Gcf.get_all_fig_managers()\n603     figManagers.sort(key=lambda m: m.num)\n604     return [m.canvas.figure.get_label() for m in figManagers]\n605 \n606 \n607 def get_current_fig_manager():\n608     \"\"\"\n609     Return the figure manager of the active figure.\n610 \n611     If there is currently no active figure, a new one is created.\n612     \"\"\"\n613     figManager = _pylab_helpers.Gcf.get_active()\n614     if figManager is None:\n615         gcf()  # creates an active figure as a side effect\n616         figManager = _pylab_helpers.Gcf.get_active()\n617     return figManager\n618 \n619 \n620 @docstring.copy(FigureCanvasBase.mpl_connect)\n621 def connect(s, func):\n622     return get_current_fig_manager().canvas.mpl_connect(s, func)\n623 \n624 \n625 @docstring.copy(FigureCanvasBase.mpl_disconnect)\n626 def disconnect(cid):\n627     return get_current_fig_manager().canvas.mpl_disconnect(cid)\n628 \n629 \n630 def close(fig=None):\n631     \"\"\"\n632     Close a figure window.\n633 \n634     Parameters\n635     ----------\n636     fig : None or int or str or `.Figure`\n637         The figure to close. There are a number of ways to specify this:\n638 \n639         - *None*: the current figure\n640         - `.Figure`: the given `.Figure` instance\n641         - ``int``: a figure number\n642         - ``str``: a figure name\n643         - 'all': all figures\n644 \n645     \"\"\"\n646     if fig is None:\n647         figManager = _pylab_helpers.Gcf.get_active()\n648         if figManager is None:\n649             return\n650         else:\n651             _pylab_helpers.Gcf.destroy(figManager.num)\n652     elif fig == 'all':\n653         _pylab_helpers.Gcf.destroy_all()\n654     elif isinstance(fig, int):\n655         _pylab_helpers.Gcf.destroy(fig)\n656     elif hasattr(fig, 'int'):\n657         # if we are dealing with a type UUID, we\n658         # can use its integer representation\n659         _pylab_helpers.Gcf.destroy(fig.int)\n660     elif isinstance(fig, str):\n661         allLabels = get_figlabels()\n662         if fig in allLabels:\n663             num = get_fignums()[allLabels.index(fig)]\n664             _pylab_helpers.Gcf.destroy(num)\n665     elif isinstance(fig, Figure):\n666         _pylab_helpers.Gcf.destroy_fig(fig)\n667     else:\n668         raise TypeError(\"close() argument must be a Figure, an int, a string, \"\n669                         \"or None, not '%s'\")\n670 \n671 \n672 def clf():\n673     \"\"\"Clear the current figure.\"\"\"\n674     gcf().clf()\n675 \n676 \n677 def draw():\n678     \"\"\"Redraw the current figure.\n679 \n680     This is used to update a figure that has been altered, but not\n681     automatically re-drawn.  If interactive mode is on (:func:`.ion()`), this\n682     should be only rarely needed, but there may be ways to modify the state of\n683     a figure without marking it as `stale`.  Please report these cases as\n684     bugs.\n685 \n686     A more object-oriented alternative, given any\n687     :class:`~matplotlib.figure.Figure` instance, :attr:`fig`, that\n688     was created using a :mod:`~matplotlib.pyplot` function, is::\n689 \n690         fig.canvas.draw_idle()\n691     \"\"\"\n692     get_current_fig_manager().canvas.draw_idle()\n693 \n694 \n695 @docstring.copy(Figure.savefig)\n696 def savefig(*args, **kwargs):\n697     fig = gcf()\n698     res = fig.savefig(*args, **kwargs)\n699     fig.canvas.draw_idle()   # need this if 'transparent=True' to reset colors\n700     return res\n701 \n702 \n703 ## Putting things in figures ##\n704 \n705 \n706 def figlegend(*args, **kwargs):\n707     return gcf().legend(*args, **kwargs)\n708 if Figure.legend.__doc__:\n709     figlegend.__doc__ = Figure.legend.__doc__.replace(\"legend(\", \"figlegend(\")\n710 \n711 \n712 ## Axes ##\n713 \n714 @docstring.dedent_interpd\n715 def axes(arg=None, **kwargs):\n716     \"\"\"\n717     Add an axes to the current figure and make it the current axes.\n718 \n719     Call signatures::\n720 \n721         plt.axes()\n722         plt.axes(rect, projection=None, polar=False, **kwargs)\n723         plt.axes(ax)\n724 \n725     Parameters\n726     ----------\n727     arg : { None, 4-tuple, Axes }\n728         The exact behavior of this function depends on the type:\n729 \n730         - *None*: A new full window axes is added using\n731           ``subplot(111, **kwargs)``\n732         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.\n733           A new axes is added with dimensions *rect* in normalized\n734           (0, 1) units using `~.Figure.add_axes` on the current figure.\n735         - `~.axes.Axes`: This is equivalent to `.pyplot.sca`.\n736           It sets the current axes to *arg*. Note: This implicitly\n737           changes the current figure to the parent of *arg*.\n738 \n739           .. note:: The use of an `.axes.Axes` as an argument is deprecated\n740                     and will be removed in v3.0. Please use `.pyplot.sca`\n741                     instead.\n742 \n743     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n744 'polar', 'rectilinear', str}, optional\n745         The projection type of the `~.axes.Axes`. *str* is the name of\n746         a costum projection, see `~matplotlib.projections`. The default\n747         None results in a 'rectilinear' projection.\n748 \n749     polar : boolean, optional\n750         If True, equivalent to projection='polar'.\n751 \n752     sharex, sharey : `~.axes.Axes`, optional\n753         Share the x or y `~matplotlib.axis` with sharex and/or sharey.\n754         The axis will have the same limits, ticks, and scale as the axis\n755         of the shared axes.\n756 \n757 \n758     label : str\n759         A label for the returned axes.\n760 \n761     Other Parameters\n762     ----------------\n763     **kwargs\n764         This method also takes the keyword arguments for\n765         the returned axes class. The keyword arguments for the\n766         rectilinear axes class `~.axes.Axes` can be found in\n767         the following table but there might also be other keyword\n768         arguments if another projection is used, see the actual axes\n769         class.\n770         %(Axes)s\n771 \n772     Returns\n773     -------\n774     axes : `~.axes.Axes` (or a subclass of `~.axes.Axes`)\n775         The returned axes class depends on the projection used. It is\n776         `~.axes.Axes` if rectilinear projection are used and\n777         `.projections.polar.PolarAxes` if polar projection\n778         are used.\n779 \n780     Notes\n781     -----\n782     If the figure already has a axes with key (*args*,\n783     *kwargs*) then it will simply make that axes current and\n784     return it.  This behavior is deprecated. Meanwhile, if you do\n785     not want this behavior (i.e., you want to force the creation of a\n786     new axes), you must use a unique set of args and kwargs.  The axes\n787     *label* attribute has been exposed for this purpose: if you want\n788     two axes that are otherwise identical to be added to the figure,\n789     make sure you give them unique labels.\n790 \n791     See Also\n792     --------\n793     .Figure.add_axes\n794     .pyplot.subplot\n795     .Figure.add_subplot\n796     .Figure.subplots\n797     .pyplot.subplots\n798 \n799     Examples\n800     --------\n801     ::\n802 \n803         # Creating a new full window axes\n804         plt.axes()\n805 \n806         # Creating a new axes with specified dimensions and some kwargs\n807         plt.axes((left, bottom, width, height), facecolor='w')\n808     \"\"\"\n809 \n810     if arg is None:\n811         return subplot(111, **kwargs)\n812     else:\n813         return gcf().add_axes(arg, **kwargs)\n814 \n815 \n816 def delaxes(ax=None):\n817     \"\"\"\n818     Remove the `Axes` *ax* (defaulting to the current axes) from its figure.\n819 \n820     A KeyError is raised if the axes doesn't exist.\n821     \"\"\"\n822     if ax is None:\n823         ax = gca()\n824     ax.figure.delaxes(ax)\n825 \n826 \n827 def sca(ax):\n828     \"\"\"\n829     Set the current Axes instance to *ax*.\n830 \n831     The current Figure is updated to the parent of *ax*.\n832     \"\"\"\n833     managers = _pylab_helpers.Gcf.get_all_fig_managers()\n834     for m in managers:\n835         if ax in m.canvas.figure.axes:\n836             _pylab_helpers.Gcf.set_active(m)\n837             m.canvas.figure.sca(ax)\n838             return\n839     raise ValueError(\"Axes instance argument was not found in a figure\")\n840 \n841 \n842 def gca(**kwargs):\n843     \"\"\"\n844     Get the current :class:`~matplotlib.axes.Axes` instance on the\n845     current figure matching the given keyword args, or create one.\n846 \n847     Examples\n848     --------\n849     To get the current polar axes on the current figure::\n850 \n851         plt.gca(projection='polar')\n852 \n853     If the current axes doesn't exist, or isn't a polar one, the appropriate\n854     axes will be created and then returned.\n855 \n856     See Also\n857     --------\n858     matplotlib.figure.Figure.gca : The figure's gca method.\n859     \"\"\"\n860     return gcf().gca(**kwargs)\n861 \n862 \n863 ## More ways of creating axes ##\n864 \n865 @docstring.dedent_interpd\n866 def subplot(*args, **kwargs):\n867     \"\"\"\n868     Add a subplot to the current figure.\n869 \n870     Wrapper of `.Figure.add_subplot` with a difference in behavior\n871     explained in the notes section.\n872 \n873     Call signatures::\n874 \n875        subplot(nrows, ncols, index, **kwargs)\n876        subplot(pos, **kwargs)\n877        subplot(ax)\n878 \n879     Parameters\n880     ----------\n881     *args\n882         Either a 3-digit integer or three separate integers\n883         describing the position of the subplot. If the three\n884         integers are *nrows*, *ncols*, and *index* in order, the\n885         subplot will take the *index* position on a grid with *nrows*\n886         rows and *ncols* columns. *index* starts at 1 in the upper left\n887         corner and increases to the right.\n888 \n889         *pos* is a three digit integer, where the first digit is the\n890         number of rows, the second the number of columns, and the third\n891         the index of the subplot. i.e. fig.add_subplot(235) is the same as\n892         fig.add_subplot(2, 3, 5). Note that all integers must be less than\n893         10 for this form to work.\n894 \n895     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \\\n896 'polar', 'rectilinear', str}, optional\n897         The projection type of the subplot (`~.axes.Axes`). *str* is the name\n898         of a costum projection, see `~matplotlib.projections`. The default\n899         None results in a 'rectilinear' projection.\n900 \n901     polar : boolean, optional\n902         If True, equivalent to projection='polar'.\n903 \n904     sharex, sharey : `~.axes.Axes`, optional\n905         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The\n906         axis will have the same limits, ticks, and scale as the axis of the\n907         shared axes.\n908 \n909     label : str\n910         A label for the returned axes.\n911 \n912     Other Parameters\n913     ----------------\n914     **kwargs\n915         This method also takes the keyword arguments for\n916         the returned axes base class. The keyword arguments for the\n917         rectilinear base class `~.axes.Axes` can be found in\n918         the following table but there might also be other keyword\n919         arguments if another projection is used.\n920         %(Axes)s\n921 \n922     Returns\n923     -------\n924     axes : an `.axes.SubplotBase` subclass of `~.axes.Axes` (or a subclass \\\n925     of `~.axes.Axes`)\n926 \n927         The axes of the subplot. The returned axes base class depends on\n928         the projection used. It is `~.axes.Axes` if rectilinear projection\n929         are used and `.projections.polar.PolarAxes` if polar projection\n930         are used. The returned axes is then a subplot subclass of the\n931         base class.\n932 \n933     Notes\n934     -----\n935     Creating a subplot will delete any pre-existing subplot that overlaps\n936     with it beyond sharing a boundary::\n937 \n938         import matplotlib.pyplot as plt\n939         # plot a line, implicitly creating a subplot(111)\n940         plt.plot([1,2,3])\n941         # now create a subplot which represents the top plot of a grid\n942         # with 2 rows and 1 column. Since this subplot will overlap the\n943         # first, the plot (and its axes) previously created, will be removed\n944         plt.subplot(211)\n945 \n946     If you do not want this behavior, use the `.Figure.add_subplot` method\n947     or the `.pyplot.axes` function instead.\n948 \n949     If the figure already has a subplot with key (*args*,\n950     *kwargs*) then it will simply make that subplot current and\n951     return it.  This behavior is deprecated. Meanwhile, if you do\n952     not want this behavior (i.e., you want to force the creation of a\n953     new subplot), you must use a unique set of args and kwargs.  The axes\n954     *label* attribute has been exposed for this purpose: if you want\n955     two subplots that are otherwise identical to be added to the figure,\n956     make sure you give them unique labels.\n957 \n958     In rare circumstances, `.add_subplot` may be called with a single\n959     argument, a subplot axes instance already created in the\n960     present figure but not in the figure's list of axes.\n961 \n962     See Also\n963     --------\n964     .Figure.add_subplot\n965     .pyplot.subplots\n966     .pyplot.axes\n967     .Figure.subplots\n968 \n969     Examples\n970     --------\n971     ::\n972 \n973         plt.subplot(221)\n974 \n975         # equivalent but more general\n976         ax1=plt.subplot(2, 2, 1)\n977 \n978         # add a subplot with no frame\n979         ax2=plt.subplot(222, frameon=False)\n980 \n981         # add a polar subplot\n982         plt.subplot(223, projection='polar')\n983 \n984         # add a red subplot that shares the x-axis with ax1\n985         plt.subplot(224, sharex=ax1, facecolor='red')\n986 \n987         # delete ax2 from the figure\n988         plt.delaxes(ax2)\n989 \n990         # add ax2 to the figure again\n991         plt.subplot(ax2)\n992         \"\"\"\n993 \n994     # if subplot called without arguments, create subplot(1,1,1)\n995     if len(args) == 0:\n996         args = (1, 1, 1)\n997 \n998     # This check was added because it is very easy to type\n999     # subplot(1, 2, False) when subplots(1, 2, False) was intended\n1000     # (sharex=False, that is). In most cases, no error will\n1001     # ever occur, but mysterious behavior can result because what was\n1002     # intended to be the sharex argument is instead treated as a\n1003     # subplot index for subplot()\n1004     if len(args) >= 3 and isinstance(args[2], bool):\n1005         cbook._warn_external(\"The subplot index argument to subplot() appears \"\n1006                              \"to be a boolean. Did you intend to use \"\n1007                              \"subplots()?\")\n1008 \n1009     fig = gcf()\n1010     a = fig.add_subplot(*args, **kwargs)\n1011     bbox = a.bbox\n1012     byebye = []\n1013     for other in fig.axes:\n1014         if other == a:\n1015             continue\n1016         if bbox.fully_overlaps(other.bbox):\n1017             byebye.append(other)\n1018     for ax in byebye:\n1019         delaxes(ax)\n1020 \n1021     return a\n1022 \n1023 \n1024 def subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True,\n1025              subplot_kw=None, gridspec_kw=None, **fig_kw):\n1026     \"\"\"\n1027     Create a figure and a set of subplots.\n1028 \n1029     This utility wrapper makes it convenient to create common layouts of\n1030     subplots, including the enclosing figure object, in a single call.\n1031 \n1032     Parameters\n1033     ----------\n1034     nrows, ncols : int, optional, default: 1\n1035         Number of rows/columns of the subplot grid.\n1036 \n1037     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False\n1038         Controls sharing of properties among x (`sharex`) or y (`sharey`)\n1039         axes:\n1040 \n1041             - True or 'all': x- or y-axis will be shared among all\n1042               subplots.\n1043             - False or 'none': each subplot x- or y-axis will be\n1044               independent.\n1045             - 'row': each subplot row will share an x- or y-axis.\n1046             - 'col': each subplot column will share an x- or y-axis.\n1047 \n1048         When subplots have a shared x-axis along a column, only the x tick\n1049         labels of the bottom subplot are created. Similarly, when subplots\n1050         have a shared y-axis along a row, only the y tick labels of the first\n1051         column subplot are created. To later turn other subplots' ticklabels\n1052         on, use `~matplotlib.axes.Axes.tick_params`.\n1053 \n1054     squeeze : bool, optional, default: True\n1055         - If True, extra dimensions are squeezed out from the returned\n1056           array of `~matplotlib.axes.Axes`:\n1057 \n1058             - if only one subplot is constructed (nrows=ncols=1), the\n1059               resulting single Axes object is returned as a scalar.\n1060             - for Nx1 or 1xM subplots, the returned object is a 1D numpy\n1061               object array of Axes objects.\n1062             - for NxM, subplots with N>1 and M>1 are returned as a 2D array.\n1063 \n1064         - If False, no squeezing at all is done: the returned Axes object is\n1065           always a 2D array containing Axes instances, even if it ends up\n1066           being 1x1.\n1067 \n1068     num : integer or string, optional, default: None\n1069         A `.pyplot.figure` keyword that sets the figure number or label.\n1070 \n1071     subplot_kw : dict, optional\n1072         Dict with keywords passed to the\n1073         `~matplotlib.figure.Figure.add_subplot` call used to create each\n1074         subplot.\n1075 \n1076     gridspec_kw : dict, optional\n1077         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`\n1078         constructor used to create the grid the subplots are placed on.\n1079 \n1080     **fig_kw\n1081         All additional keyword arguments are passed to the\n1082         `.pyplot.figure` call.\n1083 \n1084     Returns\n1085     -------\n1086     fig : `~.figure.Figure`\n1087 \n1088     ax : `.axes.Axes` object or array of Axes objects.\n1089         *ax* can be either a single `~matplotlib.axes.Axes` object or an\n1090         array of Axes objects if more than one subplot was created.  The\n1091         dimensions of the resulting array can be controlled with the squeeze\n1092         keyword, see above.\n1093 \n1094     Examples\n1095     --------\n1096     ::\n1097 \n1098         # First create some toy data:\n1099         x = np.linspace(0, 2*np.pi, 400)\n1100         y = np.sin(x**2)\n1101 \n1102         # Creates just a figure and only one subplot\n1103         fig, ax = plt.subplots()\n1104         ax.plot(x, y)\n1105         ax.set_title('Simple plot')\n1106 \n1107         # Creates two subplots and unpacks the output array immediately\n1108         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n1109         ax1.plot(x, y)\n1110         ax1.set_title('Sharing Y axis')\n1111         ax2.scatter(x, y)\n1112 \n1113         # Creates four polar axes, and accesses them through the returned array\n1114         fig, axes = plt.subplots(2, 2, subplot_kw=dict(polar=True))\n1115         axes[0, 0].plot(x, y)\n1116         axes[1, 1].scatter(x, y)\n1117 \n1118         # Share a X axis with each column of subplots\n1119         plt.subplots(2, 2, sharex='col')\n1120 \n1121         # Share a Y axis with each row of subplots\n1122         plt.subplots(2, 2, sharey='row')\n1123 \n1124         # Share both X and Y axes with all subplots\n1125         plt.subplots(2, 2, sharex='all', sharey='all')\n1126 \n1127         # Note that this is the same as\n1128         plt.subplots(2, 2, sharex=True, sharey=True)\n1129 \n1130         # Creates figure number 10 with a single subplot\n1131         # and clears it if it already exists.\n1132         fig, ax=plt.subplots(num=10, clear=True)\n1133 \n1134     See Also\n1135     --------\n1136     .pyplot.figure\n1137     .pyplot.subplot\n1138     .pyplot.axes\n1139     .Figure.subplots\n1140     .Figure.add_subplot\n1141 \n1142     \"\"\"\n1143     fig = figure(**fig_kw)\n1144     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,\n1145                        squeeze=squeeze, subplot_kw=subplot_kw,\n1146                        gridspec_kw=gridspec_kw)\n1147     return fig, axs\n1148 \n1149 \n1150 def subplot2grid(shape, loc, rowspan=1, colspan=1, fig=None, **kwargs):\n1151     \"\"\"\n1152     Create an axis at specific location inside a regular grid.\n1153 \n1154     Parameters\n1155     ----------\n1156     shape : sequence of 2 ints\n1157         Shape of grid in which to place axis.\n1158         First entry is number of rows, second entry is number of columns.\n1159 \n1160     loc : sequence of 2 ints\n1161         Location to place axis within grid.\n1162         First entry is row number, second entry is column number.\n1163 \n1164     rowspan : int\n1165         Number of rows for the axis to span to the right.\n1166 \n1167     colspan : int\n1168         Number of columns for the axis to span downwards.\n1169 \n1170     fig : `Figure`, optional\n1171         Figure to place axis in. Defaults to current figure.\n1172 \n1173     **kwargs\n1174         Additional keyword arguments are handed to `add_subplot`.\n1175 \n1176 \n1177     Notes\n1178     -----\n1179     The following call ::\n1180 \n1181         subplot2grid(shape, loc, rowspan=1, colspan=1)\n1182 \n1183     is identical to ::\n1184 \n1185         gridspec=GridSpec(shape[0], shape[1])\n1186         subplotspec=gridspec.new_subplotspec(loc, rowspan, colspan)\n1187         subplot(subplotspec)\n1188     \"\"\"\n1189 \n1190     if fig is None:\n1191         fig = gcf()\n1192 \n1193     s1, s2 = shape\n1194     subplotspec = GridSpec(s1, s2).new_subplotspec(loc,\n1195                                                    rowspan=rowspan,\n1196                                                    colspan=colspan)\n1197     a = fig.add_subplot(subplotspec, **kwargs)\n1198     bbox = a.bbox\n1199     byebye = []\n1200     for other in fig.axes:\n1201         if other == a:\n1202             continue\n1203         if bbox.fully_overlaps(other.bbox):\n1204             byebye.append(other)\n1205     for ax in byebye:\n1206         delaxes(ax)\n1207 \n1208     return a\n1209 \n1210 \n1211 def twinx(ax=None):\n1212     \"\"\"\n1213     Make a second axes that shares the *x*-axis.  The new axes will\n1214     overlay *ax* (or the current axes if *ax* is *None*).  The ticks\n1215     for *ax2* will be placed on the right, and the *ax2* instance is\n1216     returned.\n1217 \n1218     .. seealso::\n1219 \n1220        :doc:`/gallery/subplots_axes_and_figures/two_scales`\n1221 \n1222     \"\"\"\n1223     if ax is None:\n1224         ax = gca()\n1225     ax1 = ax.twinx()\n1226     return ax1\n1227 \n1228 \n1229 def twiny(ax=None):\n1230     \"\"\"\n1231     Make a second axes that shares the *y*-axis.  The new axis will\n1232     overlay *ax* (or the current axes if *ax* is *None*).  The ticks\n1233     for *ax2* will be placed on the top, and the *ax2* instance is\n1234     returned.\n1235     \"\"\"\n1236     if ax is None:\n1237         ax = gca()\n1238     ax1 = ax.twiny()\n1239     return ax1\n1240 \n1241 \n1242 def subplots_adjust(left=None, bottom=None, right=None, top=None,\n1243                     wspace=None, hspace=None):\n1244     \"\"\"\n1245     Tune the subplot layout.\n1246 \n1247     The parameter meanings (and suggested defaults) are::\n1248 \n1249       left = 0.125  # the left side of the subplots of the figure\n1250       right = 0.9   # the right side of the subplots of the figure\n1251       bottom = 0.1  # the bottom of the subplots of the figure\n1252       top = 0.9     # the top of the subplots of the figure\n1253       wspace = 0.2  # the amount of width reserved for space between subplots,\n1254                     # expressed as a fraction of the average axis width\n1255       hspace = 0.2  # the amount of height reserved for space between subplots,\n1256                     # expressed as a fraction of the average axis height\n1257 \n1258     The actual defaults are controlled by the rc file\n1259     \"\"\"\n1260     fig = gcf()\n1261     fig.subplots_adjust(left, bottom, right, top, wspace, hspace)\n1262 \n1263 \n1264 def subplot_tool(targetfig=None):\n1265     \"\"\"\n1266     Launch a subplot tool window for a figure.\n1267 \n1268     A :class:`matplotlib.widgets.SubplotTool` instance is returned.\n1269     \"\"\"\n1270     tbar = rcParams['toolbar']  # turn off navigation toolbar for the toolfig\n1271     rcParams['toolbar'] = 'None'\n1272     if targetfig is None:\n1273         manager = get_current_fig_manager()\n1274         targetfig = manager.canvas.figure\n1275     else:\n1276         # find the manager for this figure\n1277         for manager in _pylab_helpers.Gcf._activeQue:\n1278             if manager.canvas.figure == targetfig:\n1279                 break\n1280         else:\n1281             raise RuntimeError('Could not find manager for targetfig')\n1282 \n1283     toolfig = figure(figsize=(6, 3))\n1284     toolfig.subplots_adjust(top=0.9)\n1285     ret = SubplotTool(targetfig, toolfig)\n1286     rcParams['toolbar'] = tbar\n1287     _pylab_helpers.Gcf.set_active(manager)  # restore the current figure\n1288     return ret\n1289 \n1290 \n1291 def tight_layout(pad=1.08, h_pad=None, w_pad=None, rect=None):\n1292     \"\"\"\n1293     Automatically adjust subplot parameters to give specified padding.\n1294 \n1295     Parameters\n1296     ----------\n1297     pad : float\n1298         Padding between the figure edge and the edges of subplots,\n1299         as a fraction of the font size.\n1300     h_pad, w_pad : float, optional\n1301         Padding (height/width) between edges of adjacent subplots,\n1302         as a fraction of the font size.  Defaults to *pad*.\n1303     rect : tuple (left, bottom, right, top), optional\n1304         A rectangle (left, bottom, right, top) in the normalized\n1305         figure coordinate that the whole subplots area (including\n1306         labels) will fit into. Default is (0, 0, 1, 1).\n1307     \"\"\"\n1308     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)\n1309 \n1310 \n1311 def box(on=None):\n1312     \"\"\"\n1313     Turn the axes box on or off on the current axes.\n1314 \n1315     Parameters\n1316     ----------\n1317     on : bool or None\n1318         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle\n1319         the state.\n1320 \n1321     See Also\n1322     --------\n1323     :meth:`matplotlib.axes.Axes.set_frame_on`\n1324     :meth:`matplotlib.axes.Axes.get_frame_on`\n1325     \"\"\"\n1326     ax = gca()\n1327     if on is None:\n1328         on = not ax.get_frame_on()\n1329     ax.set_frame_on(on)\n1330 \n1331 ## Axis ##\n1332 \n1333 \n1334 def xlim(*args, **kwargs):\n1335     \"\"\"\n1336     Get or set the x limits of the current axes.\n1337 \n1338     Call signatures::\n1339 \n1340         left, right = xlim()  # return the current xlim\n1341         xlim((left, right))   # set the xlim to left, right\n1342         xlim(left, right)     # set the xlim to left, right\n1343 \n1344     If you do not specify args, you can pass *left* or *right* as kwargs,\n1345     i.e.::\n1346 \n1347         xlim(right=3)  # adjust the right leaving left unchanged\n1348         xlim(left=1)  # adjust the left leaving right unchanged\n1349 \n1350     Setting limits turns autoscaling off for the x-axis.\n1351 \n1352     Returns\n1353     -------\n1354     left, right\n1355         A tuple of the new x-axis limits.\n1356 \n1357     Notes\n1358     -----\n1359     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot\n1360     equivalent of calling `~.Axes.get_xlim` on the current axes.\n1361     Calling this function with arguments is the pyplot equivalent of calling\n1362     `~.Axes.set_xlim` on the current axes. All arguments are passed though.\n1363     \"\"\"\n1364     ax = gca()\n1365     if not args and not kwargs:\n1366         return ax.get_xlim()\n1367     ret = ax.set_xlim(*args, **kwargs)\n1368     return ret\n1369 \n1370 \n1371 def ylim(*args, **kwargs):\n1372     \"\"\"\n1373     Get or set the y-limits of the current axes.\n1374 \n1375     Call signatures::\n1376 \n1377         bottom, top = ylim()  # return the current ylim\n1378         ylim((bottom, top))   # set the ylim to bottom, top\n1379         ylim(bottom, top)     # set the ylim to bottom, top\n1380 \n1381     If you do not specify args, you can alternatively pass *bottom* or\n1382     *top* as kwargs, i.e.::\n1383 \n1384         ylim(top=3)  # adjust the top leaving bottom unchanged\n1385         ylim(bottom=1)  # adjust the bottom leaving top unchanged\n1386 \n1387     Setting limits turns autoscaling off for the y-axis.\n1388 \n1389     Returns\n1390     -------\n1391     bottom, top\n1392         A tuple of the new y-axis limits.\n1393 \n1394     Notes\n1395     -----\n1396     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot\n1397     equivalent of calling `~.Axes.get_ylim` on the current axes.\n1398     Calling this function with arguments is the pyplot equivalent of calling\n1399     `~.Axes.set_ylim` on the current axes. All arguments are passed though.\n1400     \"\"\"\n1401     ax = gca()\n1402     if not args and not kwargs:\n1403         return ax.get_ylim()\n1404     ret = ax.set_ylim(*args, **kwargs)\n1405     return ret\n1406 \n1407 \n1408 def xticks(ticks=None, labels=None, **kwargs):\n1409     \"\"\"\n1410     Get or set the current tick locations and labels of the x-axis.\n1411 \n1412     Call signatures::\n1413 \n1414         locs, labels = xticks()            # Get locations and labels\n1415         xticks(ticks, [labels], **kwargs)  # Set locations and labels\n1416 \n1417     Parameters\n1418     ----------\n1419     ticks : array_like\n1420         A list of positions at which ticks should be placed. You can pass an\n1421         empty list to disable xticks.\n1422 \n1423     labels : array_like, optional\n1424         A list of explicit labels to place at the given *locs*.\n1425 \n1426     **kwargs\n1427         :class:`.Text` properties can be used to control the appearance of\n1428         the labels.\n1429 \n1430     Returns\n1431     -------\n1432     locs\n1433         An array of label locations.\n1434     labels\n1435         A list of `.Text` objects.\n1436 \n1437     Notes\n1438     -----\n1439     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot\n1440     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on\n1441     the current axes.\n1442     Calling this function with arguments is the pyplot equivalent of calling\n1443     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.\n1444 \n1445     Examples\n1446     --------\n1447     Get the current locations and labels:\n1448 \n1449         >>> locs, labels = xticks()\n1450 \n1451     Set label locations:\n1452 \n1453         >>> xticks(np.arange(0, 1, step=0.2))\n1454 \n1455     Set text labels:\n1456 \n1457         >>> xticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))\n1458 \n1459     Set text labels and properties:\n1460 \n1461         >>> xticks(np.arange(12), calendar.month_name[1:13], rotation=20)\n1462 \n1463     Disable xticks:\n1464 \n1465         >>> xticks([])\n1466     \"\"\"\n1467     ax = gca()\n1468 \n1469     if ticks is None and labels is None:\n1470         locs = ax.get_xticks()\n1471         labels = ax.get_xticklabels()\n1472     elif labels is None:\n1473         locs = ax.set_xticks(ticks)\n1474         labels = ax.get_xticklabels()\n1475     else:\n1476         locs = ax.set_xticks(ticks)\n1477         labels = ax.set_xticklabels(labels, **kwargs)\n1478     for l in labels:\n1479         l.update(kwargs)\n1480 \n1481     return locs, silent_list('Text xticklabel', labels)\n1482 \n1483 \n1484 def yticks(ticks=None, labels=None, **kwargs):\n1485     \"\"\"\n1486     Get or set the current tick locations and labels of the y-axis.\n1487 \n1488     Call signatures::\n1489 \n1490         locs, labels = yticks()            # Get locations and labels\n1491         yticks(ticks, [labels], **kwargs)  # Set locations and labels\n1492 \n1493     Parameters\n1494     ----------\n1495     ticks : array_like\n1496         A list of positions at which ticks should be placed. You can pass an\n1497         empty list to disable yticks.\n1498 \n1499     labels : array_like, optional\n1500         A list of explicit labels to place at the given *locs*.\n1501 \n1502     **kwargs\n1503         :class:`.Text` properties can be used to control the appearance of\n1504         the labels.\n1505 \n1506     Returns\n1507     -------\n1508     locs\n1509         An array of label locations.\n1510     labels\n1511         A list of `.Text` objects.\n1512 \n1513     Notes\n1514     -----\n1515     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot\n1516     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on\n1517     the current axes.\n1518     Calling this function with arguments is the pyplot equivalent of calling\n1519     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.\n1520 \n1521     Examples\n1522     --------\n1523     Get the current locations and labels:\n1524 \n1525         >>> locs, labels = yticks()\n1526 \n1527     Set label locations:\n1528 \n1529         >>> yticks(np.arange(0, 1, step=0.2))\n1530 \n1531     Set text labels:\n1532 \n1533         >>> yticks(np.arange(5), ('Tom', 'Dick', 'Harry', 'Sally', 'Sue'))\n1534 \n1535     Set text labels and properties:\n1536 \n1537         >>> yticks(np.arange(12), calendar.month_name[1:13], rotation=45)\n1538 \n1539     Disable yticks:\n1540 \n1541         >>> yticks([])\n1542     \"\"\"\n1543     ax = gca()\n1544 \n1545     if ticks is None and labels is None:\n1546         locs = ax.get_yticks()\n1547         labels = ax.get_yticklabels()\n1548     elif labels is None:\n1549         locs = ax.set_yticks(ticks)\n1550         labels = ax.get_yticklabels()\n1551     else:\n1552         locs = ax.set_yticks(ticks)\n1553         labels = ax.set_yticklabels(labels, **kwargs)\n1554     for l in labels:\n1555         l.update(kwargs)\n1556 \n1557     return locs, silent_list('Text yticklabel', labels)\n1558 \n1559 \n1560 def rgrids(*args, **kwargs):\n1561     \"\"\"\n1562     Get or set the radial gridlines on the current polar plot.\n1563 \n1564     Call signatures::\n1565 \n1566      lines, labels = rgrids()\n1567      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)\n1568 \n1569     When called with no arguments, `.rgrids` simply returns the tuple\n1570     (*lines*, *labels*). When called with arguments, the labels will\n1571     appear at the specified radial distances and angle.\n1572 \n1573     Parameters\n1574     ----------\n1575     radii : tuple with floats\n1576         The radii for the radial gridlines\n1577 \n1578     labels : tuple with strings or None\n1579         The labels to use at each radial gridline. The\n1580         `matplotlib.ticker.ScalarFormatter` will be used if None.\n1581 \n1582     angle : float\n1583         The angular position of the radius labels in degrees.\n1584 \n1585     fmt : str or None\n1586         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1587         For example '%f'.\n1588 \n1589     Returns\n1590     -------\n1591     lines, labels : list of `.lines.Line2D`, list of `.text.Text`\n1592         *lines* are the radial gridlines and *labels* are the tick labels.\n1593 \n1594     Other Parameters\n1595     ----------------\n1596     **kwargs\n1597         *kwargs* are optional `~.Text` properties for the labels.\n1598 \n1599     Examples\n1600     --------\n1601     ::\n1602 \n1603       # set the locations of the radial gridlines\n1604       lines, labels = rgrids( (0.25, 0.5, 1.0) )\n1605 \n1606       # set the locations and labels of the radial gridlines\n1607       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))\n1608 \n1609     See Also\n1610     --------\n1611     .pyplot.thetagrids\n1612     .projections.polar.PolarAxes.set_rgrids\n1613     .Axis.get_gridlines\n1614     .Axis.get_ticklabels\n1615     \"\"\"\n1616     ax = gca()\n1617     if not isinstance(ax, PolarAxes):\n1618         raise RuntimeError('rgrids only defined for polar axes')\n1619     if len(args) == 0:\n1620         lines = ax.yaxis.get_gridlines()\n1621         labels = ax.yaxis.get_ticklabels()\n1622     else:\n1623         lines, labels = ax.set_rgrids(*args, **kwargs)\n1624     return (silent_list('Line2D rgridline', lines),\n1625             silent_list('Text rgridlabel', labels))\n1626 \n1627 \n1628 def thetagrids(*args, **kwargs):\n1629     \"\"\"\n1630     Get or set the theta gridlines on the current polar plot.\n1631 \n1632     Call signatures::\n1633 \n1634      lines, labels = thetagrids()\n1635      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)\n1636 \n1637     When called with no arguments, `.thetagrids` simply returns the tuple\n1638     (*lines*, *labels*). When called with arguments, the labels will\n1639     appear at the specified angles.\n1640 \n1641     Parameters\n1642     ----------\n1643     angles : tuple with floats, degrees\n1644         The angles of the theta gridlines.\n1645 \n1646     labels : tuple with strings or None\n1647         The labels to use at each radial gridline. The\n1648         `.projections.polar.ThetaFormatter` will be used if None.\n1649 \n1650     fmt : str or None\n1651         Format string used in `matplotlib.ticker.FormatStrFormatter`.\n1652         For example '%f'. Note that the angle in radians will be used.\n1653 \n1654     Returns\n1655     -------\n1656     lines, labels : list of `.lines.Line2D`, list of `.text.Text`\n1657         *lines* are the theta gridlines and *labels* are the tick labels.\n1658 \n1659     Other Parameters\n1660     ----------------\n1661     **kwargs\n1662         *kwargs* are optional `~.Text` properties for the labels.\n1663 \n1664     Examples\n1665     --------\n1666     ::\n1667 \n1668       # set the locations of the angular gridlines\n1669       lines, labels = thetagrids( range(45,360,90) )\n1670 \n1671       # set the locations and labels of the angular gridlines\n1672       lines, labels = thetagrids( range(45,360,90), ('NE', 'NW', 'SW','SE') )\n1673 \n1674     See Also\n1675     --------\n1676     .pyplot.rgrids\n1677     .projections.polar.PolarAxes.set_thetagrids\n1678     .Axis.get_gridlines\n1679     .Axis.get_ticklabels\n1680     \"\"\"\n1681     ax = gca()\n1682     if not isinstance(ax, PolarAxes):\n1683         raise RuntimeError('thetagrids only defined for polar axes')\n1684     if len(args) == 0:\n1685         lines = ax.xaxis.get_ticklines()\n1686         labels = ax.xaxis.get_ticklabels()\n1687     else:\n1688         lines, labels = ax.set_thetagrids(*args, **kwargs)\n1689     return (silent_list('Line2D thetagridline', lines),\n1690             silent_list('Text thetagridlabel', labels))\n1691 \n1692 \n1693 ## Plotting Info ##\n1694 \n1695 \n1696 def plotting():\n1697     pass\n1698 \n1699 \n1700 def get_plot_commands():\n1701     \"\"\"\n1702     Get a sorted list of all of the plotting commands.\n1703     \"\"\"\n1704     # This works by searching for all functions in this module and removing\n1705     # a few hard-coded exclusions, as well as all of the colormap-setting\n1706     # functions, and anything marked as private with a preceding underscore.\n1707     exclude = {'colormaps', 'colors', 'connect', 'disconnect',\n1708                'get_plot_commands', 'get_current_fig_manager', 'ginput',\n1709                'plotting', 'waitforbuttonpress'}\n1710     exclude |= set(colormaps())\n1711     this_module = inspect.getmodule(get_plot_commands)\n1712     return sorted(\n1713         name for name, obj in globals().items()\n1714         if not name.startswith('_') and name not in exclude\n1715            and inspect.isfunction(obj)\n1716            and inspect.getmodule(obj) is this_module)\n1717 \n1718 \n1719 def colormaps():\n1720     \"\"\"\n1721     Matplotlib provides a number of colormaps, and others can be added using\n1722     :func:`~matplotlib.cm.register_cmap`.  This function documents the built-in\n1723     colormaps, and will also return a list of all registered colormaps if\n1724     called.\n1725 \n1726     You can set the colormap for an image, pcolor, scatter, etc,\n1727     using a keyword argument::\n1728 \n1729       imshow(X, cmap=cm.hot)\n1730 \n1731     or using the :func:`set_cmap` function::\n1732 \n1733       imshow(X)\n1734       pyplot.set_cmap('hot')\n1735       pyplot.set_cmap('jet')\n1736 \n1737     In interactive mode, :func:`set_cmap` will update the colormap post-hoc,\n1738     allowing you to see which one works best for your data.\n1739 \n1740     All built-in colormaps can be reversed by appending ``_r``: For instance,\n1741     ``gray_r`` is the reverse of ``gray``.\n1742 \n1743     There are several common color schemes used in visualization:\n1744 \n1745     Sequential schemes\n1746       for unipolar data that progresses from low to high\n1747     Diverging schemes\n1748       for bipolar data that emphasizes positive or negative deviations from a\n1749       central value\n1750     Cyclic schemes\n1751       for plotting values that wrap around at the endpoints, such as phase\n1752       angle, wind direction, or time of day\n1753     Qualitative schemes\n1754       for nominal data that has no inherent ordering, where color is used\n1755       only to distinguish categories\n1756 \n1757     Matplotlib ships with 4 perceptually uniform color maps which are\n1758     the recommended color maps for sequential data:\n1759 \n1760       =========   ===================================================\n1761       Colormap    Description\n1762       =========   ===================================================\n1763       inferno     perceptually uniform shades of black-red-yellow\n1764       magma       perceptually uniform shades of black-red-white\n1765       plasma      perceptually uniform shades of blue-red-yellow\n1766       viridis     perceptually uniform shades of blue-green-yellow\n1767       =========   ===================================================\n1768 \n1769     The following colormaps are based on the `ColorBrewer\n1770     <http://colorbrewer2.org>`_ color specifications and designs developed by\n1771     Cynthia Brewer:\n1772 \n1773     ColorBrewer Diverging (luminance is highest at the midpoint, and\n1774     decreases towards differently-colored endpoints):\n1775 \n1776       ========  ===================================\n1777       Colormap  Description\n1778       ========  ===================================\n1779       BrBG      brown, white, blue-green\n1780       PiYG      pink, white, yellow-green\n1781       PRGn      purple, white, green\n1782       PuOr      orange, white, purple\n1783       RdBu      red, white, blue\n1784       RdGy      red, white, gray\n1785       RdYlBu    red, yellow, blue\n1786       RdYlGn    red, yellow, green\n1787       Spectral  red, orange, yellow, green, blue\n1788       ========  ===================================\n1789 \n1790     ColorBrewer Sequential (luminance decreases monotonically):\n1791 \n1792       ========  ====================================\n1793       Colormap  Description\n1794       ========  ====================================\n1795       Blues     white to dark blue\n1796       BuGn      white, light blue, dark green\n1797       BuPu      white, light blue, dark purple\n1798       GnBu      white, light green, dark blue\n1799       Greens    white to dark green\n1800       Greys     white to black (not linear)\n1801       Oranges   white, orange, dark brown\n1802       OrRd      white, orange, dark red\n1803       PuBu      white, light purple, dark blue\n1804       PuBuGn    white, light purple, dark green\n1805       PuRd      white, light purple, dark red\n1806       Purples   white to dark purple\n1807       RdPu      white, pink, dark purple\n1808       Reds      white to dark red\n1809       YlGn      light yellow, dark green\n1810       YlGnBu    light yellow, light green, dark blue\n1811       YlOrBr    light yellow, orange, dark brown\n1812       YlOrRd    light yellow, orange, dark red\n1813       ========  ====================================\n1814 \n1815     ColorBrewer Qualitative:\n1816 \n1817     (For plotting nominal data, :class:`ListedColormap` is used,\n1818     not :class:`LinearSegmentedColormap`.  Different sets of colors are\n1819     recommended for different numbers of categories.)\n1820 \n1821     * Accent\n1822     * Dark2\n1823     * Paired\n1824     * Pastel1\n1825     * Pastel2\n1826     * Set1\n1827     * Set2\n1828     * Set3\n1829 \n1830     A set of colormaps derived from those of the same name provided\n1831     with Matlab are also included:\n1832 \n1833       =========   =======================================================\n1834       Colormap    Description\n1835       =========   =======================================================\n1836       autumn      sequential linearly-increasing shades of red-orange-yellow\n1837       bone        sequential increasing black-white color map with\n1838                   a tinge of blue, to emulate X-ray film\n1839       cool        linearly-decreasing shades of cyan-magenta\n1840       copper      sequential increasing shades of black-copper\n1841       flag        repetitive red-white-blue-black pattern (not cyclic at\n1842                   endpoints)\n1843       gray        sequential linearly-increasing black-to-white\n1844                   grayscale\n1845       hot         sequential black-red-yellow-white, to emulate blackbody\n1846                   radiation from an object at increasing temperatures\n1847       jet         a spectral map with dark endpoints, blue-cyan-yellow-red;\n1848                   based on a fluid-jet simulation by NCSA [#]_\n1849       pink        sequential increasing pastel black-pink-white, meant\n1850                   for sepia tone colorization of photographs\n1851       prism       repetitive red-yellow-green-blue-purple-...-green pattern\n1852                   (not cyclic at endpoints)\n1853       spring      linearly-increasing shades of magenta-yellow\n1854       summer      sequential linearly-increasing shades of green-yellow\n1855       winter      linearly-increasing shades of blue-green\n1856       =========   =======================================================\n1857 \n1858     A set of palettes from the `Yorick scientific visualisation\n1859     package <https://dhmunro.github.io/yorick-doc/>`_, an evolution of\n1860     the GIST package, both by David H. Munro are included:\n1861 \n1862       ============  =======================================================\n1863       Colormap      Description\n1864       ============  =======================================================\n1865       gist_earth    mapmaker's colors from dark blue deep ocean to green\n1866                     lowlands to brown highlands to white mountains\n1867       gist_heat     sequential increasing black-red-orange-white, to emulate\n1868                     blackbody radiation from an iron bar as it grows hotter\n1869       gist_ncar     pseudo-spectral black-blue-green-yellow-red-purple-white\n1870                     colormap from National Center for Atmospheric\n1871                     Research [#]_\n1872       gist_rainbow  runs through the colors in spectral order from red to\n1873                     violet at full saturation (like *hsv* but not cyclic)\n1874       gist_stern    \"Stern special\" color table from Interactive Data\n1875                     Language software\n1876       ============  =======================================================\n1877 \n1878     A set of cyclic color maps:\n1879 \n1880       ================  =================================================\n1881       Colormap          Description\n1882       ================  =================================================\n1883       hsv               red-yellow-green-cyan-blue-magenta-red, formed by\n1884                         changing the hue component in the HSV color space\n1885       twilight          perceptually uniform shades of\n1886                         white-blue-black-red-white\n1887       twilight_shifted  perceptually uniform shades of\n1888                         black-blue-white-red-black\n1889       ================  =================================================\n1890 \n1891 \n1892     Other miscellaneous schemes:\n1893 \n1894       ============= =======================================================\n1895       Colormap      Description\n1896       ============= =======================================================\n1897       afmhot        sequential black-orange-yellow-white blackbody\n1898                     spectrum, commonly used in atomic force microscopy\n1899       brg           blue-red-green\n1900       bwr           diverging blue-white-red\n1901       coolwarm      diverging blue-gray-red, meant to avoid issues with 3D\n1902                     shading, color blindness, and ordering of colors [#]_\n1903       CMRmap        \"Default colormaps on color images often reproduce to\n1904                     confusing grayscale images. The proposed colormap\n1905                     maintains an aesthetically pleasing color image that\n1906                     automatically reproduces to a monotonic grayscale with\n1907                     discrete, quantifiable saturation levels.\" [#]_\n1908       cubehelix     Unlike most other color schemes cubehelix was designed\n1909                     by D.A. Green to be monotonically increasing in terms\n1910                     of perceived brightness. Also, when printed on a black\n1911                     and white postscript printer, the scheme results in a\n1912                     greyscale with monotonically increasing brightness.\n1913                     This color scheme is named cubehelix because the r,g,b\n1914                     values produced can be visualised as a squashed helix\n1915                     around the diagonal in the r,g,b color cube.\n1916       gnuplot       gnuplot's traditional pm3d scheme\n1917                     (black-blue-red-yellow)\n1918       gnuplot2      sequential color printable as gray\n1919                     (black-blue-violet-yellow-white)\n1920       ocean         green-blue-white\n1921       rainbow       spectral purple-blue-green-yellow-orange-red colormap\n1922                     with diverging luminance\n1923       seismic       diverging blue-white-red\n1924       nipy_spectral black-purple-blue-green-yellow-red-white spectrum,\n1925                     originally from the Neuroimaging in Python project\n1926       terrain       mapmaker's colors, blue-green-yellow-brown-white,\n1927                     originally from IGOR Pro\n1928       ============= =======================================================\n1929 \n1930     The following colormaps are redundant and may be removed in future\n1931     versions.  It's recommended to use the names in the descriptions\n1932     instead, which produce identical output:\n1933 \n1934       =========  =======================================================\n1935       Colormap   Description\n1936       =========  =======================================================\n1937       gist_gray  identical to *gray*\n1938       gist_yarg  identical to *gray_r*\n1939       binary     identical to *gray_r*\n1940       =========  =======================================================\n1941 \n1942     .. rubric:: Footnotes\n1943 \n1944     .. [#] Rainbow colormaps, ``jet`` in particular, are considered a poor\n1945       choice for scientific visualization by many researchers: `Rainbow Color\n1946       Map (Still) Considered Harmful\n1947       <http://ieeexplore.ieee.org/document/4118486/?arnumber=4118486>`_\n1948 \n1949     .. [#] Resembles \"BkBlAqGrYeOrReViWh200\" from NCAR Command\n1950       Language. See `Color Table Gallery\n1951       <https://www.ncl.ucar.edu/Document/Graphics/color_table_gallery.shtml>`_\n1952 \n1953     .. [#] See `Diverging Color Maps for Scientific Visualization\n1954       <http://www.kennethmoreland.com/color-maps/>`_ by Kenneth Moreland.\n1955 \n1956     .. [#] See `A Color Map for Effective Black-and-White Rendering of\n1957       Color-Scale Images\n1958       <https://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m>`_\n1959       by Carey Rappaport\n1960     \"\"\"\n1961     return sorted(cm.cmap_d)\n1962 \n1963 \n1964 def _setup_pyplot_info_docstrings():\n1965     \"\"\"\n1966     Generates the plotting docstring.\n1967 \n1968     These must be done after the entire module is imported, so it is\n1969     called from the end of this module, which is generated by\n1970     boilerplate.py.\n1971     \"\"\"\n1972     commands = get_plot_commands()\n1973 \n1974     first_sentence = re.compile(r\"(?:\\s*).+?\\.(?:\\s+|$)\", flags=re.DOTALL)\n1975 \n1976     # Collect the first sentence of the docstring for all of the\n1977     # plotting commands.\n1978     rows = []\n1979     max_name = len(\"Function\")\n1980     max_summary = len(\"Description\")\n1981     for name in commands:\n1982         doc = globals()[name].__doc__\n1983         summary = ''\n1984         if doc is not None:\n1985             match = first_sentence.match(doc)\n1986             if match is not None:\n1987                 summary = inspect.cleandoc(match.group(0)).replace('\\n', ' ')\n1988         name = '`%s`' % name\n1989         rows.append([name, summary])\n1990         max_name = max(max_name, len(name))\n1991         max_summary = max(max_summary, len(summary))\n1992 \n1993     separator = '=' * max_name + ' ' + '=' * max_summary\n1994     lines = [\n1995         separator,\n1996         '{:{}} {:{}}'.format('Function', max_name, 'Description', max_summary),\n1997         separator,\n1998     ] + [\n1999         '{:{}} {:{}}'.format(name, max_name, summary, max_summary)\n2000         for name, summary in rows\n2001     ] + [\n2002         separator,\n2003     ]\n2004     plotting.__doc__ = '\\n'.join(lines)\n2005 \n2006 \n2007 ## Plotting part 1: manually generated functions and wrappers ##\n2008 \n2009 \n2010 def colorbar(mappable=None, cax=None, ax=None, **kw):\n2011     if mappable is None:\n2012         mappable = gci()\n2013         if mappable is None:\n2014             raise RuntimeError('No mappable was found to use for colorbar '\n2015                                'creation. First define a mappable such as '\n2016                                'an image (with imshow) or a contour set ('\n2017                                'with contourf).')\n2018     if ax is None:\n2019         ax = gca()\n2020     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kw)\n2021     return ret\n2022 colorbar.__doc__ = matplotlib.colorbar.colorbar_doc\n2023 \n2024 \n2025 def clim(vmin=None, vmax=None):\n2026     \"\"\"\n2027     Set the color limits of the current image.\n2028 \n2029     To apply clim to all axes images do::\n2030 \n2031       clim(0, 0.5)\n2032 \n2033     If either *vmin* or *vmax* is None, the image min/max respectively\n2034     will be used for color scaling.\n2035 \n2036     If you want to set the clim of multiple images,\n2037     use, for example::\n2038 \n2039       for im in gca().get_images():\n2040           im.set_clim(0, 0.05)\n2041 \n2042     \"\"\"\n2043     im = gci()\n2044     if im is None:\n2045         raise RuntimeError('You must first define an image, e.g., with imshow')\n2046 \n2047     im.set_clim(vmin, vmax)\n2048 \n2049 \n2050 def set_cmap(cmap):\n2051     \"\"\"\n2052     Set the default colormap.  Applies to the current image if any.\n2053     See help(colormaps) for more information.\n2054 \n2055     *cmap* must be a :class:`~matplotlib.colors.Colormap` instance, or\n2056     the name of a registered colormap.\n2057 \n2058     See :func:`matplotlib.cm.register_cmap` and\n2059     :func:`matplotlib.cm.get_cmap`.\n2060     \"\"\"\n2061     cmap = cm.get_cmap(cmap)\n2062 \n2063     rc('image', cmap=cmap.name)\n2064     im = gci()\n2065 \n2066     if im is not None:\n2067         im.set_cmap(cmap)\n2068 \n2069 \n2070 @docstring.copy(matplotlib.image.imread)\n2071 def imread(fname, format=None):\n2072     return matplotlib.image.imread(fname, format)\n2073 \n2074 \n2075 @docstring.copy(matplotlib.image.imsave)\n2076 def imsave(fname, arr, **kwargs):\n2077     return matplotlib.image.imsave(fname, arr, **kwargs)\n2078 \n2079 \n2080 def matshow(A, fignum=None, **kwargs):\n2081     \"\"\"\n2082     Display an array as a matrix in a new figure window.\n2083 \n2084     The origin is set at the upper left hand corner and rows (first\n2085     dimension of the array) are displayed horizontally.  The aspect\n2086     ratio of the figure window is that of the array, unless this would\n2087     make an excessively short or narrow figure.\n2088 \n2089     Tick labels for the xaxis are placed on top.\n2090 \n2091     Parameters\n2092     ----------\n2093     A : array-like(M, N)\n2094         The matrix to be displayed.\n2095 \n2096     fignum : None or int or False\n2097         If *None*, create a new figure window with automatic numbering.\n2098 \n2099         If a nonzero integer, draw into the figure with the given number\n2100         (create it if it does not exist).\n2101 \n2102         If 0, use the current axes (or create one if it does not exist).\n2103 \n2104         .. note::\n2105 \n2106            Because of how `.Axes.matshow` tries to set the figure aspect\n2107            ratio to be the one of the array, strange things may happen if you\n2108            reuse an existing figure.\n2109 \n2110     Returns\n2111     -------\n2112     image : `~matplotlib.image.AxesImage`\n2113 \n2114     Other Parameters\n2115     ----------------\n2116     **kwargs : `~matplotlib.axes.Axes.imshow` arguments\n2117 \n2118     \"\"\"\n2119     A = np.asanyarray(A)\n2120     if fignum == 0:\n2121         ax = gca()\n2122     else:\n2123         # Extract actual aspect ratio of array and make appropriately sized\n2124         # figure.\n2125         fig = figure(fignum, figsize=figaspect(A))\n2126         ax = fig.add_axes([0.15, 0.09, 0.775, 0.775])\n2127     im = ax.matshow(A, **kwargs)\n2128     sci(im)\n2129     return im\n2130 \n2131 \n2132 def polar(*args, **kwargs):\n2133     \"\"\"\n2134     Make a polar plot.\n2135 \n2136     call signature::\n2137 \n2138       polar(theta, r, **kwargs)\n2139 \n2140     Multiple *theta*, *r* arguments are supported, with format\n2141     strings, as in :func:`~matplotlib.pyplot.plot`.\n2142 \n2143     \"\"\"\n2144     # If an axis already exists, check if it has a polar projection\n2145     if gcf().get_axes():\n2146         if not isinstance(gca(), PolarAxes):\n2147             cbook._warn_external('Trying to create polar plot on an axis '\n2148                                  'that does not have a polar projection.')\n2149     ax = gca(polar=True)\n2150     ret = ax.plot(*args, **kwargs)\n2151     return ret\n2152 \n2153 \n2154 def plotfile(fname, cols=(0,), plotfuncs=None,\n2155              comments='#', skiprows=0, checkrows=5, delimiter=',',\n2156              names=None, subplots=True, newfig=True, **kwargs):\n2157     \"\"\"\n2158     Plot the data in a file.\n2159 \n2160     *cols* is a sequence of column identifiers to plot.  An identifier\n2161     is either an int or a string.  If it is an int, it indicates the\n2162     column number.  If it is a string, it indicates the column header.\n2163     matplotlib will make column headers lower case, replace spaces with\n2164     underscores, and remove all illegal characters; so ``'Adj Close*'``\n2165     will have name ``'adj_close'``.\n2166 \n2167     - If len(*cols*) == 1, only that column will be plotted on the *y* axis.\n2168 \n2169     - If len(*cols*) > 1, the first element will be an identifier for\n2170       data for the *x* axis and the remaining elements will be the\n2171       column indexes for multiple subplots if *subplots* is *True*\n2172       (the default), or for lines in a single subplot if *subplots*\n2173       is *False*.\n2174 \n2175     *plotfuncs*, if not *None*, is a dictionary mapping identifier to\n2176     an :class:`~matplotlib.axes.Axes` plotting function as a string.\n2177     Default is 'plot', other choices are 'semilogy', 'fill', 'bar',\n2178     etc.  You must use the same type of identifier in the *cols*\n2179     vector as you use in the *plotfuncs* dictionary, e.g., integer\n2180     column numbers in both or column names in both. If *subplots*\n2181     is *False*, then including any function such as 'semilogy'\n2182     that changes the axis scaling will set the scaling for all\n2183     columns.\n2184 \n2185     - *comments*: the character used to indicate the start of a comment\n2186       in the file, or *None* to switch off the removal of comments\n2187 \n2188     - *skiprows*: is the number of rows from the top to skip\n2189 \n2190     - *checkrows*: is the number of rows to check to validate the column\n2191       data type.  When set to zero all rows are validated.\n2192 \n2193     - *delimiter*: is the character(s) separating row items\n2194 \n2195     - *names*: if not None, is a list of header names.  In this case, no\n2196       header will be read from the file\n2197 \n2198     If *newfig* is *True*, the plot always will be made in a new figure;\n2199     if *False*, it will be made in the current figure if one exists,\n2200     else in a new figure.\n2201 \n2202     kwargs are passed on to plotting functions.\n2203 \n2204     Example usage::\n2205 \n2206       # plot the 2nd and 4th column against the 1st in two subplots\n2207       plotfile(fname, (0,1,3))\n2208 \n2209       # plot using column names; specify an alternate plot type for volume\n2210       plotfile(fname, ('date', 'volume', 'adj_close'),\n2211                                     plotfuncs={'volume': 'semilogy'})\n2212 \n2213     Note: plotfile is intended as a convenience for quickly plotting\n2214     data from flat files; it is not intended as an alternative\n2215     interface to general plotting with pyplot or matplotlib.\n2216     \"\"\"\n2217 \n2218     if newfig:\n2219         fig = figure()\n2220     else:\n2221         fig = gcf()\n2222 \n2223     if len(cols) < 1:\n2224         raise ValueError('must have at least one column of data')\n2225 \n2226     if plotfuncs is None:\n2227         plotfuncs = {}\n2228     with cbook._suppress_matplotlib_deprecation_warning():\n2229         r = mlab._csv2rec(fname, comments=comments, skiprows=skiprows,\n2230                           checkrows=checkrows, delimiter=delimiter,\n2231                           names=names)\n2232 \n2233     def getname_val(identifier):\n2234         'return the name and column data for identifier'\n2235         if isinstance(identifier, str):\n2236             return identifier, r[identifier]\n2237         elif isinstance(identifier, Number):\n2238             name = r.dtype.names[int(identifier)]\n2239             return name, r[name]\n2240         else:\n2241             raise TypeError('identifier must be a string or integer')\n2242 \n2243     xname, x = getname_val(cols[0])\n2244     ynamelist = []\n2245 \n2246     if len(cols) == 1:\n2247         ax1 = fig.add_subplot(1, 1, 1)\n2248         funcname = plotfuncs.get(cols[0], 'plot')\n2249         func = getattr(ax1, funcname)\n2250         func(x, **kwargs)\n2251         ax1.set_ylabel(xname)\n2252     else:\n2253         N = len(cols)\n2254         for i in range(1, N):\n2255             if subplots:\n2256                 if i == 1:\n2257                     ax = ax1 = fig.add_subplot(N - 1, 1, i)\n2258                 else:\n2259                     ax = fig.add_subplot(N - 1, 1, i, sharex=ax1)\n2260             elif i == 1:\n2261                 ax = fig.add_subplot(1, 1, 1)\n2262 \n2263             yname, y = getname_val(cols[i])\n2264             ynamelist.append(yname)\n2265 \n2266             funcname = plotfuncs.get(cols[i], 'plot')\n2267             func = getattr(ax, funcname)\n2268 \n2269             func(x, y, **kwargs)\n2270             if subplots:\n2271                 ax.set_ylabel(yname)\n2272             if ax.is_last_row():\n2273                 ax.set_xlabel(xname)\n2274             else:\n2275                 ax.set_xlabel('')\n2276 \n2277     if not subplots:\n2278         ax.legend(ynamelist)\n2279 \n2280     if xname == 'date':\n2281         fig.autofmt_xdate()\n2282 \n2283 \n2284 # If rcParams['backend_fallback'] is true, and an interactive backend is\n2285 # requested, ignore rcParams['backend'] and force selection of a backend that\n2286 # is compatible with the current running interactive framework.\n2287 if (rcParams[\"backend_fallback\"]\n2288         and dict.__getitem__(rcParams, \"backend\") in _interactive_bk\n2289         and _get_running_interactive_framework()):\n2290     dict.__setitem__(rcParams, \"backend\", rcsetup._auto_backend_sentinel)\n2291 # Set up the backend.\n2292 switch_backend(rcParams[\"backend\"])\n2293 \n2294 # Just to be safe.  Interactive mode can be turned on without\n2295 # calling `plt.ion()` so register it again here.\n2296 # This is safe because multiple calls to `install_repl_displayhook`\n2297 # are no-ops and the registered function respect `mpl.is_interactive()`\n2298 # to determine if they should trigger a draw.\n2299 install_repl_displayhook()\n2300 \n2301 \n2302 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############\n2303 \n2304 \n2305 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2306 @docstring.copy(Figure.figimage)\n2307 def figimage(\n2308         X, xo=0, yo=0, alpha=None, norm=None, cmap=None, vmin=None,\n2309         vmax=None, origin=None, resize=False, **kwargs):\n2310     return gcf().figimage(\n2311         X, xo=xo, yo=yo, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2312         vmax=vmax, origin=origin, resize=resize, **kwargs)\n2313 \n2314 \n2315 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2316 @docstring.copy(Figure.text)\n2317 def figtext(\n2318         x, y, s, fontdict=None,\n2319         withdash=cbook.deprecation._deprecated_parameter, **kwargs):\n2320     return gcf().text(\n2321         x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)\n2322 \n2323 \n2324 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2325 @docstring.copy(Figure.ginput)\n2326 def ginput(\n2327         n=1, timeout=30, show_clicks=True, mouse_add=1, mouse_pop=3,\n2328         mouse_stop=2):\n2329     return gcf().ginput(\n2330         n=n, timeout=timeout, show_clicks=show_clicks,\n2331         mouse_add=mouse_add, mouse_pop=mouse_pop,\n2332         mouse_stop=mouse_stop)\n2333 \n2334 \n2335 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2336 @docstring.copy(Figure.suptitle)\n2337 def suptitle(t, **kwargs):\n2338     return gcf().suptitle(t, **kwargs)\n2339 \n2340 \n2341 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2342 @docstring.copy(Figure.waitforbuttonpress)\n2343 def waitforbuttonpress(timeout=-1):\n2344     return gcf().waitforbuttonpress(timeout=timeout)\n2345 \n2346 \n2347 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2348 @docstring.copy(Axes.acorr)\n2349 def acorr(x, *, data=None, **kwargs):\n2350     return gca().acorr(\n2351         x, **({\"data\": data} if data is not None else {}), **kwargs)\n2352 \n2353 \n2354 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2355 @docstring.copy(Axes.angle_spectrum)\n2356 def angle_spectrum(\n2357         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2358         data=None, **kwargs):\n2359     return gca().angle_spectrum(\n2360         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2361         **({\"data\": data} if data is not None else {}), **kwargs)\n2362 \n2363 \n2364 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2365 @docstring.copy(Axes.annotate)\n2366 def annotate(s, xy, *args, **kwargs):\n2367     return gca().annotate(s, xy, *args, **kwargs)\n2368 \n2369 \n2370 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2371 @docstring.copy(Axes.arrow)\n2372 def arrow(x, y, dx, dy, **kwargs):\n2373     return gca().arrow(x, y, dx, dy, **kwargs)\n2374 \n2375 \n2376 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2377 @docstring.copy(Axes.autoscale)\n2378 def autoscale(enable=True, axis='both', tight=None):\n2379     return gca().autoscale(enable=enable, axis=axis, tight=tight)\n2380 \n2381 \n2382 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2383 @docstring.copy(Axes.axhline)\n2384 def axhline(y=0, xmin=0, xmax=1, **kwargs):\n2385     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)\n2386 \n2387 \n2388 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2389 @docstring.copy(Axes.axhspan)\n2390 def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):\n2391     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)\n2392 \n2393 \n2394 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2395 @docstring.copy(Axes.axis)\n2396 def axis(*args, **kwargs):\n2397     return gca().axis(*args, **kwargs)\n2398 \n2399 \n2400 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2401 @docstring.copy(Axes.axvline)\n2402 def axvline(x=0, ymin=0, ymax=1, **kwargs):\n2403     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)\n2404 \n2405 \n2406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2407 @docstring.copy(Axes.axvspan)\n2408 def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):\n2409     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)\n2410 \n2411 \n2412 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2413 @docstring.copy(Axes.bar)\n2414 def bar(\n2415         x, height, width=0.8, bottom=None, *, align='center',\n2416         data=None, **kwargs):\n2417     return gca().bar(\n2418         x, height, width=width, bottom=bottom, align=align,\n2419         **({\"data\": data} if data is not None else {}), **kwargs)\n2420 \n2421 \n2422 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2423 @docstring.copy(Axes.barbs)\n2424 def barbs(*args, data=None, **kw):\n2425     return gca().barbs(\n2426         *args, **({\"data\": data} if data is not None else {}), **kw)\n2427 \n2428 \n2429 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2430 @docstring.copy(Axes.barh)\n2431 def barh(y, width, height=0.8, left=None, *, align='center', **kwargs):\n2432     return gca().barh(\n2433         y, width, height=height, left=left, align=align, **kwargs)\n2434 \n2435 \n2436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2437 @docstring.copy(Axes.boxplot)\n2438 def boxplot(\n2439         x, notch=None, sym=None, vert=None, whis=None,\n2440         positions=None, widths=None, patch_artist=None,\n2441         bootstrap=None, usermedians=None, conf_intervals=None,\n2442         meanline=None, showmeans=None, showcaps=None, showbox=None,\n2443         showfliers=None, boxprops=None, labels=None, flierprops=None,\n2444         medianprops=None, meanprops=None, capprops=None,\n2445         whiskerprops=None, manage_ticks=True, autorange=False,\n2446         zorder=None, *, data=None):\n2447     return gca().boxplot(\n2448         x, notch=notch, sym=sym, vert=vert, whis=whis,\n2449         positions=positions, widths=widths, patch_artist=patch_artist,\n2450         bootstrap=bootstrap, usermedians=usermedians,\n2451         conf_intervals=conf_intervals, meanline=meanline,\n2452         showmeans=showmeans, showcaps=showcaps, showbox=showbox,\n2453         showfliers=showfliers, boxprops=boxprops, labels=labels,\n2454         flierprops=flierprops, medianprops=medianprops,\n2455         meanprops=meanprops, capprops=capprops,\n2456         whiskerprops=whiskerprops, manage_ticks=manage_ticks,\n2457         autorange=autorange, zorder=zorder, **({\"data\": data} if data\n2458         is not None else {}))\n2459 \n2460 \n2461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2462 @docstring.copy(Axes.broken_barh)\n2463 def broken_barh(xranges, yrange, *, data=None, **kwargs):\n2464     return gca().broken_barh(\n2465         xranges, yrange, **({\"data\": data} if data is not None else\n2466         {}), **kwargs)\n2467 \n2468 \n2469 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2470 @docstring.copy(Axes.cla)\n2471 def cla():\n2472     return gca().cla()\n2473 \n2474 \n2475 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2476 @docstring.copy(Axes.clabel)\n2477 def clabel(CS, *args, **kwargs):\n2478     return gca().clabel(CS, *args, **kwargs)\n2479 \n2480 \n2481 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2482 @docstring.copy(Axes.cohere)\n2483 def cohere(\n2484         x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,\n2485         window=mlab.window_hanning, noverlap=0, pad_to=None,\n2486         sides='default', scale_by_freq=None, *, data=None, **kwargs):\n2487     return gca().cohere(\n2488         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2489         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2490         scale_by_freq=scale_by_freq, **({\"data\": data} if data is not\n2491         None else {}), **kwargs)\n2492 \n2493 \n2494 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2495 @docstring.copy(Axes.contour)\n2496 def contour(*args, data=None, **kwargs):\n2497     __ret = gca().contour(\n2498         *args, **({\"data\": data} if data is not None else {}),\n2499         **kwargs)\n2500     if __ret._A is not None: sci(__ret)  # noqa\n2501     return __ret\n2502 \n2503 \n2504 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2505 @docstring.copy(Axes.contourf)\n2506 def contourf(*args, data=None, **kwargs):\n2507     __ret = gca().contourf(\n2508         *args, **({\"data\": data} if data is not None else {}),\n2509         **kwargs)\n2510     if __ret._A is not None: sci(__ret)  # noqa\n2511     return __ret\n2512 \n2513 \n2514 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2515 @docstring.copy(Axes.csd)\n2516 def csd(\n2517         x, y, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2518         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2519         return_line=None, *, data=None, **kwargs):\n2520     return gca().csd(\n2521         x, y, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2522         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2523         scale_by_freq=scale_by_freq, return_line=return_line,\n2524         **({\"data\": data} if data is not None else {}), **kwargs)\n2525 \n2526 \n2527 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2528 @docstring.copy(Axes.errorbar)\n2529 def errorbar(\n2530         x, y, yerr=None, xerr=None, fmt='', ecolor=None,\n2531         elinewidth=None, capsize=None, barsabove=False, lolims=False,\n2532         uplims=False, xlolims=False, xuplims=False, errorevery=1,\n2533         capthick=None, *, data=None, **kwargs):\n2534     return gca().errorbar(\n2535         x, y, yerr=yerr, xerr=xerr, fmt=fmt, ecolor=ecolor,\n2536         elinewidth=elinewidth, capsize=capsize, barsabove=barsabove,\n2537         lolims=lolims, uplims=uplims, xlolims=xlolims,\n2538         xuplims=xuplims, errorevery=errorevery, capthick=capthick,\n2539         **({\"data\": data} if data is not None else {}), **kwargs)\n2540 \n2541 \n2542 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2543 @docstring.copy(Axes.eventplot)\n2544 def eventplot(\n2545         positions, orientation='horizontal', lineoffsets=1,\n2546         linelengths=1, linewidths=None, colors=None,\n2547         linestyles='solid', *, data=None, **kwargs):\n2548     return gca().eventplot(\n2549         positions, orientation=orientation, lineoffsets=lineoffsets,\n2550         linelengths=linelengths, linewidths=linewidths, colors=colors,\n2551         linestyles=linestyles, **({\"data\": data} if data is not None\n2552         else {}), **kwargs)\n2553 \n2554 \n2555 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2556 @docstring.copy(Axes.fill)\n2557 def fill(*args, data=None, **kwargs):\n2558     return gca().fill(\n2559         *args, **({\"data\": data} if data is not None else {}),\n2560         **kwargs)\n2561 \n2562 \n2563 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2564 @docstring.copy(Axes.fill_between)\n2565 def fill_between(\n2566         x, y1, y2=0, where=None, interpolate=False, step=None, *,\n2567         data=None, **kwargs):\n2568     return gca().fill_between(\n2569         x, y1, y2=y2, where=where, interpolate=interpolate, step=step,\n2570         **({\"data\": data} if data is not None else {}), **kwargs)\n2571 \n2572 \n2573 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2574 @docstring.copy(Axes.fill_betweenx)\n2575 def fill_betweenx(\n2576         y, x1, x2=0, where=None, step=None, interpolate=False, *,\n2577         data=None, **kwargs):\n2578     return gca().fill_betweenx(\n2579         y, x1, x2=x2, where=where, step=step, interpolate=interpolate,\n2580         **({\"data\": data} if data is not None else {}), **kwargs)\n2581 \n2582 \n2583 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2584 @docstring.copy(Axes.grid)\n2585 def grid(b=None, which='major', axis='both', **kwargs):\n2586     return gca().grid(b=b, which=which, axis=axis, **kwargs)\n2587 \n2588 \n2589 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2590 @docstring.copy(Axes.hexbin)\n2591 def hexbin(\n2592         x, y, C=None, gridsize=100, bins=None, xscale='linear',\n2593         yscale='linear', extent=None, cmap=None, norm=None, vmin=None,\n2594         vmax=None, alpha=None, linewidths=None, edgecolors='face',\n2595         reduce_C_function=np.mean, mincnt=None, marginals=False, *,\n2596         data=None, **kwargs):\n2597     __ret = gca().hexbin(\n2598         x, y, C=C, gridsize=gridsize, bins=bins, xscale=xscale,\n2599         yscale=yscale, extent=extent, cmap=cmap, norm=norm, vmin=vmin,\n2600         vmax=vmax, alpha=alpha, linewidths=linewidths,\n2601         edgecolors=edgecolors, reduce_C_function=reduce_C_function,\n2602         mincnt=mincnt, marginals=marginals, **({\"data\": data} if data\n2603         is not None else {}), **kwargs)\n2604     sci(__ret)\n2605     return __ret\n2606 \n2607 \n2608 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2609 @docstring.copy(Axes.hist)\n2610 def hist(\n2611         x, bins=None, range=None, density=None, weights=None,\n2612         cumulative=False, bottom=None, histtype='bar', align='mid',\n2613         orientation='vertical', rwidth=None, log=False, color=None,\n2614         label=None, stacked=False, normed=None, *, data=None,\n2615         **kwargs):\n2616     return gca().hist(\n2617         x, bins=bins, range=range, density=density, weights=weights,\n2618         cumulative=cumulative, bottom=bottom, histtype=histtype,\n2619         align=align, orientation=orientation, rwidth=rwidth, log=log,\n2620         color=color, label=label, stacked=stacked, normed=normed,\n2621         **({\"data\": data} if data is not None else {}), **kwargs)\n2622 \n2623 \n2624 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2625 @docstring.copy(Axes.hist2d)\n2626 def hist2d(\n2627         x, y, bins=10, range=None, density=False, weights=None,\n2628         cmin=None, cmax=None, *, data=None, **kwargs):\n2629     __ret = gca().hist2d(\n2630         x, y, bins=bins, range=range, density=density,\n2631         weights=weights, cmin=cmin, cmax=cmax, **({\"data\": data} if\n2632         data is not None else {}), **kwargs)\n2633     sci(__ret[-1])\n2634     return __ret\n2635 \n2636 \n2637 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2638 @docstring.copy(Axes.hlines)\n2639 def hlines(\n2640         y, xmin, xmax, colors='k', linestyles='solid', label='', *,\n2641         data=None, **kwargs):\n2642     return gca().hlines(\n2643         y, xmin, xmax, colors=colors, linestyles=linestyles,\n2644         label=label, **({\"data\": data} if data is not None else {}),\n2645         **kwargs)\n2646 \n2647 \n2648 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2649 @docstring.copy(Axes.imshow)\n2650 def imshow(\n2651         X, cmap=None, norm=None, aspect=None, interpolation=None,\n2652         alpha=None, vmin=None, vmax=None, origin=None, extent=None,\n2653         shape=cbook.deprecation._deprecated_parameter, filternorm=1,\n2654         filterrad=4.0, imlim=cbook.deprecation._deprecated_parameter,\n2655         resample=None, url=None, *, data=None, **kwargs):\n2656     __ret = gca().imshow(\n2657         X, cmap=cmap, norm=norm, aspect=aspect,\n2658         interpolation=interpolation, alpha=alpha, vmin=vmin,\n2659         vmax=vmax, origin=origin, extent=extent, shape=shape,\n2660         filternorm=filternorm, filterrad=filterrad, imlim=imlim,\n2661         resample=resample, url=url, **({\"data\": data} if data is not\n2662         None else {}), **kwargs)\n2663     sci(__ret)\n2664     return __ret\n2665 \n2666 \n2667 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2668 @docstring.copy(Axes.legend)\n2669 def legend(*args, **kwargs):\n2670     return gca().legend(*args, **kwargs)\n2671 \n2672 \n2673 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2674 @docstring.copy(Axes.locator_params)\n2675 def locator_params(axis='both', tight=None, **kwargs):\n2676     return gca().locator_params(axis=axis, tight=tight, **kwargs)\n2677 \n2678 \n2679 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2680 @docstring.copy(Axes.loglog)\n2681 def loglog(*args, **kwargs):\n2682     return gca().loglog(*args, **kwargs)\n2683 \n2684 \n2685 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2686 @docstring.copy(Axes.magnitude_spectrum)\n2687 def magnitude_spectrum(\n2688         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None,\n2689         scale=None, *, data=None, **kwargs):\n2690     return gca().magnitude_spectrum(\n2691         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2692         scale=scale, **({\"data\": data} if data is not None else {}),\n2693         **kwargs)\n2694 \n2695 \n2696 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2697 @docstring.copy(Axes.margins)\n2698 def margins(*margins, x=None, y=None, tight=True):\n2699     return gca().margins(*margins, x=x, y=y, tight=tight)\n2700 \n2701 \n2702 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2703 @docstring.copy(Axes.minorticks_off)\n2704 def minorticks_off():\n2705     return gca().minorticks_off()\n2706 \n2707 \n2708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2709 @docstring.copy(Axes.minorticks_on)\n2710 def minorticks_on():\n2711     return gca().minorticks_on()\n2712 \n2713 \n2714 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2715 @docstring.copy(Axes.pcolor)\n2716 def pcolor(\n2717         *args, alpha=None, norm=None, cmap=None, vmin=None,\n2718         vmax=None, data=None, **kwargs):\n2719     __ret = gca().pcolor(\n2720         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2721         vmax=vmax, **({\"data\": data} if data is not None else {}),\n2722         **kwargs)\n2723     sci(__ret)\n2724     return __ret\n2725 \n2726 \n2727 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2728 @docstring.copy(Axes.pcolormesh)\n2729 def pcolormesh(\n2730         *args, alpha=None, norm=None, cmap=None, vmin=None,\n2731         vmax=None, shading='flat', antialiased=False, data=None,\n2732         **kwargs):\n2733     __ret = gca().pcolormesh(\n2734         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2735         vmax=vmax, shading=shading, antialiased=antialiased,\n2736         **({\"data\": data} if data is not None else {}), **kwargs)\n2737     sci(__ret)\n2738     return __ret\n2739 \n2740 \n2741 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2742 @docstring.copy(Axes.phase_spectrum)\n2743 def phase_spectrum(\n2744         x, Fs=None, Fc=None, window=None, pad_to=None, sides=None, *,\n2745         data=None, **kwargs):\n2746     return gca().phase_spectrum(\n2747         x, Fs=Fs, Fc=Fc, window=window, pad_to=pad_to, sides=sides,\n2748         **({\"data\": data} if data is not None else {}), **kwargs)\n2749 \n2750 \n2751 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2752 @docstring.copy(Axes.pie)\n2753 def pie(\n2754         x, explode=None, labels=None, colors=None, autopct=None,\n2755         pctdistance=0.6, shadow=False, labeldistance=1.1,\n2756         startangle=None, radius=None, counterclock=True,\n2757         wedgeprops=None, textprops=None, center=(0, 0), frame=False,\n2758         rotatelabels=False, *, data=None):\n2759     return gca().pie(\n2760         x, explode=explode, labels=labels, colors=colors,\n2761         autopct=autopct, pctdistance=pctdistance, shadow=shadow,\n2762         labeldistance=labeldistance, startangle=startangle,\n2763         radius=radius, counterclock=counterclock,\n2764         wedgeprops=wedgeprops, textprops=textprops, center=center,\n2765         frame=frame, rotatelabels=rotatelabels, **({\"data\": data} if\n2766         data is not None else {}))\n2767 \n2768 \n2769 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2770 @docstring.copy(Axes.plot)\n2771 def plot(*args, scalex=True, scaley=True, data=None, **kwargs):\n2772     return gca().plot(\n2773         *args, scalex=scalex, scaley=scaley, **({\"data\": data} if data\n2774         is not None else {}), **kwargs)\n2775 \n2776 \n2777 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2778 @docstring.copy(Axes.plot_date)\n2779 def plot_date(\n2780         x, y, fmt='o', tz=None, xdate=True, ydate=False, *,\n2781         data=None, **kwargs):\n2782     return gca().plot_date(\n2783         x, y, fmt=fmt, tz=tz, xdate=xdate, ydate=ydate, **({\"data\":\n2784         data} if data is not None else {}), **kwargs)\n2785 \n2786 \n2787 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2788 @docstring.copy(Axes.psd)\n2789 def psd(\n2790         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2791         noverlap=None, pad_to=None, sides=None, scale_by_freq=None,\n2792         return_line=None, *, data=None, **kwargs):\n2793     return gca().psd(\n2794         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2795         noverlap=noverlap, pad_to=pad_to, sides=sides,\n2796         scale_by_freq=scale_by_freq, return_line=return_line,\n2797         **({\"data\": data} if data is not None else {}), **kwargs)\n2798 \n2799 \n2800 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2801 @docstring.copy(Axes.quiver)\n2802 def quiver(*args, data=None, **kw):\n2803     __ret = gca().quiver(\n2804         *args, **({\"data\": data} if data is not None else {}), **kw)\n2805     sci(__ret)\n2806     return __ret\n2807 \n2808 \n2809 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2810 @docstring.copy(Axes.quiverkey)\n2811 def quiverkey(Q, X, Y, U, label, **kw):\n2812     return gca().quiverkey(Q, X, Y, U, label, **kw)\n2813 \n2814 \n2815 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2816 @docstring.copy(Axes.scatter)\n2817 def scatter(\n2818         x, y, s=None, c=None, marker=None, cmap=None, norm=None,\n2819         vmin=None, vmax=None, alpha=None, linewidths=None, verts=None,\n2820         edgecolors=None, *, plotnonfinite=False, data=None, **kwargs):\n2821     __ret = gca().scatter(\n2822         x, y, s=s, c=c, marker=marker, cmap=cmap, norm=norm,\n2823         vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths,\n2824         verts=verts, edgecolors=edgecolors,\n2825         plotnonfinite=plotnonfinite, **({\"data\": data} if data is not\n2826         None else {}), **kwargs)\n2827     sci(__ret)\n2828     return __ret\n2829 \n2830 \n2831 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2832 @docstring.copy(Axes.semilogx)\n2833 def semilogx(*args, **kwargs):\n2834     return gca().semilogx(*args, **kwargs)\n2835 \n2836 \n2837 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2838 @docstring.copy(Axes.semilogy)\n2839 def semilogy(*args, **kwargs):\n2840     return gca().semilogy(*args, **kwargs)\n2841 \n2842 \n2843 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2844 @docstring.copy(Axes.specgram)\n2845 def specgram(\n2846         x, NFFT=None, Fs=None, Fc=None, detrend=None, window=None,\n2847         noverlap=None, cmap=None, xextent=None, pad_to=None,\n2848         sides=None, scale_by_freq=None, mode=None, scale=None,\n2849         vmin=None, vmax=None, *, data=None, **kwargs):\n2850     __ret = gca().specgram(\n2851         x, NFFT=NFFT, Fs=Fs, Fc=Fc, detrend=detrend, window=window,\n2852         noverlap=noverlap, cmap=cmap, xextent=xextent, pad_to=pad_to,\n2853         sides=sides, scale_by_freq=scale_by_freq, mode=mode,\n2854         scale=scale, vmin=vmin, vmax=vmax, **({\"data\": data} if data\n2855         is not None else {}), **kwargs)\n2856     sci(__ret[-1])\n2857     return __ret\n2858 \n2859 \n2860 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2861 @docstring.copy(Axes.spy)\n2862 def spy(\n2863         Z, precision=0, marker=None, markersize=None, aspect='equal',\n2864         origin='upper', **kwargs):\n2865     __ret = gca().spy(\n2866         Z, precision=precision, marker=marker, markersize=markersize,\n2867         aspect=aspect, origin=origin, **kwargs)\n2868     if isinstance(__ret, cm.ScalarMappable): sci(__ret)  # noqa\n2869     return __ret\n2870 \n2871 \n2872 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2873 @docstring.copy(Axes.stackplot)\n2874 def stackplot(\n2875         x, *args, labels=(), colors=None, baseline='zero', data=None,\n2876         **kwargs):\n2877     return gca().stackplot(\n2878         x, *args, labels=labels, colors=colors, baseline=baseline,\n2879         **({\"data\": data} if data is not None else {}), **kwargs)\n2880 \n2881 \n2882 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2883 @docstring.copy(Axes.stem)\n2884 def stem(\n2885         *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,\n2886         label=None, use_line_collection=False, data=None):\n2887     return gca().stem(\n2888         *args, linefmt=linefmt, markerfmt=markerfmt, basefmt=basefmt,\n2889         bottom=bottom, label=label,\n2890         use_line_collection=use_line_collection, **({\"data\": data} if\n2891         data is not None else {}))\n2892 \n2893 \n2894 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2895 @docstring.copy(Axes.step)\n2896 def step(x, y, *args, where='pre', data=None, **kwargs):\n2897     return gca().step(\n2898         x, y, *args, where=where, **({\"data\": data} if data is not\n2899         None else {}), **kwargs)\n2900 \n2901 \n2902 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2903 @docstring.copy(Axes.streamplot)\n2904 def streamplot(\n2905         x, y, u, v, density=1, linewidth=None, color=None, cmap=None,\n2906         norm=None, arrowsize=1, arrowstyle='-|>', minlength=0.1,\n2907         transform=None, zorder=None, start_points=None, maxlength=4.0,\n2908         integration_direction='both', *, data=None):\n2909     __ret = gca().streamplot(\n2910         x, y, u, v, density=density, linewidth=linewidth, color=color,\n2911         cmap=cmap, norm=norm, arrowsize=arrowsize,\n2912         arrowstyle=arrowstyle, minlength=minlength,\n2913         transform=transform, zorder=zorder, start_points=start_points,\n2914         maxlength=maxlength,\n2915         integration_direction=integration_direction, **({\"data\": data}\n2916         if data is not None else {}))\n2917     sci(__ret.lines)\n2918     return __ret\n2919 \n2920 \n2921 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2922 @docstring.copy(Axes.table)\n2923 def table(\n2924         cellText=None, cellColours=None, cellLoc='right',\n2925         colWidths=None, rowLabels=None, rowColours=None,\n2926         rowLoc='left', colLabels=None, colColours=None,\n2927         colLoc='center', loc='bottom', bbox=None, edges='closed',\n2928         **kwargs):\n2929     return gca().table(\n2930         cellText=cellText, cellColours=cellColours, cellLoc=cellLoc,\n2931         colWidths=colWidths, rowLabels=rowLabels,\n2932         rowColours=rowColours, rowLoc=rowLoc, colLabels=colLabels,\n2933         colColours=colColours, colLoc=colLoc, loc=loc, bbox=bbox,\n2934         edges=edges, **kwargs)\n2935 \n2936 \n2937 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2938 @docstring.copy(Axes.text)\n2939 def text(\n2940         x, y, s, fontdict=None,\n2941         withdash=cbook.deprecation._deprecated_parameter, **kwargs):\n2942     return gca().text(x, y, s, fontdict=fontdict, withdash=withdash, **kwargs)\n2943 \n2944 \n2945 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2946 @docstring.copy(Axes.tick_params)\n2947 def tick_params(axis='both', **kwargs):\n2948     return gca().tick_params(axis=axis, **kwargs)\n2949 \n2950 \n2951 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2952 @docstring.copy(Axes.ticklabel_format)\n2953 def ticklabel_format(\n2954         *, axis='both', style='', scilimits=None, useOffset=None,\n2955         useLocale=None, useMathText=None):\n2956     return gca().ticklabel_format(\n2957         axis=axis, style=style, scilimits=scilimits,\n2958         useOffset=useOffset, useLocale=useLocale,\n2959         useMathText=useMathText)\n2960 \n2961 \n2962 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2963 @docstring.copy(Axes.tricontour)\n2964 def tricontour(*args, **kwargs):\n2965     __ret = gca().tricontour(*args, **kwargs)\n2966     if __ret._A is not None: sci(__ret)  # noqa\n2967     return __ret\n2968 \n2969 \n2970 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2971 @docstring.copy(Axes.tricontourf)\n2972 def tricontourf(*args, **kwargs):\n2973     __ret = gca().tricontourf(*args, **kwargs)\n2974     if __ret._A is not None: sci(__ret)  # noqa\n2975     return __ret\n2976 \n2977 \n2978 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2979 @docstring.copy(Axes.tripcolor)\n2980 def tripcolor(\n2981         *args, alpha=1.0, norm=None, cmap=None, vmin=None, vmax=None,\n2982         shading='flat', facecolors=None, **kwargs):\n2983     __ret = gca().tripcolor(\n2984         *args, alpha=alpha, norm=norm, cmap=cmap, vmin=vmin,\n2985         vmax=vmax, shading=shading, facecolors=facecolors, **kwargs)\n2986     sci(__ret)\n2987     return __ret\n2988 \n2989 \n2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2991 @docstring.copy(Axes.triplot)\n2992 def triplot(*args, **kwargs):\n2993     return gca().triplot(*args, **kwargs)\n2994 \n2995 \n2996 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n2997 @docstring.copy(Axes.violinplot)\n2998 def violinplot(\n2999         dataset, positions=None, vert=True, widths=0.5,\n3000         showmeans=False, showextrema=True, showmedians=False,\n3001         points=100, bw_method=None, *, data=None):\n3002     return gca().violinplot(\n3003         dataset, positions=positions, vert=vert, widths=widths,\n3004         showmeans=showmeans, showextrema=showextrema,\n3005         showmedians=showmedians, points=points, bw_method=bw_method,\n3006         **({\"data\": data} if data is not None else {}))\n3007 \n3008 \n3009 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3010 @docstring.copy(Axes.vlines)\n3011 def vlines(\n3012         x, ymin, ymax, colors='k', linestyles='solid', label='', *,\n3013         data=None, **kwargs):\n3014     return gca().vlines(\n3015         x, ymin, ymax, colors=colors, linestyles=linestyles,\n3016         label=label, **({\"data\": data} if data is not None else {}),\n3017         **kwargs)\n3018 \n3019 \n3020 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3021 @docstring.copy(Axes.xcorr)\n3022 def xcorr(\n3023         x, y, normed=True, detrend=mlab.detrend_none, usevlines=True,\n3024         maxlags=10, *, data=None, **kwargs):\n3025     return gca().xcorr(\n3026         x, y, normed=normed, detrend=detrend, usevlines=usevlines,\n3027         maxlags=maxlags, **({\"data\": data} if data is not None else\n3028         {}), **kwargs)\n3029 \n3030 \n3031 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3032 @docstring.copy(Axes._sci)\n3033 def sci(im):\n3034     return gca()._sci(im)\n3035 \n3036 \n3037 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3038 @docstring.copy(Axes.set_title)\n3039 def title(label, fontdict=None, loc='center', pad=None, **kwargs):\n3040     return gca().set_title(\n3041         label, fontdict=fontdict, loc=loc, pad=pad, **kwargs)\n3042 \n3043 \n3044 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3045 @docstring.copy(Axes.set_xlabel)\n3046 def xlabel(xlabel, fontdict=None, labelpad=None, **kwargs):\n3047     return gca().set_xlabel(\n3048         xlabel, fontdict=fontdict, labelpad=labelpad, **kwargs)\n3049 \n3050 \n3051 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3052 @docstring.copy(Axes.set_ylabel)\n3053 def ylabel(ylabel, fontdict=None, labelpad=None, **kwargs):\n3054     return gca().set_ylabel(\n3055         ylabel, fontdict=fontdict, labelpad=labelpad, **kwargs)\n3056 \n3057 \n3058 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3059 @docstring.copy(Axes.set_xscale)\n3060 def xscale(value, **kwargs):\n3061     return gca().set_xscale(value, **kwargs)\n3062 \n3063 \n3064 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3065 @docstring.copy(Axes.set_yscale)\n3066 def yscale(value, **kwargs):\n3067     return gca().set_yscale(value, **kwargs)\n3068 \n3069 \n3070 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3071 def autumn():\n3072     \"\"\"\n3073     Set the colormap to \"autumn\".\n3074 \n3075     This changes the default colormap as well as the colormap of the current\n3076     image if there is one. See ``help(colormaps)`` for more information.\n3077     \"\"\"\n3078     set_cmap(\"autumn\")\n3079 \n3080 \n3081 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3082 def bone():\n3083     \"\"\"\n3084     Set the colormap to \"bone\".\n3085 \n3086     This changes the default colormap as well as the colormap of the current\n3087     image if there is one. See ``help(colormaps)`` for more information.\n3088     \"\"\"\n3089     set_cmap(\"bone\")\n3090 \n3091 \n3092 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3093 def cool():\n3094     \"\"\"\n3095     Set the colormap to \"cool\".\n3096 \n3097     This changes the default colormap as well as the colormap of the current\n3098     image if there is one. See ``help(colormaps)`` for more information.\n3099     \"\"\"\n3100     set_cmap(\"cool\")\n3101 \n3102 \n3103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3104 def copper():\n3105     \"\"\"\n3106     Set the colormap to \"copper\".\n3107 \n3108     This changes the default colormap as well as the colormap of the current\n3109     image if there is one. See ``help(colormaps)`` for more information.\n3110     \"\"\"\n3111     set_cmap(\"copper\")\n3112 \n3113 \n3114 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3115 def flag():\n3116     \"\"\"\n3117     Set the colormap to \"flag\".\n3118 \n3119     This changes the default colormap as well as the colormap of the current\n3120     image if there is one. See ``help(colormaps)`` for more information.\n3121     \"\"\"\n3122     set_cmap(\"flag\")\n3123 \n3124 \n3125 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3126 def gray():\n3127     \"\"\"\n3128     Set the colormap to \"gray\".\n3129 \n3130     This changes the default colormap as well as the colormap of the current\n3131     image if there is one. See ``help(colormaps)`` for more information.\n3132     \"\"\"\n3133     set_cmap(\"gray\")\n3134 \n3135 \n3136 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3137 def hot():\n3138     \"\"\"\n3139     Set the colormap to \"hot\".\n3140 \n3141     This changes the default colormap as well as the colormap of the current\n3142     image if there is one. See ``help(colormaps)`` for more information.\n3143     \"\"\"\n3144     set_cmap(\"hot\")\n3145 \n3146 \n3147 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3148 def hsv():\n3149     \"\"\"\n3150     Set the colormap to \"hsv\".\n3151 \n3152     This changes the default colormap as well as the colormap of the current\n3153     image if there is one. See ``help(colormaps)`` for more information.\n3154     \"\"\"\n3155     set_cmap(\"hsv\")\n3156 \n3157 \n3158 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3159 def jet():\n3160     \"\"\"\n3161     Set the colormap to \"jet\".\n3162 \n3163     This changes the default colormap as well as the colormap of the current\n3164     image if there is one. See ``help(colormaps)`` for more information.\n3165     \"\"\"\n3166     set_cmap(\"jet\")\n3167 \n3168 \n3169 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3170 def pink():\n3171     \"\"\"\n3172     Set the colormap to \"pink\".\n3173 \n3174     This changes the default colormap as well as the colormap of the current\n3175     image if there is one. See ``help(colormaps)`` for more information.\n3176     \"\"\"\n3177     set_cmap(\"pink\")\n3178 \n3179 \n3180 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3181 def prism():\n3182     \"\"\"\n3183     Set the colormap to \"prism\".\n3184 \n3185     This changes the default colormap as well as the colormap of the current\n3186     image if there is one. See ``help(colormaps)`` for more information.\n3187     \"\"\"\n3188     set_cmap(\"prism\")\n3189 \n3190 \n3191 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3192 def spring():\n3193     \"\"\"\n3194     Set the colormap to \"spring\".\n3195 \n3196     This changes the default colormap as well as the colormap of the current\n3197     image if there is one. See ``help(colormaps)`` for more information.\n3198     \"\"\"\n3199     set_cmap(\"spring\")\n3200 \n3201 \n3202 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3203 def summer():\n3204     \"\"\"\n3205     Set the colormap to \"summer\".\n3206 \n3207     This changes the default colormap as well as the colormap of the current\n3208     image if there is one. See ``help(colormaps)`` for more information.\n3209     \"\"\"\n3210     set_cmap(\"summer\")\n3211 \n3212 \n3213 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3214 def winter():\n3215     \"\"\"\n3216     Set the colormap to \"winter\".\n3217 \n3218     This changes the default colormap as well as the colormap of the current\n3219     image if there is one. See ``help(colormaps)`` for more information.\n3220     \"\"\"\n3221     set_cmap(\"winter\")\n3222 \n3223 \n3224 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3225 def magma():\n3226     \"\"\"\n3227     Set the colormap to \"magma\".\n3228 \n3229     This changes the default colormap as well as the colormap of the current\n3230     image if there is one. See ``help(colormaps)`` for more information.\n3231     \"\"\"\n3232     set_cmap(\"magma\")\n3233 \n3234 \n3235 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3236 def inferno():\n3237     \"\"\"\n3238     Set the colormap to \"inferno\".\n3239 \n3240     This changes the default colormap as well as the colormap of the current\n3241     image if there is one. See ``help(colormaps)`` for more information.\n3242     \"\"\"\n3243     set_cmap(\"inferno\")\n3244 \n3245 \n3246 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3247 def plasma():\n3248     \"\"\"\n3249     Set the colormap to \"plasma\".\n3250 \n3251     This changes the default colormap as well as the colormap of the current\n3252     image if there is one. See ``help(colormaps)`` for more information.\n3253     \"\"\"\n3254     set_cmap(\"plasma\")\n3255 \n3256 \n3257 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3258 def viridis():\n3259     \"\"\"\n3260     Set the colormap to \"viridis\".\n3261 \n3262     This changes the default colormap as well as the colormap of the current\n3263     image if there is one. See ``help(colormaps)`` for more information.\n3264     \"\"\"\n3265     set_cmap(\"viridis\")\n3266 \n3267 \n3268 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.\n3269 def nipy_spectral():\n3270     \"\"\"\n3271     Set the colormap to \"nipy_spectral\".\n3272 \n3273     This changes the default colormap as well as the colormap of the current\n3274     image if there is one. See ``help(colormaps)`` for more information.\n3275     \"\"\"\n3276     set_cmap(\"nipy_spectral\")\n3277 \n3278 _setup_pyplot_info_docstrings()\n",
        "intended_behavior": "In the `savefig` function, add a pre-check for the figure size directly or ensure that any down-stream method from `pyplot.savefig` that eventually interacts with figure dimensions performs a check to prevent zero-width or zero-height figures from being passed to libpng. This check, similar to the one proposed in `figure.py`, should raise an informative exception if invalid dimensions are identified. This will warn users before an attempt is made to render or save the figure, thereby avoiding the runtime error from libpng."
    }
]