2025-10-15 17:11:17.501 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 17:11:20.620 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=12, cost=0.006880
2025-10-15 17:11:20.621 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 17:11:20.625 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:11:34.463 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=952, output_tokens=529, cost=0.025390
2025-10-15 17:11:34.471 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:11:38.295 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=883, output_tokens=127, cost=0.012640
2025-10-15 17:11:38.297 | DEBUG    | Extracted a valid json.
2025-10-15 17:11:38.297 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Account\")",
        "search_class(\"Address\")",
        "search_class(\"Profile\")",
        "search_code(\"ALTER TABLE `b_manage_account` MODIFY `id` varchar(22) COLLATE `utf8_bin`;\")",
        "search_code(\"ALTER TABLE `b_manage_address` ADD CONSTRAINT `b_manage_address_account_id_7de0ae37_fk`\")",
        "search_code(\"ALTER TABLE `b_manage_profile` ADD CONSTRAINT `b_manage_profile_account_id_ec864dcc_fk`\")"
    ],
    "bug_locations": []
}
2025-10-15 17:11:38.383 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 17:11:38.384 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 17:11:56.741 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1824, output_tokens=573, cost=0.035430
2025-10-15 17:11:56.747 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:12:09.042 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2613, output_tokens=465, cost=0.040080
2025-10-15 17:12:09.049 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:12:14.987 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=219, cost=0.014760
2025-10-15 17:12:14.988 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:12:14.988 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-15 17:12:20.389 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=230, cost=0.015090
2025-10-15 17:12:20.390 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:12:20.390 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-15 17:12:25.246 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=151, cost=0.012720
2025-10-15 17:12:25.247 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:12:25.247 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-15 17:12:32.048 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=227, cost=0.015000
2025-10-15 17:12:32.050 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:12:32.050 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-15 17:12:38.105 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=819, output_tokens=244, cost=0.015510
2025-10-15 17:12:38.106 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:12:38.111 | DEBUG    | Agent proxy return the following json: None
2025-10-15 17:12:38.112 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-15 17:12:38.113 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 17:12:38.113 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:12:47.205 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3105, output_tokens=357, cost=0.041760
2025-10-15 17:12:47.212 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:12:49.773 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=45, cost=0.008460
2025-10-15 17:12:49.774 | DEBUG    | Extracted a valid json.
2025-10-15 17:12:49.774 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ShortUUIDField\")",
        "search_method(\"makemigrations\")",
        "search_method(\"migrate\")"
    ],
    "bug_locations": []
}
2025-10-15 17:12:49.832 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 17:12:49.832 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 17:13:06.246 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4735, output_tokens=619, cost=0.065920
2025-10-15 17:13:06.258 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:13:21.093 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5570, output_tokens=558, cost=0.072440
2025-10-15 17:13:21.104 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:13:27.523 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=253, cost=0.016710
2025-10-15 17:13:27.524 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:13:27.524 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-15 17:13:35.832 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=271, cost=0.017250
2025-10-15 17:13:35.833 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:13:35.833 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-15 17:13:40.987 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=177, cost=0.014430
2025-10-15 17:13:40.988 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:13:40.994 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-15 17:13:47.938 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=272, cost=0.017280
2025-10-15 17:13:47.939 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:13:47.939 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-15 17:13:55.182 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=271, cost=0.017250
2025-10-15 17:13:55.183 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-15 17:13:55.183 | DEBUG    | Agent proxy return the following json: None
2025-10-15 17:13:55.184 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-15 17:13:55.185 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 17:13:55.185 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:14:08.331 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6155, output_tokens=458, cost=0.075290
2025-10-15 17:14:08.340 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:14:10.599 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=812, output_tokens=51, cost=0.009650
2025-10-15 17:14:10.600 | DEBUG    | Extracted a valid json.
2025-10-15 17:14:10.600 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"MigrationAutodetector\", \"django/db/migrations/autodetector.py\")",
        "search_method(\"deconstruct\")"
    ],
    "bug_locations": []
}
2025-10-15 17:14:10.844 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 17:14:10.845 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 17:14:35.323 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=21821, output_tokens=667, cost=0.238220
2025-10-15 17:14:35.337 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 17:14:49.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=22704, output_tokens=401, cost=0.239070
2025-10-15 17:14:49.053 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 17:14:56.160 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=755, output_tokens=224, cost=0.014270
2025-10-15 17:14:56.161 | DEBUG    | Extracted a valid json.
2025-10-15 17:14:56.161 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "MigrationAutodetector",
            "method": "",
            "intended_behavior": "When a primary key field's db_collation is altered, the MigrationAutodetector should not only generate an AlterField operation for this field but also ensure that any foreign key fields referencing it are included in the migration operations with their db_collation altered to match. This involves extending the field comparison mechanism to recognize changes in db_collation as significant for migration, automatically generating AlterField operations for both the changed field and any referencing foreign key fields, and ensuring that these operations are executed in a sequence that maintains referential integrity and consistency across the database schema. Additionally, it's essential to ensure that dependency management within the generated migrations accounts for these operations, including setting the correct dependencies in the migration file to ensure that the AlterField operation for the foreign key fields is executed after the alteration of the primary key field they reference."
        }
    ]
}
2025-10-15 17:14:56.171 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>None</method>
<code>
20 class MigrationAutodetector:
21     """
22     Take a pair of ProjectStates and compare them to see what the first would
23     need doing to make it match the second (the second usually being the
24     project's current state).
25 
26     Note that this naturally operates on entire projects at a time,
27     as it's likely that changes interact (for example, you can't
28     add a ForeignKey without having a migration to add the table it
29     depends on first). A user interface may offer single-app usage
30     if it wishes, with the caveat that it may not always be possible.
31     """
32 
33     def __init__(self, from_state, to_state, questioner=None):
34         self.from_state = from_state
35         self.to_state = to_state
36         self.questioner = questioner or MigrationQuestioner()
37         self.existing_apps = {app for app, model in from_state.models}
38 
39     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
40         """
41         Main entry point to produce a list of applicable changes.
42         Take a graph to base names on and an optional set of apps
43         to try and restrict to (restriction is not guaranteed)
44         """
45         changes = self._detect_changes(convert_apps, graph)
46         changes = self.arrange_for_graph(changes, graph, migration_name)
47         if trim_to_apps:
48             changes = self._trim_to_apps(changes, trim_to_apps)
49         return changes
50 
51     def deep_deconstruct(self, obj):
52         """
53         Recursive deconstruction for a field and its arguments.
54         Used for full comparison for rename/alter; sometimes a single-level
55         deconstruction will not compare correctly.
56         """
57         if isinstance(obj, list):
58             return [self.deep_deconstruct(value) for value in obj]
59         elif isinstance(obj, tuple):
60             return tuple(self.deep_deconstruct(value) for value in obj)
61         elif isinstance(obj, dict):
62             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
63         elif isinstance(obj, functools.partial):
64             return (
65                 obj.func,
66                 self.deep_deconstruct(obj.args),
67                 self.deep_deconstruct(obj.keywords),
68             )
69         elif isinstance(obj, COMPILED_REGEX_TYPE):
70             return RegexObject(obj)
71         elif isinstance(obj, type):
72             # If this is a type that implements 'deconstruct' as an instance method,
73             # avoid treating this as being deconstructible itself - see #22951
74             return obj
75         elif hasattr(obj, "deconstruct"):
76             deconstructed = obj.deconstruct()
77             if isinstance(obj, models.Field):
78                 # we have a field which also returns a name
79                 deconstructed = deconstructed[1:]
80             path, args, kwargs = deconstructed
81             return (
82                 path,
83                 [self.deep_deconstruct(value) for value in args],
84                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as
93         the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields.items()):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 deconstruction[2].pop("to", None)
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for (app_label, model_name), model_state in self.from_state.models.items():
135             if not model_state.options.get("managed", True):
136                 self.old_unmanaged_keys.add((app_label, model_name))
137             elif app_label not in self.from_state.real_apps:
138                 if model_state.options.get("proxy"):
139                     self.old_proxy_keys.add((app_label, model_name))
140                 else:
141                     self.old_model_keys.add((app_label, model_name))
142 
143         for (app_label, model_name), model_state in self.to_state.models.items():
144             if not model_state.options.get("managed", True):
145                 self.new_unmanaged_keys.add((app_label, model_name))
146             elif app_label not in self.from_state.real_apps or (
147                 convert_apps and app_label in convert_apps
148             ):
149                 if model_state.options.get("proxy"):
150                     self.new_proxy_keys.add((app_label, model_name))
151                 else:
152                     self.new_model_keys.add((app_label, model_name))
153 
154         self.from_state.resolve_fields_and_relations()
155         self.to_state.resolve_fields_and_relations()
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field renaming operations.
181         self.generate_renamed_fields()
182         # Generate removal of foo together.
183         self.generate_removed_altered_unique_together()
184         self.generate_removed_altered_index_together()
185         # Generate field operations.
186         self.generate_removed_fields()
187         self.generate_added_fields()
188         self.generate_altered_fields()
189         self.generate_altered_order_with_respect_to()
190         self.generate_altered_unique_together()
191         self.generate_altered_index_together()
192         self.generate_added_indexes()
193         self.generate_added_constraints()
194         self.generate_altered_db_table()
195 
196         self._sort_migrations()
197         self._build_migration_list(graph)
198         self._optimize_migrations()
199 
200         return self.migrations
201 
202     def _prepare_field_lists(self):
203         """
204         Prepare field lists and a list of the fields that used through models
205         in the old state so dependencies can be made from the through model
206         deletion to the field that uses it.
207         """
208         self.kept_model_keys = self.old_model_keys & self.new_model_keys
209         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
210         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
211         self.through_users = {}
212         self.old_field_keys = {
213             (app_label, model_name, field_name)
214             for app_label, model_name in self.kept_model_keys
215             for field_name in self.from_state.models[
216                 app_label, self.renamed_models.get((app_label, model_name), model_name)
217             ].fields
218         }
219         self.new_field_keys = {
220             (app_label, model_name, field_name)
221             for app_label, model_name in self.kept_model_keys
222             for field_name in self.to_state.models[app_label, model_name].fields
223         }
224 
225     def _generate_through_model_map(self):
226         """Through model map generation."""
227         for app_label, model_name in sorted(self.old_model_keys):
228             old_model_name = self.renamed_models.get(
229                 (app_label, model_name), model_name
230             )
231             old_model_state = self.from_state.models[app_label, old_model_name]
232             for field_name, field in old_model_state.fields.items():
233                 if hasattr(field, "remote_field") and getattr(
234                     field.remote_field, "through", None
235                 ):
236                     through_key = resolve_relation(
237                         field.remote_field.through, app_label, model_name
238                     )
239                     self.through_users[through_key] = (
240                         app_label,
241                         old_model_name,
242                         field_name,
243                     )
244 
245     @staticmethod
246     def _resolve_dependency(dependency):
247         """
248         Return the resolved dependency and a boolean denoting whether or not
249         it was swappable.
250         """
251         if dependency[0] != "__setting__":
252             return dependency, False
253         resolved_app_label, resolved_object_name = getattr(
254             settings, dependency[1]
255         ).split(".")
256         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
257 
258     def _build_migration_list(self, graph=None):
259         """
260         Chop the lists of operations up into migrations with dependencies on
261         each other. Do this by going through an app's list of operations until
262         one is found that has an outgoing dependency that isn't in another
263         app's migration yet (hasn't been chopped off its list). Then chop off
264         the operations before it into a migration and move onto the next app.
265         If the loops completes without doing anything, there's a circular
266         dependency (which _should_ be impossible as the operations are
267         all split at this point so they can't depend and be depended on).
268         """
269         self.migrations = {}
270         num_ops = sum(len(x) for x in self.generated_operations.values())
271         chop_mode = False
272         while num_ops:
273             # On every iteration, we step through all the apps and see if there
274             # is a completed set of operations.
275             # If we find that a subset of the operations are complete we can
276             # try to chop it off from the rest and continue, but we only
277             # do this if we've already been through the list once before
278             # without any chopping and nothing has changed.
279             for app_label in sorted(self.generated_operations):
280                 chopped = []
281                 dependencies = set()
282                 for operation in list(self.generated_operations[app_label]):
283                     deps_satisfied = True
284                     operation_dependencies = set()
285                     for dep in operation._auto_deps:
286                         # Temporarily resolve the swappable dependency to
287                         # prevent circular references. While keeping the
288                         # dependency checks on the resolved model, add the
289                         # swappable dependencies.
290                         original_dep = dep
291                         dep, is_swappable_dep = self._resolve_dependency(dep)
292                         if dep[0] != app_label:
293                             # External app dependency. See if it's not yet
294                             # satisfied.
295                             for other_operation in self.generated_operations.get(
296                                 dep[0], []
297                             ):
298                                 if self.check_dependency(other_operation, dep):
299                                     deps_satisfied = False
300                                     break
301                             if not deps_satisfied:
302                                 break
303                             else:
304                                 if is_swappable_dep:
305                                     operation_dependencies.add(
306                                         (original_dep[0], original_dep[1])
307                                     )
308                                 elif dep[0] in self.migrations:
309                                     operation_dependencies.add(
310                                         (dep[0], self.migrations[dep[0]][-1].name)
311                                     )
312                                 else:
313                                     # If we can't find the other app, we add a
314                                     # first/last dependency, but only if we've
315                                     # already been through once and checked
316                                     # everything.
317                                     if chop_mode:
318                                         # If the app already exists, we add a
319                                         # dependency on the last migration, as
320                                         # we don't know which migration
321                                         # contains the target field. If it's
322                                         # not yet migrated or has no
323                                         # migrations, we use __first__.
324                                         if graph and graph.leaf_nodes(dep[0]):
325                                             operation_dependencies.add(
326                                                 graph.leaf_nodes(dep[0])[0]
327                                             )
328                                         else:
329                                             operation_dependencies.add(
330                                                 (dep[0], "__first__")
331                                             )
332                                     else:
333                                         deps_satisfied = False
334                     if deps_satisfied:
335                         chopped.append(operation)
336                         dependencies.update(operation_dependencies)
337                         del self.generated_operations[app_label][0]
338                     else:
339                         break
340                 # Make a migration! Well, only if there's stuff to put in it
341                 if dependencies or chopped:
342                     if not self.generated_operations[app_label] or chop_mode:
343                         subclass = type(
344                             "Migration",
345                             (Migration,),
346                             {"operations": [], "dependencies": []},
347                         )
348                         instance = subclass(
349                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
350                             app_label,
351                         )
352                         instance.dependencies = list(dependencies)
353                         instance.operations = chopped
354                         instance.initial = app_label not in self.existing_apps
355                         self.migrations.setdefault(app_label, []).append(instance)
356                         chop_mode = False
357                     else:
358                         self.generated_operations[app_label] = (
359                             chopped + self.generated_operations[app_label]
360                         )
361             new_num_ops = sum(len(x) for x in self.generated_operations.values())
362             if new_num_ops == num_ops:
363                 if not chop_mode:
364                     chop_mode = True
365                 else:
366                     raise ValueError(
367                         "Cannot resolve operation dependencies: %r"
368                         % self.generated_operations
369                     )
370             num_ops = new_num_ops
371 
372     def _sort_migrations(self):
373         """
374         Reorder to make things possible. Reordering may be needed so FKs work
375         nicely inside the same app.
376         """
377         for app_label, ops in sorted(self.generated_operations.items()):
378             # construct a dependency graph for intra-app dependencies
379             dependency_graph = {op: set() for op in ops}
380             for op in ops:
381                 for dep in op._auto_deps:
382                     # Resolve intra-app dependencies to handle circular
383                     # references involving a swappable model.
384                     dep = self._resolve_dependency(dep)[0]
385                     if dep[0] == app_label:
386                         for op2 in ops:
387                             if self.check_dependency(op2, dep):
388                                 dependency_graph[op].add(op2)
389 
390             # we use a stable sort for deterministic tests & general behavior
391             self.generated_operations[app_label] = stable_topological_sort(
392                 ops, dependency_graph
393             )
394 
395     def _optimize_migrations(self):
396         # Add in internal dependencies among the migrations
397         for app_label, migrations in self.migrations.items():
398             for m1, m2 in zip(migrations, migrations[1:]):
399                 m2.dependencies.append((app_label, m1.name))
400 
401         # De-dupe dependencies
402         for migrations in self.migrations.values():
403             for migration in migrations:
404                 migration.dependencies = list(set(migration.dependencies))
405 
406         # Optimize migrations
407         for app_label, migrations in self.migrations.items():
408             for migration in migrations:
409                 migration.operations = MigrationOptimizer().optimize(
410                     migration.operations, app_label
411                 )
412 
413     def check_dependency(self, operation, dependency):
414         """
415         Return True if the given operation depends on the given dependency,
416         False otherwise.
417         """
418         # Created model
419         if dependency[2] is None and dependency[3] is True:
420             return (
421                 isinstance(operation, operations.CreateModel)
422                 and operation.name_lower == dependency[1].lower()
423             )
424         # Created field
425         elif dependency[2] is not None and dependency[3] is True:
426             return (
427                 isinstance(operation, operations.CreateModel)
428                 and operation.name_lower == dependency[1].lower()
429                 and any(dependency[2] == x for x, y in operation.fields)
430             ) or (
431                 isinstance(operation, operations.AddField)
432                 and operation.model_name_lower == dependency[1].lower()
433                 and operation.name_lower == dependency[2].lower()
434             )
435         # Removed field
436         elif dependency[2] is not None and dependency[3] is False:
437             return (
438                 isinstance(operation, operations.RemoveField)
439                 and operation.model_name_lower == dependency[1].lower()
440                 and operation.name_lower == dependency[2].lower()
441             )
442         # Removed model
443         elif dependency[2] is None and dependency[3] is False:
444             return (
445                 isinstance(operation, operations.DeleteModel)
446                 and operation.name_lower == dependency[1].lower()
447             )
448         # Field being altered
449         elif dependency[2] is not None and dependency[3] == "alter":
450             return (
451                 isinstance(operation, operations.AlterField)
452                 and operation.model_name_lower == dependency[1].lower()
453                 and operation.name_lower == dependency[2].lower()
454             )
455         # order_with_respect_to being unset for a field
456         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
457             return (
458                 isinstance(operation, operations.AlterOrderWithRespectTo)
459                 and operation.name_lower == dependency[1].lower()
460                 and (operation.order_with_respect_to or "").lower()
461                 != dependency[2].lower()
462             )
463         # Field is removed and part of an index/unique_together
464         elif dependency[2] is not None and dependency[3] == "foo_together_change":
465             return (
466                 isinstance(
467                     operation,
468                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
469                 )
470                 and operation.name_lower == dependency[1].lower()
471             )
472         # Unknown dependency. Raise an error.
473         else:
474             raise ValueError("Can't handle dependency %r" % (dependency,))
475 
476     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
477         # Dependencies are
478         # (app_label, model_name, field_name, create/delete as True/False)
479         operation._auto_deps = dependencies or []
480         if beginning:
481             self.generated_operations.setdefault(app_label, []).insert(0, operation)
482         else:
483             self.generated_operations.setdefault(app_label, []).append(operation)
484 
485     def swappable_first_key(self, item):
486         """
487         Place potential swappable models first in lists of created models (only
488         real way to solve #22783).
489         """
490         try:
491             model_state = self.to_state.models[item]
492             base_names = {
493                 base if isinstance(base, str) else base.__name__
494                 for base in model_state.bases
495             }
496             string_version = "%s.%s" % (item[0], item[1])
497             if (
498                 model_state.options.get("swappable")
499                 or "AbstractUser" in base_names
500                 or "AbstractBaseUser" in base_names
501                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
502             ):
503                 return ("___" + item[0], "___" + item[1])
504         except LookupError:
505             pass
506         return item
507 
508     def generate_renamed_models(self):
509         """
510         Find any renamed models, generate the operations for them, and remove
511         the old entry from the model lists. Must be run before other
512         model-level generation.
513         """
514         self.renamed_models = {}
515         self.renamed_models_rel = {}
516         added_models = self.new_model_keys - self.old_model_keys
517         for app_label, model_name in sorted(added_models):
518             model_state = self.to_state.models[app_label, model_name]
519             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
520 
521             removed_models = self.old_model_keys - self.new_model_keys
522             for rem_app_label, rem_model_name in removed_models:
523                 if rem_app_label == app_label:
524                     rem_model_state = self.from_state.models[
525                         rem_app_label, rem_model_name
526                     ]
527                     rem_model_fields_def = self.only_relation_agnostic_fields(
528                         rem_model_state.fields
529                     )
530                     if model_fields_def == rem_model_fields_def:
531                         if self.questioner.ask_rename_model(
532                             rem_model_state, model_state
533                         ):
534                             dependencies = []
535                             fields = list(model_state.fields.values()) + [
536                                 field.remote_field
537                                 for relations in self.to_state.relations[
538                                     app_label, model_name
539                                 ].values()
540                                 for field in relations.values()
541                             ]
542                             for field in fields:
543                                 if field.is_relation:
544                                     dependencies.extend(
545                                         self._get_dependencies_for_foreign_key(
546                                             app_label,
547                                             model_name,
548                                             field,
549                                             self.to_state,
550                                         )
551                                     )
552                             self.add_operation(
553                                 app_label,
554                                 operations.RenameModel(
555                                     old_name=rem_model_state.name,
556                                     new_name=model_state.name,
557                                 ),
558                                 dependencies=dependencies,
559                             )
560                             self.renamed_models[app_label, model_name] = rem_model_name
561                             renamed_models_rel_key = "%s.%s" % (
562                                 rem_model_state.app_label,
563                                 rem_model_state.name_lower,
564                             )
565                             self.renamed_models_rel[
566                                 renamed_models_rel_key
567                             ] = "%s.%s" % (
568                                 model_state.app_label,
569                                 model_state.name_lower,
570                             )
571                             self.old_model_keys.remove((rem_app_label, rem_model_name))
572                             self.old_model_keys.add((app_label, model_name))
573                             break
574 
575     def generate_created_models(self):
576         """
577         Find all new models (both managed and unmanaged) and make create
578         operations for them as well as separate operations to create any
579         foreign key or M2M relationships (these are optimized later, if
580         possible).
581 
582         Defer any model options that refer to collections of fields that might
583         be deferred (e.g. unique_together, index_together).
584         """
585         old_keys = self.old_model_keys | self.old_unmanaged_keys
586         added_models = self.new_model_keys - old_keys
587         added_unmanaged_models = self.new_unmanaged_keys - old_keys
588         all_added_models = chain(
589             sorted(added_models, key=self.swappable_first_key, reverse=True),
590             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
591         )
592         for app_label, model_name in all_added_models:
593             model_state = self.to_state.models[app_label, model_name]
594             # Gather related fields
595             related_fields = {}
596             primary_key_rel = None
597             for field_name, field in model_state.fields.items():
598                 if field.remote_field:
599                     if field.remote_field.model:
600                         if field.primary_key:
601                             primary_key_rel = field.remote_field.model
602                         elif not field.remote_field.parent_link:
603                             related_fields[field_name] = field
604                     if getattr(field.remote_field, "through", None):
605                         related_fields[field_name] = field
606 
607             # Are there indexes/unique|index_together to defer?
608             indexes = model_state.options.pop("indexes")
609             constraints = model_state.options.pop("constraints")
610             unique_together = model_state.options.pop("unique_together", None)
611             index_together = model_state.options.pop("index_together", None)
612             order_with_respect_to = model_state.options.pop(
613                 "order_with_respect_to", None
614             )
615             # Depend on the deletion of any possible proxy version of us
616             dependencies = [
617                 (app_label, model_name, None, False),
618             ]
619             # Depend on all bases
620             for base in model_state.bases:
621                 if isinstance(base, str) and "." in base:
622                     base_app_label, base_name = base.split(".", 1)
623                     dependencies.append((base_app_label, base_name, None, True))
624                     # Depend on the removal of base fields if the new model has
625                     # a field with the same name.
626                     old_base_model_state = self.from_state.models.get(
627                         (base_app_label, base_name)
628                     )
629                     new_base_model_state = self.to_state.models.get(
630                         (base_app_label, base_name)
631                     )
632                     if old_base_model_state and new_base_model_state:
633                         removed_base_fields = (
634                             set(old_base_model_state.fields)
635                             .difference(
636                                 new_base_model_state.fields,
637                             )
638                             .intersection(model_state.fields)
639                         )
640                         for removed_base_field in removed_base_fields:
641                             dependencies.append(
642                                 (base_app_label, base_name, removed_base_field, False)
643                             )
644             # Depend on the other end of the primary key if it's a relation
645             if primary_key_rel:
646                 dependencies.append(
647                     resolve_relation(
648                         primary_key_rel,
649                         app_label,
650                         model_name,
651                     )
652                     + (None, True)
653                 )
654             # Generate creation operation
655             self.add_operation(
656                 app_label,
657                 operations.CreateModel(
658                     name=model_state.name,
659                     fields=[
660                         d
661                         for d in model_state.fields.items()
662                         if d[0] not in related_fields
663                     ],
664                     options=model_state.options,
665                     bases=model_state.bases,
666                     managers=model_state.managers,
667                 ),
668                 dependencies=dependencies,
669                 beginning=True,
670             )
671 
672             # Don't add operations which modify the database for unmanaged models
673             if not model_state.options.get("managed", True):
674                 continue
675 
676             # Generate operations for each related field
677             for name, field in sorted(related_fields.items()):
678                 dependencies = self._get_dependencies_for_foreign_key(
679                     app_label,
680                     model_name,
681                     field,
682                     self.to_state,
683                 )
684                 # Depend on our own model being created
685                 dependencies.append((app_label, model_name, None, True))
686                 # Make operation
687                 self.add_operation(
688                     app_label,
689                     operations.AddField(
690                         model_name=model_name,
691                         name=name,
692                         field=field,
693                     ),
694                     dependencies=list(set(dependencies)),
695                 )
696             # Generate other opns
697             if order_with_respect_to:
698                 self.add_operation(
699                     app_label,
700                     operations.AlterOrderWithRespectTo(
701                         name=model_name,
702                         order_with_respect_to=order_with_respect_to,
703                     ),
704                     dependencies=[
705                         (app_label, model_name, order_with_respect_to, True),
706                         (app_label, model_name, None, True),
707                     ],
708                 )
709             related_dependencies = [
710                 (app_label, model_name, name, True) for name in sorted(related_fields)
711             ]
712             related_dependencies.append((app_label, model_name, None, True))
713             for index in indexes:
714                 self.add_operation(
715                     app_label,
716                     operations.AddIndex(
717                         model_name=model_name,
718                         index=index,
719                     ),
720                     dependencies=related_dependencies,
721                 )
722             for constraint in constraints:
723                 self.add_operation(
724                     app_label,
725                     operations.AddConstraint(
726                         model_name=model_name,
727                         constraint=constraint,
728                     ),
729                     dependencies=related_dependencies,
730                 )
731             if unique_together:
732                 self.add_operation(
733                     app_label,
734                     operations.AlterUniqueTogether(
735                         name=model_name,
736                         unique_together=unique_together,
737                     ),
738                     dependencies=related_dependencies,
739                 )
740             if index_together:
741                 self.add_operation(
742                     app_label,
743                     operations.AlterIndexTogether(
744                         name=model_name,
745                         index_together=index_together,
746                     ),
747                     dependencies=related_dependencies,
748                 )
749             # Fix relationships if the model changed from a proxy model to a
750             # concrete model.
751             relations = self.to_state.relations
752             if (app_label, model_name) in self.old_proxy_keys:
753                 for related_model_key, related_fields in relations[
754                     app_label, model_name
755                 ].items():
756                     related_model_state = self.to_state.models[related_model_key]
757                     for related_field_name, related_field in related_fields.items():
758                         self.add_operation(
759                             related_model_state.app_label,
760                             operations.AlterField(
761                                 model_name=related_model_state.name,
762                                 name=related_field_name,
763                                 field=related_field,
764                             ),
765                             dependencies=[(app_label, model_name, None, True)],
766                         )
767 
768     def generate_created_proxies(self):
769         """
770         Make CreateModel statements for proxy models. Use the same statements
771         as that way there's less code duplication, but for proxy models it's
772         safe to skip all the pointless field stuff and chuck out an operation.
773         """
774         added = self.new_proxy_keys - self.old_proxy_keys
775         for app_label, model_name in sorted(added):
776             model_state = self.to_state.models[app_label, model_name]
777             assert model_state.options.get("proxy")
778             # Depend on the deletion of any possible non-proxy version of us
779             dependencies = [
780                 (app_label, model_name, None, False),
781             ]
782             # Depend on all bases
783             for base in model_state.bases:
784                 if isinstance(base, str) and "." in base:
785                     base_app_label, base_name = base.split(".", 1)
786                     dependencies.append((base_app_label, base_name, None, True))
787             # Generate creation operation
788             self.add_operation(
789                 app_label,
790                 operations.CreateModel(
791                     name=model_state.name,
792                     fields=[],
793                     options=model_state.options,
794                     bases=model_state.bases,
795                     managers=model_state.managers,
796                 ),
797                 # Depend on the deletion of any possible non-proxy version of us
798                 dependencies=dependencies,
799             )
800 
801     def generate_deleted_models(self):
802         """
803         Find all deleted models (managed and unmanaged) and make delete
804         operations for them as well as separate operations to delete any
805         foreign key or M2M relationships (these are optimized later, if
806         possible).
807 
808         Also bring forward removal of any model options that refer to
809         collections of fields - the inverse of generate_created_models().
810         """
811         new_keys = self.new_model_keys | self.new_unmanaged_keys
812         deleted_models = self.old_model_keys - new_keys
813         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
814         all_deleted_models = chain(
815             sorted(deleted_models), sorted(deleted_unmanaged_models)
816         )
817         for app_label, model_name in all_deleted_models:
818             model_state = self.from_state.models[app_label, model_name]
819             # Gather related fields
820             related_fields = {}
821             for field_name, field in model_state.fields.items():
822                 if field.remote_field:
823                     if field.remote_field.model:
824                         related_fields[field_name] = field
825                     if getattr(field.remote_field, "through", None):
826                         related_fields[field_name] = field
827             # Generate option removal first
828             unique_together = model_state.options.pop("unique_together", None)
829             index_together = model_state.options.pop("index_together", None)
830             if unique_together:
831                 self.add_operation(
832                     app_label,
833                     operations.AlterUniqueTogether(
834                         name=model_name,
835                         unique_together=None,
836                     ),
837                 )
838             if index_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterIndexTogether(
842                         name=model_name,
843                         index_together=None,
844                     ),
845                 )
846             # Then remove each related field
847             for name in sorted(related_fields):
848                 self.add_operation(
849                     app_label,
850                     operations.RemoveField(
851                         model_name=model_name,
852                         name=name,
853                     ),
854                 )
855             # Finally, remove the model.
856             # This depends on both the removal/alteration of all incoming fields
857             # and the removal of all its own related fields, and if it's
858             # a through model the field that references it.
859             dependencies = []
860             relations = self.from_state.relations
861             for (
862                 related_object_app_label,
863                 object_name,
864             ), relation_related_fields in relations[app_label, model_name].items():
865                 for field_name, field in relation_related_fields.items():
866                     dependencies.append(
867                         (related_object_app_label, object_name, field_name, False),
868                     )
869                     if not field.many_to_many:
870                         dependencies.append(
871                             (
872                                 related_object_app_label,
873                                 object_name,
874                                 field_name,
875                                 "alter",
876                             ),
877                         )
878 
879             for name in sorted(related_fields):
880                 dependencies.append((app_label, model_name, name, False))
881             # We're referenced in another field's through=
882             through_user = self.through_users.get((app_label, model_state.name_lower))
883             if through_user:
884                 dependencies.append(
885                     (through_user[0], through_user[1], through_user[2], False)
886                 )
887             # Finally, make the operation, deduping any dependencies
888             self.add_operation(
889                 app_label,
890                 operations.DeleteModel(
891                     name=model_state.name,
892                 ),
893                 dependencies=list(set(dependencies)),
894             )
895 
896     def generate_deleted_proxies(self):
897         """Make DeleteModel options for proxy models."""
898         deleted = self.old_proxy_keys - self.new_proxy_keys
899         for app_label, model_name in sorted(deleted):
900             model_state = self.from_state.models[app_label, model_name]
901             assert model_state.options.get("proxy")
902             self.add_operation(
903                 app_label,
904                 operations.DeleteModel(
905                     name=model_state.name,
906                 ),
907             )
908 
909     def generate_renamed_fields(self):
910         """Work out renamed fields."""
911         self.renamed_fields = {}
912         for app_label, model_name, field_name in sorted(
913             self.new_field_keys - self.old_field_keys
914         ):
915             old_model_name = self.renamed_models.get(
916                 (app_label, model_name), model_name
917             )
918             old_model_state = self.from_state.models[app_label, old_model_name]
919             new_model_state = self.to_state.models[app_label, model_name]
920             field = new_model_state.get_field(field_name)
921             # Scan to see if this is actually a rename!
922             field_dec = self.deep_deconstruct(field)
923             for rem_app_label, rem_model_name, rem_field_name in sorted(
924                 self.old_field_keys - self.new_field_keys
925             ):
926                 if rem_app_label == app_label and rem_model_name == model_name:
927                     old_field = old_model_state.get_field(rem_field_name)
928                     old_field_dec = self.deep_deconstruct(old_field)
929                     if (
930                         field.remote_field
931                         and field.remote_field.model
932                         and "to" in old_field_dec[2]
933                     ):
934                         old_rel_to = old_field_dec[2]["to"]
935                         if old_rel_to in self.renamed_models_rel:
936                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
937                     old_field.set_attributes_from_name(rem_field_name)
938                     old_db_column = old_field.get_attname_column()[1]
939                     if old_field_dec == field_dec or (
940                         # Was the field renamed and db_column equal to the
941                         # old field's column added?
942                         old_field_dec[0:2] == field_dec[0:2]
943                         and dict(old_field_dec[2], db_column=old_db_column)
944                         == field_dec[2]
945                     ):
946                         if self.questioner.ask_rename(
947                             model_name, rem_field_name, field_name, field
948                         ):
949                             # A db_column mismatch requires a prior noop
950                             # AlterField for the subsequent RenameField to be a
951                             # noop on attempts at preserving the old name.
952                             if old_field.db_column != field.db_column:
953                                 altered_field = field.clone()
954                                 altered_field.name = rem_field_name
955                                 self.add_operation(
956                                     app_label,
957                                     operations.AlterField(
958                                         model_name=model_name,
959                                         name=rem_field_name,
960                                         field=altered_field,
961                                     ),
962                                 )
963                             self.add_operation(
964                                 app_label,
965                                 operations.RenameField(
966                                     model_name=model_name,
967                                     old_name=rem_field_name,
968                                     new_name=field_name,
969                                 ),
970                             )
971                             self.old_field_keys.remove(
972                                 (rem_app_label, rem_model_name, rem_field_name)
973                             )
974                             self.old_field_keys.add((app_label, model_name, field_name))
975                             self.renamed_fields[
976                                 app_label, model_name, field_name
977                             ] = rem_field_name
978                             break
979 
980     def generate_added_fields(self):
981         """Make AddField operations."""
982         for app_label, model_name, field_name in sorted(
983             self.new_field_keys - self.old_field_keys
984         ):
985             self._generate_added_field(app_label, model_name, field_name)
986 
987     def _generate_added_field(self, app_label, model_name, field_name):
988         field = self.to_state.models[app_label, model_name].get_field(field_name)
989         # Fields that are foreignkeys/m2ms depend on stuff
990         dependencies = []
991         if field.remote_field and field.remote_field.model:
992             dependencies.extend(
993                 self._get_dependencies_for_foreign_key(
994                     app_label,
995                     model_name,
996                     field,
997                     self.to_state,
998                 )
999             )
1000         # You can't just add NOT NULL fields with no default or fields
1001         # which don't allow empty strings as default.
1002         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1003         preserve_default = (
1004             field.null
1005             or field.has_default()
1006             or field.many_to_many
1007             or (field.blank and field.empty_strings_allowed)
1008             or (isinstance(field, time_fields) and field.auto_now)
1009         )
1010         if not preserve_default:
1011             field = field.clone()
1012             if isinstance(field, time_fields) and field.auto_now_add:
1013                 field.default = self.questioner.ask_auto_now_add_addition(
1014                     field_name, model_name
1015                 )
1016             else:
1017                 field.default = self.questioner.ask_not_null_addition(
1018                     field_name, model_name
1019                 )
1020         if (
1021             field.unique
1022             and field.default is not models.NOT_PROVIDED
1023             and callable(field.default)
1024         ):
1025             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1026         self.add_operation(
1027             app_label,
1028             operations.AddField(
1029                 model_name=model_name,
1030                 name=field_name,
1031                 field=field,
1032                 preserve_default=preserve_default,
1033             ),
1034             dependencies=dependencies,
1035         )
1036 
1037     def generate_removed_fields(self):
1038         """Make RemoveField operations."""
1039         for app_label, model_name, field_name in sorted(
1040             self.old_field_keys - self.new_field_keys
1041         ):
1042             self._generate_removed_field(app_label, model_name, field_name)
1043 
1044     def _generate_removed_field(self, app_label, model_name, field_name):
1045         self.add_operation(
1046             app_label,
1047             operations.RemoveField(
1048                 model_name=model_name,
1049                 name=field_name,
1050             ),
1051             # We might need to depend on the removal of an
1052             # order_with_respect_to or index/unique_together operation;
1053             # this is safely ignored if there isn't one
1054             dependencies=[
1055                 (app_label, model_name, field_name, "order_wrt_unset"),
1056                 (app_label, model_name, field_name, "foo_together_change"),
1057             ],
1058         )
1059 
1060     def generate_altered_fields(self):
1061         """
1062         Make AlterField operations, or possibly RemovedField/AddField if alter
1063         isn't possible.
1064         """
1065         for app_label, model_name, field_name in sorted(
1066             self.old_field_keys & self.new_field_keys
1067         ):
1068             # Did the field change?
1069             old_model_name = self.renamed_models.get(
1070                 (app_label, model_name), model_name
1071             )
1072             old_field_name = self.renamed_fields.get(
1073                 (app_label, model_name, field_name), field_name
1074             )
1075             old_field = self.from_state.models[app_label, old_model_name].get_field(
1076                 old_field_name
1077             )
1078             new_field = self.to_state.models[app_label, model_name].get_field(
1079                 field_name
1080             )
1081             dependencies = []
1082             # Implement any model renames on relations; these are handled by RenameModel
1083             # so we need to exclude them from the comparison
1084             if hasattr(new_field, "remote_field") and getattr(
1085                 new_field.remote_field, "model", None
1086             ):
1087                 rename_key = resolve_relation(
1088                     new_field.remote_field.model, app_label, model_name
1089                 )
1090                 if rename_key in self.renamed_models:
1091                     new_field.remote_field.model = old_field.remote_field.model
1092                 # Handle ForeignKey which can only have a single to_field.
1093                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1094                 if remote_field_name:
1095                     to_field_rename_key = rename_key + (remote_field_name,)
1096                     if to_field_rename_key in self.renamed_fields:
1097                         # Repoint both model and field name because to_field
1098                         # inclusion in ForeignKey.deconstruct() is based on
1099                         # both.
1100                         new_field.remote_field.model = old_field.remote_field.model
1101                         new_field.remote_field.field_name = (
1102                             old_field.remote_field.field_name
1103                         )
1104                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1105                 from_fields = getattr(new_field, "from_fields", None)
1106                 if from_fields:
1107                     from_rename_key = (app_label, model_name)
1108                     new_field.from_fields = tuple(
1109                         [
1110                             self.renamed_fields.get(
1111                                 from_rename_key + (from_field,), from_field
1112                             )
1113                             for from_field in from_fields
1114                         ]
1115                     )
1116                     new_field.to_fields = tuple(
1117                         [
1118                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1119                             for to_field in new_field.to_fields
1120                         ]
1121                     )
1122                 dependencies.extend(
1123                     self._get_dependencies_for_foreign_key(
1124                         app_label,
1125                         model_name,
1126                         new_field,
1127                         self.to_state,
1128                     )
1129                 )
1130             if hasattr(new_field, "remote_field") and getattr(
1131                 new_field.remote_field, "through", None
1132             ):
1133                 rename_key = resolve_relation(
1134                     new_field.remote_field.through, app_label, model_name
1135                 )
1136                 if rename_key in self.renamed_models:
1137                     new_field.remote_field.through = old_field.remote_field.through
1138             old_field_dec = self.deep_deconstruct(old_field)
1139             new_field_dec = self.deep_deconstruct(new_field)
1140             # If the field was confirmed to be renamed it means that only
1141             # db_column was allowed to change which generate_renamed_fields()
1142             # already accounts for by adding an AlterField operation.
1143             if old_field_dec != new_field_dec and old_field_name == field_name:
1144                 both_m2m = old_field.many_to_many and new_field.many_to_many
1145                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1146                 if both_m2m or neither_m2m:
1147                     # Either both fields are m2m or neither is
1148                     preserve_default = True
1149                     if (
1150                         old_field.null
1151                         and not new_field.null
1152                         and not new_field.has_default()
1153                         and not new_field.many_to_many
1154                     ):
1155                         field = new_field.clone()
1156                         new_default = self.questioner.ask_not_null_alteration(
1157                             field_name, model_name
1158                         )
1159                         if new_default is not models.NOT_PROVIDED:
1160                             field.default = new_default
1161                             preserve_default = False
1162                     else:
1163                         field = new_field
1164                     self.add_operation(
1165                         app_label,
1166                         operations.AlterField(
1167                             model_name=model_name,
1168                             name=field_name,
1169                             field=field,
1170                             preserve_default=preserve_default,
1171                         ),
1172                         dependencies=dependencies,
1173                     )
1174                 else:
1175                     # We cannot alter between m2m and concrete fields
1176                     self._generate_removed_field(app_label, model_name, field_name)
1177                     self._generate_added_field(app_label, model_name, field_name)
1178 
1179     def create_altered_indexes(self):
1180         option_name = operations.AddIndex.option_name
1181         for app_label, model_name in sorted(self.kept_model_keys):
1182             old_model_name = self.renamed_models.get(
1183                 (app_label, model_name), model_name
1184             )
1185             old_model_state = self.from_state.models[app_label, old_model_name]
1186             new_model_state = self.to_state.models[app_label, model_name]
1187 
1188             old_indexes = old_model_state.options[option_name]
1189             new_indexes = new_model_state.options[option_name]
1190             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1191             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1192 
1193             self.altered_indexes.update(
1194                 {
1195                     (app_label, model_name): {
1196                         "added_indexes": add_idx,
1197                         "removed_indexes": rem_idx,
1198                     }
1199                 }
1200             )
1201 
1202     def generate_added_indexes(self):
1203         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1204             for index in alt_indexes["added_indexes"]:
1205                 self.add_operation(
1206                     app_label,
1207                     operations.AddIndex(
1208                         model_name=model_name,
1209                         index=index,
1210                     ),
1211                 )
1212 
1213     def generate_removed_indexes(self):
1214         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1215             for index in alt_indexes["removed_indexes"]:
1216                 self.add_operation(
1217                     app_label,
1218                     operations.RemoveIndex(
1219                         model_name=model_name,
1220                         name=index.name,
1221                     ),
1222                 )
1223 
1224     def create_altered_constraints(self):
1225         option_name = operations.AddConstraint.option_name
1226         for app_label, model_name in sorted(self.kept_model_keys):
1227             old_model_name = self.renamed_models.get(
1228                 (app_label, model_name), model_name
1229             )
1230             old_model_state = self.from_state.models[app_label, old_model_name]
1231             new_model_state = self.to_state.models[app_label, model_name]
1232 
1233             old_constraints = old_model_state.options[option_name]
1234             new_constraints = new_model_state.options[option_name]
1235             add_constraints = [c for c in new_constraints if c not in old_constraints]
1236             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1237 
1238             self.altered_constraints.update(
1239                 {
1240                     (app_label, model_name): {
1241                         "added_constraints": add_constraints,
1242                         "removed_constraints": rem_constraints,
1243                     }
1244                 }
1245             )
1246 
1247     def generate_added_constraints(self):
1248         for (
1249             app_label,
1250             model_name,
1251         ), alt_constraints in self.altered_constraints.items():
1252             for constraint in alt_constraints["added_constraints"]:
1253                 self.add_operation(
1254                     app_label,
1255                     operations.AddConstraint(
1256                         model_name=model_name,
1257                         constraint=constraint,
1258                     ),
1259                 )
1260 
1261     def generate_removed_constraints(self):
1262         for (
1263             app_label,
1264             model_name,
1265         ), alt_constraints in self.altered_constraints.items():
1266             for constraint in alt_constraints["removed_constraints"]:
1267                 self.add_operation(
1268                     app_label,
1269                     operations.RemoveConstraint(
1270                         model_name=model_name,
1271                         name=constraint.name,
1272                     ),
1273                 )
1274 
1275     @staticmethod
1276     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1277         remote_field_model = None
1278         if hasattr(field.remote_field, "model"):
1279             remote_field_model = field.remote_field.model
1280         else:
1281             relations = project_state.relations[app_label, model_name]
1282             for (remote_app_label, remote_model_name), fields in relations.items():
1283                 if any(
1284                     field == related_field.remote_field
1285                     for related_field in fields.values()
1286                 ):
1287                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1288                     break
1289         # Account for FKs to swappable models
1290         swappable_setting = getattr(field, "swappable_setting", None)
1291         if swappable_setting is not None:
1292             dep_app_label = "__setting__"
1293             dep_object_name = swappable_setting
1294         else:
1295             dep_app_label, dep_object_name = resolve_relation(
1296                 remote_field_model,
1297                 app_label,
1298                 model_name,
1299             )
1300         dependencies = [(dep_app_label, dep_object_name, None, True)]
1301         if getattr(field.remote_field, "through", None):
1302             through_app_label, through_object_name = resolve_relation(
1303                 remote_field_model,
1304                 app_label,
1305                 model_name,
1306             )
1307             dependencies.append((through_app_label, through_object_name, None, True))
1308         return dependencies
1309 
1310     def _get_altered_foo_together_operations(self, option_name):
1311         for app_label, model_name in sorted(self.kept_model_keys):
1312             old_model_name = self.renamed_models.get(
1313                 (app_label, model_name), model_name
1314             )
1315             old_model_state = self.from_state.models[app_label, old_model_name]
1316             new_model_state = self.to_state.models[app_label, model_name]
1317 
1318             # We run the old version through the field renames to account for those
1319             old_value = old_model_state.options.get(option_name)
1320             old_value = (
1321                 {
1322                     tuple(
1323                         self.renamed_fields.get((app_label, model_name, n), n)
1324                         for n in unique
1325                     )
1326                     for unique in old_value
1327                 }
1328                 if old_value
1329                 else set()
1330             )
1331 
1332             new_value = new_model_state.options.get(option_name)
1333             new_value = set(new_value) if new_value else set()
1334 
1335             if old_value != new_value:
1336                 dependencies = []
1337                 for foo_togethers in new_value:
1338                     for field_name in foo_togethers:
1339                         field = new_model_state.get_field(field_name)
1340                         if field.remote_field and field.remote_field.model:
1341                             dependencies.extend(
1342                                 self._get_dependencies_for_foreign_key(
1343                                     app_label,
1344                                     model_name,
1345                                     field,
1346                                     self.to_state,
1347                                 )
1348                             )
1349                 yield (
1350                     old_value,
1351                     new_value,
1352                     app_label,
1353                     model_name,
1354                     dependencies,
1355                 )
1356 
1357     def _generate_removed_altered_foo_together(self, operation):
1358         for (
1359             old_value,
1360             new_value,
1361             app_label,
1362             model_name,
1363             dependencies,
1364         ) in self._get_altered_foo_together_operations(operation.option_name):
1365             removal_value = new_value.intersection(old_value)
1366             if removal_value or old_value:
1367                 self.add_operation(
1368                     app_label,
1369                     operation(
1370                         name=model_name, **{operation.option_name: removal_value}
1371                     ),
1372                     dependencies=dependencies,
1373                 )
1374 
1375     def generate_removed_altered_unique_together(self):
1376         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1377 
1378     def generate_removed_altered_index_together(self):
1379         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1380 
1381     def _generate_altered_foo_together(self, operation):
1382         for (
1383             old_value,
1384             new_value,
1385             app_label,
1386             model_name,
1387             dependencies,
1388         ) in self._get_altered_foo_together_operations(operation.option_name):
1389             removal_value = new_value.intersection(old_value)
1390             if new_value != removal_value:
1391                 self.add_operation(
1392                     app_label,
1393                     operation(name=model_name, **{operation.option_name: new_value}),
1394                     dependencies=dependencies,
1395                 )
1396 
1397     def generate_altered_unique_together(self):
1398         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1399 
1400     def generate_altered_index_together(self):
1401         self._generate_altered_foo_together(operations.AlterIndexTogether)
1402 
1403     def generate_altered_db_table(self):
1404         models_to_check = self.kept_model_keys.union(
1405             self.kept_proxy_keys, self.kept_unmanaged_keys
1406         )
1407         for app_label, model_name in sorted(models_to_check):
1408             old_model_name = self.renamed_models.get(
1409                 (app_label, model_name), model_name
1410             )
1411             old_model_state = self.from_state.models[app_label, old_model_name]
1412             new_model_state = self.to_state.models[app_label, model_name]
1413             old_db_table_name = old_model_state.options.get("db_table")
1414             new_db_table_name = new_model_state.options.get("db_table")
1415             if old_db_table_name != new_db_table_name:
1416                 self.add_operation(
1417                     app_label,
1418                     operations.AlterModelTable(
1419                         name=model_name,
1420                         table=new_db_table_name,
1421                     ),
1422                 )
1423 
1424     def generate_altered_options(self):
1425         """
1426         Work out if any non-schema-affecting options have changed and make an
1427         operation to represent them in state changes (in case Python code in
1428         migrations needs them).
1429         """
1430         models_to_check = self.kept_model_keys.union(
1431             self.kept_proxy_keys,
1432             self.kept_unmanaged_keys,
1433             # unmanaged converted to managed
1434             self.old_unmanaged_keys & self.new_model_keys,
1435             # managed converted to unmanaged
1436             self.old_model_keys & self.new_unmanaged_keys,
1437         )
1438 
1439         for app_label, model_name in sorted(models_to_check):
1440             old_model_name = self.renamed_models.get(
1441                 (app_label, model_name), model_name
1442             )
1443             old_model_state = self.from_state.models[app_label, old_model_name]
1444             new_model_state = self.to_state.models[app_label, model_name]
1445             old_options = {
1446                 key: value
1447                 for key, value in old_model_state.options.items()
1448                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1449             }
1450             new_options = {
1451                 key: value
1452                 for key, value in new_model_state.options.items()
1453                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1454             }
1455             if old_options != new_options:
1456                 self.add_operation(
1457                     app_label,
1458                     operations.AlterModelOptions(
1459                         name=model_name,
1460                         options=new_options,
1461                     ),
1462                 )
1463 
1464     def generate_altered_order_with_respect_to(self):
1465         for app_label, model_name in sorted(self.kept_model_keys):
1466             old_model_name = self.renamed_models.get(
1467                 (app_label, model_name), model_name
1468             )
1469             old_model_state = self.from_state.models[app_label, old_model_name]
1470             new_model_state = self.to_state.models[app_label, model_name]
1471             if old_model_state.options.get(
1472                 "order_with_respect_to"
1473             ) != new_model_state.options.get("order_with_respect_to"):
1474                 # Make sure it comes second if we're adding
1475                 # (removal dependency is part of RemoveField)
1476                 dependencies = []
1477                 if new_model_state.options.get("order_with_respect_to"):
1478                     dependencies.append(
1479                         (
1480                             app_label,
1481                             model_name,
1482                             new_model_state.options["order_with_respect_to"],
1483                             True,
1484                         )
1485                     )
1486                 # Actually generate the operation
1487                 self.add_operation(
1488                     app_label,
1489                     operations.AlterOrderWithRespectTo(
1490                         name=model_name,
1491                         order_with_respect_to=new_model_state.options.get(
1492                             "order_with_respect_to"
1493                         ),
1494                     ),
1495                     dependencies=dependencies,
1496                 )
1497 
1498     def generate_altered_managers(self):
1499         for app_label, model_name in sorted(self.kept_model_keys):
1500             old_model_name = self.renamed_models.get(
1501                 (app_label, model_name), model_name
1502             )
1503             old_model_state = self.from_state.models[app_label, old_model_name]
1504             new_model_state = self.to_state.models[app_label, model_name]
1505             if old_model_state.managers != new_model_state.managers:
1506                 self.add_operation(
1507                     app_label,
1508                     operations.AlterModelManagers(
1509                         name=model_name,
1510                         managers=new_model_state.managers,
1511                     ),
1512                 )
1513 
1514     def arrange_for_graph(self, changes, graph, migration_name=None):
1515         """
1516         Take a result from changes() and a MigrationGraph, and fix the names
1517         and dependencies of the changes so they extend the graph from the leaf
1518         nodes for each app.
1519         """
1520         leaves = graph.leaf_nodes()
1521         name_map = {}
1522         for app_label, migrations in list(changes.items()):
1523             if not migrations:
1524                 continue
1525             # Find the app label's current leaf node
1526             app_leaf = None
1527             for leaf in leaves:
1528                 if leaf[0] == app_label:
1529                     app_leaf = leaf
1530                     break
1531             # Do they want an initial migration for this app?
1532             if app_leaf is None and not self.questioner.ask_initial(app_label):
1533                 # They don't.
1534                 for migration in migrations:
1535                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1536                 del changes[app_label]
1537                 continue
1538             # Work out the next number in the sequence
1539             if app_leaf is None:
1540                 next_number = 1
1541             else:
1542                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1543             # Name each migration
1544             for i, migration in enumerate(migrations):
1545                 if i == 0 and app_leaf:
1546                     migration.dependencies.append(app_leaf)
1547                 new_name_parts = ["%04i" % next_number]
1548                 if migration_name:
1549                     new_name_parts.append(migration_name)
1550                 elif i == 0 and not app_leaf:
1551                     new_name_parts.append("initial")
1552                 else:
1553                     new_name_parts.append(migration.suggest_name()[:100])
1554                 new_name = "_".join(new_name_parts)
1555                 name_map[(app_label, migration.name)] = (app_label, new_name)
1556                 next_number += 1
1557                 migration.name = new_name
1558         # Now fix dependencies
1559         for migrations in changes.values():
1560             for migration in migrations:
1561                 migration.dependencies = [
1562                     name_map.get(d, d) for d in migration.dependencies
1563                 ]
1564         return changes
1565 
1566     def _trim_to_apps(self, changes, app_labels):
1567         """
1568         Take changes from arrange_for_graph() and set of app labels, and return
1569         a modified set of changes which trims out as many migrations that are
1570         not in app_labels as possible. Note that some other migrations may
1571         still be present as they may be required dependencies.
1572         """
1573         # Gather other app dependencies in a first pass
1574         app_dependencies = {}
1575         for app_label, migrations in changes.items():
1576             for migration in migrations:
1577                 for dep_app_label, name in migration.dependencies:
1578                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1579         required_apps = set(app_labels)
1580         # Keep resolving till there's no change
1581         old_required_apps = None
1582         while old_required_apps != required_apps:
1583             old_required_apps = set(required_apps)
1584             required_apps.update(
1585                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1586             )
1587         # Remove all migrations that aren't needed
1588         for app_label in list(changes):
1589             if app_label not in required_apps:
1590                 del changes[app_label]
1591         return changes
1592 
1593     @classmethod
1594     def parse_number(cls, name):
1595         """
1596         Given a migration name, try to extract a number from the beginning of
1597         it. For a squashed migration such as '0001_squashed_0004', return the
1598         second number. If no number is found, return None.
1599         """
1600         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1601             return int(squashed_match[1])
1602         match = re.match(r"^\d+", name)
1603         if match:
1604             return int(match[0])
1605         return None

</code><intended_behavior>When a primary key field's db_collation is altered, the MigrationAutodetector should not only generate an AlterField operation for this field but also ensure that any foreign key fields referencing it are included in the migration operations with their db_collation altered to match. This involves extending the field comparison mechanism to recognize changes in db_collation as significant for migration, automatically generating AlterField operations for both the changed field and any referencing foreign key fields, and ensuring that these operations are executed in a sequence that maintains referential integrity and consistency across the database schema. Additionally, it's essential to ensure that dependency management within the generated migrations accounts for these operations, including setting the correct dependencies in the migration file to ensure that the AlterField operation for the foreign key fields is executed after the alteration of the primary key field they reference.</intended_behavior>]
2025-10-15 17:14:56.171 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>MigrationAutodetector</class>
<method>None</method>
<code>
20 class MigrationAutodetector:
21     """
22     Take a pair of ProjectStates and compare them to see what the first would
23     need doing to make it match the second (the second usually being the
24     project's current state).
25 
26     Note that this naturally operates on entire projects at a time,
27     as it's likely that changes interact (for example, you can't
28     add a ForeignKey without having a migration to add the table it
29     depends on first). A user interface may offer single-app usage
30     if it wishes, with the caveat that it may not always be possible.
31     """
32 
33     def __init__(self, from_state, to_state, questioner=None):
34         self.from_state = from_state
35         self.to_state = to_state
36         self.questioner = questioner or MigrationQuestioner()
37         self.existing_apps = {app for app, model in from_state.models}
38 
39     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
40         """
41         Main entry point to produce a list of applicable changes.
42         Take a graph to base names on and an optional set of apps
43         to try and restrict to (restriction is not guaranteed)
44         """
45         changes = self._detect_changes(convert_apps, graph)
46         changes = self.arrange_for_graph(changes, graph, migration_name)
47         if trim_to_apps:
48             changes = self._trim_to_apps(changes, trim_to_apps)
49         return changes
50 
51     def deep_deconstruct(self, obj):
52         """
53         Recursive deconstruction for a field and its arguments.
54         Used for full comparison for rename/alter; sometimes a single-level
55         deconstruction will not compare correctly.
56         """
57         if isinstance(obj, list):
58             return [self.deep_deconstruct(value) for value in obj]
59         elif isinstance(obj, tuple):
60             return tuple(self.deep_deconstruct(value) for value in obj)
61         elif isinstance(obj, dict):
62             return {key: self.deep_deconstruct(value) for key, value in obj.items()}
63         elif isinstance(obj, functools.partial):
64             return (
65                 obj.func,
66                 self.deep_deconstruct(obj.args),
67                 self.deep_deconstruct(obj.keywords),
68             )
69         elif isinstance(obj, COMPILED_REGEX_TYPE):
70             return RegexObject(obj)
71         elif isinstance(obj, type):
72             # If this is a type that implements 'deconstruct' as an instance method,
73             # avoid treating this as being deconstructible itself - see #22951
74             return obj
75         elif hasattr(obj, "deconstruct"):
76             deconstructed = obj.deconstruct()
77             if isinstance(obj, models.Field):
78                 # we have a field which also returns a name
79                 deconstructed = deconstructed[1:]
80             path, args, kwargs = deconstructed
81             return (
82                 path,
83                 [self.deep_deconstruct(value) for value in args],
84                 {key: self.deep_deconstruct(value) for key, value in kwargs.items()},
85             )
86         else:
87             return obj
88 
89     def only_relation_agnostic_fields(self, fields):
90         """
91         Return a definition of the fields that ignores field names and
92         what related fields actually relate to. Used for detecting renames (as
93         the related fields change during renames).
94         """
95         fields_def = []
96         for name, field in sorted(fields.items()):
97             deconstruction = self.deep_deconstruct(field)
98             if field.remote_field and field.remote_field.model:
99                 deconstruction[2].pop("to", None)
100             fields_def.append(deconstruction)
101         return fields_def
102 
103     def _detect_changes(self, convert_apps=None, graph=None):
104         """
105         Return a dict of migration plans which will achieve the
106         change from from_state to to_state. The dict has app labels
107         as keys and a list of migrations as values.
108 
109         The resulting migrations aren't specially named, but the names
110         do matter for dependencies inside the set.
111 
112         convert_apps is the list of apps to convert to use migrations
113         (i.e. to make initial migrations for, in the usual case)
114 
115         graph is an optional argument that, if provided, can help improve
116         dependency generation and avoid potential circular dependencies.
117         """
118         # The first phase is generating all the operations for each app
119         # and gathering them into a big per-app list.
120         # Then go through that list, order it, and split into migrations to
121         # resolve dependencies caused by M2Ms and FKs.
122         self.generated_operations = {}
123         self.altered_indexes = {}
124         self.altered_constraints = {}
125 
126         # Prepare some old/new state and model lists, separating
127         # proxy models and ignoring unmigrated apps.
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for (app_label, model_name), model_state in self.from_state.models.items():
135             if not model_state.options.get("managed", True):
136                 self.old_unmanaged_keys.add((app_label, model_name))
137             elif app_label not in self.from_state.real_apps:
138                 if model_state.options.get("proxy"):
139                     self.old_proxy_keys.add((app_label, model_name))
140                 else:
141                     self.old_model_keys.add((app_label, model_name))
142 
143         for (app_label, model_name), model_state in self.to_state.models.items():
144             if not model_state.options.get("managed", True):
145                 self.new_unmanaged_keys.add((app_label, model_name))
146             elif app_label not in self.from_state.real_apps or (
147                 convert_apps and app_label in convert_apps
148             ):
149                 if model_state.options.get("proxy"):
150                     self.new_proxy_keys.add((app_label, model_name))
151                 else:
152                     self.new_model_keys.add((app_label, model_name))
153 
154         self.from_state.resolve_fields_and_relations()
155         self.to_state.resolve_fields_and_relations()
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field renaming operations.
181         self.generate_renamed_fields()
182         # Generate removal of foo together.
183         self.generate_removed_altered_unique_together()
184         self.generate_removed_altered_index_together()
185         # Generate field operations.
186         self.generate_removed_fields()
187         self.generate_added_fields()
188         self.generate_altered_fields()
189         self.generate_altered_order_with_respect_to()
190         self.generate_altered_unique_together()
191         self.generate_altered_index_together()
192         self.generate_added_indexes()
193         self.generate_added_constraints()
194         self.generate_altered_db_table()
195 
196         self._sort_migrations()
197         self._build_migration_list(graph)
198         self._optimize_migrations()
199 
200         return self.migrations
201 
202     def _prepare_field_lists(self):
203         """
204         Prepare field lists and a list of the fields that used through models
205         in the old state so dependencies can be made from the through model
206         deletion to the field that uses it.
207         """
208         self.kept_model_keys = self.old_model_keys & self.new_model_keys
209         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
210         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
211         self.through_users = {}
212         self.old_field_keys = {
213             (app_label, model_name, field_name)
214             for app_label, model_name in self.kept_model_keys
215             for field_name in self.from_state.models[
216                 app_label, self.renamed_models.get((app_label, model_name), model_name)
217             ].fields
218         }
219         self.new_field_keys = {
220             (app_label, model_name, field_name)
221             for app_label, model_name in self.kept_model_keys
222             for field_name in self.to_state.models[app_label, model_name].fields
223         }
224 
225     def _generate_through_model_map(self):
226         """Through model map generation."""
227         for app_label, model_name in sorted(self.old_model_keys):
228             old_model_name = self.renamed_models.get(
229                 (app_label, model_name), model_name
230             )
231             old_model_state = self.from_state.models[app_label, old_model_name]
232             for field_name, field in old_model_state.fields.items():
233                 if hasattr(field, "remote_field") and getattr(
234                     field.remote_field, "through", None
235                 ):
236                     through_key = resolve_relation(
237                         field.remote_field.through, app_label, model_name
238                     )
239                     self.through_users[through_key] = (
240                         app_label,
241                         old_model_name,
242                         field_name,
243                     )
244 
245     @staticmethod
246     def _resolve_dependency(dependency):
247         """
248         Return the resolved dependency and a boolean denoting whether or not
249         it was swappable.
250         """
251         if dependency[0] != "__setting__":
252             return dependency, False
253         resolved_app_label, resolved_object_name = getattr(
254             settings, dependency[1]
255         ).split(".")
256         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
257 
258     def _build_migration_list(self, graph=None):
259         """
260         Chop the lists of operations up into migrations with dependencies on
261         each other. Do this by going through an app's list of operations until
262         one is found that has an outgoing dependency that isn't in another
263         app's migration yet (hasn't been chopped off its list). Then chop off
264         the operations before it into a migration and move onto the next app.
265         If the loops completes without doing anything, there's a circular
266         dependency (which _should_ be impossible as the operations are
267         all split at this point so they can't depend and be depended on).
268         """
269         self.migrations = {}
270         num_ops = sum(len(x) for x in self.generated_operations.values())
271         chop_mode = False
272         while num_ops:
273             # On every iteration, we step through all the apps and see if there
274             # is a completed set of operations.
275             # If we find that a subset of the operations are complete we can
276             # try to chop it off from the rest and continue, but we only
277             # do this if we've already been through the list once before
278             # without any chopping and nothing has changed.
279             for app_label in sorted(self.generated_operations):
280                 chopped = []
281                 dependencies = set()
282                 for operation in list(self.generated_operations[app_label]):
283                     deps_satisfied = True
284                     operation_dependencies = set()
285                     for dep in operation._auto_deps:
286                         # Temporarily resolve the swappable dependency to
287                         # prevent circular references. While keeping the
288                         # dependency checks on the resolved model, add the
289                         # swappable dependencies.
290                         original_dep = dep
291                         dep, is_swappable_dep = self._resolve_dependency(dep)
292                         if dep[0] != app_label:
293                             # External app dependency. See if it's not yet
294                             # satisfied.
295                             for other_operation in self.generated_operations.get(
296                                 dep[0], []
297                             ):
298                                 if self.check_dependency(other_operation, dep):
299                                     deps_satisfied = False
300                                     break
301                             if not deps_satisfied:
302                                 break
303                             else:
304                                 if is_swappable_dep:
305                                     operation_dependencies.add(
306                                         (original_dep[0], original_dep[1])
307                                     )
308                                 elif dep[0] in self.migrations:
309                                     operation_dependencies.add(
310                                         (dep[0], self.migrations[dep[0]][-1].name)
311                                     )
312                                 else:
313                                     # If we can't find the other app, we add a
314                                     # first/last dependency, but only if we've
315                                     # already been through once and checked
316                                     # everything.
317                                     if chop_mode:
318                                         # If the app already exists, we add a
319                                         # dependency on the last migration, as
320                                         # we don't know which migration
321                                         # contains the target field. If it's
322                                         # not yet migrated or has no
323                                         # migrations, we use __first__.
324                                         if graph and graph.leaf_nodes(dep[0]):
325                                             operation_dependencies.add(
326                                                 graph.leaf_nodes(dep[0])[0]
327                                             )
328                                         else:
329                                             operation_dependencies.add(
330                                                 (dep[0], "__first__")
331                                             )
332                                     else:
333                                         deps_satisfied = False
334                     if deps_satisfied:
335                         chopped.append(operation)
336                         dependencies.update(operation_dependencies)
337                         del self.generated_operations[app_label][0]
338                     else:
339                         break
340                 # Make a migration! Well, only if there's stuff to put in it
341                 if dependencies or chopped:
342                     if not self.generated_operations[app_label] or chop_mode:
343                         subclass = type(
344                             "Migration",
345                             (Migration,),
346                             {"operations": [], "dependencies": []},
347                         )
348                         instance = subclass(
349                             "auto_%i" % (len(self.migrations.get(app_label, [])) + 1),
350                             app_label,
351                         )
352                         instance.dependencies = list(dependencies)
353                         instance.operations = chopped
354                         instance.initial = app_label not in self.existing_apps
355                         self.migrations.setdefault(app_label, []).append(instance)
356                         chop_mode = False
357                     else:
358                         self.generated_operations[app_label] = (
359                             chopped + self.generated_operations[app_label]
360                         )
361             new_num_ops = sum(len(x) for x in self.generated_operations.values())
362             if new_num_ops == num_ops:
363                 if not chop_mode:
364                     chop_mode = True
365                 else:
366                     raise ValueError(
367                         "Cannot resolve operation dependencies: %r"
368                         % self.generated_operations
369                     )
370             num_ops = new_num_ops
371 
372     def _sort_migrations(self):
373         """
374         Reorder to make things possible. Reordering may be needed so FKs work
375         nicely inside the same app.
376         """
377         for app_label, ops in sorted(self.generated_operations.items()):
378             # construct a dependency graph for intra-app dependencies
379             dependency_graph = {op: set() for op in ops}
380             for op in ops:
381                 for dep in op._auto_deps:
382                     # Resolve intra-app dependencies to handle circular
383                     # references involving a swappable model.
384                     dep = self._resolve_dependency(dep)[0]
385                     if dep[0] == app_label:
386                         for op2 in ops:
387                             if self.check_dependency(op2, dep):
388                                 dependency_graph[op].add(op2)
389 
390             # we use a stable sort for deterministic tests & general behavior
391             self.generated_operations[app_label] = stable_topological_sort(
392                 ops, dependency_graph
393             )
394 
395     def _optimize_migrations(self):
396         # Add in internal dependencies among the migrations
397         for app_label, migrations in self.migrations.items():
398             for m1, m2 in zip(migrations, migrations[1:]):
399                 m2.dependencies.append((app_label, m1.name))
400 
401         # De-dupe dependencies
402         for migrations in self.migrations.values():
403             for migration in migrations:
404                 migration.dependencies = list(set(migration.dependencies))
405 
406         # Optimize migrations
407         for app_label, migrations in self.migrations.items():
408             for migration in migrations:
409                 migration.operations = MigrationOptimizer().optimize(
410                     migration.operations, app_label
411                 )
412 
413     def check_dependency(self, operation, dependency):
414         """
415         Return True if the given operation depends on the given dependency,
416         False otherwise.
417         """
418         # Created model
419         if dependency[2] is None and dependency[3] is True:
420             return (
421                 isinstance(operation, operations.CreateModel)
422                 and operation.name_lower == dependency[1].lower()
423             )
424         # Created field
425         elif dependency[2] is not None and dependency[3] is True:
426             return (
427                 isinstance(operation, operations.CreateModel)
428                 and operation.name_lower == dependency[1].lower()
429                 and any(dependency[2] == x for x, y in operation.fields)
430             ) or (
431                 isinstance(operation, operations.AddField)
432                 and operation.model_name_lower == dependency[1].lower()
433                 and operation.name_lower == dependency[2].lower()
434             )
435         # Removed field
436         elif dependency[2] is not None and dependency[3] is False:
437             return (
438                 isinstance(operation, operations.RemoveField)
439                 and operation.model_name_lower == dependency[1].lower()
440                 and operation.name_lower == dependency[2].lower()
441             )
442         # Removed model
443         elif dependency[2] is None and dependency[3] is False:
444             return (
445                 isinstance(operation, operations.DeleteModel)
446                 and operation.name_lower == dependency[1].lower()
447             )
448         # Field being altered
449         elif dependency[2] is not None and dependency[3] == "alter":
450             return (
451                 isinstance(operation, operations.AlterField)
452                 and operation.model_name_lower == dependency[1].lower()
453                 and operation.name_lower == dependency[2].lower()
454             )
455         # order_with_respect_to being unset for a field
456         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
457             return (
458                 isinstance(operation, operations.AlterOrderWithRespectTo)
459                 and operation.name_lower == dependency[1].lower()
460                 and (operation.order_with_respect_to or "").lower()
461                 != dependency[2].lower()
462             )
463         # Field is removed and part of an index/unique_together
464         elif dependency[2] is not None and dependency[3] == "foo_together_change":
465             return (
466                 isinstance(
467                     operation,
468                     (operations.AlterUniqueTogether, operations.AlterIndexTogether),
469                 )
470                 and operation.name_lower == dependency[1].lower()
471             )
472         # Unknown dependency. Raise an error.
473         else:
474             raise ValueError("Can't handle dependency %r" % (dependency,))
475 
476     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
477         # Dependencies are
478         # (app_label, model_name, field_name, create/delete as True/False)
479         operation._auto_deps = dependencies or []
480         if beginning:
481             self.generated_operations.setdefault(app_label, []).insert(0, operation)
482         else:
483             self.generated_operations.setdefault(app_label, []).append(operation)
484 
485     def swappable_first_key(self, item):
486         """
487         Place potential swappable models first in lists of created models (only
488         real way to solve #22783).
489         """
490         try:
491             model_state = self.to_state.models[item]
492             base_names = {
493                 base if isinstance(base, str) else base.__name__
494                 for base in model_state.bases
495             }
496             string_version = "%s.%s" % (item[0], item[1])
497             if (
498                 model_state.options.get("swappable")
499                 or "AbstractUser" in base_names
500                 or "AbstractBaseUser" in base_names
501                 or settings.AUTH_USER_MODEL.lower() == string_version.lower()
502             ):
503                 return ("___" + item[0], "___" + item[1])
504         except LookupError:
505             pass
506         return item
507 
508     def generate_renamed_models(self):
509         """
510         Find any renamed models, generate the operations for them, and remove
511         the old entry from the model lists. Must be run before other
512         model-level generation.
513         """
514         self.renamed_models = {}
515         self.renamed_models_rel = {}
516         added_models = self.new_model_keys - self.old_model_keys
517         for app_label, model_name in sorted(added_models):
518             model_state = self.to_state.models[app_label, model_name]
519             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
520 
521             removed_models = self.old_model_keys - self.new_model_keys
522             for rem_app_label, rem_model_name in removed_models:
523                 if rem_app_label == app_label:
524                     rem_model_state = self.from_state.models[
525                         rem_app_label, rem_model_name
526                     ]
527                     rem_model_fields_def = self.only_relation_agnostic_fields(
528                         rem_model_state.fields
529                     )
530                     if model_fields_def == rem_model_fields_def:
531                         if self.questioner.ask_rename_model(
532                             rem_model_state, model_state
533                         ):
534                             dependencies = []
535                             fields = list(model_state.fields.values()) + [
536                                 field.remote_field
537                                 for relations in self.to_state.relations[
538                                     app_label, model_name
539                                 ].values()
540                                 for field in relations.values()
541                             ]
542                             for field in fields:
543                                 if field.is_relation:
544                                     dependencies.extend(
545                                         self._get_dependencies_for_foreign_key(
546                                             app_label,
547                                             model_name,
548                                             field,
549                                             self.to_state,
550                                         )
551                                     )
552                             self.add_operation(
553                                 app_label,
554                                 operations.RenameModel(
555                                     old_name=rem_model_state.name,
556                                     new_name=model_state.name,
557                                 ),
558                                 dependencies=dependencies,
559                             )
560                             self.renamed_models[app_label, model_name] = rem_model_name
561                             renamed_models_rel_key = "%s.%s" % (
562                                 rem_model_state.app_label,
563                                 rem_model_state.name_lower,
564                             )
565                             self.renamed_models_rel[
566                                 renamed_models_rel_key
567                             ] = "%s.%s" % (
568                                 model_state.app_label,
569                                 model_state.name_lower,
570                             )
571                             self.old_model_keys.remove((rem_app_label, rem_model_name))
572                             self.old_model_keys.add((app_label, model_name))
573                             break
574 
575     def generate_created_models(self):
576         """
577         Find all new models (both managed and unmanaged) and make create
578         operations for them as well as separate operations to create any
579         foreign key or M2M relationships (these are optimized later, if
580         possible).
581 
582         Defer any model options that refer to collections of fields that might
583         be deferred (e.g. unique_together, index_together).
584         """
585         old_keys = self.old_model_keys | self.old_unmanaged_keys
586         added_models = self.new_model_keys - old_keys
587         added_unmanaged_models = self.new_unmanaged_keys - old_keys
588         all_added_models = chain(
589             sorted(added_models, key=self.swappable_first_key, reverse=True),
590             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True),
591         )
592         for app_label, model_name in all_added_models:
593             model_state = self.to_state.models[app_label, model_name]
594             # Gather related fields
595             related_fields = {}
596             primary_key_rel = None
597             for field_name, field in model_state.fields.items():
598                 if field.remote_field:
599                     if field.remote_field.model:
600                         if field.primary_key:
601                             primary_key_rel = field.remote_field.model
602                         elif not field.remote_field.parent_link:
603                             related_fields[field_name] = field
604                     if getattr(field.remote_field, "through", None):
605                         related_fields[field_name] = field
606 
607             # Are there indexes/unique|index_together to defer?
608             indexes = model_state.options.pop("indexes")
609             constraints = model_state.options.pop("constraints")
610             unique_together = model_state.options.pop("unique_together", None)
611             index_together = model_state.options.pop("index_together", None)
612             order_with_respect_to = model_state.options.pop(
613                 "order_with_respect_to", None
614             )
615             # Depend on the deletion of any possible proxy version of us
616             dependencies = [
617                 (app_label, model_name, None, False),
618             ]
619             # Depend on all bases
620             for base in model_state.bases:
621                 if isinstance(base, str) and "." in base:
622                     base_app_label, base_name = base.split(".", 1)
623                     dependencies.append((base_app_label, base_name, None, True))
624                     # Depend on the removal of base fields if the new model has
625                     # a field with the same name.
626                     old_base_model_state = self.from_state.models.get(
627                         (base_app_label, base_name)
628                     )
629                     new_base_model_state = self.to_state.models.get(
630                         (base_app_label, base_name)
631                     )
632                     if old_base_model_state and new_base_model_state:
633                         removed_base_fields = (
634                             set(old_base_model_state.fields)
635                             .difference(
636                                 new_base_model_state.fields,
637                             )
638                             .intersection(model_state.fields)
639                         )
640                         for removed_base_field in removed_base_fields:
641                             dependencies.append(
642                                 (base_app_label, base_name, removed_base_field, False)
643                             )
644             # Depend on the other end of the primary key if it's a relation
645             if primary_key_rel:
646                 dependencies.append(
647                     resolve_relation(
648                         primary_key_rel,
649                         app_label,
650                         model_name,
651                     )
652                     + (None, True)
653                 )
654             # Generate creation operation
655             self.add_operation(
656                 app_label,
657                 operations.CreateModel(
658                     name=model_state.name,
659                     fields=[
660                         d
661                         for d in model_state.fields.items()
662                         if d[0] not in related_fields
663                     ],
664                     options=model_state.options,
665                     bases=model_state.bases,
666                     managers=model_state.managers,
667                 ),
668                 dependencies=dependencies,
669                 beginning=True,
670             )
671 
672             # Don't add operations which modify the database for unmanaged models
673             if not model_state.options.get("managed", True):
674                 continue
675 
676             # Generate operations for each related field
677             for name, field in sorted(related_fields.items()):
678                 dependencies = self._get_dependencies_for_foreign_key(
679                     app_label,
680                     model_name,
681                     field,
682                     self.to_state,
683                 )
684                 # Depend on our own model being created
685                 dependencies.append((app_label, model_name, None, True))
686                 # Make operation
687                 self.add_operation(
688                     app_label,
689                     operations.AddField(
690                         model_name=model_name,
691                         name=name,
692                         field=field,
693                     ),
694                     dependencies=list(set(dependencies)),
695                 )
696             # Generate other opns
697             if order_with_respect_to:
698                 self.add_operation(
699                     app_label,
700                     operations.AlterOrderWithRespectTo(
701                         name=model_name,
702                         order_with_respect_to=order_with_respect_to,
703                     ),
704                     dependencies=[
705                         (app_label, model_name, order_with_respect_to, True),
706                         (app_label, model_name, None, True),
707                     ],
708                 )
709             related_dependencies = [
710                 (app_label, model_name, name, True) for name in sorted(related_fields)
711             ]
712             related_dependencies.append((app_label, model_name, None, True))
713             for index in indexes:
714                 self.add_operation(
715                     app_label,
716                     operations.AddIndex(
717                         model_name=model_name,
718                         index=index,
719                     ),
720                     dependencies=related_dependencies,
721                 )
722             for constraint in constraints:
723                 self.add_operation(
724                     app_label,
725                     operations.AddConstraint(
726                         model_name=model_name,
727                         constraint=constraint,
728                     ),
729                     dependencies=related_dependencies,
730                 )
731             if unique_together:
732                 self.add_operation(
733                     app_label,
734                     operations.AlterUniqueTogether(
735                         name=model_name,
736                         unique_together=unique_together,
737                     ),
738                     dependencies=related_dependencies,
739                 )
740             if index_together:
741                 self.add_operation(
742                     app_label,
743                     operations.AlterIndexTogether(
744                         name=model_name,
745                         index_together=index_together,
746                     ),
747                     dependencies=related_dependencies,
748                 )
749             # Fix relationships if the model changed from a proxy model to a
750             # concrete model.
751             relations = self.to_state.relations
752             if (app_label, model_name) in self.old_proxy_keys:
753                 for related_model_key, related_fields in relations[
754                     app_label, model_name
755                 ].items():
756                     related_model_state = self.to_state.models[related_model_key]
757                     for related_field_name, related_field in related_fields.items():
758                         self.add_operation(
759                             related_model_state.app_label,
760                             operations.AlterField(
761                                 model_name=related_model_state.name,
762                                 name=related_field_name,
763                                 field=related_field,
764                             ),
765                             dependencies=[(app_label, model_name, None, True)],
766                         )
767 
768     def generate_created_proxies(self):
769         """
770         Make CreateModel statements for proxy models. Use the same statements
771         as that way there's less code duplication, but for proxy models it's
772         safe to skip all the pointless field stuff and chuck out an operation.
773         """
774         added = self.new_proxy_keys - self.old_proxy_keys
775         for app_label, model_name in sorted(added):
776             model_state = self.to_state.models[app_label, model_name]
777             assert model_state.options.get("proxy")
778             # Depend on the deletion of any possible non-proxy version of us
779             dependencies = [
780                 (app_label, model_name, None, False),
781             ]
782             # Depend on all bases
783             for base in model_state.bases:
784                 if isinstance(base, str) and "." in base:
785                     base_app_label, base_name = base.split(".", 1)
786                     dependencies.append((base_app_label, base_name, None, True))
787             # Generate creation operation
788             self.add_operation(
789                 app_label,
790                 operations.CreateModel(
791                     name=model_state.name,
792                     fields=[],
793                     options=model_state.options,
794                     bases=model_state.bases,
795                     managers=model_state.managers,
796                 ),
797                 # Depend on the deletion of any possible non-proxy version of us
798                 dependencies=dependencies,
799             )
800 
801     def generate_deleted_models(self):
802         """
803         Find all deleted models (managed and unmanaged) and make delete
804         operations for them as well as separate operations to delete any
805         foreign key or M2M relationships (these are optimized later, if
806         possible).
807 
808         Also bring forward removal of any model options that refer to
809         collections of fields - the inverse of generate_created_models().
810         """
811         new_keys = self.new_model_keys | self.new_unmanaged_keys
812         deleted_models = self.old_model_keys - new_keys
813         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
814         all_deleted_models = chain(
815             sorted(deleted_models), sorted(deleted_unmanaged_models)
816         )
817         for app_label, model_name in all_deleted_models:
818             model_state = self.from_state.models[app_label, model_name]
819             # Gather related fields
820             related_fields = {}
821             for field_name, field in model_state.fields.items():
822                 if field.remote_field:
823                     if field.remote_field.model:
824                         related_fields[field_name] = field
825                     if getattr(field.remote_field, "through", None):
826                         related_fields[field_name] = field
827             # Generate option removal first
828             unique_together = model_state.options.pop("unique_together", None)
829             index_together = model_state.options.pop("index_together", None)
830             if unique_together:
831                 self.add_operation(
832                     app_label,
833                     operations.AlterUniqueTogether(
834                         name=model_name,
835                         unique_together=None,
836                     ),
837                 )
838             if index_together:
839                 self.add_operation(
840                     app_label,
841                     operations.AlterIndexTogether(
842                         name=model_name,
843                         index_together=None,
844                     ),
845                 )
846             # Then remove each related field
847             for name in sorted(related_fields):
848                 self.add_operation(
849                     app_label,
850                     operations.RemoveField(
851                         model_name=model_name,
852                         name=name,
853                     ),
854                 )
855             # Finally, remove the model.
856             # This depends on both the removal/alteration of all incoming fields
857             # and the removal of all its own related fields, and if it's
858             # a through model the field that references it.
859             dependencies = []
860             relations = self.from_state.relations
861             for (
862                 related_object_app_label,
863                 object_name,
864             ), relation_related_fields in relations[app_label, model_name].items():
865                 for field_name, field in relation_related_fields.items():
866                     dependencies.append(
867                         (related_object_app_label, object_name, field_name, False),
868                     )
869                     if not field.many_to_many:
870                         dependencies.append(
871                             (
872                                 related_object_app_label,
873                                 object_name,
874                                 field_name,
875                                 "alter",
876                             ),
877                         )
878 
879             for name in sorted(related_fields):
880                 dependencies.append((app_label, model_name, name, False))
881             # We're referenced in another field's through=
882             through_user = self.through_users.get((app_label, model_state.name_lower))
883             if through_user:
884                 dependencies.append(
885                     (through_user[0], through_user[1], through_user[2], False)
886                 )
887             # Finally, make the operation, deduping any dependencies
888             self.add_operation(
889                 app_label,
890                 operations.DeleteModel(
891                     name=model_state.name,
892                 ),
893                 dependencies=list(set(dependencies)),
894             )
895 
896     def generate_deleted_proxies(self):
897         """Make DeleteModel options for proxy models."""
898         deleted = self.old_proxy_keys - self.new_proxy_keys
899         for app_label, model_name in sorted(deleted):
900             model_state = self.from_state.models[app_label, model_name]
901             assert model_state.options.get("proxy")
902             self.add_operation(
903                 app_label,
904                 operations.DeleteModel(
905                     name=model_state.name,
906                 ),
907             )
908 
909     def generate_renamed_fields(self):
910         """Work out renamed fields."""
911         self.renamed_fields = {}
912         for app_label, model_name, field_name in sorted(
913             self.new_field_keys - self.old_field_keys
914         ):
915             old_model_name = self.renamed_models.get(
916                 (app_label, model_name), model_name
917             )
918             old_model_state = self.from_state.models[app_label, old_model_name]
919             new_model_state = self.to_state.models[app_label, model_name]
920             field = new_model_state.get_field(field_name)
921             # Scan to see if this is actually a rename!
922             field_dec = self.deep_deconstruct(field)
923             for rem_app_label, rem_model_name, rem_field_name in sorted(
924                 self.old_field_keys - self.new_field_keys
925             ):
926                 if rem_app_label == app_label and rem_model_name == model_name:
927                     old_field = old_model_state.get_field(rem_field_name)
928                     old_field_dec = self.deep_deconstruct(old_field)
929                     if (
930                         field.remote_field
931                         and field.remote_field.model
932                         and "to" in old_field_dec[2]
933                     ):
934                         old_rel_to = old_field_dec[2]["to"]
935                         if old_rel_to in self.renamed_models_rel:
936                             old_field_dec[2]["to"] = self.renamed_models_rel[old_rel_to]
937                     old_field.set_attributes_from_name(rem_field_name)
938                     old_db_column = old_field.get_attname_column()[1]
939                     if old_field_dec == field_dec or (
940                         # Was the field renamed and db_column equal to the
941                         # old field's column added?
942                         old_field_dec[0:2] == field_dec[0:2]
943                         and dict(old_field_dec[2], db_column=old_db_column)
944                         == field_dec[2]
945                     ):
946                         if self.questioner.ask_rename(
947                             model_name, rem_field_name, field_name, field
948                         ):
949                             # A db_column mismatch requires a prior noop
950                             # AlterField for the subsequent RenameField to be a
951                             # noop on attempts at preserving the old name.
952                             if old_field.db_column != field.db_column:
953                                 altered_field = field.clone()
954                                 altered_field.name = rem_field_name
955                                 self.add_operation(
956                                     app_label,
957                                     operations.AlterField(
958                                         model_name=model_name,
959                                         name=rem_field_name,
960                                         field=altered_field,
961                                     ),
962                                 )
963                             self.add_operation(
964                                 app_label,
965                                 operations.RenameField(
966                                     model_name=model_name,
967                                     old_name=rem_field_name,
968                                     new_name=field_name,
969                                 ),
970                             )
971                             self.old_field_keys.remove(
972                                 (rem_app_label, rem_model_name, rem_field_name)
973                             )
974                             self.old_field_keys.add((app_label, model_name, field_name))
975                             self.renamed_fields[
976                                 app_label, model_name, field_name
977                             ] = rem_field_name
978                             break
979 
980     def generate_added_fields(self):
981         """Make AddField operations."""
982         for app_label, model_name, field_name in sorted(
983             self.new_field_keys - self.old_field_keys
984         ):
985             self._generate_added_field(app_label, model_name, field_name)
986 
987     def _generate_added_field(self, app_label, model_name, field_name):
988         field = self.to_state.models[app_label, model_name].get_field(field_name)
989         # Fields that are foreignkeys/m2ms depend on stuff
990         dependencies = []
991         if field.remote_field and field.remote_field.model:
992             dependencies.extend(
993                 self._get_dependencies_for_foreign_key(
994                     app_label,
995                     model_name,
996                     field,
997                     self.to_state,
998                 )
999             )
1000         # You can't just add NOT NULL fields with no default or fields
1001         # which don't allow empty strings as default.
1002         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
1003         preserve_default = (
1004             field.null
1005             or field.has_default()
1006             or field.many_to_many
1007             or (field.blank and field.empty_strings_allowed)
1008             or (isinstance(field, time_fields) and field.auto_now)
1009         )
1010         if not preserve_default:
1011             field = field.clone()
1012             if isinstance(field, time_fields) and field.auto_now_add:
1013                 field.default = self.questioner.ask_auto_now_add_addition(
1014                     field_name, model_name
1015                 )
1016             else:
1017                 field.default = self.questioner.ask_not_null_addition(
1018                     field_name, model_name
1019                 )
1020         if (
1021             field.unique
1022             and field.default is not models.NOT_PROVIDED
1023             and callable(field.default)
1024         ):
1025             self.questioner.ask_unique_callable_default_addition(field_name, model_name)
1026         self.add_operation(
1027             app_label,
1028             operations.AddField(
1029                 model_name=model_name,
1030                 name=field_name,
1031                 field=field,
1032                 preserve_default=preserve_default,
1033             ),
1034             dependencies=dependencies,
1035         )
1036 
1037     def generate_removed_fields(self):
1038         """Make RemoveField operations."""
1039         for app_label, model_name, field_name in sorted(
1040             self.old_field_keys - self.new_field_keys
1041         ):
1042             self._generate_removed_field(app_label, model_name, field_name)
1043 
1044     def _generate_removed_field(self, app_label, model_name, field_name):
1045         self.add_operation(
1046             app_label,
1047             operations.RemoveField(
1048                 model_name=model_name,
1049                 name=field_name,
1050             ),
1051             # We might need to depend on the removal of an
1052             # order_with_respect_to or index/unique_together operation;
1053             # this is safely ignored if there isn't one
1054             dependencies=[
1055                 (app_label, model_name, field_name, "order_wrt_unset"),
1056                 (app_label, model_name, field_name, "foo_together_change"),
1057             ],
1058         )
1059 
1060     def generate_altered_fields(self):
1061         """
1062         Make AlterField operations, or possibly RemovedField/AddField if alter
1063         isn't possible.
1064         """
1065         for app_label, model_name, field_name in sorted(
1066             self.old_field_keys & self.new_field_keys
1067         ):
1068             # Did the field change?
1069             old_model_name = self.renamed_models.get(
1070                 (app_label, model_name), model_name
1071             )
1072             old_field_name = self.renamed_fields.get(
1073                 (app_label, model_name, field_name), field_name
1074             )
1075             old_field = self.from_state.models[app_label, old_model_name].get_field(
1076                 old_field_name
1077             )
1078             new_field = self.to_state.models[app_label, model_name].get_field(
1079                 field_name
1080             )
1081             dependencies = []
1082             # Implement any model renames on relations; these are handled by RenameModel
1083             # so we need to exclude them from the comparison
1084             if hasattr(new_field, "remote_field") and getattr(
1085                 new_field.remote_field, "model", None
1086             ):
1087                 rename_key = resolve_relation(
1088                     new_field.remote_field.model, app_label, model_name
1089                 )
1090                 if rename_key in self.renamed_models:
1091                     new_field.remote_field.model = old_field.remote_field.model
1092                 # Handle ForeignKey which can only have a single to_field.
1093                 remote_field_name = getattr(new_field.remote_field, "field_name", None)
1094                 if remote_field_name:
1095                     to_field_rename_key = rename_key + (remote_field_name,)
1096                     if to_field_rename_key in self.renamed_fields:
1097                         # Repoint both model and field name because to_field
1098                         # inclusion in ForeignKey.deconstruct() is based on
1099                         # both.
1100                         new_field.remote_field.model = old_field.remote_field.model
1101                         new_field.remote_field.field_name = (
1102                             old_field.remote_field.field_name
1103                         )
1104                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
1105                 from_fields = getattr(new_field, "from_fields", None)
1106                 if from_fields:
1107                     from_rename_key = (app_label, model_name)
1108                     new_field.from_fields = tuple(
1109                         [
1110                             self.renamed_fields.get(
1111                                 from_rename_key + (from_field,), from_field
1112                             )
1113                             for from_field in from_fields
1114                         ]
1115                     )
1116                     new_field.to_fields = tuple(
1117                         [
1118                             self.renamed_fields.get(rename_key + (to_field,), to_field)
1119                             for to_field in new_field.to_fields
1120                         ]
1121                     )
1122                 dependencies.extend(
1123                     self._get_dependencies_for_foreign_key(
1124                         app_label,
1125                         model_name,
1126                         new_field,
1127                         self.to_state,
1128                     )
1129                 )
1130             if hasattr(new_field, "remote_field") and getattr(
1131                 new_field.remote_field, "through", None
1132             ):
1133                 rename_key = resolve_relation(
1134                     new_field.remote_field.through, app_label, model_name
1135                 )
1136                 if rename_key in self.renamed_models:
1137                     new_field.remote_field.through = old_field.remote_field.through
1138             old_field_dec = self.deep_deconstruct(old_field)
1139             new_field_dec = self.deep_deconstruct(new_field)
1140             # If the field was confirmed to be renamed it means that only
1141             # db_column was allowed to change which generate_renamed_fields()
1142             # already accounts for by adding an AlterField operation.
1143             if old_field_dec != new_field_dec and old_field_name == field_name:
1144                 both_m2m = old_field.many_to_many and new_field.many_to_many
1145                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
1146                 if both_m2m or neither_m2m:
1147                     # Either both fields are m2m or neither is
1148                     preserve_default = True
1149                     if (
1150                         old_field.null
1151                         and not new_field.null
1152                         and not new_field.has_default()
1153                         and not new_field.many_to_many
1154                     ):
1155                         field = new_field.clone()
1156                         new_default = self.questioner.ask_not_null_alteration(
1157                             field_name, model_name
1158                         )
1159                         if new_default is not models.NOT_PROVIDED:
1160                             field.default = new_default
1161                             preserve_default = False
1162                     else:
1163                         field = new_field
1164                     self.add_operation(
1165                         app_label,
1166                         operations.AlterField(
1167                             model_name=model_name,
1168                             name=field_name,
1169                             field=field,
1170                             preserve_default=preserve_default,
1171                         ),
1172                         dependencies=dependencies,
1173                     )
1174                 else:
1175                     # We cannot alter between m2m and concrete fields
1176                     self._generate_removed_field(app_label, model_name, field_name)
1177                     self._generate_added_field(app_label, model_name, field_name)
1178 
1179     def create_altered_indexes(self):
1180         option_name = operations.AddIndex.option_name
1181         for app_label, model_name in sorted(self.kept_model_keys):
1182             old_model_name = self.renamed_models.get(
1183                 (app_label, model_name), model_name
1184             )
1185             old_model_state = self.from_state.models[app_label, old_model_name]
1186             new_model_state = self.to_state.models[app_label, model_name]
1187 
1188             old_indexes = old_model_state.options[option_name]
1189             new_indexes = new_model_state.options[option_name]
1190             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1191             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1192 
1193             self.altered_indexes.update(
1194                 {
1195                     (app_label, model_name): {
1196                         "added_indexes": add_idx,
1197                         "removed_indexes": rem_idx,
1198                     }
1199                 }
1200             )
1201 
1202     def generate_added_indexes(self):
1203         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1204             for index in alt_indexes["added_indexes"]:
1205                 self.add_operation(
1206                     app_label,
1207                     operations.AddIndex(
1208                         model_name=model_name,
1209                         index=index,
1210                     ),
1211                 )
1212 
1213     def generate_removed_indexes(self):
1214         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1215             for index in alt_indexes["removed_indexes"]:
1216                 self.add_operation(
1217                     app_label,
1218                     operations.RemoveIndex(
1219                         model_name=model_name,
1220                         name=index.name,
1221                     ),
1222                 )
1223 
1224     def create_altered_constraints(self):
1225         option_name = operations.AddConstraint.option_name
1226         for app_label, model_name in sorted(self.kept_model_keys):
1227             old_model_name = self.renamed_models.get(
1228                 (app_label, model_name), model_name
1229             )
1230             old_model_state = self.from_state.models[app_label, old_model_name]
1231             new_model_state = self.to_state.models[app_label, model_name]
1232 
1233             old_constraints = old_model_state.options[option_name]
1234             new_constraints = new_model_state.options[option_name]
1235             add_constraints = [c for c in new_constraints if c not in old_constraints]
1236             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1237 
1238             self.altered_constraints.update(
1239                 {
1240                     (app_label, model_name): {
1241                         "added_constraints": add_constraints,
1242                         "removed_constraints": rem_constraints,
1243                     }
1244                 }
1245             )
1246 
1247     def generate_added_constraints(self):
1248         for (
1249             app_label,
1250             model_name,
1251         ), alt_constraints in self.altered_constraints.items():
1252             for constraint in alt_constraints["added_constraints"]:
1253                 self.add_operation(
1254                     app_label,
1255                     operations.AddConstraint(
1256                         model_name=model_name,
1257                         constraint=constraint,
1258                     ),
1259                 )
1260 
1261     def generate_removed_constraints(self):
1262         for (
1263             app_label,
1264             model_name,
1265         ), alt_constraints in self.altered_constraints.items():
1266             for constraint in alt_constraints["removed_constraints"]:
1267                 self.add_operation(
1268                     app_label,
1269                     operations.RemoveConstraint(
1270                         model_name=model_name,
1271                         name=constraint.name,
1272                     ),
1273                 )
1274 
1275     @staticmethod
1276     def _get_dependencies_for_foreign_key(app_label, model_name, field, project_state):
1277         remote_field_model = None
1278         if hasattr(field.remote_field, "model"):
1279             remote_field_model = field.remote_field.model
1280         else:
1281             relations = project_state.relations[app_label, model_name]
1282             for (remote_app_label, remote_model_name), fields in relations.items():
1283                 if any(
1284                     field == related_field.remote_field
1285                     for related_field in fields.values()
1286                 ):
1287                     remote_field_model = f"{remote_app_label}.{remote_model_name}"
1288                     break
1289         # Account for FKs to swappable models
1290         swappable_setting = getattr(field, "swappable_setting", None)
1291         if swappable_setting is not None:
1292             dep_app_label = "__setting__"
1293             dep_object_name = swappable_setting
1294         else:
1295             dep_app_label, dep_object_name = resolve_relation(
1296                 remote_field_model,
1297                 app_label,
1298                 model_name,
1299             )
1300         dependencies = [(dep_app_label, dep_object_name, None, True)]
1301         if getattr(field.remote_field, "through", None):
1302             through_app_label, through_object_name = resolve_relation(
1303                 remote_field_model,
1304                 app_label,
1305                 model_name,
1306             )
1307             dependencies.append((through_app_label, through_object_name, None, True))
1308         return dependencies
1309 
1310     def _get_altered_foo_together_operations(self, option_name):
1311         for app_label, model_name in sorted(self.kept_model_keys):
1312             old_model_name = self.renamed_models.get(
1313                 (app_label, model_name), model_name
1314             )
1315             old_model_state = self.from_state.models[app_label, old_model_name]
1316             new_model_state = self.to_state.models[app_label, model_name]
1317 
1318             # We run the old version through the field renames to account for those
1319             old_value = old_model_state.options.get(option_name)
1320             old_value = (
1321                 {
1322                     tuple(
1323                         self.renamed_fields.get((app_label, model_name, n), n)
1324                         for n in unique
1325                     )
1326                     for unique in old_value
1327                 }
1328                 if old_value
1329                 else set()
1330             )
1331 
1332             new_value = new_model_state.options.get(option_name)
1333             new_value = set(new_value) if new_value else set()
1334 
1335             if old_value != new_value:
1336                 dependencies = []
1337                 for foo_togethers in new_value:
1338                     for field_name in foo_togethers:
1339                         field = new_model_state.get_field(field_name)
1340                         if field.remote_field and field.remote_field.model:
1341                             dependencies.extend(
1342                                 self._get_dependencies_for_foreign_key(
1343                                     app_label,
1344                                     model_name,
1345                                     field,
1346                                     self.to_state,
1347                                 )
1348                             )
1349                 yield (
1350                     old_value,
1351                     new_value,
1352                     app_label,
1353                     model_name,
1354                     dependencies,
1355                 )
1356 
1357     def _generate_removed_altered_foo_together(self, operation):
1358         for (
1359             old_value,
1360             new_value,
1361             app_label,
1362             model_name,
1363             dependencies,
1364         ) in self._get_altered_foo_together_operations(operation.option_name):
1365             removal_value = new_value.intersection(old_value)
1366             if removal_value or old_value:
1367                 self.add_operation(
1368                     app_label,
1369                     operation(
1370                         name=model_name, **{operation.option_name: removal_value}
1371                     ),
1372                     dependencies=dependencies,
1373                 )
1374 
1375     def generate_removed_altered_unique_together(self):
1376         self._generate_removed_altered_foo_together(operations.AlterUniqueTogether)
1377 
1378     def generate_removed_altered_index_together(self):
1379         self._generate_removed_altered_foo_together(operations.AlterIndexTogether)
1380 
1381     def _generate_altered_foo_together(self, operation):
1382         for (
1383             old_value,
1384             new_value,
1385             app_label,
1386             model_name,
1387             dependencies,
1388         ) in self._get_altered_foo_together_operations(operation.option_name):
1389             removal_value = new_value.intersection(old_value)
1390             if new_value != removal_value:
1391                 self.add_operation(
1392                     app_label,
1393                     operation(name=model_name, **{operation.option_name: new_value}),
1394                     dependencies=dependencies,
1395                 )
1396 
1397     def generate_altered_unique_together(self):
1398         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1399 
1400     def generate_altered_index_together(self):
1401         self._generate_altered_foo_together(operations.AlterIndexTogether)
1402 
1403     def generate_altered_db_table(self):
1404         models_to_check = self.kept_model_keys.union(
1405             self.kept_proxy_keys, self.kept_unmanaged_keys
1406         )
1407         for app_label, model_name in sorted(models_to_check):
1408             old_model_name = self.renamed_models.get(
1409                 (app_label, model_name), model_name
1410             )
1411             old_model_state = self.from_state.models[app_label, old_model_name]
1412             new_model_state = self.to_state.models[app_label, model_name]
1413             old_db_table_name = old_model_state.options.get("db_table")
1414             new_db_table_name = new_model_state.options.get("db_table")
1415             if old_db_table_name != new_db_table_name:
1416                 self.add_operation(
1417                     app_label,
1418                     operations.AlterModelTable(
1419                         name=model_name,
1420                         table=new_db_table_name,
1421                     ),
1422                 )
1423 
1424     def generate_altered_options(self):
1425         """
1426         Work out if any non-schema-affecting options have changed and make an
1427         operation to represent them in state changes (in case Python code in
1428         migrations needs them).
1429         """
1430         models_to_check = self.kept_model_keys.union(
1431             self.kept_proxy_keys,
1432             self.kept_unmanaged_keys,
1433             # unmanaged converted to managed
1434             self.old_unmanaged_keys & self.new_model_keys,
1435             # managed converted to unmanaged
1436             self.old_model_keys & self.new_unmanaged_keys,
1437         )
1438 
1439         for app_label, model_name in sorted(models_to_check):
1440             old_model_name = self.renamed_models.get(
1441                 (app_label, model_name), model_name
1442             )
1443             old_model_state = self.from_state.models[app_label, old_model_name]
1444             new_model_state = self.to_state.models[app_label, model_name]
1445             old_options = {
1446                 key: value
1447                 for key, value in old_model_state.options.items()
1448                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1449             }
1450             new_options = {
1451                 key: value
1452                 for key, value in new_model_state.options.items()
1453                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1454             }
1455             if old_options != new_options:
1456                 self.add_operation(
1457                     app_label,
1458                     operations.AlterModelOptions(
1459                         name=model_name,
1460                         options=new_options,
1461                     ),
1462                 )
1463 
1464     def generate_altered_order_with_respect_to(self):
1465         for app_label, model_name in sorted(self.kept_model_keys):
1466             old_model_name = self.renamed_models.get(
1467                 (app_label, model_name), model_name
1468             )
1469             old_model_state = self.from_state.models[app_label, old_model_name]
1470             new_model_state = self.to_state.models[app_label, model_name]
1471             if old_model_state.options.get(
1472                 "order_with_respect_to"
1473             ) != new_model_state.options.get("order_with_respect_to"):
1474                 # Make sure it comes second if we're adding
1475                 # (removal dependency is part of RemoveField)
1476                 dependencies = []
1477                 if new_model_state.options.get("order_with_respect_to"):
1478                     dependencies.append(
1479                         (
1480                             app_label,
1481                             model_name,
1482                             new_model_state.options["order_with_respect_to"],
1483                             True,
1484                         )
1485                     )
1486                 # Actually generate the operation
1487                 self.add_operation(
1488                     app_label,
1489                     operations.AlterOrderWithRespectTo(
1490                         name=model_name,
1491                         order_with_respect_to=new_model_state.options.get(
1492                             "order_with_respect_to"
1493                         ),
1494                     ),
1495                     dependencies=dependencies,
1496                 )
1497 
1498     def generate_altered_managers(self):
1499         for app_label, model_name in sorted(self.kept_model_keys):
1500             old_model_name = self.renamed_models.get(
1501                 (app_label, model_name), model_name
1502             )
1503             old_model_state = self.from_state.models[app_label, old_model_name]
1504             new_model_state = self.to_state.models[app_label, model_name]
1505             if old_model_state.managers != new_model_state.managers:
1506                 self.add_operation(
1507                     app_label,
1508                     operations.AlterModelManagers(
1509                         name=model_name,
1510                         managers=new_model_state.managers,
1511                     ),
1512                 )
1513 
1514     def arrange_for_graph(self, changes, graph, migration_name=None):
1515         """
1516         Take a result from changes() and a MigrationGraph, and fix the names
1517         and dependencies of the changes so they extend the graph from the leaf
1518         nodes for each app.
1519         """
1520         leaves = graph.leaf_nodes()
1521         name_map = {}
1522         for app_label, migrations in list(changes.items()):
1523             if not migrations:
1524                 continue
1525             # Find the app label's current leaf node
1526             app_leaf = None
1527             for leaf in leaves:
1528                 if leaf[0] == app_label:
1529                     app_leaf = leaf
1530                     break
1531             # Do they want an initial migration for this app?
1532             if app_leaf is None and not self.questioner.ask_initial(app_label):
1533                 # They don't.
1534                 for migration in migrations:
1535                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1536                 del changes[app_label]
1537                 continue
1538             # Work out the next number in the sequence
1539             if app_leaf is None:
1540                 next_number = 1
1541             else:
1542                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1543             # Name each migration
1544             for i, migration in enumerate(migrations):
1545                 if i == 0 and app_leaf:
1546                     migration.dependencies.append(app_leaf)
1547                 new_name_parts = ["%04i" % next_number]
1548                 if migration_name:
1549                     new_name_parts.append(migration_name)
1550                 elif i == 0 and not app_leaf:
1551                     new_name_parts.append("initial")
1552                 else:
1553                     new_name_parts.append(migration.suggest_name()[:100])
1554                 new_name = "_".join(new_name_parts)
1555                 name_map[(app_label, migration.name)] = (app_label, new_name)
1556                 next_number += 1
1557                 migration.name = new_name
1558         # Now fix dependencies
1559         for migrations in changes.values():
1560             for migration in migrations:
1561                 migration.dependencies = [
1562                     name_map.get(d, d) for d in migration.dependencies
1563                 ]
1564         return changes
1565 
1566     def _trim_to_apps(self, changes, app_labels):
1567         """
1568         Take changes from arrange_for_graph() and set of app labels, and return
1569         a modified set of changes which trims out as many migrations that are
1570         not in app_labels as possible. Note that some other migrations may
1571         still be present as they may be required dependencies.
1572         """
1573         # Gather other app dependencies in a first pass
1574         app_dependencies = {}
1575         for app_label, migrations in changes.items():
1576             for migration in migrations:
1577                 for dep_app_label, name in migration.dependencies:
1578                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1579         required_apps = set(app_labels)
1580         # Keep resolving till there's no change
1581         old_required_apps = None
1582         while old_required_apps != required_apps:
1583             old_required_apps = set(required_apps)
1584             required_apps.update(
1585                 *[app_dependencies.get(app_label, ()) for app_label in required_apps]
1586             )
1587         # Remove all migrations that aren't needed
1588         for app_label in list(changes):
1589             if app_label not in required_apps:
1590                 del changes[app_label]
1591         return changes
1592 
1593     @classmethod
1594     def parse_number(cls, name):
1595         """
1596         Given a migration name, try to extract a number from the beginning of
1597         it. For a squashed migration such as '0001_squashed_0004', return the
1598         second number. If no number is found, return None.
1599         """
1600         if squashed_match := re.search(r".*_squashed_(\d+)", name):
1601             return int(squashed_match[1])
1602         match = re.match(r"^\d+", name)
1603         if match:
1604             return int(match[0])
1605         return None

</code><intended_behavior>When a primary key field's db_collation is altered, the MigrationAutodetector should not only generate an AlterField operation for this field but also ensure that any foreign key fields referencing it are included in the migration operations with their db_collation altered to match. This involves extending the field comparison mechanism to recognize changes in db_collation as significant for migration, automatically generating AlterField operations for both the changed field and any referencing foreign key fields, and ensuring that these operations are executed in a sequence that maintains referential integrity and consistency across the database schema. Additionally, it's essential to ensure that dependency management within the generated migrations accounts for these operations, including setting the correct dependencies in the migration file to ensure that the AlterField operation for the foreign key fields is executed after the alteration of the primary key field they reference.</intended_behavior>]
2025-10-15 17:14:56.172 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 17:14:56.172 | INFO     | Search-only: skipping patch selection
2025-10-15 17:14:56.343 | INFO     | Task django__django-15629 completed successfully.
2025-10-15 17:14:56.344 | INFO     | No patch generated. You can try running ACR again.
