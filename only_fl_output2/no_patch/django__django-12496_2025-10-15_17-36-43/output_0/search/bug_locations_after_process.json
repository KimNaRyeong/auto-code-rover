[
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/forms/models.py",
        "start": 444,
        "end": 465,
        "class_name": null,
        "method_name": "save",
        "code": "444     def save(self, commit=True):\n445         \"\"\"\n446         Save this form's self.instance object if commit=True. Otherwise, add\n447         a save_m2m() method to the form which can be called after the instance\n448         is saved manually at a later time. Return the model instance.\n449         \"\"\"\n450         if self.errors:\n451             raise ValueError(\n452                 \"The %s could not be %s because the data didn't validate.\" % (\n453                     self.instance._meta.object_name,\n454                     'created' if self.instance._state.adding else 'changed',\n455                 )\n456             )\n457         if commit:\n458             # If committing, save the instance and the m2m data immediately.\n459             self.instance.save()\n460             self._save_m2m()\n461         else:\n462             # If not committing, add a method to the form to allow deferred\n463             # saving of m2m data.\n464             self.save_m2m = self._save_m2m\n465         return self.instance\n",
        "intended_behavior": "Ensure that during the creation of a Child instance, the Parent instance is properly initiated with all necessary fields to prevent an extra UPDATE call."
    },
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/forms/models.py",
        "start": 660,
        "end": 672,
        "class_name": null,
        "method_name": "save",
        "code": "660     def save(self, commit=True):\n661         \"\"\"\n662         Save model instances for every form, adding and changing instances\n663         as necessary, and return the list of instances.\n664         \"\"\"\n665         if not commit:\n666             self.saved_forms = []\n667 \n668             def save_m2m():\n669                 for form in self.saved_forms:\n670                     form.save_m2m()\n671             self.save_m2m = save_m2m\n672         return self.save_existing_objects(commit) + self.save_new_objects(commit)\n",
        "intended_behavior": "Ensure that during the creation of a Child instance, the Parent instance is properly initiated with all necessary fields to prevent an extra UPDATE call."
    },
    {
        "rel_file_path": "django/db/models/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/models/base.py",
        "start": 666,
        "end": 750,
        "class_name": null,
        "method_name": "save",
        "code": "666     def save(self, force_insert=False, force_update=False, using=None,\n667              update_fields=None):\n668         \"\"\"\n669         Save the current instance. Override this in a subclass if you want to\n670         control the saving process.\n671 \n672         The 'force_insert' and 'force_update' parameters can be used to insist\n673         that the \"save\" must be an SQL insert or update (or equivalent for\n674         non-SQL backends), respectively. Normally, they should not be set.\n675         \"\"\"\n676         # Ensure that a model instance without a PK hasn't been assigned to\n677         # a ForeignKey or OneToOneField on this model. If the field is\n678         # nullable, allowing the save() would result in silent data loss.\n679         for field in self._meta.concrete_fields:\n680             # If the related field isn't cached, then an instance hasn't\n681             # been assigned and there's no need to worry about this check.\n682             if field.is_relation and field.is_cached(self):\n683                 obj = getattr(self, field.name, None)\n684                 if not obj:\n685                     continue\n686                 # A pk may have been assigned manually to a model instance not\n687                 # saved to the database (or auto-generated in a case like\n688                 # UUIDField), but we allow the save to proceed and rely on the\n689                 # database to raise an IntegrityError if applicable. If\n690                 # constraints aren't supported by the database, there's the\n691                 # unavoidable risk of data corruption.\n692                 if obj.pk is None:\n693                     # Remove the object from a related instance cache.\n694                     if not field.remote_field.multiple:\n695                         field.remote_field.delete_cached_value(obj)\n696                     raise ValueError(\n697                         \"save() prohibited to prevent data loss due to \"\n698                         \"unsaved related object '%s'.\" % field.name\n699                     )\n700                 elif getattr(self, field.attname) is None:\n701                     # Use pk from related object if it has been saved after\n702                     # an assignment.\n703                     setattr(self, field.attname, obj.pk)\n704                 # If the relationship's pk/to_field was changed, clear the\n705                 # cached relationship.\n706                 if getattr(obj, field.target_field.attname) != getattr(self, field.attname):\n707                     field.delete_cached_value(self)\n708 \n709         using = using or router.db_for_write(self.__class__, instance=self)\n710         if force_insert and (force_update or update_fields):\n711             raise ValueError(\"Cannot force both insert and updating in model saving.\")\n712 \n713         deferred_fields = self.get_deferred_fields()\n714         if update_fields is not None:\n715             # If update_fields is empty, skip the save. We do also check for\n716             # no-op saves later on for inheritance cases. This bailout is\n717             # still needed for skipping signal sending.\n718             if not update_fields:\n719                 return\n720 \n721             update_fields = frozenset(update_fields)\n722             field_names = set()\n723 \n724             for field in self._meta.fields:\n725                 if not field.primary_key:\n726                     field_names.add(field.name)\n727 \n728                     if field.name != field.attname:\n729                         field_names.add(field.attname)\n730 \n731             non_model_fields = update_fields.difference(field_names)\n732 \n733             if non_model_fields:\n734                 raise ValueError(\"The following fields do not exist in this \"\n735                                  \"model or are m2m fields: %s\"\n736                                  % ', '.join(non_model_fields))\n737 \n738         # If saving to the same database, and this model is deferred, then\n739         # automatically do an \"update_fields\" save on the loaded fields.\n740         elif not force_insert and deferred_fields and using == self._state.db:\n741             field_names = set()\n742             for field in self._meta.concrete_fields:\n743                 if not field.primary_key and not hasattr(field, 'through'):\n744                     field_names.add(field.attname)\n745             loaded_fields = field_names.difference(deferred_fields)\n746             if loaded_fields:\n747                 update_fields = frozenset(loaded_fields)\n748 \n749         self.save_base(using=using, force_insert=force_insert,\n750                        force_update=force_update, update_fields=update_fields)\n",
        "intended_behavior": "Ensure that during the creation of a Child instance, the Parent instance is properly initiated with all necessary fields to prevent an extra UPDATE call."
    }
]