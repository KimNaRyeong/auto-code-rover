[
    {
        "rel_file_path": "astropy/cosmology/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/cosmology/core.py",
        "start": 50,
        "end": 391,
        "class_name": "Cosmology",
        "method_name": null,
        "code": "50 class Cosmology(metaclass=abc.ABCMeta):\n51     \"\"\"Base-class for all Cosmologies.\n52 \n53     Parameters\n54     ----------\n55     *args\n56         Arguments into the cosmology; used by subclasses, not this base class.\n57     name : str or None (optional, keyword-only)\n58         The name of the cosmology.\n59     meta : dict or None (optional, keyword-only)\n60         Metadata for the cosmology, e.g., a reference.\n61     **kwargs\n62         Arguments into the cosmology; used by subclasses, not this base class.\n63 \n64     Notes\n65     -----\n66     Class instances are static -- you cannot (and should not) change the values\n67     of the parameters.  That is, all of the above attributes (except meta) are\n68     read only.\n69 \n70     For details on how to create performant custom subclasses, see the\n71     documentation on :ref:`astropy-cosmology-fast-integrals`.\n72     \"\"\"\n73 \n74     meta = MetaData()\n75 \n76     # Unified I/O object interchange methods\n77     from_format = UnifiedReadWriteMethod(CosmologyFromFormat)\n78     to_format = UnifiedReadWriteMethod(CosmologyToFormat)\n79 \n80     # Unified I/O read and write methods\n81     read = UnifiedReadWriteMethod(CosmologyRead)\n82     write = UnifiedReadWriteMethod(CosmologyWrite)\n83 \n84     # Parameters\n85     __parameters__: tuple[str, ...] = ()\n86     __all_parameters__: tuple[str, ...] = ()\n87 \n88     # ---------------------------------------------------------------\n89 \n90     def __init_subclass__(cls):\n91         super().__init_subclass__()\n92 \n93         # -------------------\n94         # Parameters\n95 \n96         # Get parameters that are still Parameters, either in this class or above.\n97         parameters = []\n98         derived_parameters = []\n99         for n in cls.__parameters__:\n100             p = getattr(cls, n)\n101             if isinstance(p, Parameter):\n102                 derived_parameters.append(n) if p.derived else parameters.append(n)\n103 \n104         # Add new parameter definitions\n105         for n, v in cls.__dict__.items():\n106             if n in parameters or n.startswith(\"_\") or not isinstance(v, Parameter):\n107                 continue\n108             derived_parameters.append(n) if v.derived else parameters.append(n)\n109 \n110         # reorder to match signature\n111         ordered = [parameters.pop(parameters.index(n))\n112                    for n in cls._init_signature.parameters.keys()\n113                    if n in parameters]\n114         parameters = ordered + parameters  # place \"unordered\" at the end\n115         cls.__parameters__ = tuple(parameters)\n116         cls.__all_parameters__ = cls.__parameters__ + tuple(derived_parameters)\n117 \n118         # -------------------\n119         # register as a Cosmology subclass\n120         _COSMOLOGY_CLASSES[cls.__qualname__] = cls\n121 \n122     @classproperty(lazy=True)\n123     def _init_signature(cls):\n124         \"\"\"Initialization signature (without 'self').\"\"\"\n125         # get signature, dropping \"self\" by taking arguments [1:]\n126         sig = inspect.signature(cls.__init__)\n127         sig = sig.replace(parameters=list(sig.parameters.values())[1:])\n128         return sig\n129 \n130     # ---------------------------------------------------------------\n131 \n132     def __init__(self, name=None, meta=None):\n133         self._name = str(name) if name is not None else name\n134         self.meta.update(meta or {})\n135 \n136     @property\n137     def name(self):\n138         \"\"\"The name of the Cosmology instance.\"\"\"\n139         return self._name\n140 \n141     @property\n142     @abc.abstractmethod\n143     def is_flat(self):\n144         \"\"\"\n145         Return bool; `True` if the cosmology is flat.\n146         This is abstract and must be defined in subclasses.\n147         \"\"\"\n148         raise NotImplementedError(\"is_flat is not implemented\")\n149 \n150     def clone(self, *, meta=None, **kwargs):\n151         \"\"\"Returns a copy of this object with updated parameters, as specified.\n152 \n153         This cannot be used to change the type of the cosmology, so ``clone()``\n154         cannot be used to change between flat and non-flat cosmologies.\n155 \n156         Parameters\n157         ----------\n158         meta : mapping or None (optional, keyword-only)\n159             Metadata that will update the current metadata.\n160         **kwargs\n161             Cosmology parameter (and name) modifications. If any parameter is\n162             changed and a new name is not given, the name will be set to \"[old\n163             name] (modified)\".\n164 \n165         Returns\n166         -------\n167         newcosmo : `~astropy.cosmology.Cosmology` subclass instance\n168             A new instance of this class with updated parameters as specified.\n169             If no arguments are given, then a reference to this object is\n170             returned instead of copy.\n171 \n172         Examples\n173         --------\n174         To make a copy of the ``Planck13`` cosmology with a different matter\n175         density (``Om0``), and a new name:\n176 \n177             >>> from astropy.cosmology import Planck13\n178             >>> Planck13.clone(name=\"Modified Planck 2013\", Om0=0.35)\n179             FlatLambdaCDM(name=\"Modified Planck 2013\", H0=67.77 km / (Mpc s),\n180                           Om0=0.35, ...\n181 \n182         If no name is specified, the new name will note the modification.\n183 \n184             >>> Planck13.clone(Om0=0.35).name\n185             'Planck13 (modified)'\n186         \"\"\"\n187         # Quick return check, taking advantage of the Cosmology immutability.\n188         if meta is None and not kwargs:\n189             return self\n190 \n191         # There are changed parameter or metadata values.\n192         # The name needs to be changed accordingly, if it wasn't already.\n193         _modname = self.name + \" (modified)\"\n194         kwargs.setdefault(\"name\", (_modname if self.name is not None else None))\n195 \n196         # mix new meta into existing, preferring the former.\n197         meta = meta if meta is not None else {}\n198         new_meta = {**self.meta, **meta}\n199         # Mix kwargs into initial arguments, preferring the former.\n200         new_init = {**self._init_arguments, \"meta\": new_meta, **kwargs}\n201         # Create BoundArgument to handle args versus kwargs.\n202         # This also handles all errors from mismatched arguments\n203         ba = self._init_signature.bind_partial(**new_init)\n204         # Instantiate, respecting args vs kwargs\n205         cloned = type(self)(*ba.args, **ba.kwargs)\n206 \n207         # Check if nothing has changed.\n208         # TODO! or should return self?\n209         if (cloned.name == _modname) and not meta and cloned.is_equivalent(self):\n210             cloned._name = self.name\n211 \n212         return cloned\n213 \n214     @property\n215     def _init_arguments(self):\n216         # parameters\n217         kw = {n: getattr(self, n) for n in self.__parameters__}\n218 \n219         # other info\n220         kw[\"name\"] = self.name\n221         kw[\"meta\"] = self.meta\n222 \n223         return kw\n224 \n225     # ---------------------------------------------------------------\n226     # comparison methods\n227 \n228     def is_equivalent(self, other: Any, /, *, format: _FormatType = False) -> bool:\n229         r\"\"\"Check equivalence between Cosmologies.\n230 \n231         Two cosmologies may be equivalent even if not the same class.\n232         For example, an instance of ``LambdaCDM`` might have :math:`\\Omega_0=1`\n233         and :math:`\\Omega_k=0` and therefore be flat, like ``FlatLambdaCDM``.\n234 \n235         Parameters\n236         ----------\n237         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n238             The object to which to compare.\n239         format : bool or None or str, optional keyword-only\n240             Whether to allow, before equivalence is checked, the object to be\n241             converted to a |Cosmology|. This allows, e.g. a |Table| to be\n242             equivalent to a Cosmology.\n243             `False` (default) will not allow conversion. `True` or `None` will,\n244             and will use the auto-identification to try to infer the correct\n245             format. A `str` is assumed to be the correct format to use when\n246             converting.\n247             ``format`` is broadcast to match the shape of ``other``.\n248             Note that the cosmology arguments are not broadcast against\n249             ``format``, so it cannot determine the output shape.\n250 \n251         Returns\n252         -------\n253         bool\n254             True if cosmologies are equivalent, False otherwise.\n255 \n256         Examples\n257         --------\n258         Two cosmologies may be equivalent even if not of the same class.\n259         In this examples the ``LambdaCDM`` has ``Ode0`` set to the same value\n260         calculated in ``FlatLambdaCDM``.\n261 \n262             >>> import astropy.units as u\n263             >>> from astropy.cosmology import LambdaCDM, FlatLambdaCDM\n264             >>> cosmo1 = LambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, 0.7)\n265             >>> cosmo2 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3)\n266             >>> cosmo1.is_equivalent(cosmo2)\n267             True\n268 \n269         While in this example, the cosmologies are not equivalent.\n270 \n271             >>> cosmo3 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, Tcmb0=3 * u.K)\n272             >>> cosmo3.is_equivalent(cosmo2)\n273             False\n274 \n275         Also, using the keyword argument, the notion of equivalence is extended\n276         to any Python object that can be converted to a |Cosmology|.\n277 \n278             >>> from astropy.cosmology import Planck18\n279             >>> tbl = Planck18.to_format(\"astropy.table\")\n280             >>> Planck18.is_equivalent(tbl, format=True)\n281             True\n282 \n283         The list of valid formats, e.g. the |Table| in this example, may be\n284         checked with ``Cosmology.from_format.list_formats()``.\n285 \n286         As can be seen in the list of formats, not all formats can be\n287         auto-identified by ``Cosmology.from_format.registry``. Objects of\n288         these kinds can still be checked for equivalence, but the correct\n289         format string must be used.\n290 \n291             >>> tbl = Planck18.to_format(\"yaml\")\n292             >>> Planck18.is_equivalent(tbl, format=\"yaml\")\n293             True\n294         \"\"\"\n295         from .funcs import cosmology_equal\n296 \n297         try:\n298             return cosmology_equal(self, other, format=(None, format), allow_equivalent=True)\n299         except Exception:\n300             # `is_equivalent` allows `other` to be any object and returns False\n301             # if `other` cannot be converted to a Cosmology, rather than\n302             # raising an Exception.\n303             return False\n304 \n305     def __equiv__(self, other: Any, /) -> bool:\n306         \"\"\"Cosmology equivalence. Use ``.is_equivalent()`` for actual check!\n307 \n308         Parameters\n309         ----------\n310         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n311             The object in which to compare.\n312 \n313         Returns\n314         -------\n315         bool or `NotImplemented`\n316             `NotImplemented` if ``other`` is from a different class.\n317             `True` if ``other`` is of the same class and has matching parameters\n318             and parameter values.\n319             `False` otherwise.\n320         \"\"\"\n321         if other.__class__ is not self.__class__:\n322             return NotImplemented  # allows other.__equiv__\n323 \n324         # Check all parameters in 'other' match those in 'self' and 'other' has\n325         # no extra parameters (latter part should never happen b/c same class)\n326         params_eq = (set(self.__all_parameters__) == set(other.__all_parameters__)\n327                      and all(np.all(getattr(self, k) == getattr(other, k))\n328                              for k in self.__all_parameters__))\n329         return params_eq\n330 \n331     def __eq__(self, other: Any, /) -> bool:\n332         \"\"\"Check equality between Cosmologies.\n333 \n334         Checks the Parameters and immutable fields (i.e. not \"meta\").\n335 \n336         Parameters\n337         ----------\n338         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n339             The object in which to compare.\n340 \n341         Returns\n342         -------\n343         bool\n344             `True` if Parameters and names are the same, `False` otherwise.\n345         \"\"\"\n346         if other.__class__ is not self.__class__:\n347             return NotImplemented  # allows other.__eq__\n348 \n349         eq = (\n350             # non-Parameter checks: name\n351             self.name == other.name\n352             # check all parameters in 'other' match those in 'self' and 'other'\n353             # has no extra parameters (latter part should never happen b/c same\n354             # class) TODO! element-wise when there are array cosmologies\n355             and set(self.__all_parameters__) == set(other.__all_parameters__)\n356             and all(np.all(getattr(self, k) == getattr(other, k))\n357                     for k in self.__all_parameters__)\n358         )\n359 \n360         return eq\n361 \n362     # ---------------------------------------------------------------\n363 \n364     def __repr__(self):\n365         namelead = f\"{self.__class__.__qualname__}(\"\n366         if self.name is not None:\n367             namelead += f\"name=\\\"{self.name}\\\", \"\n368         # nicely formatted parameters\n369         fmtps = (f'{k}={getattr(self, k)}' for k in self.__parameters__)\n370 \n371         return namelead + \", \".join(fmtps) + \")\"\n372 \n373     def __astropy_table__(self, cls, copy, **kwargs):\n374         \"\"\"Return a `~astropy.table.Table` of type ``cls``.\n375 \n376         Parameters\n377         ----------\n378         cls : type\n379             Astropy ``Table`` class or subclass.\n380         copy : bool\n381             Ignored.\n382         **kwargs : dict, optional\n383             Additional keyword arguments. Passed to ``self.to_format()``.\n384             See ``Cosmology.to_format.help(\"astropy.table\")`` for allowed kwargs.\n385 \n386         Returns\n387         -------\n388         `astropy.table.Table` or subclass instance\n389             Instance of type ``cls``.\n390         \"\"\"\n391         return self.to_format(\"astropy.table\", cls=cls, **kwargs)\n",
        "intended_behavior": "Implement a new method, 'write_html', within the 'Cosmology' class. This method should leverage the 'to_table' method to convert the cosmology instance into a tabular format suitable for HTML representation. Then, format this table using MathJax for any relevant cosmological parameters with the assistance of a new feature or extension utilizing 'QTable.write(..., format='html')'. The new method should smoothly integrate with existing IO capabilities, meaning it should use or extend the existing framework ('UnifiedReadWriteMethod') to support the HTML format, ensuring consistency with how other formats are handled."
    },
    {
        "rel_file_path": "astropy/cosmology/io/table.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/cosmology/io/table.py",
        "start": 139,
        "end": 233,
        "class_name": null,
        "method_name": "to_table",
        "code": "139 def to_table(cosmology, *args, cls=QTable, cosmology_in_meta=True):\n140     \"\"\"Serialize the cosmology into a `~astropy.table.QTable`.\n141 \n142     Parameters\n143     ----------\n144     cosmology : `~astropy.cosmology.Cosmology` subclass instance\n145     *args\n146         Not used. Needed for compatibility with\n147         `~astropy.io.registry.UnifiedReadWriteMethod`\n148     cls : type (optional, keyword-only)\n149         Astropy :class:`~astropy.table.Table` class or subclass type to return.\n150         Default is :class:`~astropy.table.QTable`.\n151     cosmology_in_meta : bool\n152         Whether to put the cosmology class in the Table metadata (if `True`,\n153         default) or as the first column (if `False`).\n154 \n155     Returns\n156     -------\n157     `~astropy.table.QTable`\n158         With columns for the cosmology parameters, and metadata and\n159         cosmology class name in the Table's ``meta`` attribute\n160 \n161     Raises\n162     ------\n163     TypeError\n164         If kwarg (optional) 'cls' is not a subclass of `astropy.table.Table`\n165 \n166     Examples\n167     --------\n168     A Cosmology as a `~astropy.table.QTable` will have the cosmology's name and\n169     parameters as columns.\n170 \n171         >>> from astropy.cosmology import Planck18\n172         >>> ct = Planck18.to_format(\"astropy.table\")\n173         >>> ct\n174         <QTable length=1>\n175           name        H0        Om0    Tcmb0    Neff      m_nu      Ob0\n176                  km / (Mpc s)            K                 eV\n177           str8     float64    float64 float64 float64  float64[3] float64\n178         -------- ------------ ------- ------- ------- ----------- -------\n179         Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897\n180 \n181     The cosmological class and other metadata, e.g. a paper reference, are in\n182     the Table's metadata.\n183 \n184         >>> ct.meta\n185         OrderedDict([..., ('cosmology', 'FlatLambdaCDM')])\n186 \n187     To move the cosmology class from the metadata to a Table row, set the\n188     ``cosmology_in_meta`` argument to `False`:\n189 \n190         >>> Planck18.to_format(\"astropy.table\", cosmology_in_meta=False)\n191         <QTable length=1>\n192           cosmology     name        H0        Om0    Tcmb0    Neff      m_nu      Ob0\n193                                km / (Mpc s)            K                 eV\n194             str13       str8     float64    float64 float64 float64  float64[3] float64\n195         ------------- -------- ------------ ------- ------- ------- ----------- -------\n196         FlatLambdaCDM Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897\n197 \n198     Astropy recommends `~astropy.table.QTable` for tables with\n199     `~astropy.units.Quantity` columns. However the returned type may be\n200     overridden using the ``cls`` argument:\n201 \n202         >>> from astropy.table import Table\n203         >>> Planck18.to_format(\"astropy.table\", cls=Table)\n204         <Table length=1>\n205         ...\n206     \"\"\"\n207     if not issubclass(cls, Table):\n208         raise TypeError(f\"'cls' must be a (sub)class of Table, not {type(cls)}\")\n209 \n210     # Start by getting a map representation.\n211     data = to_mapping(cosmology)\n212     data[\"cosmology\"] = data[\"cosmology\"].__qualname__  # change to str\n213 \n214     # Metadata\n215     meta = data.pop(\"meta\")  # remove the meta\n216     if cosmology_in_meta:\n217         meta[\"cosmology\"] = data.pop(\"cosmology\")\n218 \n219     # Need to turn everything into something Table can process:\n220     # - Column for Parameter\n221     # - list for anything else\n222     cosmo_cls = cosmology.__class__\n223     for k, v in data.items():\n224         if k in cosmology.__parameters__:\n225             col = convert_parameter_to_column(getattr(cosmo_cls, k), v,\n226                                               cosmology.meta.get(k))\n227         else:\n228             col = Column([v])\n229         data[k] = col\n230 \n231     tbl = cls(data, meta=meta)\n232     tbl.add_index(\"name\", unique=True)\n233     return tbl\n",
        "intended_behavior": "Enhance the 'to_table' method (or create a helper function specifically for HTML output) to ensure it includes additional formatting details necessary for HTML representation, especially focusing on providing support for MathJax formatting. This may involve attaching metadata or custom formatting instructions to table columns based on cosmology parameters, utilizing the approach similar to 'def_unit' for specifying MathJax representations."
    },
    {
        "rel_file_path": "astropy/units/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/units/core.py",
        "start": 1,
        "end": 2575,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \n3 \"\"\"\n4 Core units classes and functions\n5 \"\"\"\n6 \n7 \n8 import inspect\n9 import operator\n10 import textwrap\n11 import warnings\n12 \n13 import numpy as np\n14 \n15 from astropy.utils.decorators import lazyproperty\n16 from astropy.utils.exceptions import AstropyWarning\n17 from astropy.utils.misc import isiterable\n18 \n19 from . import format as unit_format\n20 from .utils import is_effectively_unity, resolve_fractions, sanitize_scale, validate_power\n21 \n22 __all__ = [\n23     'UnitsError', 'UnitsWarning', 'UnitConversionError', 'UnitTypeError',\n24     'UnitBase', 'NamedUnit', 'IrreducibleUnit', 'Unit', 'CompositeUnit',\n25     'PrefixUnit', 'UnrecognizedUnit', 'def_unit', 'get_current_unit_registry',\n26     'set_enabled_units', 'add_enabled_units',\n27     'set_enabled_equivalencies', 'add_enabled_equivalencies',\n28     'set_enabled_aliases', 'add_enabled_aliases',\n29     'dimensionless_unscaled', 'one',\n30 ]\n31 \n32 UNITY = 1.0\n33 \n34 \n35 def _flatten_units_collection(items):\n36     \"\"\"\n37     Given a list of sequences, modules or dictionaries of units, or\n38     single units, return a flat set of all the units found.\n39     \"\"\"\n40     if not isinstance(items, list):\n41         items = [items]\n42 \n43     result = set()\n44     for item in items:\n45         if isinstance(item, UnitBase):\n46             result.add(item)\n47         else:\n48             if isinstance(item, dict):\n49                 units = item.values()\n50             elif inspect.ismodule(item):\n51                 units = vars(item).values()\n52             elif isiterable(item):\n53                 units = item\n54             else:\n55                 continue\n56 \n57             for unit in units:\n58                 if isinstance(unit, UnitBase):\n59                     result.add(unit)\n60 \n61     return result\n62 \n63 \n64 def _normalize_equivalencies(equivalencies):\n65     \"\"\"\n66     Normalizes equivalencies, ensuring each is a 4-tuple of the form::\n67 \n68     (from_unit, to_unit, forward_func, backward_func)\n69 \n70     Parameters\n71     ----------\n72     equivalencies : list of equivalency pairs\n73 \n74     Raises\n75     ------\n76     ValueError if an equivalency cannot be interpreted\n77     \"\"\"\n78     if equivalencies is None:\n79         return []\n80 \n81     normalized = []\n82 \n83     for i, equiv in enumerate(equivalencies):\n84         if len(equiv) == 2:\n85             funit, tunit = equiv\n86             a = b = lambda x: x\n87         elif len(equiv) == 3:\n88             funit, tunit, a = equiv\n89             b = a\n90         elif len(equiv) == 4:\n91             funit, tunit, a, b = equiv\n92         else:\n93             raise ValueError(\n94                 f\"Invalid equivalence entry {i}: {equiv!r}\")\n95         if not (funit is Unit(funit) and\n96                 (tunit is None or tunit is Unit(tunit)) and\n97                 callable(a) and\n98                 callable(b)):\n99             raise ValueError(\n100                 f\"Invalid equivalence entry {i}: {equiv!r}\")\n101         normalized.append((funit, tunit, a, b))\n102 \n103     return normalized\n104 \n105 \n106 class _UnitRegistry:\n107     \"\"\"\n108     Manages a registry of the enabled units.\n109     \"\"\"\n110 \n111     def __init__(self, init=[], equivalencies=[], aliases={}):\n112 \n113         if isinstance(init, _UnitRegistry):\n114             # If passed another registry we don't need to rebuild everything.\n115             # but because these are mutable types we don't want to create\n116             # conflicts so everything needs to be copied.\n117             self._equivalencies = init._equivalencies.copy()\n118             self._aliases = init._aliases.copy()\n119             self._all_units = init._all_units.copy()\n120             self._registry = init._registry.copy()\n121             self._non_prefix_units = init._non_prefix_units.copy()\n122             # The physical type is a dictionary containing sets as values.\n123             # All of these must be copied otherwise we could alter the old\n124             # registry.\n125             self._by_physical_type = {k: v.copy() for k, v in\n126                                       init._by_physical_type.items()}\n127 \n128         else:\n129             self._reset_units()\n130             self._reset_equivalencies()\n131             self._reset_aliases()\n132             self.add_enabled_units(init)\n133             self.add_enabled_equivalencies(equivalencies)\n134             self.add_enabled_aliases(aliases)\n135 \n136     def _reset_units(self):\n137         self._all_units = set()\n138         self._non_prefix_units = set()\n139         self._registry = {}\n140         self._by_physical_type = {}\n141 \n142     def _reset_equivalencies(self):\n143         self._equivalencies = set()\n144 \n145     def _reset_aliases(self):\n146         self._aliases = {}\n147 \n148     @property\n149     def registry(self):\n150         return self._registry\n151 \n152     @property\n153     def all_units(self):\n154         return self._all_units\n155 \n156     @property\n157     def non_prefix_units(self):\n158         return self._non_prefix_units\n159 \n160     def set_enabled_units(self, units):\n161         \"\"\"\n162         Sets the units enabled in the unit registry.\n163 \n164         These units are searched when using\n165         `UnitBase.find_equivalent_units`, for example.\n166 \n167         Parameters\n168         ----------\n169         units : list of sequence, dict, or module\n170             This is a list of things in which units may be found\n171             (sequences, dicts or modules), or units themselves.  The\n172             entire set will be \"enabled\" for searching through by\n173             methods like `UnitBase.find_equivalent_units` and\n174             `UnitBase.compose`.\n175         \"\"\"\n176         self._reset_units()\n177         return self.add_enabled_units(units)\n178 \n179     def add_enabled_units(self, units):\n180         \"\"\"\n181         Adds to the set of units enabled in the unit registry.\n182 \n183         These units are searched when using\n184         `UnitBase.find_equivalent_units`, for example.\n185 \n186         Parameters\n187         ----------\n188         units : list of sequence, dict, or module\n189             This is a list of things in which units may be found\n190             (sequences, dicts or modules), or units themselves.  The\n191             entire set will be added to the \"enabled\" set for\n192             searching through by methods like\n193             `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n194         \"\"\"\n195         units = _flatten_units_collection(units)\n196 \n197         for unit in units:\n198             # Loop through all of the names first, to ensure all of them\n199             # are new, then add them all as a single \"transaction\" below.\n200             for st in unit._names:\n201                 if (st in self._registry and unit != self._registry[st]):\n202                     raise ValueError(\n203                         \"Object with name {!r} already exists in namespace. \"\n204                         \"Filter the set of units to avoid name clashes before \"\n205                         \"enabling them.\".format(st))\n206 \n207             for st in unit._names:\n208                 self._registry[st] = unit\n209 \n210             self._all_units.add(unit)\n211             if not isinstance(unit, PrefixUnit):\n212                 self._non_prefix_units.add(unit)\n213 \n214             hash = unit._get_physical_type_id()\n215             self._by_physical_type.setdefault(hash, set()).add(unit)\n216 \n217     def get_units_with_physical_type(self, unit):\n218         \"\"\"\n219         Get all units in the registry with the same physical type as\n220         the given unit.\n221 \n222         Parameters\n223         ----------\n224         unit : UnitBase instance\n225         \"\"\"\n226         return self._by_physical_type.get(unit._get_physical_type_id(), set())\n227 \n228     @property\n229     def equivalencies(self):\n230         return list(self._equivalencies)\n231 \n232     def set_enabled_equivalencies(self, equivalencies):\n233         \"\"\"\n234         Sets the equivalencies enabled in the unit registry.\n235 \n236         These equivalencies are used if no explicit equivalencies are given,\n237         both in unit conversion and in finding equivalent units.\n238 \n239         This is meant in particular for allowing angles to be dimensionless.\n240         Use with care.\n241 \n242         Parameters\n243         ----------\n244         equivalencies : list of tuple\n245             List of equivalent pairs, e.g., as returned by\n246             `~astropy.units.equivalencies.dimensionless_angles`.\n247         \"\"\"\n248         self._reset_equivalencies()\n249         return self.add_enabled_equivalencies(equivalencies)\n250 \n251     def add_enabled_equivalencies(self, equivalencies):\n252         \"\"\"\n253         Adds to the set of equivalencies enabled in the unit registry.\n254 \n255         These equivalencies are used if no explicit equivalencies are given,\n256         both in unit conversion and in finding equivalent units.\n257 \n258         This is meant in particular for allowing angles to be dimensionless.\n259         Use with care.\n260 \n261         Parameters\n262         ----------\n263         equivalencies : list of tuple\n264             List of equivalent pairs, e.g., as returned by\n265             `~astropy.units.equivalencies.dimensionless_angles`.\n266         \"\"\"\n267         # pre-normalize list to help catch mistakes\n268         equivalencies = _normalize_equivalencies(equivalencies)\n269         self._equivalencies |= set(equivalencies)\n270 \n271     @property\n272     def aliases(self):\n273         return self._aliases\n274 \n275     def set_enabled_aliases(self, aliases):\n276         \"\"\"\n277         Set aliases for units.\n278 \n279         Parameters\n280         ----------\n281         aliases : dict of str, Unit\n282             The aliases to set. The keys must be the string aliases, and values\n283             must be the `astropy.units.Unit` that the alias will be mapped to.\n284 \n285         Raises\n286         ------\n287         ValueError\n288             If the alias already defines a different unit.\n289 \n290         \"\"\"\n291         self._reset_aliases()\n292         self.add_enabled_aliases(aliases)\n293 \n294     def add_enabled_aliases(self, aliases):\n295         \"\"\"\n296         Add aliases for units.\n297 \n298         Parameters\n299         ----------\n300         aliases : dict of str, Unit\n301             The aliases to add. The keys must be the string aliases, and values\n302             must be the `astropy.units.Unit` that the alias will be mapped to.\n303 \n304         Raises\n305         ------\n306         ValueError\n307             If the alias already defines a different unit.\n308 \n309         \"\"\"\n310         for alias, unit in aliases.items():\n311             if alias in self._registry and unit != self._registry[alias]:\n312                 raise ValueError(\n313                     f\"{alias} already means {self._registry[alias]}, so \"\n314                     f\"cannot be used as an alias for {unit}.\")\n315             if alias in self._aliases and unit != self._aliases[alias]:\n316                 raise ValueError(\n317                     f\"{alias} already is an alias for {self._aliases[alias]}, so \"\n318                     f\"cannot be used as an alias for {unit}.\")\n319 \n320         for alias, unit in aliases.items():\n321             if alias not in self._registry and alias not in self._aliases:\n322                 self._aliases[alias] = unit\n323 \n324 \n325 class _UnitContext:\n326     def __init__(self, init=[], equivalencies=[]):\n327         _unit_registries.append(\n328             _UnitRegistry(init=init, equivalencies=equivalencies))\n329 \n330     def __enter__(self):\n331         pass\n332 \n333     def __exit__(self, type, value, tb):\n334         _unit_registries.pop()\n335 \n336 \n337 _unit_registries = [_UnitRegistry()]\n338 \n339 \n340 def get_current_unit_registry():\n341     return _unit_registries[-1]\n342 \n343 \n344 def set_enabled_units(units):\n345     \"\"\"\n346     Sets the units enabled in the unit registry.\n347 \n348     These units are searched when using\n349     `UnitBase.find_equivalent_units`, for example.\n350 \n351     This may be used either permanently, or as a context manager using\n352     the ``with`` statement (see example below).\n353 \n354     Parameters\n355     ----------\n356     units : list of sequence, dict, or module\n357         This is a list of things in which units may be found\n358         (sequences, dicts or modules), or units themselves.  The\n359         entire set will be \"enabled\" for searching through by methods\n360         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.\n361 \n362     Examples\n363     --------\n364 \n365     >>> from astropy import units as u\n366     >>> with u.set_enabled_units([u.pc]):\n367     ...     u.m.find_equivalent_units()\n368     ...\n369       Primary name | Unit definition | Aliases\n370     [\n371       pc           | 3.08568e+16 m   | parsec  ,\n372     ]\n373     >>> u.m.find_equivalent_units()\n374       Primary name | Unit definition | Aliases\n375     [\n376       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n377       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n378       cm           | 0.01 m          | centimeter                       ,\n379       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n380       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n381       lsec         | 2.99792e+08 m   | lightsecond                      ,\n382       lyr          | 9.46073e+15 m   | lightyear                        ,\n383       m            | irreducible     | meter                            ,\n384       micron       | 1e-06 m         |                                  ,\n385       pc           | 3.08568e+16 m   | parsec                           ,\n386       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n387     ]\n388     \"\"\"\n389     # get a context with a new registry, using equivalencies of the current one\n390     context = _UnitContext(\n391         equivalencies=get_current_unit_registry().equivalencies)\n392     # in this new current registry, enable the units requested\n393     get_current_unit_registry().set_enabled_units(units)\n394     return context\n395 \n396 \n397 def add_enabled_units(units):\n398     \"\"\"\n399     Adds to the set of units enabled in the unit registry.\n400 \n401     These units are searched when using\n402     `UnitBase.find_equivalent_units`, for example.\n403 \n404     This may be used either permanently, or as a context manager using\n405     the ``with`` statement (see example below).\n406 \n407     Parameters\n408     ----------\n409     units : list of sequence, dict, or module\n410         This is a list of things in which units may be found\n411         (sequences, dicts or modules), or units themselves.  The\n412         entire set will be added to the \"enabled\" set for searching\n413         through by methods like `UnitBase.find_equivalent_units` and\n414         `UnitBase.compose`.\n415 \n416     Examples\n417     --------\n418 \n419     >>> from astropy import units as u\n420     >>> from astropy.units import imperial\n421     >>> with u.add_enabled_units(imperial):\n422     ...     u.m.find_equivalent_units()\n423     ...\n424       Primary name | Unit definition | Aliases\n425     [\n426       AU           | 1.49598e+11 m   | au, astronomical_unit            ,\n427       Angstrom     | 1e-10 m         | AA, angstrom                     ,\n428       cm           | 0.01 m          | centimeter                       ,\n429       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,\n430       ft           | 0.3048 m        | foot                             ,\n431       fur          | 201.168 m       | furlong                          ,\n432       inch         | 0.0254 m        |                                  ,\n433       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,\n434       lsec         | 2.99792e+08 m   | lightsecond                      ,\n435       lyr          | 9.46073e+15 m   | lightyear                        ,\n436       m            | irreducible     | meter                            ,\n437       mi           | 1609.34 m       | mile                             ,\n438       micron       | 1e-06 m         |                                  ,\n439       mil          | 2.54e-05 m      | thou                             ,\n440       nmi          | 1852 m          | nauticalmile, NM                 ,\n441       pc           | 3.08568e+16 m   | parsec                           ,\n442       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,\n443       yd           | 0.9144 m        | yard                             ,\n444     ]\n445     \"\"\"\n446     # get a context with a new registry, which is a copy of the current one\n447     context = _UnitContext(get_current_unit_registry())\n448     # in this new current registry, enable the further units requested\n449     get_current_unit_registry().add_enabled_units(units)\n450     return context\n451 \n452 \n453 def set_enabled_equivalencies(equivalencies):\n454     \"\"\"\n455     Sets the equivalencies enabled in the unit registry.\n456 \n457     These equivalencies are used if no explicit equivalencies are given,\n458     both in unit conversion and in finding equivalent units.\n459 \n460     This is meant in particular for allowing angles to be dimensionless.\n461     Use with care.\n462 \n463     Parameters\n464     ----------\n465     equivalencies : list of tuple\n466         list of equivalent pairs, e.g., as returned by\n467         `~astropy.units.equivalencies.dimensionless_angles`.\n468 \n469     Examples\n470     --------\n471     Exponentiation normally requires dimensionless quantities.  To avoid\n472     problems with complex phases::\n473 \n474         >>> from astropy import units as u\n475         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):\n476         ...     phase = 0.5 * u.cycle\n477         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP\n478         <Quantity -1.+1.2246468e-16j>\n479     \"\"\"\n480     # get a context with a new registry, using all units of the current one\n481     context = _UnitContext(get_current_unit_registry())\n482     # in this new current registry, enable the equivalencies requested\n483     get_current_unit_registry().set_enabled_equivalencies(equivalencies)\n484     return context\n485 \n486 \n487 def add_enabled_equivalencies(equivalencies):\n488     \"\"\"\n489     Adds to the equivalencies enabled in the unit registry.\n490 \n491     These equivalencies are used if no explicit equivalencies are given,\n492     both in unit conversion and in finding equivalent units.\n493 \n494     This is meant in particular for allowing angles to be dimensionless.\n495     Since no equivalencies are enabled by default, generally it is recommended\n496     to use `set_enabled_equivalencies`.\n497 \n498     Parameters\n499     ----------\n500     equivalencies : list of tuple\n501         list of equivalent pairs, e.g., as returned by\n502         `~astropy.units.equivalencies.dimensionless_angles`.\n503     \"\"\"\n504     # get a context with a new registry, which is a copy of the current one\n505     context = _UnitContext(get_current_unit_registry())\n506     # in this new current registry, enable the further equivalencies requested\n507     get_current_unit_registry().add_enabled_equivalencies(equivalencies)\n508     return context\n509 \n510 \n511 def set_enabled_aliases(aliases):\n512     \"\"\"\n513     Set aliases for units.\n514 \n515     This is useful for handling alternate spellings for units, or\n516     misspelled units in files one is trying to read.\n517 \n518     Parameters\n519     ----------\n520     aliases : dict of str, Unit\n521         The aliases to set. The keys must be the string aliases, and values\n522         must be the `astropy.units.Unit` that the alias will be mapped to.\n523 \n524     Raises\n525     ------\n526     ValueError\n527         If the alias already defines a different unit.\n528 \n529     Examples\n530     --------\n531     To temporarily allow for a misspelled 'Angstroem' unit::\n532 \n533         >>> from astropy import units as u\n534         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):\n535         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n536         True\n537 \n538     \"\"\"\n539     # get a context with a new registry, which is a copy of the current one\n540     context = _UnitContext(get_current_unit_registry())\n541     # in this new current registry, enable the further equivalencies requested\n542     get_current_unit_registry().set_enabled_aliases(aliases)\n543     return context\n544 \n545 \n546 def add_enabled_aliases(aliases):\n547     \"\"\"\n548     Add aliases for units.\n549 \n550     This is useful for handling alternate spellings for units, or\n551     misspelled units in files one is trying to read.\n552 \n553     Since no aliases are enabled by default, generally it is recommended\n554     to use `set_enabled_aliases`.\n555 \n556     Parameters\n557     ----------\n558     aliases : dict of str, Unit\n559         The aliases to add. The keys must be the string aliases, and values\n560         must be the `astropy.units.Unit` that the alias will be mapped to.\n561 \n562     Raises\n563     ------\n564     ValueError\n565         If the alias already defines a different unit.\n566 \n567     Examples\n568     --------\n569     To temporarily allow for a misspelled 'Angstroem' unit::\n570 \n571         >>> from astropy import units as u\n572         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):\n573         ...     print(u.Unit(\"Angstroem\", parse_strict=\"raise\") == u.Angstrom)\n574         True\n575 \n576     \"\"\"\n577     # get a context with a new registry, which is a copy of the current one\n578     context = _UnitContext(get_current_unit_registry())\n579     # in this new current registry, enable the further equivalencies requested\n580     get_current_unit_registry().add_enabled_aliases(aliases)\n581     return context\n582 \n583 \n584 class UnitsError(Exception):\n585     \"\"\"\n586     The base class for unit-specific exceptions.\n587     \"\"\"\n588 \n589 \n590 class UnitScaleError(UnitsError, ValueError):\n591     \"\"\"\n592     Used to catch the errors involving scaled units,\n593     which are not recognized by FITS format.\n594     \"\"\"\n595     pass\n596 \n597 \n598 class UnitConversionError(UnitsError, ValueError):\n599     \"\"\"\n600     Used specifically for errors related to converting between units or\n601     interpreting units in terms of other units.\n602     \"\"\"\n603 \n604 \n605 class UnitTypeError(UnitsError, TypeError):\n606     \"\"\"\n607     Used specifically for errors in setting to units not allowed by a class.\n608 \n609     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`\n610     instances were set to a non-angular unit.\n611     \"\"\"\n612 \n613 \n614 class UnitsWarning(AstropyWarning):\n615     \"\"\"\n616     The base class for unit-specific warnings.\n617     \"\"\"\n618 \n619 \n620 class UnitBase:\n621     \"\"\"\n622     Abstract base class for units.\n623 \n624     Most of the arithmetic operations on units are defined in this\n625     base class.\n626 \n627     Should not be instantiated by users directly.\n628     \"\"\"\n629     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy\n630     # arrays to avoid element-wise multiplication.\n631     __array_priority__ = 1000\n632 \n633     _hash = None\n634     _type_id = None\n635 \n636     def __deepcopy__(self, memo):\n637         # This may look odd, but the units conversion will be very\n638         # broken after deep-copying if we don't guarantee that a given\n639         # physical unit corresponds to only one instance\n640         return self\n641 \n642     def _repr_latex_(self):\n643         \"\"\"\n644         Generate latex representation of unit name.  This is used by\n645         the IPython notebook to print a unit with a nice layout.\n646 \n647         Returns\n648         -------\n649         Latex string\n650         \"\"\"\n651         return unit_format.Latex.to_string(self)\n652 \n653     def __bytes__(self):\n654         \"\"\"Return string representation for unit\"\"\"\n655         return unit_format.Generic.to_string(self).encode('unicode_escape')\n656 \n657     def __str__(self):\n658         \"\"\"Return string representation for unit\"\"\"\n659         return unit_format.Generic.to_string(self)\n660 \n661     def __repr__(self):\n662         string = unit_format.Generic.to_string(self)\n663 \n664         return f'Unit(\"{string}\")'\n665 \n666     def _get_physical_type_id(self):\n667         \"\"\"\n668         Returns an identifier that uniquely identifies the physical\n669         type of this unit.  It is comprised of the bases and powers of\n670         this unit, without the scale.  Since it is hashable, it is\n671         useful as a dictionary key.\n672         \"\"\"\n673         if self._type_id is None:\n674             unit = self.decompose()\n675             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))\n676 \n677         return self._type_id\n678 \n679     @property\n680     def names(self):\n681         \"\"\"\n682         Returns all of the names associated with this unit.\n683         \"\"\"\n684         raise AttributeError(\n685             \"Can not get names from unnamed units. \"\n686             \"Perhaps you meant to_string()?\")\n687 \n688     @property\n689     def name(self):\n690         \"\"\"\n691         Returns the canonical (short) name associated with this unit.\n692         \"\"\"\n693         raise AttributeError(\n694             \"Can not get names from unnamed units. \"\n695             \"Perhaps you meant to_string()?\")\n696 \n697     @property\n698     def aliases(self):\n699         \"\"\"\n700         Returns the alias (long) names for this unit.\n701         \"\"\"\n702         raise AttributeError(\n703             \"Can not get aliases from unnamed units. \"\n704             \"Perhaps you meant to_string()?\")\n705 \n706     @property\n707     def scale(self):\n708         \"\"\"\n709         Return the scale of the unit.\n710         \"\"\"\n711         return 1.0\n712 \n713     @property\n714     def bases(self):\n715         \"\"\"\n716         Return the bases of the unit.\n717         \"\"\"\n718         return [self]\n719 \n720     @property\n721     def powers(self):\n722         \"\"\"\n723         Return the powers of the unit.\n724         \"\"\"\n725         return [1]\n726 \n727     def to_string(self, format=unit_format.Generic):\n728         \"\"\"\n729         Output the unit in the given format as a string.\n730 \n731         Parameters\n732         ----------\n733         format : `astropy.units.format.Base` instance or str\n734             The name of a format or a formatter object.  If not\n735             provided, defaults to the generic format.\n736         \"\"\"\n737 \n738         f = unit_format.get_format(format)\n739         return f.to_string(self)\n740 \n741     def __format__(self, format_spec):\n742         \"\"\"Try to format units using a formatter.\"\"\"\n743         try:\n744             return self.to_string(format=format_spec)\n745         except ValueError:\n746             return format(str(self), format_spec)\n747 \n748     @staticmethod\n749     def _normalize_equivalencies(equivalencies):\n750         \"\"\"\n751         Normalizes equivalencies, ensuring each is a 4-tuple of the form::\n752 \n753         (from_unit, to_unit, forward_func, backward_func)\n754 \n755         Parameters\n756         ----------\n757         equivalencies : list of equivalency pairs, or None\n758 \n759         Returns\n760         -------\n761         A normalized list, including possible global defaults set by, e.g.,\n762         `set_enabled_equivalencies`, except when `equivalencies`=`None`,\n763         in which case the returned list is always empty.\n764 \n765         Raises\n766         ------\n767         ValueError if an equivalency cannot be interpreted\n768         \"\"\"\n769         normalized = _normalize_equivalencies(equivalencies)\n770         if equivalencies is not None:\n771             normalized += get_current_unit_registry().equivalencies\n772 \n773         return normalized\n774 \n775     def __pow__(self, p):\n776         p = validate_power(p)\n777         return CompositeUnit(1, [self], [p], _error_check=False)\n778 \n779     def __truediv__(self, m):\n780         if isinstance(m, (bytes, str)):\n781             m = Unit(m)\n782 \n783         if isinstance(m, UnitBase):\n784             if m.is_unity():\n785                 return self\n786             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)\n787 \n788         try:\n789             # Cannot handle this as Unit, re-try as Quantity\n790             from .quantity import Quantity\n791             return Quantity(1, self) / m\n792         except TypeError:\n793             return NotImplemented\n794 \n795     def __rtruediv__(self, m):\n796         if isinstance(m, (bytes, str)):\n797             return Unit(m) / self\n798 \n799         try:\n800             # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n801             # so we make it into one, fasttracking when it does not have a\n802             # unit, for the common case of <array> / <unit>.\n803             from .quantity import Quantity\n804             if hasattr(m, 'unit'):\n805                 result = Quantity(m)\n806                 result /= self\n807                 return result\n808             else:\n809                 return Quantity(m, self**(-1))\n810         except TypeError:\n811             return NotImplemented\n812 \n813     def __mul__(self, m):\n814         if isinstance(m, (bytes, str)):\n815             m = Unit(m)\n816 \n817         if isinstance(m, UnitBase):\n818             if m.is_unity():\n819                 return self\n820             elif self.is_unity():\n821                 return m\n822             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)\n823 \n824         # Cannot handle this as Unit, re-try as Quantity.\n825         try:\n826             from .quantity import Quantity\n827             return Quantity(1, unit=self) * m\n828         except TypeError:\n829             return NotImplemented\n830 \n831     def __rmul__(self, m):\n832         if isinstance(m, (bytes, str)):\n833             return Unit(m) * self\n834 \n835         # Cannot handle this as Unit.  Here, m cannot be a Quantity,\n836         # so we make it into one, fasttracking when it does not have a unit\n837         # for the common case of <array> * <unit>.\n838         try:\n839             from .quantity import Quantity\n840             if hasattr(m, 'unit'):\n841                 result = Quantity(m)\n842                 result *= self\n843                 return result\n844             else:\n845                 return Quantity(m, unit=self)\n846         except TypeError:\n847             return NotImplemented\n848 \n849     def __rlshift__(self, m):\n850         try:\n851             from .quantity import Quantity\n852             return Quantity(m, self, copy=False, subok=True)\n853         except Exception:\n854             return NotImplemented\n855 \n856     def __rrshift__(self, m):\n857         warnings.warn(\">> is not implemented. Did you mean to convert \"\n858                       \"to a Quantity with unit {} using '<<'?\".format(self),\n859                       AstropyWarning)\n860         return NotImplemented\n861 \n862     def __hash__(self):\n863         if self._hash is None:\n864             parts = ([str(self.scale)] +\n865                      [x.name for x in self.bases] +\n866                      [str(x) for x in self.powers])\n867             self._hash = hash(tuple(parts))\n868         return self._hash\n869 \n870     def __getstate__(self):\n871         # If we get pickled, we should *not* store the memoized members since\n872         # hashes of strings vary between sessions.\n873         state = self.__dict__.copy()\n874         state.pop('_hash', None)\n875         state.pop('_type_id', None)\n876         return state\n877 \n878     def __eq__(self, other):\n879         if self is other:\n880             return True\n881 \n882         try:\n883             other = Unit(other, parse_strict='silent')\n884         except (ValueError, UnitsError, TypeError):\n885             return NotImplemented\n886 \n887         # Other is unit-like, but the test below requires it is a UnitBase\n888         # instance; if it is not, give up (so that other can try).\n889         if not isinstance(other, UnitBase):\n890             return NotImplemented\n891 \n892         try:\n893             return is_effectively_unity(self._to(other))\n894         except UnitsError:\n895             return False\n896 \n897     def __ne__(self, other):\n898         return not (self == other)\n899 \n900     def __le__(self, other):\n901         scale = self._to(Unit(other))\n902         return scale <= 1. or is_effectively_unity(scale)\n903 \n904     def __ge__(self, other):\n905         scale = self._to(Unit(other))\n906         return scale >= 1. or is_effectively_unity(scale)\n907 \n908     def __lt__(self, other):\n909         return not (self >= other)\n910 \n911     def __gt__(self, other):\n912         return not (self <= other)\n913 \n914     def __neg__(self):\n915         return self * -1.\n916 \n917     def is_equivalent(self, other, equivalencies=[]):\n918         \"\"\"\n919         Returns `True` if this unit is equivalent to ``other``.\n920 \n921         Parameters\n922         ----------\n923         other : `~astropy.units.Unit`, str, or tuple\n924             The unit to convert to. If a tuple of units is specified, this\n925             method returns true if the unit matches any of those in the tuple.\n926 \n927         equivalencies : list of tuple\n928             A list of equivalence pairs to try if the units are not\n929             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n930             This list is in addition to possible global defaults set by, e.g.,\n931             `set_enabled_equivalencies`.\n932             Use `None` to turn off all equivalencies.\n933 \n934         Returns\n935         -------\n936         bool\n937         \"\"\"\n938         equivalencies = self._normalize_equivalencies(equivalencies)\n939 \n940         if isinstance(other, tuple):\n941             return any(self.is_equivalent(u, equivalencies=equivalencies)\n942                        for u in other)\n943 \n944         other = Unit(other, parse_strict='silent')\n945 \n946         return self._is_equivalent(other, equivalencies)\n947 \n948     def _is_equivalent(self, other, equivalencies=[]):\n949         \"\"\"Returns `True` if this unit is equivalent to `other`.\n950         See `is_equivalent`, except that a proper Unit object should be\n951         given (i.e., no string) and that the equivalency list should be\n952         normalized using `_normalize_equivalencies`.\n953         \"\"\"\n954         if isinstance(other, UnrecognizedUnit):\n955             return False\n956 \n957         if (self._get_physical_type_id() ==\n958                 other._get_physical_type_id()):\n959             return True\n960         elif len(equivalencies):\n961             unit = self.decompose()\n962             other = other.decompose()\n963             for a, b, forward, backward in equivalencies:\n964                 if b is None:\n965                     # after canceling, is what's left convertible\n966                     # to dimensionless (according to the equivalency)?\n967                     try:\n968                         (other/unit).decompose([a])\n969                         return True\n970                     except Exception:\n971                         pass\n972                 elif (\n973                     a._is_equivalent(unit) and b._is_equivalent(other)\n974                     or b._is_equivalent(unit) and a._is_equivalent(other)\n975                 ):\n976                     return True\n977 \n978         return False\n979 \n980     def _apply_equivalencies(self, unit, other, equivalencies):\n981         \"\"\"\n982         Internal function (used from `_get_converter`) to apply\n983         equivalence pairs.\n984         \"\"\"\n985         def make_converter(scale1, func, scale2):\n986             def convert(v):\n987                 return func(_condition_arg(v) / scale1) * scale2\n988             return convert\n989 \n990         for funit, tunit, a, b in equivalencies:\n991             if tunit is None:\n992                 try:\n993                     ratio_in_funit = (other.decompose() /\n994                                       unit.decompose()).decompose([funit])\n995                     return make_converter(ratio_in_funit.scale, a, 1.)\n996                 except UnitsError:\n997                     pass\n998             else:\n999                 try:\n1000                     scale1 = funit._to(unit)\n1001                     scale2 = tunit._to(other)\n1002                     return make_converter(scale1, a, scale2)\n1003                 except UnitsError:\n1004                     pass\n1005                 try:\n1006                     scale1 = tunit._to(unit)\n1007                     scale2 = funit._to(other)\n1008                     return make_converter(scale1, b, scale2)\n1009                 except UnitsError:\n1010                     pass\n1011 \n1012         def get_err_str(unit):\n1013             unit_str = unit.to_string('unscaled')\n1014             physical_type = unit.physical_type\n1015             if physical_type != 'unknown':\n1016                 unit_str = f\"'{unit_str}' ({physical_type})\"\n1017             else:\n1018                 unit_str = f\"'{unit_str}'\"\n1019             return unit_str\n1020 \n1021         unit_str = get_err_str(unit)\n1022         other_str = get_err_str(other)\n1023 \n1024         raise UnitConversionError(\n1025             f\"{unit_str} and {other_str} are not convertible\")\n1026 \n1027     def _get_converter(self, other, equivalencies=[]):\n1028         \"\"\"Get a converter for values in ``self`` to ``other``.\n1029 \n1030         If no conversion is necessary, returns ``unit_scale_converter``\n1031         (which is used as a check in quantity helpers).\n1032 \n1033         \"\"\"\n1034 \n1035         # First see if it is just a scaling.\n1036         try:\n1037             scale = self._to(other)\n1038         except UnitsError:\n1039             pass\n1040         else:\n1041             if scale == 1.:\n1042                 return unit_scale_converter\n1043             else:\n1044                 return lambda val: scale * _condition_arg(val)\n1045 \n1046         # if that doesn't work, maybe we can do it with equivalencies?\n1047         try:\n1048             return self._apply_equivalencies(\n1049                 self, other, self._normalize_equivalencies(equivalencies))\n1050         except UnitsError as exc:\n1051             # Last hope: maybe other knows how to do it?\n1052             # We assume the equivalencies have the unit itself as first item.\n1053             # TODO: maybe better for other to have a `_back_converter` method?\n1054             if hasattr(other, 'equivalencies'):\n1055                 for funit, tunit, a, b in other.equivalencies:\n1056                     if other is funit:\n1057                         try:\n1058                             return lambda v: b(self._get_converter(\n1059                                 tunit, equivalencies=equivalencies)(v))\n1060                         except Exception:\n1061                             pass\n1062 \n1063             raise exc\n1064 \n1065     def _to(self, other):\n1066         \"\"\"\n1067         Returns the scale to the specified unit.\n1068 \n1069         See `to`, except that a Unit object should be given (i.e., no\n1070         string), and that all defaults are used, i.e., no\n1071         equivalencies and value=1.\n1072         \"\"\"\n1073         # There are many cases where we just want to ensure a Quantity is\n1074         # of a particular unit, without checking whether it's already in\n1075         # a particular unit.  If we're being asked to convert from a unit\n1076         # to itself, we can short-circuit all of this.\n1077         if self is other:\n1078             return 1.0\n1079 \n1080         # Don't presume decomposition is possible; e.g.,\n1081         # conversion to function units is through equivalencies.\n1082         if isinstance(other, UnitBase):\n1083             self_decomposed = self.decompose()\n1084             other_decomposed = other.decompose()\n1085 \n1086             # Check quickly whether equivalent.  This is faster than\n1087             # `is_equivalent`, because it doesn't generate the entire\n1088             # physical type list of both units.  In other words it \"fails\n1089             # fast\".\n1090             if (self_decomposed.powers == other_decomposed.powers\n1091                 and all(self_base is other_base for (self_base, other_base)\n1092                         in zip(self_decomposed.bases, other_decomposed.bases))):\n1093                 return self_decomposed.scale / other_decomposed.scale\n1094 \n1095         raise UnitConversionError(\n1096             f\"'{self!r}' is not a scaled version of '{other!r}'\")\n1097 \n1098     def to(self, other, value=UNITY, equivalencies=[]):\n1099         \"\"\"\n1100         Return the converted values in the specified unit.\n1101 \n1102         Parameters\n1103         ----------\n1104         other : unit-like\n1105             The unit to convert to.\n1106 \n1107         value : int, float, or scalar array-like, optional\n1108             Value(s) in the current unit to be converted to the\n1109             specified unit.  If not provided, defaults to 1.0\n1110 \n1111         equivalencies : list of tuple\n1112             A list of equivalence pairs to try if the units are not\n1113             directly convertible.  See :ref:`astropy:unit_equivalencies`.\n1114             This list is in addition to possible global defaults set by, e.g.,\n1115             `set_enabled_equivalencies`.\n1116             Use `None` to turn off all equivalencies.\n1117 \n1118         Returns\n1119         -------\n1120         values : scalar or array\n1121             Converted value(s). Input value sequences are returned as\n1122             numpy arrays.\n1123 \n1124         Raises\n1125         ------\n1126         UnitsError\n1127             If units are inconsistent\n1128         \"\"\"\n1129         if other is self and value is UNITY:\n1130             return UNITY\n1131         else:\n1132             return self._get_converter(Unit(other),\n1133                                        equivalencies=equivalencies)(value)\n1134 \n1135     def in_units(self, other, value=1.0, equivalencies=[]):\n1136         \"\"\"\n1137         Alias for `to` for backward compatibility with pynbody.\n1138         \"\"\"\n1139         return self.to(\n1140             other, value=value, equivalencies=equivalencies)\n1141 \n1142     def decompose(self, bases=set()):\n1143         \"\"\"\n1144         Return a unit object composed of only irreducible units.\n1145 \n1146         Parameters\n1147         ----------\n1148         bases : sequence of UnitBase, optional\n1149             The bases to decompose into.  When not provided,\n1150             decomposes down to any irreducible units.  When provided,\n1151             the decomposed result will only contain the given units.\n1152             This will raises a `UnitsError` if it's not possible\n1153             to do so.\n1154 \n1155         Returns\n1156         -------\n1157         unit : `~astropy.units.CompositeUnit`\n1158             New object containing only irreducible unit objects.\n1159         \"\"\"\n1160         raise NotImplementedError()\n1161 \n1162     def _compose(self, equivalencies=[], namespace=[], max_depth=2, depth=0,\n1163                  cached_results=None):\n1164         def is_final_result(unit):\n1165             # Returns True if this result contains only the expected\n1166             # units\n1167             for base in unit.bases:\n1168                 if base not in namespace:\n1169                     return False\n1170             return True\n1171 \n1172         unit = self.decompose()\n1173         key = hash(unit)\n1174 \n1175         cached = cached_results.get(key)\n1176         if cached is not None:\n1177             if isinstance(cached, Exception):\n1178                 raise cached\n1179             return cached\n1180 \n1181         # Prevent too many levels of recursion\n1182         # And special case for dimensionless unit\n1183         if depth >= max_depth:\n1184             cached_results[key] = [unit]\n1185             return [unit]\n1186 \n1187         # Make a list including all of the equivalent units\n1188         units = [unit]\n1189         for funit, tunit, a, b in equivalencies:\n1190             if tunit is not None:\n1191                 if self._is_equivalent(funit):\n1192                     scale = funit.decompose().scale / unit.scale\n1193                     units.append(Unit(a(1.0 / scale) * tunit).decompose())\n1194                 elif self._is_equivalent(tunit):\n1195                     scale = tunit.decompose().scale / unit.scale\n1196                     units.append(Unit(b(1.0 / scale) * funit).decompose())\n1197             else:\n1198                 if self._is_equivalent(funit):\n1199                     units.append(Unit(unit.scale))\n1200 \n1201         # Store partial results\n1202         partial_results = []\n1203         # Store final results that reduce to a single unit or pair of\n1204         # units\n1205         if len(unit.bases) == 0:\n1206             final_results = [{unit}, set()]\n1207         else:\n1208             final_results = [set(), set()]\n1209 \n1210         for tunit in namespace:\n1211             tunit_decomposed = tunit.decompose()\n1212             for u in units:\n1213                 # If the unit is a base unit, look for an exact match\n1214                 # to one of the bases of the target unit.  If found,\n1215                 # factor by the same power as the target unit's base.\n1216                 # This allows us to factor out fractional powers\n1217                 # without needing to do an exhaustive search.\n1218                 if len(tunit_decomposed.bases) == 1:\n1219                     for base, power in zip(u.bases, u.powers):\n1220                         if tunit_decomposed._is_equivalent(base):\n1221                             tunit = tunit ** power\n1222                             tunit_decomposed = tunit_decomposed ** power\n1223                             break\n1224 \n1225                 composed = (u / tunit_decomposed).decompose()\n1226                 factored = composed * tunit\n1227                 len_bases = len(composed.bases)\n1228                 if is_final_result(factored) and len_bases <= 1:\n1229                     final_results[len_bases].add(factored)\n1230                 else:\n1231                     partial_results.append(\n1232                         (len_bases, composed, tunit))\n1233 \n1234         # Do we have any minimal results?\n1235         for final_result in final_results:\n1236             if len(final_result):\n1237                 results = final_results[0].union(final_results[1])\n1238                 cached_results[key] = results\n1239                 return results\n1240 \n1241         partial_results.sort(key=operator.itemgetter(0))\n1242 \n1243         # ...we have to recurse and try to further compose\n1244         results = []\n1245         for len_bases, composed, tunit in partial_results:\n1246             try:\n1247                 composed_list = composed._compose(\n1248                     equivalencies=equivalencies,\n1249                     namespace=namespace,\n1250                     max_depth=max_depth, depth=depth + 1,\n1251                     cached_results=cached_results)\n1252             except UnitsError:\n1253                 composed_list = []\n1254             for subcomposed in composed_list:\n1255                 results.append(\n1256                     (len(subcomposed.bases), subcomposed, tunit))\n1257 \n1258         if len(results):\n1259             results.sort(key=operator.itemgetter(0))\n1260 \n1261             min_length = results[0][0]\n1262             subresults = set()\n1263             for len_bases, composed, tunit in results:\n1264                 if len_bases > min_length:\n1265                     break\n1266                 else:\n1267                     factored = composed * tunit\n1268                     if is_final_result(factored):\n1269                         subresults.add(factored)\n1270 \n1271             if len(subresults):\n1272                 cached_results[key] = subresults\n1273                 return subresults\n1274 \n1275         if not is_final_result(self):\n1276             result = UnitsError(\n1277                 f\"Cannot represent unit {self} in terms of the given units\")\n1278             cached_results[key] = result\n1279             raise result\n1280 \n1281         cached_results[key] = [self]\n1282         return [self]\n1283 \n1284     def compose(self, equivalencies=[], units=None, max_depth=2,\n1285                 include_prefix_units=None):\n1286         \"\"\"\n1287         Return the simplest possible composite unit(s) that represent\n1288         the given unit.  Since there may be multiple equally simple\n1289         compositions of the unit, a list of units is always returned.\n1290 \n1291         Parameters\n1292         ----------\n1293         equivalencies : list of tuple\n1294             A list of equivalence pairs to also list.  See\n1295             :ref:`astropy:unit_equivalencies`.\n1296             This list is in addition to possible global defaults set by, e.g.,\n1297             `set_enabled_equivalencies`.\n1298             Use `None` to turn off all equivalencies.\n1299 \n1300         units : set of `~astropy.units.Unit`, optional\n1301             If not provided, any known units may be used to compose\n1302             into.  Otherwise, ``units`` is a dict, module or sequence\n1303             containing the units to compose into.\n1304 \n1305         max_depth : int, optional\n1306             The maximum recursion depth to use when composing into\n1307             composite units.\n1308 \n1309         include_prefix_units : bool, optional\n1310             When `True`, include prefixed units in the result.\n1311             Default is `True` if a sequence is passed in to ``units``,\n1312             `False` otherwise.\n1313 \n1314         Returns\n1315         -------\n1316         units : list of `CompositeUnit`\n1317             A list of candidate compositions.  These will all be\n1318             equally simple, but it may not be possible to\n1319             automatically determine which of the candidates are\n1320             better.\n1321         \"\"\"\n1322         # if units parameter is specified and is a sequence (list|tuple),\n1323         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]\n1324         if include_prefix_units is None:\n1325             include_prefix_units = isinstance(units, (list, tuple))\n1326 \n1327         # Pre-normalize the equivalencies list\n1328         equivalencies = self._normalize_equivalencies(equivalencies)\n1329 \n1330         # The namespace of units to compose into should be filtered to\n1331         # only include units with bases in common with self, otherwise\n1332         # they can't possibly provide useful results.  Having too many\n1333         # destination units greatly increases the search space.\n1334 \n1335         def has_bases_in_common(a, b):\n1336             if len(a.bases) == 0 and len(b.bases) == 0:\n1337                 return True\n1338             for ab in a.bases:\n1339                 for bb in b.bases:\n1340                     if ab == bb:\n1341                         return True\n1342             return False\n1343 \n1344         def has_bases_in_common_with_equiv(unit, other):\n1345             if has_bases_in_common(unit, other):\n1346                 return True\n1347             for funit, tunit, a, b in equivalencies:\n1348                 if tunit is not None:\n1349                     if unit._is_equivalent(funit):\n1350                         if has_bases_in_common(tunit.decompose(), other):\n1351                             return True\n1352                     elif unit._is_equivalent(tunit):\n1353                         if has_bases_in_common(funit.decompose(), other):\n1354                             return True\n1355                 else:\n1356                     if unit._is_equivalent(funit):\n1357                         if has_bases_in_common(dimensionless_unscaled, other):\n1358                             return True\n1359             return False\n1360 \n1361         def filter_units(units):\n1362             filtered_namespace = set()\n1363             for tunit in units:\n1364                 if (isinstance(tunit, UnitBase) and\n1365                     (include_prefix_units or\n1366                      not isinstance(tunit, PrefixUnit)) and\n1367                     has_bases_in_common_with_equiv(\n1368                         decomposed, tunit.decompose())):\n1369                     filtered_namespace.add(tunit)\n1370             return filtered_namespace\n1371 \n1372         decomposed = self.decompose()\n1373 \n1374         if units is None:\n1375             units = filter_units(self._get_units_with_same_physical_type(\n1376                 equivalencies=equivalencies))\n1377             if len(units) == 0:\n1378                 units = get_current_unit_registry().non_prefix_units\n1379         elif isinstance(units, dict):\n1380             units = set(filter_units(units.values()))\n1381         elif inspect.ismodule(units):\n1382             units = filter_units(vars(units).values())\n1383         else:\n1384             units = filter_units(_flatten_units_collection(units))\n1385 \n1386         def sort_results(results):\n1387             if not len(results):\n1388                 return []\n1389 \n1390             # Sort the results so the simplest ones appear first.\n1391             # Simplest is defined as \"the minimum sum of absolute\n1392             # powers\" (i.e. the fewest bases), and preference should\n1393             # be given to results where the sum of powers is positive\n1394             # and the scale is exactly equal to 1.0\n1395             results = list(results)\n1396             results.sort(key=lambda x: np.abs(x.scale))\n1397             results.sort(key=lambda x: np.sum(np.abs(x.powers)))\n1398             results.sort(key=lambda x: np.sum(x.powers) < 0.0)\n1399             results.sort(key=lambda x: not is_effectively_unity(x.scale))\n1400 \n1401             last_result = results[0]\n1402             filtered = [last_result]\n1403             for result in results[1:]:\n1404                 if str(result) != str(last_result):\n1405                     filtered.append(result)\n1406                 last_result = result\n1407 \n1408             return filtered\n1409 \n1410         return sort_results(self._compose(\n1411             equivalencies=equivalencies, namespace=units,\n1412             max_depth=max_depth, depth=0, cached_results={}))\n1413 \n1414     def to_system(self, system):\n1415         \"\"\"\n1416         Converts this unit into ones belonging to the given system.\n1417         Since more than one result may be possible, a list is always\n1418         returned.\n1419 \n1420         Parameters\n1421         ----------\n1422         system : module\n1423             The module that defines the unit system.  Commonly used\n1424             ones include `astropy.units.si` and `astropy.units.cgs`.\n1425 \n1426             To use your own module it must contain unit objects and a\n1427             sequence member named ``bases`` containing the base units of\n1428             the system.\n1429 \n1430         Returns\n1431         -------\n1432         units : list of `CompositeUnit`\n1433             The list is ranked so that units containing only the base\n1434             units of that system will appear first.\n1435         \"\"\"\n1436         bases = set(system.bases)\n1437 \n1438         def score(compose):\n1439             # In case that compose._bases has no elements we return\n1440             # 'np.inf' as 'score value'.  It does not really matter which\n1441             # number we would return. This case occurs for instance for\n1442             # dimensionless quantities:\n1443             compose_bases = compose.bases\n1444             if len(compose_bases) == 0:\n1445                 return np.inf\n1446             else:\n1447                 sum = 0\n1448                 for base in compose_bases:\n1449                     if base in bases:\n1450                         sum += 1\n1451 \n1452                 return sum / float(len(compose_bases))\n1453 \n1454         x = self.decompose(bases=bases)\n1455         composed = x.compose(units=system)\n1456         composed = sorted(composed, key=score, reverse=True)\n1457         return composed\n1458 \n1459     @lazyproperty\n1460     def si(self):\n1461         \"\"\"\n1462         Returns a copy of the current `Unit` instance in SI units.\n1463         \"\"\"\n1464 \n1465         from . import si\n1466         return self.to_system(si)[0]\n1467 \n1468     @lazyproperty\n1469     def cgs(self):\n1470         \"\"\"\n1471         Returns a copy of the current `Unit` instance with CGS units.\n1472         \"\"\"\n1473         from . import cgs\n1474         return self.to_system(cgs)[0]\n1475 \n1476     @property\n1477     def physical_type(self):\n1478         \"\"\"\n1479         Physical type(s) dimensionally compatible with the unit.\n1480 \n1481         Returns\n1482         -------\n1483         `~astropy.units.physical.PhysicalType`\n1484             A representation of the physical type(s) of a unit.\n1485 \n1486         Examples\n1487         --------\n1488         >>> from astropy import units as u\n1489         >>> u.m.physical_type\n1490         PhysicalType('length')\n1491         >>> (u.m ** 2 / u.s).physical_type\n1492         PhysicalType({'diffusivity', 'kinematic viscosity'})\n1493 \n1494         Physical types can be compared to other physical types\n1495         (recommended in packages) or to strings.\n1496 \n1497         >>> area = (u.m ** 2).physical_type\n1498         >>> area == u.m.physical_type ** 2\n1499         True\n1500         >>> area == \"area\"\n1501         True\n1502 \n1503         `~astropy.units.physical.PhysicalType` objects can be used for\n1504         dimensional analysis.\n1505 \n1506         >>> number_density = u.m.physical_type ** -3\n1507         >>> velocity = (u.m / u.s).physical_type\n1508         >>> number_density * velocity\n1509         PhysicalType('particle flux')\n1510         \"\"\"\n1511         from . import physical\n1512         return physical.get_physical_type(self)\n1513 \n1514     def _get_units_with_same_physical_type(self, equivalencies=[]):\n1515         \"\"\"\n1516         Return a list of registered units with the same physical type\n1517         as this unit.\n1518 \n1519         This function is used by Quantity to add its built-in\n1520         conversions to equivalent units.\n1521 \n1522         This is a private method, since end users should be encouraged\n1523         to use the more powerful `compose` and `find_equivalent_units`\n1524         methods (which use this under the hood).\n1525 \n1526         Parameters\n1527         ----------\n1528         equivalencies : list of tuple\n1529             A list of equivalence pairs to also pull options from.\n1530             See :ref:`astropy:unit_equivalencies`.  It must already be\n1531             normalized using `_normalize_equivalencies`.\n1532         \"\"\"\n1533         unit_registry = get_current_unit_registry()\n1534         units = set(unit_registry.get_units_with_physical_type(self))\n1535         for funit, tunit, a, b in equivalencies:\n1536             if tunit is not None:\n1537                 if self.is_equivalent(funit) and tunit not in units:\n1538                     units.update(\n1539                         unit_registry.get_units_with_physical_type(tunit))\n1540                 if self._is_equivalent(tunit) and funit not in units:\n1541                     units.update(\n1542                         unit_registry.get_units_with_physical_type(funit))\n1543             else:\n1544                 if self.is_equivalent(funit):\n1545                     units.add(dimensionless_unscaled)\n1546         return units\n1547 \n1548     class EquivalentUnitsList(list):\n1549         \"\"\"\n1550         A class to handle pretty-printing the result of\n1551         `find_equivalent_units`.\n1552         \"\"\"\n1553 \n1554         HEADING_NAMES = ('Primary name', 'Unit definition', 'Aliases')\n1555         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant\n1556         NO_EQUIV_UNITS_MSG = 'There are no equivalent units'\n1557 \n1558         def __repr__(self):\n1559             if len(self) == 0:\n1560                 return self.NO_EQUIV_UNITS_MSG\n1561             else:\n1562                 lines = self._process_equivalent_units(self)\n1563                 lines.insert(0, self.HEADING_NAMES)\n1564                 widths = [0] * self.ROW_LEN\n1565                 for line in lines:\n1566                     for i, col in enumerate(line):\n1567                         widths[i] = max(widths[i], len(col))\n1568 \n1569                 f = \"  {{0:<{0}s}} | {{1:<{1}s}} | {{2:<{2}s}}\".format(*widths)\n1570                 lines = [f.format(*line) for line in lines]\n1571                 lines = (lines[0:1] +\n1572                          ['['] +\n1573                          [f'{x} ,' for x in lines[1:]] +\n1574                          [']'])\n1575                 return '\\n'.join(lines)\n1576 \n1577         def _repr_html_(self):\n1578             \"\"\"\n1579             Outputs a HTML table representation within Jupyter notebooks.\n1580             \"\"\"\n1581             if len(self) == 0:\n1582                 return f\"<p>{self.NO_EQUIV_UNITS_MSG}</p>\"\n1583             else:\n1584                 # HTML tags to use to compose the table in HTML\n1585                 blank_table = '<table style=\"width:50%\">{}</table>'\n1586                 blank_row_container = \"<tr>{}</tr>\"\n1587                 heading_row_content = \"<th>{}</th>\" * self.ROW_LEN\n1588                 data_row_content = \"<td>{}</td>\" * self.ROW_LEN\n1589 \n1590                 # The HTML will be rendered & the table is simple, so don't\n1591                 # bother to include newlines & indentation for the HTML code.\n1592                 heading_row = blank_row_container.format(\n1593                     heading_row_content.format(*self.HEADING_NAMES))\n1594                 data_rows = self._process_equivalent_units(self)\n1595                 all_rows = heading_row\n1596                 for row in data_rows:\n1597                     html_row = blank_row_container.format(\n1598                         data_row_content.format(*row))\n1599                     all_rows += html_row\n1600                 return blank_table.format(all_rows)\n1601 \n1602         @staticmethod\n1603         def _process_equivalent_units(equiv_units_data):\n1604             \"\"\"\n1605             Extract attributes, and sort, the equivalent units pre-formatting.\n1606             \"\"\"\n1607             processed_equiv_units = []\n1608             for u in equiv_units_data:\n1609                 irred = u.decompose().to_string()\n1610                 if irred == u.name:\n1611                     irred = 'irreducible'\n1612                 processed_equiv_units.append(\n1613                     (u.name, irred, ', '.join(u.aliases)))\n1614             processed_equiv_units.sort()\n1615             return processed_equiv_units\n1616 \n1617     def find_equivalent_units(self, equivalencies=[], units=None,\n1618                               include_prefix_units=False):\n1619         \"\"\"\n1620         Return a list of all the units that are the same type as ``self``.\n1621 \n1622         Parameters\n1623         ----------\n1624         equivalencies : list of tuple\n1625             A list of equivalence pairs to also list.  See\n1626             :ref:`astropy:unit_equivalencies`.\n1627             Any list given, including an empty one, supersedes global defaults\n1628             that may be in effect (as set by `set_enabled_equivalencies`)\n1629 \n1630         units : set of `~astropy.units.Unit`, optional\n1631             If not provided, all defined units will be searched for\n1632             equivalencies.  Otherwise, may be a dict, module or\n1633             sequence containing the units to search for equivalencies.\n1634 \n1635         include_prefix_units : bool, optional\n1636             When `True`, include prefixed units in the result.\n1637             Default is `False`.\n1638 \n1639         Returns\n1640         -------\n1641         units : list of `UnitBase`\n1642             A list of unit objects that match ``u``.  A subclass of\n1643             `list` (``EquivalentUnitsList``) is returned that\n1644             pretty-prints the list of units when output.\n1645         \"\"\"\n1646         results = self.compose(\n1647             equivalencies=equivalencies, units=units, max_depth=1,\n1648             include_prefix_units=include_prefix_units)\n1649         results = {x.bases[0] for x in results if len(x.bases) == 1}\n1650         return self.EquivalentUnitsList(results)\n1651 \n1652     def is_unity(self):\n1653         \"\"\"\n1654         Returns `True` if the unit is unscaled and dimensionless.\n1655         \"\"\"\n1656         return False\n1657 \n1658 \n1659 class NamedUnit(UnitBase):\n1660     \"\"\"\n1661     The base class of units that have a name.\n1662 \n1663     Parameters\n1664     ----------\n1665     st : str, list of str, 2-tuple\n1666         The name of the unit.  If a list of strings, the first element\n1667         is the canonical (short) name, and the rest of the elements\n1668         are aliases.  If a tuple of lists, the first element is a list\n1669         of short names, and the second element is a list of long\n1670         names; all but the first short name are considered \"aliases\".\n1671         Each name *should* be a valid Python identifier to make it\n1672         easy to access, but this is not required.\n1673 \n1674     namespace : dict, optional\n1675         When provided, inject the unit, and all of its aliases, in the\n1676         given namespace dictionary.  If a unit by the same name is\n1677         already in the namespace, a ValueError is raised.\n1678 \n1679     doc : str, optional\n1680         A docstring describing the unit.\n1681 \n1682     format : dict, optional\n1683         A mapping to format-specific representations of this unit.\n1684         For example, for the ``Ohm`` unit, it might be nice to have it\n1685         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n1686         case, `format` argument should be set to::\n1687 \n1688             {'latex': r'\\\\Omega'}\n1689 \n1690     Raises\n1691     ------\n1692     ValueError\n1693         If any of the given unit names are already in the registry.\n1694 \n1695     ValueError\n1696         If any of the given unit names are not valid Python tokens.\n1697     \"\"\"\n1698 \n1699     def __init__(self, st, doc=None, format=None, namespace=None):\n1700 \n1701         UnitBase.__init__(self)\n1702 \n1703         if isinstance(st, (bytes, str)):\n1704             self._names = [st]\n1705             self._short_names = [st]\n1706             self._long_names = []\n1707         elif isinstance(st, tuple):\n1708             if not len(st) == 2:\n1709                 raise ValueError(\"st must be string, list or 2-tuple\")\n1710             self._names = st[0] + [n for n in st[1] if n not in st[0]]\n1711             if not len(self._names):\n1712                 raise ValueError(\"must provide at least one name\")\n1713             self._short_names = st[0][:]\n1714             self._long_names = st[1][:]\n1715         else:\n1716             if len(st) == 0:\n1717                 raise ValueError(\n1718                     \"st list must have at least one entry\")\n1719             self._names = st[:]\n1720             self._short_names = [st[0]]\n1721             self._long_names = st[1:]\n1722 \n1723         if format is None:\n1724             format = {}\n1725         self._format = format\n1726 \n1727         if doc is None:\n1728             doc = self._generate_doc()\n1729         else:\n1730             doc = textwrap.dedent(doc)\n1731             doc = textwrap.fill(doc)\n1732 \n1733         self.__doc__ = doc\n1734 \n1735         self._inject(namespace)\n1736 \n1737     def _generate_doc(self):\n1738         \"\"\"\n1739         Generate a docstring for the unit if the user didn't supply\n1740         one.  This is only used from the constructor and may be\n1741         overridden in subclasses.\n1742         \"\"\"\n1743         names = self.names\n1744         if len(self.names) > 1:\n1745             return \"{1} ({0})\".format(*names[:2])\n1746         else:\n1747             return names[0]\n1748 \n1749     def get_format_name(self, format):\n1750         \"\"\"\n1751         Get a name for this unit that is specific to a particular\n1752         format.\n1753 \n1754         Uses the dictionary passed into the `format` kwarg in the\n1755         constructor.\n1756 \n1757         Parameters\n1758         ----------\n1759         format : str\n1760             The name of the format\n1761 \n1762         Returns\n1763         -------\n1764         name : str\n1765             The name of the unit for the given format.\n1766         \"\"\"\n1767         return self._format.get(format, self.name)\n1768 \n1769     @property\n1770     def names(self):\n1771         \"\"\"\n1772         Returns all of the names associated with this unit.\n1773         \"\"\"\n1774         return self._names\n1775 \n1776     @property\n1777     def name(self):\n1778         \"\"\"\n1779         Returns the canonical (short) name associated with this unit.\n1780         \"\"\"\n1781         return self._names[0]\n1782 \n1783     @property\n1784     def aliases(self):\n1785         \"\"\"\n1786         Returns the alias (long) names for this unit.\n1787         \"\"\"\n1788         return self._names[1:]\n1789 \n1790     @property\n1791     def short_names(self):\n1792         \"\"\"\n1793         Returns all of the short names associated with this unit.\n1794         \"\"\"\n1795         return self._short_names\n1796 \n1797     @property\n1798     def long_names(self):\n1799         \"\"\"\n1800         Returns all of the long names associated with this unit.\n1801         \"\"\"\n1802         return self._long_names\n1803 \n1804     def _inject(self, namespace=None):\n1805         \"\"\"\n1806         Injects the unit, and all of its aliases, in the given\n1807         namespace dictionary.\n1808         \"\"\"\n1809         if namespace is None:\n1810             return\n1811 \n1812         # Loop through all of the names first, to ensure all of them\n1813         # are new, then add them all as a single \"transaction\" below.\n1814         for name in self._names:\n1815             if name in namespace and self != namespace[name]:\n1816                 raise ValueError(\n1817                     \"Object with name {!r} already exists in \"\n1818                     \"given namespace ({!r}).\".format(\n1819                         name, namespace[name]))\n1820 \n1821         for name in self._names:\n1822             namespace[name] = self\n1823 \n1824 \n1825 def _recreate_irreducible_unit(cls, names, registered):\n1826     \"\"\"\n1827     This is used to reconstruct units when passed around by\n1828     multiprocessing.\n1829     \"\"\"\n1830     registry = get_current_unit_registry().registry\n1831     if names[0] in registry:\n1832         # If in local registry return that object.\n1833         return registry[names[0]]\n1834     else:\n1835         # otherwise, recreate the unit.\n1836         unit = cls(names)\n1837         if registered:\n1838             # If not in local registry but registered in origin registry,\n1839             # enable unit in local registry.\n1840             get_current_unit_registry().add_enabled_units([unit])\n1841 \n1842         return unit\n1843 \n1844 \n1845 class IrreducibleUnit(NamedUnit):\n1846     \"\"\"\n1847     Irreducible units are the units that all other units are defined\n1848     in terms of.\n1849 \n1850     Examples are meters, seconds, kilograms, amperes, etc.  There is\n1851     only once instance of such a unit per type.\n1852     \"\"\"\n1853 \n1854     def __reduce__(self):\n1855         # When IrreducibleUnit objects are passed to other processes\n1856         # over multiprocessing, they need to be recreated to be the\n1857         # ones already in the subprocesses' namespace, not new\n1858         # objects, or they will be considered \"unconvertible\".\n1859         # Therefore, we have a custom pickler/unpickler that\n1860         # understands how to recreate the Unit on the other side.\n1861         registry = get_current_unit_registry().registry\n1862         return (_recreate_irreducible_unit,\n1863                 (self.__class__, list(self.names), self.name in registry),\n1864                 self.__getstate__())\n1865 \n1866     @property\n1867     def represents(self):\n1868         \"\"\"The unit that this named unit represents.\n1869 \n1870         For an irreducible unit, that is always itself.\n1871         \"\"\"\n1872         return self\n1873 \n1874     def decompose(self, bases=set()):\n1875         if len(bases) and self not in bases:\n1876             for base in bases:\n1877                 try:\n1878                     scale = self._to(base)\n1879                 except UnitsError:\n1880                     pass\n1881                 else:\n1882                     if is_effectively_unity(scale):\n1883                         return base\n1884                     else:\n1885                         return CompositeUnit(scale, [base], [1],\n1886                                              _error_check=False)\n1887 \n1888             raise UnitConversionError(\n1889                 f\"Unit {self} can not be decomposed into the requested bases\")\n1890 \n1891         return self\n1892 \n1893 \n1894 class UnrecognizedUnit(IrreducibleUnit):\n1895     \"\"\"\n1896     A unit that did not parse correctly.  This allows for\n1897     round-tripping it as a string, but no unit operations actually work\n1898     on it.\n1899 \n1900     Parameters\n1901     ----------\n1902     st : str\n1903         The name of the unit.\n1904     \"\"\"\n1905     # For UnrecognizedUnits, we want to use \"standard\" Python\n1906     # pickling, not the special case that is used for\n1907     # IrreducibleUnits.\n1908     __reduce__ = object.__reduce__\n1909 \n1910     def __repr__(self):\n1911         return f\"UnrecognizedUnit({str(self)})\"\n1912 \n1913     def __bytes__(self):\n1914         return self.name.encode('ascii', 'replace')\n1915 \n1916     def __str__(self):\n1917         return self.name\n1918 \n1919     def to_string(self, format=None):\n1920         return self.name\n1921 \n1922     def _unrecognized_operator(self, *args, **kwargs):\n1923         raise ValueError(\n1924             \"The unit {!r} is unrecognized, so all arithmetic operations \"\n1925             \"with it are invalid.\".format(self.name))\n1926 \n1927     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = __lt__ = \\\n1928         __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator\n1929 \n1930     def __eq__(self, other):\n1931         try:\n1932             other = Unit(other, parse_strict='silent')\n1933         except (ValueError, UnitsError, TypeError):\n1934             return NotImplemented\n1935 \n1936         return isinstance(other, type(self)) and self.name == other.name\n1937 \n1938     def __ne__(self, other):\n1939         return not (self == other)\n1940 \n1941     def is_equivalent(self, other, equivalencies=None):\n1942         self._normalize_equivalencies(equivalencies)\n1943         return self == other\n1944 \n1945     def _get_converter(self, other, equivalencies=None):\n1946         self._normalize_equivalencies(equivalencies)\n1947         raise ValueError(\n1948             \"The unit {!r} is unrecognized.  It can not be converted \"\n1949             \"to other units.\".format(self.name))\n1950 \n1951     def get_format_name(self, format):\n1952         return self.name\n1953 \n1954     def is_unity(self):\n1955         return False\n1956 \n1957 \n1958 class _UnitMetaClass(type):\n1959     \"\"\"\n1960     This metaclass exists because the Unit constructor should\n1961     sometimes return instances that already exist.  This \"overrides\"\n1962     the constructor before the new instance is actually created, so we\n1963     can return an existing one.\n1964     \"\"\"\n1965 \n1966     def __call__(self, s=\"\", represents=None, format=None, namespace=None,\n1967                  doc=None, parse_strict='raise'):\n1968 \n1969         # Short-circuit if we're already a unit\n1970         if hasattr(s, '_get_physical_type_id'):\n1971             return s\n1972 \n1973         # turn possible Quantity input for s or represents into a Unit\n1974         from .quantity import Quantity\n1975 \n1976         if isinstance(represents, Quantity):\n1977             if is_effectively_unity(represents.value):\n1978                 represents = represents.unit\n1979             else:\n1980                 represents = CompositeUnit(represents.value *\n1981                                            represents.unit.scale,\n1982                                            bases=represents.unit.bases,\n1983                                            powers=represents.unit.powers,\n1984                                            _error_check=False)\n1985 \n1986         if isinstance(s, Quantity):\n1987             if is_effectively_unity(s.value):\n1988                 s = s.unit\n1989             else:\n1990                 s = CompositeUnit(s.value * s.unit.scale,\n1991                                   bases=s.unit.bases,\n1992                                   powers=s.unit.powers,\n1993                                   _error_check=False)\n1994 \n1995         # now decide what we really need to do; define derived Unit?\n1996         if isinstance(represents, UnitBase):\n1997             # This has the effect of calling the real __new__ and\n1998             # __init__ on the Unit class.\n1999             return super().__call__(\n2000                 s, represents, format=format, namespace=namespace, doc=doc)\n2001 \n2002         # or interpret a Quantity (now became unit), string or number?\n2003         if isinstance(s, UnitBase):\n2004             return s\n2005 \n2006         elif isinstance(s, (bytes, str)):\n2007             if len(s.strip()) == 0:\n2008                 # Return the NULL unit\n2009                 return dimensionless_unscaled\n2010 \n2011             if format is None:\n2012                 format = unit_format.Generic\n2013 \n2014             f = unit_format.get_format(format)\n2015             if isinstance(s, bytes):\n2016                 s = s.decode('ascii')\n2017 \n2018             try:\n2019                 return f.parse(s)\n2020             except NotImplementedError:\n2021                 raise\n2022             except Exception as e:\n2023                 if parse_strict == 'silent':\n2024                     pass\n2025                 else:\n2026                     # Deliberately not issubclass here. Subclasses\n2027                     # should use their name.\n2028                     if f is not unit_format.Generic:\n2029                         format_clause = f.name + ' '\n2030                     else:\n2031                         format_clause = ''\n2032                     msg = (\"'{}' did not parse as {}unit: {} \"\n2033                            \"If this is meant to be a custom unit, \"\n2034                            \"define it with 'u.def_unit'. To have it \"\n2035                            \"recognized inside a file reader or other code, \"\n2036                            \"enable it with 'u.add_enabled_units'. \"\n2037                            \"For details, see \"\n2038                            \"https://docs.astropy.org/en/latest/units/combining_and_defining.html\"\n2039                            .format(s, format_clause, str(e)))\n2040                     if parse_strict == 'raise':\n2041                         raise ValueError(msg)\n2042                     elif parse_strict == 'warn':\n2043                         warnings.warn(msg, UnitsWarning)\n2044                     else:\n2045                         raise ValueError(\"'parse_strict' must be 'warn', \"\n2046                                          \"'raise' or 'silent'\")\n2047                 return UnrecognizedUnit(s)\n2048 \n2049         elif isinstance(s, (int, float, np.floating, np.integer)):\n2050             return CompositeUnit(s, [], [], _error_check=False)\n2051 \n2052         elif isinstance(s, tuple):\n2053             from .structured import StructuredUnit\n2054             return StructuredUnit(s)\n2055 \n2056         elif s is None:\n2057             raise TypeError(\"None is not a valid Unit\")\n2058 \n2059         else:\n2060             raise TypeError(f\"{s} can not be converted to a Unit\")\n2061 \n2062 \n2063 class Unit(NamedUnit, metaclass=_UnitMetaClass):\n2064     \"\"\"\n2065     The main unit class.\n2066 \n2067     There are a number of different ways to construct a Unit, but\n2068     always returns a `UnitBase` instance.  If the arguments refer to\n2069     an already-existing unit, that existing unit instance is returned,\n2070     rather than a new one.\n2071 \n2072     - From a string::\n2073 \n2074         Unit(s, format=None, parse_strict='silent')\n2075 \n2076       Construct from a string representing a (possibly compound) unit.\n2077 \n2078       The optional `format` keyword argument specifies the format the\n2079       string is in, by default ``\"generic\"``.  For a description of\n2080       the available formats, see `astropy.units.format`.\n2081 \n2082       The optional ``parse_strict`` keyword controls what happens when an\n2083       unrecognized unit string is passed in.  It may be one of the following:\n2084 \n2085          - ``'raise'``: (default) raise a ValueError exception.\n2086 \n2087          - ``'warn'``: emit a Warning, and return an\n2088            `UnrecognizedUnit` instance.\n2089 \n2090          - ``'silent'``: return an `UnrecognizedUnit` instance.\n2091 \n2092     - From a number::\n2093 \n2094         Unit(number)\n2095 \n2096       Creates a dimensionless unit.\n2097 \n2098     - From a `UnitBase` instance::\n2099 \n2100         Unit(unit)\n2101 \n2102       Returns the given unit unchanged.\n2103 \n2104     - From no arguments::\n2105 \n2106         Unit()\n2107 \n2108       Returns the dimensionless unit.\n2109 \n2110     - The last form, which creates a new `Unit` is described in detail\n2111       below.\n2112 \n2113     See also: https://docs.astropy.org/en/stable/units/\n2114 \n2115     Parameters\n2116     ----------\n2117     st : str or list of str\n2118         The name of the unit.  If a list, the first element is the\n2119         canonical (short) name, and the rest of the elements are\n2120         aliases.\n2121 \n2122     represents : UnitBase instance\n2123         The unit that this named unit represents.\n2124 \n2125     doc : str, optional\n2126         A docstring describing the unit.\n2127 \n2128     format : dict, optional\n2129         A mapping to format-specific representations of this unit.\n2130         For example, for the ``Ohm`` unit, it might be nice to have it\n2131         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n2132         case, `format` argument should be set to::\n2133 \n2134             {'latex': r'\\\\Omega'}\n2135 \n2136     namespace : dict, optional\n2137         When provided, inject the unit (and all of its aliases) into\n2138         the given namespace.\n2139 \n2140     Raises\n2141     ------\n2142     ValueError\n2143         If any of the given unit names are already in the registry.\n2144 \n2145     ValueError\n2146         If any of the given unit names are not valid Python tokens.\n2147     \"\"\"\n2148 \n2149     def __init__(self, st, represents=None, doc=None,\n2150                  format=None, namespace=None):\n2151 \n2152         represents = Unit(represents)\n2153         self._represents = represents\n2154 \n2155         NamedUnit.__init__(self, st, namespace=namespace, doc=doc,\n2156                            format=format)\n2157 \n2158     @property\n2159     def represents(self):\n2160         \"\"\"The unit that this named unit represents.\"\"\"\n2161         return self._represents\n2162 \n2163     def decompose(self, bases=set()):\n2164         return self._represents.decompose(bases=bases)\n2165 \n2166     def is_unity(self):\n2167         return self._represents.is_unity()\n2168 \n2169     def __hash__(self):\n2170         if self._hash is None:\n2171             self._hash = hash((self.name, self._represents))\n2172         return self._hash\n2173 \n2174     @classmethod\n2175     def _from_physical_type_id(cls, physical_type_id):\n2176         # get string bases and powers from the ID tuple\n2177         bases = [cls(base) for base, _ in physical_type_id]\n2178         powers = [power for _, power in physical_type_id]\n2179 \n2180         if len(physical_type_id) == 1 and powers[0] == 1:\n2181             unit = bases[0]\n2182         else:\n2183             unit = CompositeUnit(1, bases, powers,\n2184                                  _error_check=False)\n2185 \n2186         return unit\n2187 \n2188 \n2189 class PrefixUnit(Unit):\n2190     \"\"\"\n2191     A unit that is simply a SI-prefixed version of another unit.\n2192 \n2193     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.\n2194 \n2195     The constructor is the same as for `Unit`.\n2196     \"\"\"\n2197 \n2198 \n2199 class CompositeUnit(UnitBase):\n2200     \"\"\"\n2201     Create a composite unit using expressions of previously defined\n2202     units.\n2203 \n2204     Direct use of this class is not recommended. Instead use the\n2205     factory function `Unit` and arithmetic operators to compose\n2206     units.\n2207 \n2208     Parameters\n2209     ----------\n2210     scale : number\n2211         A scaling factor for the unit.\n2212 \n2213     bases : sequence of `UnitBase`\n2214         A sequence of units this unit is composed of.\n2215 \n2216     powers : sequence of numbers\n2217         A sequence of powers (in parallel with ``bases``) for each\n2218         of the base units.\n2219     \"\"\"\n2220     _decomposed_cache = None\n2221 \n2222     def __init__(self, scale, bases, powers, decompose=False,\n2223                  decompose_bases=set(), _error_check=True):\n2224         # There are many cases internal to astropy.units where we\n2225         # already know that all the bases are Unit objects, and the\n2226         # powers have been validated.  In those cases, we can skip the\n2227         # error checking for performance reasons.  When the private\n2228         # kwarg `_error_check` is False, the error checking is turned\n2229         # off.\n2230         if _error_check:\n2231             for base in bases:\n2232                 if not isinstance(base, UnitBase):\n2233                     raise TypeError(\n2234                         \"bases must be sequence of UnitBase instances\")\n2235             powers = [validate_power(p) for p in powers]\n2236 \n2237         if not decompose and len(bases) == 1 and powers[0] >= 0:\n2238             # Short-cut; with one unit there's nothing to expand and gather,\n2239             # as that has happened already when creating the unit.  But do only\n2240             # positive powers, since for negative powers we need to re-sort.\n2241             unit = bases[0]\n2242             power = powers[0]\n2243             if power == 1:\n2244                 scale *= unit.scale\n2245                 self._bases = unit.bases\n2246                 self._powers = unit.powers\n2247             elif power == 0:\n2248                 self._bases = []\n2249                 self._powers = []\n2250             else:\n2251                 scale *= unit.scale ** power\n2252                 self._bases = unit.bases\n2253                 self._powers = [operator.mul(*resolve_fractions(p, power))\n2254                                 for p in unit.powers]\n2255 \n2256             self._scale = sanitize_scale(scale)\n2257         else:\n2258             # Regular case: use inputs as preliminary scale, bases, and powers,\n2259             # then \"expand and gather\" identical bases, sanitize the scale, &c.\n2260             self._scale = scale\n2261             self._bases = bases\n2262             self._powers = powers\n2263             self._expand_and_gather(decompose=decompose,\n2264                                     bases=decompose_bases)\n2265 \n2266     def __repr__(self):\n2267         if len(self._bases):\n2268             return super().__repr__()\n2269         else:\n2270             if self._scale != 1.0:\n2271                 return f'Unit(dimensionless with a scale of {self._scale})'\n2272             else:\n2273                 return 'Unit(dimensionless)'\n2274 \n2275     @property\n2276     def scale(self):\n2277         \"\"\"\n2278         Return the scale of the composite unit.\n2279         \"\"\"\n2280         return self._scale\n2281 \n2282     @property\n2283     def bases(self):\n2284         \"\"\"\n2285         Return the bases of the composite unit.\n2286         \"\"\"\n2287         return self._bases\n2288 \n2289     @property\n2290     def powers(self):\n2291         \"\"\"\n2292         Return the powers of the composite unit.\n2293         \"\"\"\n2294         return self._powers\n2295 \n2296     def _expand_and_gather(self, decompose=False, bases=set()):\n2297         def add_unit(unit, power, scale):\n2298             if bases and unit not in bases:\n2299                 for base in bases:\n2300                     try:\n2301                         scale *= unit._to(base) ** power\n2302                     except UnitsError:\n2303                         pass\n2304                     else:\n2305                         unit = base\n2306                         break\n2307 \n2308             if unit in new_parts:\n2309                 a, b = resolve_fractions(new_parts[unit], power)\n2310                 new_parts[unit] = a + b\n2311             else:\n2312                 new_parts[unit] = power\n2313             return scale\n2314 \n2315         new_parts = {}\n2316         scale = self._scale\n2317 \n2318         for b, p in zip(self._bases, self._powers):\n2319             if decompose and b not in bases:\n2320                 b = b.decompose(bases=bases)\n2321 \n2322             if isinstance(b, CompositeUnit):\n2323                 scale *= b._scale ** p\n2324                 for b_sub, p_sub in zip(b._bases, b._powers):\n2325                     a, b = resolve_fractions(p_sub, p)\n2326                     scale = add_unit(b_sub, a * b, scale)\n2327             else:\n2328                 scale = add_unit(b, p, scale)\n2329 \n2330         new_parts = [x for x in new_parts.items() if x[1] != 0]\n2331         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))\n2332 \n2333         self._bases = [x[0] for x in new_parts]\n2334         self._powers = [x[1] for x in new_parts]\n2335         self._scale = sanitize_scale(scale)\n2336 \n2337     def __copy__(self):\n2338         \"\"\"\n2339         For compatibility with python copy module.\n2340         \"\"\"\n2341         return CompositeUnit(self._scale, self._bases[:], self._powers[:])\n2342 \n2343     def decompose(self, bases=set()):\n2344         if len(bases) == 0 and self._decomposed_cache is not None:\n2345             return self._decomposed_cache\n2346 \n2347         for base in self.bases:\n2348             if (not isinstance(base, IrreducibleUnit) or\n2349                     (len(bases) and base not in bases)):\n2350                 break\n2351         else:\n2352             if len(bases) == 0:\n2353                 self._decomposed_cache = self\n2354             return self\n2355 \n2356         x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True,\n2357                           decompose_bases=bases)\n2358         if len(bases) == 0:\n2359             self._decomposed_cache = x\n2360         return x\n2361 \n2362     def is_unity(self):\n2363         unit = self.decompose()\n2364         return len(unit.bases) == 0 and unit.scale == 1.0\n2365 \n2366 \n2367 si_prefixes = [\n2368     (['Y'], ['yotta'], 1e24),\n2369     (['Z'], ['zetta'], 1e21),\n2370     (['E'], ['exa'], 1e18),\n2371     (['P'], ['peta'], 1e15),\n2372     (['T'], ['tera'], 1e12),\n2373     (['G'], ['giga'], 1e9),\n2374     (['M'], ['mega'], 1e6),\n2375     (['k'], ['kilo'], 1e3),\n2376     (['h'], ['hecto'], 1e2),\n2377     (['da'], ['deka', 'deca'], 1e1),\n2378     (['d'], ['deci'], 1e-1),\n2379     (['c'], ['centi'], 1e-2),\n2380     (['m'], ['milli'], 1e-3),\n2381     (['u'], ['micro'], 1e-6),\n2382     (['n'], ['nano'], 1e-9),\n2383     (['p'], ['pico'], 1e-12),\n2384     (['f'], ['femto'], 1e-15),\n2385     (['a'], ['atto'], 1e-18),\n2386     (['z'], ['zepto'], 1e-21),\n2387     (['y'], ['yocto'], 1e-24)\n2388 ]\n2389 \n2390 \n2391 binary_prefixes = [\n2392     (['Ki'], ['kibi'], 2. ** 10),\n2393     (['Mi'], ['mebi'], 2. ** 20),\n2394     (['Gi'], ['gibi'], 2. ** 30),\n2395     (['Ti'], ['tebi'], 2. ** 40),\n2396     (['Pi'], ['pebi'], 2. ** 50),\n2397     (['Ei'], ['exbi'], 2. ** 60)\n2398 ]\n2399 \n2400 \n2401 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):\n2402     \"\"\"\n2403     Set up all of the standard metric prefixes for a unit.  This\n2404     function should not be used directly, but instead use the\n2405     `prefixes` kwarg on `def_unit`.\n2406 \n2407     Parameters\n2408     ----------\n2409     excludes : list of str, optional\n2410         Any prefixes to exclude from creation to avoid namespace\n2411         collisions.\n2412 \n2413     namespace : dict, optional\n2414         When provided, inject the unit (and all of its aliases) into\n2415         the given namespace dictionary.\n2416 \n2417     prefixes : list, optional\n2418         When provided, it is a list of prefix definitions of the form:\n2419 \n2420             (short_names, long_tables, factor)\n2421     \"\"\"\n2422     if prefixes is True:\n2423         prefixes = si_prefixes\n2424     elif prefixes is False:\n2425         prefixes = []\n2426 \n2427     for short, full, factor in prefixes:\n2428         names = []\n2429         format = {}\n2430         for prefix in short:\n2431             if prefix in excludes:\n2432                 continue\n2433 \n2434             for alias in u.short_names:\n2435                 names.append(prefix + alias)\n2436 \n2437                 # This is a hack to use Greek mu as a prefix\n2438                 # for some formatters.\n2439                 if prefix == 'u':\n2440                     format['latex'] = r'\\mu ' + u.get_format_name('latex')\n2441                     format['unicode'] = '\\N{MICRO SIGN}' + u.get_format_name('unicode')\n2442 \n2443                 for key, val in u._format.items():\n2444                     format.setdefault(key, prefix + val)\n2445 \n2446         for prefix in full:\n2447             if prefix in excludes:\n2448                 continue\n2449 \n2450             for alias in u.long_names:\n2451                 names.append(prefix + alias)\n2452 \n2453         if len(names):\n2454             PrefixUnit(names, CompositeUnit(factor, [u], [1],\n2455                                             _error_check=False),\n2456                        namespace=namespace, format=format)\n2457 \n2458 \n2459 def def_unit(s, represents=None, doc=None, format=None, prefixes=False,\n2460              exclude_prefixes=[], namespace=None):\n2461     \"\"\"\n2462     Factory function for defining new units.\n2463 \n2464     Parameters\n2465     ----------\n2466     s : str or list of str\n2467         The name of the unit.  If a list, the first element is the\n2468         canonical (short) name, and the rest of the elements are\n2469         aliases.\n2470 \n2471     represents : UnitBase instance, optional\n2472         The unit that this named unit represents.  If not provided,\n2473         a new `IrreducibleUnit` is created.\n2474 \n2475     doc : str, optional\n2476         A docstring describing the unit.\n2477 \n2478     format : dict, optional\n2479         A mapping to format-specific representations of this unit.\n2480         For example, for the ``Ohm`` unit, it might be nice to\n2481         have it displayed as ``\\\\Omega`` by the ``latex``\n2482         formatter.  In that case, `format` argument should be set\n2483         to::\n2484 \n2485             {'latex': r'\\\\Omega'}\n2486 \n2487     prefixes : bool or list, optional\n2488         When `True`, generate all of the SI prefixed versions of the\n2489         unit as well.  For example, for a given unit ``m``, will\n2490         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of\n2491         prefix definitions of the form:\n2492 \n2493             (short_names, long_tables, factor)\n2494 \n2495         Default is `False`.  This function always returns the base\n2496         unit object, even if multiple scaled versions of the unit were\n2497         created.\n2498 \n2499     exclude_prefixes : list of str, optional\n2500         If any of the SI prefixes need to be excluded, they may be\n2501         listed here.  For example, ``Pa`` can be interpreted either as\n2502         \"petaannum\" or \"Pascal\".  Therefore, when defining the\n2503         prefixes for ``a``, ``exclude_prefixes`` should be set to\n2504         ``[\"P\"]``.\n2505 \n2506     namespace : dict, optional\n2507         When provided, inject the unit (and all of its aliases and\n2508         prefixes), into the given namespace dictionary.\n2509 \n2510     Returns\n2511     -------\n2512     unit : `~astropy.units.UnitBase`\n2513         The newly-defined unit, or a matching unit that was already\n2514         defined.\n2515     \"\"\"\n2516 \n2517     if represents is not None:\n2518         result = Unit(s, represents, namespace=namespace, doc=doc,\n2519                       format=format)\n2520     else:\n2521         result = IrreducibleUnit(\n2522             s, namespace=namespace, doc=doc, format=format)\n2523 \n2524     if prefixes:\n2525         _add_prefixes(result, excludes=exclude_prefixes, namespace=namespace,\n2526                       prefixes=prefixes)\n2527     return result\n2528 \n2529 \n2530 def _condition_arg(value):\n2531     \"\"\"\n2532     Validate value is acceptable for conversion purposes.\n2533 \n2534     Will convert into an array if not a scalar, and can be converted\n2535     into an array\n2536 \n2537     Parameters\n2538     ----------\n2539     value : int or float value, or sequence of such values\n2540 \n2541     Returns\n2542     -------\n2543     Scalar value or numpy array\n2544 \n2545     Raises\n2546     ------\n2547     ValueError\n2548         If value is not as expected\n2549     \"\"\"\n2550     if isinstance(value, (np.ndarray, float, int, complex, np.void)):\n2551         return value\n2552 \n2553     avalue = np.array(value)\n2554     if avalue.dtype.kind not in ['i', 'f', 'c']:\n2555         raise ValueError(\"Value not scalar compatible or convertible to \"\n2556                          \"an int, float, or complex array\")\n2557     return avalue\n2558 \n2559 \n2560 def unit_scale_converter(val):\n2561     \"\"\"Function that just multiplies the value by unity.\n2562 \n2563     This is a separate function so it can be recognized and\n2564     discarded in unit conversion.\n2565     \"\"\"\n2566     return 1. * _condition_arg(val)\n2567 \n2568 \n2569 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)\n2570 # Abbreviation of the above, see #1980\n2571 one = dimensionless_unscaled\n2572 \n2573 # Maintain error in old location for backward compatibility\n2574 # TODO: Is this still needed? Should there be a deprecation warning?\n2575 unit_format.fits.UnitScaleError = UnitScaleError\n",
        "intended_behavior": "Although not directly a bug, enhancing the use of 'def_unit' or a similar mechanism within cosmology parameters to specify their MathJax representation is required. This enhancement means improving or leveraging the 'format' attribute in cosmology parameters, ensuring that when these parameters are converted into HTML table entries, their MathJax representation is used."
    }
]