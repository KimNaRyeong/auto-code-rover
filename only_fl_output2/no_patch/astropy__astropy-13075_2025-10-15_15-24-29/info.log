2025-10-15 15:24:29.568 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:24:34.100 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=302, output_tokens=12, cost=0.003380
2025-10-15 15:24:34.101 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 15:24:34.104 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:24:44.097 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=610, output_tokens=329, cost=0.015970
2025-10-15 15:24:44.106 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:24:47.249 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=683, output_tokens=76, cost=0.009110
2025-10-15 15:24:47.250 | DEBUG    | Extracted a valid json.
2025-10-15 15:24:47.250 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Cosmology\")",
        "search_method_in_class(\"write\", \"Cosmology\")",
        "search_method(\"to_table\")",
        "search_method(\"write\")",
        "search_class(\"QTable\")",
        "search_method(\"def_unit\")"
    ],
    "bug_locations": []
}
2025-10-15 15:24:47.313 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:24:47.314 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:25:14.175 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2721, output_tokens=942, cost=0.055470
2025-10-15 15:25:14.195 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:25:26.481 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3879, output_tokens=459, cost=0.052560
2025-10-15 15:25:26.491 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:25:38.831 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=813, output_tokens=391, cost=0.019860
2025-10-15 15:25:38.833 | DEBUG    | Extracted a valid json.
2025-10-15 15:25:38.833 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/cosmology/core.py",
            "class": "Cosmology",
            "method": "",
            "intended_behavior": "Implement a new method, 'write_html', within the 'Cosmology' class. This method should leverage the 'to_table' method to convert the cosmology instance into a tabular format suitable for HTML representation. Then, format this table using MathJax for any relevant cosmological parameters with the assistance of a new feature or extension utilizing 'QTable.write(..., format='html')'. The new method should smoothly integrate with existing IO capabilities, meaning it should use or extend the existing framework ('UnifiedReadWriteMethod') to support the HTML format, ensuring consistency with how other formats are handled."
        },
        {
            "file": "astropy/cosmology/io/table.py",
            "class": "",
            "method": "to_table",
            "intended_behavior": "Enhance the 'to_table' method (or create a helper function specifically for HTML output) to ensure it includes additional formatting details necessary for HTML representation, especially focusing on providing support for MathJax formatting. This may involve attaching metadata or custom formatting instructions to table columns based on cosmology parameters, utilizing the approach similar to 'def_unit' for specifying MathJax representations."
        },
        {
            "file": "astropy/units/core.py",
            "class": "",
            "method": "",
            "intended_behavior": "Although not directly a bug, enhancing the use of 'def_unit' or a similar mechanism within cosmology parameters to specify their MathJax representation is required. This enhancement means improving or leveraging the 'format' attribute in cosmology parameters, ensuring that when these parameters are converted into HTML table entries, their MathJax representation is used."
        }
    ]
}
2025-10-15 15:25:38.847 | DEBUG    | Bug location extracted successfully: [<file>astropy/cosmology/core.py</file>
<class>Cosmology</class>
<method>None</method>
<code>
50 class Cosmology(metaclass=abc.ABCMeta):
51     """Base-class for all Cosmologies.
52 
53     Parameters
54     ----------
55     *args
56         Arguments into the cosmology; used by subclasses, not this base class.
57     name : str or None (optional, keyword-only)
58         The name of the cosmology.
59     meta : dict or None (optional, keyword-only)
60         Metadata for the cosmology, e.g., a reference.
61     **kwargs
62         Arguments into the cosmology; used by subclasses, not this base class.
63 
64     Notes
65     -----
66     Class instances are static -- you cannot (and should not) change the values
67     of the parameters.  That is, all of the above attributes (except meta) are
68     read only.
69 
70     For details on how to create performant custom subclasses, see the
71     documentation on :ref:`astropy-cosmology-fast-integrals`.
72     """
73 
74     meta = MetaData()
75 
76     # Unified I/O object interchange methods
77     from_format = UnifiedReadWriteMethod(CosmologyFromFormat)
78     to_format = UnifiedReadWriteMethod(CosmologyToFormat)
79 
80     # Unified I/O read and write methods
81     read = UnifiedReadWriteMethod(CosmologyRead)
82     write = UnifiedReadWriteMethod(CosmologyWrite)
83 
84     # Parameters
85     __parameters__: tuple[str, ...] = ()
86     __all_parameters__: tuple[str, ...] = ()
87 
88     # ---------------------------------------------------------------
89 
90     def __init_subclass__(cls):
91         super().__init_subclass__()
92 
93         # -------------------
94         # Parameters
95 
96         # Get parameters that are still Parameters, either in this class or above.
97         parameters = []
98         derived_parameters = []
99         for n in cls.__parameters__:
100             p = getattr(cls, n)
101             if isinstance(p, Parameter):
102                 derived_parameters.append(n) if p.derived else parameters.append(n)
103 
104         # Add new parameter definitions
105         for n, v in cls.__dict__.items():
106             if n in parameters or n.startswith("_") or not isinstance(v, Parameter):
107                 continue
108             derived_parameters.append(n) if v.derived else parameters.append(n)
109 
110         # reorder to match signature
111         ordered = [parameters.pop(parameters.index(n))
112                    for n in cls._init_signature.parameters.keys()
113                    if n in parameters]
114         parameters = ordered + parameters  # place "unordered" at the end
115         cls.__parameters__ = tuple(parameters)
116         cls.__all_parameters__ = cls.__parameters__ + tuple(derived_parameters)
117 
118         # -------------------
119         # register as a Cosmology subclass
120         _COSMOLOGY_CLASSES[cls.__qualname__] = cls
121 
122     @classproperty(lazy=True)
123     def _init_signature(cls):
124         """Initialization signature (without 'self')."""
125         # get signature, dropping "self" by taking arguments [1:]
126         sig = inspect.signature(cls.__init__)
127         sig = sig.replace(parameters=list(sig.parameters.values())[1:])
128         return sig
129 
130     # ---------------------------------------------------------------
131 
132     def __init__(self, name=None, meta=None):
133         self._name = str(name) if name is not None else name
134         self.meta.update(meta or {})
135 
136     @property
137     def name(self):
138         """The name of the Cosmology instance."""
139         return self._name
140 
141     @property
142     @abc.abstractmethod
143     def is_flat(self):
144         """
145         Return bool; `True` if the cosmology is flat.
146         This is abstract and must be defined in subclasses.
147         """
148         raise NotImplementedError("is_flat is not implemented")
149 
150     def clone(self, *, meta=None, **kwargs):
151         """Returns a copy of this object with updated parameters, as specified.
152 
153         This cannot be used to change the type of the cosmology, so ``clone()``
154         cannot be used to change between flat and non-flat cosmologies.
155 
156         Parameters
157         ----------
158         meta : mapping or None (optional, keyword-only)
159             Metadata that will update the current metadata.
160         **kwargs
161             Cosmology parameter (and name) modifications. If any parameter is
162             changed and a new name is not given, the name will be set to "[old
163             name] (modified)".
164 
165         Returns
166         -------
167         newcosmo : `~astropy.cosmology.Cosmology` subclass instance
168             A new instance of this class with updated parameters as specified.
169             If no arguments are given, then a reference to this object is
170             returned instead of copy.
171 
172         Examples
173         --------
174         To make a copy of the ``Planck13`` cosmology with a different matter
175         density (``Om0``), and a new name:
176 
177             >>> from astropy.cosmology import Planck13
178             >>> Planck13.clone(name="Modified Planck 2013", Om0=0.35)
179             FlatLambdaCDM(name="Modified Planck 2013", H0=67.77 km / (Mpc s),
180                           Om0=0.35, ...
181 
182         If no name is specified, the new name will note the modification.
183 
184             >>> Planck13.clone(Om0=0.35).name
185             'Planck13 (modified)'
186         """
187         # Quick return check, taking advantage of the Cosmology immutability.
188         if meta is None and not kwargs:
189             return self
190 
191         # There are changed parameter or metadata values.
192         # The name needs to be changed accordingly, if it wasn't already.
193         _modname = self.name + " (modified)"
194         kwargs.setdefault("name", (_modname if self.name is not None else None))
195 
196         # mix new meta into existing, preferring the former.
197         meta = meta if meta is not None else {}
198         new_meta = {**self.meta, **meta}
199         # Mix kwargs into initial arguments, preferring the former.
200         new_init = {**self._init_arguments, "meta": new_meta, **kwargs}
201         # Create BoundArgument to handle args versus kwargs.
202         # This also handles all errors from mismatched arguments
203         ba = self._init_signature.bind_partial(**new_init)
204         # Instantiate, respecting args vs kwargs
205         cloned = type(self)(*ba.args, **ba.kwargs)
206 
207         # Check if nothing has changed.
208         # TODO! or should return self?
209         if (cloned.name == _modname) and not meta and cloned.is_equivalent(self):
210             cloned._name = self.name
211 
212         return cloned
213 
214     @property
215     def _init_arguments(self):
216         # parameters
217         kw = {n: getattr(self, n) for n in self.__parameters__}
218 
219         # other info
220         kw["name"] = self.name
221         kw["meta"] = self.meta
222 
223         return kw
224 
225     # ---------------------------------------------------------------
226     # comparison methods
227 
228     def is_equivalent(self, other: Any, /, *, format: _FormatType = False) -> bool:
229         r"""Check equivalence between Cosmologies.
230 
231         Two cosmologies may be equivalent even if not the same class.
232         For example, an instance of ``LambdaCDM`` might have :math:`\Omega_0=1`
233         and :math:`\Omega_k=0` and therefore be flat, like ``FlatLambdaCDM``.
234 
235         Parameters
236         ----------
237         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
238             The object to which to compare.
239         format : bool or None or str, optional keyword-only
240             Whether to allow, before equivalence is checked, the object to be
241             converted to a |Cosmology|. This allows, e.g. a |Table| to be
242             equivalent to a Cosmology.
243             `False` (default) will not allow conversion. `True` or `None` will,
244             and will use the auto-identification to try to infer the correct
245             format. A `str` is assumed to be the correct format to use when
246             converting.
247             ``format`` is broadcast to match the shape of ``other``.
248             Note that the cosmology arguments are not broadcast against
249             ``format``, so it cannot determine the output shape.
250 
251         Returns
252         -------
253         bool
254             True if cosmologies are equivalent, False otherwise.
255 
256         Examples
257         --------
258         Two cosmologies may be equivalent even if not of the same class.
259         In this examples the ``LambdaCDM`` has ``Ode0`` set to the same value
260         calculated in ``FlatLambdaCDM``.
261 
262             >>> import astropy.units as u
263             >>> from astropy.cosmology import LambdaCDM, FlatLambdaCDM
264             >>> cosmo1 = LambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, 0.7)
265             >>> cosmo2 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3)
266             >>> cosmo1.is_equivalent(cosmo2)
267             True
268 
269         While in this example, the cosmologies are not equivalent.
270 
271             >>> cosmo3 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, Tcmb0=3 * u.K)
272             >>> cosmo3.is_equivalent(cosmo2)
273             False
274 
275         Also, using the keyword argument, the notion of equivalence is extended
276         to any Python object that can be converted to a |Cosmology|.
277 
278             >>> from astropy.cosmology import Planck18
279             >>> tbl = Planck18.to_format("astropy.table")
280             >>> Planck18.is_equivalent(tbl, format=True)
281             True
282 
283         The list of valid formats, e.g. the |Table| in this example, may be
284         checked with ``Cosmology.from_format.list_formats()``.
285 
286         As can be seen in the list of formats, not all formats can be
287         auto-identified by ``Cosmology.from_format.registry``. Objects of
288         these kinds can still be checked for equivalence, but the correct
289         format string must be used.
290 
291             >>> tbl = Planck18.to_format("yaml")
292             >>> Planck18.is_equivalent(tbl, format="yaml")
293             True
294         """
295         from .funcs import cosmology_equal
296 
297         try:
298             return cosmology_equal(self, other, format=(None, format), allow_equivalent=True)
299         except Exception:
300             # `is_equivalent` allows `other` to be any object and returns False
301             # if `other` cannot be converted to a Cosmology, rather than
302             # raising an Exception.
303             return False
304 
305     def __equiv__(self, other: Any, /) -> bool:
306         """Cosmology equivalence. Use ``.is_equivalent()`` for actual check!
307 
308         Parameters
309         ----------
310         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
311             The object in which to compare.
312 
313         Returns
314         -------
315         bool or `NotImplemented`
316             `NotImplemented` if ``other`` is from a different class.
317             `True` if ``other`` is of the same class and has matching parameters
318             and parameter values.
319             `False` otherwise.
320         """
321         if other.__class__ is not self.__class__:
322             return NotImplemented  # allows other.__equiv__
323 
324         # Check all parameters in 'other' match those in 'self' and 'other' has
325         # no extra parameters (latter part should never happen b/c same class)
326         params_eq = (set(self.__all_parameters__) == set(other.__all_parameters__)
327                      and all(np.all(getattr(self, k) == getattr(other, k))
328                              for k in self.__all_parameters__))
329         return params_eq
330 
331     def __eq__(self, other: Any, /) -> bool:
332         """Check equality between Cosmologies.
333 
334         Checks the Parameters and immutable fields (i.e. not "meta").
335 
336         Parameters
337         ----------
338         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
339             The object in which to compare.
340 
341         Returns
342         -------
343         bool
344             `True` if Parameters and names are the same, `False` otherwise.
345         """
346         if other.__class__ is not self.__class__:
347             return NotImplemented  # allows other.__eq__
348 
349         eq = (
350             # non-Parameter checks: name
351             self.name == other.name
352             # check all parameters in 'other' match those in 'self' and 'other'
353             # has no extra parameters (latter part should never happen b/c same
354             # class) TODO! element-wise when there are array cosmologies
355             and set(self.__all_parameters__) == set(other.__all_parameters__)
356             and all(np.all(getattr(self, k) == getattr(other, k))
357                     for k in self.__all_parameters__)
358         )
359 
360         return eq
361 
362     # ---------------------------------------------------------------
363 
364     def __repr__(self):
365         namelead = f"{self.__class__.__qualname__}("
366         if self.name is not None:
367             namelead += f"name=\"{self.name}\", "
368         # nicely formatted parameters
369         fmtps = (f'{k}={getattr(self, k)}' for k in self.__parameters__)
370 
371         return namelead + ", ".join(fmtps) + ")"
372 
373     def __astropy_table__(self, cls, copy, **kwargs):
374         """Return a `~astropy.table.Table` of type ``cls``.
375 
376         Parameters
377         ----------
378         cls : type
379             Astropy ``Table`` class or subclass.
380         copy : bool
381             Ignored.
382         **kwargs : dict, optional
383             Additional keyword arguments. Passed to ``self.to_format()``.
384             See ``Cosmology.to_format.help("astropy.table")`` for allowed kwargs.
385 
386         Returns
387         -------
388         `astropy.table.Table` or subclass instance
389             Instance of type ``cls``.
390         """
391         return self.to_format("astropy.table", cls=cls, **kwargs)

</code><intended_behavior>Implement a new method, 'write_html', within the 'Cosmology' class. This method should leverage the 'to_table' method to convert the cosmology instance into a tabular format suitable for HTML representation. Then, format this table using MathJax for any relevant cosmological parameters with the assistance of a new feature or extension utilizing 'QTable.write(..., format='html')'. The new method should smoothly integrate with existing IO capabilities, meaning it should use or extend the existing framework ('UnifiedReadWriteMethod') to support the HTML format, ensuring consistency with how other formats are handled.</intended_behavior>, <file>astropy/cosmology/io/table.py</file>
<class>None</class>
<method>to_table</method>
<code>
139 def to_table(cosmology, *args, cls=QTable, cosmology_in_meta=True):
140     """Serialize the cosmology into a `~astropy.table.QTable`.
141 
142     Parameters
143     ----------
144     cosmology : `~astropy.cosmology.Cosmology` subclass instance
145     *args
146         Not used. Needed for compatibility with
147         `~astropy.io.registry.UnifiedReadWriteMethod`
148     cls : type (optional, keyword-only)
149         Astropy :class:`~astropy.table.Table` class or subclass type to return.
150         Default is :class:`~astropy.table.QTable`.
151     cosmology_in_meta : bool
152         Whether to put the cosmology class in the Table metadata (if `True`,
153         default) or as the first column (if `False`).
154 
155     Returns
156     -------
157     `~astropy.table.QTable`
158         With columns for the cosmology parameters, and metadata and
159         cosmology class name in the Table's ``meta`` attribute
160 
161     Raises
162     ------
163     TypeError
164         If kwarg (optional) 'cls' is not a subclass of `astropy.table.Table`
165 
166     Examples
167     --------
168     A Cosmology as a `~astropy.table.QTable` will have the cosmology's name and
169     parameters as columns.
170 
171         >>> from astropy.cosmology import Planck18
172         >>> ct = Planck18.to_format("astropy.table")
173         >>> ct
174         <QTable length=1>
175           name        H0        Om0    Tcmb0    Neff      m_nu      Ob0
176                  km / (Mpc s)            K                 eV
177           str8     float64    float64 float64 float64  float64[3] float64
178         -------- ------------ ------- ------- ------- ----------- -------
179         Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897
180 
181     The cosmological class and other metadata, e.g. a paper reference, are in
182     the Table's metadata.
183 
184         >>> ct.meta
185         OrderedDict([..., ('cosmology', 'FlatLambdaCDM')])
186 
187     To move the cosmology class from the metadata to a Table row, set the
188     ``cosmology_in_meta`` argument to `False`:
189 
190         >>> Planck18.to_format("astropy.table", cosmology_in_meta=False)
191         <QTable length=1>
192           cosmology     name        H0        Om0    Tcmb0    Neff      m_nu      Ob0
193                                km / (Mpc s)            K                 eV
194             str13       str8     float64    float64 float64 float64  float64[3] float64
195         ------------- -------- ------------ ------- ------- ------- ----------- -------
196         FlatLambdaCDM Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897
197 
198     Astropy recommends `~astropy.table.QTable` for tables with
199     `~astropy.units.Quantity` columns. However the returned type may be
200     overridden using the ``cls`` argument:
201 
202         >>> from astropy.table import Table
203         >>> Planck18.to_format("astropy.table", cls=Table)
204         <Table length=1>
205         ...
206     """
207     if not issubclass(cls, Table):
208         raise TypeError(f"'cls' must be a (sub)class of Table, not {type(cls)}")
209 
210     # Start by getting a map representation.
211     data = to_mapping(cosmology)
212     data["cosmology"] = data["cosmology"].__qualname__  # change to str
213 
214     # Metadata
215     meta = data.pop("meta")  # remove the meta
216     if cosmology_in_meta:
217         meta["cosmology"] = data.pop("cosmology")
218 
219     # Need to turn everything into something Table can process:
220     # - Column for Parameter
221     # - list for anything else
222     cosmo_cls = cosmology.__class__
223     for k, v in data.items():
224         if k in cosmology.__parameters__:
225             col = convert_parameter_to_column(getattr(cosmo_cls, k), v,
226                                               cosmology.meta.get(k))
227         else:
228             col = Column([v])
229         data[k] = col
230 
231     tbl = cls(data, meta=meta)
232     tbl.add_index("name", unique=True)
233     return tbl

</code><intended_behavior>Enhance the 'to_table' method (or create a helper function specifically for HTML output) to ensure it includes additional formatting details necessary for HTML representation, especially focusing on providing support for MathJax formatting. This may involve attaching metadata or custom formatting instructions to table columns based on cosmology parameters, utilizing the approach similar to 'def_unit' for specifying MathJax representations.</intended_behavior>, <file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import is_effectively_unity, resolve_fractions, sanitize_scale, validate_power
21 
22 __all__ = [
23     'UnitsError', 'UnitsWarning', 'UnitConversionError', 'UnitTypeError',
24     'UnitBase', 'NamedUnit', 'IrreducibleUnit', 'Unit', 'CompositeUnit',
25     'PrefixUnit', 'UnrecognizedUnit', 'def_unit', 'get_current_unit_registry',
26     'set_enabled_units', 'add_enabled_units',
27     'set_enabled_equivalencies', 'add_enabled_equivalencies',
28     'set_enabled_aliases', 'add_enabled_aliases',
29     'dimensionless_unscaled', 'one',
30 ]
31 
32 UNITY = 1.0
33 
34 
35 def _flatten_units_collection(items):
36     """
37     Given a list of sequences, modules or dictionaries of units, or
38     single units, return a flat set of all the units found.
39     """
40     if not isinstance(items, list):
41         items = [items]
42 
43     result = set()
44     for item in items:
45         if isinstance(item, UnitBase):
46             result.add(item)
47         else:
48             if isinstance(item, dict):
49                 units = item.values()
50             elif inspect.ismodule(item):
51                 units = vars(item).values()
52             elif isiterable(item):
53                 units = item
54             else:
55                 continue
56 
57             for unit in units:
58                 if isinstance(unit, UnitBase):
59                     result.add(unit)
60 
61     return result
62 
63 
64 def _normalize_equivalencies(equivalencies):
65     """
66     Normalizes equivalencies, ensuring each is a 4-tuple of the form::
67 
68     (from_unit, to_unit, forward_func, backward_func)
69 
70     Parameters
71     ----------
72     equivalencies : list of equivalency pairs
73 
74     Raises
75     ------
76     ValueError if an equivalency cannot be interpreted
77     """
78     if equivalencies is None:
79         return []
80 
81     normalized = []
82 
83     for i, equiv in enumerate(equivalencies):
84         if len(equiv) == 2:
85             funit, tunit = equiv
86             a = b = lambda x: x
87         elif len(equiv) == 3:
88             funit, tunit, a = equiv
89             b = a
90         elif len(equiv) == 4:
91             funit, tunit, a, b = equiv
92         else:
93             raise ValueError(
94                 f"Invalid equivalence entry {i}: {equiv!r}")
95         if not (funit is Unit(funit) and
96                 (tunit is None or tunit is Unit(tunit)) and
97                 callable(a) and
98                 callable(b)):
99             raise ValueError(
100                 f"Invalid equivalence entry {i}: {equiv!r}")
101         normalized.append((funit, tunit, a, b))
102 
103     return normalized
104 
105 
106 class _UnitRegistry:
107     """
108     Manages a registry of the enabled units.
109     """
110 
111     def __init__(self, init=[], equivalencies=[], aliases={}):
112 
113         if isinstance(init, _UnitRegistry):
114             # If passed another registry we don't need to rebuild everything.
115             # but because these are mutable types we don't want to create
116             # conflicts so everything needs to be copied.
117             self._equivalencies = init._equivalencies.copy()
118             self._aliases = init._aliases.copy()
119             self._all_units = init._all_units.copy()
120             self._registry = init._registry.copy()
121             self._non_prefix_units = init._non_prefix_units.copy()
122             # The physical type is a dictionary containing sets as values.
123             # All of these must be copied otherwise we could alter the old
124             # registry.
125             self._by_physical_type = {k: v.copy() for k, v in
126                                       init._by_physical_type.items()}
127 
128         else:
129             self._reset_units()
130             self._reset_equivalencies()
131             self._reset_aliases()
132             self.add_enabled_units(init)
133             self.add_enabled_equivalencies(equivalencies)
134             self.add_enabled_aliases(aliases)
135 
136     def _reset_units(self):
137         self._all_units = set()
138         self._non_prefix_units = set()
139         self._registry = {}
140         self._by_physical_type = {}
141 
142     def _reset_equivalencies(self):
143         self._equivalencies = set()
144 
145     def _reset_aliases(self):
146         self._aliases = {}
147 
148     @property
149     def registry(self):
150         return self._registry
151 
152     @property
153     def all_units(self):
154         return self._all_units
155 
156     @property
157     def non_prefix_units(self):
158         return self._non_prefix_units
159 
160     def set_enabled_units(self, units):
161         """
162         Sets the units enabled in the unit registry.
163 
164         These units are searched when using
165         `UnitBase.find_equivalent_units`, for example.
166 
167         Parameters
168         ----------
169         units : list of sequence, dict, or module
170             This is a list of things in which units may be found
171             (sequences, dicts or modules), or units themselves.  The
172             entire set will be "enabled" for searching through by
173             methods like `UnitBase.find_equivalent_units` and
174             `UnitBase.compose`.
175         """
176         self._reset_units()
177         return self.add_enabled_units(units)
178 
179     def add_enabled_units(self, units):
180         """
181         Adds to the set of units enabled in the unit registry.
182 
183         These units are searched when using
184         `UnitBase.find_equivalent_units`, for example.
185 
186         Parameters
187         ----------
188         units : list of sequence, dict, or module
189             This is a list of things in which units may be found
190             (sequences, dicts or modules), or units themselves.  The
191             entire set will be added to the "enabled" set for
192             searching through by methods like
193             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
194         """
195         units = _flatten_units_collection(units)
196 
197         for unit in units:
198             # Loop through all of the names first, to ensure all of them
199             # are new, then add them all as a single "transaction" below.
200             for st in unit._names:
201                 if (st in self._registry and unit != self._registry[st]):
202                     raise ValueError(
203                         "Object with name {!r} already exists in namespace. "
204                         "Filter the set of units to avoid name clashes before "
205                         "enabling them.".format(st))
206 
207             for st in unit._names:
208                 self._registry[st] = unit
209 
210             self._all_units.add(unit)
211             if not isinstance(unit, PrefixUnit):
212                 self._non_prefix_units.add(unit)
213 
214             hash = unit._get_physical_type_id()
215             self._by_physical_type.setdefault(hash, set()).add(unit)
216 
217     def get_units_with_physical_type(self, unit):
218         """
219         Get all units in the registry with the same physical type as
220         the given unit.
221 
222         Parameters
223         ----------
224         unit : UnitBase instance
225         """
226         return self._by_physical_type.get(unit._get_physical_type_id(), set())
227 
228     @property
229     def equivalencies(self):
230         return list(self._equivalencies)
231 
232     def set_enabled_equivalencies(self, equivalencies):
233         """
234         Sets the equivalencies enabled in the unit registry.
235 
236         These equivalencies are used if no explicit equivalencies are given,
237         both in unit conversion and in finding equivalent units.
238 
239         This is meant in particular for allowing angles to be dimensionless.
240         Use with care.
241 
242         Parameters
243         ----------
244         equivalencies : list of tuple
245             List of equivalent pairs, e.g., as returned by
246             `~astropy.units.equivalencies.dimensionless_angles`.
247         """
248         self._reset_equivalencies()
249         return self.add_enabled_equivalencies(equivalencies)
250 
251     def add_enabled_equivalencies(self, equivalencies):
252         """
253         Adds to the set of equivalencies enabled in the unit registry.
254 
255         These equivalencies are used if no explicit equivalencies are given,
256         both in unit conversion and in finding equivalent units.
257 
258         This is meant in particular for allowing angles to be dimensionless.
259         Use with care.
260 
261         Parameters
262         ----------
263         equivalencies : list of tuple
264             List of equivalent pairs, e.g., as returned by
265             `~astropy.units.equivalencies.dimensionless_angles`.
266         """
267         # pre-normalize list to help catch mistakes
268         equivalencies = _normalize_equivalencies(equivalencies)
269         self._equivalencies |= set(equivalencies)
270 
271     @property
272     def aliases(self):
273         return self._aliases
274 
275     def set_enabled_aliases(self, aliases):
276         """
277         Set aliases for units.
278 
279         Parameters
280         ----------
281         aliases : dict of str, Unit
282             The aliases to set. The keys must be the string aliases, and values
283             must be the `astropy.units.Unit` that the alias will be mapped to.
284 
285         Raises
286         ------
287         ValueError
288             If the alias already defines a different unit.
289 
290         """
291         self._reset_aliases()
292         self.add_enabled_aliases(aliases)
293 
294     def add_enabled_aliases(self, aliases):
295         """
296         Add aliases for units.
297 
298         Parameters
299         ----------
300         aliases : dict of str, Unit
301             The aliases to add. The keys must be the string aliases, and values
302             must be the `astropy.units.Unit` that the alias will be mapped to.
303 
304         Raises
305         ------
306         ValueError
307             If the alias already defines a different unit.
308 
309         """
310         for alias, unit in aliases.items():
311             if alias in self._registry and unit != self._registry[alias]:
312                 raise ValueError(
313                     f"{alias} already means {self._registry[alias]}, so "
314                     f"cannot be used as an alias for {unit}.")
315             if alias in self._aliases and unit != self._aliases[alias]:
316                 raise ValueError(
317                     f"{alias} already is an alias for {self._aliases[alias]}, so "
318                     f"cannot be used as an alias for {unit}.")
319 
320         for alias, unit in aliases.items():
321             if alias not in self._registry and alias not in self._aliases:
322                 self._aliases[alias] = unit
323 
324 
325 class _UnitContext:
326     def __init__(self, init=[], equivalencies=[]):
327         _unit_registries.append(
328             _UnitRegistry(init=init, equivalencies=equivalencies))
329 
330     def __enter__(self):
331         pass
332 
333     def __exit__(self, type, value, tb):
334         _unit_registries.pop()
335 
336 
337 _unit_registries = [_UnitRegistry()]
338 
339 
340 def get_current_unit_registry():
341     return _unit_registries[-1]
342 
343 
344 def set_enabled_units(units):
345     """
346     Sets the units enabled in the unit registry.
347 
348     These units are searched when using
349     `UnitBase.find_equivalent_units`, for example.
350 
351     This may be used either permanently, or as a context manager using
352     the ``with`` statement (see example below).
353 
354     Parameters
355     ----------
356     units : list of sequence, dict, or module
357         This is a list of things in which units may be found
358         (sequences, dicts or modules), or units themselves.  The
359         entire set will be "enabled" for searching through by methods
360         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
361 
362     Examples
363     --------
364 
365     >>> from astropy import units as u
366     >>> with u.set_enabled_units([u.pc]):
367     ...     u.m.find_equivalent_units()
368     ...
369       Primary name | Unit definition | Aliases
370     [
371       pc           | 3.08568e+16 m   | parsec  ,
372     ]
373     >>> u.m.find_equivalent_units()
374       Primary name | Unit definition | Aliases
375     [
376       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
377       Angstrom     | 1e-10 m         | AA, angstrom                     ,
378       cm           | 0.01 m          | centimeter                       ,
379       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
380       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
381       lsec         | 2.99792e+08 m   | lightsecond                      ,
382       lyr          | 9.46073e+15 m   | lightyear                        ,
383       m            | irreducible     | meter                            ,
384       micron       | 1e-06 m         |                                  ,
385       pc           | 3.08568e+16 m   | parsec                           ,
386       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
387     ]
388     """
389     # get a context with a new registry, using equivalencies of the current one
390     context = _UnitContext(
391         equivalencies=get_current_unit_registry().equivalencies)
392     # in this new current registry, enable the units requested
393     get_current_unit_registry().set_enabled_units(units)
394     return context
395 
396 
397 def add_enabled_units(units):
398     """
399     Adds to the set of units enabled in the unit registry.
400 
401     These units are searched when using
402     `UnitBase.find_equivalent_units`, for example.
403 
404     This may be used either permanently, or as a context manager using
405     the ``with`` statement (see example below).
406 
407     Parameters
408     ----------
409     units : list of sequence, dict, or module
410         This is a list of things in which units may be found
411         (sequences, dicts or modules), or units themselves.  The
412         entire set will be added to the "enabled" set for searching
413         through by methods like `UnitBase.find_equivalent_units` and
414         `UnitBase.compose`.
415 
416     Examples
417     --------
418 
419     >>> from astropy import units as u
420     >>> from astropy.units import imperial
421     >>> with u.add_enabled_units(imperial):
422     ...     u.m.find_equivalent_units()
423     ...
424       Primary name | Unit definition | Aliases
425     [
426       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
427       Angstrom     | 1e-10 m         | AA, angstrom                     ,
428       cm           | 0.01 m          | centimeter                       ,
429       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
430       ft           | 0.3048 m        | foot                             ,
431       fur          | 201.168 m       | furlong                          ,
432       inch         | 0.0254 m        |                                  ,
433       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
434       lsec         | 2.99792e+08 m   | lightsecond                      ,
435       lyr          | 9.46073e+15 m   | lightyear                        ,
436       m            | irreducible     | meter                            ,
437       mi           | 1609.34 m       | mile                             ,
438       micron       | 1e-06 m         |                                  ,
439       mil          | 2.54e-05 m      | thou                             ,
440       nmi          | 1852 m          | nauticalmile, NM                 ,
441       pc           | 3.08568e+16 m   | parsec                           ,
442       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
443       yd           | 0.9144 m        | yard                             ,
444     ]
445     """
446     # get a context with a new registry, which is a copy of the current one
447     context = _UnitContext(get_current_unit_registry())
448     # in this new current registry, enable the further units requested
449     get_current_unit_registry().add_enabled_units(units)
450     return context
451 
452 
453 def set_enabled_equivalencies(equivalencies):
454     """
455     Sets the equivalencies enabled in the unit registry.
456 
457     These equivalencies are used if no explicit equivalencies are given,
458     both in unit conversion and in finding equivalent units.
459 
460     This is meant in particular for allowing angles to be dimensionless.
461     Use with care.
462 
463     Parameters
464     ----------
465     equivalencies : list of tuple
466         list of equivalent pairs, e.g., as returned by
467         `~astropy.units.equivalencies.dimensionless_angles`.
468 
469     Examples
470     --------
471     Exponentiation normally requires dimensionless quantities.  To avoid
472     problems with complex phases::
473 
474         >>> from astropy import units as u
475         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
476         ...     phase = 0.5 * u.cycle
477         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
478         <Quantity -1.+1.2246468e-16j>
479     """
480     # get a context with a new registry, using all units of the current one
481     context = _UnitContext(get_current_unit_registry())
482     # in this new current registry, enable the equivalencies requested
483     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
484     return context
485 
486 
487 def add_enabled_equivalencies(equivalencies):
488     """
489     Adds to the equivalencies enabled in the unit registry.
490 
491     These equivalencies are used if no explicit equivalencies are given,
492     both in unit conversion and in finding equivalent units.
493 
494     This is meant in particular for allowing angles to be dimensionless.
495     Since no equivalencies are enabled by default, generally it is recommended
496     to use `set_enabled_equivalencies`.
497 
498     Parameters
499     ----------
500     equivalencies : list of tuple
501         list of equivalent pairs, e.g., as returned by
502         `~astropy.units.equivalencies.dimensionless_angles`.
503     """
504     # get a context with a new registry, which is a copy of the current one
505     context = _UnitContext(get_current_unit_registry())
506     # in this new current registry, enable the further equivalencies requested
507     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
508     return context
509 
510 
511 def set_enabled_aliases(aliases):
512     """
513     Set aliases for units.
514 
515     This is useful for handling alternate spellings for units, or
516     misspelled units in files one is trying to read.
517 
518     Parameters
519     ----------
520     aliases : dict of str, Unit
521         The aliases to set. The keys must be the string aliases, and values
522         must be the `astropy.units.Unit` that the alias will be mapped to.
523 
524     Raises
525     ------
526     ValueError
527         If the alias already defines a different unit.
528 
529     Examples
530     --------
531     To temporarily allow for a misspelled 'Angstroem' unit::
532 
533         >>> from astropy import units as u
534         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
535         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
536         True
537 
538     """
539     # get a context with a new registry, which is a copy of the current one
540     context = _UnitContext(get_current_unit_registry())
541     # in this new current registry, enable the further equivalencies requested
542     get_current_unit_registry().set_enabled_aliases(aliases)
543     return context
544 
545 
546 def add_enabled_aliases(aliases):
547     """
548     Add aliases for units.
549 
550     This is useful for handling alternate spellings for units, or
551     misspelled units in files one is trying to read.
552 
553     Since no aliases are enabled by default, generally it is recommended
554     to use `set_enabled_aliases`.
555 
556     Parameters
557     ----------
558     aliases : dict of str, Unit
559         The aliases to add. The keys must be the string aliases, and values
560         must be the `astropy.units.Unit` that the alias will be mapped to.
561 
562     Raises
563     ------
564     ValueError
565         If the alias already defines a different unit.
566 
567     Examples
568     --------
569     To temporarily allow for a misspelled 'Angstroem' unit::
570 
571         >>> from astropy import units as u
572         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
573         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
574         True
575 
576     """
577     # get a context with a new registry, which is a copy of the current one
578     context = _UnitContext(get_current_unit_registry())
579     # in this new current registry, enable the further equivalencies requested
580     get_current_unit_registry().add_enabled_aliases(aliases)
581     return context
582 
583 
584 class UnitsError(Exception):
585     """
586     The base class for unit-specific exceptions.
587     """
588 
589 
590 class UnitScaleError(UnitsError, ValueError):
591     """
592     Used to catch the errors involving scaled units,
593     which are not recognized by FITS format.
594     """
595     pass
596 
597 
598 class UnitConversionError(UnitsError, ValueError):
599     """
600     Used specifically for errors related to converting between units or
601     interpreting units in terms of other units.
602     """
603 
604 
605 class UnitTypeError(UnitsError, TypeError):
606     """
607     Used specifically for errors in setting to units not allowed by a class.
608 
609     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
610     instances were set to a non-angular unit.
611     """
612 
613 
614 class UnitsWarning(AstropyWarning):
615     """
616     The base class for unit-specific warnings.
617     """
618 
619 
620 class UnitBase:
621     """
622     Abstract base class for units.
623 
624     Most of the arithmetic operations on units are defined in this
625     base class.
626 
627     Should not be instantiated by users directly.
628     """
629     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
630     # arrays to avoid element-wise multiplication.
631     __array_priority__ = 1000
632 
633     _hash = None
634     _type_id = None
635 
636     def __deepcopy__(self, memo):
637         # This may look odd, but the units conversion will be very
638         # broken after deep-copying if we don't guarantee that a given
639         # physical unit corresponds to only one instance
640         return self
641 
642     def _repr_latex_(self):
643         """
644         Generate latex representation of unit name.  This is used by
645         the IPython notebook to print a unit with a nice layout.
646 
647         Returns
648         -------
649         Latex string
650         """
651         return unit_format.Latex.to_string(self)
652 
653     def __bytes__(self):
654         """Return string representation for unit"""
655         return unit_format.Generic.to_string(self).encode('unicode_escape')
656 
657     def __str__(self):
658         """Return string representation for unit"""
659         return unit_format.Generic.to_string(self)
660 
661     def __repr__(self):
662         string = unit_format.Generic.to_string(self)
663 
664         return f'Unit("{string}")'
665 
666     def _get_physical_type_id(self):
667         """
668         Returns an identifier that uniquely identifies the physical
669         type of this unit.  It is comprised of the bases and powers of
670         this unit, without the scale.  Since it is hashable, it is
671         useful as a dictionary key.
672         """
673         if self._type_id is None:
674             unit = self.decompose()
675             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
676 
677         return self._type_id
678 
679     @property
680     def names(self):
681         """
682         Returns all of the names associated with this unit.
683         """
684         raise AttributeError(
685             "Can not get names from unnamed units. "
686             "Perhaps you meant to_string()?")
687 
688     @property
689     def name(self):
690         """
691         Returns the canonical (short) name associated with this unit.
692         """
693         raise AttributeError(
694             "Can not get names from unnamed units. "
695             "Perhaps you meant to_string()?")
696 
697     @property
698     def aliases(self):
699         """
700         Returns the alias (long) names for this unit.
701         """
702         raise AttributeError(
703             "Can not get aliases from unnamed units. "
704             "Perhaps you meant to_string()?")
705 
706     @property
707     def scale(self):
708         """
709         Return the scale of the unit.
710         """
711         return 1.0
712 
713     @property
714     def bases(self):
715         """
716         Return the bases of the unit.
717         """
718         return [self]
719 
720     @property
721     def powers(self):
722         """
723         Return the powers of the unit.
724         """
725         return [1]
726 
727     def to_string(self, format=unit_format.Generic):
728         """
729         Output the unit in the given format as a string.
730 
731         Parameters
732         ----------
733         format : `astropy.units.format.Base` instance or str
734             The name of a format or a formatter object.  If not
735             provided, defaults to the generic format.
736         """
737 
738         f = unit_format.get_format(format)
739         return f.to_string(self)
740 
741     def __format__(self, format_spec):
742         """Try to format units using a formatter."""
743         try:
744             return self.to_string(format=format_spec)
745         except ValueError:
746             return format(str(self), format_spec)
747 
748     @staticmethod
749     def _normalize_equivalencies(equivalencies):
750         """
751         Normalizes equivalencies, ensuring each is a 4-tuple of the form::
752 
753         (from_unit, to_unit, forward_func, backward_func)
754 
755         Parameters
756         ----------
757         equivalencies : list of equivalency pairs, or None
758 
759         Returns
760         -------
761         A normalized list, including possible global defaults set by, e.g.,
762         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
763         in which case the returned list is always empty.
764 
765         Raises
766         ------
767         ValueError if an equivalency cannot be interpreted
768         """
769         normalized = _normalize_equivalencies(equivalencies)
770         if equivalencies is not None:
771             normalized += get_current_unit_registry().equivalencies
772 
773         return normalized
774 
775     def __pow__(self, p):
776         p = validate_power(p)
777         return CompositeUnit(1, [self], [p], _error_check=False)
778 
779     def __truediv__(self, m):
780         if isinstance(m, (bytes, str)):
781             m = Unit(m)
782 
783         if isinstance(m, UnitBase):
784             if m.is_unity():
785                 return self
786             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
787 
788         try:
789             # Cannot handle this as Unit, re-try as Quantity
790             from .quantity import Quantity
791             return Quantity(1, self) / m
792         except TypeError:
793             return NotImplemented
794 
795     def __rtruediv__(self, m):
796         if isinstance(m, (bytes, str)):
797             return Unit(m) / self
798 
799         try:
800             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
801             # so we make it into one, fasttracking when it does not have a
802             # unit, for the common case of <array> / <unit>.
803             from .quantity import Quantity
804             if hasattr(m, 'unit'):
805                 result = Quantity(m)
806                 result /= self
807                 return result
808             else:
809                 return Quantity(m, self**(-1))
810         except TypeError:
811             return NotImplemented
812 
813     def __mul__(self, m):
814         if isinstance(m, (bytes, str)):
815             m = Unit(m)
816 
817         if isinstance(m, UnitBase):
818             if m.is_unity():
819                 return self
820             elif self.is_unity():
821                 return m
822             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
823 
824         # Cannot handle this as Unit, re-try as Quantity.
825         try:
826             from .quantity import Quantity
827             return Quantity(1, unit=self) * m
828         except TypeError:
829             return NotImplemented
830 
831     def __rmul__(self, m):
832         if isinstance(m, (bytes, str)):
833             return Unit(m) * self
834 
835         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
836         # so we make it into one, fasttracking when it does not have a unit
837         # for the common case of <array> * <unit>.
838         try:
839             from .quantity import Quantity
840             if hasattr(m, 'unit'):
841                 result = Quantity(m)
842                 result *= self
843                 return result
844             else:
845                 return Quantity(m, unit=self)
846         except TypeError:
847             return NotImplemented
848 
849     def __rlshift__(self, m):
850         try:
851             from .quantity import Quantity
852             return Quantity(m, self, copy=False, subok=True)
853         except Exception:
854             return NotImplemented
855 
856     def __rrshift__(self, m):
857         warnings.warn(">> is not implemented. Did you mean to convert "
858                       "to a Quantity with unit {} using '<<'?".format(self),
859                       AstropyWarning)
860         return NotImplemented
861 
862     def __hash__(self):
863         if self._hash is None:
864             parts = ([str(self.scale)] +
865                      [x.name for x in self.bases] +
866                      [str(x) for x in self.powers])
867             self._hash = hash(tuple(parts))
868         return self._hash
869 
870     def __getstate__(self):
871         # If we get pickled, we should *not* store the memoized members since
872         # hashes of strings vary between sessions.
873         state = self.__dict__.copy()
874         state.pop('_hash', None)
875         state.pop('_type_id', None)
876         return state
877 
878     def __eq__(self, other):
879         if self is other:
880             return True
881 
882         try:
883             other = Unit(other, parse_strict='silent')
884         except (ValueError, UnitsError, TypeError):
885             return NotImplemented
886 
887         # Other is unit-like, but the test below requires it is a UnitBase
888         # instance; if it is not, give up (so that other can try).
889         if not isinstance(other, UnitBase):
890             return NotImplemented
891 
892         try:
893             return is_effectively_unity(self._to(other))
894         except UnitsError:
895             return False
896 
897     def __ne__(self, other):
898         return not (self == other)
899 
900     def __le__(self, other):
901         scale = self._to(Unit(other))
902         return scale <= 1. or is_effectively_unity(scale)
903 
904     def __ge__(self, other):
905         scale = self._to(Unit(other))
906         return scale >= 1. or is_effectively_unity(scale)
907 
908     def __lt__(self, other):
909         return not (self >= other)
910 
911     def __gt__(self, other):
912         return not (self <= other)
913 
914     def __neg__(self):
915         return self * -1.
916 
917     def is_equivalent(self, other, equivalencies=[]):
918         """
919         Returns `True` if this unit is equivalent to ``other``.
920 
921         Parameters
922         ----------
923         other : `~astropy.units.Unit`, str, or tuple
924             The unit to convert to. If a tuple of units is specified, this
925             method returns true if the unit matches any of those in the tuple.
926 
927         equivalencies : list of tuple
928             A list of equivalence pairs to try if the units are not
929             directly convertible.  See :ref:`astropy:unit_equivalencies`.
930             This list is in addition to possible global defaults set by, e.g.,
931             `set_enabled_equivalencies`.
932             Use `None` to turn off all equivalencies.
933 
934         Returns
935         -------
936         bool
937         """
938         equivalencies = self._normalize_equivalencies(equivalencies)
939 
940         if isinstance(other, tuple):
941             return any(self.is_equivalent(u, equivalencies=equivalencies)
942                        for u in other)
943 
944         other = Unit(other, parse_strict='silent')
945 
946         return self._is_equivalent(other, equivalencies)
947 
948     def _is_equivalent(self, other, equivalencies=[]):
949         """Returns `True` if this unit is equivalent to `other`.
950         See `is_equivalent`, except that a proper Unit object should be
951         given (i.e., no string) and that the equivalency list should be
952         normalized using `_normalize_equivalencies`.
953         """
954         if isinstance(other, UnrecognizedUnit):
955             return False
956 
957         if (self._get_physical_type_id() ==
958                 other._get_physical_type_id()):
959             return True
960         elif len(equivalencies):
961             unit = self.decompose()
962             other = other.decompose()
963             for a, b, forward, backward in equivalencies:
964                 if b is None:
965                     # after canceling, is what's left convertible
966                     # to dimensionless (according to the equivalency)?
967                     try:
968                         (other/unit).decompose([a])
969                         return True
970                     except Exception:
971                         pass
972                 elif (
973                     a._is_equivalent(unit) and b._is_equivalent(other)
974                     or b._is_equivalent(unit) and a._is_equivalent(other)
975                 ):
976                     return True
977 
978         return False
979 
980     def _apply_equivalencies(self, unit, other, equivalencies):
981         """
982         Internal function (used from `_get_converter`) to apply
983         equivalence pairs.
984         """
985         def make_converter(scale1, func, scale2):
986             def convert(v):
987                 return func(_condition_arg(v) / scale1) * scale2
988             return convert
989 
990         for funit, tunit, a, b in equivalencies:
991             if tunit is None:
992                 try:
993                     ratio_in_funit = (other.decompose() /
994                                       unit.decompose()).decompose([funit])
995                     return make_converter(ratio_in_funit.scale, a, 1.)
996                 except UnitsError:
997                     pass
998             else:
999                 try:
1000                     scale1 = funit._to(unit)
1001                     scale2 = tunit._to(other)
1002                     return make_converter(scale1, a, scale2)
1003                 except UnitsError:
1004                     pass
1005                 try:
1006                     scale1 = tunit._to(unit)
1007                     scale2 = funit._to(other)
1008                     return make_converter(scale1, b, scale2)
1009                 except UnitsError:
1010                     pass
1011 
1012         def get_err_str(unit):
1013             unit_str = unit.to_string('unscaled')
1014             physical_type = unit.physical_type
1015             if physical_type != 'unknown':
1016                 unit_str = f"'{unit_str}' ({physical_type})"
1017             else:
1018                 unit_str = f"'{unit_str}'"
1019             return unit_str
1020 
1021         unit_str = get_err_str(unit)
1022         other_str = get_err_str(other)
1023 
1024         raise UnitConversionError(
1025             f"{unit_str} and {other_str} are not convertible")
1026 
1027     def _get_converter(self, other, equivalencies=[]):
1028         """Get a converter for values in ``self`` to ``other``.
1029 
1030         If no conversion is necessary, returns ``unit_scale_converter``
1031         (which is used as a check in quantity helpers).
1032 
1033         """
1034 
1035         # First see if it is just a scaling.
1036         try:
1037             scale = self._to(other)
1038         except UnitsError:
1039             pass
1040         else:
1041             if scale == 1.:
1042                 return unit_scale_converter
1043             else:
1044                 return lambda val: scale * _condition_arg(val)
1045 
1046         # if that doesn't work, maybe we can do it with equivalencies?
1047         try:
1048             return self._apply_equivalencies(
1049                 self, other, self._normalize_equivalencies(equivalencies))
1050         except UnitsError as exc:
1051             # Last hope: maybe other knows how to do it?
1052             # We assume the equivalencies have the unit itself as first item.
1053             # TODO: maybe better for other to have a `_back_converter` method?
1054             if hasattr(other, 'equivalencies'):
1055                 for funit, tunit, a, b in other.equivalencies:
1056                     if other is funit:
1057                         try:
1058                             return lambda v: b(self._get_converter(
1059                                 tunit, equivalencies=equivalencies)(v))
1060                         except Exception:
1061                             pass
1062 
1063             raise exc
1064 
1065     def _to(self, other):
1066         """
1067         Returns the scale to the specified unit.
1068 
1069         See `to`, except that a Unit object should be given (i.e., no
1070         string), and that all defaults are used, i.e., no
1071         equivalencies and value=1.
1072         """
1073         # There are many cases where we just want to ensure a Quantity is
1074         # of a particular unit, without checking whether it's already in
1075         # a particular unit.  If we're being asked to convert from a unit
1076         # to itself, we can short-circuit all of this.
1077         if self is other:
1078             return 1.0
1079 
1080         # Don't presume decomposition is possible; e.g.,
1081         # conversion to function units is through equivalencies.
1082         if isinstance(other, UnitBase):
1083             self_decomposed = self.decompose()
1084             other_decomposed = other.decompose()
1085 
1086             # Check quickly whether equivalent.  This is faster than
1087             # `is_equivalent`, because it doesn't generate the entire
1088             # physical type list of both units.  In other words it "fails
1089             # fast".
1090             if (self_decomposed.powers == other_decomposed.powers
1091                 and all(self_base is other_base for (self_base, other_base)
1092                         in zip(self_decomposed.bases, other_decomposed.bases))):
1093                 return self_decomposed.scale / other_decomposed.scale
1094 
1095         raise UnitConversionError(
1096             f"'{self!r}' is not a scaled version of '{other!r}'")
1097 
1098     def to(self, other, value=UNITY, equivalencies=[]):
1099         """
1100         Return the converted values in the specified unit.
1101 
1102         Parameters
1103         ----------
1104         other : unit-like
1105             The unit to convert to.
1106 
1107         value : int, float, or scalar array-like, optional
1108             Value(s) in the current unit to be converted to the
1109             specified unit.  If not provided, defaults to 1.0
1110 
1111         equivalencies : list of tuple
1112             A list of equivalence pairs to try if the units are not
1113             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1114             This list is in addition to possible global defaults set by, e.g.,
1115             `set_enabled_equivalencies`.
1116             Use `None` to turn off all equivalencies.
1117 
1118         Returns
1119         -------
1120         values : scalar or array
1121             Converted value(s). Input value sequences are returned as
1122             numpy arrays.
1123 
1124         Raises
1125         ------
1126         UnitsError
1127             If units are inconsistent
1128         """
1129         if other is self and value is UNITY:
1130             return UNITY
1131         else:
1132             return self._get_converter(Unit(other),
1133                                        equivalencies=equivalencies)(value)
1134 
1135     def in_units(self, other, value=1.0, equivalencies=[]):
1136         """
1137         Alias for `to` for backward compatibility with pynbody.
1138         """
1139         return self.to(
1140             other, value=value, equivalencies=equivalencies)
1141 
1142     def decompose(self, bases=set()):
1143         """
1144         Return a unit object composed of only irreducible units.
1145 
1146         Parameters
1147         ----------
1148         bases : sequence of UnitBase, optional
1149             The bases to decompose into.  When not provided,
1150             decomposes down to any irreducible units.  When provided,
1151             the decomposed result will only contain the given units.
1152             This will raises a `UnitsError` if it's not possible
1153             to do so.
1154 
1155         Returns
1156         -------
1157         unit : `~astropy.units.CompositeUnit`
1158             New object containing only irreducible unit objects.
1159         """
1160         raise NotImplementedError()
1161 
1162     def _compose(self, equivalencies=[], namespace=[], max_depth=2, depth=0,
1163                  cached_results=None):
1164         def is_final_result(unit):
1165             # Returns True if this result contains only the expected
1166             # units
1167             for base in unit.bases:
1168                 if base not in namespace:
1169                     return False
1170             return True
1171 
1172         unit = self.decompose()
1173         key = hash(unit)
1174 
1175         cached = cached_results.get(key)
1176         if cached is not None:
1177             if isinstance(cached, Exception):
1178                 raise cached
1179             return cached
1180 
1181         # Prevent too many levels of recursion
1182         # And special case for dimensionless unit
1183         if depth >= max_depth:
1184             cached_results[key] = [unit]
1185             return [unit]
1186 
1187         # Make a list including all of the equivalent units
1188         units = [unit]
1189         for funit, tunit, a, b in equivalencies:
1190             if tunit is not None:
1191                 if self._is_equivalent(funit):
1192                     scale = funit.decompose().scale / unit.scale
1193                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1194                 elif self._is_equivalent(tunit):
1195                     scale = tunit.decompose().scale / unit.scale
1196                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1197             else:
1198                 if self._is_equivalent(funit):
1199                     units.append(Unit(unit.scale))
1200 
1201         # Store partial results
1202         partial_results = []
1203         # Store final results that reduce to a single unit or pair of
1204         # units
1205         if len(unit.bases) == 0:
1206             final_results = [{unit}, set()]
1207         else:
1208             final_results = [set(), set()]
1209 
1210         for tunit in namespace:
1211             tunit_decomposed = tunit.decompose()
1212             for u in units:
1213                 # If the unit is a base unit, look for an exact match
1214                 # to one of the bases of the target unit.  If found,
1215                 # factor by the same power as the target unit's base.
1216                 # This allows us to factor out fractional powers
1217                 # without needing to do an exhaustive search.
1218                 if len(tunit_decomposed.bases) == 1:
1219                     for base, power in zip(u.bases, u.powers):
1220                         if tunit_decomposed._is_equivalent(base):
1221                             tunit = tunit ** power
1222                             tunit_decomposed = tunit_decomposed ** power
1223                             break
1224 
1225                 composed = (u / tunit_decomposed).decompose()
1226                 factored = composed * tunit
1227                 len_bases = len(composed.bases)
1228                 if is_final_result(factored) and len_bases <= 1:
1229                     final_results[len_bases].add(factored)
1230                 else:
1231                     partial_results.append(
1232                         (len_bases, composed, tunit))
1233 
1234         # Do we have any minimal results?
1235         for final_result in final_results:
1236             if len(final_result):
1237                 results = final_results[0].union(final_results[1])
1238                 cached_results[key] = results
1239                 return results
1240 
1241         partial_results.sort(key=operator.itemgetter(0))
1242 
1243         # ...we have to recurse and try to further compose
1244         results = []
1245         for len_bases, composed, tunit in partial_results:
1246             try:
1247                 composed_list = composed._compose(
1248                     equivalencies=equivalencies,
1249                     namespace=namespace,
1250                     max_depth=max_depth, depth=depth + 1,
1251                     cached_results=cached_results)
1252             except UnitsError:
1253                 composed_list = []
1254             for subcomposed in composed_list:
1255                 results.append(
1256                     (len(subcomposed.bases), subcomposed, tunit))
1257 
1258         if len(results):
1259             results.sort(key=operator.itemgetter(0))
1260 
1261             min_length = results[0][0]
1262             subresults = set()
1263             for len_bases, composed, tunit in results:
1264                 if len_bases > min_length:
1265                     break
1266                 else:
1267                     factored = composed * tunit
1268                     if is_final_result(factored):
1269                         subresults.add(factored)
1270 
1271             if len(subresults):
1272                 cached_results[key] = subresults
1273                 return subresults
1274 
1275         if not is_final_result(self):
1276             result = UnitsError(
1277                 f"Cannot represent unit {self} in terms of the given units")
1278             cached_results[key] = result
1279             raise result
1280 
1281         cached_results[key] = [self]
1282         return [self]
1283 
1284     def compose(self, equivalencies=[], units=None, max_depth=2,
1285                 include_prefix_units=None):
1286         """
1287         Return the simplest possible composite unit(s) that represent
1288         the given unit.  Since there may be multiple equally simple
1289         compositions of the unit, a list of units is always returned.
1290 
1291         Parameters
1292         ----------
1293         equivalencies : list of tuple
1294             A list of equivalence pairs to also list.  See
1295             :ref:`astropy:unit_equivalencies`.
1296             This list is in addition to possible global defaults set by, e.g.,
1297             `set_enabled_equivalencies`.
1298             Use `None` to turn off all equivalencies.
1299 
1300         units : set of `~astropy.units.Unit`, optional
1301             If not provided, any known units may be used to compose
1302             into.  Otherwise, ``units`` is a dict, module or sequence
1303             containing the units to compose into.
1304 
1305         max_depth : int, optional
1306             The maximum recursion depth to use when composing into
1307             composite units.
1308 
1309         include_prefix_units : bool, optional
1310             When `True`, include prefixed units in the result.
1311             Default is `True` if a sequence is passed in to ``units``,
1312             `False` otherwise.
1313 
1314         Returns
1315         -------
1316         units : list of `CompositeUnit`
1317             A list of candidate compositions.  These will all be
1318             equally simple, but it may not be possible to
1319             automatically determine which of the candidates are
1320             better.
1321         """
1322         # if units parameter is specified and is a sequence (list|tuple),
1323         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1324         if include_prefix_units is None:
1325             include_prefix_units = isinstance(units, (list, tuple))
1326 
1327         # Pre-normalize the equivalencies list
1328         equivalencies = self._normalize_equivalencies(equivalencies)
1329 
1330         # The namespace of units to compose into should be filtered to
1331         # only include units with bases in common with self, otherwise
1332         # they can't possibly provide useful results.  Having too many
1333         # destination units greatly increases the search space.
1334 
1335         def has_bases_in_common(a, b):
1336             if len(a.bases) == 0 and len(b.bases) == 0:
1337                 return True
1338             for ab in a.bases:
1339                 for bb in b.bases:
1340                     if ab == bb:
1341                         return True
1342             return False
1343 
1344         def has_bases_in_common_with_equiv(unit, other):
1345             if has_bases_in_common(unit, other):
1346                 return True
1347             for funit, tunit, a, b in equivalencies:
1348                 if tunit is not None:
1349                     if unit._is_equivalent(funit):
1350                         if has_bases_in_common(tunit.decompose(), other):
1351                             return True
1352                     elif unit._is_equivalent(tunit):
1353                         if has_bases_in_common(funit.decompose(), other):
1354                             return True
1355                 else:
1356                     if unit._is_equivalent(funit):
1357                         if has_bases_in_common(dimensionless_unscaled, other):
1358                             return True
1359             return False
1360 
1361         def filter_units(units):
1362             filtered_namespace = set()
1363             for tunit in units:
1364                 if (isinstance(tunit, UnitBase) and
1365                     (include_prefix_units or
1366                      not isinstance(tunit, PrefixUnit)) and
1367                     has_bases_in_common_with_equiv(
1368                         decomposed, tunit.decompose())):
1369                     filtered_namespace.add(tunit)
1370             return filtered_namespace
1371 
1372         decomposed = self.decompose()
1373 
1374         if units is None:
1375             units = filter_units(self._get_units_with_same_physical_type(
1376                 equivalencies=equivalencies))
1377             if len(units) == 0:
1378                 units = get_current_unit_registry().non_prefix_units
1379         elif isinstance(units, dict):
1380             units = set(filter_units(units.values()))
1381         elif inspect.ismodule(units):
1382             units = filter_units(vars(units).values())
1383         else:
1384             units = filter_units(_flatten_units_collection(units))
1385 
1386         def sort_results(results):
1387             if not len(results):
1388                 return []
1389 
1390             # Sort the results so the simplest ones appear first.
1391             # Simplest is defined as "the minimum sum of absolute
1392             # powers" (i.e. the fewest bases), and preference should
1393             # be given to results where the sum of powers is positive
1394             # and the scale is exactly equal to 1.0
1395             results = list(results)
1396             results.sort(key=lambda x: np.abs(x.scale))
1397             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1398             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1399             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1400 
1401             last_result = results[0]
1402             filtered = [last_result]
1403             for result in results[1:]:
1404                 if str(result) != str(last_result):
1405                     filtered.append(result)
1406                 last_result = result
1407 
1408             return filtered
1409 
1410         return sort_results(self._compose(
1411             equivalencies=equivalencies, namespace=units,
1412             max_depth=max_depth, depth=0, cached_results={}))
1413 
1414     def to_system(self, system):
1415         """
1416         Converts this unit into ones belonging to the given system.
1417         Since more than one result may be possible, a list is always
1418         returned.
1419 
1420         Parameters
1421         ----------
1422         system : module
1423             The module that defines the unit system.  Commonly used
1424             ones include `astropy.units.si` and `astropy.units.cgs`.
1425 
1426             To use your own module it must contain unit objects and a
1427             sequence member named ``bases`` containing the base units of
1428             the system.
1429 
1430         Returns
1431         -------
1432         units : list of `CompositeUnit`
1433             The list is ranked so that units containing only the base
1434             units of that system will appear first.
1435         """
1436         bases = set(system.bases)
1437 
1438         def score(compose):
1439             # In case that compose._bases has no elements we return
1440             # 'np.inf' as 'score value'.  It does not really matter which
1441             # number we would return. This case occurs for instance for
1442             # dimensionless quantities:
1443             compose_bases = compose.bases
1444             if len(compose_bases) == 0:
1445                 return np.inf
1446             else:
1447                 sum = 0
1448                 for base in compose_bases:
1449                     if base in bases:
1450                         sum += 1
1451 
1452                 return sum / float(len(compose_bases))
1453 
1454         x = self.decompose(bases=bases)
1455         composed = x.compose(units=system)
1456         composed = sorted(composed, key=score, reverse=True)
1457         return composed
1458 
1459     @lazyproperty
1460     def si(self):
1461         """
1462         Returns a copy of the current `Unit` instance in SI units.
1463         """
1464 
1465         from . import si
1466         return self.to_system(si)[0]
1467 
1468     @lazyproperty
1469     def cgs(self):
1470         """
1471         Returns a copy of the current `Unit` instance with CGS units.
1472         """
1473         from . import cgs
1474         return self.to_system(cgs)[0]
1475 
1476     @property
1477     def physical_type(self):
1478         """
1479         Physical type(s) dimensionally compatible with the unit.
1480 
1481         Returns
1482         -------
1483         `~astropy.units.physical.PhysicalType`
1484             A representation of the physical type(s) of a unit.
1485 
1486         Examples
1487         --------
1488         >>> from astropy import units as u
1489         >>> u.m.physical_type
1490         PhysicalType('length')
1491         >>> (u.m ** 2 / u.s).physical_type
1492         PhysicalType({'diffusivity', 'kinematic viscosity'})
1493 
1494         Physical types can be compared to other physical types
1495         (recommended in packages) or to strings.
1496 
1497         >>> area = (u.m ** 2).physical_type
1498         >>> area == u.m.physical_type ** 2
1499         True
1500         >>> area == "area"
1501         True
1502 
1503         `~astropy.units.physical.PhysicalType` objects can be used for
1504         dimensional analysis.
1505 
1506         >>> number_density = u.m.physical_type ** -3
1507         >>> velocity = (u.m / u.s).physical_type
1508         >>> number_density * velocity
1509         PhysicalType('particle flux')
1510         """
1511         from . import physical
1512         return physical.get_physical_type(self)
1513 
1514     def _get_units_with_same_physical_type(self, equivalencies=[]):
1515         """
1516         Return a list of registered units with the same physical type
1517         as this unit.
1518 
1519         This function is used by Quantity to add its built-in
1520         conversions to equivalent units.
1521 
1522         This is a private method, since end users should be encouraged
1523         to use the more powerful `compose` and `find_equivalent_units`
1524         methods (which use this under the hood).
1525 
1526         Parameters
1527         ----------
1528         equivalencies : list of tuple
1529             A list of equivalence pairs to also pull options from.
1530             See :ref:`astropy:unit_equivalencies`.  It must already be
1531             normalized using `_normalize_equivalencies`.
1532         """
1533         unit_registry = get_current_unit_registry()
1534         units = set(unit_registry.get_units_with_physical_type(self))
1535         for funit, tunit, a, b in equivalencies:
1536             if tunit is not None:
1537                 if self.is_equivalent(funit) and tunit not in units:
1538                     units.update(
1539                         unit_registry.get_units_with_physical_type(tunit))
1540                 if self._is_equivalent(tunit) and funit not in units:
1541                     units.update(
1542                         unit_registry.get_units_with_physical_type(funit))
1543             else:
1544                 if self.is_equivalent(funit):
1545                     units.add(dimensionless_unscaled)
1546         return units
1547 
1548     class EquivalentUnitsList(list):
1549         """
1550         A class to handle pretty-printing the result of
1551         `find_equivalent_units`.
1552         """
1553 
1554         HEADING_NAMES = ('Primary name', 'Unit definition', 'Aliases')
1555         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1556         NO_EQUIV_UNITS_MSG = 'There are no equivalent units'
1557 
1558         def __repr__(self):
1559             if len(self) == 0:
1560                 return self.NO_EQUIV_UNITS_MSG
1561             else:
1562                 lines = self._process_equivalent_units(self)
1563                 lines.insert(0, self.HEADING_NAMES)
1564                 widths = [0] * self.ROW_LEN
1565                 for line in lines:
1566                     for i, col in enumerate(line):
1567                         widths[i] = max(widths[i], len(col))
1568 
1569                 f = "  {{0:<{0}s}} | {{1:<{1}s}} | {{2:<{2}s}}".format(*widths)
1570                 lines = [f.format(*line) for line in lines]
1571                 lines = (lines[0:1] +
1572                          ['['] +
1573                          [f'{x} ,' for x in lines[1:]] +
1574                          [']'])
1575                 return '\n'.join(lines)
1576 
1577         def _repr_html_(self):
1578             """
1579             Outputs a HTML table representation within Jupyter notebooks.
1580             """
1581             if len(self) == 0:
1582                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1583             else:
1584                 # HTML tags to use to compose the table in HTML
1585                 blank_table = '<table style="width:50%">{}</table>'
1586                 blank_row_container = "<tr>{}</tr>"
1587                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1588                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1589 
1590                 # The HTML will be rendered & the table is simple, so don't
1591                 # bother to include newlines & indentation for the HTML code.
1592                 heading_row = blank_row_container.format(
1593                     heading_row_content.format(*self.HEADING_NAMES))
1594                 data_rows = self._process_equivalent_units(self)
1595                 all_rows = heading_row
1596                 for row in data_rows:
1597                     html_row = blank_row_container.format(
1598                         data_row_content.format(*row))
1599                     all_rows += html_row
1600                 return blank_table.format(all_rows)
1601 
1602         @staticmethod
1603         def _process_equivalent_units(equiv_units_data):
1604             """
1605             Extract attributes, and sort, the equivalent units pre-formatting.
1606             """
1607             processed_equiv_units = []
1608             for u in equiv_units_data:
1609                 irred = u.decompose().to_string()
1610                 if irred == u.name:
1611                     irred = 'irreducible'
1612                 processed_equiv_units.append(
1613                     (u.name, irred, ', '.join(u.aliases)))
1614             processed_equiv_units.sort()
1615             return processed_equiv_units
1616 
1617     def find_equivalent_units(self, equivalencies=[], units=None,
1618                               include_prefix_units=False):
1619         """
1620         Return a list of all the units that are the same type as ``self``.
1621 
1622         Parameters
1623         ----------
1624         equivalencies : list of tuple
1625             A list of equivalence pairs to also list.  See
1626             :ref:`astropy:unit_equivalencies`.
1627             Any list given, including an empty one, supersedes global defaults
1628             that may be in effect (as set by `set_enabled_equivalencies`)
1629 
1630         units : set of `~astropy.units.Unit`, optional
1631             If not provided, all defined units will be searched for
1632             equivalencies.  Otherwise, may be a dict, module or
1633             sequence containing the units to search for equivalencies.
1634 
1635         include_prefix_units : bool, optional
1636             When `True`, include prefixed units in the result.
1637             Default is `False`.
1638 
1639         Returns
1640         -------
1641         units : list of `UnitBase`
1642             A list of unit objects that match ``u``.  A subclass of
1643             `list` (``EquivalentUnitsList``) is returned that
1644             pretty-prints the list of units when output.
1645         """
1646         results = self.compose(
1647             equivalencies=equivalencies, units=units, max_depth=1,
1648             include_prefix_units=include_prefix_units)
1649         results = {x.bases[0] for x in results if len(x.bases) == 1}
1650         return self.EquivalentUnitsList(results)
1651 
1652     def is_unity(self):
1653         """
1654         Returns `True` if the unit is unscaled and dimensionless.
1655         """
1656         return False
1657 
1658 
1659 class NamedUnit(UnitBase):
1660     """
1661     The base class of units that have a name.
1662 
1663     Parameters
1664     ----------
1665     st : str, list of str, 2-tuple
1666         The name of the unit.  If a list of strings, the first element
1667         is the canonical (short) name, and the rest of the elements
1668         are aliases.  If a tuple of lists, the first element is a list
1669         of short names, and the second element is a list of long
1670         names; all but the first short name are considered "aliases".
1671         Each name *should* be a valid Python identifier to make it
1672         easy to access, but this is not required.
1673 
1674     namespace : dict, optional
1675         When provided, inject the unit, and all of its aliases, in the
1676         given namespace dictionary.  If a unit by the same name is
1677         already in the namespace, a ValueError is raised.
1678 
1679     doc : str, optional
1680         A docstring describing the unit.
1681 
1682     format : dict, optional
1683         A mapping to format-specific representations of this unit.
1684         For example, for the ``Ohm`` unit, it might be nice to have it
1685         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1686         case, `format` argument should be set to::
1687 
1688             {'latex': r'\\Omega'}
1689 
1690     Raises
1691     ------
1692     ValueError
1693         If any of the given unit names are already in the registry.
1694 
1695     ValueError
1696         If any of the given unit names are not valid Python tokens.
1697     """
1698 
1699     def __init__(self, st, doc=None, format=None, namespace=None):
1700 
1701         UnitBase.__init__(self)
1702 
1703         if isinstance(st, (bytes, str)):
1704             self._names = [st]
1705             self._short_names = [st]
1706             self._long_names = []
1707         elif isinstance(st, tuple):
1708             if not len(st) == 2:
1709                 raise ValueError("st must be string, list or 2-tuple")
1710             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1711             if not len(self._names):
1712                 raise ValueError("must provide at least one name")
1713             self._short_names = st[0][:]
1714             self._long_names = st[1][:]
1715         else:
1716             if len(st) == 0:
1717                 raise ValueError(
1718                     "st list must have at least one entry")
1719             self._names = st[:]
1720             self._short_names = [st[0]]
1721             self._long_names = st[1:]
1722 
1723         if format is None:
1724             format = {}
1725         self._format = format
1726 
1727         if doc is None:
1728             doc = self._generate_doc()
1729         else:
1730             doc = textwrap.dedent(doc)
1731             doc = textwrap.fill(doc)
1732 
1733         self.__doc__ = doc
1734 
1735         self._inject(namespace)
1736 
1737     def _generate_doc(self):
1738         """
1739         Generate a docstring for the unit if the user didn't supply
1740         one.  This is only used from the constructor and may be
1741         overridden in subclasses.
1742         """
1743         names = self.names
1744         if len(self.names) > 1:
1745             return "{1} ({0})".format(*names[:2])
1746         else:
1747             return names[0]
1748 
1749     def get_format_name(self, format):
1750         """
1751         Get a name for this unit that is specific to a particular
1752         format.
1753 
1754         Uses the dictionary passed into the `format` kwarg in the
1755         constructor.
1756 
1757         Parameters
1758         ----------
1759         format : str
1760             The name of the format
1761 
1762         Returns
1763         -------
1764         name : str
1765             The name of the unit for the given format.
1766         """
1767         return self._format.get(format, self.name)
1768 
1769     @property
1770     def names(self):
1771         """
1772         Returns all of the names associated with this unit.
1773         """
1774         return self._names
1775 
1776     @property
1777     def name(self):
1778         """
1779         Returns the canonical (short) name associated with this unit.
1780         """
1781         return self._names[0]
1782 
1783     @property
1784     def aliases(self):
1785         """
1786         Returns the alias (long) names for this unit.
1787         """
1788         return self._names[1:]
1789 
1790     @property
1791     def short_names(self):
1792         """
1793         Returns all of the short names associated with this unit.
1794         """
1795         return self._short_names
1796 
1797     @property
1798     def long_names(self):
1799         """
1800         Returns all of the long names associated with this unit.
1801         """
1802         return self._long_names
1803 
1804     def _inject(self, namespace=None):
1805         """
1806         Injects the unit, and all of its aliases, in the given
1807         namespace dictionary.
1808         """
1809         if namespace is None:
1810             return
1811 
1812         # Loop through all of the names first, to ensure all of them
1813         # are new, then add them all as a single "transaction" below.
1814         for name in self._names:
1815             if name in namespace and self != namespace[name]:
1816                 raise ValueError(
1817                     "Object with name {!r} already exists in "
1818                     "given namespace ({!r}).".format(
1819                         name, namespace[name]))
1820 
1821         for name in self._names:
1822             namespace[name] = self
1823 
1824 
1825 def _recreate_irreducible_unit(cls, names, registered):
1826     """
1827     This is used to reconstruct units when passed around by
1828     multiprocessing.
1829     """
1830     registry = get_current_unit_registry().registry
1831     if names[0] in registry:
1832         # If in local registry return that object.
1833         return registry[names[0]]
1834     else:
1835         # otherwise, recreate the unit.
1836         unit = cls(names)
1837         if registered:
1838             # If not in local registry but registered in origin registry,
1839             # enable unit in local registry.
1840             get_current_unit_registry().add_enabled_units([unit])
1841 
1842         return unit
1843 
1844 
1845 class IrreducibleUnit(NamedUnit):
1846     """
1847     Irreducible units are the units that all other units are defined
1848     in terms of.
1849 
1850     Examples are meters, seconds, kilograms, amperes, etc.  There is
1851     only once instance of such a unit per type.
1852     """
1853 
1854     def __reduce__(self):
1855         # When IrreducibleUnit objects are passed to other processes
1856         # over multiprocessing, they need to be recreated to be the
1857         # ones already in the subprocesses' namespace, not new
1858         # objects, or they will be considered "unconvertible".
1859         # Therefore, we have a custom pickler/unpickler that
1860         # understands how to recreate the Unit on the other side.
1861         registry = get_current_unit_registry().registry
1862         return (_recreate_irreducible_unit,
1863                 (self.__class__, list(self.names), self.name in registry),
1864                 self.__getstate__())
1865 
1866     @property
1867     def represents(self):
1868         """The unit that this named unit represents.
1869 
1870         For an irreducible unit, that is always itself.
1871         """
1872         return self
1873 
1874     def decompose(self, bases=set()):
1875         if len(bases) and self not in bases:
1876             for base in bases:
1877                 try:
1878                     scale = self._to(base)
1879                 except UnitsError:
1880                     pass
1881                 else:
1882                     if is_effectively_unity(scale):
1883                         return base
1884                     else:
1885                         return CompositeUnit(scale, [base], [1],
1886                                              _error_check=False)
1887 
1888             raise UnitConversionError(
1889                 f"Unit {self} can not be decomposed into the requested bases")
1890 
1891         return self
1892 
1893 
1894 class UnrecognizedUnit(IrreducibleUnit):
1895     """
1896     A unit that did not parse correctly.  This allows for
1897     round-tripping it as a string, but no unit operations actually work
1898     on it.
1899 
1900     Parameters
1901     ----------
1902     st : str
1903         The name of the unit.
1904     """
1905     # For UnrecognizedUnits, we want to use "standard" Python
1906     # pickling, not the special case that is used for
1907     # IrreducibleUnits.
1908     __reduce__ = object.__reduce__
1909 
1910     def __repr__(self):
1911         return f"UnrecognizedUnit({str(self)})"
1912 
1913     def __bytes__(self):
1914         return self.name.encode('ascii', 'replace')
1915 
1916     def __str__(self):
1917         return self.name
1918 
1919     def to_string(self, format=None):
1920         return self.name
1921 
1922     def _unrecognized_operator(self, *args, **kwargs):
1923         raise ValueError(
1924             "The unit {!r} is unrecognized, so all arithmetic operations "
1925             "with it are invalid.".format(self.name))
1926 
1927     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = __lt__ = \
1928         __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1929 
1930     def __eq__(self, other):
1931         try:
1932             other = Unit(other, parse_strict='silent')
1933         except (ValueError, UnitsError, TypeError):
1934             return NotImplemented
1935 
1936         return isinstance(other, type(self)) and self.name == other.name
1937 
1938     def __ne__(self, other):
1939         return not (self == other)
1940 
1941     def is_equivalent(self, other, equivalencies=None):
1942         self._normalize_equivalencies(equivalencies)
1943         return self == other
1944 
1945     def _get_converter(self, other, equivalencies=None):
1946         self._normalize_equivalencies(equivalencies)
1947         raise ValueError(
1948             "The unit {!r} is unrecognized.  It can not be converted "
1949             "to other units.".format(self.name))
1950 
1951     def get_format_name(self, format):
1952         return self.name
1953 
1954     def is_unity(self):
1955         return False
1956 
1957 
1958 class _UnitMetaClass(type):
1959     """
1960     This metaclass exists because the Unit constructor should
1961     sometimes return instances that already exist.  This "overrides"
1962     the constructor before the new instance is actually created, so we
1963     can return an existing one.
1964     """
1965 
1966     def __call__(self, s="", represents=None, format=None, namespace=None,
1967                  doc=None, parse_strict='raise'):
1968 
1969         # Short-circuit if we're already a unit
1970         if hasattr(s, '_get_physical_type_id'):
1971             return s
1972 
1973         # turn possible Quantity input for s or represents into a Unit
1974         from .quantity import Quantity
1975 
1976         if isinstance(represents, Quantity):
1977             if is_effectively_unity(represents.value):
1978                 represents = represents.unit
1979             else:
1980                 represents = CompositeUnit(represents.value *
1981                                            represents.unit.scale,
1982                                            bases=represents.unit.bases,
1983                                            powers=represents.unit.powers,
1984                                            _error_check=False)
1985 
1986         if isinstance(s, Quantity):
1987             if is_effectively_unity(s.value):
1988                 s = s.unit
1989             else:
1990                 s = CompositeUnit(s.value * s.unit.scale,
1991                                   bases=s.unit.bases,
1992                                   powers=s.unit.powers,
1993                                   _error_check=False)
1994 
1995         # now decide what we really need to do; define derived Unit?
1996         if isinstance(represents, UnitBase):
1997             # This has the effect of calling the real __new__ and
1998             # __init__ on the Unit class.
1999             return super().__call__(
2000                 s, represents, format=format, namespace=namespace, doc=doc)
2001 
2002         # or interpret a Quantity (now became unit), string or number?
2003         if isinstance(s, UnitBase):
2004             return s
2005 
2006         elif isinstance(s, (bytes, str)):
2007             if len(s.strip()) == 0:
2008                 # Return the NULL unit
2009                 return dimensionless_unscaled
2010 
2011             if format is None:
2012                 format = unit_format.Generic
2013 
2014             f = unit_format.get_format(format)
2015             if isinstance(s, bytes):
2016                 s = s.decode('ascii')
2017 
2018             try:
2019                 return f.parse(s)
2020             except NotImplementedError:
2021                 raise
2022             except Exception as e:
2023                 if parse_strict == 'silent':
2024                     pass
2025                 else:
2026                     # Deliberately not issubclass here. Subclasses
2027                     # should use their name.
2028                     if f is not unit_format.Generic:
2029                         format_clause = f.name + ' '
2030                     else:
2031                         format_clause = ''
2032                     msg = ("'{}' did not parse as {}unit: {} "
2033                            "If this is meant to be a custom unit, "
2034                            "define it with 'u.def_unit'. To have it "
2035                            "recognized inside a file reader or other code, "
2036                            "enable it with 'u.add_enabled_units'. "
2037                            "For details, see "
2038                            "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2039                            .format(s, format_clause, str(e)))
2040                     if parse_strict == 'raise':
2041                         raise ValueError(msg)
2042                     elif parse_strict == 'warn':
2043                         warnings.warn(msg, UnitsWarning)
2044                     else:
2045                         raise ValueError("'parse_strict' must be 'warn', "
2046                                          "'raise' or 'silent'")
2047                 return UnrecognizedUnit(s)
2048 
2049         elif isinstance(s, (int, float, np.floating, np.integer)):
2050             return CompositeUnit(s, [], [], _error_check=False)
2051 
2052         elif isinstance(s, tuple):
2053             from .structured import StructuredUnit
2054             return StructuredUnit(s)
2055 
2056         elif s is None:
2057             raise TypeError("None is not a valid Unit")
2058 
2059         else:
2060             raise TypeError(f"{s} can not be converted to a Unit")
2061 
2062 
2063 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2064     """
2065     The main unit class.
2066 
2067     There are a number of different ways to construct a Unit, but
2068     always returns a `UnitBase` instance.  If the arguments refer to
2069     an already-existing unit, that existing unit instance is returned,
2070     rather than a new one.
2071 
2072     - From a string::
2073 
2074         Unit(s, format=None, parse_strict='silent')
2075 
2076       Construct from a string representing a (possibly compound) unit.
2077 
2078       The optional `format` keyword argument specifies the format the
2079       string is in, by default ``"generic"``.  For a description of
2080       the available formats, see `astropy.units.format`.
2081 
2082       The optional ``parse_strict`` keyword controls what happens when an
2083       unrecognized unit string is passed in.  It may be one of the following:
2084 
2085          - ``'raise'``: (default) raise a ValueError exception.
2086 
2087          - ``'warn'``: emit a Warning, and return an
2088            `UnrecognizedUnit` instance.
2089 
2090          - ``'silent'``: return an `UnrecognizedUnit` instance.
2091 
2092     - From a number::
2093 
2094         Unit(number)
2095 
2096       Creates a dimensionless unit.
2097 
2098     - From a `UnitBase` instance::
2099 
2100         Unit(unit)
2101 
2102       Returns the given unit unchanged.
2103 
2104     - From no arguments::
2105 
2106         Unit()
2107 
2108       Returns the dimensionless unit.
2109 
2110     - The last form, which creates a new `Unit` is described in detail
2111       below.
2112 
2113     See also: https://docs.astropy.org/en/stable/units/
2114 
2115     Parameters
2116     ----------
2117     st : str or list of str
2118         The name of the unit.  If a list, the first element is the
2119         canonical (short) name, and the rest of the elements are
2120         aliases.
2121 
2122     represents : UnitBase instance
2123         The unit that this named unit represents.
2124 
2125     doc : str, optional
2126         A docstring describing the unit.
2127 
2128     format : dict, optional
2129         A mapping to format-specific representations of this unit.
2130         For example, for the ``Ohm`` unit, it might be nice to have it
2131         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2132         case, `format` argument should be set to::
2133 
2134             {'latex': r'\\Omega'}
2135 
2136     namespace : dict, optional
2137         When provided, inject the unit (and all of its aliases) into
2138         the given namespace.
2139 
2140     Raises
2141     ------
2142     ValueError
2143         If any of the given unit names are already in the registry.
2144 
2145     ValueError
2146         If any of the given unit names are not valid Python tokens.
2147     """
2148 
2149     def __init__(self, st, represents=None, doc=None,
2150                  format=None, namespace=None):
2151 
2152         represents = Unit(represents)
2153         self._represents = represents
2154 
2155         NamedUnit.__init__(self, st, namespace=namespace, doc=doc,
2156                            format=format)
2157 
2158     @property
2159     def represents(self):
2160         """The unit that this named unit represents."""
2161         return self._represents
2162 
2163     def decompose(self, bases=set()):
2164         return self._represents.decompose(bases=bases)
2165 
2166     def is_unity(self):
2167         return self._represents.is_unity()
2168 
2169     def __hash__(self):
2170         if self._hash is None:
2171             self._hash = hash((self.name, self._represents))
2172         return self._hash
2173 
2174     @classmethod
2175     def _from_physical_type_id(cls, physical_type_id):
2176         # get string bases and powers from the ID tuple
2177         bases = [cls(base) for base, _ in physical_type_id]
2178         powers = [power for _, power in physical_type_id]
2179 
2180         if len(physical_type_id) == 1 and powers[0] == 1:
2181             unit = bases[0]
2182         else:
2183             unit = CompositeUnit(1, bases, powers,
2184                                  _error_check=False)
2185 
2186         return unit
2187 
2188 
2189 class PrefixUnit(Unit):
2190     """
2191     A unit that is simply a SI-prefixed version of another unit.
2192 
2193     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2194 
2195     The constructor is the same as for `Unit`.
2196     """
2197 
2198 
2199 class CompositeUnit(UnitBase):
2200     """
2201     Create a composite unit using expressions of previously defined
2202     units.
2203 
2204     Direct use of this class is not recommended. Instead use the
2205     factory function `Unit` and arithmetic operators to compose
2206     units.
2207 
2208     Parameters
2209     ----------
2210     scale : number
2211         A scaling factor for the unit.
2212 
2213     bases : sequence of `UnitBase`
2214         A sequence of units this unit is composed of.
2215 
2216     powers : sequence of numbers
2217         A sequence of powers (in parallel with ``bases``) for each
2218         of the base units.
2219     """
2220     _decomposed_cache = None
2221 
2222     def __init__(self, scale, bases, powers, decompose=False,
2223                  decompose_bases=set(), _error_check=True):
2224         # There are many cases internal to astropy.units where we
2225         # already know that all the bases are Unit objects, and the
2226         # powers have been validated.  In those cases, we can skip the
2227         # error checking for performance reasons.  When the private
2228         # kwarg `_error_check` is False, the error checking is turned
2229         # off.
2230         if _error_check:
2231             for base in bases:
2232                 if not isinstance(base, UnitBase):
2233                     raise TypeError(
2234                         "bases must be sequence of UnitBase instances")
2235             powers = [validate_power(p) for p in powers]
2236 
2237         if not decompose and len(bases) == 1 and powers[0] >= 0:
2238             # Short-cut; with one unit there's nothing to expand and gather,
2239             # as that has happened already when creating the unit.  But do only
2240             # positive powers, since for negative powers we need to re-sort.
2241             unit = bases[0]
2242             power = powers[0]
2243             if power == 1:
2244                 scale *= unit.scale
2245                 self._bases = unit.bases
2246                 self._powers = unit.powers
2247             elif power == 0:
2248                 self._bases = []
2249                 self._powers = []
2250             else:
2251                 scale *= unit.scale ** power
2252                 self._bases = unit.bases
2253                 self._powers = [operator.mul(*resolve_fractions(p, power))
2254                                 for p in unit.powers]
2255 
2256             self._scale = sanitize_scale(scale)
2257         else:
2258             # Regular case: use inputs as preliminary scale, bases, and powers,
2259             # then "expand and gather" identical bases, sanitize the scale, &c.
2260             self._scale = scale
2261             self._bases = bases
2262             self._powers = powers
2263             self._expand_and_gather(decompose=decompose,
2264                                     bases=decompose_bases)
2265 
2266     def __repr__(self):
2267         if len(self._bases):
2268             return super().__repr__()
2269         else:
2270             if self._scale != 1.0:
2271                 return f'Unit(dimensionless with a scale of {self._scale})'
2272             else:
2273                 return 'Unit(dimensionless)'
2274 
2275     @property
2276     def scale(self):
2277         """
2278         Return the scale of the composite unit.
2279         """
2280         return self._scale
2281 
2282     @property
2283     def bases(self):
2284         """
2285         Return the bases of the composite unit.
2286         """
2287         return self._bases
2288 
2289     @property
2290     def powers(self):
2291         """
2292         Return the powers of the composite unit.
2293         """
2294         return self._powers
2295 
2296     def _expand_and_gather(self, decompose=False, bases=set()):
2297         def add_unit(unit, power, scale):
2298             if bases and unit not in bases:
2299                 for base in bases:
2300                     try:
2301                         scale *= unit._to(base) ** power
2302                     except UnitsError:
2303                         pass
2304                     else:
2305                         unit = base
2306                         break
2307 
2308             if unit in new_parts:
2309                 a, b = resolve_fractions(new_parts[unit], power)
2310                 new_parts[unit] = a + b
2311             else:
2312                 new_parts[unit] = power
2313             return scale
2314 
2315         new_parts = {}
2316         scale = self._scale
2317 
2318         for b, p in zip(self._bases, self._powers):
2319             if decompose and b not in bases:
2320                 b = b.decompose(bases=bases)
2321 
2322             if isinstance(b, CompositeUnit):
2323                 scale *= b._scale ** p
2324                 for b_sub, p_sub in zip(b._bases, b._powers):
2325                     a, b = resolve_fractions(p_sub, p)
2326                     scale = add_unit(b_sub, a * b, scale)
2327             else:
2328                 scale = add_unit(b, p, scale)
2329 
2330         new_parts = [x for x in new_parts.items() if x[1] != 0]
2331         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))
2332 
2333         self._bases = [x[0] for x in new_parts]
2334         self._powers = [x[1] for x in new_parts]
2335         self._scale = sanitize_scale(scale)
2336 
2337     def __copy__(self):
2338         """
2339         For compatibility with python copy module.
2340         """
2341         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2342 
2343     def decompose(self, bases=set()):
2344         if len(bases) == 0 and self._decomposed_cache is not None:
2345             return self._decomposed_cache
2346 
2347         for base in self.bases:
2348             if (not isinstance(base, IrreducibleUnit) or
2349                     (len(bases) and base not in bases)):
2350                 break
2351         else:
2352             if len(bases) == 0:
2353                 self._decomposed_cache = self
2354             return self
2355 
2356         x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True,
2357                           decompose_bases=bases)
2358         if len(bases) == 0:
2359             self._decomposed_cache = x
2360         return x
2361 
2362     def is_unity(self):
2363         unit = self.decompose()
2364         return len(unit.bases) == 0 and unit.scale == 1.0
2365 
2366 
2367 si_prefixes = [
2368     (['Y'], ['yotta'], 1e24),
2369     (['Z'], ['zetta'], 1e21),
2370     (['E'], ['exa'], 1e18),
2371     (['P'], ['peta'], 1e15),
2372     (['T'], ['tera'], 1e12),
2373     (['G'], ['giga'], 1e9),
2374     (['M'], ['mega'], 1e6),
2375     (['k'], ['kilo'], 1e3),
2376     (['h'], ['hecto'], 1e2),
2377     (['da'], ['deka', 'deca'], 1e1),
2378     (['d'], ['deci'], 1e-1),
2379     (['c'], ['centi'], 1e-2),
2380     (['m'], ['milli'], 1e-3),
2381     (['u'], ['micro'], 1e-6),
2382     (['n'], ['nano'], 1e-9),
2383     (['p'], ['pico'], 1e-12),
2384     (['f'], ['femto'], 1e-15),
2385     (['a'], ['atto'], 1e-18),
2386     (['z'], ['zepto'], 1e-21),
2387     (['y'], ['yocto'], 1e-24)
2388 ]
2389 
2390 
2391 binary_prefixes = [
2392     (['Ki'], ['kibi'], 2. ** 10),
2393     (['Mi'], ['mebi'], 2. ** 20),
2394     (['Gi'], ['gibi'], 2. ** 30),
2395     (['Ti'], ['tebi'], 2. ** 40),
2396     (['Pi'], ['pebi'], 2. ** 50),
2397     (['Ei'], ['exbi'], 2. ** 60)
2398 ]
2399 
2400 
2401 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2402     """
2403     Set up all of the standard metric prefixes for a unit.  This
2404     function should not be used directly, but instead use the
2405     `prefixes` kwarg on `def_unit`.
2406 
2407     Parameters
2408     ----------
2409     excludes : list of str, optional
2410         Any prefixes to exclude from creation to avoid namespace
2411         collisions.
2412 
2413     namespace : dict, optional
2414         When provided, inject the unit (and all of its aliases) into
2415         the given namespace dictionary.
2416 
2417     prefixes : list, optional
2418         When provided, it is a list of prefix definitions of the form:
2419 
2420             (short_names, long_tables, factor)
2421     """
2422     if prefixes is True:
2423         prefixes = si_prefixes
2424     elif prefixes is False:
2425         prefixes = []
2426 
2427     for short, full, factor in prefixes:
2428         names = []
2429         format = {}
2430         for prefix in short:
2431             if prefix in excludes:
2432                 continue
2433 
2434             for alias in u.short_names:
2435                 names.append(prefix + alias)
2436 
2437                 # This is a hack to use Greek mu as a prefix
2438                 # for some formatters.
2439                 if prefix == 'u':
2440                     format['latex'] = r'\mu ' + u.get_format_name('latex')
2441                     format['unicode'] = '\N{MICRO SIGN}' + u.get_format_name('unicode')
2442 
2443                 for key, val in u._format.items():
2444                     format.setdefault(key, prefix + val)
2445 
2446         for prefix in full:
2447             if prefix in excludes:
2448                 continue
2449 
2450             for alias in u.long_names:
2451                 names.append(prefix + alias)
2452 
2453         if len(names):
2454             PrefixUnit(names, CompositeUnit(factor, [u], [1],
2455                                             _error_check=False),
2456                        namespace=namespace, format=format)
2457 
2458 
2459 def def_unit(s, represents=None, doc=None, format=None, prefixes=False,
2460              exclude_prefixes=[], namespace=None):
2461     """
2462     Factory function for defining new units.
2463 
2464     Parameters
2465     ----------
2466     s : str or list of str
2467         The name of the unit.  If a list, the first element is the
2468         canonical (short) name, and the rest of the elements are
2469         aliases.
2470 
2471     represents : UnitBase instance, optional
2472         The unit that this named unit represents.  If not provided,
2473         a new `IrreducibleUnit` is created.
2474 
2475     doc : str, optional
2476         A docstring describing the unit.
2477 
2478     format : dict, optional
2479         A mapping to format-specific representations of this unit.
2480         For example, for the ``Ohm`` unit, it might be nice to
2481         have it displayed as ``\\Omega`` by the ``latex``
2482         formatter.  In that case, `format` argument should be set
2483         to::
2484 
2485             {'latex': r'\\Omega'}
2486 
2487     prefixes : bool or list, optional
2488         When `True`, generate all of the SI prefixed versions of the
2489         unit as well.  For example, for a given unit ``m``, will
2490         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2491         prefix definitions of the form:
2492 
2493             (short_names, long_tables, factor)
2494 
2495         Default is `False`.  This function always returns the base
2496         unit object, even if multiple scaled versions of the unit were
2497         created.
2498 
2499     exclude_prefixes : list of str, optional
2500         If any of the SI prefixes need to be excluded, they may be
2501         listed here.  For example, ``Pa`` can be interpreted either as
2502         "petaannum" or "Pascal".  Therefore, when defining the
2503         prefixes for ``a``, ``exclude_prefixes`` should be set to
2504         ``["P"]``.
2505 
2506     namespace : dict, optional
2507         When provided, inject the unit (and all of its aliases and
2508         prefixes), into the given namespace dictionary.
2509 
2510     Returns
2511     -------
2512     unit : `~astropy.units.UnitBase`
2513         The newly-defined unit, or a matching unit that was already
2514         defined.
2515     """
2516 
2517     if represents is not None:
2518         result = Unit(s, represents, namespace=namespace, doc=doc,
2519                       format=format)
2520     else:
2521         result = IrreducibleUnit(
2522             s, namespace=namespace, doc=doc, format=format)
2523 
2524     if prefixes:
2525         _add_prefixes(result, excludes=exclude_prefixes, namespace=namespace,
2526                       prefixes=prefixes)
2527     return result
2528 
2529 
2530 def _condition_arg(value):
2531     """
2532     Validate value is acceptable for conversion purposes.
2533 
2534     Will convert into an array if not a scalar, and can be converted
2535     into an array
2536 
2537     Parameters
2538     ----------
2539     value : int or float value, or sequence of such values
2540 
2541     Returns
2542     -------
2543     Scalar value or numpy array
2544 
2545     Raises
2546     ------
2547     ValueError
2548         If value is not as expected
2549     """
2550     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2551         return value
2552 
2553     avalue = np.array(value)
2554     if avalue.dtype.kind not in ['i', 'f', 'c']:
2555         raise ValueError("Value not scalar compatible or convertible to "
2556                          "an int, float, or complex array")
2557     return avalue
2558 
2559 
2560 def unit_scale_converter(val):
2561     """Function that just multiplies the value by unity.
2562 
2563     This is a separate function so it can be recognized and
2564     discarded in unit conversion.
2565     """
2566     return 1. * _condition_arg(val)
2567 
2568 
2569 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2570 # Abbreviation of the above, see #1980
2571 one = dimensionless_unscaled
2572 
2573 # Maintain error in old location for backward compatibility
2574 # TODO: Is this still needed? Should there be a deprecation warning?
2575 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>Although not directly a bug, enhancing the use of 'def_unit' or a similar mechanism within cosmology parameters to specify their MathJax representation is required. This enhancement means improving or leveraging the 'format' attribute in cosmology parameters, ensuring that when these parameters are converted into HTML table entries, their MathJax representation is used.</intended_behavior>]
2025-10-15 15:25:38.848 | INFO     | Search completed. Bug locations: [<file>astropy/cosmology/core.py</file>
<class>Cosmology</class>
<method>None</method>
<code>
50 class Cosmology(metaclass=abc.ABCMeta):
51     """Base-class for all Cosmologies.
52 
53     Parameters
54     ----------
55     *args
56         Arguments into the cosmology; used by subclasses, not this base class.
57     name : str or None (optional, keyword-only)
58         The name of the cosmology.
59     meta : dict or None (optional, keyword-only)
60         Metadata for the cosmology, e.g., a reference.
61     **kwargs
62         Arguments into the cosmology; used by subclasses, not this base class.
63 
64     Notes
65     -----
66     Class instances are static -- you cannot (and should not) change the values
67     of the parameters.  That is, all of the above attributes (except meta) are
68     read only.
69 
70     For details on how to create performant custom subclasses, see the
71     documentation on :ref:`astropy-cosmology-fast-integrals`.
72     """
73 
74     meta = MetaData()
75 
76     # Unified I/O object interchange methods
77     from_format = UnifiedReadWriteMethod(CosmologyFromFormat)
78     to_format = UnifiedReadWriteMethod(CosmologyToFormat)
79 
80     # Unified I/O read and write methods
81     read = UnifiedReadWriteMethod(CosmologyRead)
82     write = UnifiedReadWriteMethod(CosmologyWrite)
83 
84     # Parameters
85     __parameters__: tuple[str, ...] = ()
86     __all_parameters__: tuple[str, ...] = ()
87 
88     # ---------------------------------------------------------------
89 
90     def __init_subclass__(cls):
91         super().__init_subclass__()
92 
93         # -------------------
94         # Parameters
95 
96         # Get parameters that are still Parameters, either in this class or above.
97         parameters = []
98         derived_parameters = []
99         for n in cls.__parameters__:
100             p = getattr(cls, n)
101             if isinstance(p, Parameter):
102                 derived_parameters.append(n) if p.derived else parameters.append(n)
103 
104         # Add new parameter definitions
105         for n, v in cls.__dict__.items():
106             if n in parameters or n.startswith("_") or not isinstance(v, Parameter):
107                 continue
108             derived_parameters.append(n) if v.derived else parameters.append(n)
109 
110         # reorder to match signature
111         ordered = [parameters.pop(parameters.index(n))
112                    for n in cls._init_signature.parameters.keys()
113                    if n in parameters]
114         parameters = ordered + parameters  # place "unordered" at the end
115         cls.__parameters__ = tuple(parameters)
116         cls.__all_parameters__ = cls.__parameters__ + tuple(derived_parameters)
117 
118         # -------------------
119         # register as a Cosmology subclass
120         _COSMOLOGY_CLASSES[cls.__qualname__] = cls
121 
122     @classproperty(lazy=True)
123     def _init_signature(cls):
124         """Initialization signature (without 'self')."""
125         # get signature, dropping "self" by taking arguments [1:]
126         sig = inspect.signature(cls.__init__)
127         sig = sig.replace(parameters=list(sig.parameters.values())[1:])
128         return sig
129 
130     # ---------------------------------------------------------------
131 
132     def __init__(self, name=None, meta=None):
133         self._name = str(name) if name is not None else name
134         self.meta.update(meta or {})
135 
136     @property
137     def name(self):
138         """The name of the Cosmology instance."""
139         return self._name
140 
141     @property
142     @abc.abstractmethod
143     def is_flat(self):
144         """
145         Return bool; `True` if the cosmology is flat.
146         This is abstract and must be defined in subclasses.
147         """
148         raise NotImplementedError("is_flat is not implemented")
149 
150     def clone(self, *, meta=None, **kwargs):
151         """Returns a copy of this object with updated parameters, as specified.
152 
153         This cannot be used to change the type of the cosmology, so ``clone()``
154         cannot be used to change between flat and non-flat cosmologies.
155 
156         Parameters
157         ----------
158         meta : mapping or None (optional, keyword-only)
159             Metadata that will update the current metadata.
160         **kwargs
161             Cosmology parameter (and name) modifications. If any parameter is
162             changed and a new name is not given, the name will be set to "[old
163             name] (modified)".
164 
165         Returns
166         -------
167         newcosmo : `~astropy.cosmology.Cosmology` subclass instance
168             A new instance of this class with updated parameters as specified.
169             If no arguments are given, then a reference to this object is
170             returned instead of copy.
171 
172         Examples
173         --------
174         To make a copy of the ``Planck13`` cosmology with a different matter
175         density (``Om0``), and a new name:
176 
177             >>> from astropy.cosmology import Planck13
178             >>> Planck13.clone(name="Modified Planck 2013", Om0=0.35)
179             FlatLambdaCDM(name="Modified Planck 2013", H0=67.77 km / (Mpc s),
180                           Om0=0.35, ...
181 
182         If no name is specified, the new name will note the modification.
183 
184             >>> Planck13.clone(Om0=0.35).name
185             'Planck13 (modified)'
186         """
187         # Quick return check, taking advantage of the Cosmology immutability.
188         if meta is None and not kwargs:
189             return self
190 
191         # There are changed parameter or metadata values.
192         # The name needs to be changed accordingly, if it wasn't already.
193         _modname = self.name + " (modified)"
194         kwargs.setdefault("name", (_modname if self.name is not None else None))
195 
196         # mix new meta into existing, preferring the former.
197         meta = meta if meta is not None else {}
198         new_meta = {**self.meta, **meta}
199         # Mix kwargs into initial arguments, preferring the former.
200         new_init = {**self._init_arguments, "meta": new_meta, **kwargs}
201         # Create BoundArgument to handle args versus kwargs.
202         # This also handles all errors from mismatched arguments
203         ba = self._init_signature.bind_partial(**new_init)
204         # Instantiate, respecting args vs kwargs
205         cloned = type(self)(*ba.args, **ba.kwargs)
206 
207         # Check if nothing has changed.
208         # TODO! or should return self?
209         if (cloned.name == _modname) and not meta and cloned.is_equivalent(self):
210             cloned._name = self.name
211 
212         return cloned
213 
214     @property
215     def _init_arguments(self):
216         # parameters
217         kw = {n: getattr(self, n) for n in self.__parameters__}
218 
219         # other info
220         kw["name"] = self.name
221         kw["meta"] = self.meta
222 
223         return kw
224 
225     # ---------------------------------------------------------------
226     # comparison methods
227 
228     def is_equivalent(self, other: Any, /, *, format: _FormatType = False) -> bool:
229         r"""Check equivalence between Cosmologies.
230 
231         Two cosmologies may be equivalent even if not the same class.
232         For example, an instance of ``LambdaCDM`` might have :math:`\Omega_0=1`
233         and :math:`\Omega_k=0` and therefore be flat, like ``FlatLambdaCDM``.
234 
235         Parameters
236         ----------
237         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
238             The object to which to compare.
239         format : bool or None or str, optional keyword-only
240             Whether to allow, before equivalence is checked, the object to be
241             converted to a |Cosmology|. This allows, e.g. a |Table| to be
242             equivalent to a Cosmology.
243             `False` (default) will not allow conversion. `True` or `None` will,
244             and will use the auto-identification to try to infer the correct
245             format. A `str` is assumed to be the correct format to use when
246             converting.
247             ``format`` is broadcast to match the shape of ``other``.
248             Note that the cosmology arguments are not broadcast against
249             ``format``, so it cannot determine the output shape.
250 
251         Returns
252         -------
253         bool
254             True if cosmologies are equivalent, False otherwise.
255 
256         Examples
257         --------
258         Two cosmologies may be equivalent even if not of the same class.
259         In this examples the ``LambdaCDM`` has ``Ode0`` set to the same value
260         calculated in ``FlatLambdaCDM``.
261 
262             >>> import astropy.units as u
263             >>> from astropy.cosmology import LambdaCDM, FlatLambdaCDM
264             >>> cosmo1 = LambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, 0.7)
265             >>> cosmo2 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3)
266             >>> cosmo1.is_equivalent(cosmo2)
267             True
268 
269         While in this example, the cosmologies are not equivalent.
270 
271             >>> cosmo3 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, Tcmb0=3 * u.K)
272             >>> cosmo3.is_equivalent(cosmo2)
273             False
274 
275         Also, using the keyword argument, the notion of equivalence is extended
276         to any Python object that can be converted to a |Cosmology|.
277 
278             >>> from astropy.cosmology import Planck18
279             >>> tbl = Planck18.to_format("astropy.table")
280             >>> Planck18.is_equivalent(tbl, format=True)
281             True
282 
283         The list of valid formats, e.g. the |Table| in this example, may be
284         checked with ``Cosmology.from_format.list_formats()``.
285 
286         As can be seen in the list of formats, not all formats can be
287         auto-identified by ``Cosmology.from_format.registry``. Objects of
288         these kinds can still be checked for equivalence, but the correct
289         format string must be used.
290 
291             >>> tbl = Planck18.to_format("yaml")
292             >>> Planck18.is_equivalent(tbl, format="yaml")
293             True
294         """
295         from .funcs import cosmology_equal
296 
297         try:
298             return cosmology_equal(self, other, format=(None, format), allow_equivalent=True)
299         except Exception:
300             # `is_equivalent` allows `other` to be any object and returns False
301             # if `other` cannot be converted to a Cosmology, rather than
302             # raising an Exception.
303             return False
304 
305     def __equiv__(self, other: Any, /) -> bool:
306         """Cosmology equivalence. Use ``.is_equivalent()`` for actual check!
307 
308         Parameters
309         ----------
310         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
311             The object in which to compare.
312 
313         Returns
314         -------
315         bool or `NotImplemented`
316             `NotImplemented` if ``other`` is from a different class.
317             `True` if ``other`` is of the same class and has matching parameters
318             and parameter values.
319             `False` otherwise.
320         """
321         if other.__class__ is not self.__class__:
322             return NotImplemented  # allows other.__equiv__
323 
324         # Check all parameters in 'other' match those in 'self' and 'other' has
325         # no extra parameters (latter part should never happen b/c same class)
326         params_eq = (set(self.__all_parameters__) == set(other.__all_parameters__)
327                      and all(np.all(getattr(self, k) == getattr(other, k))
328                              for k in self.__all_parameters__))
329         return params_eq
330 
331     def __eq__(self, other: Any, /) -> bool:
332         """Check equality between Cosmologies.
333 
334         Checks the Parameters and immutable fields (i.e. not "meta").
335 
336         Parameters
337         ----------
338         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only
339             The object in which to compare.
340 
341         Returns
342         -------
343         bool
344             `True` if Parameters and names are the same, `False` otherwise.
345         """
346         if other.__class__ is not self.__class__:
347             return NotImplemented  # allows other.__eq__
348 
349         eq = (
350             # non-Parameter checks: name
351             self.name == other.name
352             # check all parameters in 'other' match those in 'self' and 'other'
353             # has no extra parameters (latter part should never happen b/c same
354             # class) TODO! element-wise when there are array cosmologies
355             and set(self.__all_parameters__) == set(other.__all_parameters__)
356             and all(np.all(getattr(self, k) == getattr(other, k))
357                     for k in self.__all_parameters__)
358         )
359 
360         return eq
361 
362     # ---------------------------------------------------------------
363 
364     def __repr__(self):
365         namelead = f"{self.__class__.__qualname__}("
366         if self.name is not None:
367             namelead += f"name=\"{self.name}\", "
368         # nicely formatted parameters
369         fmtps = (f'{k}={getattr(self, k)}' for k in self.__parameters__)
370 
371         return namelead + ", ".join(fmtps) + ")"
372 
373     def __astropy_table__(self, cls, copy, **kwargs):
374         """Return a `~astropy.table.Table` of type ``cls``.
375 
376         Parameters
377         ----------
378         cls : type
379             Astropy ``Table`` class or subclass.
380         copy : bool
381             Ignored.
382         **kwargs : dict, optional
383             Additional keyword arguments. Passed to ``self.to_format()``.
384             See ``Cosmology.to_format.help("astropy.table")`` for allowed kwargs.
385 
386         Returns
387         -------
388         `astropy.table.Table` or subclass instance
389             Instance of type ``cls``.
390         """
391         return self.to_format("astropy.table", cls=cls, **kwargs)

</code><intended_behavior>Implement a new method, 'write_html', within the 'Cosmology' class. This method should leverage the 'to_table' method to convert the cosmology instance into a tabular format suitable for HTML representation. Then, format this table using MathJax for any relevant cosmological parameters with the assistance of a new feature or extension utilizing 'QTable.write(..., format='html')'. The new method should smoothly integrate with existing IO capabilities, meaning it should use or extend the existing framework ('UnifiedReadWriteMethod') to support the HTML format, ensuring consistency with how other formats are handled.</intended_behavior>, <file>astropy/cosmology/io/table.py</file>
<class>None</class>
<method>to_table</method>
<code>
139 def to_table(cosmology, *args, cls=QTable, cosmology_in_meta=True):
140     """Serialize the cosmology into a `~astropy.table.QTable`.
141 
142     Parameters
143     ----------
144     cosmology : `~astropy.cosmology.Cosmology` subclass instance
145     *args
146         Not used. Needed for compatibility with
147         `~astropy.io.registry.UnifiedReadWriteMethod`
148     cls : type (optional, keyword-only)
149         Astropy :class:`~astropy.table.Table` class or subclass type to return.
150         Default is :class:`~astropy.table.QTable`.
151     cosmology_in_meta : bool
152         Whether to put the cosmology class in the Table metadata (if `True`,
153         default) or as the first column (if `False`).
154 
155     Returns
156     -------
157     `~astropy.table.QTable`
158         With columns for the cosmology parameters, and metadata and
159         cosmology class name in the Table's ``meta`` attribute
160 
161     Raises
162     ------
163     TypeError
164         If kwarg (optional) 'cls' is not a subclass of `astropy.table.Table`
165 
166     Examples
167     --------
168     A Cosmology as a `~astropy.table.QTable` will have the cosmology's name and
169     parameters as columns.
170 
171         >>> from astropy.cosmology import Planck18
172         >>> ct = Planck18.to_format("astropy.table")
173         >>> ct
174         <QTable length=1>
175           name        H0        Om0    Tcmb0    Neff      m_nu      Ob0
176                  km / (Mpc s)            K                 eV
177           str8     float64    float64 float64 float64  float64[3] float64
178         -------- ------------ ------- ------- ------- ----------- -------
179         Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897
180 
181     The cosmological class and other metadata, e.g. a paper reference, are in
182     the Table's metadata.
183 
184         >>> ct.meta
185         OrderedDict([..., ('cosmology', 'FlatLambdaCDM')])
186 
187     To move the cosmology class from the metadata to a Table row, set the
188     ``cosmology_in_meta`` argument to `False`:
189 
190         >>> Planck18.to_format("astropy.table", cosmology_in_meta=False)
191         <QTable length=1>
192           cosmology     name        H0        Om0    Tcmb0    Neff      m_nu      Ob0
193                                km / (Mpc s)            K                 eV
194             str13       str8     float64    float64 float64 float64  float64[3] float64
195         ------------- -------- ------------ ------- ------- ------- ----------- -------
196         FlatLambdaCDM Planck18        67.66 0.30966  2.7255   3.046 0.0 .. 0.06 0.04897
197 
198     Astropy recommends `~astropy.table.QTable` for tables with
199     `~astropy.units.Quantity` columns. However the returned type may be
200     overridden using the ``cls`` argument:
201 
202         >>> from astropy.table import Table
203         >>> Planck18.to_format("astropy.table", cls=Table)
204         <Table length=1>
205         ...
206     """
207     if not issubclass(cls, Table):
208         raise TypeError(f"'cls' must be a (sub)class of Table, not {type(cls)}")
209 
210     # Start by getting a map representation.
211     data = to_mapping(cosmology)
212     data["cosmology"] = data["cosmology"].__qualname__  # change to str
213 
214     # Metadata
215     meta = data.pop("meta")  # remove the meta
216     if cosmology_in_meta:
217         meta["cosmology"] = data.pop("cosmology")
218 
219     # Need to turn everything into something Table can process:
220     # - Column for Parameter
221     # - list for anything else
222     cosmo_cls = cosmology.__class__
223     for k, v in data.items():
224         if k in cosmology.__parameters__:
225             col = convert_parameter_to_column(getattr(cosmo_cls, k), v,
226                                               cosmology.meta.get(k))
227         else:
228             col = Column([v])
229         data[k] = col
230 
231     tbl = cls(data, meta=meta)
232     tbl.add_index("name", unique=True)
233     return tbl

</code><intended_behavior>Enhance the 'to_table' method (or create a helper function specifically for HTML output) to ensure it includes additional formatting details necessary for HTML representation, especially focusing on providing support for MathJax formatting. This may involve attaching metadata or custom formatting instructions to table columns based on cosmology parameters, utilizing the approach similar to 'def_unit' for specifying MathJax representations.</intended_behavior>, <file>astropy/units/core.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under a 3-clause BSD style license - see LICENSE.rst
2 
3 """
4 Core units classes and functions
5 """
6 
7 
8 import inspect
9 import operator
10 import textwrap
11 import warnings
12 
13 import numpy as np
14 
15 from astropy.utils.decorators import lazyproperty
16 from astropy.utils.exceptions import AstropyWarning
17 from astropy.utils.misc import isiterable
18 
19 from . import format as unit_format
20 from .utils import is_effectively_unity, resolve_fractions, sanitize_scale, validate_power
21 
22 __all__ = [
23     'UnitsError', 'UnitsWarning', 'UnitConversionError', 'UnitTypeError',
24     'UnitBase', 'NamedUnit', 'IrreducibleUnit', 'Unit', 'CompositeUnit',
25     'PrefixUnit', 'UnrecognizedUnit', 'def_unit', 'get_current_unit_registry',
26     'set_enabled_units', 'add_enabled_units',
27     'set_enabled_equivalencies', 'add_enabled_equivalencies',
28     'set_enabled_aliases', 'add_enabled_aliases',
29     'dimensionless_unscaled', 'one',
30 ]
31 
32 UNITY = 1.0
33 
34 
35 def _flatten_units_collection(items):
36     """
37     Given a list of sequences, modules or dictionaries of units, or
38     single units, return a flat set of all the units found.
39     """
40     if not isinstance(items, list):
41         items = [items]
42 
43     result = set()
44     for item in items:
45         if isinstance(item, UnitBase):
46             result.add(item)
47         else:
48             if isinstance(item, dict):
49                 units = item.values()
50             elif inspect.ismodule(item):
51                 units = vars(item).values()
52             elif isiterable(item):
53                 units = item
54             else:
55                 continue
56 
57             for unit in units:
58                 if isinstance(unit, UnitBase):
59                     result.add(unit)
60 
61     return result
62 
63 
64 def _normalize_equivalencies(equivalencies):
65     """
66     Normalizes equivalencies, ensuring each is a 4-tuple of the form::
67 
68     (from_unit, to_unit, forward_func, backward_func)
69 
70     Parameters
71     ----------
72     equivalencies : list of equivalency pairs
73 
74     Raises
75     ------
76     ValueError if an equivalency cannot be interpreted
77     """
78     if equivalencies is None:
79         return []
80 
81     normalized = []
82 
83     for i, equiv in enumerate(equivalencies):
84         if len(equiv) == 2:
85             funit, tunit = equiv
86             a = b = lambda x: x
87         elif len(equiv) == 3:
88             funit, tunit, a = equiv
89             b = a
90         elif len(equiv) == 4:
91             funit, tunit, a, b = equiv
92         else:
93             raise ValueError(
94                 f"Invalid equivalence entry {i}: {equiv!r}")
95         if not (funit is Unit(funit) and
96                 (tunit is None or tunit is Unit(tunit)) and
97                 callable(a) and
98                 callable(b)):
99             raise ValueError(
100                 f"Invalid equivalence entry {i}: {equiv!r}")
101         normalized.append((funit, tunit, a, b))
102 
103     return normalized
104 
105 
106 class _UnitRegistry:
107     """
108     Manages a registry of the enabled units.
109     """
110 
111     def __init__(self, init=[], equivalencies=[], aliases={}):
112 
113         if isinstance(init, _UnitRegistry):
114             # If passed another registry we don't need to rebuild everything.
115             # but because these are mutable types we don't want to create
116             # conflicts so everything needs to be copied.
117             self._equivalencies = init._equivalencies.copy()
118             self._aliases = init._aliases.copy()
119             self._all_units = init._all_units.copy()
120             self._registry = init._registry.copy()
121             self._non_prefix_units = init._non_prefix_units.copy()
122             # The physical type is a dictionary containing sets as values.
123             # All of these must be copied otherwise we could alter the old
124             # registry.
125             self._by_physical_type = {k: v.copy() for k, v in
126                                       init._by_physical_type.items()}
127 
128         else:
129             self._reset_units()
130             self._reset_equivalencies()
131             self._reset_aliases()
132             self.add_enabled_units(init)
133             self.add_enabled_equivalencies(equivalencies)
134             self.add_enabled_aliases(aliases)
135 
136     def _reset_units(self):
137         self._all_units = set()
138         self._non_prefix_units = set()
139         self._registry = {}
140         self._by_physical_type = {}
141 
142     def _reset_equivalencies(self):
143         self._equivalencies = set()
144 
145     def _reset_aliases(self):
146         self._aliases = {}
147 
148     @property
149     def registry(self):
150         return self._registry
151 
152     @property
153     def all_units(self):
154         return self._all_units
155 
156     @property
157     def non_prefix_units(self):
158         return self._non_prefix_units
159 
160     def set_enabled_units(self, units):
161         """
162         Sets the units enabled in the unit registry.
163 
164         These units are searched when using
165         `UnitBase.find_equivalent_units`, for example.
166 
167         Parameters
168         ----------
169         units : list of sequence, dict, or module
170             This is a list of things in which units may be found
171             (sequences, dicts or modules), or units themselves.  The
172             entire set will be "enabled" for searching through by
173             methods like `UnitBase.find_equivalent_units` and
174             `UnitBase.compose`.
175         """
176         self._reset_units()
177         return self.add_enabled_units(units)
178 
179     def add_enabled_units(self, units):
180         """
181         Adds to the set of units enabled in the unit registry.
182 
183         These units are searched when using
184         `UnitBase.find_equivalent_units`, for example.
185 
186         Parameters
187         ----------
188         units : list of sequence, dict, or module
189             This is a list of things in which units may be found
190             (sequences, dicts or modules), or units themselves.  The
191             entire set will be added to the "enabled" set for
192             searching through by methods like
193             `UnitBase.find_equivalent_units` and `UnitBase.compose`.
194         """
195         units = _flatten_units_collection(units)
196 
197         for unit in units:
198             # Loop through all of the names first, to ensure all of them
199             # are new, then add them all as a single "transaction" below.
200             for st in unit._names:
201                 if (st in self._registry and unit != self._registry[st]):
202                     raise ValueError(
203                         "Object with name {!r} already exists in namespace. "
204                         "Filter the set of units to avoid name clashes before "
205                         "enabling them.".format(st))
206 
207             for st in unit._names:
208                 self._registry[st] = unit
209 
210             self._all_units.add(unit)
211             if not isinstance(unit, PrefixUnit):
212                 self._non_prefix_units.add(unit)
213 
214             hash = unit._get_physical_type_id()
215             self._by_physical_type.setdefault(hash, set()).add(unit)
216 
217     def get_units_with_physical_type(self, unit):
218         """
219         Get all units in the registry with the same physical type as
220         the given unit.
221 
222         Parameters
223         ----------
224         unit : UnitBase instance
225         """
226         return self._by_physical_type.get(unit._get_physical_type_id(), set())
227 
228     @property
229     def equivalencies(self):
230         return list(self._equivalencies)
231 
232     def set_enabled_equivalencies(self, equivalencies):
233         """
234         Sets the equivalencies enabled in the unit registry.
235 
236         These equivalencies are used if no explicit equivalencies are given,
237         both in unit conversion and in finding equivalent units.
238 
239         This is meant in particular for allowing angles to be dimensionless.
240         Use with care.
241 
242         Parameters
243         ----------
244         equivalencies : list of tuple
245             List of equivalent pairs, e.g., as returned by
246             `~astropy.units.equivalencies.dimensionless_angles`.
247         """
248         self._reset_equivalencies()
249         return self.add_enabled_equivalencies(equivalencies)
250 
251     def add_enabled_equivalencies(self, equivalencies):
252         """
253         Adds to the set of equivalencies enabled in the unit registry.
254 
255         These equivalencies are used if no explicit equivalencies are given,
256         both in unit conversion and in finding equivalent units.
257 
258         This is meant in particular for allowing angles to be dimensionless.
259         Use with care.
260 
261         Parameters
262         ----------
263         equivalencies : list of tuple
264             List of equivalent pairs, e.g., as returned by
265             `~astropy.units.equivalencies.dimensionless_angles`.
266         """
267         # pre-normalize list to help catch mistakes
268         equivalencies = _normalize_equivalencies(equivalencies)
269         self._equivalencies |= set(equivalencies)
270 
271     @property
272     def aliases(self):
273         return self._aliases
274 
275     def set_enabled_aliases(self, aliases):
276         """
277         Set aliases for units.
278 
279         Parameters
280         ----------
281         aliases : dict of str, Unit
282             The aliases to set. The keys must be the string aliases, and values
283             must be the `astropy.units.Unit` that the alias will be mapped to.
284 
285         Raises
286         ------
287         ValueError
288             If the alias already defines a different unit.
289 
290         """
291         self._reset_aliases()
292         self.add_enabled_aliases(aliases)
293 
294     def add_enabled_aliases(self, aliases):
295         """
296         Add aliases for units.
297 
298         Parameters
299         ----------
300         aliases : dict of str, Unit
301             The aliases to add. The keys must be the string aliases, and values
302             must be the `astropy.units.Unit` that the alias will be mapped to.
303 
304         Raises
305         ------
306         ValueError
307             If the alias already defines a different unit.
308 
309         """
310         for alias, unit in aliases.items():
311             if alias in self._registry and unit != self._registry[alias]:
312                 raise ValueError(
313                     f"{alias} already means {self._registry[alias]}, so "
314                     f"cannot be used as an alias for {unit}.")
315             if alias in self._aliases and unit != self._aliases[alias]:
316                 raise ValueError(
317                     f"{alias} already is an alias for {self._aliases[alias]}, so "
318                     f"cannot be used as an alias for {unit}.")
319 
320         for alias, unit in aliases.items():
321             if alias not in self._registry and alias not in self._aliases:
322                 self._aliases[alias] = unit
323 
324 
325 class _UnitContext:
326     def __init__(self, init=[], equivalencies=[]):
327         _unit_registries.append(
328             _UnitRegistry(init=init, equivalencies=equivalencies))
329 
330     def __enter__(self):
331         pass
332 
333     def __exit__(self, type, value, tb):
334         _unit_registries.pop()
335 
336 
337 _unit_registries = [_UnitRegistry()]
338 
339 
340 def get_current_unit_registry():
341     return _unit_registries[-1]
342 
343 
344 def set_enabled_units(units):
345     """
346     Sets the units enabled in the unit registry.
347 
348     These units are searched when using
349     `UnitBase.find_equivalent_units`, for example.
350 
351     This may be used either permanently, or as a context manager using
352     the ``with`` statement (see example below).
353 
354     Parameters
355     ----------
356     units : list of sequence, dict, or module
357         This is a list of things in which units may be found
358         (sequences, dicts or modules), or units themselves.  The
359         entire set will be "enabled" for searching through by methods
360         like `UnitBase.find_equivalent_units` and `UnitBase.compose`.
361 
362     Examples
363     --------
364 
365     >>> from astropy import units as u
366     >>> with u.set_enabled_units([u.pc]):
367     ...     u.m.find_equivalent_units()
368     ...
369       Primary name | Unit definition | Aliases
370     [
371       pc           | 3.08568e+16 m   | parsec  ,
372     ]
373     >>> u.m.find_equivalent_units()
374       Primary name | Unit definition | Aliases
375     [
376       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
377       Angstrom     | 1e-10 m         | AA, angstrom                     ,
378       cm           | 0.01 m          | centimeter                       ,
379       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
380       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
381       lsec         | 2.99792e+08 m   | lightsecond                      ,
382       lyr          | 9.46073e+15 m   | lightyear                        ,
383       m            | irreducible     | meter                            ,
384       micron       | 1e-06 m         |                                  ,
385       pc           | 3.08568e+16 m   | parsec                           ,
386       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
387     ]
388     """
389     # get a context with a new registry, using equivalencies of the current one
390     context = _UnitContext(
391         equivalencies=get_current_unit_registry().equivalencies)
392     # in this new current registry, enable the units requested
393     get_current_unit_registry().set_enabled_units(units)
394     return context
395 
396 
397 def add_enabled_units(units):
398     """
399     Adds to the set of units enabled in the unit registry.
400 
401     These units are searched when using
402     `UnitBase.find_equivalent_units`, for example.
403 
404     This may be used either permanently, or as a context manager using
405     the ``with`` statement (see example below).
406 
407     Parameters
408     ----------
409     units : list of sequence, dict, or module
410         This is a list of things in which units may be found
411         (sequences, dicts or modules), or units themselves.  The
412         entire set will be added to the "enabled" set for searching
413         through by methods like `UnitBase.find_equivalent_units` and
414         `UnitBase.compose`.
415 
416     Examples
417     --------
418 
419     >>> from astropy import units as u
420     >>> from astropy.units import imperial
421     >>> with u.add_enabled_units(imperial):
422     ...     u.m.find_equivalent_units()
423     ...
424       Primary name | Unit definition | Aliases
425     [
426       AU           | 1.49598e+11 m   | au, astronomical_unit            ,
427       Angstrom     | 1e-10 m         | AA, angstrom                     ,
428       cm           | 0.01 m          | centimeter                       ,
429       earthRad     | 6.3781e+06 m    | R_earth, Rearth                  ,
430       ft           | 0.3048 m        | foot                             ,
431       fur          | 201.168 m       | furlong                          ,
432       inch         | 0.0254 m        |                                  ,
433       jupiterRad   | 7.1492e+07 m    | R_jup, Rjup, R_jupiter, Rjupiter ,
434       lsec         | 2.99792e+08 m   | lightsecond                      ,
435       lyr          | 9.46073e+15 m   | lightyear                        ,
436       m            | irreducible     | meter                            ,
437       mi           | 1609.34 m       | mile                             ,
438       micron       | 1e-06 m         |                                  ,
439       mil          | 2.54e-05 m      | thou                             ,
440       nmi          | 1852 m          | nauticalmile, NM                 ,
441       pc           | 3.08568e+16 m   | parsec                           ,
442       solRad       | 6.957e+08 m     | R_sun, Rsun                      ,
443       yd           | 0.9144 m        | yard                             ,
444     ]
445     """
446     # get a context with a new registry, which is a copy of the current one
447     context = _UnitContext(get_current_unit_registry())
448     # in this new current registry, enable the further units requested
449     get_current_unit_registry().add_enabled_units(units)
450     return context
451 
452 
453 def set_enabled_equivalencies(equivalencies):
454     """
455     Sets the equivalencies enabled in the unit registry.
456 
457     These equivalencies are used if no explicit equivalencies are given,
458     both in unit conversion and in finding equivalent units.
459 
460     This is meant in particular for allowing angles to be dimensionless.
461     Use with care.
462 
463     Parameters
464     ----------
465     equivalencies : list of tuple
466         list of equivalent pairs, e.g., as returned by
467         `~astropy.units.equivalencies.dimensionless_angles`.
468 
469     Examples
470     --------
471     Exponentiation normally requires dimensionless quantities.  To avoid
472     problems with complex phases::
473 
474         >>> from astropy import units as u
475         >>> with u.set_enabled_equivalencies(u.dimensionless_angles()):
476         ...     phase = 0.5 * u.cycle
477         ...     np.exp(1j*phase)  # doctest: +FLOAT_CMP
478         <Quantity -1.+1.2246468e-16j>
479     """
480     # get a context with a new registry, using all units of the current one
481     context = _UnitContext(get_current_unit_registry())
482     # in this new current registry, enable the equivalencies requested
483     get_current_unit_registry().set_enabled_equivalencies(equivalencies)
484     return context
485 
486 
487 def add_enabled_equivalencies(equivalencies):
488     """
489     Adds to the equivalencies enabled in the unit registry.
490 
491     These equivalencies are used if no explicit equivalencies are given,
492     both in unit conversion and in finding equivalent units.
493 
494     This is meant in particular for allowing angles to be dimensionless.
495     Since no equivalencies are enabled by default, generally it is recommended
496     to use `set_enabled_equivalencies`.
497 
498     Parameters
499     ----------
500     equivalencies : list of tuple
501         list of equivalent pairs, e.g., as returned by
502         `~astropy.units.equivalencies.dimensionless_angles`.
503     """
504     # get a context with a new registry, which is a copy of the current one
505     context = _UnitContext(get_current_unit_registry())
506     # in this new current registry, enable the further equivalencies requested
507     get_current_unit_registry().add_enabled_equivalencies(equivalencies)
508     return context
509 
510 
511 def set_enabled_aliases(aliases):
512     """
513     Set aliases for units.
514 
515     This is useful for handling alternate spellings for units, or
516     misspelled units in files one is trying to read.
517 
518     Parameters
519     ----------
520     aliases : dict of str, Unit
521         The aliases to set. The keys must be the string aliases, and values
522         must be the `astropy.units.Unit` that the alias will be mapped to.
523 
524     Raises
525     ------
526     ValueError
527         If the alias already defines a different unit.
528 
529     Examples
530     --------
531     To temporarily allow for a misspelled 'Angstroem' unit::
532 
533         >>> from astropy import units as u
534         >>> with u.set_enabled_aliases({'Angstroem': u.Angstrom}):
535         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
536         True
537 
538     """
539     # get a context with a new registry, which is a copy of the current one
540     context = _UnitContext(get_current_unit_registry())
541     # in this new current registry, enable the further equivalencies requested
542     get_current_unit_registry().set_enabled_aliases(aliases)
543     return context
544 
545 
546 def add_enabled_aliases(aliases):
547     """
548     Add aliases for units.
549 
550     This is useful for handling alternate spellings for units, or
551     misspelled units in files one is trying to read.
552 
553     Since no aliases are enabled by default, generally it is recommended
554     to use `set_enabled_aliases`.
555 
556     Parameters
557     ----------
558     aliases : dict of str, Unit
559         The aliases to add. The keys must be the string aliases, and values
560         must be the `astropy.units.Unit` that the alias will be mapped to.
561 
562     Raises
563     ------
564     ValueError
565         If the alias already defines a different unit.
566 
567     Examples
568     --------
569     To temporarily allow for a misspelled 'Angstroem' unit::
570 
571         >>> from astropy import units as u
572         >>> with u.add_enabled_aliases({'Angstroem': u.Angstrom}):
573         ...     print(u.Unit("Angstroem", parse_strict="raise") == u.Angstrom)
574         True
575 
576     """
577     # get a context with a new registry, which is a copy of the current one
578     context = _UnitContext(get_current_unit_registry())
579     # in this new current registry, enable the further equivalencies requested
580     get_current_unit_registry().add_enabled_aliases(aliases)
581     return context
582 
583 
584 class UnitsError(Exception):
585     """
586     The base class for unit-specific exceptions.
587     """
588 
589 
590 class UnitScaleError(UnitsError, ValueError):
591     """
592     Used to catch the errors involving scaled units,
593     which are not recognized by FITS format.
594     """
595     pass
596 
597 
598 class UnitConversionError(UnitsError, ValueError):
599     """
600     Used specifically for errors related to converting between units or
601     interpreting units in terms of other units.
602     """
603 
604 
605 class UnitTypeError(UnitsError, TypeError):
606     """
607     Used specifically for errors in setting to units not allowed by a class.
608 
609     E.g., would be raised if the unit of an `~astropy.coordinates.Angle`
610     instances were set to a non-angular unit.
611     """
612 
613 
614 class UnitsWarning(AstropyWarning):
615     """
616     The base class for unit-specific warnings.
617     """
618 
619 
620 class UnitBase:
621     """
622     Abstract base class for units.
623 
624     Most of the arithmetic operations on units are defined in this
625     base class.
626 
627     Should not be instantiated by users directly.
628     """
629     # Make sure that __rmul__ of units gets called over the __mul__ of Numpy
630     # arrays to avoid element-wise multiplication.
631     __array_priority__ = 1000
632 
633     _hash = None
634     _type_id = None
635 
636     def __deepcopy__(self, memo):
637         # This may look odd, but the units conversion will be very
638         # broken after deep-copying if we don't guarantee that a given
639         # physical unit corresponds to only one instance
640         return self
641 
642     def _repr_latex_(self):
643         """
644         Generate latex representation of unit name.  This is used by
645         the IPython notebook to print a unit with a nice layout.
646 
647         Returns
648         -------
649         Latex string
650         """
651         return unit_format.Latex.to_string(self)
652 
653     def __bytes__(self):
654         """Return string representation for unit"""
655         return unit_format.Generic.to_string(self).encode('unicode_escape')
656 
657     def __str__(self):
658         """Return string representation for unit"""
659         return unit_format.Generic.to_string(self)
660 
661     def __repr__(self):
662         string = unit_format.Generic.to_string(self)
663 
664         return f'Unit("{string}")'
665 
666     def _get_physical_type_id(self):
667         """
668         Returns an identifier that uniquely identifies the physical
669         type of this unit.  It is comprised of the bases and powers of
670         this unit, without the scale.  Since it is hashable, it is
671         useful as a dictionary key.
672         """
673         if self._type_id is None:
674             unit = self.decompose()
675             self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))
676 
677         return self._type_id
678 
679     @property
680     def names(self):
681         """
682         Returns all of the names associated with this unit.
683         """
684         raise AttributeError(
685             "Can not get names from unnamed units. "
686             "Perhaps you meant to_string()?")
687 
688     @property
689     def name(self):
690         """
691         Returns the canonical (short) name associated with this unit.
692         """
693         raise AttributeError(
694             "Can not get names from unnamed units. "
695             "Perhaps you meant to_string()?")
696 
697     @property
698     def aliases(self):
699         """
700         Returns the alias (long) names for this unit.
701         """
702         raise AttributeError(
703             "Can not get aliases from unnamed units. "
704             "Perhaps you meant to_string()?")
705 
706     @property
707     def scale(self):
708         """
709         Return the scale of the unit.
710         """
711         return 1.0
712 
713     @property
714     def bases(self):
715         """
716         Return the bases of the unit.
717         """
718         return [self]
719 
720     @property
721     def powers(self):
722         """
723         Return the powers of the unit.
724         """
725         return [1]
726 
727     def to_string(self, format=unit_format.Generic):
728         """
729         Output the unit in the given format as a string.
730 
731         Parameters
732         ----------
733         format : `astropy.units.format.Base` instance or str
734             The name of a format or a formatter object.  If not
735             provided, defaults to the generic format.
736         """
737 
738         f = unit_format.get_format(format)
739         return f.to_string(self)
740 
741     def __format__(self, format_spec):
742         """Try to format units using a formatter."""
743         try:
744             return self.to_string(format=format_spec)
745         except ValueError:
746             return format(str(self), format_spec)
747 
748     @staticmethod
749     def _normalize_equivalencies(equivalencies):
750         """
751         Normalizes equivalencies, ensuring each is a 4-tuple of the form::
752 
753         (from_unit, to_unit, forward_func, backward_func)
754 
755         Parameters
756         ----------
757         equivalencies : list of equivalency pairs, or None
758 
759         Returns
760         -------
761         A normalized list, including possible global defaults set by, e.g.,
762         `set_enabled_equivalencies`, except when `equivalencies`=`None`,
763         in which case the returned list is always empty.
764 
765         Raises
766         ------
767         ValueError if an equivalency cannot be interpreted
768         """
769         normalized = _normalize_equivalencies(equivalencies)
770         if equivalencies is not None:
771             normalized += get_current_unit_registry().equivalencies
772 
773         return normalized
774 
775     def __pow__(self, p):
776         p = validate_power(p)
777         return CompositeUnit(1, [self], [p], _error_check=False)
778 
779     def __truediv__(self, m):
780         if isinstance(m, (bytes, str)):
781             m = Unit(m)
782 
783         if isinstance(m, UnitBase):
784             if m.is_unity():
785                 return self
786             return CompositeUnit(1, [self, m], [1, -1], _error_check=False)
787 
788         try:
789             # Cannot handle this as Unit, re-try as Quantity
790             from .quantity import Quantity
791             return Quantity(1, self) / m
792         except TypeError:
793             return NotImplemented
794 
795     def __rtruediv__(self, m):
796         if isinstance(m, (bytes, str)):
797             return Unit(m) / self
798 
799         try:
800             # Cannot handle this as Unit.  Here, m cannot be a Quantity,
801             # so we make it into one, fasttracking when it does not have a
802             # unit, for the common case of <array> / <unit>.
803             from .quantity import Quantity
804             if hasattr(m, 'unit'):
805                 result = Quantity(m)
806                 result /= self
807                 return result
808             else:
809                 return Quantity(m, self**(-1))
810         except TypeError:
811             return NotImplemented
812 
813     def __mul__(self, m):
814         if isinstance(m, (bytes, str)):
815             m = Unit(m)
816 
817         if isinstance(m, UnitBase):
818             if m.is_unity():
819                 return self
820             elif self.is_unity():
821                 return m
822             return CompositeUnit(1, [self, m], [1, 1], _error_check=False)
823 
824         # Cannot handle this as Unit, re-try as Quantity.
825         try:
826             from .quantity import Quantity
827             return Quantity(1, unit=self) * m
828         except TypeError:
829             return NotImplemented
830 
831     def __rmul__(self, m):
832         if isinstance(m, (bytes, str)):
833             return Unit(m) * self
834 
835         # Cannot handle this as Unit.  Here, m cannot be a Quantity,
836         # so we make it into one, fasttracking when it does not have a unit
837         # for the common case of <array> * <unit>.
838         try:
839             from .quantity import Quantity
840             if hasattr(m, 'unit'):
841                 result = Quantity(m)
842                 result *= self
843                 return result
844             else:
845                 return Quantity(m, unit=self)
846         except TypeError:
847             return NotImplemented
848 
849     def __rlshift__(self, m):
850         try:
851             from .quantity import Quantity
852             return Quantity(m, self, copy=False, subok=True)
853         except Exception:
854             return NotImplemented
855 
856     def __rrshift__(self, m):
857         warnings.warn(">> is not implemented. Did you mean to convert "
858                       "to a Quantity with unit {} using '<<'?".format(self),
859                       AstropyWarning)
860         return NotImplemented
861 
862     def __hash__(self):
863         if self._hash is None:
864             parts = ([str(self.scale)] +
865                      [x.name for x in self.bases] +
866                      [str(x) for x in self.powers])
867             self._hash = hash(tuple(parts))
868         return self._hash
869 
870     def __getstate__(self):
871         # If we get pickled, we should *not* store the memoized members since
872         # hashes of strings vary between sessions.
873         state = self.__dict__.copy()
874         state.pop('_hash', None)
875         state.pop('_type_id', None)
876         return state
877 
878     def __eq__(self, other):
879         if self is other:
880             return True
881 
882         try:
883             other = Unit(other, parse_strict='silent')
884         except (ValueError, UnitsError, TypeError):
885             return NotImplemented
886 
887         # Other is unit-like, but the test below requires it is a UnitBase
888         # instance; if it is not, give up (so that other can try).
889         if not isinstance(other, UnitBase):
890             return NotImplemented
891 
892         try:
893             return is_effectively_unity(self._to(other))
894         except UnitsError:
895             return False
896 
897     def __ne__(self, other):
898         return not (self == other)
899 
900     def __le__(self, other):
901         scale = self._to(Unit(other))
902         return scale <= 1. or is_effectively_unity(scale)
903 
904     def __ge__(self, other):
905         scale = self._to(Unit(other))
906         return scale >= 1. or is_effectively_unity(scale)
907 
908     def __lt__(self, other):
909         return not (self >= other)
910 
911     def __gt__(self, other):
912         return not (self <= other)
913 
914     def __neg__(self):
915         return self * -1.
916 
917     def is_equivalent(self, other, equivalencies=[]):
918         """
919         Returns `True` if this unit is equivalent to ``other``.
920 
921         Parameters
922         ----------
923         other : `~astropy.units.Unit`, str, or tuple
924             The unit to convert to. If a tuple of units is specified, this
925             method returns true if the unit matches any of those in the tuple.
926 
927         equivalencies : list of tuple
928             A list of equivalence pairs to try if the units are not
929             directly convertible.  See :ref:`astropy:unit_equivalencies`.
930             This list is in addition to possible global defaults set by, e.g.,
931             `set_enabled_equivalencies`.
932             Use `None` to turn off all equivalencies.
933 
934         Returns
935         -------
936         bool
937         """
938         equivalencies = self._normalize_equivalencies(equivalencies)
939 
940         if isinstance(other, tuple):
941             return any(self.is_equivalent(u, equivalencies=equivalencies)
942                        for u in other)
943 
944         other = Unit(other, parse_strict='silent')
945 
946         return self._is_equivalent(other, equivalencies)
947 
948     def _is_equivalent(self, other, equivalencies=[]):
949         """Returns `True` if this unit is equivalent to `other`.
950         See `is_equivalent`, except that a proper Unit object should be
951         given (i.e., no string) and that the equivalency list should be
952         normalized using `_normalize_equivalencies`.
953         """
954         if isinstance(other, UnrecognizedUnit):
955             return False
956 
957         if (self._get_physical_type_id() ==
958                 other._get_physical_type_id()):
959             return True
960         elif len(equivalencies):
961             unit = self.decompose()
962             other = other.decompose()
963             for a, b, forward, backward in equivalencies:
964                 if b is None:
965                     # after canceling, is what's left convertible
966                     # to dimensionless (according to the equivalency)?
967                     try:
968                         (other/unit).decompose([a])
969                         return True
970                     except Exception:
971                         pass
972                 elif (
973                     a._is_equivalent(unit) and b._is_equivalent(other)
974                     or b._is_equivalent(unit) and a._is_equivalent(other)
975                 ):
976                     return True
977 
978         return False
979 
980     def _apply_equivalencies(self, unit, other, equivalencies):
981         """
982         Internal function (used from `_get_converter`) to apply
983         equivalence pairs.
984         """
985         def make_converter(scale1, func, scale2):
986             def convert(v):
987                 return func(_condition_arg(v) / scale1) * scale2
988             return convert
989 
990         for funit, tunit, a, b in equivalencies:
991             if tunit is None:
992                 try:
993                     ratio_in_funit = (other.decompose() /
994                                       unit.decompose()).decompose([funit])
995                     return make_converter(ratio_in_funit.scale, a, 1.)
996                 except UnitsError:
997                     pass
998             else:
999                 try:
1000                     scale1 = funit._to(unit)
1001                     scale2 = tunit._to(other)
1002                     return make_converter(scale1, a, scale2)
1003                 except UnitsError:
1004                     pass
1005                 try:
1006                     scale1 = tunit._to(unit)
1007                     scale2 = funit._to(other)
1008                     return make_converter(scale1, b, scale2)
1009                 except UnitsError:
1010                     pass
1011 
1012         def get_err_str(unit):
1013             unit_str = unit.to_string('unscaled')
1014             physical_type = unit.physical_type
1015             if physical_type != 'unknown':
1016                 unit_str = f"'{unit_str}' ({physical_type})"
1017             else:
1018                 unit_str = f"'{unit_str}'"
1019             return unit_str
1020 
1021         unit_str = get_err_str(unit)
1022         other_str = get_err_str(other)
1023 
1024         raise UnitConversionError(
1025             f"{unit_str} and {other_str} are not convertible")
1026 
1027     def _get_converter(self, other, equivalencies=[]):
1028         """Get a converter for values in ``self`` to ``other``.
1029 
1030         If no conversion is necessary, returns ``unit_scale_converter``
1031         (which is used as a check in quantity helpers).
1032 
1033         """
1034 
1035         # First see if it is just a scaling.
1036         try:
1037             scale = self._to(other)
1038         except UnitsError:
1039             pass
1040         else:
1041             if scale == 1.:
1042                 return unit_scale_converter
1043             else:
1044                 return lambda val: scale * _condition_arg(val)
1045 
1046         # if that doesn't work, maybe we can do it with equivalencies?
1047         try:
1048             return self._apply_equivalencies(
1049                 self, other, self._normalize_equivalencies(equivalencies))
1050         except UnitsError as exc:
1051             # Last hope: maybe other knows how to do it?
1052             # We assume the equivalencies have the unit itself as first item.
1053             # TODO: maybe better for other to have a `_back_converter` method?
1054             if hasattr(other, 'equivalencies'):
1055                 for funit, tunit, a, b in other.equivalencies:
1056                     if other is funit:
1057                         try:
1058                             return lambda v: b(self._get_converter(
1059                                 tunit, equivalencies=equivalencies)(v))
1060                         except Exception:
1061                             pass
1062 
1063             raise exc
1064 
1065     def _to(self, other):
1066         """
1067         Returns the scale to the specified unit.
1068 
1069         See `to`, except that a Unit object should be given (i.e., no
1070         string), and that all defaults are used, i.e., no
1071         equivalencies and value=1.
1072         """
1073         # There are many cases where we just want to ensure a Quantity is
1074         # of a particular unit, without checking whether it's already in
1075         # a particular unit.  If we're being asked to convert from a unit
1076         # to itself, we can short-circuit all of this.
1077         if self is other:
1078             return 1.0
1079 
1080         # Don't presume decomposition is possible; e.g.,
1081         # conversion to function units is through equivalencies.
1082         if isinstance(other, UnitBase):
1083             self_decomposed = self.decompose()
1084             other_decomposed = other.decompose()
1085 
1086             # Check quickly whether equivalent.  This is faster than
1087             # `is_equivalent`, because it doesn't generate the entire
1088             # physical type list of both units.  In other words it "fails
1089             # fast".
1090             if (self_decomposed.powers == other_decomposed.powers
1091                 and all(self_base is other_base for (self_base, other_base)
1092                         in zip(self_decomposed.bases, other_decomposed.bases))):
1093                 return self_decomposed.scale / other_decomposed.scale
1094 
1095         raise UnitConversionError(
1096             f"'{self!r}' is not a scaled version of '{other!r}'")
1097 
1098     def to(self, other, value=UNITY, equivalencies=[]):
1099         """
1100         Return the converted values in the specified unit.
1101 
1102         Parameters
1103         ----------
1104         other : unit-like
1105             The unit to convert to.
1106 
1107         value : int, float, or scalar array-like, optional
1108             Value(s) in the current unit to be converted to the
1109             specified unit.  If not provided, defaults to 1.0
1110 
1111         equivalencies : list of tuple
1112             A list of equivalence pairs to try if the units are not
1113             directly convertible.  See :ref:`astropy:unit_equivalencies`.
1114             This list is in addition to possible global defaults set by, e.g.,
1115             `set_enabled_equivalencies`.
1116             Use `None` to turn off all equivalencies.
1117 
1118         Returns
1119         -------
1120         values : scalar or array
1121             Converted value(s). Input value sequences are returned as
1122             numpy arrays.
1123 
1124         Raises
1125         ------
1126         UnitsError
1127             If units are inconsistent
1128         """
1129         if other is self and value is UNITY:
1130             return UNITY
1131         else:
1132             return self._get_converter(Unit(other),
1133                                        equivalencies=equivalencies)(value)
1134 
1135     def in_units(self, other, value=1.0, equivalencies=[]):
1136         """
1137         Alias for `to` for backward compatibility with pynbody.
1138         """
1139         return self.to(
1140             other, value=value, equivalencies=equivalencies)
1141 
1142     def decompose(self, bases=set()):
1143         """
1144         Return a unit object composed of only irreducible units.
1145 
1146         Parameters
1147         ----------
1148         bases : sequence of UnitBase, optional
1149             The bases to decompose into.  When not provided,
1150             decomposes down to any irreducible units.  When provided,
1151             the decomposed result will only contain the given units.
1152             This will raises a `UnitsError` if it's not possible
1153             to do so.
1154 
1155         Returns
1156         -------
1157         unit : `~astropy.units.CompositeUnit`
1158             New object containing only irreducible unit objects.
1159         """
1160         raise NotImplementedError()
1161 
1162     def _compose(self, equivalencies=[], namespace=[], max_depth=2, depth=0,
1163                  cached_results=None):
1164         def is_final_result(unit):
1165             # Returns True if this result contains only the expected
1166             # units
1167             for base in unit.bases:
1168                 if base not in namespace:
1169                     return False
1170             return True
1171 
1172         unit = self.decompose()
1173         key = hash(unit)
1174 
1175         cached = cached_results.get(key)
1176         if cached is not None:
1177             if isinstance(cached, Exception):
1178                 raise cached
1179             return cached
1180 
1181         # Prevent too many levels of recursion
1182         # And special case for dimensionless unit
1183         if depth >= max_depth:
1184             cached_results[key] = [unit]
1185             return [unit]
1186 
1187         # Make a list including all of the equivalent units
1188         units = [unit]
1189         for funit, tunit, a, b in equivalencies:
1190             if tunit is not None:
1191                 if self._is_equivalent(funit):
1192                     scale = funit.decompose().scale / unit.scale
1193                     units.append(Unit(a(1.0 / scale) * tunit).decompose())
1194                 elif self._is_equivalent(tunit):
1195                     scale = tunit.decompose().scale / unit.scale
1196                     units.append(Unit(b(1.0 / scale) * funit).decompose())
1197             else:
1198                 if self._is_equivalent(funit):
1199                     units.append(Unit(unit.scale))
1200 
1201         # Store partial results
1202         partial_results = []
1203         # Store final results that reduce to a single unit or pair of
1204         # units
1205         if len(unit.bases) == 0:
1206             final_results = [{unit}, set()]
1207         else:
1208             final_results = [set(), set()]
1209 
1210         for tunit in namespace:
1211             tunit_decomposed = tunit.decompose()
1212             for u in units:
1213                 # If the unit is a base unit, look for an exact match
1214                 # to one of the bases of the target unit.  If found,
1215                 # factor by the same power as the target unit's base.
1216                 # This allows us to factor out fractional powers
1217                 # without needing to do an exhaustive search.
1218                 if len(tunit_decomposed.bases) == 1:
1219                     for base, power in zip(u.bases, u.powers):
1220                         if tunit_decomposed._is_equivalent(base):
1221                             tunit = tunit ** power
1222                             tunit_decomposed = tunit_decomposed ** power
1223                             break
1224 
1225                 composed = (u / tunit_decomposed).decompose()
1226                 factored = composed * tunit
1227                 len_bases = len(composed.bases)
1228                 if is_final_result(factored) and len_bases <= 1:
1229                     final_results[len_bases].add(factored)
1230                 else:
1231                     partial_results.append(
1232                         (len_bases, composed, tunit))
1233 
1234         # Do we have any minimal results?
1235         for final_result in final_results:
1236             if len(final_result):
1237                 results = final_results[0].union(final_results[1])
1238                 cached_results[key] = results
1239                 return results
1240 
1241         partial_results.sort(key=operator.itemgetter(0))
1242 
1243         # ...we have to recurse and try to further compose
1244         results = []
1245         for len_bases, composed, tunit in partial_results:
1246             try:
1247                 composed_list = composed._compose(
1248                     equivalencies=equivalencies,
1249                     namespace=namespace,
1250                     max_depth=max_depth, depth=depth + 1,
1251                     cached_results=cached_results)
1252             except UnitsError:
1253                 composed_list = []
1254             for subcomposed in composed_list:
1255                 results.append(
1256                     (len(subcomposed.bases), subcomposed, tunit))
1257 
1258         if len(results):
1259             results.sort(key=operator.itemgetter(0))
1260 
1261             min_length = results[0][0]
1262             subresults = set()
1263             for len_bases, composed, tunit in results:
1264                 if len_bases > min_length:
1265                     break
1266                 else:
1267                     factored = composed * tunit
1268                     if is_final_result(factored):
1269                         subresults.add(factored)
1270 
1271             if len(subresults):
1272                 cached_results[key] = subresults
1273                 return subresults
1274 
1275         if not is_final_result(self):
1276             result = UnitsError(
1277                 f"Cannot represent unit {self} in terms of the given units")
1278             cached_results[key] = result
1279             raise result
1280 
1281         cached_results[key] = [self]
1282         return [self]
1283 
1284     def compose(self, equivalencies=[], units=None, max_depth=2,
1285                 include_prefix_units=None):
1286         """
1287         Return the simplest possible composite unit(s) that represent
1288         the given unit.  Since there may be multiple equally simple
1289         compositions of the unit, a list of units is always returned.
1290 
1291         Parameters
1292         ----------
1293         equivalencies : list of tuple
1294             A list of equivalence pairs to also list.  See
1295             :ref:`astropy:unit_equivalencies`.
1296             This list is in addition to possible global defaults set by, e.g.,
1297             `set_enabled_equivalencies`.
1298             Use `None` to turn off all equivalencies.
1299 
1300         units : set of `~astropy.units.Unit`, optional
1301             If not provided, any known units may be used to compose
1302             into.  Otherwise, ``units`` is a dict, module or sequence
1303             containing the units to compose into.
1304 
1305         max_depth : int, optional
1306             The maximum recursion depth to use when composing into
1307             composite units.
1308 
1309         include_prefix_units : bool, optional
1310             When `True`, include prefixed units in the result.
1311             Default is `True` if a sequence is passed in to ``units``,
1312             `False` otherwise.
1313 
1314         Returns
1315         -------
1316         units : list of `CompositeUnit`
1317             A list of candidate compositions.  These will all be
1318             equally simple, but it may not be possible to
1319             automatically determine which of the candidates are
1320             better.
1321         """
1322         # if units parameter is specified and is a sequence (list|tuple),
1323         # include_prefix_units is turned on by default.  Ex: units=[u.kpc]
1324         if include_prefix_units is None:
1325             include_prefix_units = isinstance(units, (list, tuple))
1326 
1327         # Pre-normalize the equivalencies list
1328         equivalencies = self._normalize_equivalencies(equivalencies)
1329 
1330         # The namespace of units to compose into should be filtered to
1331         # only include units with bases in common with self, otherwise
1332         # they can't possibly provide useful results.  Having too many
1333         # destination units greatly increases the search space.
1334 
1335         def has_bases_in_common(a, b):
1336             if len(a.bases) == 0 and len(b.bases) == 0:
1337                 return True
1338             for ab in a.bases:
1339                 for bb in b.bases:
1340                     if ab == bb:
1341                         return True
1342             return False
1343 
1344         def has_bases_in_common_with_equiv(unit, other):
1345             if has_bases_in_common(unit, other):
1346                 return True
1347             for funit, tunit, a, b in equivalencies:
1348                 if tunit is not None:
1349                     if unit._is_equivalent(funit):
1350                         if has_bases_in_common(tunit.decompose(), other):
1351                             return True
1352                     elif unit._is_equivalent(tunit):
1353                         if has_bases_in_common(funit.decompose(), other):
1354                             return True
1355                 else:
1356                     if unit._is_equivalent(funit):
1357                         if has_bases_in_common(dimensionless_unscaled, other):
1358                             return True
1359             return False
1360 
1361         def filter_units(units):
1362             filtered_namespace = set()
1363             for tunit in units:
1364                 if (isinstance(tunit, UnitBase) and
1365                     (include_prefix_units or
1366                      not isinstance(tunit, PrefixUnit)) and
1367                     has_bases_in_common_with_equiv(
1368                         decomposed, tunit.decompose())):
1369                     filtered_namespace.add(tunit)
1370             return filtered_namespace
1371 
1372         decomposed = self.decompose()
1373 
1374         if units is None:
1375             units = filter_units(self._get_units_with_same_physical_type(
1376                 equivalencies=equivalencies))
1377             if len(units) == 0:
1378                 units = get_current_unit_registry().non_prefix_units
1379         elif isinstance(units, dict):
1380             units = set(filter_units(units.values()))
1381         elif inspect.ismodule(units):
1382             units = filter_units(vars(units).values())
1383         else:
1384             units = filter_units(_flatten_units_collection(units))
1385 
1386         def sort_results(results):
1387             if not len(results):
1388                 return []
1389 
1390             # Sort the results so the simplest ones appear first.
1391             # Simplest is defined as "the minimum sum of absolute
1392             # powers" (i.e. the fewest bases), and preference should
1393             # be given to results where the sum of powers is positive
1394             # and the scale is exactly equal to 1.0
1395             results = list(results)
1396             results.sort(key=lambda x: np.abs(x.scale))
1397             results.sort(key=lambda x: np.sum(np.abs(x.powers)))
1398             results.sort(key=lambda x: np.sum(x.powers) < 0.0)
1399             results.sort(key=lambda x: not is_effectively_unity(x.scale))
1400 
1401             last_result = results[0]
1402             filtered = [last_result]
1403             for result in results[1:]:
1404                 if str(result) != str(last_result):
1405                     filtered.append(result)
1406                 last_result = result
1407 
1408             return filtered
1409 
1410         return sort_results(self._compose(
1411             equivalencies=equivalencies, namespace=units,
1412             max_depth=max_depth, depth=0, cached_results={}))
1413 
1414     def to_system(self, system):
1415         """
1416         Converts this unit into ones belonging to the given system.
1417         Since more than one result may be possible, a list is always
1418         returned.
1419 
1420         Parameters
1421         ----------
1422         system : module
1423             The module that defines the unit system.  Commonly used
1424             ones include `astropy.units.si` and `astropy.units.cgs`.
1425 
1426             To use your own module it must contain unit objects and a
1427             sequence member named ``bases`` containing the base units of
1428             the system.
1429 
1430         Returns
1431         -------
1432         units : list of `CompositeUnit`
1433             The list is ranked so that units containing only the base
1434             units of that system will appear first.
1435         """
1436         bases = set(system.bases)
1437 
1438         def score(compose):
1439             # In case that compose._bases has no elements we return
1440             # 'np.inf' as 'score value'.  It does not really matter which
1441             # number we would return. This case occurs for instance for
1442             # dimensionless quantities:
1443             compose_bases = compose.bases
1444             if len(compose_bases) == 0:
1445                 return np.inf
1446             else:
1447                 sum = 0
1448                 for base in compose_bases:
1449                     if base in bases:
1450                         sum += 1
1451 
1452                 return sum / float(len(compose_bases))
1453 
1454         x = self.decompose(bases=bases)
1455         composed = x.compose(units=system)
1456         composed = sorted(composed, key=score, reverse=True)
1457         return composed
1458 
1459     @lazyproperty
1460     def si(self):
1461         """
1462         Returns a copy of the current `Unit` instance in SI units.
1463         """
1464 
1465         from . import si
1466         return self.to_system(si)[0]
1467 
1468     @lazyproperty
1469     def cgs(self):
1470         """
1471         Returns a copy of the current `Unit` instance with CGS units.
1472         """
1473         from . import cgs
1474         return self.to_system(cgs)[0]
1475 
1476     @property
1477     def physical_type(self):
1478         """
1479         Physical type(s) dimensionally compatible with the unit.
1480 
1481         Returns
1482         -------
1483         `~astropy.units.physical.PhysicalType`
1484             A representation of the physical type(s) of a unit.
1485 
1486         Examples
1487         --------
1488         >>> from astropy import units as u
1489         >>> u.m.physical_type
1490         PhysicalType('length')
1491         >>> (u.m ** 2 / u.s).physical_type
1492         PhysicalType({'diffusivity', 'kinematic viscosity'})
1493 
1494         Physical types can be compared to other physical types
1495         (recommended in packages) or to strings.
1496 
1497         >>> area = (u.m ** 2).physical_type
1498         >>> area == u.m.physical_type ** 2
1499         True
1500         >>> area == "area"
1501         True
1502 
1503         `~astropy.units.physical.PhysicalType` objects can be used for
1504         dimensional analysis.
1505 
1506         >>> number_density = u.m.physical_type ** -3
1507         >>> velocity = (u.m / u.s).physical_type
1508         >>> number_density * velocity
1509         PhysicalType('particle flux')
1510         """
1511         from . import physical
1512         return physical.get_physical_type(self)
1513 
1514     def _get_units_with_same_physical_type(self, equivalencies=[]):
1515         """
1516         Return a list of registered units with the same physical type
1517         as this unit.
1518 
1519         This function is used by Quantity to add its built-in
1520         conversions to equivalent units.
1521 
1522         This is a private method, since end users should be encouraged
1523         to use the more powerful `compose` and `find_equivalent_units`
1524         methods (which use this under the hood).
1525 
1526         Parameters
1527         ----------
1528         equivalencies : list of tuple
1529             A list of equivalence pairs to also pull options from.
1530             See :ref:`astropy:unit_equivalencies`.  It must already be
1531             normalized using `_normalize_equivalencies`.
1532         """
1533         unit_registry = get_current_unit_registry()
1534         units = set(unit_registry.get_units_with_physical_type(self))
1535         for funit, tunit, a, b in equivalencies:
1536             if tunit is not None:
1537                 if self.is_equivalent(funit) and tunit not in units:
1538                     units.update(
1539                         unit_registry.get_units_with_physical_type(tunit))
1540                 if self._is_equivalent(tunit) and funit not in units:
1541                     units.update(
1542                         unit_registry.get_units_with_physical_type(funit))
1543             else:
1544                 if self.is_equivalent(funit):
1545                     units.add(dimensionless_unscaled)
1546         return units
1547 
1548     class EquivalentUnitsList(list):
1549         """
1550         A class to handle pretty-printing the result of
1551         `find_equivalent_units`.
1552         """
1553 
1554         HEADING_NAMES = ('Primary name', 'Unit definition', 'Aliases')
1555         ROW_LEN = 3  # len(HEADING_NAMES), but hard-code since it is constant
1556         NO_EQUIV_UNITS_MSG = 'There are no equivalent units'
1557 
1558         def __repr__(self):
1559             if len(self) == 0:
1560                 return self.NO_EQUIV_UNITS_MSG
1561             else:
1562                 lines = self._process_equivalent_units(self)
1563                 lines.insert(0, self.HEADING_NAMES)
1564                 widths = [0] * self.ROW_LEN
1565                 for line in lines:
1566                     for i, col in enumerate(line):
1567                         widths[i] = max(widths[i], len(col))
1568 
1569                 f = "  {{0:<{0}s}} | {{1:<{1}s}} | {{2:<{2}s}}".format(*widths)
1570                 lines = [f.format(*line) for line in lines]
1571                 lines = (lines[0:1] +
1572                          ['['] +
1573                          [f'{x} ,' for x in lines[1:]] +
1574                          [']'])
1575                 return '\n'.join(lines)
1576 
1577         def _repr_html_(self):
1578             """
1579             Outputs a HTML table representation within Jupyter notebooks.
1580             """
1581             if len(self) == 0:
1582                 return f"<p>{self.NO_EQUIV_UNITS_MSG}</p>"
1583             else:
1584                 # HTML tags to use to compose the table in HTML
1585                 blank_table = '<table style="width:50%">{}</table>'
1586                 blank_row_container = "<tr>{}</tr>"
1587                 heading_row_content = "<th>{}</th>" * self.ROW_LEN
1588                 data_row_content = "<td>{}</td>" * self.ROW_LEN
1589 
1590                 # The HTML will be rendered & the table is simple, so don't
1591                 # bother to include newlines & indentation for the HTML code.
1592                 heading_row = blank_row_container.format(
1593                     heading_row_content.format(*self.HEADING_NAMES))
1594                 data_rows = self._process_equivalent_units(self)
1595                 all_rows = heading_row
1596                 for row in data_rows:
1597                     html_row = blank_row_container.format(
1598                         data_row_content.format(*row))
1599                     all_rows += html_row
1600                 return blank_table.format(all_rows)
1601 
1602         @staticmethod
1603         def _process_equivalent_units(equiv_units_data):
1604             """
1605             Extract attributes, and sort, the equivalent units pre-formatting.
1606             """
1607             processed_equiv_units = []
1608             for u in equiv_units_data:
1609                 irred = u.decompose().to_string()
1610                 if irred == u.name:
1611                     irred = 'irreducible'
1612                 processed_equiv_units.append(
1613                     (u.name, irred, ', '.join(u.aliases)))
1614             processed_equiv_units.sort()
1615             return processed_equiv_units
1616 
1617     def find_equivalent_units(self, equivalencies=[], units=None,
1618                               include_prefix_units=False):
1619         """
1620         Return a list of all the units that are the same type as ``self``.
1621 
1622         Parameters
1623         ----------
1624         equivalencies : list of tuple
1625             A list of equivalence pairs to also list.  See
1626             :ref:`astropy:unit_equivalencies`.
1627             Any list given, including an empty one, supersedes global defaults
1628             that may be in effect (as set by `set_enabled_equivalencies`)
1629 
1630         units : set of `~astropy.units.Unit`, optional
1631             If not provided, all defined units will be searched for
1632             equivalencies.  Otherwise, may be a dict, module or
1633             sequence containing the units to search for equivalencies.
1634 
1635         include_prefix_units : bool, optional
1636             When `True`, include prefixed units in the result.
1637             Default is `False`.
1638 
1639         Returns
1640         -------
1641         units : list of `UnitBase`
1642             A list of unit objects that match ``u``.  A subclass of
1643             `list` (``EquivalentUnitsList``) is returned that
1644             pretty-prints the list of units when output.
1645         """
1646         results = self.compose(
1647             equivalencies=equivalencies, units=units, max_depth=1,
1648             include_prefix_units=include_prefix_units)
1649         results = {x.bases[0] for x in results if len(x.bases) == 1}
1650         return self.EquivalentUnitsList(results)
1651 
1652     def is_unity(self):
1653         """
1654         Returns `True` if the unit is unscaled and dimensionless.
1655         """
1656         return False
1657 
1658 
1659 class NamedUnit(UnitBase):
1660     """
1661     The base class of units that have a name.
1662 
1663     Parameters
1664     ----------
1665     st : str, list of str, 2-tuple
1666         The name of the unit.  If a list of strings, the first element
1667         is the canonical (short) name, and the rest of the elements
1668         are aliases.  If a tuple of lists, the first element is a list
1669         of short names, and the second element is a list of long
1670         names; all but the first short name are considered "aliases".
1671         Each name *should* be a valid Python identifier to make it
1672         easy to access, but this is not required.
1673 
1674     namespace : dict, optional
1675         When provided, inject the unit, and all of its aliases, in the
1676         given namespace dictionary.  If a unit by the same name is
1677         already in the namespace, a ValueError is raised.
1678 
1679     doc : str, optional
1680         A docstring describing the unit.
1681 
1682     format : dict, optional
1683         A mapping to format-specific representations of this unit.
1684         For example, for the ``Ohm`` unit, it might be nice to have it
1685         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
1686         case, `format` argument should be set to::
1687 
1688             {'latex': r'\\Omega'}
1689 
1690     Raises
1691     ------
1692     ValueError
1693         If any of the given unit names are already in the registry.
1694 
1695     ValueError
1696         If any of the given unit names are not valid Python tokens.
1697     """
1698 
1699     def __init__(self, st, doc=None, format=None, namespace=None):
1700 
1701         UnitBase.__init__(self)
1702 
1703         if isinstance(st, (bytes, str)):
1704             self._names = [st]
1705             self._short_names = [st]
1706             self._long_names = []
1707         elif isinstance(st, tuple):
1708             if not len(st) == 2:
1709                 raise ValueError("st must be string, list or 2-tuple")
1710             self._names = st[0] + [n for n in st[1] if n not in st[0]]
1711             if not len(self._names):
1712                 raise ValueError("must provide at least one name")
1713             self._short_names = st[0][:]
1714             self._long_names = st[1][:]
1715         else:
1716             if len(st) == 0:
1717                 raise ValueError(
1718                     "st list must have at least one entry")
1719             self._names = st[:]
1720             self._short_names = [st[0]]
1721             self._long_names = st[1:]
1722 
1723         if format is None:
1724             format = {}
1725         self._format = format
1726 
1727         if doc is None:
1728             doc = self._generate_doc()
1729         else:
1730             doc = textwrap.dedent(doc)
1731             doc = textwrap.fill(doc)
1732 
1733         self.__doc__ = doc
1734 
1735         self._inject(namespace)
1736 
1737     def _generate_doc(self):
1738         """
1739         Generate a docstring for the unit if the user didn't supply
1740         one.  This is only used from the constructor and may be
1741         overridden in subclasses.
1742         """
1743         names = self.names
1744         if len(self.names) > 1:
1745             return "{1} ({0})".format(*names[:2])
1746         else:
1747             return names[0]
1748 
1749     def get_format_name(self, format):
1750         """
1751         Get a name for this unit that is specific to a particular
1752         format.
1753 
1754         Uses the dictionary passed into the `format` kwarg in the
1755         constructor.
1756 
1757         Parameters
1758         ----------
1759         format : str
1760             The name of the format
1761 
1762         Returns
1763         -------
1764         name : str
1765             The name of the unit for the given format.
1766         """
1767         return self._format.get(format, self.name)
1768 
1769     @property
1770     def names(self):
1771         """
1772         Returns all of the names associated with this unit.
1773         """
1774         return self._names
1775 
1776     @property
1777     def name(self):
1778         """
1779         Returns the canonical (short) name associated with this unit.
1780         """
1781         return self._names[0]
1782 
1783     @property
1784     def aliases(self):
1785         """
1786         Returns the alias (long) names for this unit.
1787         """
1788         return self._names[1:]
1789 
1790     @property
1791     def short_names(self):
1792         """
1793         Returns all of the short names associated with this unit.
1794         """
1795         return self._short_names
1796 
1797     @property
1798     def long_names(self):
1799         """
1800         Returns all of the long names associated with this unit.
1801         """
1802         return self._long_names
1803 
1804     def _inject(self, namespace=None):
1805         """
1806         Injects the unit, and all of its aliases, in the given
1807         namespace dictionary.
1808         """
1809         if namespace is None:
1810             return
1811 
1812         # Loop through all of the names first, to ensure all of them
1813         # are new, then add them all as a single "transaction" below.
1814         for name in self._names:
1815             if name in namespace and self != namespace[name]:
1816                 raise ValueError(
1817                     "Object with name {!r} already exists in "
1818                     "given namespace ({!r}).".format(
1819                         name, namespace[name]))
1820 
1821         for name in self._names:
1822             namespace[name] = self
1823 
1824 
1825 def _recreate_irreducible_unit(cls, names, registered):
1826     """
1827     This is used to reconstruct units when passed around by
1828     multiprocessing.
1829     """
1830     registry = get_current_unit_registry().registry
1831     if names[0] in registry:
1832         # If in local registry return that object.
1833         return registry[names[0]]
1834     else:
1835         # otherwise, recreate the unit.
1836         unit = cls(names)
1837         if registered:
1838             # If not in local registry but registered in origin registry,
1839             # enable unit in local registry.
1840             get_current_unit_registry().add_enabled_units([unit])
1841 
1842         return unit
1843 
1844 
1845 class IrreducibleUnit(NamedUnit):
1846     """
1847     Irreducible units are the units that all other units are defined
1848     in terms of.
1849 
1850     Examples are meters, seconds, kilograms, amperes, etc.  There is
1851     only once instance of such a unit per type.
1852     """
1853 
1854     def __reduce__(self):
1855         # When IrreducibleUnit objects are passed to other processes
1856         # over multiprocessing, they need to be recreated to be the
1857         # ones already in the subprocesses' namespace, not new
1858         # objects, or they will be considered "unconvertible".
1859         # Therefore, we have a custom pickler/unpickler that
1860         # understands how to recreate the Unit on the other side.
1861         registry = get_current_unit_registry().registry
1862         return (_recreate_irreducible_unit,
1863                 (self.__class__, list(self.names), self.name in registry),
1864                 self.__getstate__())
1865 
1866     @property
1867     def represents(self):
1868         """The unit that this named unit represents.
1869 
1870         For an irreducible unit, that is always itself.
1871         """
1872         return self
1873 
1874     def decompose(self, bases=set()):
1875         if len(bases) and self not in bases:
1876             for base in bases:
1877                 try:
1878                     scale = self._to(base)
1879                 except UnitsError:
1880                     pass
1881                 else:
1882                     if is_effectively_unity(scale):
1883                         return base
1884                     else:
1885                         return CompositeUnit(scale, [base], [1],
1886                                              _error_check=False)
1887 
1888             raise UnitConversionError(
1889                 f"Unit {self} can not be decomposed into the requested bases")
1890 
1891         return self
1892 
1893 
1894 class UnrecognizedUnit(IrreducibleUnit):
1895     """
1896     A unit that did not parse correctly.  This allows for
1897     round-tripping it as a string, but no unit operations actually work
1898     on it.
1899 
1900     Parameters
1901     ----------
1902     st : str
1903         The name of the unit.
1904     """
1905     # For UnrecognizedUnits, we want to use "standard" Python
1906     # pickling, not the special case that is used for
1907     # IrreducibleUnits.
1908     __reduce__ = object.__reduce__
1909 
1910     def __repr__(self):
1911         return f"UnrecognizedUnit({str(self)})"
1912 
1913     def __bytes__(self):
1914         return self.name.encode('ascii', 'replace')
1915 
1916     def __str__(self):
1917         return self.name
1918 
1919     def to_string(self, format=None):
1920         return self.name
1921 
1922     def _unrecognized_operator(self, *args, **kwargs):
1923         raise ValueError(
1924             "The unit {!r} is unrecognized, so all arithmetic operations "
1925             "with it are invalid.".format(self.name))
1926 
1927     __pow__ = __truediv__ = __rtruediv__ = __mul__ = __rmul__ = __lt__ = \
1928         __gt__ = __le__ = __ge__ = __neg__ = _unrecognized_operator
1929 
1930     def __eq__(self, other):
1931         try:
1932             other = Unit(other, parse_strict='silent')
1933         except (ValueError, UnitsError, TypeError):
1934             return NotImplemented
1935 
1936         return isinstance(other, type(self)) and self.name == other.name
1937 
1938     def __ne__(self, other):
1939         return not (self == other)
1940 
1941     def is_equivalent(self, other, equivalencies=None):
1942         self._normalize_equivalencies(equivalencies)
1943         return self == other
1944 
1945     def _get_converter(self, other, equivalencies=None):
1946         self._normalize_equivalencies(equivalencies)
1947         raise ValueError(
1948             "The unit {!r} is unrecognized.  It can not be converted "
1949             "to other units.".format(self.name))
1950 
1951     def get_format_name(self, format):
1952         return self.name
1953 
1954     def is_unity(self):
1955         return False
1956 
1957 
1958 class _UnitMetaClass(type):
1959     """
1960     This metaclass exists because the Unit constructor should
1961     sometimes return instances that already exist.  This "overrides"
1962     the constructor before the new instance is actually created, so we
1963     can return an existing one.
1964     """
1965 
1966     def __call__(self, s="", represents=None, format=None, namespace=None,
1967                  doc=None, parse_strict='raise'):
1968 
1969         # Short-circuit if we're already a unit
1970         if hasattr(s, '_get_physical_type_id'):
1971             return s
1972 
1973         # turn possible Quantity input for s or represents into a Unit
1974         from .quantity import Quantity
1975 
1976         if isinstance(represents, Quantity):
1977             if is_effectively_unity(represents.value):
1978                 represents = represents.unit
1979             else:
1980                 represents = CompositeUnit(represents.value *
1981                                            represents.unit.scale,
1982                                            bases=represents.unit.bases,
1983                                            powers=represents.unit.powers,
1984                                            _error_check=False)
1985 
1986         if isinstance(s, Quantity):
1987             if is_effectively_unity(s.value):
1988                 s = s.unit
1989             else:
1990                 s = CompositeUnit(s.value * s.unit.scale,
1991                                   bases=s.unit.bases,
1992                                   powers=s.unit.powers,
1993                                   _error_check=False)
1994 
1995         # now decide what we really need to do; define derived Unit?
1996         if isinstance(represents, UnitBase):
1997             # This has the effect of calling the real __new__ and
1998             # __init__ on the Unit class.
1999             return super().__call__(
2000                 s, represents, format=format, namespace=namespace, doc=doc)
2001 
2002         # or interpret a Quantity (now became unit), string or number?
2003         if isinstance(s, UnitBase):
2004             return s
2005 
2006         elif isinstance(s, (bytes, str)):
2007             if len(s.strip()) == 0:
2008                 # Return the NULL unit
2009                 return dimensionless_unscaled
2010 
2011             if format is None:
2012                 format = unit_format.Generic
2013 
2014             f = unit_format.get_format(format)
2015             if isinstance(s, bytes):
2016                 s = s.decode('ascii')
2017 
2018             try:
2019                 return f.parse(s)
2020             except NotImplementedError:
2021                 raise
2022             except Exception as e:
2023                 if parse_strict == 'silent':
2024                     pass
2025                 else:
2026                     # Deliberately not issubclass here. Subclasses
2027                     # should use their name.
2028                     if f is not unit_format.Generic:
2029                         format_clause = f.name + ' '
2030                     else:
2031                         format_clause = ''
2032                     msg = ("'{}' did not parse as {}unit: {} "
2033                            "If this is meant to be a custom unit, "
2034                            "define it with 'u.def_unit'. To have it "
2035                            "recognized inside a file reader or other code, "
2036                            "enable it with 'u.add_enabled_units'. "
2037                            "For details, see "
2038                            "https://docs.astropy.org/en/latest/units/combining_and_defining.html"
2039                            .format(s, format_clause, str(e)))
2040                     if parse_strict == 'raise':
2041                         raise ValueError(msg)
2042                     elif parse_strict == 'warn':
2043                         warnings.warn(msg, UnitsWarning)
2044                     else:
2045                         raise ValueError("'parse_strict' must be 'warn', "
2046                                          "'raise' or 'silent'")
2047                 return UnrecognizedUnit(s)
2048 
2049         elif isinstance(s, (int, float, np.floating, np.integer)):
2050             return CompositeUnit(s, [], [], _error_check=False)
2051 
2052         elif isinstance(s, tuple):
2053             from .structured import StructuredUnit
2054             return StructuredUnit(s)
2055 
2056         elif s is None:
2057             raise TypeError("None is not a valid Unit")
2058 
2059         else:
2060             raise TypeError(f"{s} can not be converted to a Unit")
2061 
2062 
2063 class Unit(NamedUnit, metaclass=_UnitMetaClass):
2064     """
2065     The main unit class.
2066 
2067     There are a number of different ways to construct a Unit, but
2068     always returns a `UnitBase` instance.  If the arguments refer to
2069     an already-existing unit, that existing unit instance is returned,
2070     rather than a new one.
2071 
2072     - From a string::
2073 
2074         Unit(s, format=None, parse_strict='silent')
2075 
2076       Construct from a string representing a (possibly compound) unit.
2077 
2078       The optional `format` keyword argument specifies the format the
2079       string is in, by default ``"generic"``.  For a description of
2080       the available formats, see `astropy.units.format`.
2081 
2082       The optional ``parse_strict`` keyword controls what happens when an
2083       unrecognized unit string is passed in.  It may be one of the following:
2084 
2085          - ``'raise'``: (default) raise a ValueError exception.
2086 
2087          - ``'warn'``: emit a Warning, and return an
2088            `UnrecognizedUnit` instance.
2089 
2090          - ``'silent'``: return an `UnrecognizedUnit` instance.
2091 
2092     - From a number::
2093 
2094         Unit(number)
2095 
2096       Creates a dimensionless unit.
2097 
2098     - From a `UnitBase` instance::
2099 
2100         Unit(unit)
2101 
2102       Returns the given unit unchanged.
2103 
2104     - From no arguments::
2105 
2106         Unit()
2107 
2108       Returns the dimensionless unit.
2109 
2110     - The last form, which creates a new `Unit` is described in detail
2111       below.
2112 
2113     See also: https://docs.astropy.org/en/stable/units/
2114 
2115     Parameters
2116     ----------
2117     st : str or list of str
2118         The name of the unit.  If a list, the first element is the
2119         canonical (short) name, and the rest of the elements are
2120         aliases.
2121 
2122     represents : UnitBase instance
2123         The unit that this named unit represents.
2124 
2125     doc : str, optional
2126         A docstring describing the unit.
2127 
2128     format : dict, optional
2129         A mapping to format-specific representations of this unit.
2130         For example, for the ``Ohm`` unit, it might be nice to have it
2131         displayed as ``\\Omega`` by the ``latex`` formatter.  In that
2132         case, `format` argument should be set to::
2133 
2134             {'latex': r'\\Omega'}
2135 
2136     namespace : dict, optional
2137         When provided, inject the unit (and all of its aliases) into
2138         the given namespace.
2139 
2140     Raises
2141     ------
2142     ValueError
2143         If any of the given unit names are already in the registry.
2144 
2145     ValueError
2146         If any of the given unit names are not valid Python tokens.
2147     """
2148 
2149     def __init__(self, st, represents=None, doc=None,
2150                  format=None, namespace=None):
2151 
2152         represents = Unit(represents)
2153         self._represents = represents
2154 
2155         NamedUnit.__init__(self, st, namespace=namespace, doc=doc,
2156                            format=format)
2157 
2158     @property
2159     def represents(self):
2160         """The unit that this named unit represents."""
2161         return self._represents
2162 
2163     def decompose(self, bases=set()):
2164         return self._represents.decompose(bases=bases)
2165 
2166     def is_unity(self):
2167         return self._represents.is_unity()
2168 
2169     def __hash__(self):
2170         if self._hash is None:
2171             self._hash = hash((self.name, self._represents))
2172         return self._hash
2173 
2174     @classmethod
2175     def _from_physical_type_id(cls, physical_type_id):
2176         # get string bases and powers from the ID tuple
2177         bases = [cls(base) for base, _ in physical_type_id]
2178         powers = [power for _, power in physical_type_id]
2179 
2180         if len(physical_type_id) == 1 and powers[0] == 1:
2181             unit = bases[0]
2182         else:
2183             unit = CompositeUnit(1, bases, powers,
2184                                  _error_check=False)
2185 
2186         return unit
2187 
2188 
2189 class PrefixUnit(Unit):
2190     """
2191     A unit that is simply a SI-prefixed version of another unit.
2192 
2193     For example, ``mm`` is a `PrefixUnit` of ``.001 * m``.
2194 
2195     The constructor is the same as for `Unit`.
2196     """
2197 
2198 
2199 class CompositeUnit(UnitBase):
2200     """
2201     Create a composite unit using expressions of previously defined
2202     units.
2203 
2204     Direct use of this class is not recommended. Instead use the
2205     factory function `Unit` and arithmetic operators to compose
2206     units.
2207 
2208     Parameters
2209     ----------
2210     scale : number
2211         A scaling factor for the unit.
2212 
2213     bases : sequence of `UnitBase`
2214         A sequence of units this unit is composed of.
2215 
2216     powers : sequence of numbers
2217         A sequence of powers (in parallel with ``bases``) for each
2218         of the base units.
2219     """
2220     _decomposed_cache = None
2221 
2222     def __init__(self, scale, bases, powers, decompose=False,
2223                  decompose_bases=set(), _error_check=True):
2224         # There are many cases internal to astropy.units where we
2225         # already know that all the bases are Unit objects, and the
2226         # powers have been validated.  In those cases, we can skip the
2227         # error checking for performance reasons.  When the private
2228         # kwarg `_error_check` is False, the error checking is turned
2229         # off.
2230         if _error_check:
2231             for base in bases:
2232                 if not isinstance(base, UnitBase):
2233                     raise TypeError(
2234                         "bases must be sequence of UnitBase instances")
2235             powers = [validate_power(p) for p in powers]
2236 
2237         if not decompose and len(bases) == 1 and powers[0] >= 0:
2238             # Short-cut; with one unit there's nothing to expand and gather,
2239             # as that has happened already when creating the unit.  But do only
2240             # positive powers, since for negative powers we need to re-sort.
2241             unit = bases[0]
2242             power = powers[0]
2243             if power == 1:
2244                 scale *= unit.scale
2245                 self._bases = unit.bases
2246                 self._powers = unit.powers
2247             elif power == 0:
2248                 self._bases = []
2249                 self._powers = []
2250             else:
2251                 scale *= unit.scale ** power
2252                 self._bases = unit.bases
2253                 self._powers = [operator.mul(*resolve_fractions(p, power))
2254                                 for p in unit.powers]
2255 
2256             self._scale = sanitize_scale(scale)
2257         else:
2258             # Regular case: use inputs as preliminary scale, bases, and powers,
2259             # then "expand and gather" identical bases, sanitize the scale, &c.
2260             self._scale = scale
2261             self._bases = bases
2262             self._powers = powers
2263             self._expand_and_gather(decompose=decompose,
2264                                     bases=decompose_bases)
2265 
2266     def __repr__(self):
2267         if len(self._bases):
2268             return super().__repr__()
2269         else:
2270             if self._scale != 1.0:
2271                 return f'Unit(dimensionless with a scale of {self._scale})'
2272             else:
2273                 return 'Unit(dimensionless)'
2274 
2275     @property
2276     def scale(self):
2277         """
2278         Return the scale of the composite unit.
2279         """
2280         return self._scale
2281 
2282     @property
2283     def bases(self):
2284         """
2285         Return the bases of the composite unit.
2286         """
2287         return self._bases
2288 
2289     @property
2290     def powers(self):
2291         """
2292         Return the powers of the composite unit.
2293         """
2294         return self._powers
2295 
2296     def _expand_and_gather(self, decompose=False, bases=set()):
2297         def add_unit(unit, power, scale):
2298             if bases and unit not in bases:
2299                 for base in bases:
2300                     try:
2301                         scale *= unit._to(base) ** power
2302                     except UnitsError:
2303                         pass
2304                     else:
2305                         unit = base
2306                         break
2307 
2308             if unit in new_parts:
2309                 a, b = resolve_fractions(new_parts[unit], power)
2310                 new_parts[unit] = a + b
2311             else:
2312                 new_parts[unit] = power
2313             return scale
2314 
2315         new_parts = {}
2316         scale = self._scale
2317 
2318         for b, p in zip(self._bases, self._powers):
2319             if decompose and b not in bases:
2320                 b = b.decompose(bases=bases)
2321 
2322             if isinstance(b, CompositeUnit):
2323                 scale *= b._scale ** p
2324                 for b_sub, p_sub in zip(b._bases, b._powers):
2325                     a, b = resolve_fractions(p_sub, p)
2326                     scale = add_unit(b_sub, a * b, scale)
2327             else:
2328                 scale = add_unit(b, p, scale)
2329 
2330         new_parts = [x for x in new_parts.items() if x[1] != 0]
2331         new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))
2332 
2333         self._bases = [x[0] for x in new_parts]
2334         self._powers = [x[1] for x in new_parts]
2335         self._scale = sanitize_scale(scale)
2336 
2337     def __copy__(self):
2338         """
2339         For compatibility with python copy module.
2340         """
2341         return CompositeUnit(self._scale, self._bases[:], self._powers[:])
2342 
2343     def decompose(self, bases=set()):
2344         if len(bases) == 0 and self._decomposed_cache is not None:
2345             return self._decomposed_cache
2346 
2347         for base in self.bases:
2348             if (not isinstance(base, IrreducibleUnit) or
2349                     (len(bases) and base not in bases)):
2350                 break
2351         else:
2352             if len(bases) == 0:
2353                 self._decomposed_cache = self
2354             return self
2355 
2356         x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True,
2357                           decompose_bases=bases)
2358         if len(bases) == 0:
2359             self._decomposed_cache = x
2360         return x
2361 
2362     def is_unity(self):
2363         unit = self.decompose()
2364         return len(unit.bases) == 0 and unit.scale == 1.0
2365 
2366 
2367 si_prefixes = [
2368     (['Y'], ['yotta'], 1e24),
2369     (['Z'], ['zetta'], 1e21),
2370     (['E'], ['exa'], 1e18),
2371     (['P'], ['peta'], 1e15),
2372     (['T'], ['tera'], 1e12),
2373     (['G'], ['giga'], 1e9),
2374     (['M'], ['mega'], 1e6),
2375     (['k'], ['kilo'], 1e3),
2376     (['h'], ['hecto'], 1e2),
2377     (['da'], ['deka', 'deca'], 1e1),
2378     (['d'], ['deci'], 1e-1),
2379     (['c'], ['centi'], 1e-2),
2380     (['m'], ['milli'], 1e-3),
2381     (['u'], ['micro'], 1e-6),
2382     (['n'], ['nano'], 1e-9),
2383     (['p'], ['pico'], 1e-12),
2384     (['f'], ['femto'], 1e-15),
2385     (['a'], ['atto'], 1e-18),
2386     (['z'], ['zepto'], 1e-21),
2387     (['y'], ['yocto'], 1e-24)
2388 ]
2389 
2390 
2391 binary_prefixes = [
2392     (['Ki'], ['kibi'], 2. ** 10),
2393     (['Mi'], ['mebi'], 2. ** 20),
2394     (['Gi'], ['gibi'], 2. ** 30),
2395     (['Ti'], ['tebi'], 2. ** 40),
2396     (['Pi'], ['pebi'], 2. ** 50),
2397     (['Ei'], ['exbi'], 2. ** 60)
2398 ]
2399 
2400 
2401 def _add_prefixes(u, excludes=[], namespace=None, prefixes=False):
2402     """
2403     Set up all of the standard metric prefixes for a unit.  This
2404     function should not be used directly, but instead use the
2405     `prefixes` kwarg on `def_unit`.
2406 
2407     Parameters
2408     ----------
2409     excludes : list of str, optional
2410         Any prefixes to exclude from creation to avoid namespace
2411         collisions.
2412 
2413     namespace : dict, optional
2414         When provided, inject the unit (and all of its aliases) into
2415         the given namespace dictionary.
2416 
2417     prefixes : list, optional
2418         When provided, it is a list of prefix definitions of the form:
2419 
2420             (short_names, long_tables, factor)
2421     """
2422     if prefixes is True:
2423         prefixes = si_prefixes
2424     elif prefixes is False:
2425         prefixes = []
2426 
2427     for short, full, factor in prefixes:
2428         names = []
2429         format = {}
2430         for prefix in short:
2431             if prefix in excludes:
2432                 continue
2433 
2434             for alias in u.short_names:
2435                 names.append(prefix + alias)
2436 
2437                 # This is a hack to use Greek mu as a prefix
2438                 # for some formatters.
2439                 if prefix == 'u':
2440                     format['latex'] = r'\mu ' + u.get_format_name('latex')
2441                     format['unicode'] = '\N{MICRO SIGN}' + u.get_format_name('unicode')
2442 
2443                 for key, val in u._format.items():
2444                     format.setdefault(key, prefix + val)
2445 
2446         for prefix in full:
2447             if prefix in excludes:
2448                 continue
2449 
2450             for alias in u.long_names:
2451                 names.append(prefix + alias)
2452 
2453         if len(names):
2454             PrefixUnit(names, CompositeUnit(factor, [u], [1],
2455                                             _error_check=False),
2456                        namespace=namespace, format=format)
2457 
2458 
2459 def def_unit(s, represents=None, doc=None, format=None, prefixes=False,
2460              exclude_prefixes=[], namespace=None):
2461     """
2462     Factory function for defining new units.
2463 
2464     Parameters
2465     ----------
2466     s : str or list of str
2467         The name of the unit.  If a list, the first element is the
2468         canonical (short) name, and the rest of the elements are
2469         aliases.
2470 
2471     represents : UnitBase instance, optional
2472         The unit that this named unit represents.  If not provided,
2473         a new `IrreducibleUnit` is created.
2474 
2475     doc : str, optional
2476         A docstring describing the unit.
2477 
2478     format : dict, optional
2479         A mapping to format-specific representations of this unit.
2480         For example, for the ``Ohm`` unit, it might be nice to
2481         have it displayed as ``\\Omega`` by the ``latex``
2482         formatter.  In that case, `format` argument should be set
2483         to::
2484 
2485             {'latex': r'\\Omega'}
2486 
2487     prefixes : bool or list, optional
2488         When `True`, generate all of the SI prefixed versions of the
2489         unit as well.  For example, for a given unit ``m``, will
2490         generate ``mm``, ``cm``, ``km``, etc.  When a list, it is a list of
2491         prefix definitions of the form:
2492 
2493             (short_names, long_tables, factor)
2494 
2495         Default is `False`.  This function always returns the base
2496         unit object, even if multiple scaled versions of the unit were
2497         created.
2498 
2499     exclude_prefixes : list of str, optional
2500         If any of the SI prefixes need to be excluded, they may be
2501         listed here.  For example, ``Pa`` can be interpreted either as
2502         "petaannum" or "Pascal".  Therefore, when defining the
2503         prefixes for ``a``, ``exclude_prefixes`` should be set to
2504         ``["P"]``.
2505 
2506     namespace : dict, optional
2507         When provided, inject the unit (and all of its aliases and
2508         prefixes), into the given namespace dictionary.
2509 
2510     Returns
2511     -------
2512     unit : `~astropy.units.UnitBase`
2513         The newly-defined unit, or a matching unit that was already
2514         defined.
2515     """
2516 
2517     if represents is not None:
2518         result = Unit(s, represents, namespace=namespace, doc=doc,
2519                       format=format)
2520     else:
2521         result = IrreducibleUnit(
2522             s, namespace=namespace, doc=doc, format=format)
2523 
2524     if prefixes:
2525         _add_prefixes(result, excludes=exclude_prefixes, namespace=namespace,
2526                       prefixes=prefixes)
2527     return result
2528 
2529 
2530 def _condition_arg(value):
2531     """
2532     Validate value is acceptable for conversion purposes.
2533 
2534     Will convert into an array if not a scalar, and can be converted
2535     into an array
2536 
2537     Parameters
2538     ----------
2539     value : int or float value, or sequence of such values
2540 
2541     Returns
2542     -------
2543     Scalar value or numpy array
2544 
2545     Raises
2546     ------
2547     ValueError
2548         If value is not as expected
2549     """
2550     if isinstance(value, (np.ndarray, float, int, complex, np.void)):
2551         return value
2552 
2553     avalue = np.array(value)
2554     if avalue.dtype.kind not in ['i', 'f', 'c']:
2555         raise ValueError("Value not scalar compatible or convertible to "
2556                          "an int, float, or complex array")
2557     return avalue
2558 
2559 
2560 def unit_scale_converter(val):
2561     """Function that just multiplies the value by unity.
2562 
2563     This is a separate function so it can be recognized and
2564     discarded in unit conversion.
2565     """
2566     return 1. * _condition_arg(val)
2567 
2568 
2569 dimensionless_unscaled = CompositeUnit(1, [], [], _error_check=False)
2570 # Abbreviation of the above, see #1980
2571 one = dimensionless_unscaled
2572 
2573 # Maintain error in old location for backward compatibility
2574 # TODO: Is this still needed? Should there be a deprecation warning?
2575 unit_format.fits.UnitScaleError = UnitScaleError

</code><intended_behavior>Although not directly a bug, enhancing the use of 'def_unit' or a similar mechanism within cosmology parameters to specify their MathJax representation is required. This enhancement means improving or leveraging the 'format' attribute in cosmology parameters, ensuring that when these parameters are converted into HTML table entries, their MathJax representation is used.</intended_behavior>]
2025-10-15 15:25:38.848 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:25:38.848 | INFO     | Search-only: skipping patch selection
2025-10-15 15:25:38.954 | INFO     | Task astropy__astropy-13075 completed successfully.
2025-10-15 15:25:38.955 | INFO     | No patch generated. You can try running ACR again.
