2025-10-15 19:13:34.623 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 19:13:37.729 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=190, output_tokens=12, cost=0.002260
2025-10-15 19:13:37.730 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 19:13:37.734 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:13:47.356 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=499, output_tokens=294, cost=0.013810
2025-10-15 19:13:47.381 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:13:50.248 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=53, cost=0.008070
2025-10-15 19:13:50.249 | DEBUG    | Extracted a valid json.
2025-10-15 19:13:50.249 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ManyToManyField\")",
        "search_code(\"ManyToManyField\")",
        "search_method_in_class(\"__init__\", \"ManyToManyField\")"
    ],
    "bug_locations": []
}
2025-10-15 19:13:50.332 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 19:13:50.333 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 19:14:04.760 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2148, output_tokens=586, cost=0.039060
2025-10-15 19:14:04.767 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:14:12.620 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2950, output_tokens=277, cost=0.037810
2025-10-15 19:14:12.624 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:14:20.683 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=631, output_tokens=234, cost=0.013330
2025-10-15 19:14:20.684 | DEBUG    | Extracted a valid json.
2025-10-15 19:14:20.684 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "__init__",
            "intended_behavior": "The `__init__` method should include a new validation segment after determining the value of `symmetrical`. This segment should check if `symmetrical` is `True` and `related_name` is provided (not `None`). If both conditions are met, the method should raise a ValueError (or a more specific custom exception), indicating that specifying a `related_name` for symmetrical `ManyToManyField` is invalid. This ensures clarity for developers about the non-creation of the related field on the target model when `symmetrical=True` and preserves the congruity and integrity of the model relationships by preventing misuse. This intended change is designed to alert developers early in the development process to an incorrect use of `ManyToManyField`, preventing bugs and confusion that might result from misunderstanding the purpose and behavior of the `symmetrical` attribute in relation to `related_name`."
        }
    ]
}
2025-10-15 19:14:20.688 | DEBUG    | Found override of __init__ in RelatedField
2025-10-15 19:14:20.688 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x7fd54d722c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x7fd45b357080>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x7fd45d67e3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x7fd45b357080>, <app.raw_tasks.RawSweTask object at 0x7fd45b3570b0>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x7fd45d67e480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x7fd45b28a1e0>
    └ <function run_task_in_subprocess at 0x7fd45d67e660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x7fd45b28a1e0>
    │        │      └ <function run_raw_task at 0x7fd45d67e700>
    │        └ <function ProcessPoolExecutor.submit at 0x7fd54d336020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x7fd54d335da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x7fd54d335ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x7fd54d335f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7fd45e31aa50>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x7fd54d4fcea0>
    └ <ForkProcess name='ForkProcess-171' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-171' parent=188003 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x7fd54d56e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-171' parent=188003 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-171' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-171' parent=188003 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-171' parent=188003 started>
    │    └ <function Popen._launch at 0x7fd45b6737e0>
    └ <multiprocessing.popen_fork.Popen object at 0x7fd45c9618b0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x7fd54d4fd8a0>
           └ <ForkProcess name='ForkProcess-171' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x7fd54d4fce00>
    └ <ForkProcess name='ForkProcess-171' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-171' parent=188003 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x7fd45d874890>, <multiprocessing.queues.SimpleQueue object at 0x7fd45b3a9e...
    │    │        └ <ForkProcess name='ForkProcess-171' parent=188003 started>
    │    └ <function _process_worker at 0x7fd54d3351c0>
    └ <ForkProcess name='ForkProcess-171' parent=188003 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x7fd45c961850>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>
        │         └ <function run_raw_task at 0x7fd45d67e700>
        └ <concurrent.futures.process._CallItem object at 0x7fd45bb815b0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output2/django__django-14730_2025-10-15_19-13-34'
             │            │    └ <function RawSweTask.to_task at 0x7fd45d67d6c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x7fd45c961850>
             └ <function do_inference at 0x7fd45d67e8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x7fd45d8e0400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7fd45dd084a0>
       │                 │         │            └ SweTask(task_id='django__django-14730', problem_statement="Prevent developers from defining a related_name on symmetrical Man...
       │                 │         └ <app.manage.ProjectApiManager object at 0x7fd45d8dd3a0>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output2/django__django-14730_2025-10-15_19-13-34/output_0')
       └ <function _run_one_task at 0x7fd45d8e18a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x7fd45d995bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x7fd45d827050>
                                  └ <app.manage.ProjectApiManager object at 0x7fd45d8dd3a0>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'django/db/models/fields/related.py', 'class': 'ManyToManyField', 'method': '__init__', 'intended_behavior': 'The `_...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x7fd45d9958a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x7fd45e6ed7f0>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x7fd45d827050>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '__init__'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/db/mo...
    │    │                      │   └ 'ManyToManyField'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/db/mo...
    │    └ <function SearchBackend._get_inherited_methods at 0x7fd45d995800>
    └ <app.search.search_backend.SearchBackend object at 0x7fd45e6ed7f0>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'RelatedField', 'method_name': '__init__'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x7fd45d994f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x7fd45e6ed7f0>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x7fd45e6ed7f0>, {'class_name': 'RelatedField', 'method_name': '__init__'})
           └ <function SearchBackend.search_method_in_class at 0x7fd45d994ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-15 19:14:20.696 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>__init__</method>
<code>
1165     def __init__(self, to, related_name=None, related_query_name=None,
1166                  limit_choices_to=None, symmetrical=None, through=None,
1167                  through_fields=None, db_constraint=True, db_table=None,
1168                  swappable=True, **kwargs):
1169         try:
1170             to._meta
1171         except AttributeError:
1172             if not isinstance(to, str):
1173                 raise TypeError(
1174                     '%s(%r) is invalid. First parameter to ManyToManyField '
1175                     'must be either a model, a model name, or the string %r' % (
1176                         self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT,
1177                     )
1178                 )
1179 
1180         if symmetrical is None:
1181             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1182 
1183         if through is not None and db_table is not None:
1184             raise ValueError(
1185                 'Cannot specify a db_table if an intermediary model is used.'
1186             )
1187 
1188         kwargs['rel'] = self.rel_class(
1189             self, to,
1190             related_name=related_name,
1191             related_query_name=related_query_name,
1192             limit_choices_to=limit_choices_to,
1193             symmetrical=symmetrical,
1194             through=through,
1195             through_fields=through_fields,
1196             db_constraint=db_constraint,
1197         )
1198         self.has_null_arg = 'null' in kwargs
1199 
1200         super().__init__(
1201             related_name=related_name,
1202             related_query_name=related_query_name,
1203             limit_choices_to=limit_choices_to,
1204             **kwargs,
1205         )
1206 
1207         self.db_table = db_table
1208         self.swappable = swappable

</code><intended_behavior>The `__init__` method should include a new validation segment after determining the value of `symmetrical`. This segment should check if `symmetrical` is `True` and `related_name` is provided (not `None`). If both conditions are met, the method should raise a ValueError (or a more specific custom exception), indicating that specifying a `related_name` for symmetrical `ManyToManyField` is invalid. This ensures clarity for developers about the non-creation of the related field on the target model when `symmetrical=True` and preserves the congruity and integrity of the model relationships by preventing misuse. This intended change is designed to alert developers early in the development process to an incorrect use of `ManyToManyField`, preventing bugs and confusion that might result from misunderstanding the purpose and behavior of the `symmetrical` attribute in relation to `related_name`.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1145 class ManyToManyField(RelatedField):
1146     """
1147     Provide a many-to-many relation by using an intermediary model that
1148     holds two ForeignKey fields pointed at the two sides of the relation.
1149 
1150     Unless a ``through`` model was provided, ManyToManyField will use the
1151     create_many_to_many_intermediary_model factory to automatically generate
1152     the intermediary model.
1153     """
1154 
1155     # Field flags
1156     many_to_many = True
1157     many_to_one = False
1158     one_to_many = False
1159     one_to_one = False
1160 
1161     rel_class = ManyToManyRel
1162 
1163     description = _("Many-to-many relationship")
1164 
1165     def __init__(self, to, related_name=None, related_query_name=None,
1166                  limit_choices_to=None, symmetrical=None, through=None,
1167                  through_fields=None, db_constraint=True, db_table=None,
1168                  swappable=True, **kwargs):
1169         try:
1170             to._meta
1171         except AttributeError:
1172             if not isinstance(to, str):
1173                 raise TypeError(
1174                     '%s(%r) is invalid. First parameter to ManyToManyField '
1175                     'must be either a model, a model name, or the string %r' % (
1176                         self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT,
1177                     )
1178                 )
1179 
1180         if symmetrical is None:
1181             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1182 
1183         if through is not None and db_table is not None:
1184             raise ValueError(
1185                 'Cannot specify a db_table if an intermediary model is used.'
1186             )
1187 
1188         kwargs['rel'] = self.rel_class(
1189             self, to,
1190             related_name=related_name,
1191             related_query_name=related_query_name,
1192             limit_choices_to=limit_choices_to,
1193             symmetrical=symmetrical,
1194             through=through,
1195             through_fields=through_fields,
1196             db_constraint=db_constraint,
1197         )
1198         self.has_null_arg = 'null' in kwargs
1199 
1200         super().__init__(
1201             related_name=related_name,
1202             related_query_name=related_query_name,
1203             limit_choices_to=limit_choices_to,
1204             **kwargs,
1205         )
1206 
1207         self.db_table = db_table
1208         self.swappable = swappable
1209 
1210     def check(self, **kwargs):
1211         return [
1212             *super().check(**kwargs),
1213             *self._check_unique(**kwargs),
1214             *self._check_relationship_model(**kwargs),
1215             *self._check_ignored_options(**kwargs),
1216             *self._check_table_uniqueness(**kwargs),
1217         ]
1218 
1219     def _check_unique(self, **kwargs):
1220         if self.unique:
1221             return [
1222                 checks.Error(
1223                     'ManyToManyFields cannot be unique.',
1224                     obj=self,
1225                     id='fields.E330',
1226                 )
1227             ]
1228         return []
1229 
1230     def _check_ignored_options(self, **kwargs):
1231         warnings = []
1232 
1233         if self.has_null_arg:
1234             warnings.append(
1235                 checks.Warning(
1236                     'null has no effect on ManyToManyField.',
1237                     obj=self,
1238                     id='fields.W340',
1239                 )
1240             )
1241 
1242         if self._validators:
1243             warnings.append(
1244                 checks.Warning(
1245                     'ManyToManyField does not support validators.',
1246                     obj=self,
1247                     id='fields.W341',
1248                 )
1249             )
1250         if (self.remote_field.limit_choices_to and self.remote_field.through and
1251                 not self.remote_field.through._meta.auto_created):
1252             warnings.append(
1253                 checks.Warning(
1254                     'limit_choices_to has no effect on ManyToManyField '
1255                     'with a through model.',
1256                     obj=self,
1257                     id='fields.W343',
1258                 )
1259             )
1260 
1261         return warnings
1262 
1263     def _check_relationship_model(self, from_model=None, **kwargs):
1264         if hasattr(self.remote_field.through, '_meta'):
1265             qualified_model_name = "%s.%s" % (
1266                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1267         else:
1268             qualified_model_name = self.remote_field.through
1269 
1270         errors = []
1271 
1272         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1273             # The relationship model is not installed.
1274             errors.append(
1275                 checks.Error(
1276                     "Field specifies a many-to-many relation through model "
1277                     "'%s', which has not been installed." % qualified_model_name,
1278                     obj=self,
1279                     id='fields.E331',
1280                 )
1281             )
1282 
1283         else:
1284             assert from_model is not None, (
1285                 "ManyToManyField with intermediate "
1286                 "tables cannot be checked if you don't pass the model "
1287                 "where the field is attached to."
1288             )
1289             # Set some useful local variables
1290             to_model = resolve_relation(from_model, self.remote_field.model)
1291             from_model_name = from_model._meta.object_name
1292             if isinstance(to_model, str):
1293                 to_model_name = to_model
1294             else:
1295                 to_model_name = to_model._meta.object_name
1296             relationship_model_name = self.remote_field.through._meta.object_name
1297             self_referential = from_model == to_model
1298             # Count foreign keys in intermediate model
1299             if self_referential:
1300                 seen_self = sum(
1301                     from_model == getattr(field.remote_field, 'model', None)
1302                     for field in self.remote_field.through._meta.fields
1303                 )
1304 
1305                 if seen_self > 2 and not self.remote_field.through_fields:
1306                     errors.append(
1307                         checks.Error(
1308                             "The model is used as an intermediate model by "
1309                             "'%s', but it has more than two foreign keys "
1310                             "to '%s', which is ambiguous. You must specify "
1311                             "which two foreign keys Django should use via the "
1312                             "through_fields keyword argument." % (self, from_model_name),
1313                             hint="Use through_fields to specify which two foreign keys Django should use.",
1314                             obj=self.remote_field.through,
1315                             id='fields.E333',
1316                         )
1317                     )
1318 
1319             else:
1320                 # Count foreign keys in relationship model
1321                 seen_from = sum(
1322                     from_model == getattr(field.remote_field, 'model', None)
1323                     for field in self.remote_field.through._meta.fields
1324                 )
1325                 seen_to = sum(
1326                     to_model == getattr(field.remote_field, 'model', None)
1327                     for field in self.remote_field.through._meta.fields
1328                 )
1329 
1330                 if seen_from > 1 and not self.remote_field.through_fields:
1331                     errors.append(
1332                         checks.Error(
1333                             ("The model is used as an intermediate model by "
1334                              "'%s', but it has more than one foreign key "
1335                              "from '%s', which is ambiguous. You must specify "
1336                              "which foreign key Django should use via the "
1337                              "through_fields keyword argument.") % (self, from_model_name),
1338                             hint=(
1339                                 'If you want to create a recursive relationship, '
1340                                 'use ManyToManyField("%s", through="%s").'
1341                             ) % (
1342                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1343                                 relationship_model_name,
1344                             ),
1345                             obj=self,
1346                             id='fields.E334',
1347                         )
1348                     )
1349 
1350                 if seen_to > 1 and not self.remote_field.through_fields:
1351                     errors.append(
1352                         checks.Error(
1353                             "The model is used as an intermediate model by "
1354                             "'%s', but it has more than one foreign key "
1355                             "to '%s', which is ambiguous. You must specify "
1356                             "which foreign key Django should use via the "
1357                             "through_fields keyword argument." % (self, to_model_name),
1358                             hint=(
1359                                 'If you want to create a recursive relationship, '
1360                                 'use ManyToManyField("%s", through="%s").'
1361                             ) % (
1362                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1363                                 relationship_model_name,
1364                             ),
1365                             obj=self,
1366                             id='fields.E335',
1367                         )
1368                     )
1369 
1370                 if seen_from == 0 or seen_to == 0:
1371                     errors.append(
1372                         checks.Error(
1373                             "The model is used as an intermediate model by "
1374                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1375                                 self, from_model_name, to_model_name
1376                             ),
1377                             obj=self.remote_field.through,
1378                             id='fields.E336',
1379                         )
1380                     )
1381 
1382         # Validate `through_fields`.
1383         if self.remote_field.through_fields is not None:
1384             # Validate that we're given an iterable of at least two items
1385             # and that none of them is "falsy".
1386             if not (len(self.remote_field.through_fields) >= 2 and
1387                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1388                 errors.append(
1389                     checks.Error(
1390                         "Field specifies 'through_fields' but does not provide "
1391                         "the names of the two link fields that should be used "
1392                         "for the relation through model '%s'." % qualified_model_name,
1393                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1394                         obj=self,
1395                         id='fields.E337',
1396                     )
1397                 )
1398 
1399             # Validate the given through fields -- they should be actual
1400             # fields on the through model, and also be foreign keys to the
1401             # expected models.
1402             else:
1403                 assert from_model is not None, (
1404                     "ManyToManyField with intermediate "
1405                     "tables cannot be checked if you don't pass the model "
1406                     "where the field is attached to."
1407                 )
1408 
1409                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1410                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1411 
1412                 for field_name, related_model in ((source_field_name, source),
1413                                                   (target_field_name, target)):
1414 
1415                     possible_field_names = []
1416                     for f in through._meta.fields:
1417                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1418                             possible_field_names.append(f.name)
1419                     if possible_field_names:
1420                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1421                             related_model._meta.object_name,
1422                             ', '.join(possible_field_names),
1423                         )
1424                     else:
1425                         hint = None
1426 
1427                     try:
1428                         field = through._meta.get_field(field_name)
1429                     except exceptions.FieldDoesNotExist:
1430                         errors.append(
1431                             checks.Error(
1432                                 "The intermediary model '%s' has no field '%s'."
1433                                 % (qualified_model_name, field_name),
1434                                 hint=hint,
1435                                 obj=self,
1436                                 id='fields.E338',
1437                             )
1438                         )
1439                     else:
1440                         if not (hasattr(field, 'remote_field') and
1441                                 getattr(field.remote_field, 'model', None) == related_model):
1442                             errors.append(
1443                                 checks.Error(
1444                                     "'%s.%s' is not a foreign key to '%s'." % (
1445                                         through._meta.object_name, field_name,
1446                                         related_model._meta.object_name,
1447                                     ),
1448                                     hint=hint,
1449                                     obj=self,
1450                                     id='fields.E339',
1451                                 )
1452                             )
1453 
1454         return errors
1455 
1456     def _check_table_uniqueness(self, **kwargs):
1457         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1458             return []
1459         registered_tables = {
1460             model._meta.db_table: model
1461             for model in self.opts.apps.get_models(include_auto_created=True)
1462             if model != self.remote_field.through and model._meta.managed
1463         }
1464         m2m_db_table = self.m2m_db_table()
1465         model = registered_tables.get(m2m_db_table)
1466         # The second condition allows multiple m2m relations on a model if
1467         # some point to a through model that proxies another through model.
1468         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1469             if model._meta.auto_created:
1470                 def _get_field_name(model):
1471                     for field in model._meta.auto_created._meta.many_to_many:
1472                         if field.remote_field.through is model:
1473                             return field.name
1474                 opts = model._meta.auto_created._meta
1475                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1476             else:
1477                 clashing_obj = model._meta.label
1478             if settings.DATABASE_ROUTERS:
1479                 error_class, error_id = checks.Warning, 'fields.W344'
1480                 error_hint = (
1481                     'You have configured settings.DATABASE_ROUTERS. Verify '
1482                     'that the table of %r is correctly routed to a separate '
1483                     'database.' % clashing_obj
1484                 )
1485             else:
1486                 error_class, error_id = checks.Error, 'fields.E340'
1487                 error_hint = None
1488             return [
1489                 error_class(
1490                     "The field's intermediary table '%s' clashes with the "
1491                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1492                     obj=self,
1493                     hint=error_hint,
1494                     id=error_id,
1495                 )
1496             ]
1497         return []
1498 
1499     def deconstruct(self):
1500         name, path, args, kwargs = super().deconstruct()
1501         # Handle the simpler arguments.
1502         if self.db_table is not None:
1503             kwargs['db_table'] = self.db_table
1504         if self.remote_field.db_constraint is not True:
1505             kwargs['db_constraint'] = self.remote_field.db_constraint
1506         # Rel needs more work.
1507         if isinstance(self.remote_field.model, str):
1508             kwargs['to'] = self.remote_field.model
1509         else:
1510             kwargs['to'] = self.remote_field.model._meta.label
1511         if getattr(self.remote_field, 'through', None) is not None:
1512             if isinstance(self.remote_field.through, str):
1513                 kwargs['through'] = self.remote_field.through
1514             elif not self.remote_field.through._meta.auto_created:
1515                 kwargs['through'] = self.remote_field.through._meta.label
1516         # If swappable is True, then see if we're actually pointing to the target
1517         # of a swap.
1518         swappable_setting = self.swappable_setting
1519         if swappable_setting is not None:
1520             # If it's already a settings reference, error.
1521             if hasattr(kwargs['to'], "setting_name"):
1522                 if kwargs['to'].setting_name != swappable_setting:
1523                     raise ValueError(
1524                         "Cannot deconstruct a ManyToManyField pointing to a "
1525                         "model that is swapped in place of more than one model "
1526                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1527                     )
1528 
1529             kwargs['to'] = SettingsReference(
1530                 kwargs['to'],
1531                 swappable_setting,
1532             )
1533         return name, path, args, kwargs
1534 
1535     def _get_path_info(self, direct=False, filtered_relation=None):
1536         """Called by both direct and indirect m2m traversal."""
1537         int_model = self.remote_field.through
1538         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1539         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1540         if direct:
1541             join1infos = linkfield1.get_reverse_path_info()
1542             join2infos = linkfield2.get_path_info(filtered_relation)
1543         else:
1544             join1infos = linkfield2.get_reverse_path_info()
1545             join2infos = linkfield1.get_path_info(filtered_relation)
1546 
1547         # Get join infos between the last model of join 1 and the first model
1548         # of join 2. Assume the only reason these may differ is due to model
1549         # inheritance.
1550         join1_final = join1infos[-1].to_opts
1551         join2_initial = join2infos[0].from_opts
1552         if join1_final is join2_initial:
1553             intermediate_infos = []
1554         elif issubclass(join1_final.model, join2_initial.model):
1555             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1556         else:
1557             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1558 
1559         return [*join1infos, *intermediate_infos, *join2infos]
1560 
1561     def get_path_info(self, filtered_relation=None):
1562         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1563 
1564     def get_reverse_path_info(self, filtered_relation=None):
1565         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1566 
1567     def _get_m2m_db_table(self, opts):
1568         """
1569         Function that can be curried to provide the m2m table name for this
1570         relation.
1571         """
1572         if self.remote_field.through is not None:
1573             return self.remote_field.through._meta.db_table
1574         elif self.db_table:
1575             return self.db_table
1576         else:
1577             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1578             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1579 
1580     def _get_m2m_attr(self, related, attr):
1581         """
1582         Function that can be curried to provide the source accessor or DB
1583         column name for the m2m table.
1584         """
1585         cache_attr = '_m2m_%s_cache' % attr
1586         if hasattr(self, cache_attr):
1587             return getattr(self, cache_attr)
1588         if self.remote_field.through_fields is not None:
1589             link_field_name = self.remote_field.through_fields[0]
1590         else:
1591             link_field_name = None
1592         for f in self.remote_field.through._meta.fields:
1593             if (f.is_relation and f.remote_field.model == related.related_model and
1594                     (link_field_name is None or link_field_name == f.name)):
1595                 setattr(self, cache_attr, getattr(f, attr))
1596                 return getattr(self, cache_attr)
1597 
1598     def _get_m2m_reverse_attr(self, related, attr):
1599         """
1600         Function that can be curried to provide the related accessor or DB
1601         column name for the m2m table.
1602         """
1603         cache_attr = '_m2m_reverse_%s_cache' % attr
1604         if hasattr(self, cache_attr):
1605             return getattr(self, cache_attr)
1606         found = False
1607         if self.remote_field.through_fields is not None:
1608             link_field_name = self.remote_field.through_fields[1]
1609         else:
1610             link_field_name = None
1611         for f in self.remote_field.through._meta.fields:
1612             if f.is_relation and f.remote_field.model == related.model:
1613                 if link_field_name is None and related.related_model == related.model:
1614                     # If this is an m2m-intermediate to self,
1615                     # the first foreign key you find will be
1616                     # the source column. Keep searching for
1617                     # the second foreign key.
1618                     if found:
1619                         setattr(self, cache_attr, getattr(f, attr))
1620                         break
1621                     else:
1622                         found = True
1623                 elif link_field_name is None or link_field_name == f.name:
1624                     setattr(self, cache_attr, getattr(f, attr))
1625                     break
1626         return getattr(self, cache_attr)
1627 
1628     def contribute_to_class(self, cls, name, **kwargs):
1629         # To support multiple relations to self, it's useful to have a non-None
1630         # related name on symmetrical relations for internal reasons. The
1631         # concept doesn't make a lot of sense externally ("you want me to
1632         # specify *what* on my non-reversible relation?!"), so we set it up
1633         # automatically. The funky name reduces the chance of an accidental
1634         # clash.
1635         if self.remote_field.symmetrical and (
1636             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1637             self.remote_field.model == cls._meta.object_name
1638         ):
1639             self.remote_field.related_name = "%s_rel_+" % name
1640         elif self.remote_field.is_hidden():
1641             # If the backwards relation is disabled, replace the original
1642             # related_name with one generated from the m2m field name. Django
1643             # still uses backwards relations internally and we need to avoid
1644             # clashes between multiple m2m fields with related_name == '+'.
1645             self.remote_field.related_name = '_%s_%s_%s_+' % (
1646                 cls._meta.app_label,
1647                 cls.__name__.lower(),
1648                 name,
1649             )
1650 
1651         super().contribute_to_class(cls, name, **kwargs)
1652 
1653         # The intermediate m2m model is not auto created if:
1654         #  1) There is a manually specified intermediate, or
1655         #  2) The class owning the m2m field is abstract.
1656         #  3) The class owning the m2m field has been swapped out.
1657         if not cls._meta.abstract:
1658             if self.remote_field.through:
1659                 def resolve_through_model(_, model, field):
1660                     field.remote_field.through = model
1661                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1662             elif not cls._meta.swapped:
1663                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1664 
1665         # Add the descriptor for the m2m relation.
1666         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1667 
1668         # Set up the accessor for the m2m table name for the relation.
1669         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1670 
1671     def contribute_to_related_class(self, cls, related):
1672         # Internal M2Ms (i.e., those with a related name ending with '+')
1673         # and swapped models don't get a related descriptor.
1674         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1675             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1676 
1677         # Set up the accessors for the column names on the m2m table.
1678         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1679         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1680 
1681         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1682         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1683 
1684         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1685         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1686         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1687         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1688 
1689     def set_attributes_from_rel(self):
1690         pass
1691 
1692     def value_from_object(self, obj):
1693         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1694 
1695     def save_form_data(self, instance, data):
1696         getattr(instance, self.attname).set(data)
1697 
1698     def formfield(self, *, using=None, **kwargs):
1699         defaults = {
1700             'form_class': forms.ModelMultipleChoiceField,
1701             'queryset': self.remote_field.model._default_manager.using(using),
1702             **kwargs,
1703         }
1704         # If initial is passed in, it's a list of related objects, but the
1705         # MultipleChoiceField takes a list of IDs.
1706         if defaults.get('initial') is not None:
1707             initial = defaults['initial']
1708             if callable(initial):
1709                 initial = initial()
1710             defaults['initial'] = [i.pk for i in initial]
1711         return super().formfield(**defaults)
1712 
1713     def db_check(self, connection):
1714         return None
1715 
1716     def db_type(self, connection):
1717         # A ManyToManyField is not represented by a single column,
1718         # so return None.
1719         return None
1720 
1721     def db_parameters(self, connection):
1722         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 19:14:20.696 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>__init__</method>
<code>
1165     def __init__(self, to, related_name=None, related_query_name=None,
1166                  limit_choices_to=None, symmetrical=None, through=None,
1167                  through_fields=None, db_constraint=True, db_table=None,
1168                  swappable=True, **kwargs):
1169         try:
1170             to._meta
1171         except AttributeError:
1172             if not isinstance(to, str):
1173                 raise TypeError(
1174                     '%s(%r) is invalid. First parameter to ManyToManyField '
1175                     'must be either a model, a model name, or the string %r' % (
1176                         self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT,
1177                     )
1178                 )
1179 
1180         if symmetrical is None:
1181             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1182 
1183         if through is not None and db_table is not None:
1184             raise ValueError(
1185                 'Cannot specify a db_table if an intermediary model is used.'
1186             )
1187 
1188         kwargs['rel'] = self.rel_class(
1189             self, to,
1190             related_name=related_name,
1191             related_query_name=related_query_name,
1192             limit_choices_to=limit_choices_to,
1193             symmetrical=symmetrical,
1194             through=through,
1195             through_fields=through_fields,
1196             db_constraint=db_constraint,
1197         )
1198         self.has_null_arg = 'null' in kwargs
1199 
1200         super().__init__(
1201             related_name=related_name,
1202             related_query_name=related_query_name,
1203             limit_choices_to=limit_choices_to,
1204             **kwargs,
1205         )
1206 
1207         self.db_table = db_table
1208         self.swappable = swappable

</code><intended_behavior>The `__init__` method should include a new validation segment after determining the value of `symmetrical`. This segment should check if `symmetrical` is `True` and `related_name` is provided (not `None`). If both conditions are met, the method should raise a ValueError (or a more specific custom exception), indicating that specifying a `related_name` for symmetrical `ManyToManyField` is invalid. This ensures clarity for developers about the non-creation of the related field on the target model when `symmetrical=True` and preserves the congruity and integrity of the model relationships by preventing misuse. This intended change is designed to alert developers early in the development process to an incorrect use of `ManyToManyField`, preventing bugs and confusion that might result from misunderstanding the purpose and behavior of the `symmetrical` attribute in relation to `related_name`.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1145 class ManyToManyField(RelatedField):
1146     """
1147     Provide a many-to-many relation by using an intermediary model that
1148     holds two ForeignKey fields pointed at the two sides of the relation.
1149 
1150     Unless a ``through`` model was provided, ManyToManyField will use the
1151     create_many_to_many_intermediary_model factory to automatically generate
1152     the intermediary model.
1153     """
1154 
1155     # Field flags
1156     many_to_many = True
1157     many_to_one = False
1158     one_to_many = False
1159     one_to_one = False
1160 
1161     rel_class = ManyToManyRel
1162 
1163     description = _("Many-to-many relationship")
1164 
1165     def __init__(self, to, related_name=None, related_query_name=None,
1166                  limit_choices_to=None, symmetrical=None, through=None,
1167                  through_fields=None, db_constraint=True, db_table=None,
1168                  swappable=True, **kwargs):
1169         try:
1170             to._meta
1171         except AttributeError:
1172             if not isinstance(to, str):
1173                 raise TypeError(
1174                     '%s(%r) is invalid. First parameter to ManyToManyField '
1175                     'must be either a model, a model name, or the string %r' % (
1176                         self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT,
1177                     )
1178                 )
1179 
1180         if symmetrical is None:
1181             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1182 
1183         if through is not None and db_table is not None:
1184             raise ValueError(
1185                 'Cannot specify a db_table if an intermediary model is used.'
1186             )
1187 
1188         kwargs['rel'] = self.rel_class(
1189             self, to,
1190             related_name=related_name,
1191             related_query_name=related_query_name,
1192             limit_choices_to=limit_choices_to,
1193             symmetrical=symmetrical,
1194             through=through,
1195             through_fields=through_fields,
1196             db_constraint=db_constraint,
1197         )
1198         self.has_null_arg = 'null' in kwargs
1199 
1200         super().__init__(
1201             related_name=related_name,
1202             related_query_name=related_query_name,
1203             limit_choices_to=limit_choices_to,
1204             **kwargs,
1205         )
1206 
1207         self.db_table = db_table
1208         self.swappable = swappable
1209 
1210     def check(self, **kwargs):
1211         return [
1212             *super().check(**kwargs),
1213             *self._check_unique(**kwargs),
1214             *self._check_relationship_model(**kwargs),
1215             *self._check_ignored_options(**kwargs),
1216             *self._check_table_uniqueness(**kwargs),
1217         ]
1218 
1219     def _check_unique(self, **kwargs):
1220         if self.unique:
1221             return [
1222                 checks.Error(
1223                     'ManyToManyFields cannot be unique.',
1224                     obj=self,
1225                     id='fields.E330',
1226                 )
1227             ]
1228         return []
1229 
1230     def _check_ignored_options(self, **kwargs):
1231         warnings = []
1232 
1233         if self.has_null_arg:
1234             warnings.append(
1235                 checks.Warning(
1236                     'null has no effect on ManyToManyField.',
1237                     obj=self,
1238                     id='fields.W340',
1239                 )
1240             )
1241 
1242         if self._validators:
1243             warnings.append(
1244                 checks.Warning(
1245                     'ManyToManyField does not support validators.',
1246                     obj=self,
1247                     id='fields.W341',
1248                 )
1249             )
1250         if (self.remote_field.limit_choices_to and self.remote_field.through and
1251                 not self.remote_field.through._meta.auto_created):
1252             warnings.append(
1253                 checks.Warning(
1254                     'limit_choices_to has no effect on ManyToManyField '
1255                     'with a through model.',
1256                     obj=self,
1257                     id='fields.W343',
1258                 )
1259             )
1260 
1261         return warnings
1262 
1263     def _check_relationship_model(self, from_model=None, **kwargs):
1264         if hasattr(self.remote_field.through, '_meta'):
1265             qualified_model_name = "%s.%s" % (
1266                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1267         else:
1268             qualified_model_name = self.remote_field.through
1269 
1270         errors = []
1271 
1272         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1273             # The relationship model is not installed.
1274             errors.append(
1275                 checks.Error(
1276                     "Field specifies a many-to-many relation through model "
1277                     "'%s', which has not been installed." % qualified_model_name,
1278                     obj=self,
1279                     id='fields.E331',
1280                 )
1281             )
1282 
1283         else:
1284             assert from_model is not None, (
1285                 "ManyToManyField with intermediate "
1286                 "tables cannot be checked if you don't pass the model "
1287                 "where the field is attached to."
1288             )
1289             # Set some useful local variables
1290             to_model = resolve_relation(from_model, self.remote_field.model)
1291             from_model_name = from_model._meta.object_name
1292             if isinstance(to_model, str):
1293                 to_model_name = to_model
1294             else:
1295                 to_model_name = to_model._meta.object_name
1296             relationship_model_name = self.remote_field.through._meta.object_name
1297             self_referential = from_model == to_model
1298             # Count foreign keys in intermediate model
1299             if self_referential:
1300                 seen_self = sum(
1301                     from_model == getattr(field.remote_field, 'model', None)
1302                     for field in self.remote_field.through._meta.fields
1303                 )
1304 
1305                 if seen_self > 2 and not self.remote_field.through_fields:
1306                     errors.append(
1307                         checks.Error(
1308                             "The model is used as an intermediate model by "
1309                             "'%s', but it has more than two foreign keys "
1310                             "to '%s', which is ambiguous. You must specify "
1311                             "which two foreign keys Django should use via the "
1312                             "through_fields keyword argument." % (self, from_model_name),
1313                             hint="Use through_fields to specify which two foreign keys Django should use.",
1314                             obj=self.remote_field.through,
1315                             id='fields.E333',
1316                         )
1317                     )
1318 
1319             else:
1320                 # Count foreign keys in relationship model
1321                 seen_from = sum(
1322                     from_model == getattr(field.remote_field, 'model', None)
1323                     for field in self.remote_field.through._meta.fields
1324                 )
1325                 seen_to = sum(
1326                     to_model == getattr(field.remote_field, 'model', None)
1327                     for field in self.remote_field.through._meta.fields
1328                 )
1329 
1330                 if seen_from > 1 and not self.remote_field.through_fields:
1331                     errors.append(
1332                         checks.Error(
1333                             ("The model is used as an intermediate model by "
1334                              "'%s', but it has more than one foreign key "
1335                              "from '%s', which is ambiguous. You must specify "
1336                              "which foreign key Django should use via the "
1337                              "through_fields keyword argument.") % (self, from_model_name),
1338                             hint=(
1339                                 'If you want to create a recursive relationship, '
1340                                 'use ManyToManyField("%s", through="%s").'
1341                             ) % (
1342                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1343                                 relationship_model_name,
1344                             ),
1345                             obj=self,
1346                             id='fields.E334',
1347                         )
1348                     )
1349 
1350                 if seen_to > 1 and not self.remote_field.through_fields:
1351                     errors.append(
1352                         checks.Error(
1353                             "The model is used as an intermediate model by "
1354                             "'%s', but it has more than one foreign key "
1355                             "to '%s', which is ambiguous. You must specify "
1356                             "which foreign key Django should use via the "
1357                             "through_fields keyword argument." % (self, to_model_name),
1358                             hint=(
1359                                 'If you want to create a recursive relationship, '
1360                                 'use ManyToManyField("%s", through="%s").'
1361                             ) % (
1362                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1363                                 relationship_model_name,
1364                             ),
1365                             obj=self,
1366                             id='fields.E335',
1367                         )
1368                     )
1369 
1370                 if seen_from == 0 or seen_to == 0:
1371                     errors.append(
1372                         checks.Error(
1373                             "The model is used as an intermediate model by "
1374                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1375                                 self, from_model_name, to_model_name
1376                             ),
1377                             obj=self.remote_field.through,
1378                             id='fields.E336',
1379                         )
1380                     )
1381 
1382         # Validate `through_fields`.
1383         if self.remote_field.through_fields is not None:
1384             # Validate that we're given an iterable of at least two items
1385             # and that none of them is "falsy".
1386             if not (len(self.remote_field.through_fields) >= 2 and
1387                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1388                 errors.append(
1389                     checks.Error(
1390                         "Field specifies 'through_fields' but does not provide "
1391                         "the names of the two link fields that should be used "
1392                         "for the relation through model '%s'." % qualified_model_name,
1393                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1394                         obj=self,
1395                         id='fields.E337',
1396                     )
1397                 )
1398 
1399             # Validate the given through fields -- they should be actual
1400             # fields on the through model, and also be foreign keys to the
1401             # expected models.
1402             else:
1403                 assert from_model is not None, (
1404                     "ManyToManyField with intermediate "
1405                     "tables cannot be checked if you don't pass the model "
1406                     "where the field is attached to."
1407                 )
1408 
1409                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1410                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1411 
1412                 for field_name, related_model in ((source_field_name, source),
1413                                                   (target_field_name, target)):
1414 
1415                     possible_field_names = []
1416                     for f in through._meta.fields:
1417                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1418                             possible_field_names.append(f.name)
1419                     if possible_field_names:
1420                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1421                             related_model._meta.object_name,
1422                             ', '.join(possible_field_names),
1423                         )
1424                     else:
1425                         hint = None
1426 
1427                     try:
1428                         field = through._meta.get_field(field_name)
1429                     except exceptions.FieldDoesNotExist:
1430                         errors.append(
1431                             checks.Error(
1432                                 "The intermediary model '%s' has no field '%s'."
1433                                 % (qualified_model_name, field_name),
1434                                 hint=hint,
1435                                 obj=self,
1436                                 id='fields.E338',
1437                             )
1438                         )
1439                     else:
1440                         if not (hasattr(field, 'remote_field') and
1441                                 getattr(field.remote_field, 'model', None) == related_model):
1442                             errors.append(
1443                                 checks.Error(
1444                                     "'%s.%s' is not a foreign key to '%s'." % (
1445                                         through._meta.object_name, field_name,
1446                                         related_model._meta.object_name,
1447                                     ),
1448                                     hint=hint,
1449                                     obj=self,
1450                                     id='fields.E339',
1451                                 )
1452                             )
1453 
1454         return errors
1455 
1456     def _check_table_uniqueness(self, **kwargs):
1457         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1458             return []
1459         registered_tables = {
1460             model._meta.db_table: model
1461             for model in self.opts.apps.get_models(include_auto_created=True)
1462             if model != self.remote_field.through and model._meta.managed
1463         }
1464         m2m_db_table = self.m2m_db_table()
1465         model = registered_tables.get(m2m_db_table)
1466         # The second condition allows multiple m2m relations on a model if
1467         # some point to a through model that proxies another through model.
1468         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1469             if model._meta.auto_created:
1470                 def _get_field_name(model):
1471                     for field in model._meta.auto_created._meta.many_to_many:
1472                         if field.remote_field.through is model:
1473                             return field.name
1474                 opts = model._meta.auto_created._meta
1475                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1476             else:
1477                 clashing_obj = model._meta.label
1478             if settings.DATABASE_ROUTERS:
1479                 error_class, error_id = checks.Warning, 'fields.W344'
1480                 error_hint = (
1481                     'You have configured settings.DATABASE_ROUTERS. Verify '
1482                     'that the table of %r is correctly routed to a separate '
1483                     'database.' % clashing_obj
1484                 )
1485             else:
1486                 error_class, error_id = checks.Error, 'fields.E340'
1487                 error_hint = None
1488             return [
1489                 error_class(
1490                     "The field's intermediary table '%s' clashes with the "
1491                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1492                     obj=self,
1493                     hint=error_hint,
1494                     id=error_id,
1495                 )
1496             ]
1497         return []
1498 
1499     def deconstruct(self):
1500         name, path, args, kwargs = super().deconstruct()
1501         # Handle the simpler arguments.
1502         if self.db_table is not None:
1503             kwargs['db_table'] = self.db_table
1504         if self.remote_field.db_constraint is not True:
1505             kwargs['db_constraint'] = self.remote_field.db_constraint
1506         # Rel needs more work.
1507         if isinstance(self.remote_field.model, str):
1508             kwargs['to'] = self.remote_field.model
1509         else:
1510             kwargs['to'] = self.remote_field.model._meta.label
1511         if getattr(self.remote_field, 'through', None) is not None:
1512             if isinstance(self.remote_field.through, str):
1513                 kwargs['through'] = self.remote_field.through
1514             elif not self.remote_field.through._meta.auto_created:
1515                 kwargs['through'] = self.remote_field.through._meta.label
1516         # If swappable is True, then see if we're actually pointing to the target
1517         # of a swap.
1518         swappable_setting = self.swappable_setting
1519         if swappable_setting is not None:
1520             # If it's already a settings reference, error.
1521             if hasattr(kwargs['to'], "setting_name"):
1522                 if kwargs['to'].setting_name != swappable_setting:
1523                     raise ValueError(
1524                         "Cannot deconstruct a ManyToManyField pointing to a "
1525                         "model that is swapped in place of more than one model "
1526                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1527                     )
1528 
1529             kwargs['to'] = SettingsReference(
1530                 kwargs['to'],
1531                 swappable_setting,
1532             )
1533         return name, path, args, kwargs
1534 
1535     def _get_path_info(self, direct=False, filtered_relation=None):
1536         """Called by both direct and indirect m2m traversal."""
1537         int_model = self.remote_field.through
1538         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1539         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1540         if direct:
1541             join1infos = linkfield1.get_reverse_path_info()
1542             join2infos = linkfield2.get_path_info(filtered_relation)
1543         else:
1544             join1infos = linkfield2.get_reverse_path_info()
1545             join2infos = linkfield1.get_path_info(filtered_relation)
1546 
1547         # Get join infos between the last model of join 1 and the first model
1548         # of join 2. Assume the only reason these may differ is due to model
1549         # inheritance.
1550         join1_final = join1infos[-1].to_opts
1551         join2_initial = join2infos[0].from_opts
1552         if join1_final is join2_initial:
1553             intermediate_infos = []
1554         elif issubclass(join1_final.model, join2_initial.model):
1555             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1556         else:
1557             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1558 
1559         return [*join1infos, *intermediate_infos, *join2infos]
1560 
1561     def get_path_info(self, filtered_relation=None):
1562         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1563 
1564     def get_reverse_path_info(self, filtered_relation=None):
1565         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1566 
1567     def _get_m2m_db_table(self, opts):
1568         """
1569         Function that can be curried to provide the m2m table name for this
1570         relation.
1571         """
1572         if self.remote_field.through is not None:
1573             return self.remote_field.through._meta.db_table
1574         elif self.db_table:
1575             return self.db_table
1576         else:
1577             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1578             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1579 
1580     def _get_m2m_attr(self, related, attr):
1581         """
1582         Function that can be curried to provide the source accessor or DB
1583         column name for the m2m table.
1584         """
1585         cache_attr = '_m2m_%s_cache' % attr
1586         if hasattr(self, cache_attr):
1587             return getattr(self, cache_attr)
1588         if self.remote_field.through_fields is not None:
1589             link_field_name = self.remote_field.through_fields[0]
1590         else:
1591             link_field_name = None
1592         for f in self.remote_field.through._meta.fields:
1593             if (f.is_relation and f.remote_field.model == related.related_model and
1594                     (link_field_name is None or link_field_name == f.name)):
1595                 setattr(self, cache_attr, getattr(f, attr))
1596                 return getattr(self, cache_attr)
1597 
1598     def _get_m2m_reverse_attr(self, related, attr):
1599         """
1600         Function that can be curried to provide the related accessor or DB
1601         column name for the m2m table.
1602         """
1603         cache_attr = '_m2m_reverse_%s_cache' % attr
1604         if hasattr(self, cache_attr):
1605             return getattr(self, cache_attr)
1606         found = False
1607         if self.remote_field.through_fields is not None:
1608             link_field_name = self.remote_field.through_fields[1]
1609         else:
1610             link_field_name = None
1611         for f in self.remote_field.through._meta.fields:
1612             if f.is_relation and f.remote_field.model == related.model:
1613                 if link_field_name is None and related.related_model == related.model:
1614                     # If this is an m2m-intermediate to self,
1615                     # the first foreign key you find will be
1616                     # the source column. Keep searching for
1617                     # the second foreign key.
1618                     if found:
1619                         setattr(self, cache_attr, getattr(f, attr))
1620                         break
1621                     else:
1622                         found = True
1623                 elif link_field_name is None or link_field_name == f.name:
1624                     setattr(self, cache_attr, getattr(f, attr))
1625                     break
1626         return getattr(self, cache_attr)
1627 
1628     def contribute_to_class(self, cls, name, **kwargs):
1629         # To support multiple relations to self, it's useful to have a non-None
1630         # related name on symmetrical relations for internal reasons. The
1631         # concept doesn't make a lot of sense externally ("you want me to
1632         # specify *what* on my non-reversible relation?!"), so we set it up
1633         # automatically. The funky name reduces the chance of an accidental
1634         # clash.
1635         if self.remote_field.symmetrical and (
1636             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1637             self.remote_field.model == cls._meta.object_name
1638         ):
1639             self.remote_field.related_name = "%s_rel_+" % name
1640         elif self.remote_field.is_hidden():
1641             # If the backwards relation is disabled, replace the original
1642             # related_name with one generated from the m2m field name. Django
1643             # still uses backwards relations internally and we need to avoid
1644             # clashes between multiple m2m fields with related_name == '+'.
1645             self.remote_field.related_name = '_%s_%s_%s_+' % (
1646                 cls._meta.app_label,
1647                 cls.__name__.lower(),
1648                 name,
1649             )
1650 
1651         super().contribute_to_class(cls, name, **kwargs)
1652 
1653         # The intermediate m2m model is not auto created if:
1654         #  1) There is a manually specified intermediate, or
1655         #  2) The class owning the m2m field is abstract.
1656         #  3) The class owning the m2m field has been swapped out.
1657         if not cls._meta.abstract:
1658             if self.remote_field.through:
1659                 def resolve_through_model(_, model, field):
1660                     field.remote_field.through = model
1661                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1662             elif not cls._meta.swapped:
1663                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1664 
1665         # Add the descriptor for the m2m relation.
1666         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1667 
1668         # Set up the accessor for the m2m table name for the relation.
1669         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1670 
1671     def contribute_to_related_class(self, cls, related):
1672         # Internal M2Ms (i.e., those with a related name ending with '+')
1673         # and swapped models don't get a related descriptor.
1674         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1675             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1676 
1677         # Set up the accessors for the column names on the m2m table.
1678         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1679         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1680 
1681         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1682         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1683 
1684         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1685         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1686         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1687         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1688 
1689     def set_attributes_from_rel(self):
1690         pass
1691 
1692     def value_from_object(self, obj):
1693         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1694 
1695     def save_form_data(self, instance, data):
1696         getattr(instance, self.attname).set(data)
1697 
1698     def formfield(self, *, using=None, **kwargs):
1699         defaults = {
1700             'form_class': forms.ModelMultipleChoiceField,
1701             'queryset': self.remote_field.model._default_manager.using(using),
1702             **kwargs,
1703         }
1704         # If initial is passed in, it's a list of related objects, but the
1705         # MultipleChoiceField takes a list of IDs.
1706         if defaults.get('initial') is not None:
1707             initial = defaults['initial']
1708             if callable(initial):
1709                 initial = initial()
1710             defaults['initial'] = [i.pk for i in initial]
1711         return super().formfield(**defaults)
1712 
1713     def db_check(self, connection):
1714         return None
1715 
1716     def db_type(self, connection):
1717         # A ManyToManyField is not represented by a single column,
1718         # so return None.
1719         return None
1720 
1721     def db_parameters(self, connection):
1722         return {"type": None, "check": None}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 19:14:20.696 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 19:14:20.696 | INFO     | Search-only: skipping patch selection
2025-10-15 19:14:20.841 | INFO     | Task django__django-14730 completed successfully.
2025-10-15 19:14:20.842 | INFO     | No patch generated. You can try running ACR again.
