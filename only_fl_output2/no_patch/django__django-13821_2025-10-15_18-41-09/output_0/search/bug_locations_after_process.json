[
    {
        "rel_file_path": "django/db/backends/sqlite3/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/backends/sqlite3/base.py",
        "start": 1,
        "end": 614,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 SQLite backend for the sqlite3 module in the standard library.\n3 \"\"\"\n4 import datetime\n5 import decimal\n6 import functools\n7 import hashlib\n8 import math\n9 import operator\n10 import random\n11 import re\n12 import statistics\n13 import warnings\n14 from itertools import chain\n15 from sqlite3 import dbapi2 as Database\n16 \n17 import pytz\n18 \n19 from django.core.exceptions import ImproperlyConfigured\n20 from django.db import IntegrityError\n21 from django.db.backends import utils as backend_utils\n22 from django.db.backends.base.base import BaseDatabaseWrapper\n23 from django.utils import timezone\n24 from django.utils.asyncio import async_unsafe\n25 from django.utils.dateparse import parse_datetime, parse_time\n26 from django.utils.duration import duration_microseconds\n27 from django.utils.regex_helper import _lazy_re_compile\n28 from django.utils.version import PY38\n29 \n30 from .client import DatabaseClient\n31 from .creation import DatabaseCreation\n32 from .features import DatabaseFeatures\n33 from .introspection import DatabaseIntrospection\n34 from .operations import DatabaseOperations\n35 from .schema import DatabaseSchemaEditor\n36 \n37 \n38 def decoder(conv_func):\n39     \"\"\"\n40     Convert bytestrings from Python's sqlite3 interface to a regular string.\n41     \"\"\"\n42     return lambda s: conv_func(s.decode())\n43 \n44 \n45 def none_guard(func):\n46     \"\"\"\n47     Decorator that returns None if any of the arguments to the decorated\n48     function are None. Many SQL functions return NULL if any of their arguments\n49     are NULL. This decorator simplifies the implementation of this for the\n50     custom functions registered below.\n51     \"\"\"\n52     @functools.wraps(func)\n53     def wrapper(*args, **kwargs):\n54         return None if None in args else func(*args, **kwargs)\n55     return wrapper\n56 \n57 \n58 def list_aggregate(function):\n59     \"\"\"\n60     Return an aggregate class that accumulates values in a list and applies\n61     the provided function to the data.\n62     \"\"\"\n63     return type('ListAggregate', (list,), {'finalize': function, 'step': list.append})\n64 \n65 \n66 def check_sqlite_version():\n67     if Database.sqlite_version_info < (3, 8, 3):\n68         raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)\n69 \n70 \n71 check_sqlite_version()\n72 \n73 Database.register_converter(\"bool\", b'1'.__eq__)\n74 Database.register_converter(\"time\", decoder(parse_time))\n75 Database.register_converter(\"datetime\", decoder(parse_datetime))\n76 Database.register_converter(\"timestamp\", decoder(parse_datetime))\n77 \n78 Database.register_adapter(decimal.Decimal, str)\n79 \n80 \n81 class DatabaseWrapper(BaseDatabaseWrapper):\n82     vendor = 'sqlite'\n83     display_name = 'SQLite'\n84     # SQLite doesn't actually support most of these types, but it \"does the right\n85     # thing\" given more verbose field definitions, so leave them as is so that\n86     # schema inspection is more useful.\n87     data_types = {\n88         'AutoField': 'integer',\n89         'BigAutoField': 'integer',\n90         'BinaryField': 'BLOB',\n91         'BooleanField': 'bool',\n92         'CharField': 'varchar(%(max_length)s)',\n93         'DateField': 'date',\n94         'DateTimeField': 'datetime',\n95         'DecimalField': 'decimal',\n96         'DurationField': 'bigint',\n97         'FileField': 'varchar(%(max_length)s)',\n98         'FilePathField': 'varchar(%(max_length)s)',\n99         'FloatField': 'real',\n100         'IntegerField': 'integer',\n101         'BigIntegerField': 'bigint',\n102         'IPAddressField': 'char(15)',\n103         'GenericIPAddressField': 'char(39)',\n104         'JSONField': 'text',\n105         'NullBooleanField': 'bool',\n106         'OneToOneField': 'integer',\n107         'PositiveBigIntegerField': 'bigint unsigned',\n108         'PositiveIntegerField': 'integer unsigned',\n109         'PositiveSmallIntegerField': 'smallint unsigned',\n110         'SlugField': 'varchar(%(max_length)s)',\n111         'SmallAutoField': 'integer',\n112         'SmallIntegerField': 'smallint',\n113         'TextField': 'text',\n114         'TimeField': 'time',\n115         'UUIDField': 'char(32)',\n116     }\n117     data_type_check_constraints = {\n118         'PositiveBigIntegerField': '\"%(column)s\" >= 0',\n119         'JSONField': '(JSON_VALID(\"%(column)s\") OR \"%(column)s\" IS NULL)',\n120         'PositiveIntegerField': '\"%(column)s\" >= 0',\n121         'PositiveSmallIntegerField': '\"%(column)s\" >= 0',\n122     }\n123     data_types_suffix = {\n124         'AutoField': 'AUTOINCREMENT',\n125         'BigAutoField': 'AUTOINCREMENT',\n126         'SmallAutoField': 'AUTOINCREMENT',\n127     }\n128     # SQLite requires LIKE statements to include an ESCAPE clause if the value\n129     # being escaped has a percent or underscore in it.\n130     # See https://www.sqlite.org/lang_expr.html for an explanation.\n131     operators = {\n132         'exact': '= %s',\n133         'iexact': \"LIKE %s ESCAPE '\\\\'\",\n134         'contains': \"LIKE %s ESCAPE '\\\\'\",\n135         'icontains': \"LIKE %s ESCAPE '\\\\'\",\n136         'regex': 'REGEXP %s',\n137         'iregex': \"REGEXP '(?i)' || %s\",\n138         'gt': '> %s',\n139         'gte': '>= %s',\n140         'lt': '< %s',\n141         'lte': '<= %s',\n142         'startswith': \"LIKE %s ESCAPE '\\\\'\",\n143         'endswith': \"LIKE %s ESCAPE '\\\\'\",\n144         'istartswith': \"LIKE %s ESCAPE '\\\\'\",\n145         'iendswith': \"LIKE %s ESCAPE '\\\\'\",\n146     }\n147 \n148     # The patterns below are used to generate SQL pattern lookup clauses when\n149     # the right-hand side of the lookup isn't a raw string (it might be an expression\n150     # or the result of a bilateral transformation).\n151     # In those cases, special characters for LIKE operators (e.g. \\, *, _) should be\n152     # escaped on database side.\n153     #\n154     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n155     # the LIKE operator.\n156     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, '\\', '\\\\'), '%%', '\\%%'), '_', '\\_')\"\n157     pattern_ops = {\n158         'contains': r\"LIKE '%%' || {} || '%%' ESCAPE '\\'\",\n159         'icontains': r\"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\\'\",\n160         'startswith': r\"LIKE {} || '%%' ESCAPE '\\'\",\n161         'istartswith': r\"LIKE UPPER({}) || '%%' ESCAPE '\\'\",\n162         'endswith': r\"LIKE '%%' || {} ESCAPE '\\'\",\n163         'iendswith': r\"LIKE '%%' || UPPER({}) ESCAPE '\\'\",\n164     }\n165 \n166     Database = Database\n167     SchemaEditorClass = DatabaseSchemaEditor\n168     # Classes instantiated in __init__().\n169     client_class = DatabaseClient\n170     creation_class = DatabaseCreation\n171     features_class = DatabaseFeatures\n172     introspection_class = DatabaseIntrospection\n173     ops_class = DatabaseOperations\n174 \n175     def get_connection_params(self):\n176         settings_dict = self.settings_dict\n177         if not settings_dict['NAME']:\n178             raise ImproperlyConfigured(\n179                 \"settings.DATABASES is improperly configured. \"\n180                 \"Please supply the NAME value.\")\n181         kwargs = {\n182             # TODO: Remove str() when dropping support for PY36.\n183             # https://bugs.python.org/issue33496\n184             'database': str(settings_dict['NAME']),\n185             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n186             **settings_dict['OPTIONS'],\n187         }\n188         # Always allow the underlying SQLite connection to be shareable\n189         # between multiple threads. The safe-guarding will be handled at a\n190         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n191         # property. This is necessary as the shareability is disabled by\n192         # default in pysqlite and it cannot be changed once a connection is\n193         # opened.\n194         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n195             warnings.warn(\n196                 'The `check_same_thread` option was provided and set to '\n197                 'True. It will be overridden with False. Use the '\n198                 '`DatabaseWrapper.allow_thread_sharing` property instead '\n199                 'for controlling thread shareability.',\n200                 RuntimeWarning\n201             )\n202         kwargs.update({'check_same_thread': False, 'uri': True})\n203         return kwargs\n204 \n205     @async_unsafe\n206     def get_new_connection(self, conn_params):\n207         conn = Database.connect(**conn_params)\n208         if PY38:\n209             create_deterministic_function = functools.partial(\n210                 conn.create_function,\n211                 deterministic=True,\n212             )\n213         else:\n214             create_deterministic_function = conn.create_function\n215         create_deterministic_function('django_date_extract', 2, _sqlite_datetime_extract)\n216         create_deterministic_function('django_date_trunc', 4, _sqlite_date_trunc)\n217         create_deterministic_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)\n218         create_deterministic_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)\n219         create_deterministic_function('django_datetime_extract', 4, _sqlite_datetime_extract)\n220         create_deterministic_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)\n221         create_deterministic_function('django_time_extract', 2, _sqlite_time_extract)\n222         create_deterministic_function('django_time_trunc', 4, _sqlite_time_trunc)\n223         create_deterministic_function('django_time_diff', 2, _sqlite_time_diff)\n224         create_deterministic_function('django_timestamp_diff', 2, _sqlite_timestamp_diff)\n225         create_deterministic_function('django_format_dtdelta', 3, _sqlite_format_dtdelta)\n226         create_deterministic_function('regexp', 2, _sqlite_regexp)\n227         create_deterministic_function('ACOS', 1, none_guard(math.acos))\n228         create_deterministic_function('ASIN', 1, none_guard(math.asin))\n229         create_deterministic_function('ATAN', 1, none_guard(math.atan))\n230         create_deterministic_function('ATAN2', 2, none_guard(math.atan2))\n231         create_deterministic_function('BITXOR', 2, none_guard(operator.xor))\n232         create_deterministic_function('CEILING', 1, none_guard(math.ceil))\n233         create_deterministic_function('COS', 1, none_guard(math.cos))\n234         create_deterministic_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))\n235         create_deterministic_function('DEGREES', 1, none_guard(math.degrees))\n236         create_deterministic_function('EXP', 1, none_guard(math.exp))\n237         create_deterministic_function('FLOOR', 1, none_guard(math.floor))\n238         create_deterministic_function('LN', 1, none_guard(math.log))\n239         create_deterministic_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))\n240         create_deterministic_function('LPAD', 3, _sqlite_lpad)\n241         create_deterministic_function('MD5', 1, none_guard(lambda x: hashlib.md5(x.encode()).hexdigest()))\n242         create_deterministic_function('MOD', 2, none_guard(math.fmod))\n243         create_deterministic_function('PI', 0, lambda: math.pi)\n244         create_deterministic_function('POWER', 2, none_guard(operator.pow))\n245         create_deterministic_function('RADIANS', 1, none_guard(math.radians))\n246         create_deterministic_function('REPEAT', 2, none_guard(operator.mul))\n247         create_deterministic_function('REVERSE', 1, none_guard(lambda x: x[::-1]))\n248         create_deterministic_function('RPAD', 3, _sqlite_rpad)\n249         create_deterministic_function('SHA1', 1, none_guard(lambda x: hashlib.sha1(x.encode()).hexdigest()))\n250         create_deterministic_function('SHA224', 1, none_guard(lambda x: hashlib.sha224(x.encode()).hexdigest()))\n251         create_deterministic_function('SHA256', 1, none_guard(lambda x: hashlib.sha256(x.encode()).hexdigest()))\n252         create_deterministic_function('SHA384', 1, none_guard(lambda x: hashlib.sha384(x.encode()).hexdigest()))\n253         create_deterministic_function('SHA512', 1, none_guard(lambda x: hashlib.sha512(x.encode()).hexdigest()))\n254         create_deterministic_function('SIGN', 1, none_guard(lambda x: (x > 0) - (x < 0)))\n255         create_deterministic_function('SIN', 1, none_guard(math.sin))\n256         create_deterministic_function('SQRT', 1, none_guard(math.sqrt))\n257         create_deterministic_function('TAN', 1, none_guard(math.tan))\n258         # Don't use the built-in RANDOM() function because it returns a value\n259         # in the range [2^63, 2^63 - 1] instead of [0, 1).\n260         conn.create_function('RAND', 0, random.random)\n261         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))\n262         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))\n263         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))\n264         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))\n265         conn.execute('PRAGMA foreign_keys = ON')\n266         return conn\n267 \n268     def init_connection_state(self):\n269         pass\n270 \n271     def create_cursor(self, name=None):\n272         return self.connection.cursor(factory=SQLiteCursorWrapper)\n273 \n274     @async_unsafe\n275     def close(self):\n276         self.validate_thread_sharing()\n277         # If database is in memory, closing the connection destroys the\n278         # database. To prevent accidental data loss, ignore close requests on\n279         # an in-memory db.\n280         if not self.is_in_memory_db():\n281             BaseDatabaseWrapper.close(self)\n282 \n283     def _savepoint_allowed(self):\n284         # When 'isolation_level' is not None, sqlite3 commits before each\n285         # savepoint; it's a bug. When it is None, savepoints don't make sense\n286         # because autocommit is enabled. The only exception is inside 'atomic'\n287         # blocks. To work around that bug, on SQLite, 'atomic' starts a\n288         # transaction explicitly rather than simply disable autocommit.\n289         return self.in_atomic_block\n290 \n291     def _set_autocommit(self, autocommit):\n292         if autocommit:\n293             level = None\n294         else:\n295             # sqlite3's internal default is ''. It's different from None.\n296             # See Modules/_sqlite/connection.c.\n297             level = ''\n298         # 'isolation_level' is a misleading API.\n299         # SQLite always runs at the SERIALIZABLE isolation level.\n300         with self.wrap_database_errors:\n301             self.connection.isolation_level = level\n302 \n303     def disable_constraint_checking(self):\n304         with self.cursor() as cursor:\n305             cursor.execute('PRAGMA foreign_keys = OFF')\n306             # Foreign key constraints cannot be turned off while in a multi-\n307             # statement transaction. Fetch the current state of the pragma\n308             # to determine if constraints are effectively disabled.\n309             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]\n310         return not bool(enabled)\n311 \n312     def enable_constraint_checking(self):\n313         with self.cursor() as cursor:\n314             cursor.execute('PRAGMA foreign_keys = ON')\n315 \n316     def check_constraints(self, table_names=None):\n317         \"\"\"\n318         Check each table name in `table_names` for rows with invalid foreign\n319         key references. This method is intended to be used in conjunction with\n320         `disable_constraint_checking()` and `enable_constraint_checking()`, to\n321         determine if rows with invalid references were entered while constraint\n322         checks were off.\n323         \"\"\"\n324         if self.features.supports_pragma_foreign_key_check:\n325             with self.cursor() as cursor:\n326                 if table_names is None:\n327                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()\n328                 else:\n329                     violations = chain.from_iterable(\n330                         cursor.execute(\n331                             'PRAGMA foreign_key_check(%s)'\n332                             % self.ops.quote_name(table_name)\n333                         ).fetchall()\n334                         for table_name in table_names\n335                     )\n336                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n337                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n338                     foreign_key = cursor.execute(\n339                         'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)\n340                     ).fetchall()[foreign_key_index]\n341                     column_name, referenced_column_name = foreign_key[3:5]\n342                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n343                     primary_key_value, bad_value = cursor.execute(\n344                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n345                             self.ops.quote_name(primary_key_column_name),\n346                             self.ops.quote_name(column_name),\n347                             self.ops.quote_name(table_name),\n348                         ),\n349                         (rowid,),\n350                     ).fetchone()\n351                     raise IntegrityError(\n352                         \"The row in table '%s' with primary key '%s' has an \"\n353                         \"invalid foreign key: %s.%s contains a value '%s' that \"\n354                         \"does not have a corresponding value in %s.%s.\" % (\n355                             table_name, primary_key_value, table_name, column_name,\n356                             bad_value, referenced_table_name, referenced_column_name\n357                         )\n358                     )\n359         else:\n360             with self.cursor() as cursor:\n361                 if table_names is None:\n362                     table_names = self.introspection.table_names(cursor)\n363                 for table_name in table_names:\n364                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n365                     if not primary_key_column_name:\n366                         continue\n367                     key_columns = self.introspection.get_key_columns(cursor, table_name)\n368                     for column_name, referenced_table_name, referenced_column_name in key_columns:\n369                         cursor.execute(\n370                             \"\"\"\n371                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n372                             LEFT JOIN `%s` as REFERRED\n373                             ON (REFERRING.`%s` = REFERRED.`%s`)\n374                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\n375                             \"\"\"\n376                             % (\n377                                 primary_key_column_name, column_name, table_name,\n378                                 referenced_table_name, column_name, referenced_column_name,\n379                                 column_name, referenced_column_name,\n380                             )\n381                         )\n382                         for bad_row in cursor.fetchall():\n383                             raise IntegrityError(\n384                                 \"The row in table '%s' with primary key '%s' has an \"\n385                                 \"invalid foreign key: %s.%s contains a value '%s' that \"\n386                                 \"does not have a corresponding value in %s.%s.\" % (\n387                                     table_name, bad_row[0], table_name, column_name,\n388                                     bad_row[1], referenced_table_name, referenced_column_name,\n389                                 )\n390                             )\n391 \n392     def is_usable(self):\n393         return True\n394 \n395     def _start_transaction_under_autocommit(self):\n396         \"\"\"\n397         Start a transaction explicitly in autocommit mode.\n398 \n399         Staying in autocommit mode works around a bug of sqlite3 that breaks\n400         savepoints when autocommit is disabled.\n401         \"\"\"\n402         self.cursor().execute(\"BEGIN\")\n403 \n404     def is_in_memory_db(self):\n405         return self.creation.is_in_memory_db(self.settings_dict['NAME'])\n406 \n407 \n408 FORMAT_QMARK_REGEX = _lazy_re_compile(r'(?<!%)%s')\n409 \n410 \n411 class SQLiteCursorWrapper(Database.Cursor):\n412     \"\"\"\n413     Django uses \"format\" style placeholders, but pysqlite2 uses \"qmark\" style.\n414     This fixes it -- but note that if you want to use a literal \"%s\" in a query,\n415     you'll need to use \"%%s\".\n416     \"\"\"\n417     def execute(self, query, params=None):\n418         if params is None:\n419             return Database.Cursor.execute(self, query)\n420         query = self.convert_query(query)\n421         return Database.Cursor.execute(self, query, params)\n422 \n423     def executemany(self, query, param_list):\n424         query = self.convert_query(query)\n425         return Database.Cursor.executemany(self, query, param_list)\n426 \n427     def convert_query(self, query):\n428         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')\n429 \n430 \n431 def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):\n432     if dt is None:\n433         return None\n434     try:\n435         dt = backend_utils.typecast_timestamp(dt)\n436     except (TypeError, ValueError):\n437         return None\n438     if conn_tzname:\n439         dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))\n440     if tzname is not None and tzname != conn_tzname:\n441         sign_index = tzname.find('+') + tzname.find('-') + 1\n442         if sign_index > -1:\n443             sign = tzname[sign_index]\n444             tzname, offset = tzname.split(sign)\n445             if offset:\n446                 hours, minutes = offset.split(':')\n447                 offset_delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))\n448                 dt += offset_delta if sign == '+' else -offset_delta\n449         dt = timezone.localtime(dt, pytz.timezone(tzname))\n450     return dt\n451 \n452 \n453 def _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):\n454     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n455     if dt is None:\n456         return None\n457     if lookup_type == 'year':\n458         return \"%i-01-01\" % dt.year\n459     elif lookup_type == 'quarter':\n460         month_in_quarter = dt.month - (dt.month - 1) % 3\n461         return '%i-%02i-01' % (dt.year, month_in_quarter)\n462     elif lookup_type == 'month':\n463         return \"%i-%02i-01\" % (dt.year, dt.month)\n464     elif lookup_type == 'week':\n465         dt = dt - datetime.timedelta(days=dt.weekday())\n466         return \"%i-%02i-%02i\" % (dt.year, dt.month, dt.day)\n467     elif lookup_type == 'day':\n468         return \"%i-%02i-%02i\" % (dt.year, dt.month, dt.day)\n469 \n470 \n471 def _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):\n472     if dt is None:\n473         return None\n474     dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n475     if dt_parsed is None:\n476         try:\n477             dt = backend_utils.typecast_time(dt)\n478         except (ValueError, TypeError):\n479             return None\n480     else:\n481         dt = dt_parsed\n482     if lookup_type == 'hour':\n483         return \"%02i:00:00\" % dt.hour\n484     elif lookup_type == 'minute':\n485         return \"%02i:%02i:00\" % (dt.hour, dt.minute)\n486     elif lookup_type == 'second':\n487         return \"%02i:%02i:%02i\" % (dt.hour, dt.minute, dt.second)\n488 \n489 \n490 def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):\n491     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n492     if dt is None:\n493         return None\n494     return dt.date().isoformat()\n495 \n496 \n497 def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):\n498     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n499     if dt is None:\n500         return None\n501     return dt.time().isoformat()\n502 \n503 \n504 def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):\n505     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n506     if dt is None:\n507         return None\n508     if lookup_type == 'week_day':\n509         return (dt.isoweekday() % 7) + 1\n510     elif lookup_type == 'iso_week_day':\n511         return dt.isoweekday()\n512     elif lookup_type == 'week':\n513         return dt.isocalendar()[1]\n514     elif lookup_type == 'quarter':\n515         return math.ceil(dt.month / 3)\n516     elif lookup_type == 'iso_year':\n517         return dt.isocalendar()[0]\n518     else:\n519         return getattr(dt, lookup_type)\n520 \n521 \n522 def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):\n523     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n524     if dt is None:\n525         return None\n526     if lookup_type == 'year':\n527         return \"%i-01-01 00:00:00\" % dt.year\n528     elif lookup_type == 'quarter':\n529         month_in_quarter = dt.month - (dt.month - 1) % 3\n530         return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)\n531     elif lookup_type == 'month':\n532         return \"%i-%02i-01 00:00:00\" % (dt.year, dt.month)\n533     elif lookup_type == 'week':\n534         dt = dt - datetime.timedelta(days=dt.weekday())\n535         return \"%i-%02i-%02i 00:00:00\" % (dt.year, dt.month, dt.day)\n536     elif lookup_type == 'day':\n537         return \"%i-%02i-%02i 00:00:00\" % (dt.year, dt.month, dt.day)\n538     elif lookup_type == 'hour':\n539         return \"%i-%02i-%02i %02i:00:00\" % (dt.year, dt.month, dt.day, dt.hour)\n540     elif lookup_type == 'minute':\n541         return \"%i-%02i-%02i %02i:%02i:00\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)\n542     elif lookup_type == 'second':\n543         return \"%i-%02i-%02i %02i:%02i:%02i\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n544 \n545 \n546 def _sqlite_time_extract(lookup_type, dt):\n547     if dt is None:\n548         return None\n549     try:\n550         dt = backend_utils.typecast_time(dt)\n551     except (ValueError, TypeError):\n552         return None\n553     return getattr(dt, lookup_type)\n554 \n555 \n556 @none_guard\n557 def _sqlite_format_dtdelta(conn, lhs, rhs):\n558     \"\"\"\n559     LHS and RHS can be either:\n560     - An integer number of microseconds\n561     - A string representing a datetime\n562     \"\"\"\n563     try:\n564         real_lhs = datetime.timedelta(0, 0, lhs) if isinstance(lhs, int) else backend_utils.typecast_timestamp(lhs)\n565         real_rhs = datetime.timedelta(0, 0, rhs) if isinstance(rhs, int) else backend_utils.typecast_timestamp(rhs)\n566         if conn.strip() == '+':\n567             out = real_lhs + real_rhs\n568         else:\n569             out = real_lhs - real_rhs\n570     except (ValueError, TypeError):\n571         return None\n572     # typecast_timestamp returns a date or a datetime without timezone.\n573     # It will be formatted as \"%Y-%m-%d\" or \"%Y-%m-%d %H:%M:%S[.%f]\"\n574     return str(out)\n575 \n576 \n577 @none_guard\n578 def _sqlite_time_diff(lhs, rhs):\n579     left = backend_utils.typecast_time(lhs)\n580     right = backend_utils.typecast_time(rhs)\n581     return (\n582         (left.hour * 60 * 60 * 1000000) +\n583         (left.minute * 60 * 1000000) +\n584         (left.second * 1000000) +\n585         (left.microsecond) -\n586         (right.hour * 60 * 60 * 1000000) -\n587         (right.minute * 60 * 1000000) -\n588         (right.second * 1000000) -\n589         (right.microsecond)\n590     )\n591 \n592 \n593 @none_guard\n594 def _sqlite_timestamp_diff(lhs, rhs):\n595     left = backend_utils.typecast_timestamp(lhs)\n596     right = backend_utils.typecast_timestamp(rhs)\n597     return duration_microseconds(left - right)\n598 \n599 \n600 @none_guard\n601 def _sqlite_regexp(re_pattern, re_string):\n602     return bool(re.search(re_pattern, str(re_string)))\n603 \n604 \n605 @none_guard\n606 def _sqlite_lpad(text, length, fill_text):\n607     if len(text) >= length:\n608         return text[:length]\n609     return (fill_text * length)[:length - len(text)] + text\n610 \n611 \n612 @none_guard\n613 def _sqlite_rpad(text, length, fill_text):\n614     return (text + fill_text * length)[:length]\n",
        "intended_behavior": "This file should include a check early in the database connection setup process to determine the version of SQLite. If the version is lower than 3.9.0, the setup should raise a ConfigurationError informing the developer that their version of SQLite is not supported and that they should upgrade to at least version 3.9.0."
    }
]