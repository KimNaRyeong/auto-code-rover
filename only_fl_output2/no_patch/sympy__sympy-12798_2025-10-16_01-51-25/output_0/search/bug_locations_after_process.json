[
    {
        "rel_file_path": "sympy/functions/combinatorial/factorials.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/factorials.py",
        "start": 520,
        "end": 521,
        "class_name": null,
        "method_name": "_eval_rewrite_as_FallingFactorial",
        "code": "520     def _eval_rewrite_as_FallingFactorial(self, x, k):\n521         return FallingFactorial(x + k - 1, k)\n",
        "intended_behavior": "This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation."
    },
    {
        "rel_file_path": "sympy/functions/combinatorial/factorials.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/factorials.py",
        "start": 864,
        "end": 866,
        "class_name": null,
        "method_name": "_eval_rewrite_as_FallingFactorial",
        "code": "864     def _eval_rewrite_as_FallingFactorial(self, n, k):\n865         if k.is_integer:\n866             return ff(n, k) / factorial(k)\n",
        "intended_behavior": "This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation."
    },
    {
        "rel_file_path": "sympy/functions/combinatorial/factorials.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/factorials.py",
        "start": 520,
        "end": 521,
        "class_name": "RisingFactorial",
        "method_name": "_eval_rewrite_as_FallingFactorial",
        "code": "520     def _eval_rewrite_as_FallingFactorial(self, x, k):\n521         return FallingFactorial(x + k - 1, k)\n",
        "intended_behavior": "This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation."
    },
    {
        "rel_file_path": "sympy/functions/combinatorial/factorials.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/combinatorial/factorials.py",
        "start": 864,
        "end": 866,
        "class_name": "binomial",
        "method_name": "_eval_rewrite_as_FallingFactorial",
        "code": "864     def _eval_rewrite_as_FallingFactorial(self, n, k):\n865         if k.is_integer:\n866             return ff(n, k) / factorial(k)\n",
        "intended_behavior": "This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation."
    },
    {
        "rel_file_path": "sympy/functions/special/error_functions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/functions/special/error_functions.py",
        "start": 1,
        "end": 2445,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" This module contains various functions that are special cases\n2     of incomplete gamma functions. It should probably be renamed. \"\"\"\n3 \n4 from __future__ import print_function, division\n5 \n6 from sympy.core import Add, S, sympify, cacheit, pi, I\n7 from sympy.core.function import Function, ArgumentIndexError\n8 from sympy.core.symbol import Symbol\n9 from sympy.functions.combinatorial.factorials import factorial\n10 from sympy.functions.elementary.integers import floor\n11 from sympy.functions.elementary.miscellaneous import sqrt, root\n12 from sympy.functions.elementary.exponential import exp, log\n13 from sympy.functions.elementary.complexes import polar_lift\n14 from sympy.functions.elementary.hyperbolic import cosh, sinh\n15 from sympy.functions.elementary.trigonometric import cos, sin, sinc\n16 from sympy.functions.special.hyper import hyper, meijerg\n17 from sympy.core.compatibility import range\n18 \n19 # TODO series expansions\n20 # TODO see the \"Note:\" in Ei\n21 \n22 ###############################################################################\n23 ################################ ERROR FUNCTION ###############################\n24 ###############################################################################\n25 \n26 \n27 class erf(Function):\n28     r\"\"\"\n29     The Gauss error function. This function is defined as:\n30 \n31     .. math ::\n32         \\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} \\mathrm{d}t.\n33 \n34     Examples\n35     ========\n36 \n37     >>> from sympy import I, oo, erf\n38     >>> from sympy.abc import z\n39 \n40     Several special values are known:\n41 \n42     >>> erf(0)\n43     0\n44     >>> erf(oo)\n45     1\n46     >>> erf(-oo)\n47     -1\n48     >>> erf(I*oo)\n49     oo*I\n50     >>> erf(-I*oo)\n51     -oo*I\n52 \n53     In general one can pull out factors of -1 and I from the argument:\n54 \n55     >>> erf(-z)\n56     -erf(z)\n57 \n58     The error function obeys the mirror symmetry:\n59 \n60     >>> from sympy import conjugate\n61     >>> conjugate(erf(z))\n62     erf(conjugate(z))\n63 \n64     Differentiation with respect to z is supported:\n65 \n66     >>> from sympy import diff\n67     >>> diff(erf(z), z)\n68     2*exp(-z**2)/sqrt(pi)\n69 \n70     We can numerically evaluate the error function to arbitrary precision\n71     on the whole complex plane:\n72 \n73     >>> erf(4).evalf(30)\n74     0.999999984582742099719981147840\n75 \n76     >>> erf(-4*I).evalf(30)\n77     -1296959.73071763923152794095062*I\n78 \n79     See Also\n80     ========\n81 \n82     erfc: Complementary error function.\n83     erfi: Imaginary error function.\n84     erf2: Two-argument error function.\n85     erfinv: Inverse error function.\n86     erfcinv: Inverse Complementary error function.\n87     erf2inv: Inverse two-argument error function.\n88 \n89     References\n90     ==========\n91 \n92     .. [1] http://en.wikipedia.org/wiki/Error_function\n93     .. [2] http://dlmf.nist.gov/7\n94     .. [3] http://mathworld.wolfram.com/Erf.html\n95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf\n96     \"\"\"\n97 \n98     unbranched = True\n99 \n100     def fdiff(self, argindex=1):\n101         if argindex == 1:\n102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)\n103         else:\n104             raise ArgumentIndexError(self, argindex)\n105 \n106 \n107     def inverse(self, argindex=1):\n108         \"\"\"\n109         Returns the inverse of this function.\n110         \"\"\"\n111         return erfinv\n112 \n113     @classmethod\n114     def eval(cls, arg):\n115         if arg.is_Number:\n116             if arg is S.NaN:\n117                 return S.NaN\n118             elif arg is S.Infinity:\n119                 return S.One\n120             elif arg is S.NegativeInfinity:\n121                 return S.NegativeOne\n122             elif arg is S.Zero:\n123                 return S.Zero\n124 \n125         if arg.func is erfinv:\n126              return arg.args[0]\n127 \n128         if arg.func is erfcinv:\n129             return S.One - arg.args[0]\n130 \n131         if arg.func is erf2inv and arg.args[0] is S.Zero:\n132             return arg.args[1]\n133 \n134         # Try to pull out factors of I\n135         t = arg.extract_multiplicatively(S.ImaginaryUnit)\n136         if t is S.Infinity or t is S.NegativeInfinity:\n137             return arg\n138 \n139         # Try to pull out factors of -1\n140         if arg.could_extract_minus_sign():\n141             return -cls(-arg)\n142 \n143     @staticmethod\n144     @cacheit\n145     def taylor_term(n, x, *previous_terms):\n146         if n < 0 or n % 2 == 0:\n147             return S.Zero\n148         else:\n149             x = sympify(x)\n150             k = floor((n - 1)/S(2))\n151             if len(previous_terms) > 2:\n152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)\n153             else:\n154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))\n155 \n156     def _eval_conjugate(self):\n157         return self.func(self.args[0].conjugate())\n158 \n159     def _eval_is_real(self):\n160         return self.args[0].is_real\n161 \n162     def _eval_rewrite_as_uppergamma(self, z):\n163         from sympy import uppergamma\n164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))\n165 \n166     def _eval_rewrite_as_fresnels(self, z):\n167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n169 \n170     def _eval_rewrite_as_fresnelc(self, z):\n171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n173 \n174     def _eval_rewrite_as_meijerg(self, z):\n175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)\n176 \n177     def _eval_rewrite_as_hyper(self, z):\n178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)\n179 \n180     def _eval_rewrite_as_expint(self, z):\n181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)\n182 \n183     def _eval_rewrite_as_tractable(self, z):\n184         return S.One - _erfs(z)*exp(-z**2)\n185 \n186     def _eval_rewrite_as_erfc(self, z):\n187         return S.One - erfc(z)\n188 \n189     def _eval_rewrite_as_erfi(self, z):\n190         return -I*erfi(I*z)\n191 \n192     def _eval_as_leading_term(self, x):\n193         from sympy import Order\n194         arg = self.args[0].as_leading_term(x)\n195 \n196         if x in arg.free_symbols and Order(1, x).contains(arg):\n197             return 2*x/sqrt(pi)\n198         else:\n199             return self.func(arg)\n200 \n201     def as_real_imag(self, deep=True, **hints):\n202         if self.args[0].is_real:\n203             if deep:\n204                 hints['complex'] = False\n205                 return (self.expand(deep, **hints), S.Zero)\n206             else:\n207                 return (self, S.Zero)\n208         if deep:\n209             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n210         else:\n211             x, y = self.args[0].as_real_imag()\n212 \n213         sq = -y**2/x**2\n214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n216                     self.func(x + x*sqrt(sq)))\n217         return (re, im)\n218 \n219 \n220 class erfc(Function):\n221     r\"\"\"\n222     Complementary Error Function. The function is defined as:\n223 \n224     .. math ::\n225         \\mathrm{erfc}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_x^\\infty e^{-t^2} \\mathrm{d}t\n226 \n227     Examples\n228     ========\n229 \n230     >>> from sympy import I, oo, erfc\n231     >>> from sympy.abc import z\n232 \n233     Several special values are known:\n234 \n235     >>> erfc(0)\n236     1\n237     >>> erfc(oo)\n238     0\n239     >>> erfc(-oo)\n240     2\n241     >>> erfc(I*oo)\n242     -oo*I\n243     >>> erfc(-I*oo)\n244     oo*I\n245 \n246     The error function obeys the mirror symmetry:\n247 \n248     >>> from sympy import conjugate\n249     >>> conjugate(erfc(z))\n250     erfc(conjugate(z))\n251 \n252     Differentiation with respect to z is supported:\n253 \n254     >>> from sympy import diff\n255     >>> diff(erfc(z), z)\n256     -2*exp(-z**2)/sqrt(pi)\n257 \n258     It also follows\n259 \n260     >>> erfc(-z)\n261     -erfc(z) + 2\n262 \n263     We can numerically evaluate the complementary error function to arbitrary precision\n264     on the whole complex plane:\n265 \n266     >>> erfc(4).evalf(30)\n267     0.0000000154172579002800188521596734869\n268 \n269     >>> erfc(4*I).evalf(30)\n270     1.0 - 1296959.73071763923152794095062*I\n271 \n272     See Also\n273     ========\n274 \n275     erf: Gaussian error function.\n276     erfi: Imaginary error function.\n277     erf2: Two-argument error function.\n278     erfinv: Inverse error function.\n279     erfcinv: Inverse Complementary error function.\n280     erf2inv: Inverse two-argument error function.\n281 \n282     References\n283     ==========\n284 \n285     .. [1] http://en.wikipedia.org/wiki/Error_function\n286     .. [2] http://dlmf.nist.gov/7\n287     .. [3] http://mathworld.wolfram.com/Erfc.html\n288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc\n289     \"\"\"\n290 \n291     unbranched = True\n292 \n293     def fdiff(self, argindex=1):\n294         if argindex == 1:\n295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)\n296         else:\n297             raise ArgumentIndexError(self, argindex)\n298 \n299     def inverse(self, argindex=1):\n300         \"\"\"\n301         Returns the inverse of this function.\n302         \"\"\"\n303         return erfcinv\n304 \n305     @classmethod\n306     def eval(cls, arg):\n307         if arg.is_Number:\n308             if arg is S.NaN:\n309                 return S.NaN\n310             elif arg is S.Infinity:\n311                 return S.Zero\n312             elif arg is S.Zero:\n313                 return S.One\n314 \n315         if arg.func is erfinv:\n316             return S.One - arg.args[0]\n317 \n318         if arg.func is erfcinv:\n319             return arg.args[0]\n320 \n321         # Try to pull out factors of I\n322         t = arg.extract_multiplicatively(S.ImaginaryUnit)\n323         if t is S.Infinity or t is S.NegativeInfinity:\n324             return -arg\n325 \n326         # Try to pull out factors of -1\n327         if arg.could_extract_minus_sign():\n328             return S(2) - cls(-arg)\n329 \n330     @staticmethod\n331     @cacheit\n332     def taylor_term(n, x, *previous_terms):\n333         if n == 0:\n334             return S.One\n335         elif n < 0 or n % 2 == 0:\n336             return S.Zero\n337         else:\n338             x = sympify(x)\n339             k = floor((n - 1)/S(2))\n340             if len(previous_terms) > 2:\n341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)\n342             else:\n343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))\n344 \n345     def _eval_conjugate(self):\n346         return self.func(self.args[0].conjugate())\n347 \n348     def _eval_is_real(self):\n349         return self.args[0].is_real\n350 \n351     def _eval_rewrite_as_tractable(self, z):\n352         return self.rewrite(erf).rewrite(\"tractable\", deep=True)\n353 \n354     def _eval_rewrite_as_erf(self, z):\n355         return S.One - erf(z)\n356 \n357     def _eval_rewrite_as_erfi(self, z):\n358         return S.One + I*erfi(I*z)\n359 \n360     def _eval_rewrite_as_fresnels(self, z):\n361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n363 \n364     def _eval_rewrite_as_fresnelc(self, z):\n365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)\n366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n367 \n368     def _eval_rewrite_as_meijerg(self, z):\n369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)\n370 \n371     def _eval_rewrite_as_hyper(self, z):\n372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)\n373 \n374     def _eval_rewrite_as_uppergamma(self, z):\n375         from sympy import uppergamma\n376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))\n377 \n378     def _eval_rewrite_as_expint(self, z):\n379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)\n380 \n381     def _eval_as_leading_term(self, x):\n382         from sympy import Order\n383         arg = self.args[0].as_leading_term(x)\n384 \n385         if x in arg.free_symbols and Order(1, x).contains(arg):\n386             return S.One\n387         else:\n388             return self.func(arg)\n389 \n390     def as_real_imag(self, deep=True, **hints):\n391         if self.args[0].is_real:\n392             if deep:\n393                 hints['complex'] = False\n394                 return (self.expand(deep, **hints), S.Zero)\n395             else:\n396                 return (self, S.Zero)\n397         if deep:\n398             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n399         else:\n400             x, y = self.args[0].as_real_imag()\n401 \n402         sq = -y**2/x**2\n403         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n404         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n405                     self.func(x + x*sqrt(sq)))\n406         return (re, im)\n407 \n408 class erfi(Function):\n409     r\"\"\"\n410     Imaginary error function. The function erfi is defined as:\n411 \n412     .. math ::\n413         \\mathrm{erfi}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{t^2} \\mathrm{d}t\n414 \n415     Examples\n416     ========\n417 \n418     >>> from sympy import I, oo, erfi\n419     >>> from sympy.abc import z\n420 \n421     Several special values are known:\n422 \n423     >>> erfi(0)\n424     0\n425     >>> erfi(oo)\n426     oo\n427     >>> erfi(-oo)\n428     -oo\n429     >>> erfi(I*oo)\n430     I\n431     >>> erfi(-I*oo)\n432     -I\n433 \n434     In general one can pull out factors of -1 and I from the argument:\n435 \n436     >>> erfi(-z)\n437     -erfi(z)\n438 \n439     >>> from sympy import conjugate\n440     >>> conjugate(erfi(z))\n441     erfi(conjugate(z))\n442 \n443     Differentiation with respect to z is supported:\n444 \n445     >>> from sympy import diff\n446     >>> diff(erfi(z), z)\n447     2*exp(z**2)/sqrt(pi)\n448 \n449     We can numerically evaluate the imaginary error function to arbitrary precision\n450     on the whole complex plane:\n451 \n452     >>> erfi(2).evalf(30)\n453     18.5648024145755525987042919132\n454 \n455     >>> erfi(-2*I).evalf(30)\n456     -0.995322265018952734162069256367*I\n457 \n458     See Also\n459     ========\n460 \n461     erf: Gaussian error function.\n462     erfc: Complementary error function.\n463     erf2: Two-argument error function.\n464     erfinv: Inverse error function.\n465     erfcinv: Inverse Complementary error function.\n466     erf2inv: Inverse two-argument error function.\n467 \n468     References\n469     ==========\n470 \n471     .. [1] http://en.wikipedia.org/wiki/Error_function\n472     .. [2] http://mathworld.wolfram.com/Erfi.html\n473     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi\n474     \"\"\"\n475 \n476     unbranched = True\n477 \n478     def fdiff(self, argindex=1):\n479         if argindex == 1:\n480             return 2*exp(self.args[0]**2)/sqrt(S.Pi)\n481         else:\n482             raise ArgumentIndexError(self, argindex)\n483 \n484     @classmethod\n485     def eval(cls, z):\n486         if z.is_Number:\n487             if z is S.NaN:\n488                 return S.NaN\n489             elif z is S.Zero:\n490                 return S.Zero\n491             elif z is S.Infinity:\n492                 return S.Infinity\n493 \n494         # Try to pull out factors of -1\n495         if z.could_extract_minus_sign():\n496             return -cls(-z)\n497 \n498         # Try to pull out factors of I\n499         nz = z.extract_multiplicatively(I)\n500         if nz is not None:\n501             if nz is S.Infinity:\n502                 return I\n503             if nz.func is erfinv:\n504                 return I*nz.args[0]\n505             if nz.func is erfcinv:\n506                 return I*(S.One - nz.args[0])\n507             if nz.func is erf2inv and nz.args[0] is S.Zero:\n508                 return I*nz.args[1]\n509 \n510     @staticmethod\n511     @cacheit\n512     def taylor_term(n, x, *previous_terms):\n513         if n < 0 or n % 2 == 0:\n514             return S.Zero\n515         else:\n516             x = sympify(x)\n517             k = floor((n - 1)/S(2))\n518             if len(previous_terms) > 2:\n519                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)\n520             else:\n521                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))\n522 \n523     def _eval_conjugate(self):\n524         return self.func(self.args[0].conjugate())\n525 \n526     def _eval_is_real(self):\n527         return self.args[0].is_real\n528 \n529     def _eval_rewrite_as_tractable(self, z):\n530         return self.rewrite(erf).rewrite(\"tractable\", deep=True)\n531 \n532     def _eval_rewrite_as_erf(self, z):\n533         return -I*erf(I*z)\n534 \n535     def _eval_rewrite_as_erfc(self, z):\n536         return I*erfc(I*z) - I\n537 \n538     def _eval_rewrite_as_fresnels(self, z):\n539         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)\n540         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n541 \n542     def _eval_rewrite_as_fresnelc(self, z):\n543         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)\n544         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n545 \n546     def _eval_rewrite_as_meijerg(self, z):\n547         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)\n548 \n549     def _eval_rewrite_as_hyper(self, z):\n550         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)\n551 \n552     def _eval_rewrite_as_uppergamma(self, z):\n553         from sympy import uppergamma\n554         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)\n555 \n556     def _eval_rewrite_as_expint(self, z):\n557         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)\n558 \n559     def as_real_imag(self, deep=True, **hints):\n560         if self.args[0].is_real:\n561             if deep:\n562                 hints['complex'] = False\n563                 return (self.expand(deep, **hints), S.Zero)\n564             else:\n565                 return (self, S.Zero)\n566         if deep:\n567             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n568         else:\n569             x, y = self.args[0].as_real_imag()\n570 \n571         sq = -y**2/x**2\n572         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n573         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n574                     self.func(x + x*sqrt(sq)))\n575         return (re, im)\n576 \n577 class erf2(Function):\n578     r\"\"\"\n579     Two-argument error function. This function is defined as:\n580 \n581     .. math ::\n582         \\mathrm{erf2}(x, y) = \\frac{2}{\\sqrt{\\pi}} \\int_x^y e^{-t^2} \\mathrm{d}t\n583 \n584     Examples\n585     ========\n586 \n587     >>> from sympy import I, oo, erf2\n588     >>> from sympy.abc import x, y\n589 \n590     Several special values are known:\n591 \n592     >>> erf2(0, 0)\n593     0\n594     >>> erf2(x, x)\n595     0\n596     >>> erf2(x, oo)\n597     -erf(x) + 1\n598     >>> erf2(x, -oo)\n599     -erf(x) - 1\n600     >>> erf2(oo, y)\n601     erf(y) - 1\n602     >>> erf2(-oo, y)\n603     erf(y) + 1\n604 \n605     In general one can pull out factors of -1:\n606 \n607     >>> erf2(-x, -y)\n608     -erf2(x, y)\n609 \n610     The error function obeys the mirror symmetry:\n611 \n612     >>> from sympy import conjugate\n613     >>> conjugate(erf2(x, y))\n614     erf2(conjugate(x), conjugate(y))\n615 \n616     Differentiation with respect to x, y is supported:\n617 \n618     >>> from sympy import diff\n619     >>> diff(erf2(x, y), x)\n620     -2*exp(-x**2)/sqrt(pi)\n621     >>> diff(erf2(x, y), y)\n622     2*exp(-y**2)/sqrt(pi)\n623 \n624     See Also\n625     ========\n626 \n627     erf: Gaussian error function.\n628     erfc: Complementary error function.\n629     erfi: Imaginary error function.\n630     erfinv: Inverse error function.\n631     erfcinv: Inverse Complementary error function.\n632     erf2inv: Inverse two-argument error function.\n633 \n634     References\n635     ==========\n636 \n637     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/\n638     \"\"\"\n639 \n640 \n641     def fdiff(self, argindex):\n642         x, y = self.args\n643         if argindex == 1:\n644             return -2*exp(-x**2)/sqrt(S.Pi)\n645         elif argindex == 2:\n646             return 2*exp(-y**2)/sqrt(S.Pi)\n647         else:\n648             raise ArgumentIndexError(self, argindex)\n649 \n650     @classmethod\n651     def eval(cls, x, y):\n652         I = S.Infinity\n653         N = S.NegativeInfinity\n654         O = S.Zero\n655         if x is S.NaN or y is S.NaN:\n656             return S.NaN\n657         elif x == y:\n658             return S.Zero\n659         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):\n660             return erf(y) - erf(x)\n661 \n662         if y.func is erf2inv and y.args[0] == x:\n663             return y.args[1]\n664 \n665         #Try to pull out -1 factor\n666         sign_x = x.could_extract_minus_sign()\n667         sign_y = y.could_extract_minus_sign()\n668         if (sign_x and sign_y):\n669             return -cls(-x, -y)\n670         elif (sign_x or sign_y):\n671             return erf(y)-erf(x)\n672 \n673     def _eval_conjugate(self):\n674         return self.func(self.args[0].conjugate(), self.args[1].conjugate())\n675 \n676     def _eval_is_real(self):\n677         return self.args[0].is_real and self.args[1].is_real\n678 \n679     def _eval_rewrite_as_erf(self, x, y):\n680         return erf(y) - erf(x)\n681 \n682     def _eval_rewrite_as_erfc(self, x, y):\n683         return erfc(x) - erfc(y)\n684 \n685     def _eval_rewrite_as_erfi(self, x, y):\n686         return I*(erfi(I*x)-erfi(I*y))\n687 \n688     def _eval_rewrite_as_fresnels(self, x, y):\n689         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)\n690 \n691     def _eval_rewrite_as_fresnelc(self, x, y):\n692         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)\n693 \n694     def _eval_rewrite_as_meijerg(self, x, y):\n695         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)\n696 \n697     def _eval_rewrite_as_hyper(self, x, y):\n698         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)\n699 \n700     def _eval_rewrite_as_uppergamma(self, x, y):\n701         from sympy import uppergamma\n702         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -\n703             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))\n704 \n705     def _eval_rewrite_as_expint(self, x, y):\n706         return erf(y).rewrite(expint) - erf(x).rewrite(expint)\n707 \n708 class erfinv(Function):\n709     r\"\"\"\n710     Inverse Error Function. The erfinv function is defined as:\n711 \n712     .. math ::\n713         \\mathrm{erf}(x) = y \\quad \\Rightarrow \\quad \\mathrm{erfinv}(y) = x\n714 \n715     Examples\n716     ========\n717 \n718     >>> from sympy import I, oo, erfinv\n719     >>> from sympy.abc import x\n720 \n721     Several special values are known:\n722 \n723     >>> erfinv(0)\n724     0\n725     >>> erfinv(1)\n726     oo\n727 \n728     Differentiation with respect to x is supported:\n729 \n730     >>> from sympy import diff\n731     >>> diff(erfinv(x), x)\n732     sqrt(pi)*exp(erfinv(x)**2)/2\n733 \n734     We can numerically evaluate the inverse error function to arbitrary precision\n735     on [-1, 1]:\n736 \n737     >>> erfinv(0.2).evalf(30)\n738     0.179143454621291692285822705344\n739 \n740     See Also\n741     ========\n742 \n743     erf: Gaussian error function.\n744     erfc: Complementary error function.\n745     erfi: Imaginary error function.\n746     erf2: Two-argument error function.\n747     erfcinv: Inverse Complementary error function.\n748     erf2inv: Inverse two-argument error function.\n749 \n750     References\n751     ==========\n752 \n753     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions\n754     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/\n755     \"\"\"\n756 \n757 \n758     def fdiff(self, argindex =1):\n759         if argindex == 1:\n760             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half\n761         else :\n762             raise ArgumentIndexError(self, argindex)\n763 \n764     def inverse(self, argindex=1):\n765         \"\"\"\n766         Returns the inverse of this function.\n767         \"\"\"\n768         return erf\n769 \n770     @classmethod\n771     def eval(cls, z):\n772         if z is S.NaN:\n773             return S.NaN\n774         elif z is S.NegativeOne:\n775             return S.NegativeInfinity\n776         elif z is S.Zero:\n777             return S.Zero\n778         elif z is S.One:\n779             return S.Infinity\n780 \n781         if (z.func is erf) and z.args[0].is_real:\n782             return z.args[0]\n783 \n784         # Try to pull out factors of -1\n785         nz = z.extract_multiplicatively(-1)\n786         if nz is not None and ((nz.func is erf) and (nz.args[0]).is_real):\n787             return -nz.args[0]\n788 \n789     def _eval_rewrite_as_erfcinv(self, z):\n790        return erfcinv(1-z)\n791 \n792 class erfcinv (Function):\n793     r\"\"\"\n794     Inverse Complementary Error Function. The erfcinv function is defined as:\n795 \n796     .. math ::\n797         \\mathrm{erfc}(x) = y \\quad \\Rightarrow \\quad \\mathrm{erfcinv}(y) = x\n798 \n799     Examples\n800     ========\n801 \n802     >>> from sympy import I, oo, erfcinv\n803     >>> from sympy.abc import x\n804 \n805     Several special values are known:\n806 \n807     >>> erfcinv(1)\n808     0\n809     >>> erfcinv(0)\n810     oo\n811 \n812     Differentiation with respect to x is supported:\n813 \n814     >>> from sympy import diff\n815     >>> diff(erfcinv(x), x)\n816     -sqrt(pi)*exp(erfcinv(x)**2)/2\n817 \n818     See Also\n819     ========\n820 \n821     erf: Gaussian error function.\n822     erfc: Complementary error function.\n823     erfi: Imaginary error function.\n824     erf2: Two-argument error function.\n825     erfinv: Inverse error function.\n826     erf2inv: Inverse two-argument error function.\n827 \n828     References\n829     ==========\n830 \n831     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions\n832     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/\n833     \"\"\"\n834 \n835 \n836     def fdiff(self, argindex =1):\n837         if argindex == 1:\n838             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half\n839         else:\n840             raise ArgumentIndexError(self, argindex)\n841 \n842     def inverse(self, argindex=1):\n843         \"\"\"\n844         Returns the inverse of this function.\n845         \"\"\"\n846         return erfc\n847 \n848     @classmethod\n849     def eval(cls, z):\n850         if z is S.NaN:\n851             return S.NaN\n852         elif z is S.Zero:\n853             return S.Infinity\n854         elif z is S.One:\n855             return S.Zero\n856         elif z == 2:\n857             return S.NegativeInfinity\n858 \n859     def _eval_rewrite_as_erfinv(self, z):\n860         return erfinv(1-z)\n861 \n862 class erf2inv(Function):\n863     r\"\"\"\n864     Two-argument Inverse error function. The erf2inv function is defined as:\n865 \n866     .. math ::\n867         \\mathrm{erf2}(x, w) = y \\quad \\Rightarrow \\quad \\mathrm{erf2inv}(x, y) = w\n868 \n869     Examples\n870     ========\n871 \n872     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv\n873     >>> from sympy.abc import x, y\n874 \n875     Several special values are known:\n876 \n877     >>> erf2inv(0, 0)\n878     0\n879     >>> erf2inv(1, 0)\n880     1\n881     >>> erf2inv(0, 1)\n882     oo\n883     >>> erf2inv(0, y)\n884     erfinv(y)\n885     >>> erf2inv(oo, y)\n886     erfcinv(-y)\n887 \n888     Differentiation with respect to x and y is supported:\n889 \n890     >>> from sympy import diff\n891     >>> diff(erf2inv(x, y), x)\n892     exp(-x**2 + erf2inv(x, y)**2)\n893     >>> diff(erf2inv(x, y), y)\n894     sqrt(pi)*exp(erf2inv(x, y)**2)/2\n895 \n896     See Also\n897     ========\n898 \n899     erf: Gaussian error function.\n900     erfc: Complementary error function.\n901     erfi: Imaginary error function.\n902     erf2: Two-argument error function.\n903     erfinv: Inverse error function.\n904     erfcinv: Inverse complementary error function.\n905 \n906     References\n907     ==========\n908 \n909     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/\n910     \"\"\"\n911 \n912 \n913     def fdiff(self, argindex):\n914         x, y = self.args\n915         if argindex == 1:\n916             return exp(self.func(x,y)**2-x**2)\n917         elif argindex == 2:\n918             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)\n919         else:\n920             raise ArgumentIndexError(self, argindex)\n921 \n922     @classmethod\n923     def eval(cls, x, y):\n924         if x is S.NaN or y is S.NaN:\n925             return S.NaN\n926         elif x is S.Zero and y is S.Zero:\n927             return S.Zero\n928         elif x is S.Zero and y is S.One:\n929             return S.Infinity\n930         elif x is S.One and y is S.Zero:\n931             return S.One\n932         elif x is S.Zero:\n933             return erfinv(y)\n934         elif x is S.Infinity:\n935             return erfcinv(-y)\n936         elif y is S.Zero:\n937             return x\n938         elif y is S.Infinity:\n939             return erfinv(x)\n940 \n941 \n942 ###############################################################################\n943 #################### EXPONENTIAL INTEGRALS ####################################\n944 ###############################################################################\n945 \n946 class Ei(Function):\n947     r\"\"\"\n948     The classical exponential integral.\n949 \n950     For use in SymPy, this function is defined as\n951 \n952     .. math:: \\operatorname{Ei}(x) = \\sum_{n=1}^\\infty \\frac{x^n}{n\\, n!}\n953                                      + \\log(x) + \\gamma,\n954 \n955     where `\\gamma` is the Euler-Mascheroni constant.\n956 \n957     If `x` is a polar number, this defines an analytic function on the\n958     Riemann surface of the logarithm. Otherwise this defines an analytic\n959     function in the cut plane `\\mathbb{C} \\setminus (-\\infty, 0]`.\n960 \n961     **Background**\n962 \n963     The name *exponential integral* comes from the following statement:\n964 \n965     .. math:: \\operatorname{Ei}(x) = \\int_{-\\infty}^x \\frac{e^t}{t} \\mathrm{d}t\n966 \n967     If the integral is interpreted as a Cauchy principal value, this statement\n968     holds for `x > 0` and `\\operatorname{Ei}(x)` as defined above.\n969 \n970     Note that we carefully avoided defining `\\operatorname{Ei}(x)` for\n971     negative real `x`. This is because above integral formula does not hold for\n972     any polar lift of such `x`, indeed all branches of\n973     `\\operatorname{Ei}(x)` above the negative reals are imaginary.\n974 \n975     However, the following statement holds for all `x \\in \\mathbb{R}^*`:\n976 \n977     .. math:: \\int_{-\\infty}^x \\frac{e^t}{t} \\mathrm{d}t =\n978               \\frac{\\operatorname{Ei}\\left(|x|e^{i \\arg(x)}\\right) +\n979                     \\operatorname{Ei}\\left(|x|e^{- i \\arg(x)}\\right)}{2},\n980 \n981     where the integral is again understood to be a principal value if\n982     `x > 0`, and `|x|e^{i \\arg(x)}`,\n983     `|x|e^{- i \\arg(x)}` denote two conjugate polar lifts of `x`.\n984 \n985     Examples\n986     ========\n987 \n988     >>> from sympy import Ei, polar_lift, exp_polar, I, pi\n989     >>> from sympy.abc import x\n990 \n991     The exponential integral in SymPy is strictly undefined for negative values\n992     of the argument. For convenience, exponential integrals with negative\n993     arguments are immediately converted into an expression that agrees with\n994     the classical integral definition:\n995 \n996     >>> Ei(-1)\n997     -I*pi + Ei(exp_polar(I*pi))\n998 \n999     This yields a real value:\n1000 \n1001     >>> Ei(-1).n(chop=True)\n1002     -0.219383934395520\n1003 \n1004     On the other hand the analytic continuation is not real:\n1005 \n1006     >>> Ei(polar_lift(-1)).n(chop=True)\n1007     -0.21938393439552 + 3.14159265358979*I\n1008 \n1009     The exponential integral has a logarithmic branch point at the origin:\n1010 \n1011     >>> Ei(x*exp_polar(2*I*pi))\n1012     Ei(x) + 2*I*pi\n1013 \n1014     Differentiation is supported:\n1015 \n1016     >>> Ei(x).diff(x)\n1017     exp(x)/x\n1018 \n1019     The exponential integral is related to many other special functions.\n1020     For example:\n1021 \n1022     >>> from sympy import uppergamma, expint, Shi\n1023     >>> Ei(x).rewrite(expint)\n1024     -expint(1, x*exp_polar(I*pi)) - I*pi\n1025     >>> Ei(x).rewrite(Shi)\n1026     Chi(x) + Shi(x)\n1027 \n1028     See Also\n1029     ========\n1030 \n1031     expint: Generalised exponential integral.\n1032     E1: Special case of the generalised exponential integral.\n1033     li: Logarithmic integral.\n1034     Li: Offset logarithmic integral.\n1035     Si: Sine integral.\n1036     Ci: Cosine integral.\n1037     Shi: Hyperbolic sine integral.\n1038     Chi: Hyperbolic cosine integral.\n1039     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.\n1040 \n1041     References\n1042     ==========\n1043 \n1044     .. [1] http://dlmf.nist.gov/6.6\n1045     .. [2] http://en.wikipedia.org/wiki/Exponential_integral\n1046     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm\n1047 \n1048     \"\"\"\n1049 \n1050 \n1051     @classmethod\n1052     def eval(cls, z):\n1053         if z is S.Zero:\n1054             return S.NegativeInfinity\n1055         elif z is S.Infinity:\n1056             return S.Infinity\n1057         elif z is S.NegativeInfinity:\n1058             return S.Zero\n1059 \n1060         if not z.is_polar and z.is_negative:\n1061             # Note: is this a good idea?\n1062             return Ei(polar_lift(z)) - pi*I\n1063         nz, n = z.extract_branch_factor()\n1064         if n:\n1065             return Ei(nz) + 2*I*pi*n\n1066 \n1067     def fdiff(self, argindex=1):\n1068         from sympy import unpolarify\n1069         arg = unpolarify(self.args[0])\n1070         if argindex == 1:\n1071             return exp(arg)/arg\n1072         else:\n1073             raise ArgumentIndexError(self, argindex)\n1074 \n1075     def _eval_evalf(self, prec):\n1076         if (self.args[0]/polar_lift(-1)).is_positive:\n1077             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)\n1078         return Function._eval_evalf(self, prec)\n1079 \n1080     def _eval_rewrite_as_uppergamma(self, z):\n1081         from sympy import uppergamma\n1082         # XXX this does not currently work usefully because uppergamma\n1083         #     immediately turns into expint\n1084         return -uppergamma(0, polar_lift(-1)*z) - I*pi\n1085 \n1086     def _eval_rewrite_as_expint(self, z):\n1087         return -expint(1, polar_lift(-1)*z) - I*pi\n1088 \n1089     def _eval_rewrite_as_li(self, z):\n1090         if isinstance(z, log):\n1091             return li(z.args[0])\n1092         # TODO:\n1093         # Actually it only holds that:\n1094         #  Ei(z) = li(exp(z))\n1095         # for -pi < imag(z) <= pi\n1096         return li(exp(z))\n1097 \n1098     def _eval_rewrite_as_Si(self, z):\n1099         return Shi(z) + Chi(z)\n1100     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1101     _eval_rewrite_as_Chi = _eval_rewrite_as_Si\n1102     _eval_rewrite_as_Shi = _eval_rewrite_as_Si\n1103 \n1104     def _eval_rewrite_as_tractable(self, z):\n1105         return exp(z) * _eis(z)\n1106 \n1107     def _eval_nseries(self, x, n, logx):\n1108         x0 = self.args[0].limit(x, 0)\n1109         if x0 is S.Zero:\n1110             f = self._eval_rewrite_as_Si(*self.args)\n1111             return f._eval_nseries(x, n, logx)\n1112         return super(Ei, self)._eval_nseries(x, n, logx)\n1113 \n1114 \n1115 class expint(Function):\n1116     r\"\"\"\n1117     Generalized exponential integral.\n1118 \n1119     This function is defined as\n1120 \n1121     .. math:: \\operatorname{E}_\\nu(z) = z^{\\nu - 1} \\Gamma(1 - \\nu, z),\n1122 \n1123     where `\\Gamma(1 - \\nu, z)` is the upper incomplete gamma function\n1124     (``uppergamma``).\n1125 \n1126     Hence for :math:`z` with positive real part we have\n1127 \n1128     .. math:: \\operatorname{E}_\\nu(z)\n1129               =   \\int_1^\\infty \\frac{e^{-zt}}{z^\\nu} \\mathrm{d}t,\n1130 \n1131     which explains the name.\n1132 \n1133     The representation as an incomplete gamma function provides an analytic\n1134     continuation for :math:`\\operatorname{E}_\\nu(z)`. If :math:`\\nu` is a\n1135     non-positive integer the exponential integral is thus an unbranched\n1136     function of :math:`z`, otherwise there is a branch point at the origin.\n1137     Refer to the incomplete gamma function documentation for details of the\n1138     branching behavior.\n1139 \n1140     Examples\n1141     ========\n1142 \n1143     >>> from sympy import expint, S\n1144     >>> from sympy.abc import nu, z\n1145 \n1146     Differentiation is supported. Differentiation with respect to z explains\n1147     further the name: for integral orders, the exponential integral is an\n1148     iterated integral of the exponential function.\n1149 \n1150     >>> expint(nu, z).diff(z)\n1151     -expint(nu - 1, z)\n1152 \n1153     Differentiation with respect to nu has no classical expression:\n1154 \n1155     >>> expint(nu, z).diff(nu)\n1156     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, -nu + 1), ()), z)\n1157 \n1158     At non-postive integer orders, the exponential integral reduces to the\n1159     exponential function:\n1160 \n1161     >>> expint(0, z)\n1162     exp(-z)/z\n1163     >>> expint(-1, z)\n1164     exp(-z)/z + exp(-z)/z**2\n1165 \n1166     At half-integers it reduces to error functions:\n1167 \n1168     >>> expint(S(1)/2, z)\n1169     sqrt(pi)*erfc(sqrt(z))/sqrt(z)\n1170 \n1171     At positive integer orders it can be rewritten in terms of exponentials\n1172     and expint(1, z). Use expand_func() to do this:\n1173 \n1174     >>> from sympy import expand_func\n1175     >>> expand_func(expint(5, z))\n1176     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24\n1177 \n1178     The generalised exponential integral is essentially equivalent to the\n1179     incomplete gamma function:\n1180 \n1181     >>> from sympy import uppergamma\n1182     >>> expint(nu, z).rewrite(uppergamma)\n1183     z**(nu - 1)*uppergamma(-nu + 1, z)\n1184 \n1185     As such it is branched at the origin:\n1186 \n1187     >>> from sympy import exp_polar, pi, I\n1188     >>> expint(4, z*exp_polar(2*pi*I))\n1189     I*pi*z**3/3 + expint(4, z)\n1190     >>> expint(nu, z*exp_polar(2*pi*I))\n1191     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(-nu + 1) + expint(nu, z)\n1192 \n1193     See Also\n1194     ========\n1195 \n1196     Ei: Another related function called exponential integral.\n1197     E1: The classical case, returns expint(1, z).\n1198     li: Logarithmic integral.\n1199     Li: Offset logarithmic integral.\n1200     Si: Sine integral.\n1201     Ci: Cosine integral.\n1202     Shi: Hyperbolic sine integral.\n1203     Chi: Hyperbolic cosine integral.\n1204     sympy.functions.special.gamma_functions.uppergamma\n1205 \n1206     References\n1207     ==========\n1208 \n1209     .. [1] http://dlmf.nist.gov/8.19\n1210     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/\n1211     .. [3] http://en.wikipedia.org/wiki/Exponential_integral\n1212 \n1213     \"\"\"\n1214 \n1215 \n1216     @classmethod\n1217     def eval(cls, nu, z):\n1218         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,\n1219                            factorial)\n1220         nu2 = unpolarify(nu)\n1221         if nu != nu2:\n1222             return expint(nu2, z)\n1223         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):\n1224             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))\n1225 \n1226         # Extract branching information. This can be deduced from what is\n1227         # explained in lowergamma.eval().\n1228         z, n = z.extract_branch_factor()\n1229         if n == 0:\n1230             return\n1231         if nu.is_integer:\n1232             if (nu > 0) != True:\n1233                 return\n1234             return expint(nu, z) \\\n1235                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)\n1236         else:\n1237             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)\n1238 \n1239     def fdiff(self, argindex):\n1240         from sympy import meijerg\n1241         nu, z = self.args\n1242         if argindex == 1:\n1243             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)\n1244         elif argindex == 2:\n1245             return -expint(nu - 1, z)\n1246         else:\n1247             raise ArgumentIndexError(self, argindex)\n1248 \n1249     def _eval_rewrite_as_uppergamma(self, nu, z):\n1250         from sympy import uppergamma\n1251         return z**(nu - 1)*uppergamma(1 - nu, z)\n1252 \n1253     def _eval_rewrite_as_Ei(self, nu, z):\n1254         from sympy import exp_polar, unpolarify, exp, factorial\n1255         if nu == 1:\n1256             return -Ei(z*exp_polar(-I*pi)) - I*pi\n1257         elif nu.is_Integer and nu > 1:\n1258             # DLMF, 8.19.7\n1259             x = -unpolarify(z)\n1260             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \\\n1261                 exp(x)/factorial(nu - 1) * \\\n1262                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])\n1263         else:\n1264             return self\n1265 \n1266     def _eval_expand_func(self, **hints):\n1267         return self.rewrite(Ei).rewrite(expint, **hints)\n1268 \n1269     def _eval_rewrite_as_Si(self, nu, z):\n1270         if nu != 1:\n1271             return self\n1272         return Shi(z) - Chi(z)\n1273     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1274     _eval_rewrite_as_Chi = _eval_rewrite_as_Si\n1275     _eval_rewrite_as_Shi = _eval_rewrite_as_Si\n1276 \n1277     def _eval_nseries(self, x, n, logx):\n1278         if not self.args[0].has(x):\n1279             nu = self.args[0]\n1280             if nu == 1:\n1281                 f = self._eval_rewrite_as_Si(*self.args)\n1282                 return f._eval_nseries(x, n, logx)\n1283             elif nu.is_Integer and nu > 1:\n1284                 f = self._eval_rewrite_as_Ei(*self.args)\n1285                 return f._eval_nseries(x, n, logx)\n1286         return super(expint, self)._eval_nseries(x, n, logx)\n1287 \n1288     def _sage_(self):\n1289         import sage.all as sage\n1290         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())\n1291 \n1292 \n1293 def E1(z):\n1294     \"\"\"\n1295     Classical case of the generalized exponential integral.\n1296 \n1297     This is equivalent to ``expint(1, z)``.\n1298 \n1299     See Also\n1300     ========\n1301 \n1302     Ei: Exponential integral.\n1303     expint: Generalised exponential integral.\n1304     li: Logarithmic integral.\n1305     Li: Offset logarithmic integral.\n1306     Si: Sine integral.\n1307     Ci: Cosine integral.\n1308     Shi: Hyperbolic sine integral.\n1309     Chi: Hyperbolic cosine integral.\n1310     \"\"\"\n1311     return expint(1, z)\n1312 \n1313 \n1314 class li(Function):\n1315     r\"\"\"\n1316     The classical logarithmic integral.\n1317 \n1318     For the use in SymPy, this function is defined as\n1319 \n1320     .. math:: \\operatorname{li}(x) = \\int_0^x \\frac{1}{\\log(t)} \\mathrm{d}t \\,.\n1321 \n1322     Examples\n1323     ========\n1324 \n1325     >>> from sympy import I, oo, li\n1326     >>> from sympy.abc import z\n1327 \n1328     Several special values are known:\n1329 \n1330     >>> li(0)\n1331     0\n1332     >>> li(1)\n1333     -oo\n1334     >>> li(oo)\n1335     oo\n1336 \n1337     Differentiation with respect to z is supported:\n1338 \n1339     >>> from sympy import diff\n1340     >>> diff(li(z), z)\n1341     1/log(z)\n1342 \n1343     Defining the `li` function via an integral:\n1344 \n1345 \n1346     The logarithmic integral can also be defined in terms of Ei:\n1347 \n1348     >>> from sympy import Ei\n1349     >>> li(z).rewrite(Ei)\n1350     Ei(log(z))\n1351     >>> diff(li(z).rewrite(Ei), z)\n1352     1/log(z)\n1353 \n1354     We can numerically evaluate the logarithmic integral to arbitrary precision\n1355     on the whole complex plane (except the singular points):\n1356 \n1357     >>> li(2).evalf(30)\n1358     1.04516378011749278484458888919\n1359 \n1360     >>> li(2*I).evalf(30)\n1361     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I\n1362 \n1363     We can even compute Soldner's constant by the help of mpmath:\n1364 \n1365     >>> from mpmath import findroot\n1366     >>> findroot(li, 2)\n1367     1.45136923488338\n1368 \n1369     Further transformations include rewriting `li` in terms of\n1370     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:\n1371 \n1372     >>> from sympy import Si, Ci, Shi, Chi\n1373     >>> li(z).rewrite(Si)\n1374     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))\n1375     >>> li(z).rewrite(Ci)\n1376     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))\n1377     >>> li(z).rewrite(Shi)\n1378     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))\n1379     >>> li(z).rewrite(Chi)\n1380     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))\n1381 \n1382     See Also\n1383     ========\n1384 \n1385     Li: Offset logarithmic integral.\n1386     Ei: Exponential integral.\n1387     expint: Generalised exponential integral.\n1388     E1: Special case of the generalised exponential integral.\n1389     Si: Sine integral.\n1390     Ci: Cosine integral.\n1391     Shi: Hyperbolic sine integral.\n1392     Chi: Hyperbolic cosine integral.\n1393 \n1394     References\n1395     ==========\n1396 \n1397     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral\n1398     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html\n1399     .. [3] http://dlmf.nist.gov/6\n1400     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html\n1401     \"\"\"\n1402 \n1403 \n1404     @classmethod\n1405     def eval(cls, z):\n1406         if z is S.Zero:\n1407             return S.Zero\n1408         elif z is S.One:\n1409             return S.NegativeInfinity\n1410         elif z is S.Infinity:\n1411             return S.Infinity\n1412 \n1413     def fdiff(self, argindex=1):\n1414         arg = self.args[0]\n1415         if argindex == 1:\n1416             return S.One / log(arg)\n1417         else:\n1418             raise ArgumentIndexError(self, argindex)\n1419 \n1420     def _eval_conjugate(self):\n1421         z = self.args[0]\n1422         # Exclude values on the branch cut (-oo, 0)\n1423         if not (z.is_real and z.is_negative):\n1424             return self.func(z.conjugate())\n1425 \n1426     def _eval_rewrite_as_Li(self, z):\n1427         return Li(z) + li(2)\n1428 \n1429     def _eval_rewrite_as_Ei(self, z):\n1430         return Ei(log(z))\n1431 \n1432     def _eval_rewrite_as_uppergamma(self, z):\n1433         from sympy import uppergamma\n1434         return (-uppergamma(0, -log(z)) +\n1435                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))\n1436 \n1437     def _eval_rewrite_as_Si(self, z):\n1438         return (Ci(I*log(z)) - I*Si(I*log(z)) -\n1439                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))\n1440 \n1441     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1442 \n1443     def _eval_rewrite_as_Shi(self, z):\n1444         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))\n1445 \n1446     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi\n1447 \n1448     def _eval_rewrite_as_hyper(self, z):\n1449         return (log(z)*hyper((1, 1), (2, 2), log(z)) +\n1450                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)\n1451 \n1452     def _eval_rewrite_as_meijerg(self, z):\n1453         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))\n1454                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))\n1455 \n1456     def _eval_rewrite_as_tractable(self, z):\n1457         return z * _eis(log(z))\n1458 \n1459 \n1460 class Li(Function):\n1461     r\"\"\"\n1462     The offset logarithmic integral.\n1463 \n1464     For the use in SymPy, this function is defined as\n1465 \n1466     .. math:: \\operatorname{Li}(x) = \\operatorname{li}(x) - \\operatorname{li}(2)\n1467 \n1468     Examples\n1469     ========\n1470 \n1471     >>> from sympy import I, oo, Li\n1472     >>> from sympy.abc import z\n1473 \n1474     The following special value is known:\n1475 \n1476     >>> Li(2)\n1477     0\n1478 \n1479     Differentiation with respect to z is supported:\n1480 \n1481     >>> from sympy import diff\n1482     >>> diff(Li(z), z)\n1483     1/log(z)\n1484 \n1485     The shifted logarithmic integral can be written in terms of `li(z)`:\n1486 \n1487     >>> from sympy import li\n1488     >>> Li(z).rewrite(li)\n1489     li(z) - li(2)\n1490 \n1491     We can numerically evaluate the logarithmic integral to arbitrary precision\n1492     on the whole complex plane (except the singular points):\n1493 \n1494     >>> Li(2).evalf(30)\n1495     0\n1496 \n1497     >>> Li(4).evalf(30)\n1498     1.92242131492155809316615998938\n1499 \n1500     See Also\n1501     ========\n1502 \n1503     li: Logarithmic integral.\n1504     Ei: Exponential integral.\n1505     expint: Generalised exponential integral.\n1506     E1: Special case of the generalised exponential integral.\n1507     Si: Sine integral.\n1508     Ci: Cosine integral.\n1509     Shi: Hyperbolic sine integral.\n1510     Chi: Hyperbolic cosine integral.\n1511 \n1512     References\n1513     ==========\n1514 \n1515     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral\n1516     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html\n1517     .. [3] http://dlmf.nist.gov/6\n1518     \"\"\"\n1519 \n1520 \n1521     @classmethod\n1522     def eval(cls, z):\n1523         if z is S.Infinity:\n1524             return S.Infinity\n1525         elif z is 2*S.One:\n1526             return S.Zero\n1527 \n1528     def fdiff(self, argindex=1):\n1529         arg = self.args[0]\n1530         if argindex == 1:\n1531             return S.One / log(arg)\n1532         else:\n1533             raise ArgumentIndexError(self, argindex)\n1534 \n1535     def _eval_evalf(self, prec):\n1536         return self.rewrite(li).evalf(prec)\n1537 \n1538     def _eval_rewrite_as_li(self, z):\n1539         return li(z) - li(2)\n1540 \n1541     def _eval_rewrite_as_tractable(self, z):\n1542         return self.rewrite(li).rewrite(\"tractable\", deep=True)\n1543 \n1544 ###############################################################################\n1545 #################### TRIGONOMETRIC INTEGRALS ##################################\n1546 ###############################################################################\n1547 \n1548 class TrigonometricIntegral(Function):\n1549     \"\"\" Base class for trigonometric integrals. \"\"\"\n1550 \n1551 \n1552     @classmethod\n1553     def eval(cls, z):\n1554         if z == 0:\n1555             return cls._atzero\n1556         elif z is S.Infinity:\n1557             return cls._atinf()\n1558         elif z is S.NegativeInfinity:\n1559             return cls._atneginf()\n1560 \n1561         nz = z.extract_multiplicatively(polar_lift(I))\n1562         if nz is None and cls._trigfunc(0) == 0:\n1563             nz = z.extract_multiplicatively(I)\n1564         if nz is not None:\n1565             return cls._Ifactor(nz, 1)\n1566         nz = z.extract_multiplicatively(polar_lift(-I))\n1567         if nz is not None:\n1568             return cls._Ifactor(nz, -1)\n1569 \n1570         nz = z.extract_multiplicatively(polar_lift(-1))\n1571         if nz is None and cls._trigfunc(0) == 0:\n1572             nz = z.extract_multiplicatively(-1)\n1573         if nz is not None:\n1574             return cls._minusfactor(nz)\n1575 \n1576         nz, n = z.extract_branch_factor()\n1577         if n == 0 and nz == z:\n1578             return\n1579         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)\n1580 \n1581     def fdiff(self, argindex=1):\n1582         from sympy import unpolarify\n1583         arg = unpolarify(self.args[0])\n1584         if argindex == 1:\n1585             return self._trigfunc(arg)/arg\n1586 \n1587     def _eval_rewrite_as_Ei(self, z):\n1588         return self._eval_rewrite_as_expint(z).rewrite(Ei)\n1589 \n1590     def _eval_rewrite_as_uppergamma(self, z):\n1591         from sympy import uppergamma\n1592         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)\n1593 \n1594     def _eval_nseries(self, x, n, logx):\n1595         # NOTE this is fairly inefficient\n1596         from sympy import log, EulerGamma, Pow\n1597         n += 1\n1598         if self.args[0].subs(x, 0) != 0:\n1599             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)\n1600         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)\n1601         if self._trigfunc(0) != 0:\n1602             baseseries -= 1\n1603         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)\n1604         if self._trigfunc(0) != 0:\n1605             baseseries += EulerGamma + log(x)\n1606         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)\n1607 \n1608 \n1609 class Si(TrigonometricIntegral):\n1610     r\"\"\"\n1611     Sine integral.\n1612 \n1613     This function is defined by\n1614 \n1615     .. math:: \\operatorname{Si}(z) = \\int_0^z \\frac{\\sin{t}}{t} \\mathrm{d}t.\n1616 \n1617     It is an entire function.\n1618 \n1619     Examples\n1620     ========\n1621 \n1622     >>> from sympy import Si\n1623     >>> from sympy.abc import z\n1624 \n1625     The sine integral is an antiderivative of sin(z)/z:\n1626 \n1627     >>> Si(z).diff(z)\n1628     sin(z)/z\n1629 \n1630     It is unbranched:\n1631 \n1632     >>> from sympy import exp_polar, I, pi\n1633     >>> Si(z*exp_polar(2*I*pi))\n1634     Si(z)\n1635 \n1636     Sine integral behaves much like ordinary sine under multiplication by ``I``:\n1637 \n1638     >>> Si(I*z)\n1639     I*Shi(z)\n1640     >>> Si(-z)\n1641     -Si(z)\n1642 \n1643     It can also be expressed in terms of exponential integrals, but beware\n1644     that the latter is branched:\n1645 \n1646     >>> from sympy import expint\n1647     >>> Si(z).rewrite(expint)\n1648     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +\n1649          expint(1, z*exp_polar(I*pi/2))/2) + pi/2\n1650 \n1651     It can be rewritten in the form of sinc function (By definition)\n1652 \n1653     >>> from sympy import sinc\n1654     >>> Si(z).rewrite(sinc)\n1655     Integral(sinc(t), (t, 0, z))\n1656 \n1657     See Also\n1658     ========\n1659 \n1660     Ci: Cosine integral.\n1661     Shi: Hyperbolic sine integral.\n1662     Chi: Hyperbolic cosine integral.\n1663     Ei: Exponential integral.\n1664     expint: Generalised exponential integral.\n1665     sinc: unnormalized sinc function\n1666     E1: Special case of the generalised exponential integral.\n1667     li: Logarithmic integral.\n1668     Li: Offset logarithmic integral.\n1669 \n1670     References\n1671     ==========\n1672 \n1673     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral\n1674 \n1675     \"\"\"\n1676 \n1677     _trigfunc = sin\n1678     _atzero = S(0)\n1679 \n1680     @classmethod\n1681     def _atinf(cls):\n1682         return pi*S.Half\n1683 \n1684     @classmethod\n1685     def _atneginf(cls):\n1686         return -pi*S.Half\n1687 \n1688     @classmethod\n1689     def _minusfactor(cls, z):\n1690         return -Si(z)\n1691 \n1692     @classmethod\n1693     def _Ifactor(cls, z, sign):\n1694         return I*Shi(z)*sign\n1695 \n1696     def _eval_rewrite_as_expint(self, z):\n1697         # XXX should we polarify z?\n1698         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I\n1699 \n1700     def _eval_rewrite_as_sinc(self, z):\n1701         from sympy import Integral\n1702         t = Symbol('t', Dummy=True)\n1703         return Integral(sinc(t), (t, 0, z))\n1704 \n1705     def _sage_(self):\n1706         import sage.all as sage\n1707         return sage.sin_integral(self.args[0]._sage_())\n1708 \n1709 class Ci(TrigonometricIntegral):\n1710     r\"\"\"\n1711     Cosine integral.\n1712 \n1713     This function is defined for positive `x` by\n1714 \n1715     .. math:: \\operatorname{Ci}(x) = \\gamma + \\log{x}\n1716                          + \\int_0^x \\frac{\\cos{t} - 1}{t} \\mathrm{d}t\n1717            = -\\int_x^\\infty \\frac{\\cos{t}}{t} \\mathrm{d}t,\n1718 \n1719     where `\\gamma` is the Euler-Mascheroni constant.\n1720 \n1721     We have\n1722 \n1723     .. math:: \\operatorname{Ci}(z) =\n1724         -\\frac{\\operatorname{E}_1\\left(e^{i\\pi/2} z\\right)\n1725                + \\operatorname{E}_1\\left(e^{-i \\pi/2} z\\right)}{2}\n1726 \n1727     which holds for all polar `z` and thus provides an analytic\n1728     continuation to the Riemann surface of the logarithm.\n1729 \n1730     The formula also holds as stated\n1731     for `z \\in \\mathbb{C}` with `\\Re(z) > 0`.\n1732     By lifting to the principal branch we obtain an analytic function on the\n1733     cut complex plane.\n1734 \n1735     Examples\n1736     ========\n1737 \n1738     >>> from sympy import Ci\n1739     >>> from sympy.abc import z\n1740 \n1741     The cosine integral is a primitive of `\\cos(z)/z`:\n1742 \n1743     >>> Ci(z).diff(z)\n1744     cos(z)/z\n1745 \n1746     It has a logarithmic branch point at the origin:\n1747 \n1748     >>> from sympy import exp_polar, I, pi\n1749     >>> Ci(z*exp_polar(2*I*pi))\n1750     Ci(z) + 2*I*pi\n1751 \n1752     The cosine integral behaves somewhat like ordinary `\\cos` under multiplication by `i`:\n1753 \n1754     >>> from sympy import polar_lift\n1755     >>> Ci(polar_lift(I)*z)\n1756     Chi(z) + I*pi/2\n1757     >>> Ci(polar_lift(-1)*z)\n1758     Ci(z) + I*pi\n1759 \n1760     It can also be expressed in terms of exponential integrals:\n1761 \n1762     >>> from sympy import expint\n1763     >>> Ci(z).rewrite(expint)\n1764     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2\n1765 \n1766     See Also\n1767     ========\n1768 \n1769     Si: Sine integral.\n1770     Shi: Hyperbolic sine integral.\n1771     Chi: Hyperbolic cosine integral.\n1772     Ei: Exponential integral.\n1773     expint: Generalised exponential integral.\n1774     E1: Special case of the generalised exponential integral.\n1775     li: Logarithmic integral.\n1776     Li: Offset logarithmic integral.\n1777 \n1778     References\n1779     ==========\n1780 \n1781     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral\n1782 \n1783     \"\"\"\n1784 \n1785     _trigfunc = cos\n1786     _atzero = S.ComplexInfinity\n1787 \n1788     @classmethod\n1789     def _atinf(cls):\n1790         return S.Zero\n1791 \n1792     @classmethod\n1793     def _atneginf(cls):\n1794         return I*pi\n1795 \n1796     @classmethod\n1797     def _minusfactor(cls, z):\n1798         return Ci(z) + I*pi\n1799 \n1800     @classmethod\n1801     def _Ifactor(cls, z, sign):\n1802         return Chi(z) + I*pi/2*sign\n1803 \n1804     def _eval_rewrite_as_expint(self, z):\n1805         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2\n1806 \n1807     def _sage_(self):\n1808         import sage.all as sage\n1809         return sage.cos_integral(self.args[0]._sage_())\n1810 \n1811 \n1812 class Shi(TrigonometricIntegral):\n1813     r\"\"\"\n1814     Sinh integral.\n1815 \n1816     This function is defined by\n1817 \n1818     .. math:: \\operatorname{Shi}(z) = \\int_0^z \\frac{\\sinh{t}}{t} \\mathrm{d}t.\n1819 \n1820     It is an entire function.\n1821 \n1822     Examples\n1823     ========\n1824 \n1825     >>> from sympy import Shi\n1826     >>> from sympy.abc import z\n1827 \n1828     The Sinh integral is a primitive of `\\sinh(z)/z`:\n1829 \n1830     >>> Shi(z).diff(z)\n1831     sinh(z)/z\n1832 \n1833     It is unbranched:\n1834 \n1835     >>> from sympy import exp_polar, I, pi\n1836     >>> Shi(z*exp_polar(2*I*pi))\n1837     Shi(z)\n1838 \n1839     The `\\sinh` integral behaves much like ordinary `\\sinh` under multiplication by `i`:\n1840 \n1841     >>> Shi(I*z)\n1842     I*Si(z)\n1843     >>> Shi(-z)\n1844     -Shi(z)\n1845 \n1846     It can also be expressed in terms of exponential integrals, but beware\n1847     that the latter is branched:\n1848 \n1849     >>> from sympy import expint\n1850     >>> Shi(z).rewrite(expint)\n1851     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n1852 \n1853     See Also\n1854     ========\n1855 \n1856     Si: Sine integral.\n1857     Ci: Cosine integral.\n1858     Chi: Hyperbolic cosine integral.\n1859     Ei: Exponential integral.\n1860     expint: Generalised exponential integral.\n1861     E1: Special case of the generalised exponential integral.\n1862     li: Logarithmic integral.\n1863     Li: Offset logarithmic integral.\n1864 \n1865     References\n1866     ==========\n1867 \n1868     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral\n1869 \n1870     \"\"\"\n1871 \n1872     _trigfunc = sinh\n1873     _atzero = S(0)\n1874 \n1875     @classmethod\n1876     def _atinf(cls):\n1877         return S.Infinity\n1878 \n1879     @classmethod\n1880     def _atneginf(cls):\n1881         return S.NegativeInfinity\n1882 \n1883     @classmethod\n1884     def _minusfactor(cls, z):\n1885         return -Shi(z)\n1886 \n1887     @classmethod\n1888     def _Ifactor(cls, z, sign):\n1889         return I*Si(z)*sign\n1890 \n1891     def _eval_rewrite_as_expint(self, z):\n1892         from sympy import exp_polar\n1893         # XXX should we polarify z?\n1894         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2\n1895 \n1896     def _sage_(self):\n1897         import sage.all as sage\n1898         return sage.sinh_integral(self.args[0]._sage_())\n1899 \n1900 \n1901 class Chi(TrigonometricIntegral):\n1902     r\"\"\"\n1903     Cosh integral.\n1904 \n1905     This function is defined for positive :math:`x` by\n1906 \n1907     .. math:: \\operatorname{Chi}(x) = \\gamma + \\log{x}\n1908                          + \\int_0^x \\frac{\\cosh{t} - 1}{t} \\mathrm{d}t,\n1909 \n1910     where :math:`\\gamma` is the Euler-Mascheroni constant.\n1911 \n1912     We have\n1913 \n1914     .. math:: \\operatorname{Chi}(z) = \\operatorname{Ci}\\left(e^{i \\pi/2}z\\right)\n1915                          - i\\frac{\\pi}{2},\n1916 \n1917     which holds for all polar :math:`z` and thus provides an analytic\n1918     continuation to the Riemann surface of the logarithm.\n1919     By lifting to the principal branch we obtain an analytic function on the\n1920     cut complex plane.\n1921 \n1922     Examples\n1923     ========\n1924 \n1925     >>> from sympy import Chi\n1926     >>> from sympy.abc import z\n1927 \n1928     The `\\cosh` integral is a primitive of `\\cosh(z)/z`:\n1929 \n1930     >>> Chi(z).diff(z)\n1931     cosh(z)/z\n1932 \n1933     It has a logarithmic branch point at the origin:\n1934 \n1935     >>> from sympy import exp_polar, I, pi\n1936     >>> Chi(z*exp_polar(2*I*pi))\n1937     Chi(z) + 2*I*pi\n1938 \n1939     The `\\cosh` integral behaves somewhat like ordinary `\\cosh` under multiplication by `i`:\n1940 \n1941     >>> from sympy import polar_lift\n1942     >>> Chi(polar_lift(I)*z)\n1943     Ci(z) + I*pi/2\n1944     >>> Chi(polar_lift(-1)*z)\n1945     Chi(z) + I*pi\n1946 \n1947     It can also be expressed in terms of exponential integrals:\n1948 \n1949     >>> from sympy import expint\n1950     >>> Chi(z).rewrite(expint)\n1951     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n1952 \n1953     See Also\n1954     ========\n1955 \n1956     Si: Sine integral.\n1957     Ci: Cosine integral.\n1958     Shi: Hyperbolic sine integral.\n1959     Ei: Exponential integral.\n1960     expint: Generalised exponential integral.\n1961     E1: Special case of the generalised exponential integral.\n1962     li: Logarithmic integral.\n1963     Li: Offset logarithmic integral.\n1964 \n1965     References\n1966     ==========\n1967 \n1968     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral\n1969 \n1970     \"\"\"\n1971 \n1972     _trigfunc = cosh\n1973     _atzero = S.ComplexInfinity\n1974 \n1975     @classmethod\n1976     def _atinf(cls):\n1977         return S.Infinity\n1978 \n1979     @classmethod\n1980     def _atneginf(cls):\n1981         return S.Infinity\n1982 \n1983     @classmethod\n1984     def _minusfactor(cls, z):\n1985         return Chi(z) + I*pi\n1986 \n1987     @classmethod\n1988     def _Ifactor(cls, z, sign):\n1989         return Ci(z) + I*pi/2*sign\n1990 \n1991     def _eval_rewrite_as_expint(self, z):\n1992         from sympy import exp_polar\n1993         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2\n1994 \n1995     def _latex(self, printer, exp=None):\n1996         if len(self.args) != 1:\n1997             raise ValueError(\"Arg length should be 1\")\n1998         if exp:\n1999             return r'\\operatorname{Chi}^{%s}{\\left (%s \\right )}' \\\n2000                 % (printer._print(exp), printer._print(self.args[0]))\n2001         else:\n2002             return r'\\operatorname{Chi}{\\left (%s \\right )}' \\\n2003                 % printer._print(self.args[0])\n2004 \n2005     @staticmethod\n2006     def _latex_no_arg(printer):\n2007         return r'\\operatorname{Chi}'\n2008 \n2009     def _sage_(self):\n2010         import sage.all as sage\n2011         return sage.cosh_integral(self.args[0]._sage_())\n2012 \n2013 \n2014 ###############################################################################\n2015 #################### FRESNEL INTEGRALS ########################################\n2016 ###############################################################################\n2017 \n2018 class FresnelIntegral(Function):\n2019     \"\"\" Base class for the Fresnel integrals.\"\"\"\n2020 \n2021     unbranched = True\n2022 \n2023     @classmethod\n2024     def eval(cls, z):\n2025         # Value at zero\n2026         if z is S.Zero:\n2027             return S(0)\n2028 \n2029         # Try to pull out factors of -1 and I\n2030         prefact = S.One\n2031         newarg = z\n2032         changed = False\n2033 \n2034         nz = newarg.extract_multiplicatively(-1)\n2035         if nz is not None:\n2036             prefact = -prefact\n2037             newarg = nz\n2038             changed = True\n2039 \n2040         nz = newarg.extract_multiplicatively(I)\n2041         if nz is not None:\n2042             prefact = cls._sign*I*prefact\n2043             newarg = nz\n2044             changed = True\n2045 \n2046         if changed:\n2047             return prefact*cls(newarg)\n2048 \n2049         # Values at positive infinities signs\n2050         # if any were extracted automatically\n2051         if z is S.Infinity:\n2052             return S.Half\n2053         elif z is I*S.Infinity:\n2054             return cls._sign*I*S.Half\n2055 \n2056     def fdiff(self, argindex=1):\n2057         if argindex == 1:\n2058             return self._trigfunc(S.Half*pi*self.args[0]**2)\n2059         else:\n2060             raise ArgumentIndexError(self, argindex)\n2061 \n2062     def _eval_is_real(self):\n2063         return self.args[0].is_real\n2064 \n2065     def _eval_conjugate(self):\n2066         return self.func(self.args[0].conjugate())\n2067 \n2068     def _as_real_imag(self, deep=True, **hints):\n2069         if self.args[0].is_real:\n2070             if deep:\n2071                 hints['complex'] = False\n2072                 return (self.expand(deep, **hints), S.Zero)\n2073             else:\n2074                 return (self, S.Zero)\n2075         if deep:\n2076             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n2077         else:\n2078             re, im = self.args[0].as_real_imag()\n2079         return (re, im)\n2080 \n2081     def as_real_imag(self, deep=True, **hints):\n2082         # Fresnel S\n2083         # http://functions.wolfram.com/06.32.19.0003.01\n2084         # http://functions.wolfram.com/06.32.19.0006.01\n2085         # Fresnel C\n2086         # http://functions.wolfram.com/06.33.19.0003.01\n2087         # http://functions.wolfram.com/06.33.19.0006.01\n2088         x, y = self._as_real_imag(deep=deep, **hints)\n2089         sq = -y**2/x**2\n2090         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n2091         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n2092                 self.func(x + x*sqrt(sq)))\n2093         return (re, im)\n2094 \n2095 \n2096 class fresnels(FresnelIntegral):\n2097     r\"\"\"\n2098     Fresnel integral S.\n2099 \n2100     This function is defined by\n2101 \n2102     .. math:: \\operatorname{S}(z) = \\int_0^z \\sin{\\frac{\\pi}{2} t^2} \\mathrm{d}t.\n2103 \n2104     It is an entire function.\n2105 \n2106     Examples\n2107     ========\n2108 \n2109     >>> from sympy import I, oo, fresnels\n2110     >>> from sympy.abc import z\n2111 \n2112     Several special values are known:\n2113 \n2114     >>> fresnels(0)\n2115     0\n2116     >>> fresnels(oo)\n2117     1/2\n2118     >>> fresnels(-oo)\n2119     -1/2\n2120     >>> fresnels(I*oo)\n2121     -I/2\n2122     >>> fresnels(-I*oo)\n2123     I/2\n2124 \n2125     In general one can pull out factors of -1 and `i` from the argument:\n2126 \n2127     >>> fresnels(-z)\n2128     -fresnels(z)\n2129     >>> fresnels(I*z)\n2130     -I*fresnels(z)\n2131 \n2132     The Fresnel S integral obeys the mirror symmetry\n2133     `\\overline{S(z)} = S(\\bar{z})`:\n2134 \n2135     >>> from sympy import conjugate\n2136     >>> conjugate(fresnels(z))\n2137     fresnels(conjugate(z))\n2138 \n2139     Differentiation with respect to `z` is supported:\n2140 \n2141     >>> from sympy import diff\n2142     >>> diff(fresnels(z), z)\n2143     sin(pi*z**2/2)\n2144 \n2145     Defining the Fresnel functions via an integral\n2146 \n2147     >>> from sympy import integrate, pi, sin, gamma, expand_func\n2148     >>> integrate(sin(pi*z**2/2), z)\n2149     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))\n2150     >>> expand_func(integrate(sin(pi*z**2/2), z))\n2151     fresnels(z)\n2152 \n2153     We can numerically evaluate the Fresnel integral to arbitrary precision\n2154     on the whole complex plane:\n2155 \n2156     >>> fresnels(2).evalf(30)\n2157     0.343415678363698242195300815958\n2158 \n2159     >>> fresnels(-2*I).evalf(30)\n2160     0.343415678363698242195300815958*I\n2161 \n2162     See Also\n2163     ========\n2164 \n2165     fresnelc: Fresnel cosine integral.\n2166 \n2167     References\n2168     ==========\n2169 \n2170     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral\n2171     .. [2] http://dlmf.nist.gov/7\n2172     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html\n2173     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS\n2174     .. [5] The converging factors for the fresnel integrals\n2175             by John W. Wrench Jr. and Vicki Alley\n2176 \n2177     \"\"\"\n2178     _trigfunc = sin\n2179     _sign = -S.One\n2180 \n2181     @staticmethod\n2182     @cacheit\n2183     def taylor_term(n, x, *previous_terms):\n2184         if n < 0:\n2185             return S.Zero\n2186         else:\n2187             x = sympify(x)\n2188             if len(previous_terms) > 1:\n2189                 p = previous_terms[-1]\n2190                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p\n2191             else:\n2192                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))\n2193 \n2194     def _eval_rewrite_as_erf(self, z):\n2195         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))\n2196 \n2197     def _eval_rewrite_as_hyper(self, z):\n2198         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)\n2199 \n2200     def _eval_rewrite_as_meijerg(self, z):\n2201         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))\n2202                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))\n2203 \n2204     def _eval_aseries(self, n, args0, x, logx):\n2205         from sympy import Order\n2206         point = args0[0]\n2207 \n2208         # Expansion at oo\n2209         if point is S.Infinity:\n2210             z = self.args[0]\n2211 \n2212             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8\n2213             p = [(-1)**k * factorial(4*k + 1) /\n2214                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))\n2215                  for k in range(0, n)]\n2216             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /\n2217                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))\n2218                  for k in range(1, n)]\n2219 \n2220             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]\n2221             q = [-sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]\n2222 \n2223             return S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)\n2224 \n2225         # All other points are not handled\n2226         return super(fresnels, self)._eval_aseries(n, args0, x, logx)\n2227 \n2228 \n2229 class fresnelc(FresnelIntegral):\n2230     r\"\"\"\n2231     Fresnel integral C.\n2232 \n2233     This function is defined by\n2234 \n2235     .. math:: \\operatorname{C}(z) = \\int_0^z \\cos{\\frac{\\pi}{2} t^2} \\mathrm{d}t.\n2236 \n2237     It is an entire function.\n2238 \n2239     Examples\n2240     ========\n2241 \n2242     >>> from sympy import I, oo, fresnelc\n2243     >>> from sympy.abc import z\n2244 \n2245     Several special values are known:\n2246 \n2247     >>> fresnelc(0)\n2248     0\n2249     >>> fresnelc(oo)\n2250     1/2\n2251     >>> fresnelc(-oo)\n2252     -1/2\n2253     >>> fresnelc(I*oo)\n2254     I/2\n2255     >>> fresnelc(-I*oo)\n2256     -I/2\n2257 \n2258     In general one can pull out factors of -1 and `i` from the argument:\n2259 \n2260     >>> fresnelc(-z)\n2261     -fresnelc(z)\n2262     >>> fresnelc(I*z)\n2263     I*fresnelc(z)\n2264 \n2265     The Fresnel C integral obeys the mirror symmetry\n2266     `\\overline{C(z)} = C(\\bar{z})`:\n2267 \n2268     >>> from sympy import conjugate\n2269     >>> conjugate(fresnelc(z))\n2270     fresnelc(conjugate(z))\n2271 \n2272     Differentiation with respect to `z` is supported:\n2273 \n2274     >>> from sympy import diff\n2275     >>> diff(fresnelc(z), z)\n2276     cos(pi*z**2/2)\n2277 \n2278     Defining the Fresnel functions via an integral\n2279 \n2280     >>> from sympy import integrate, pi, cos, gamma, expand_func\n2281     >>> integrate(cos(pi*z**2/2), z)\n2282     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))\n2283     >>> expand_func(integrate(cos(pi*z**2/2), z))\n2284     fresnelc(z)\n2285 \n2286     We can numerically evaluate the Fresnel integral to arbitrary precision\n2287     on the whole complex plane:\n2288 \n2289     >>> fresnelc(2).evalf(30)\n2290     0.488253406075340754500223503357\n2291 \n2292     >>> fresnelc(-2*I).evalf(30)\n2293     -0.488253406075340754500223503357*I\n2294 \n2295     See Also\n2296     ========\n2297 \n2298     fresnels: Fresnel sine integral.\n2299 \n2300     References\n2301     ==========\n2302 \n2303     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral\n2304     .. [2] http://dlmf.nist.gov/7\n2305     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html\n2306     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC\n2307     .. [5] The converging factors for the fresnel integrals\n2308             by John W. Wrench Jr. and Vicki Alley\n2309     \"\"\"\n2310     _trigfunc = cos\n2311     _sign = S.One\n2312 \n2313     @staticmethod\n2314     @cacheit\n2315     def taylor_term(n, x, *previous_terms):\n2316         if n < 0:\n2317             return S.Zero\n2318         else:\n2319             x = sympify(x)\n2320             if len(previous_terms) > 1:\n2321                 p = previous_terms[-1]\n2322                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p\n2323             else:\n2324                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))\n2325 \n2326     def _eval_rewrite_as_erf(self, z):\n2327         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))\n2328 \n2329     def _eval_rewrite_as_hyper(self, z):\n2330         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)\n2331 \n2332     def _eval_rewrite_as_meijerg(self, z):\n2333         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))\n2334                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))\n2335 \n2336     def _eval_aseries(self, n, args0, x, logx):\n2337         from sympy import Order\n2338         point = args0[0]\n2339 \n2340         # Expansion at oo\n2341         if point is S.Infinity:\n2342             z = self.args[0]\n2343 \n2344             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8\n2345             p = [(-1)**k * factorial(4*k + 1) /\n2346                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))\n2347                  for k in range(0, n)]\n2348             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /\n2349                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))\n2350                  for k in range(1, n)]\n2351 \n2352             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]\n2353             q = [ sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]\n2354 \n2355             return S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)\n2356 \n2357         # All other points are not handled\n2358         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)\n2359 \n2360 \n2361 ###############################################################################\n2362 #################### HELPER FUNCTIONS #########################################\n2363 ###############################################################################\n2364 \n2365 \n2366 class _erfs(Function):\n2367     \"\"\"\n2368     Helper function to make the `\\\\mathrm{erf}(z)` function\n2369     tractable for the Gruntz algorithm.\n2370     \"\"\"\n2371 \n2372 \n2373     def _eval_aseries(self, n, args0, x, logx):\n2374         from sympy import Order\n2375         point = args0[0]\n2376 \n2377         # Expansion at oo\n2378         if point is S.Infinity:\n2379             z = self.args[0]\n2380             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(\n2381                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]\n2382             o = Order(1/z**(2*n + 1), x)\n2383             # It is very inefficient to first add the order and then do the nseries\n2384             return (Add(*l))._eval_nseries(x, n, logx) + o\n2385 \n2386         # Expansion at I*oo\n2387         t = point.extract_multiplicatively(S.ImaginaryUnit)\n2388         if t is S.Infinity:\n2389             z = self.args[0]\n2390             # TODO: is the series really correct?\n2391             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(\n2392                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]\n2393             o = Order(1/z**(2*n + 1), x)\n2394             # It is very inefficient to first add the order and then do the nseries\n2395             return (Add(*l))._eval_nseries(x, n, logx) + o\n2396 \n2397         # All other points are not handled\n2398         return super(_erfs, self)._eval_aseries(n, args0, x, logx)\n2399 \n2400     def fdiff(self, argindex=1):\n2401         if argindex == 1:\n2402             z = self.args[0]\n2403             return -2/sqrt(S.Pi) + 2*z*_erfs(z)\n2404         else:\n2405             raise ArgumentIndexError(self, argindex)\n2406 \n2407     def _eval_rewrite_as_intractable(self, z):\n2408         return (S.One - erf(z))*exp(z**2)\n2409 \n2410 \n2411 class _eis(Function):\n2412     \"\"\"\n2413     Helper function to make the `\\\\mathrm{Ei}(z)` and `\\\\mathrm{li}(z)` functions\n2414     tractable for the Gruntz algorithm.\n2415     \"\"\"\n2416 \n2417 \n2418     def _eval_aseries(self, n, args0, x, logx):\n2419         from sympy import Order\n2420         if args0[0] != S.Infinity:\n2421             return super(_erfs, self)._eval_aseries(n, args0, x, logx)\n2422 \n2423         z = self.args[0]\n2424         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]\n2425         o = Order(1/z**(n + 1), x)\n2426         # It is very inefficient to first add the order and then do the nseries\n2427         return (Add(*l))._eval_nseries(x, n, logx) + o\n2428 \n2429 \n2430     def fdiff(self, argindex=1):\n2431         if argindex == 1:\n2432             z = self.args[0]\n2433             return S.One / z - _eis(z)\n2434         else:\n2435             raise ArgumentIndexError(self, argindex)\n2436 \n2437     def _eval_rewrite_as_intractable(self, z):\n2438         return exp(-z)*Ei(z)\n2439 \n2440     def _eval_nseries(self, x, n, logx):\n2441         x0 = self.args[0].limit(x, 0)\n2442         if x0 is S.Zero:\n2443             f = self._eval_rewrite_as_intractable(*self.args)\n2444             return f._eval_nseries(x, n, logx)\n2445         return super(_eis, self)._eval_nseries(x, n, logx)\n",
        "intended_behavior": "Each of these methods should ensure the operations involving error functions and related special functions are executed in line with established mathematical definitions and transformations. Reversions or corrections might be needed to align the implementations with the intended mathematical behaviors, specifically reverting to functionality before the modifications introduced in SymPy 1.0."
    },
    {
        "rel_file_path": "sympy/integrals/integrals.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/integrals/integrals.py",
        "start": 1,
        "end": 1347,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.concrete.expr_with_limits import AddWithLimits\n4 from sympy.core.add import Add\n5 from sympy.core.basic import Basic\n6 from sympy.core.compatibility import is_sequence, range\n7 from sympy.core.containers import Tuple\n8 from sympy.core.expr import Expr\n9 from sympy.core.function import diff\n10 from sympy.core.mul import Mul\n11 from sympy.core.numbers import oo\n12 from sympy.core.relational import Eq\n13 from sympy.core.singleton import S\n14 from sympy.core.symbol import (Dummy, Symbol, Wild)\n15 from sympy.core.sympify import sympify\n16 from sympy.integrals.manualintegrate import manualintegrate\n17 from sympy.integrals.trigonometry import trigintegrate\n18 from sympy.integrals.meijerint import meijerint_definite, meijerint_indefinite\n19 from sympy.matrices import MatrixBase\n20 from sympy.utilities.misc import filldedent\n21 from sympy.polys import Poly, PolynomialError\n22 from sympy.functions import Piecewise, sqrt, sign\n23 from sympy.functions.elementary.exponential import log\n24 from sympy.series import limit\n25 from sympy.series.order import Order\n26 \n27 \n28 class Integral(AddWithLimits):\n29     \"\"\"Represents unevaluated integral.\"\"\"\n30 \n31     __slots__ = ['is_commutative']\n32 \n33     def __new__(cls, function, *symbols, **assumptions):\n34         \"\"\"Create an unevaluated integral.\n35 \n36         Arguments are an integrand followed by one or more limits.\n37 \n38         If no limits are given and there is only one free symbol in the\n39         expression, that symbol will be used, otherwise an error will be\n40         raised.\n41 \n42         >>> from sympy import Integral\n43         >>> from sympy.abc import x, y\n44         >>> Integral(x)\n45         Integral(x, x)\n46         >>> Integral(y)\n47         Integral(y, y)\n48 \n49         When limits are provided, they are interpreted as follows (using\n50         ``x`` as though it were the variable of integration):\n51 \n52             (x,) or x - indefinite integral\n53             (x, a) - \"evaluate at\" integral is an abstract antiderivative\n54             (x, a, b) - definite integral\n55 \n56         The ``as_dummy`` method can be used to see which symbols cannot be\n57         targeted by subs: those with a preppended underscore cannot be\n58         changed with ``subs``. (Also, the integration variables themselves --\n59         the first element of a limit -- can never be changed by subs.)\n60 \n61         >>> i = Integral(x, x)\n62         >>> at = Integral(x, (x, x))\n63         >>> i.as_dummy()\n64         Integral(x, x)\n65         >>> at.as_dummy()\n66         Integral(_x, (_x, x))\n67 \n68         \"\"\"\n69 \n70         #This will help other classes define their own definitions\n71         #of behaviour with Integral.\n72         if hasattr(function, '_eval_Integral'):\n73             return function._eval_Integral(*symbols, **assumptions)\n74 \n75         obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)\n76         return obj\n77 \n78     def __getnewargs__(self):\n79         return (self.function,) + tuple([tuple(xab) for xab in self.limits])\n80 \n81     @property\n82     def free_symbols(self):\n83         \"\"\"\n84         This method returns the symbols that will exist when the\n85         integral is evaluated. This is useful if one is trying to\n86         determine whether an integral depends on a certain\n87         symbol or not.\n88 \n89         Examples\n90         ========\n91 \n92         >>> from sympy import Integral\n93         >>> from sympy.abc import x, y\n94         >>> Integral(x, (x, y, 1)).free_symbols\n95         {y}\n96 \n97         See Also\n98         ========\n99 \n100         function, limits, variables\n101         \"\"\"\n102         return AddWithLimits.free_symbols.fget(self)\n103 \n104     def _eval_is_zero(self):\n105         # This is a very naive and quick test, not intended to do the integral to\n106         # answer whether it is zero or not, e.g. Integral(sin(x), (x, 0, 2*pi))\n107         # is zero but this routine should return None for that case. But, like\n108         # Mul, there are trivial situations for which the integral will be\n109         # zero so we check for those.\n110         if self.function.is_zero:\n111             return True\n112         got_none = False\n113         for l in self.limits:\n114             if len(l) == 3:\n115                 z = (l[1] == l[2]) or (l[1] - l[2]).is_zero\n116                 if z:\n117                     return True\n118                 elif z is None:\n119                     got_none = True\n120         free = self.function.free_symbols\n121         for xab in self.limits:\n122             if len(xab) == 1:\n123                 free.add(xab[0])\n124                 continue\n125             if len(xab) == 2 and xab[0] not in free:\n126                 if xab[1].is_zero:\n127                     return True\n128                 elif xab[1].is_zero is None:\n129                     got_none = True\n130             # take integration symbol out of free since it will be replaced\n131             # with the free symbols in the limits\n132             free.discard(xab[0])\n133             # add in the new symbols\n134             for i in xab[1:]:\n135                 free.update(i.free_symbols)\n136         if self.function.is_zero is False and got_none is False:\n137             return False\n138 \n139     def transform(self, x, u):\n140         r\"\"\"\n141         Performs a change of variables from `x` to `u` using the relationship\n142         given by `x` and `u` which will define the transformations `f` and `F`\n143         (which are inverses of each other) as follows:\n144 \n145         1) If `x` is a Symbol (which is a variable of integration) then `u`\n146            will be interpreted as some function, f(u), with inverse F(u).\n147            This, in effect, just makes the substitution of x with f(x).\n148 \n149         2) If `u` is a Symbol then `x` will be interpreted as some function,\n150            F(x), with inverse f(u). This is commonly referred to as\n151            u-substitution.\n152 \n153         Once f and F have been identified, the transformation is made as\n154         follows:\n155 \n156         .. math:: \\int_a^b x \\mathrm{d}x \\rightarrow \\int_{F(a)}^{F(b)} f(x)\n157                   \\frac{\\mathrm{d}}{\\mathrm{d}x}\n158 \n159         where `F(x)` is the inverse of `f(x)` and the limits and integrand have\n160         been corrected so as to retain the same value after integration.\n161 \n162         Notes\n163         =====\n164 \n165         The mappings, F(x) or f(u), must lead to a unique integral. Linear\n166         or rational linear expression, `2*x`, `1/x` and `sqrt(x)`, will\n167         always work; quadratic expressions like `x**2 - 1` are acceptable\n168         as long as the resulting integrand does not depend on the sign of\n169         the solutions (see examples).\n170 \n171         The integral will be returned unchanged if `x` is not a variable of\n172         integration.\n173 \n174         `x` must be (or contain) only one of of the integration variables. If\n175         `u` has more than one free symbol then it should be sent as a tuple\n176         (`u`, `uvar`) where `uvar` identifies which variable is replacing\n177         the integration variable.\n178         XXX can it contain another integration variable?\n179 \n180         Examples\n181         ========\n182 \n183         >>> from sympy.abc import a, b, c, d, x, u, y\n184         >>> from sympy import Integral, S, cos, sqrt\n185 \n186         >>> i = Integral(x*cos(x**2 - 1), (x, 0, 1))\n187 \n188         transform can change the variable of integration\n189 \n190         >>> i.transform(x, u)\n191         Integral(u*cos(u**2 - 1), (u, 0, 1))\n192 \n193         transform can perform u-substitution as long as a unique\n194         integrand is obtained:\n195 \n196         >>> i.transform(x**2 - 1, u)\n197         Integral(cos(u)/2, (u, -1, 0))\n198 \n199         This attempt fails because x = +/-sqrt(u + 1) and the\n200         sign does not cancel out of the integrand:\n201 \n202         >>> Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)\n203         Traceback (most recent call last):\n204         ...\n205         ValueError:\n206         The mapping between F(x) and f(u) did not give a unique integrand.\n207 \n208         transform can do a substitution. Here, the previous\n209         result is transformed back into the original expression\n210         using \"u-substitution\":\n211 \n212         >>> ui = _\n213         >>> _.transform(sqrt(u + 1), x) == i\n214         True\n215 \n216         We can accomplish the same with a regular substitution:\n217 \n218         >>> ui.transform(u, x**2 - 1) == i\n219         True\n220 \n221         If the `x` does not contain a symbol of integration then\n222         the integral will be returned unchanged. Integral `i` does\n223         not have an integration variable `a` so no change is made:\n224 \n225         >>> i.transform(a, x) == i\n226         True\n227 \n228         When `u` has more than one free symbol the symbol that is\n229         replacing `x` must be identified by passing `u` as a tuple:\n230 \n231         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, u))\n232         Integral(a + u, (u, -a, -a + 1))\n233         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, a))\n234         Integral(a + u, (a, -u, -u + 1))\n235 \n236         See Also\n237         ========\n238 \n239         variables : Lists the integration variables\n240         as_dummy : Replace integration variables with dummy ones\n241         \"\"\"\n242         from sympy.solvers.solvers import solve, posify\n243         d = Dummy('d')\n244 \n245         xfree = x.free_symbols.intersection(self.variables)\n246         if len(xfree) > 1:\n247             raise ValueError(\n248                 'F(x) can only contain one of: %s' % self.variables)\n249         xvar = xfree.pop() if xfree else d\n250 \n251         if xvar not in self.variables:\n252             return self\n253 \n254         u = sympify(u)\n255         if isinstance(u, Expr):\n256             ufree = u.free_symbols\n257             if len(ufree) != 1:\n258                 raise ValueError(filldedent('''\n259                 When f(u) has more than one free symbol, the one replacing x\n260                 must be identified: pass f(u) as (f(u), u)'''))\n261             uvar = ufree.pop()\n262         else:\n263             u, uvar = u\n264             if uvar not in u.free_symbols:\n265                 raise ValueError(filldedent('''\n266                 Expecting a tuple (expr, symbol) where symbol identified\n267                 a free symbol in expr, but symbol is not in expr's free\n268                 symbols.'''))\n269             if not isinstance(uvar, Symbol):\n270                 raise ValueError(filldedent('''\n271                 Expecting a tuple (expr, symbol) but didn't get\n272                 a symbol; got %s''' % uvar))\n273 \n274         if x.is_Symbol and u.is_Symbol:\n275             return self.xreplace({x: u})\n276 \n277         if not x.is_Symbol and not u.is_Symbol:\n278             raise ValueError('either x or u must be a symbol')\n279 \n280         if uvar == xvar:\n281             return self.transform(x, (u.subs(uvar, d), d)).xreplace({d: uvar})\n282 \n283         if uvar in self.limits:\n284             raise ValueError(filldedent('''\n285             u must contain the same variable as in x\n286             or a variable that is not already an integration variable'''))\n287 \n288         if not x.is_Symbol:\n289             F = [x.subs(xvar, d)]\n290             soln = solve(u - x, xvar, check=False)\n291             if not soln:\n292                 raise ValueError('no solution for solve(F(x) - f(u), x)')\n293             f = [fi.subs(uvar, d) for fi in soln]\n294         else:\n295             f = [u.subs(uvar, d)]\n296             pdiff, reps = posify(u - x)\n297             puvar = uvar.subs([(v, k) for k, v in reps.items()])\n298             soln = [s.subs(reps) for s in solve(pdiff, puvar)]\n299             if not soln:\n300                 raise ValueError('no solution for solve(F(x) - f(u), u)')\n301             F = [fi.subs(xvar, d) for fi in soln]\n302 \n303         newfuncs = set([(self.function.subs(xvar, fi)*fi.diff(d)\n304                         ).subs(d, uvar) for fi in f])\n305         if len(newfuncs) > 1:\n306             raise ValueError(filldedent('''\n307             The mapping between F(x) and f(u) did not give\n308             a unique integrand.'''))\n309         newfunc = newfuncs.pop()\n310 \n311         def _calc_limit_1(F, a, b):\n312             \"\"\"\n313             replace d with a, using subs if possible, otherwise limit\n314             where sign of b is considered\n315             \"\"\"\n316             wok = F.subs(d, a)\n317             if wok is S.NaN or wok.is_finite is False and a.is_finite:\n318                 return limit(sign(b)*F, d, a)\n319             return wok\n320 \n321         def _calc_limit(a, b):\n322             \"\"\"\n323             replace d with a, using subs if possible, otherwise limit\n324             where sign of b is considered\n325             \"\"\"\n326             avals = list({_calc_limit_1(Fi, a, b) for Fi in F})\n327             if len(avals) > 1:\n328                 raise ValueError(filldedent('''\n329                 The mapping between F(x) and f(u) did not\n330                 give a unique limit.'''))\n331             return avals[0]\n332 \n333         newlimits = []\n334         for xab in self.limits:\n335             sym = xab[0]\n336             if sym == xvar:\n337                 if len(xab) == 3:\n338                     a, b = xab[1:]\n339                     a, b = _calc_limit(a, b), _calc_limit(b, a)\n340                     if a - b > 0:\n341                         a, b = b, a\n342                         newfunc = -newfunc\n343                     newlimits.append((uvar, a, b))\n344                 elif len(xab) == 2:\n345                     a = _calc_limit(xab[1], 1)\n346                     newlimits.append((uvar, a))\n347                 else:\n348                     newlimits.append(uvar)\n349             else:\n350                 newlimits.append(xab)\n351 \n352         return self.func(newfunc, *newlimits)\n353 \n354     def doit(self, **hints):\n355         \"\"\"\n356         Perform the integration using any hints given.\n357 \n358         Examples\n359         ========\n360 \n361         >>> from sympy import Integral\n362         >>> from sympy.abc import x, i\n363         >>> Integral(x**i, (i, 1, 3)).doit()\n364         Piecewise((2, Eq(log(x), 0)), (x**3/log(x) - x/log(x), True))\n365 \n366         See Also\n367         ========\n368 \n369         sympy.integrals.trigonometry.trigintegrate\n370         sympy.integrals.risch.heurisch\n371         sympy.integrals.rationaltools.ratint\n372         as_sum : Approximate the integral using a sum\n373         \"\"\"\n374         if not hints.get('integrals', True):\n375             return self\n376 \n377         deep = hints.get('deep', True)\n378         meijerg = hints.get('meijerg', None)\n379         conds = hints.get('conds', 'piecewise')\n380         risch = hints.get('risch', None)\n381         manual = hints.get('manual', None)\n382 \n383         if conds not in ['separate', 'piecewise', 'none']:\n384             raise ValueError('conds must be one of \"separate\", \"piecewise\", '\n385                              '\"none\", got: %s' % conds)\n386 \n387         if risch and any(len(xab) > 1 for xab in self.limits):\n388             raise ValueError('risch=True is only allowed for indefinite integrals.')\n389 \n390         # check for the trivial zero\n391         if self.is_zero:\n392             return S.Zero\n393 \n394         # now compute and check the function\n395         function = self.function\n396         if deep:\n397             function = function.doit(**hints)\n398         if function.is_zero:\n399             return S.Zero\n400 \n401         if isinstance(function, MatrixBase):\n402             return function.applyfunc(lambda f: self.func(f, self.limits).doit(**hints))\n403 \n404         # There is no trivial answer, so continue\n405 \n406         undone_limits = []\n407         # ulj = free symbols of any undone limits' upper and lower limits\n408         ulj = set()\n409         for xab in self.limits:\n410             # compute uli, the free symbols in the\n411             # Upper and Lower limits of limit I\n412             if len(xab) == 1:\n413                 uli = set(xab[:1])\n414             elif len(xab) == 2:\n415                 uli = xab[1].free_symbols\n416             elif len(xab) == 3:\n417                 uli = xab[1].free_symbols.union(xab[2].free_symbols)\n418             # this integral can be done as long as there is no blocking\n419             # limit that has been undone. An undone limit is blocking if\n420             # it contains an integration variable that is in this limit's\n421             # upper or lower free symbols or vice versa\n422             if xab[0] in ulj or any(v[0] in uli for v in undone_limits):\n423                 undone_limits.append(xab)\n424                 ulj.update(uli)\n425                 function = self.func(*([function] + [xab]))\n426                 factored_function = function.factor()\n427                 if not isinstance(factored_function, Integral):\n428                     function = factored_function\n429                 continue\n430 \n431             # There are a number of tradeoffs in using the Meijer G method.\n432             # It can sometimes be a lot faster than other methods, and\n433             # sometimes slower. And there are certain types of integrals for\n434             # which it is more likely to work than others.\n435             # These heuristics are incorporated in deciding what integration\n436             # methods to try, in what order.\n437             # See the integrate() docstring for details.\n438             def try_meijerg(function, xab):\n439                 ret = None\n440                 if len(xab) == 3 and meijerg is not False:\n441                     x, a, b = xab\n442                     try:\n443                         res = meijerint_definite(function, x, a, b)\n444                     except NotImplementedError:\n445                         from sympy.integrals.meijerint import _debug\n446                         _debug('NotImplementedError from meijerint_definite')\n447                         res = None\n448                     if res is not None:\n449                         f, cond = res\n450                         if conds == 'piecewise':\n451                             ret = Piecewise((f, cond),\n452                                           (self.func(function, (x, a, b)), True))\n453                         elif conds == 'separate':\n454                             if len(self.limits) != 1:\n455                                 raise ValueError('conds=separate not supported in '\n456                                                  'multiple integrals')\n457                             ret = f, cond\n458                         else:\n459                             ret = f\n460                 return ret\n461 \n462             meijerg1 = meijerg\n463             if len(xab) == 3 and xab[1].is_real and xab[2].is_real \\\n464                 and not function.is_Poly and \\\n465                     (xab[1].has(oo, -oo) or xab[2].has(oo, -oo)):\n466                 ret = try_meijerg(function, xab)\n467                 if ret is not None:\n468                     function = ret\n469                     continue\n470                 else:\n471                     meijerg1 = False\n472 \n473             # If the special meijerg code did not succeed in finding a definite\n474             # integral, then the code using meijerint_indefinite will not either\n475             # (it might find an antiderivative, but the answer is likely to be\n476             #  nonsensical).\n477             # Thus if we are requested to only use Meijer G-function methods,\n478             # we give up at this stage. Otherwise we just disable G-function\n479             # methods.\n480             if meijerg1 is False and meijerg is True:\n481                 antideriv = None\n482             else:\n483                 antideriv = self._eval_integral(\n484                     function, xab[0],\n485                     meijerg=meijerg1, risch=risch, manual=manual,\n486                     conds=conds)\n487                 if antideriv is None and meijerg1 is True:\n488                     ret = try_meijerg(function, xab)\n489                     if ret is not None:\n490                         function = ret\n491                         continue\n492 \n493             if antideriv is None:\n494                 undone_limits.append(xab)\n495                 function = self.func(*([function] + [xab])).factor()\n496                 factored_function = function.factor()\n497                 if not isinstance(factored_function, Integral):\n498                     function = factored_function\n499                 continue\n500             else:\n501                 if len(xab) == 1:\n502                     function = antideriv\n503                 else:\n504                     if len(xab) == 3:\n505                         x, a, b = xab\n506                     elif len(xab) == 2:\n507                         x, b = xab\n508                         a = None\n509                     else:\n510                         raise NotImplementedError\n511 \n512                     if deep:\n513                         if isinstance(a, Basic):\n514                             a = a.doit(**hints)\n515                         if isinstance(b, Basic):\n516                             b = b.doit(**hints)\n517 \n518                     if antideriv.is_Poly:\n519                         gens = list(antideriv.gens)\n520                         gens.remove(x)\n521 \n522                         antideriv = antideriv.as_expr()\n523 \n524                         function = antideriv._eval_interval(x, a, b)\n525                         function = Poly(function, *gens)\n526                     else:\n527                         def is_indef_int(g, x):\n528                             return (isinstance(g, Integral) and\n529                                     any(i == (x,) for i in g.limits))\n530 \n531                         def eval_factored(f, x, a, b):\n532                             # _eval_interval for integrals with\n533                             # (constant) factors\n534                             # a single indefinite integral is assumed\n535                             args = []\n536                             for g in Mul.make_args(f):\n537                                 if is_indef_int(g, x):\n538                                     args.append(g._eval_interval(x, a, b))\n539                                 else:\n540                                     args.append(g)\n541                             return Mul(*args)\n542 \n543                         integrals, others = [], []\n544                         for f in Add.make_args(antideriv):\n545                             if any(is_indef_int(g, x)\n546                                    for g in Mul.make_args(f)):\n547                                 integrals.append(f)\n548                             else:\n549                                 others.append(f)\n550                         uneval = Add(*[eval_factored(f, x, a, b)\n551                                        for f in integrals])\n552                         try:\n553                             evalued = Add(*others)._eval_interval(x, a, b)\n554                             function = uneval + evalued\n555                         except NotImplementedError:\n556                             # This can happen if _eval_interval depends in a\n557                             # complicated way on limits that cannot be computed\n558                             undone_limits.append(xab)\n559                             function = self.func(*([function] + [xab]))\n560                             factored_function = function.factor()\n561                             if not isinstance(factored_function, Integral):\n562                                 function = factored_function\n563         return function\n564 \n565     def _eval_derivative(self, sym):\n566         \"\"\"Evaluate the derivative of the current Integral object by\n567         differentiating under the integral sign [1], using the Fundamental\n568         Theorem of Calculus [2] when possible.\n569 \n570         Whenever an Integral is encountered that is equivalent to zero or\n571         has an integrand that is independent of the variable of integration\n572         those integrals are performed. All others are returned as Integral\n573         instances which can be resolved with doit() (provided they are integrable).\n574 \n575         References:\n576            [1] http://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign\n577            [2] http://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus\n578 \n579         Examples\n580         ========\n581 \n582         >>> from sympy import Integral\n583         >>> from sympy.abc import x, y\n584         >>> i = Integral(x + y, y, (y, 1, x))\n585         >>> i.diff(x)\n586         Integral(x + y, (y, x)) + Integral(1, y, (y, 1, x))\n587         >>> i.doit().diff(x) == i.diff(x).doit()\n588         True\n589         >>> i.diff(y)\n590         0\n591 \n592         The previous must be true since there is no y in the evaluated integral:\n593 \n594         >>> i.free_symbols\n595         {x}\n596         >>> i.doit()\n597         2*x**3/3 - x/2 - 1/6\n598 \n599         \"\"\"\n600 \n601         # differentiate under the integral sign; we do not\n602         # check for regularity conditions (TODO), see issue 4215\n603 \n604         # get limits and the function\n605         f, limits = self.function, list(self.limits)\n606 \n607         # the order matters if variables of integration appear in the limits\n608         # so work our way in from the outside to the inside.\n609         limit = limits.pop(-1)\n610         if len(limit) == 3:\n611             x, a, b = limit\n612         elif len(limit) == 2:\n613             x, b = limit\n614             a = None\n615         else:\n616             a = b = None\n617             x = limit[0]\n618 \n619         if limits:  # f is the argument to an integral\n620             f = self.func(f, *tuple(limits))\n621 \n622         # assemble the pieces\n623         def _do(f, ab):\n624             dab_dsym = diff(ab, sym)\n625             if not dab_dsym:\n626                 return S.Zero\n627             if isinstance(f, Integral):\n628                 limits = [(x, x) if (len(l) == 1 and l[0] == x) else l\n629                           for l in f.limits]\n630                 f = self.func(f.function, *limits)\n631             return f.subs(x, ab)*dab_dsym\n632         rv = 0\n633         if b is not None:\n634             rv += _do(f, b)\n635         if a is not None:\n636             rv -= _do(f, a)\n637         if len(limit) == 1 and sym == x:\n638             # the dummy variable *is* also the real-world variable\n639             arg = f\n640             rv += arg\n641         else:\n642             # the dummy variable might match sym but it's\n643             # only a dummy and the actual variable is determined\n644             # by the limits, so mask off the variable of integration\n645             # while differentiating\n646             u = Dummy('u')\n647             arg = f.subs(x, u).diff(sym).subs(u, x)\n648             rv += self.func(arg, Tuple(x, a, b))\n649         return rv\n650 \n651     def _eval_integral(self, f, x, meijerg=None, risch=None, manual=None,\n652                        conds='piecewise'):\n653         \"\"\"\n654         Calculate the anti-derivative to the function f(x).\n655 \n656         The following algorithms are applied (roughly in this order):\n657 \n658         1. Simple heuristics (based on pattern matching and integral table):\n659 \n660            - most frequently used functions (e.g. polynomials, products of trig functions)\n661 \n662         2. Integration of rational functions:\n663 \n664            - A complete algorithm for integrating rational functions is\n665              implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm\n666              also uses the partial fraction decomposition algorithm\n667              implemented in apart() as a preprocessor to make this process\n668              faster.  Note that the integral of a rational function is always\n669              elementary, but in general, it may include a RootSum.\n670 \n671         3. Full Risch algorithm:\n672 \n673            - The Risch algorithm is a complete decision\n674              procedure for integrating elementary functions, which means that\n675              given any elementary function, it will either compute an\n676              elementary antiderivative, or else prove that none exists.\n677              Currently, part of transcendental case is implemented, meaning\n678              elementary integrals containing exponentials, logarithms, and\n679              (soon!) trigonometric functions can be computed.  The algebraic\n680              case, e.g., functions containing roots, is much more difficult\n681              and is not implemented yet.\n682 \n683            - If the routine fails (because the integrand is not elementary, or\n684              because a case is not implemented yet), it continues on to the\n685              next algorithms below.  If the routine proves that the integrals\n686              is nonelementary, it still moves on to the algorithms below,\n687              because we might be able to find a closed-form solution in terms\n688              of special functions.  If risch=True, however, it will stop here.\n689 \n690         4. The Meijer G-Function algorithm:\n691 \n692            - This algorithm works by first rewriting the integrand in terms of\n693              very general Meijer G-Function (meijerg in SymPy), integrating\n694              it, and then rewriting the result back, if possible.  This\n695              algorithm is particularly powerful for definite integrals (which\n696              is actually part of a different method of Integral), since it can\n697              compute closed-form solutions of definite integrals even when no\n698              closed-form indefinite integral exists.  But it also is capable\n699              of computing many indefinite integrals as well.\n700 \n701            - Another advantage of this method is that it can use some results\n702              about the Meijer G-Function to give a result in terms of a\n703              Piecewise expression, which allows to express conditionally\n704              convergent integrals.\n705 \n706            - Setting meijerg=True will cause integrate() to use only this\n707              method.\n708 \n709         5. The \"manual integration\" algorithm:\n710 \n711            - This algorithm tries to mimic how a person would find an\n712              antiderivative by hand, for example by looking for a\n713              substitution or applying integration by parts. This algorithm\n714              does not handle as many integrands but can return results in a\n715              more familiar form.\n716 \n717            - Sometimes this algorithm can evaluate parts of an integral; in\n718              this case integrate() will try to evaluate the rest of the\n719              integrand using the other methods here.\n720 \n721            - Setting manual=True will cause integrate() to use only this\n722              method.\n723 \n724         6. The Heuristic Risch algorithm:\n725 \n726            - This is a heuristic version of the Risch algorithm, meaning that\n727              it is not deterministic.  This is tried as a last resort because\n728              it can be very slow.  It is still used because not enough of the\n729              full Risch algorithm is implemented, so that there are still some\n730              integrals that can only be computed using this method.  The goal\n731              is to implement enough of the Risch and Meijer G-function methods\n732              so that this can be deleted.\n733 \n734         \"\"\"\n735         from sympy.integrals.deltafunctions import deltaintegrate\n736         from sympy.integrals.singularityfunctions import singularityintegrate\n737         from sympy.integrals.heurisch import heurisch, heurisch_wrapper\n738         from sympy.integrals.rationaltools import ratint\n739         from sympy.integrals.risch import risch_integrate\n740 \n741         if risch:\n742             try:\n743                 return risch_integrate(f, x, conds=conds)\n744             except NotImplementedError:\n745                 return None\n746 \n747         if manual:\n748             try:\n749                 result = manualintegrate(f, x)\n750                 if result is not None and result.func != Integral:\n751                     return result\n752             except (ValueError, PolynomialError):\n753                 pass\n754 \n755 \n756         # if it is a poly(x) then let the polynomial integrate itself (fast)\n757         #\n758         # It is important to make this check first, otherwise the other code\n759         # will return a sympy expression instead of a Polynomial.\n760         #\n761         # see Polynomial for details.\n762         if isinstance(f, Poly) and not meijerg:\n763             return f.integrate(x)\n764 \n765         # Piecewise antiderivatives need to call special integrate.\n766         if f.func is Piecewise:\n767             return f._eval_integral(x)\n768 \n769         # let's cut it short if `f` does not depend on `x`\n770         if not f.has(x):\n771             return f*x\n772 \n773         # try to convert to poly(x) and then integrate if successful (fast)\n774         poly = f.as_poly(x)\n775         if poly is not None and not meijerg:\n776             return poly.integrate().as_expr()\n777 \n778         if risch is not False:\n779             try:\n780                 result, i = risch_integrate(f, x, separate_integral=True, conds=conds)\n781             except NotImplementedError:\n782                 pass\n783             else:\n784                 if i:\n785                     # There was a nonelementary integral. Try integrating it.\n786                     return result + i.doit(risch=False)\n787                 else:\n788                     return result\n789 \n790         # since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...\n791         # we are going to handle Add terms separately,\n792         # if `f` is not Add -- we only have one term\n793 \n794         # Note that in general, this is a bad idea, because Integral(g1) +\n795         # Integral(g2) might not be computable, even if Integral(g1 + g2) is.\n796         # For example, Integral(x**x + x**x*log(x)).  But many heuristics only\n797         # work term-wise.  So we compute this step last, after trying\n798         # risch_integrate.  We also try risch_integrate again in this loop,\n799         # because maybe the integral is a sum of an elementary part and a\n800         # nonelementary part (like erf(x) + exp(x)).  risch_integrate() is\n801         # quite fast, so this is acceptable.\n802         parts = []\n803         args = Add.make_args(f)\n804         for g in args:\n805             coeff, g = g.as_independent(x)\n806 \n807             # g(x) = const\n808             if g is S.One and not meijerg:\n809                 parts.append(coeff*x)\n810                 continue\n811 \n812             # g(x) = expr + O(x**n)\n813             order_term = g.getO()\n814 \n815             if order_term is not None:\n816                 h = self._eval_integral(g.removeO(), x)\n817 \n818                 if h is not None:\n819                     h_order_expr = self._eval_integral(order_term.expr, x)\n820 \n821                     if h_order_expr is not None:\n822                         h_order_term = order_term.func(\n823                             h_order_expr, *order_term.variables)\n824                         parts.append(coeff*(h + h_order_term))\n825                         continue\n826 \n827                 # NOTE: if there is O(x**n) and we fail to integrate then there is\n828                 # no point in trying other methods because they will fail anyway.\n829                 return None\n830 \n831             #               c\n832             # g(x) = (a*x+b)\n833             if g.is_Pow and not g.exp.has(x) and not meijerg:\n834                 a = Wild('a', exclude=[x])\n835                 b = Wild('b', exclude=[x])\n836 \n837                 M = g.base.match(a*x + b)\n838 \n839                 if M is not None:\n840                     if g.exp == -1:\n841                         h = log(g.base)\n842                     elif conds != 'piecewise':\n843                         h = g.base**(g.exp + 1) / (g.exp + 1)\n844                     else:\n845                         h1 = log(g.base)\n846                         h2 = g.base**(g.exp + 1) / (g.exp + 1)\n847                         h = Piecewise((h1, Eq(g.exp, -1)), (h2, True))\n848 \n849                     parts.append(coeff * h / M[a])\n850                     continue\n851 \n852             #        poly(x)\n853             # g(x) = -------\n854             #        poly(x)\n855             if g.is_rational_function(x) and not meijerg:\n856                 parts.append(coeff * ratint(g, x))\n857                 continue\n858 \n859             if not meijerg:\n860                 # g(x) = Mul(trig)\n861                 h = trigintegrate(g, x, conds=conds)\n862                 if h is not None:\n863                     parts.append(coeff * h)\n864                     continue\n865 \n866                 # g(x) has at least a DiracDelta term\n867                 h = deltaintegrate(g, x)\n868                 if h is not None:\n869                     parts.append(coeff * h)\n870                     continue\n871 \n872                 # g(x) has at least a Singularity Function term\n873                 h = singularityintegrate(g, x)\n874                 if h is not None:\n875                     parts.append(coeff * h)\n876                     continue\n877 \n878                 # Try risch again.\n879                 if risch is not False:\n880                     try:\n881                         h, i = risch_integrate(g, x, separate_integral=True, conds=conds)\n882                     except NotImplementedError:\n883                         h = None\n884                     else:\n885                         if i:\n886                             h = h + i.doit(risch=False)\n887 \n888                         parts.append(coeff*h)\n889                         continue\n890 \n891                 # fall back to heurisch\n892                 try:\n893                     if conds == 'piecewise':\n894                         h = heurisch_wrapper(g, x, hints=[])\n895                     else:\n896                         h = heurisch(g, x, hints=[])\n897                 except PolynomialError:\n898                     # XXX: this exception means there is a bug in the\n899                     # implementation of heuristic Risch integration\n900                     # algorithm.\n901                     h = None\n902             else:\n903                 h = None\n904 \n905             if meijerg is not False and h is None:\n906                 # rewrite using G functions\n907                 try:\n908                     h = meijerint_indefinite(g, x)\n909                 except NotImplementedError:\n910                     from sympy.integrals.meijerint import _debug\n911                     _debug('NotImplementedError from meijerint_definite')\n912                     res = None\n913                 if h is not None:\n914                     parts.append(coeff * h)\n915                     continue\n916 \n917             if h is None and manual is not False:\n918                 try:\n919                     result = manualintegrate(g, x)\n920                     if result is not None and not isinstance(result, Integral):\n921                         if result.has(Integral):\n922                             # try to have other algorithms do the integrals\n923                             # manualintegrate can't handle\n924                             result = result.func(*[\n925                                 arg.doit(manual=False) if arg.has(Integral) else arg\n926                                 for arg in result.args\n927                             ]).expand(multinomial=False,\n928                                       log=False,\n929                                       power_exp=False,\n930                                       power_base=False)\n931                         if not result.has(Integral):\n932                             parts.append(coeff * result)\n933                             continue\n934                 except (ValueError, PolynomialError):\n935                     # can't handle some SymPy expressions\n936                     pass\n937 \n938             # if we failed maybe it was because we had\n939             # a product that could have been expanded,\n940             # so let's try an expansion of the whole\n941             # thing before giving up; we don't try this\n942             # at the outset because there are things\n943             # that cannot be solved unless they are\n944             # NOT expanded e.g., x**x*(1+log(x)). There\n945             # should probably be a checker somewhere in this\n946             # routine to look for such cases and try to do\n947             # collection on the expressions if they are already\n948             # in an expanded form\n949             if not h and len(args) == 1:\n950                 f = f.expand(mul=True, deep=False)\n951                 if f.is_Add:\n952                     # Note: risch will be identical on the expanded\n953                     # expression, but maybe it will be able to pick out parts,\n954                     # like x*(exp(x) + erf(x)).\n955                     return self._eval_integral(f, x, meijerg=meijerg, risch=risch, conds=conds)\n956 \n957             if h is not None:\n958                 parts.append(coeff * h)\n959             else:\n960                 return None\n961 \n962         return Add(*parts)\n963 \n964     def _eval_lseries(self, x, logx):\n965         expr = self.as_dummy()\n966         symb = x\n967         for l in expr.limits:\n968             if x in l[1:]:\n969                 symb = l[0]\n970                 break\n971         for term in expr.function.lseries(symb, logx):\n972             yield integrate(term, *expr.limits)\n973 \n974     def _eval_nseries(self, x, n, logx):\n975         expr = self.as_dummy()\n976         symb = x\n977         for l in expr.limits:\n978             if x in l[1:]:\n979                 symb = l[0]\n980                 break\n981         terms, order = expr.function.nseries(\n982             x=symb, n=n, logx=logx).as_coeff_add(Order)\n983         order = [o.subs(symb, x) for o in order]\n984         return integrate(terms, *expr.limits) + Add(*order)*x\n985 \n986     def _eval_as_leading_term(self, x):\n987         series_gen = self.args[0].lseries(x)\n988         for leading_term in series_gen:\n989             if leading_term != 0:\n990                 break\n991         return integrate(leading_term, *self.args[1:])\n992 \n993     def as_sum(self, n, method=\"midpoint\"):\n994         \"\"\"\n995         Approximates the definite integral by a sum.\n996 \n997         method ... one of: left, right, midpoint, trapezoid\n998 \n999         These are all basically the rectangle method [1], the only difference\n1000         is where the function value is taken in each interval to define the\n1001         rectangle.\n1002 \n1003         [1] http://en.wikipedia.org/wiki/Rectangle_method\n1004 \n1005         Examples\n1006         ========\n1007 \n1008         >>> from sympy import sin, sqrt\n1009         >>> from sympy.abc import x\n1010         >>> from sympy.integrals import Integral\n1011         >>> e = Integral(sin(x), (x, 3, 7))\n1012         >>> e\n1013         Integral(sin(x), (x, 3, 7))\n1014 \n1015         For demonstration purposes, this interval will only be split into 2\n1016         regions, bounded by [3, 5] and [5, 7].\n1017 \n1018         The left-hand rule uses function evaluations at the left of each\n1019         interval:\n1020 \n1021         >>> e.as_sum(2, 'left')\n1022         2*sin(5) + 2*sin(3)\n1023 \n1024         The midpoint rule uses evaluations at the center of each interval:\n1025 \n1026         >>> e.as_sum(2, 'midpoint')\n1027         2*sin(4) + 2*sin(6)\n1028 \n1029         The right-hand rule uses function evaluations at the right of each\n1030         interval:\n1031 \n1032         >>> e.as_sum(2, 'right')\n1033         2*sin(5) + 2*sin(7)\n1034 \n1035         The trapezoid rule uses function evaluations on both sides of the\n1036         intervals. This is equivalent to taking the average of the left and\n1037         right hand rule results:\n1038 \n1039         >>> e.as_sum(2, 'trapezoid')\n1040         2*sin(5) + sin(3) + sin(7)\n1041         >>> (e.as_sum(2, 'left') + e.as_sum(2, 'right'))/2 == _\n1042         True\n1043 \n1044         All but the trapexoid method may be used when dealing with a function\n1045         with a discontinuity. Here, the discontinuity at x = 0 can be avoided\n1046         by using the midpoint or right-hand method:\n1047 \n1048         >>> e = Integral(1/sqrt(x), (x, 0, 1))\n1049         >>> e.as_sum(5).n(4)\n1050         1.730\n1051         >>> e.as_sum(10).n(4)\n1052         1.809\n1053         >>> e.doit().n(4)  # the actual value is 2\n1054         2.000\n1055 \n1056         The left- or trapezoid method will encounter the discontinuity and\n1057         return oo:\n1058 \n1059         >>> e.as_sum(5, 'left')\n1060         oo\n1061         >>> e.as_sum(5, 'trapezoid')\n1062         oo\n1063 \n1064         See Also\n1065         ========\n1066 \n1067         Integral.doit : Perform the integration using any hints\n1068         \"\"\"\n1069 \n1070         limits = self.limits\n1071         if len(limits) > 1:\n1072             raise NotImplementedError(\n1073                 \"Multidimensional midpoint rule not implemented yet\")\n1074         else:\n1075             limit = limits[0]\n1076             if len(limit) != 3:\n1077                 raise ValueError(\"Expecting a definite integral.\")\n1078         if n <= 0:\n1079             raise ValueError(\"n must be > 0\")\n1080         if n == oo:\n1081             raise NotImplementedError(\"Infinite summation not yet implemented\")\n1082         sym, lower_limit, upper_limit = limit\n1083         dx = (upper_limit - lower_limit)/n\n1084 \n1085         if method == 'trapezoid':\n1086             l = self.function.limit(sym, lower_limit)\n1087             r = self.function.limit(sym, upper_limit, \"-\")\n1088             result = (l + r)/2\n1089             for i in range(1, n):\n1090                 x = lower_limit + i*dx\n1091                 result += self.function.subs(sym, x)\n1092             return result*dx\n1093         elif method not in ('left', 'right', 'midpoint'):\n1094             raise NotImplementedError(\"Unknown method %s\" % method)\n1095 \n1096         result = 0\n1097         for i in range(n):\n1098             if method == \"midpoint\":\n1099                 xi = lower_limit + i*dx + dx/2\n1100             elif method == \"left\":\n1101                 xi = lower_limit + i*dx\n1102                 if i == 0:\n1103                     result = self.function.limit(sym, lower_limit)\n1104                     continue\n1105             elif method == \"right\":\n1106                 xi = lower_limit + i*dx + dx\n1107                 if i == n:\n1108                     result += self.function.limit(sym, upper_limit, \"-\")\n1109                     continue\n1110             result += self.function.subs(sym, xi)\n1111         return result*dx\n1112 \n1113     def _sage_(self):\n1114         import sage.all as sage\n1115         f, limits = self.function._sage_(), list(self.limits)\n1116         for limit in limits:\n1117             if len(limit) == 1:\n1118                 x = limit[0]\n1119                 f = sage.integral(f,\n1120                                     x._sage_(),\n1121                                     hold=True)\n1122             elif len(limit) == 2:\n1123                 x, b = limit\n1124                 f = sage.integral(f,\n1125                                     x._sage_(),\n1126                                     b._sage_(),\n1127                                     hold=True)\n1128             else:\n1129                 x, a, b = limit\n1130                 f = sage.integral(f,\n1131                                   (x._sage_(),\n1132                                     a._sage_(),\n1133                                     b._sage_()),\n1134                                     hold=True)\n1135         return f\n1136 \n1137 \n1138 def integrate(*args, **kwargs):\n1139     \"\"\"integrate(f, var, ...)\n1140 \n1141     Compute definite or indefinite integral of one or more variables\n1142     using Risch-Norman algorithm and table lookup. This procedure is\n1143     able to handle elementary algebraic and transcendental functions\n1144     and also a huge class of special functions, including Airy,\n1145     Bessel, Whittaker and Lambert.\n1146 \n1147     var can be:\n1148 \n1149     - a symbol                   -- indefinite integration\n1150     - a tuple (symbol, a)        -- indefinite integration with result\n1151                                     given with `a` replacing `symbol`\n1152     - a tuple (symbol, a, b)     -- definite integration\n1153 \n1154     Several variables can be specified, in which case the result is\n1155     multiple integration. (If var is omitted and the integrand is\n1156     univariate, the indefinite integral in that variable will be performed.)\n1157 \n1158     Indefinite integrals are returned without terms that are independent\n1159     of the integration variables. (see examples)\n1160 \n1161     Definite improper integrals often entail delicate convergence\n1162     conditions. Pass conds='piecewise', 'separate' or 'none' to have\n1163     these returned, respectively, as a Piecewise function, as a separate\n1164     result (i.e. result will be a tuple), or not at all (default is\n1165     'piecewise').\n1166 \n1167     **Strategy**\n1168 \n1169     SymPy uses various approaches to definite integration. One method is to\n1170     find an antiderivative for the integrand, and then use the fundamental\n1171     theorem of calculus. Various functions are implemented to integrate\n1172     polynomial, rational and trigonometric functions, and integrands\n1173     containing DiracDelta terms.\n1174 \n1175     SymPy also implements the part of the Risch algorithm, which is a decision\n1176     procedure for integrating elementary functions, i.e., the algorithm can\n1177     either find an elementary antiderivative, or prove that one does not\n1178     exist.  There is also a (very successful, albeit somewhat slow) general\n1179     implementation of the heuristic Risch algorithm.  This algorithm will\n1180     eventually be phased out as more of the full Risch algorithm is\n1181     implemented. See the docstring of Integral._eval_integral() for more\n1182     details on computing the antiderivative using algebraic methods.\n1183 \n1184     The option risch=True can be used to use only the (full) Risch algorithm.\n1185     This is useful if you want to know if an elementary function has an\n1186     elementary antiderivative.  If the indefinite Integral returned by this\n1187     function is an instance of NonElementaryIntegral, that means that the\n1188     Risch algorithm has proven that integral to be non-elementary.  Note that\n1189     by default, additional methods (such as the Meijer G method outlined\n1190     below) are tried on these integrals, as they may be expressible in terms\n1191     of special functions, so if you only care about elementary answers, use\n1192     risch=True.  Also note that an unevaluated Integral returned by this\n1193     function is not necessarily a NonElementaryIntegral, even with risch=True,\n1194     as it may just be an indication that the particular part of the Risch\n1195     algorithm needed to integrate that function is not yet implemented.\n1196 \n1197     Another family of strategies comes from re-writing the integrand in\n1198     terms of so-called Meijer G-functions. Indefinite integrals of a\n1199     single G-function can always be computed, and the definite integral\n1200     of a product of two G-functions can be computed from zero to\n1201     infinity. Various strategies are implemented to rewrite integrands\n1202     as G-functions, and use this information to compute integrals (see\n1203     the ``meijerint`` module).\n1204 \n1205     The option manual=True can be used to use only an algorithm that tries\n1206     to mimic integration by hand. This algorithm does not handle as many\n1207     integrands as the other algorithms implemented but may return results in\n1208     a more familiar form. The ``manualintegrate`` module has functions that\n1209     return the steps used (see the module docstring for more information).\n1210 \n1211     In general, the algebraic methods work best for computing\n1212     antiderivatives of (possibly complicated) combinations of elementary\n1213     functions. The G-function methods work best for computing definite\n1214     integrals from zero to infinity of moderately complicated\n1215     combinations of special functions, or indefinite integrals of very\n1216     simple combinations of special functions.\n1217 \n1218     The strategy employed by the integration code is as follows:\n1219 \n1220     - If computing a definite integral, and both limits are real,\n1221       and at least one limit is +- oo, try the G-function method of\n1222       definite integration first.\n1223 \n1224     - Try to find an antiderivative, using all available methods, ordered\n1225       by performance (that is try fastest method first, slowest last; in\n1226       particular polynomial integration is tried first, Meijer\n1227       G-functions second to last, and heuristic Risch last).\n1228 \n1229     - If still not successful, try G-functions irrespective of the\n1230       limits.\n1231 \n1232     The option meijerg=True, False, None can be used to, respectively:\n1233     always use G-function methods and no others, never use G-function\n1234     methods, or use all available methods (in order as described above).\n1235     It defaults to None.\n1236 \n1237     Examples\n1238     ========\n1239 \n1240     >>> from sympy import integrate, log, exp, oo\n1241     >>> from sympy.abc import a, x, y\n1242 \n1243     >>> integrate(x*y, x)\n1244     x**2*y/2\n1245 \n1246     >>> integrate(log(x), x)\n1247     x*log(x) - x\n1248 \n1249     >>> integrate(log(x), (x, 1, a))\n1250     a*log(a) - a + 1\n1251 \n1252     >>> integrate(x)\n1253     x**2/2\n1254 \n1255     Terms that are independent of x are dropped by indefinite integration:\n1256 \n1257     >>> from sympy import sqrt\n1258     >>> integrate(sqrt(1 + x), (x, 0, x))\n1259     2*(x + 1)**(3/2)/3 - 2/3\n1260     >>> integrate(sqrt(1 + x), x)\n1261     2*(x + 1)**(3/2)/3\n1262 \n1263     >>> integrate(x*y)\n1264     Traceback (most recent call last):\n1265     ...\n1266     ValueError: specify integration variables to integrate x*y\n1267 \n1268     Note that ``integrate(x)`` syntax is meant only for convenience\n1269     in interactive sessions and should be avoided in library code.\n1270 \n1271     >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'\n1272     Piecewise((gamma(a + 1), -re(a) < 1),\n1273         (Integral(x**a*exp(-x), (x, 0, oo)), True))\n1274 \n1275     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')\n1276     gamma(a + 1)\n1277 \n1278     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')\n1279     (gamma(a + 1), -re(a) < 1)\n1280 \n1281     See Also\n1282     ========\n1283 \n1284     Integral, Integral.doit\n1285 \n1286     \"\"\"\n1287     meijerg = kwargs.pop('meijerg', None)\n1288     conds = kwargs.pop('conds', 'piecewise')\n1289     risch = kwargs.pop('risch', None)\n1290     manual = kwargs.pop('manual', None)\n1291     integral = Integral(*args, **kwargs)\n1292 \n1293     if isinstance(integral, Integral):\n1294         return integral.doit(deep=False, meijerg=meijerg, conds=conds,\n1295                              risch=risch, manual=manual)\n1296     else:\n1297         return integral\n1298 \n1299 \n1300 def line_integrate(field, curve, vars):\n1301     \"\"\"line_integrate(field, Curve, variables)\n1302 \n1303     Compute the line integral.\n1304 \n1305     Examples\n1306     ========\n1307 \n1308     >>> from sympy import Curve, line_integrate, E, ln\n1309     >>> from sympy.abc import x, y, t\n1310     >>> C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))\n1311     >>> line_integrate(x + y, C, [x, y])\n1312     3*sqrt(2)\n1313 \n1314     See Also\n1315     ========\n1316 \n1317     integrate, Integral\n1318     \"\"\"\n1319     from sympy.geometry import Curve\n1320     F = sympify(field)\n1321     if not F:\n1322         raise ValueError(\n1323             \"Expecting function specifying field as first argument.\")\n1324     if not isinstance(curve, Curve):\n1325         raise ValueError(\"Expecting Curve entity as second argument.\")\n1326     if not is_sequence(vars):\n1327         raise ValueError(\"Expecting ordered iterable for variables.\")\n1328     if len(curve.functions) != len(vars):\n1329         raise ValueError(\"Field variable size does not match curve dimension.\")\n1330 \n1331     if curve.parameter in vars:\n1332         raise ValueError(\"Curve parameter clashes with field parameters.\")\n1333 \n1334     # Calculate derivatives for line parameter functions\n1335     # F(r) -> F(r(t)) and finally F(r(t)*r'(t))\n1336     Ft = F\n1337     dldt = 0\n1338     for i, var in enumerate(vars):\n1339         _f = curve.functions[i]\n1340         _dn = diff(_f, curve.parameter)\n1341         # ...arc length\n1342         dldt = dldt + (_dn * _dn)\n1343         Ft = Ft.subs(var, _f)\n1344     Ft = Ft * sqrt(dldt)\n1345 \n1346     integral = Integral(Ft, curve.limits).doit(deep=False)\n1347     return integral\n",
        "intended_behavior": "These integral-related functions should be carefully reviewed to ensure that modifications involving \"ff\" have not adversely affected the computation of integrals. The goal is to maintain or restore the precise handling of integrals, transformations, and evaluations based on the library's standards before the changes."
    },
    {
        "rel_file_path": "sympy/simplify/combsimp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/simplify/combsimp.py",
        "start": 1,
        "end": 513,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from sympy.core import Function, S, Mul, Pow, Add\n4 from sympy.core.compatibility import ordered, default_sort_key\n5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial\n6 from sympy.functions import gamma, sqrt, sin\n7 from sympy.polys import factor, cancel\n8 \n9 from sympy.utilities.timeutils import timethis\n10 from sympy.utilities.iterables import sift\n11 from sympy.utilities.iterables import uniq\n12 \n13 \n14 \n15 @timethis('combsimp')\n16 def combsimp(expr):\n17     r\"\"\"\n18     Simplify combinatorial expressions.\n19 \n20     This function takes as input an expression containing factorials,\n21     binomials, Pochhammer symbol and other \"combinatorial\" functions,\n22     and tries to minimize the number of those functions and reduce\n23     the size of their arguments.\n24 \n25     The algorithm works by rewriting all combinatorial functions as\n26     expressions involving rising factorials (Pochhammer symbols) and\n27     applies recurrence relations and other transformations applicable\n28     to rising factorials, to reduce their arguments, possibly letting\n29     the resulting rising factorial to cancel. Rising factorials with\n30     the second argument being an integer are expanded into polynomial\n31     forms and finally all other rising factorial are rewritten in terms\n32     of more familiar functions. If the initial expression consisted of\n33     gamma functions alone, the result is expressed in terms of gamma\n34     functions. If the initial expression consists of gamma function\n35     with some other combinatorial, the result is expressed in terms of\n36     gamma functions.\n37 \n38     If the result is expressed using gamma functions, the following three\n39     additional steps are performed:\n40 \n41     1. Reduce the number of gammas by applying the reflection theorem\n42        gamma(x)*gamma(1-x) == pi/sin(pi*x).\n43     2. Reduce the number of gammas by applying the multiplication theorem\n44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).\n45     3. Reduce the number of prefactors by absorbing them into gammas, where\n46        possible.\n47 \n48     All transformation rules can be found (or was derived from) here:\n49 \n50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/\n51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/\n52 \n53     Examples\n54     ========\n55 \n56     >>> from sympy.simplify import combsimp\n57     >>> from sympy import factorial, binomial\n58     >>> from sympy.abc import n, k\n59 \n60     >>> combsimp(factorial(n)/factorial(n - 3))\n61     n*(n - 2)*(n - 1)\n62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))\n63     (n + 1)/(k + 1)\n64 \n65     \"\"\"\n66 \n67     # as a rule of thumb, if the expression contained gammas initially, it\n68     # probably makes sense to retain them\n69     as_gamma = expr.has(gamma)\n70     as_factorial = expr.has(factorial)\n71     as_binomial = expr.has(binomial)\n72 \n73 \n74     expr = expr.replace(binomial,\n75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))\n76     expr = expr.replace(factorial,\n77         lambda n: _rf(1, n.expand()))\n78     expr = expr.rewrite(gamma)\n79     expr = expr.replace(gamma,\n80         lambda n: _rf(1, (n - 1).expand()))\n81 \n82     if as_gamma:\n83         expr = expr.replace(_rf,\n84             lambda a, b: gamma(a + b)/gamma(a))\n85     else:\n86         expr = expr.replace(_rf,\n87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))\n88 \n89     def rule(n, k):\n90         coeff, rewrite = S.One, False\n91 \n92         cn, _n = n.as_coeff_Add()\n93 \n94         if _n and cn.is_Integer and cn:\n95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)\n96             rewrite = True\n97             n = _n\n98 \n99         # this sort of binomial has already been removed by\n100         # rising factorials but is left here in case the order\n101         # of rule application is changed\n102         if k.is_Add:\n103             ck, _k = k.as_coeff_Add()\n104             if _k and ck.is_Integer and ck:\n105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)\n106                 rewrite = True\n107                 k = _k\n108 \n109         if rewrite:\n110             return coeff*binomial(n, k)\n111 \n112     expr = expr.replace(binomial, rule)\n113 \n114     def rule_gamma(expr, level=0):\n115         \"\"\" Simplify products of gamma functions further. \"\"\"\n116 \n117         if expr.is_Atom:\n118             return expr\n119 \n120         def gamma_rat(x):\n121             # helper to simplify ratios of gammas\n122             was = x.count(gamma)\n123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()\n124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))\n125             if xx.count(gamma) < was:\n126                 x = xx\n127             return x\n128 \n129         def gamma_factor(x):\n130             # return True if there is a gamma factor in shallow args\n131             if x.func is gamma:\n132                 return True\n133             if x.is_Add or x.is_Mul:\n134                 return any(gamma_factor(xi) for xi in x.args)\n135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):\n136                 return gamma_factor(x.base)\n137             return False\n138 \n139         # recursion step\n140         if level == 0:\n141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])\n142             level += 1\n143 \n144         if not expr.is_Mul:\n145             return expr\n146 \n147         # non-commutative step\n148         if level == 1:\n149             args, nc = expr.args_cnc()\n150             if not args:\n151                 return expr\n152             if nc:\n153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)\n154             level += 1\n155 \n156         # pure gamma handling, not factor absorbtion\n157         if level == 2:\n158             sifted = sift(expr.args, gamma_factor)\n159             gamma_ind = Mul(*sifted.pop(False, []))\n160             d = Mul(*sifted.pop(True, []))\n161             assert not sifted\n162 \n163             nd, dd = d.as_numer_denom()\n164             for ipass in range(2):\n165                 args = list(ordered(Mul.make_args(nd)))\n166                 for i, ni in enumerate(args):\n167                     if ni.is_Add:\n168                         ni, dd = Add(*[\n169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]\n170                             ).as_numer_denom()\n171                         args[i] = ni\n172                         if not dd.has(gamma):\n173                             break\n174                 nd = Mul(*args)\n175                 if ipass ==  0 and not gamma_factor(nd):\n176                     break\n177                 nd, dd = dd, nd  # now process in reversed order\n178             expr = gamma_ind*nd/dd\n179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):\n180                 return expr\n181             level += 1\n182 \n183         # iteration until constant\n184         if level == 3:\n185             while True:\n186                 was = expr\n187                 expr = rule_gamma(expr, 4)\n188                 if expr == was:\n189                     return expr\n190 \n191         numer_gammas = []\n192         denom_gammas = []\n193         numer_others = []\n194         denom_others = []\n195         def explicate(p):\n196             if p is S.One:\n197                 return None, []\n198             b, e = p.as_base_exp()\n199             if e.is_Integer:\n200                 if b.func is gamma:\n201                     return True, [b.args[0]]*e\n202                 else:\n203                     return False, [b]*e\n204             else:\n205                 return False, [p]\n206 \n207         newargs = list(ordered(expr.args))\n208         while newargs:\n209             n, d = newargs.pop().as_numer_denom()\n210             isg, l = explicate(n)\n211             if isg:\n212                 numer_gammas.extend(l)\n213             elif isg is False:\n214                 numer_others.extend(l)\n215             isg, l = explicate(d)\n216             if isg:\n217                 denom_gammas.extend(l)\n218             elif isg is False:\n219                 denom_others.extend(l)\n220 \n221         # =========== level 2 work: pure gamma manipulation =========\n222 \n223         # Try to reduce the number of gamma factors by applying the\n224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)\n225         for gammas, numer, denom in [(\n226             numer_gammas, numer_others, denom_others),\n227                 (denom_gammas, denom_others, numer_others)]:\n228             new = []\n229             while gammas:\n230                 g1 = gammas.pop()\n231                 if g1.is_integer:\n232                     new.append(g1)\n233                     continue\n234                 for i, g2 in enumerate(gammas):\n235                     n = g1 + g2 - 1\n236                     if not n.is_Integer:\n237                         continue\n238                     numer.append(S.Pi)\n239                     denom.append(sin(S.Pi*g1))\n240                     gammas.pop(i)\n241                     if n > 0:\n242                         for k in range(n):\n243                             numer.append(1 - g1 + k)\n244                     elif n < 0:\n245                         for k in range(-n):\n246                             denom.append(-g1 - k)\n247                     break\n248                 else:\n249                     new.append(g1)\n250             # /!\\ updating IN PLACE\n251             gammas[:] = new\n252 \n253         # Try to reduce the number of gammas by using the duplication\n254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =\n255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could\n256         # be done with higher argument ratios like gamma(3*x)/gamma(x),\n257         # this would not reduce the number of gammas as in this case.\n258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,\n259                                 denom_others),\n260                                (denom_gammas, numer_gammas, denom_others,\n261                                 numer_others)]:\n262 \n263             while True:\n264                 for x in ng:\n265                     for y in dg:\n266                         n = x - 2*y\n267                         if n.is_Integer:\n268                             break\n269                     else:\n270                         continue\n271                     break\n272                 else:\n273                     break\n274                 ng.remove(x)\n275                 dg.remove(y)\n276                 if n > 0:\n277                     for k in range(n):\n278                         no.append(2*y + k)\n279                 elif n < 0:\n280                     for k in range(-n):\n281                         do.append(2*y - 1 - k)\n282                 ng.append(y + S(1)/2)\n283                 no.append(2**(2*y - 1))\n284                 do.append(sqrt(S.Pi))\n285 \n286         # Try to reduce the number of gamma factors by applying the\n287         # multiplication theorem (used when n gammas with args differing\n288         # by 1/n mod 1 are encountered).\n289         #\n290         # run of 2 with args differing by 1/2\n291         #\n292         # >>> combsimp(gamma(x)*gamma(x+S.Half))\n293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)\n294         #\n295         # run of 3 args differing by 1/3 (mod 1)\n296         #\n297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))\n298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)\n299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))\n300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)\n301         #\n302         def _run(coeffs):\n303             # find runs in coeffs such that the difference in terms (mod 1)\n304             # of t1, t2, ..., tn is 1/n\n305             u = list(uniq(coeffs))\n306             for i in range(len(u)):\n307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])\n308                 for one, j in dj:\n309                     if one.p == 1 and one.q != 1:\n310                         n = one.q\n311                         got = [i]\n312                         get = list(range(1, n))\n313                         for d, j in dj:\n314                             m = n*d\n315                             if m.is_Integer and m in get:\n316                                 get.remove(m)\n317                                 got.append(j)\n318                                 if not get:\n319                                     break\n320                         else:\n321                             continue\n322                         for i, j in enumerate(got):\n323                             c = u[j]\n324                             coeffs.remove(c)\n325                             got[i] = c\n326                         return one.q, got[0], got[1:]\n327 \n328         def _mult_thm(gammas, numer, denom):\n329             # pull off and analyze the leading coefficient from each gamma arg\n330             # looking for runs in those Rationals\n331 \n332             # expr -> coeff + resid -> rats[resid] = coeff\n333             rats = {}\n334             for g in gammas:\n335                 c, resid = g.as_coeff_Add()\n336                 rats.setdefault(resid, []).append(c)\n337 \n338             # look for runs in Rationals for each resid\n339             keys = sorted(rats, key=default_sort_key)\n340             for resid in keys:\n341                 coeffs = list(sorted(rats[resid]))\n342                 new = []\n343                 while True:\n344                     run = _run(coeffs)\n345                     if run is None:\n346                         break\n347 \n348                     # process the sequence that was found:\n349                     # 1) convert all the gamma functions to have the right\n350                     #    argument (could be off by an integer)\n351                     # 2) append the factors corresponding to the theorem\n352                     # 3) append the new gamma function\n353 \n354                     n, ui, other = run\n355 \n356                     # (1)\n357                     for u in other:\n358                         con = resid + u - 1\n359                         for k in range(int(u - ui)):\n360                             numer.append(con - k)\n361 \n362                     con = n*(resid + ui)  # for (2) and (3)\n363 \n364                     # (2)\n365                     numer.append((2*S.Pi)**(S(n - 1)/2)*\n366                                  n**(S(1)/2 - con))\n367                     # (3)\n368                     new.append(con)\n369 \n370                 # restore resid to coeffs\n371                 rats[resid] = [resid + c for c in coeffs] + new\n372 \n373             # rebuild the gamma arguments\n374             g = []\n375             for resid in keys:\n376                 g += rats[resid]\n377             # /!\\ updating IN PLACE\n378             gammas[:] = g\n379 \n380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),\n381                                 (denom_gammas, denom_others, numer_others)]:\n382             _mult_thm(l, numer, denom)\n383 \n384         # =========== level >= 2 work: factor absorbtion =========\n385 \n386         if level >= 2:\n387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)\n388             # and gamma(x)/(x - 1) -> gamma(x - 1)\n389             # This code (in particular repeated calls to find_fuzzy) can be very\n390             # slow.\n391             def find_fuzzy(l, x):\n392                 if not l:\n393                     return\n394                 S1, T1 = compute_ST(x)\n395                 for y in l:\n396                     S2, T2 = inv[y]\n397                     if T1 != T2 or (not S1.intersection(S2) and\n398                                     (S1 != set() or S2 != set())):\n399                         continue\n400                     # XXX we want some simplification (e.g. cancel or\n401                     # simplify) but no matter what it's slow.\n402                     a = len(cancel(x/y).free_symbols)\n403                     b = len(x.free_symbols)\n404                     c = len(y.free_symbols)\n405                     # TODO is there a better heuristic?\n406                     if a == 0 and (b > 0 or c > 0):\n407                         return y\n408 \n409             # We thus try to avoid expensive calls by building the following\n410             # \"invariants\": For every factor or gamma function argument\n411             #   - the set of free symbols S\n412             #   - the set of functional components T\n413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset\n414             # or S1 == S2 == emptyset)\n415             inv = {}\n416 \n417             def compute_ST(expr):\n418                 if expr in inv:\n419                     return inv[expr]\n420                 return (expr.free_symbols, expr.atoms(Function).union(\n421                         set(e.exp for e in expr.atoms(Pow))))\n422 \n423             def update_ST(expr):\n424                 inv[expr] = compute_ST(expr)\n425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:\n426                 update_ST(expr)\n427 \n428             for gammas, numer, denom in [(\n429                 numer_gammas, numer_others, denom_others),\n430                     (denom_gammas, denom_others, numer_others)]:\n431                 new = []\n432                 while gammas:\n433                     g = gammas.pop()\n434                     cont = True\n435                     while cont:\n436                         cont = False\n437                         y = find_fuzzy(numer, g)\n438                         if y is not None:\n439                             numer.remove(y)\n440                             if y != g:\n441                                 numer.append(y/g)\n442                                 update_ST(y/g)\n443                             g += 1\n444                             cont = True\n445                         y = find_fuzzy(denom, g - 1)\n446                         if y is not None:\n447                             denom.remove(y)\n448                             if y != g - 1:\n449                                 numer.append((g - 1)/y)\n450                                 update_ST((g - 1)/y)\n451                             g -= 1\n452                             cont = True\n453                     new.append(g)\n454                 # /!\\ updating IN PLACE\n455                 gammas[:] = new\n456 \n457         # =========== rebuild expr ==================================\n458 \n459         return Mul(*[gamma(g) for g in numer_gammas]) \\\n460             / Mul(*[gamma(g) for g in denom_gammas]) \\\n461             * Mul(*numer_others) / Mul(*denom_others)\n462 \n463     # (for some reason we cannot use Basic.replace in this case)\n464     was = factor(expr)\n465     expr = rule_gamma(was)\n466     if expr != was:\n467         expr = factor(expr)\n468 \n469     if not as_gamma:\n470         if as_factorial:\n471             expr = expr.rewrite(factorial)\n472         elif as_binomial:\n473             expr = expr.rewrite(binomial)\n474 \n475     return expr\n476 \n477 class _rf(Function):\n478     @classmethod\n479     def eval(cls, a, b):\n480         if b.is_Integer:\n481             if not b:\n482                 return S.One\n483 \n484             n, result = int(b), S.One\n485 \n486             if n > 0:\n487                 for i in range(n):\n488                     result *= a + i\n489 \n490                 return result\n491             elif n < 0:\n492                 for i in range(1, -n + 1):\n493                     result *= a - i\n494 \n495                 return 1/result\n496         else:\n497             if b.is_Add:\n498                 c, _b = b.as_coeff_Add()\n499 \n500                 if c.is_Integer:\n501                     if c > 0:\n502                         return _rf(a, _b)*_rf(a + _b, c)\n503                     elif c < 0:\n504                         return _rf(a, _b)/_rf(a + _b + c, -c)\n505 \n506             if a.is_Add:\n507                 c, _a = a.as_coeff_Add()\n508 \n509                 if c.is_Integer:\n510                     if c > 0:\n511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)\n512                     elif c < 0:\n513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)\n",
        "intended_behavior": "The combinatorial simplification routines, including those that utilize \"rf\", should follow correct simplification logic to yield results consistent with the established combinatorial mathematics principles. If recent changes have introduced discrepancies or errors, a reversion or adjustment will be necessary to restore the accuracy of these simplifications."
    }
]