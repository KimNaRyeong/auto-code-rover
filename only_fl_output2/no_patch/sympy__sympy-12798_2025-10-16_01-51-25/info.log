2025-10-16 01:51:25.745 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 01:51:30.090 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=125, output_tokens=12, cost=0.001610
2025-10-16 01:51:30.090 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 01:51:30.094 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:51:35.895 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=433, output_tokens=221, cost=0.010960
2025-10-16 01:51:35.902 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:51:37.526 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=575, output_tokens=27, cost=0.006560
2025-10-16 01:51:37.527 | DEBUG    | Extracted a valid json.
2025-10-16 01:51:37.527 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"ff\")", "search_method(\"rf\")"],
    "bug_locations": []
}
2025-10-16 01:51:37.531 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:51:37.532 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:51:46.738 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=801, output_tokens=382, cost=0.019470
2025-10-16 01:51:46.748 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:51:53.934 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1399, output_tokens=257, cost=0.021700
2025-10-16 01:51:53.940 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:51:55.526 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=14, cost=0.006530
2025-10-16 01:51:55.527 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:51:55.527 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:51:58.624 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=14, cost=0.006530
2025-10-16 01:51:58.625 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:51:58.625 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:51:59.638 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=14, cost=0.006530
2025-10-16 01:51:59.639 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:51:59.645 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:52:01.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=14, cost=0.006530
2025-10-16 01:52:01.154 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:52:01.154 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:52:02.199 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=14, cost=0.006530
2025-10-16 01:52:02.201 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:52:02.202 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:52:02.202 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:52:02.203 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:52:02.203 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:52:11.939 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1683, output_tokens=399, cost=0.028800
2025-10-16 01:52:11.945 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:52:14.004 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=14, cost=0.007950
2025-10-16 01:52:14.005 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:52:14.005 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:52:16.064 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=14, cost=0.007950
2025-10-16 01:52:16.065 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:52:16.065 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:52:17.058 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=14, cost=0.007950
2025-10-16 01:52:17.059 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:52:17.065 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:52:18.891 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=753, output_tokens=32, cost=0.008490
2025-10-16 01:52:18.892 | DEBUG    | Extracted a valid json.
2025-10-16 01:52:18.892 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ff\")",
        "search_code(\"rf\")"
    ],
    "bug_locations": []
}
2025-10-16 01:52:33.654 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:52:33.654 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:52:51.915 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=13294, output_tokens=671, cost=0.153070
2025-10-16 01:52:51.922 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:53:01.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14181, output_tokens=338, cost=0.151950
2025-10-16 01:53:01.667 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:53:03.126 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-16 01:53:03.127 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:03.127 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:53:04.802 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-16 01:53:04.803 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:04.803 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:53:06.873 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-16 01:53:06.874 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:06.880 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:53:07.899 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-16 01:53:07.900 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:07.900 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:53:08.986 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=14, cost=0.007340
2025-10-16 01:53:08.987 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:08.987 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:53:08.987 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:53:08.988 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:53:08.988 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:53:16.976 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14546, output_tokens=178, cost=0.150800
2025-10-16 01:53:16.981 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:53:18.301 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=532, output_tokens=14, cost=0.005740
2025-10-16 01:53:18.302 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:18.302 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:53:19.407 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=532, output_tokens=14, cost=0.005740
2025-10-16 01:53:19.408 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:19.408 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:53:20.513 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=532, output_tokens=14, cost=0.005740
2025-10-16 01:53:20.514 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:20.514 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:53:21.496 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=532, output_tokens=14, cost=0.005740
2025-10-16 01:53:21.497 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:21.497 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:53:22.584 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=532, output_tokens=14, cost=0.005740
2025-10-16 01:53:22.585 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:22.591 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:53:22.591 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:53:22.592 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:53:22.592 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:53:33.344 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=14751, output_tokens=378, cost=0.158850
2025-10-16 01:53:33.352 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:53:34.819 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=14, cost=0.007740
2025-10-16 01:53:34.820 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:34.820 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-16 01:53:35.967 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=14, cost=0.007740
2025-10-16 01:53:35.968 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:35.968 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-16 01:53:37.000 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=14, cost=0.007740
2025-10-16 01:53:37.001 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:37.001 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-16 01:53:38.230 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=14, cost=0.007740
2025-10-16 01:53:38.231 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:38.231 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-16 01:53:39.228 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=732, output_tokens=14, cost=0.007740
2025-10-16 01:53:39.229 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-16 01:53:39.229 | DEBUG    | Agent proxy return the following json: None
2025-10-16 01:53:39.230 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-16 01:53:39.231 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-16 01:53:39.231 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:53:51.674 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=15156, output_tokens=390, cost=0.163260
2025-10-16 01:53:51.682 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:53:55.464 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=744, output_tokens=103, cost=0.010530
2025-10-16 01:53:55.466 | DEBUG    | Extracted a valid json.
2025-10-16 01:53:55.466 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"ff\", \"sympy/functions/combinatorial/factorials.py\")",
        "search_code_in_file(\"rf\", \"sympy/functions/special/error_functions.py\")",
        "search_code_in_file(\"ff\", \"sympy/integrals/integrals.py\")",
        "search_code_in_file(\"rf\", \"sympy/simplify/combsimp.py\")"
    ],
    "bug_locations": []
}
2025-10-16 01:53:56.064 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:53:56.064 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:54:21.425 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=16731, output_tokens=774, cost=0.190530
2025-10-16 01:54:21.433 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:54:39.597 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=17721, output_tokens=691, cost=0.197940
2025-10-16 01:54:39.605 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:54:49.377 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1045, output_tokens=405, cost=0.022600
2025-10-16 01:54:49.378 | DEBUG    | Extracted a valid json.
2025-10-16 01:54:49.378 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/functions/combinatorial/factorials.py",
            "class": "",
            "method": "_eval_rewrite_as_FallingFactorial",
            "intended_behavior": "This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation."
        },
        {
            "file": "sympy/functions/special/error_functions.py",
            "class": "",
            "method": "multiple",
            "intended_behavior": "Each of these methods should ensure the operations involving error functions and related special functions are executed in line with established mathematical definitions and transformations. Reversions or corrections might be needed to align the implementations with the intended mathematical behaviors, specifically reverting to functionality before the modifications introduced in SymPy 1.0."
        },
        {
            "file": "sympy/integrals/integrals.py",
            "class": "",
            "method": "multiple",
            "intended_behavior": "These integral-related functions should be carefully reviewed to ensure that modifications involving \"ff\" have not adversely affected the computation of integrals. The goal is to maintain or restore the precise handling of integrals, transformations, and evaluations based on the library's standards before the changes."
        },
        {
            "file": "sympy/simplify/combsimp.py",
            "class": "",
            "method": "multiple",
            "intended_behavior": "The combinatorial simplification routines, including those that utilize \"rf\", should follow correct simplification logic to yield results consistent with the established combinatorial mathematics principles. If recent changes have introduced discrepancies or errors, a reversion or adjustment will be necessary to restore the accuracy of these simplifications."
        }
    ]
}
2025-10-16 01:54:49.394 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>RisingFactorial</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>binomial</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/special/error_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module contains various functions that are special cases
2     of incomplete gamma functions. It should probably be renamed. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, S, sympify, cacheit, pi, I
7 from sympy.core.function import Function, ArgumentIndexError
8 from sympy.core.symbol import Symbol
9 from sympy.functions.combinatorial.factorials import factorial
10 from sympy.functions.elementary.integers import floor
11 from sympy.functions.elementary.miscellaneous import sqrt, root
12 from sympy.functions.elementary.exponential import exp, log
13 from sympy.functions.elementary.complexes import polar_lift
14 from sympy.functions.elementary.hyperbolic import cosh, sinh
15 from sympy.functions.elementary.trigonometric import cos, sin, sinc
16 from sympy.functions.special.hyper import hyper, meijerg
17 from sympy.core.compatibility import range
18 
19 # TODO series expansions
20 # TODO see the "Note:" in Ei
21 
22 ###############################################################################
23 ################################ ERROR FUNCTION ###############################
24 ###############################################################################
25 
26 
27 class erf(Function):
28     r"""
29     The Gauss error function. This function is defined as:
30 
31     .. math ::
32         \mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} \mathrm{d}t.
33 
34     Examples
35     ========
36 
37     >>> from sympy import I, oo, erf
38     >>> from sympy.abc import z
39 
40     Several special values are known:
41 
42     >>> erf(0)
43     0
44     >>> erf(oo)
45     1
46     >>> erf(-oo)
47     -1
48     >>> erf(I*oo)
49     oo*I
50     >>> erf(-I*oo)
51     -oo*I
52 
53     In general one can pull out factors of -1 and I from the argument:
54 
55     >>> erf(-z)
56     -erf(z)
57 
58     The error function obeys the mirror symmetry:
59 
60     >>> from sympy import conjugate
61     >>> conjugate(erf(z))
62     erf(conjugate(z))
63 
64     Differentiation with respect to z is supported:
65 
66     >>> from sympy import diff
67     >>> diff(erf(z), z)
68     2*exp(-z**2)/sqrt(pi)
69 
70     We can numerically evaluate the error function to arbitrary precision
71     on the whole complex plane:
72 
73     >>> erf(4).evalf(30)
74     0.999999984582742099719981147840
75 
76     >>> erf(-4*I).evalf(30)
77     -1296959.73071763923152794095062*I
78 
79     See Also
80     ========
81 
82     erfc: Complementary error function.
83     erfi: Imaginary error function.
84     erf2: Two-argument error function.
85     erfinv: Inverse error function.
86     erfcinv: Inverse Complementary error function.
87     erf2inv: Inverse two-argument error function.
88 
89     References
90     ==========
91 
92     .. [1] http://en.wikipedia.org/wiki/Error_function
93     .. [2] http://dlmf.nist.gov/7
94     .. [3] http://mathworld.wolfram.com/Erf.html
95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf
96     """
97 
98     unbranched = True
99 
100     def fdiff(self, argindex=1):
101         if argindex == 1:
102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)
103         else:
104             raise ArgumentIndexError(self, argindex)
105 
106 
107     def inverse(self, argindex=1):
108         """
109         Returns the inverse of this function.
110         """
111         return erfinv
112 
113     @classmethod
114     def eval(cls, arg):
115         if arg.is_Number:
116             if arg is S.NaN:
117                 return S.NaN
118             elif arg is S.Infinity:
119                 return S.One
120             elif arg is S.NegativeInfinity:
121                 return S.NegativeOne
122             elif arg is S.Zero:
123                 return S.Zero
124 
125         if arg.func is erfinv:
126              return arg.args[0]
127 
128         if arg.func is erfcinv:
129             return S.One - arg.args[0]
130 
131         if arg.func is erf2inv and arg.args[0] is S.Zero:
132             return arg.args[1]
133 
134         # Try to pull out factors of I
135         t = arg.extract_multiplicatively(S.ImaginaryUnit)
136         if t is S.Infinity or t is S.NegativeInfinity:
137             return arg
138 
139         # Try to pull out factors of -1
140         if arg.could_extract_minus_sign():
141             return -cls(-arg)
142 
143     @staticmethod
144     @cacheit
145     def taylor_term(n, x, *previous_terms):
146         if n < 0 or n % 2 == 0:
147             return S.Zero
148         else:
149             x = sympify(x)
150             k = floor((n - 1)/S(2))
151             if len(previous_terms) > 2:
152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
153             else:
154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
155 
156     def _eval_conjugate(self):
157         return self.func(self.args[0].conjugate())
158 
159     def _eval_is_real(self):
160         return self.args[0].is_real
161 
162     def _eval_rewrite_as_uppergamma(self, z):
163         from sympy import uppergamma
164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
165 
166     def _eval_rewrite_as_fresnels(self, z):
167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
169 
170     def _eval_rewrite_as_fresnelc(self, z):
171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
173 
174     def _eval_rewrite_as_meijerg(self, z):
175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
176 
177     def _eval_rewrite_as_hyper(self, z):
178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
179 
180     def _eval_rewrite_as_expint(self, z):
181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)
182 
183     def _eval_rewrite_as_tractable(self, z):
184         return S.One - _erfs(z)*exp(-z**2)
185 
186     def _eval_rewrite_as_erfc(self, z):
187         return S.One - erfc(z)
188 
189     def _eval_rewrite_as_erfi(self, z):
190         return -I*erfi(I*z)
191 
192     def _eval_as_leading_term(self, x):
193         from sympy import Order
194         arg = self.args[0].as_leading_term(x)
195 
196         if x in arg.free_symbols and Order(1, x).contains(arg):
197             return 2*x/sqrt(pi)
198         else:
199             return self.func(arg)
200 
201     def as_real_imag(self, deep=True, **hints):
202         if self.args[0].is_real:
203             if deep:
204                 hints['complex'] = False
205                 return (self.expand(deep, **hints), S.Zero)
206             else:
207                 return (self, S.Zero)
208         if deep:
209             x, y = self.args[0].expand(deep, **hints).as_real_imag()
210         else:
211             x, y = self.args[0].as_real_imag()
212 
213         sq = -y**2/x**2
214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
216                     self.func(x + x*sqrt(sq)))
217         return (re, im)
218 
219 
220 class erfc(Function):
221     r"""
222     Complementary Error Function. The function is defined as:
223 
224     .. math ::
225         \mathrm{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-t^2} \mathrm{d}t
226 
227     Examples
228     ========
229 
230     >>> from sympy import I, oo, erfc
231     >>> from sympy.abc import z
232 
233     Several special values are known:
234 
235     >>> erfc(0)
236     1
237     >>> erfc(oo)
238     0
239     >>> erfc(-oo)
240     2
241     >>> erfc(I*oo)
242     -oo*I
243     >>> erfc(-I*oo)
244     oo*I
245 
246     The error function obeys the mirror symmetry:
247 
248     >>> from sympy import conjugate
249     >>> conjugate(erfc(z))
250     erfc(conjugate(z))
251 
252     Differentiation with respect to z is supported:
253 
254     >>> from sympy import diff
255     >>> diff(erfc(z), z)
256     -2*exp(-z**2)/sqrt(pi)
257 
258     It also follows
259 
260     >>> erfc(-z)
261     -erfc(z) + 2
262 
263     We can numerically evaluate the complementary error function to arbitrary precision
264     on the whole complex plane:
265 
266     >>> erfc(4).evalf(30)
267     0.0000000154172579002800188521596734869
268 
269     >>> erfc(4*I).evalf(30)
270     1.0 - 1296959.73071763923152794095062*I
271 
272     See Also
273     ========
274 
275     erf: Gaussian error function.
276     erfi: Imaginary error function.
277     erf2: Two-argument error function.
278     erfinv: Inverse error function.
279     erfcinv: Inverse Complementary error function.
280     erf2inv: Inverse two-argument error function.
281 
282     References
283     ==========
284 
285     .. [1] http://en.wikipedia.org/wiki/Error_function
286     .. [2] http://dlmf.nist.gov/7
287     .. [3] http://mathworld.wolfram.com/Erfc.html
288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc
289     """
290 
291     unbranched = True
292 
293     def fdiff(self, argindex=1):
294         if argindex == 1:
295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)
296         else:
297             raise ArgumentIndexError(self, argindex)
298 
299     def inverse(self, argindex=1):
300         """
301         Returns the inverse of this function.
302         """
303         return erfcinv
304 
305     @classmethod
306     def eval(cls, arg):
307         if arg.is_Number:
308             if arg is S.NaN:
309                 return S.NaN
310             elif arg is S.Infinity:
311                 return S.Zero
312             elif arg is S.Zero:
313                 return S.One
314 
315         if arg.func is erfinv:
316             return S.One - arg.args[0]
317 
318         if arg.func is erfcinv:
319             return arg.args[0]
320 
321         # Try to pull out factors of I
322         t = arg.extract_multiplicatively(S.ImaginaryUnit)
323         if t is S.Infinity or t is S.NegativeInfinity:
324             return -arg
325 
326         # Try to pull out factors of -1
327         if arg.could_extract_minus_sign():
328             return S(2) - cls(-arg)
329 
330     @staticmethod
331     @cacheit
332     def taylor_term(n, x, *previous_terms):
333         if n == 0:
334             return S.One
335         elif n < 0 or n % 2 == 0:
336             return S.Zero
337         else:
338             x = sympify(x)
339             k = floor((n - 1)/S(2))
340             if len(previous_terms) > 2:
341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
342             else:
343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
344 
345     def _eval_conjugate(self):
346         return self.func(self.args[0].conjugate())
347 
348     def _eval_is_real(self):
349         return self.args[0].is_real
350 
351     def _eval_rewrite_as_tractable(self, z):
352         return self.rewrite(erf).rewrite("tractable", deep=True)
353 
354     def _eval_rewrite_as_erf(self, z):
355         return S.One - erf(z)
356 
357     def _eval_rewrite_as_erfi(self, z):
358         return S.One + I*erfi(I*z)
359 
360     def _eval_rewrite_as_fresnels(self, z):
361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
363 
364     def _eval_rewrite_as_fresnelc(self, z):
365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)
366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
367 
368     def _eval_rewrite_as_meijerg(self, z):
369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
370 
371     def _eval_rewrite_as_hyper(self, z):
372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
373 
374     def _eval_rewrite_as_uppergamma(self, z):
375         from sympy import uppergamma
376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
377 
378     def _eval_rewrite_as_expint(self, z):
379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)
380 
381     def _eval_as_leading_term(self, x):
382         from sympy import Order
383         arg = self.args[0].as_leading_term(x)
384 
385         if x in arg.free_symbols and Order(1, x).contains(arg):
386             return S.One
387         else:
388             return self.func(arg)
389 
390     def as_real_imag(self, deep=True, **hints):
391         if self.args[0].is_real:
392             if deep:
393                 hints['complex'] = False
394                 return (self.expand(deep, **hints), S.Zero)
395             else:
396                 return (self, S.Zero)
397         if deep:
398             x, y = self.args[0].expand(deep, **hints).as_real_imag()
399         else:
400             x, y = self.args[0].as_real_imag()
401 
402         sq = -y**2/x**2
403         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
404         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
405                     self.func(x + x*sqrt(sq)))
406         return (re, im)
407 
408 class erfi(Function):
409     r"""
410     Imaginary error function. The function erfi is defined as:
411 
412     .. math ::
413         \mathrm{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{t^2} \mathrm{d}t
414 
415     Examples
416     ========
417 
418     >>> from sympy import I, oo, erfi
419     >>> from sympy.abc import z
420 
421     Several special values are known:
422 
423     >>> erfi(0)
424     0
425     >>> erfi(oo)
426     oo
427     >>> erfi(-oo)
428     -oo
429     >>> erfi(I*oo)
430     I
431     >>> erfi(-I*oo)
432     -I
433 
434     In general one can pull out factors of -1 and I from the argument:
435 
436     >>> erfi(-z)
437     -erfi(z)
438 
439     >>> from sympy import conjugate
440     >>> conjugate(erfi(z))
441     erfi(conjugate(z))
442 
443     Differentiation with respect to z is supported:
444 
445     >>> from sympy import diff
446     >>> diff(erfi(z), z)
447     2*exp(z**2)/sqrt(pi)
448 
449     We can numerically evaluate the imaginary error function to arbitrary precision
450     on the whole complex plane:
451 
452     >>> erfi(2).evalf(30)
453     18.5648024145755525987042919132
454 
455     >>> erfi(-2*I).evalf(30)
456     -0.995322265018952734162069256367*I
457 
458     See Also
459     ========
460 
461     erf: Gaussian error function.
462     erfc: Complementary error function.
463     erf2: Two-argument error function.
464     erfinv: Inverse error function.
465     erfcinv: Inverse Complementary error function.
466     erf2inv: Inverse two-argument error function.
467 
468     References
469     ==========
470 
471     .. [1] http://en.wikipedia.org/wiki/Error_function
472     .. [2] http://mathworld.wolfram.com/Erfi.html
473     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi
474     """
475 
476     unbranched = True
477 
478     def fdiff(self, argindex=1):
479         if argindex == 1:
480             return 2*exp(self.args[0]**2)/sqrt(S.Pi)
481         else:
482             raise ArgumentIndexError(self, argindex)
483 
484     @classmethod
485     def eval(cls, z):
486         if z.is_Number:
487             if z is S.NaN:
488                 return S.NaN
489             elif z is S.Zero:
490                 return S.Zero
491             elif z is S.Infinity:
492                 return S.Infinity
493 
494         # Try to pull out factors of -1
495         if z.could_extract_minus_sign():
496             return -cls(-z)
497 
498         # Try to pull out factors of I
499         nz = z.extract_multiplicatively(I)
500         if nz is not None:
501             if nz is S.Infinity:
502                 return I
503             if nz.func is erfinv:
504                 return I*nz.args[0]
505             if nz.func is erfcinv:
506                 return I*(S.One - nz.args[0])
507             if nz.func is erf2inv and nz.args[0] is S.Zero:
508                 return I*nz.args[1]
509 
510     @staticmethod
511     @cacheit
512     def taylor_term(n, x, *previous_terms):
513         if n < 0 or n % 2 == 0:
514             return S.Zero
515         else:
516             x = sympify(x)
517             k = floor((n - 1)/S(2))
518             if len(previous_terms) > 2:
519                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)
520             else:
521                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))
522 
523     def _eval_conjugate(self):
524         return self.func(self.args[0].conjugate())
525 
526     def _eval_is_real(self):
527         return self.args[0].is_real
528 
529     def _eval_rewrite_as_tractable(self, z):
530         return self.rewrite(erf).rewrite("tractable", deep=True)
531 
532     def _eval_rewrite_as_erf(self, z):
533         return -I*erf(I*z)
534 
535     def _eval_rewrite_as_erfc(self, z):
536         return I*erfc(I*z) - I
537 
538     def _eval_rewrite_as_fresnels(self, z):
539         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
540         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
541 
542     def _eval_rewrite_as_fresnelc(self, z):
543         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
544         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
545 
546     def _eval_rewrite_as_meijerg(self, z):
547         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)
548 
549     def _eval_rewrite_as_hyper(self, z):
550         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)
551 
552     def _eval_rewrite_as_uppergamma(self, z):
553         from sympy import uppergamma
554         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)
555 
556     def _eval_rewrite_as_expint(self, z):
557         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)
558 
559     def as_real_imag(self, deep=True, **hints):
560         if self.args[0].is_real:
561             if deep:
562                 hints['complex'] = False
563                 return (self.expand(deep, **hints), S.Zero)
564             else:
565                 return (self, S.Zero)
566         if deep:
567             x, y = self.args[0].expand(deep, **hints).as_real_imag()
568         else:
569             x, y = self.args[0].as_real_imag()
570 
571         sq = -y**2/x**2
572         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
573         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
574                     self.func(x + x*sqrt(sq)))
575         return (re, im)
576 
577 class erf2(Function):
578     r"""
579     Two-argument error function. This function is defined as:
580 
581     .. math ::
582         \mathrm{erf2}(x, y) = \frac{2}{\sqrt{\pi}} \int_x^y e^{-t^2} \mathrm{d}t
583 
584     Examples
585     ========
586 
587     >>> from sympy import I, oo, erf2
588     >>> from sympy.abc import x, y
589 
590     Several special values are known:
591 
592     >>> erf2(0, 0)
593     0
594     >>> erf2(x, x)
595     0
596     >>> erf2(x, oo)
597     -erf(x) + 1
598     >>> erf2(x, -oo)
599     -erf(x) - 1
600     >>> erf2(oo, y)
601     erf(y) - 1
602     >>> erf2(-oo, y)
603     erf(y) + 1
604 
605     In general one can pull out factors of -1:
606 
607     >>> erf2(-x, -y)
608     -erf2(x, y)
609 
610     The error function obeys the mirror symmetry:
611 
612     >>> from sympy import conjugate
613     >>> conjugate(erf2(x, y))
614     erf2(conjugate(x), conjugate(y))
615 
616     Differentiation with respect to x, y is supported:
617 
618     >>> from sympy import diff
619     >>> diff(erf2(x, y), x)
620     -2*exp(-x**2)/sqrt(pi)
621     >>> diff(erf2(x, y), y)
622     2*exp(-y**2)/sqrt(pi)
623 
624     See Also
625     ========
626 
627     erf: Gaussian error function.
628     erfc: Complementary error function.
629     erfi: Imaginary error function.
630     erfinv: Inverse error function.
631     erfcinv: Inverse Complementary error function.
632     erf2inv: Inverse two-argument error function.
633 
634     References
635     ==========
636 
637     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/
638     """
639 
640 
641     def fdiff(self, argindex):
642         x, y = self.args
643         if argindex == 1:
644             return -2*exp(-x**2)/sqrt(S.Pi)
645         elif argindex == 2:
646             return 2*exp(-y**2)/sqrt(S.Pi)
647         else:
648             raise ArgumentIndexError(self, argindex)
649 
650     @classmethod
651     def eval(cls, x, y):
652         I = S.Infinity
653         N = S.NegativeInfinity
654         O = S.Zero
655         if x is S.NaN or y is S.NaN:
656             return S.NaN
657         elif x == y:
658             return S.Zero
659         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):
660             return erf(y) - erf(x)
661 
662         if y.func is erf2inv and y.args[0] == x:
663             return y.args[1]
664 
665         #Try to pull out -1 factor
666         sign_x = x.could_extract_minus_sign()
667         sign_y = y.could_extract_minus_sign()
668         if (sign_x and sign_y):
669             return -cls(-x, -y)
670         elif (sign_x or sign_y):
671             return erf(y)-erf(x)
672 
673     def _eval_conjugate(self):
674         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
675 
676     def _eval_is_real(self):
677         return self.args[0].is_real and self.args[1].is_real
678 
679     def _eval_rewrite_as_erf(self, x, y):
680         return erf(y) - erf(x)
681 
682     def _eval_rewrite_as_erfc(self, x, y):
683         return erfc(x) - erfc(y)
684 
685     def _eval_rewrite_as_erfi(self, x, y):
686         return I*(erfi(I*x)-erfi(I*y))
687 
688     def _eval_rewrite_as_fresnels(self, x, y):
689         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)
690 
691     def _eval_rewrite_as_fresnelc(self, x, y):
692         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)
693 
694     def _eval_rewrite_as_meijerg(self, x, y):
695         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)
696 
697     def _eval_rewrite_as_hyper(self, x, y):
698         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)
699 
700     def _eval_rewrite_as_uppergamma(self, x, y):
701         from sympy import uppergamma
702         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -
703             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))
704 
705     def _eval_rewrite_as_expint(self, x, y):
706         return erf(y).rewrite(expint) - erf(x).rewrite(expint)
707 
708 class erfinv(Function):
709     r"""
710     Inverse Error Function. The erfinv function is defined as:
711 
712     .. math ::
713         \mathrm{erf}(x) = y \quad \Rightarrow \quad \mathrm{erfinv}(y) = x
714 
715     Examples
716     ========
717 
718     >>> from sympy import I, oo, erfinv
719     >>> from sympy.abc import x
720 
721     Several special values are known:
722 
723     >>> erfinv(0)
724     0
725     >>> erfinv(1)
726     oo
727 
728     Differentiation with respect to x is supported:
729 
730     >>> from sympy import diff
731     >>> diff(erfinv(x), x)
732     sqrt(pi)*exp(erfinv(x)**2)/2
733 
734     We can numerically evaluate the inverse error function to arbitrary precision
735     on [-1, 1]:
736 
737     >>> erfinv(0.2).evalf(30)
738     0.179143454621291692285822705344
739 
740     See Also
741     ========
742 
743     erf: Gaussian error function.
744     erfc: Complementary error function.
745     erfi: Imaginary error function.
746     erf2: Two-argument error function.
747     erfcinv: Inverse Complementary error function.
748     erf2inv: Inverse two-argument error function.
749 
750     References
751     ==========
752 
753     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions
754     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/
755     """
756 
757 
758     def fdiff(self, argindex =1):
759         if argindex == 1:
760             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
761         else :
762             raise ArgumentIndexError(self, argindex)
763 
764     def inverse(self, argindex=1):
765         """
766         Returns the inverse of this function.
767         """
768         return erf
769 
770     @classmethod
771     def eval(cls, z):
772         if z is S.NaN:
773             return S.NaN
774         elif z is S.NegativeOne:
775             return S.NegativeInfinity
776         elif z is S.Zero:
777             return S.Zero
778         elif z is S.One:
779             return S.Infinity
780 
781         if (z.func is erf) and z.args[0].is_real:
782             return z.args[0]
783 
784         # Try to pull out factors of -1
785         nz = z.extract_multiplicatively(-1)
786         if nz is not None and ((nz.func is erf) and (nz.args[0]).is_real):
787             return -nz.args[0]
788 
789     def _eval_rewrite_as_erfcinv(self, z):
790        return erfcinv(1-z)
791 
792 class erfcinv (Function):
793     r"""
794     Inverse Complementary Error Function. The erfcinv function is defined as:
795 
796     .. math ::
797         \mathrm{erfc}(x) = y \quad \Rightarrow \quad \mathrm{erfcinv}(y) = x
798 
799     Examples
800     ========
801 
802     >>> from sympy import I, oo, erfcinv
803     >>> from sympy.abc import x
804 
805     Several special values are known:
806 
807     >>> erfcinv(1)
808     0
809     >>> erfcinv(0)
810     oo
811 
812     Differentiation with respect to x is supported:
813 
814     >>> from sympy import diff
815     >>> diff(erfcinv(x), x)
816     -sqrt(pi)*exp(erfcinv(x)**2)/2
817 
818     See Also
819     ========
820 
821     erf: Gaussian error function.
822     erfc: Complementary error function.
823     erfi: Imaginary error function.
824     erf2: Two-argument error function.
825     erfinv: Inverse error function.
826     erf2inv: Inverse two-argument error function.
827 
828     References
829     ==========
830 
831     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions
832     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/
833     """
834 
835 
836     def fdiff(self, argindex =1):
837         if argindex == 1:
838             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
839         else:
840             raise ArgumentIndexError(self, argindex)
841 
842     def inverse(self, argindex=1):
843         """
844         Returns the inverse of this function.
845         """
846         return erfc
847 
848     @classmethod
849     def eval(cls, z):
850         if z is S.NaN:
851             return S.NaN
852         elif z is S.Zero:
853             return S.Infinity
854         elif z is S.One:
855             return S.Zero
856         elif z == 2:
857             return S.NegativeInfinity
858 
859     def _eval_rewrite_as_erfinv(self, z):
860         return erfinv(1-z)
861 
862 class erf2inv(Function):
863     r"""
864     Two-argument Inverse error function. The erf2inv function is defined as:
865 
866     .. math ::
867         \mathrm{erf2}(x, w) = y \quad \Rightarrow \quad \mathrm{erf2inv}(x, y) = w
868 
869     Examples
870     ========
871 
872     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv
873     >>> from sympy.abc import x, y
874 
875     Several special values are known:
876 
877     >>> erf2inv(0, 0)
878     0
879     >>> erf2inv(1, 0)
880     1
881     >>> erf2inv(0, 1)
882     oo
883     >>> erf2inv(0, y)
884     erfinv(y)
885     >>> erf2inv(oo, y)
886     erfcinv(-y)
887 
888     Differentiation with respect to x and y is supported:
889 
890     >>> from sympy import diff
891     >>> diff(erf2inv(x, y), x)
892     exp(-x**2 + erf2inv(x, y)**2)
893     >>> diff(erf2inv(x, y), y)
894     sqrt(pi)*exp(erf2inv(x, y)**2)/2
895 
896     See Also
897     ========
898 
899     erf: Gaussian error function.
900     erfc: Complementary error function.
901     erfi: Imaginary error function.
902     erf2: Two-argument error function.
903     erfinv: Inverse error function.
904     erfcinv: Inverse complementary error function.
905 
906     References
907     ==========
908 
909     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/
910     """
911 
912 
913     def fdiff(self, argindex):
914         x, y = self.args
915         if argindex == 1:
916             return exp(self.func(x,y)**2-x**2)
917         elif argindex == 2:
918             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)
919         else:
920             raise ArgumentIndexError(self, argindex)
921 
922     @classmethod
923     def eval(cls, x, y):
924         if x is S.NaN or y is S.NaN:
925             return S.NaN
926         elif x is S.Zero and y is S.Zero:
927             return S.Zero
928         elif x is S.Zero and y is S.One:
929             return S.Infinity
930         elif x is S.One and y is S.Zero:
931             return S.One
932         elif x is S.Zero:
933             return erfinv(y)
934         elif x is S.Infinity:
935             return erfcinv(-y)
936         elif y is S.Zero:
937             return x
938         elif y is S.Infinity:
939             return erfinv(x)
940 
941 
942 ###############################################################################
943 #################### EXPONENTIAL INTEGRALS ####################################
944 ###############################################################################
945 
946 class Ei(Function):
947     r"""
948     The classical exponential integral.
949 
950     For use in SymPy, this function is defined as
951 
952     .. math:: \operatorname{Ei}(x) = \sum_{n=1}^\infty \frac{x^n}{n\, n!}
953                                      + \log(x) + \gamma,
954 
955     where `\gamma` is the Euler-Mascheroni constant.
956 
957     If `x` is a polar number, this defines an analytic function on the
958     Riemann surface of the logarithm. Otherwise this defines an analytic
959     function in the cut plane `\mathbb{C} \setminus (-\infty, 0]`.
960 
961     **Background**
962 
963     The name *exponential integral* comes from the following statement:
964 
965     .. math:: \operatorname{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t
966 
967     If the integral is interpreted as a Cauchy principal value, this statement
968     holds for `x > 0` and `\operatorname{Ei}(x)` as defined above.
969 
970     Note that we carefully avoided defining `\operatorname{Ei}(x)` for
971     negative real `x`. This is because above integral formula does not hold for
972     any polar lift of such `x`, indeed all branches of
973     `\operatorname{Ei}(x)` above the negative reals are imaginary.
974 
975     However, the following statement holds for all `x \in \mathbb{R}^*`:
976 
977     .. math:: \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t =
978               \frac{\operatorname{Ei}\left(|x|e^{i \arg(x)}\right) +
979                     \operatorname{Ei}\left(|x|e^{- i \arg(x)}\right)}{2},
980 
981     where the integral is again understood to be a principal value if
982     `x > 0`, and `|x|e^{i \arg(x)}`,
983     `|x|e^{- i \arg(x)}` denote two conjugate polar lifts of `x`.
984 
985     Examples
986     ========
987 
988     >>> from sympy import Ei, polar_lift, exp_polar, I, pi
989     >>> from sympy.abc import x
990 
991     The exponential integral in SymPy is strictly undefined for negative values
992     of the argument. For convenience, exponential integrals with negative
993     arguments are immediately converted into an expression that agrees with
994     the classical integral definition:
995 
996     >>> Ei(-1)
997     -I*pi + Ei(exp_polar(I*pi))
998 
999     This yields a real value:
1000 
1001     >>> Ei(-1).n(chop=True)
1002     -0.219383934395520
1003 
1004     On the other hand the analytic continuation is not real:
1005 
1006     >>> Ei(polar_lift(-1)).n(chop=True)
1007     -0.21938393439552 + 3.14159265358979*I
1008 
1009     The exponential integral has a logarithmic branch point at the origin:
1010 
1011     >>> Ei(x*exp_polar(2*I*pi))
1012     Ei(x) + 2*I*pi
1013 
1014     Differentiation is supported:
1015 
1016     >>> Ei(x).diff(x)
1017     exp(x)/x
1018 
1019     The exponential integral is related to many other special functions.
1020     For example:
1021 
1022     >>> from sympy import uppergamma, expint, Shi
1023     >>> Ei(x).rewrite(expint)
1024     -expint(1, x*exp_polar(I*pi)) - I*pi
1025     >>> Ei(x).rewrite(Shi)
1026     Chi(x) + Shi(x)
1027 
1028     See Also
1029     ========
1030 
1031     expint: Generalised exponential integral.
1032     E1: Special case of the generalised exponential integral.
1033     li: Logarithmic integral.
1034     Li: Offset logarithmic integral.
1035     Si: Sine integral.
1036     Ci: Cosine integral.
1037     Shi: Hyperbolic sine integral.
1038     Chi: Hyperbolic cosine integral.
1039     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.
1040 
1041     References
1042     ==========
1043 
1044     .. [1] http://dlmf.nist.gov/6.6
1045     .. [2] http://en.wikipedia.org/wiki/Exponential_integral
1046     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm
1047 
1048     """
1049 
1050 
1051     @classmethod
1052     def eval(cls, z):
1053         if z is S.Zero:
1054             return S.NegativeInfinity
1055         elif z is S.Infinity:
1056             return S.Infinity
1057         elif z is S.NegativeInfinity:
1058             return S.Zero
1059 
1060         if not z.is_polar and z.is_negative:
1061             # Note: is this a good idea?
1062             return Ei(polar_lift(z)) - pi*I
1063         nz, n = z.extract_branch_factor()
1064         if n:
1065             return Ei(nz) + 2*I*pi*n
1066 
1067     def fdiff(self, argindex=1):
1068         from sympy import unpolarify
1069         arg = unpolarify(self.args[0])
1070         if argindex == 1:
1071             return exp(arg)/arg
1072         else:
1073             raise ArgumentIndexError(self, argindex)
1074 
1075     def _eval_evalf(self, prec):
1076         if (self.args[0]/polar_lift(-1)).is_positive:
1077             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)
1078         return Function._eval_evalf(self, prec)
1079 
1080     def _eval_rewrite_as_uppergamma(self, z):
1081         from sympy import uppergamma
1082         # XXX this does not currently work usefully because uppergamma
1083         #     immediately turns into expint
1084         return -uppergamma(0, polar_lift(-1)*z) - I*pi
1085 
1086     def _eval_rewrite_as_expint(self, z):
1087         return -expint(1, polar_lift(-1)*z) - I*pi
1088 
1089     def _eval_rewrite_as_li(self, z):
1090         if isinstance(z, log):
1091             return li(z.args[0])
1092         # TODO:
1093         # Actually it only holds that:
1094         #  Ei(z) = li(exp(z))
1095         # for -pi < imag(z) <= pi
1096         return li(exp(z))
1097 
1098     def _eval_rewrite_as_Si(self, z):
1099         return Shi(z) + Chi(z)
1100     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1101     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1102     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1103 
1104     def _eval_rewrite_as_tractable(self, z):
1105         return exp(z) * _eis(z)
1106 
1107     def _eval_nseries(self, x, n, logx):
1108         x0 = self.args[0].limit(x, 0)
1109         if x0 is S.Zero:
1110             f = self._eval_rewrite_as_Si(*self.args)
1111             return f._eval_nseries(x, n, logx)
1112         return super(Ei, self)._eval_nseries(x, n, logx)
1113 
1114 
1115 class expint(Function):
1116     r"""
1117     Generalized exponential integral.
1118 
1119     This function is defined as
1120 
1121     .. math:: \operatorname{E}_\nu(z) = z^{\nu - 1} \Gamma(1 - \nu, z),
1122 
1123     where `\Gamma(1 - \nu, z)` is the upper incomplete gamma function
1124     (``uppergamma``).
1125 
1126     Hence for :math:`z` with positive real part we have
1127 
1128     .. math:: \operatorname{E}_\nu(z)
1129               =   \int_1^\infty \frac{e^{-zt}}{z^\nu} \mathrm{d}t,
1130 
1131     which explains the name.
1132 
1133     The representation as an incomplete gamma function provides an analytic
1134     continuation for :math:`\operatorname{E}_\nu(z)`. If :math:`\nu` is a
1135     non-positive integer the exponential integral is thus an unbranched
1136     function of :math:`z`, otherwise there is a branch point at the origin.
1137     Refer to the incomplete gamma function documentation for details of the
1138     branching behavior.
1139 
1140     Examples
1141     ========
1142 
1143     >>> from sympy import expint, S
1144     >>> from sympy.abc import nu, z
1145 
1146     Differentiation is supported. Differentiation with respect to z explains
1147     further the name: for integral orders, the exponential integral is an
1148     iterated integral of the exponential function.
1149 
1150     >>> expint(nu, z).diff(z)
1151     -expint(nu - 1, z)
1152 
1153     Differentiation with respect to nu has no classical expression:
1154 
1155     >>> expint(nu, z).diff(nu)
1156     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, -nu + 1), ()), z)
1157 
1158     At non-postive integer orders, the exponential integral reduces to the
1159     exponential function:
1160 
1161     >>> expint(0, z)
1162     exp(-z)/z
1163     >>> expint(-1, z)
1164     exp(-z)/z + exp(-z)/z**2
1165 
1166     At half-integers it reduces to error functions:
1167 
1168     >>> expint(S(1)/2, z)
1169     sqrt(pi)*erfc(sqrt(z))/sqrt(z)
1170 
1171     At positive integer orders it can be rewritten in terms of exponentials
1172     and expint(1, z). Use expand_func() to do this:
1173 
1174     >>> from sympy import expand_func
1175     >>> expand_func(expint(5, z))
1176     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24
1177 
1178     The generalised exponential integral is essentially equivalent to the
1179     incomplete gamma function:
1180 
1181     >>> from sympy import uppergamma
1182     >>> expint(nu, z).rewrite(uppergamma)
1183     z**(nu - 1)*uppergamma(-nu + 1, z)
1184 
1185     As such it is branched at the origin:
1186 
1187     >>> from sympy import exp_polar, pi, I
1188     >>> expint(4, z*exp_polar(2*pi*I))
1189     I*pi*z**3/3 + expint(4, z)
1190     >>> expint(nu, z*exp_polar(2*pi*I))
1191     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(-nu + 1) + expint(nu, z)
1192 
1193     See Also
1194     ========
1195 
1196     Ei: Another related function called exponential integral.
1197     E1: The classical case, returns expint(1, z).
1198     li: Logarithmic integral.
1199     Li: Offset logarithmic integral.
1200     Si: Sine integral.
1201     Ci: Cosine integral.
1202     Shi: Hyperbolic sine integral.
1203     Chi: Hyperbolic cosine integral.
1204     sympy.functions.special.gamma_functions.uppergamma
1205 
1206     References
1207     ==========
1208 
1209     .. [1] http://dlmf.nist.gov/8.19
1210     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/
1211     .. [3] http://en.wikipedia.org/wiki/Exponential_integral
1212 
1213     """
1214 
1215 
1216     @classmethod
1217     def eval(cls, nu, z):
1218         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,
1219                            factorial)
1220         nu2 = unpolarify(nu)
1221         if nu != nu2:
1222             return expint(nu2, z)
1223         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):
1224             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))
1225 
1226         # Extract branching information. This can be deduced from what is
1227         # explained in lowergamma.eval().
1228         z, n = z.extract_branch_factor()
1229         if n == 0:
1230             return
1231         if nu.is_integer:
1232             if (nu > 0) != True:
1233                 return
1234             return expint(nu, z) \
1235                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)
1236         else:
1237             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)
1238 
1239     def fdiff(self, argindex):
1240         from sympy import meijerg
1241         nu, z = self.args
1242         if argindex == 1:
1243             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)
1244         elif argindex == 2:
1245             return -expint(nu - 1, z)
1246         else:
1247             raise ArgumentIndexError(self, argindex)
1248 
1249     def _eval_rewrite_as_uppergamma(self, nu, z):
1250         from sympy import uppergamma
1251         return z**(nu - 1)*uppergamma(1 - nu, z)
1252 
1253     def _eval_rewrite_as_Ei(self, nu, z):
1254         from sympy import exp_polar, unpolarify, exp, factorial
1255         if nu == 1:
1256             return -Ei(z*exp_polar(-I*pi)) - I*pi
1257         elif nu.is_Integer and nu > 1:
1258             # DLMF, 8.19.7
1259             x = -unpolarify(z)
1260             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \
1261                 exp(x)/factorial(nu - 1) * \
1262                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])
1263         else:
1264             return self
1265 
1266     def _eval_expand_func(self, **hints):
1267         return self.rewrite(Ei).rewrite(expint, **hints)
1268 
1269     def _eval_rewrite_as_Si(self, nu, z):
1270         if nu != 1:
1271             return self
1272         return Shi(z) - Chi(z)
1273     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1274     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1275     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1276 
1277     def _eval_nseries(self, x, n, logx):
1278         if not self.args[0].has(x):
1279             nu = self.args[0]
1280             if nu == 1:
1281                 f = self._eval_rewrite_as_Si(*self.args)
1282                 return f._eval_nseries(x, n, logx)
1283             elif nu.is_Integer and nu > 1:
1284                 f = self._eval_rewrite_as_Ei(*self.args)
1285                 return f._eval_nseries(x, n, logx)
1286         return super(expint, self)._eval_nseries(x, n, logx)
1287 
1288     def _sage_(self):
1289         import sage.all as sage
1290         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())
1291 
1292 
1293 def E1(z):
1294     """
1295     Classical case of the generalized exponential integral.
1296 
1297     This is equivalent to ``expint(1, z)``.
1298 
1299     See Also
1300     ========
1301 
1302     Ei: Exponential integral.
1303     expint: Generalised exponential integral.
1304     li: Logarithmic integral.
1305     Li: Offset logarithmic integral.
1306     Si: Sine integral.
1307     Ci: Cosine integral.
1308     Shi: Hyperbolic sine integral.
1309     Chi: Hyperbolic cosine integral.
1310     """
1311     return expint(1, z)
1312 
1313 
1314 class li(Function):
1315     r"""
1316     The classical logarithmic integral.
1317 
1318     For the use in SymPy, this function is defined as
1319 
1320     .. math:: \operatorname{li}(x) = \int_0^x \frac{1}{\log(t)} \mathrm{d}t \,.
1321 
1322     Examples
1323     ========
1324 
1325     >>> from sympy import I, oo, li
1326     >>> from sympy.abc import z
1327 
1328     Several special values are known:
1329 
1330     >>> li(0)
1331     0
1332     >>> li(1)
1333     -oo
1334     >>> li(oo)
1335     oo
1336 
1337     Differentiation with respect to z is supported:
1338 
1339     >>> from sympy import diff
1340     >>> diff(li(z), z)
1341     1/log(z)
1342 
1343     Defining the `li` function via an integral:
1344 
1345 
1346     The logarithmic integral can also be defined in terms of Ei:
1347 
1348     >>> from sympy import Ei
1349     >>> li(z).rewrite(Ei)
1350     Ei(log(z))
1351     >>> diff(li(z).rewrite(Ei), z)
1352     1/log(z)
1353 
1354     We can numerically evaluate the logarithmic integral to arbitrary precision
1355     on the whole complex plane (except the singular points):
1356 
1357     >>> li(2).evalf(30)
1358     1.04516378011749278484458888919
1359 
1360     >>> li(2*I).evalf(30)
1361     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I
1362 
1363     We can even compute Soldner's constant by the help of mpmath:
1364 
1365     >>> from mpmath import findroot
1366     >>> findroot(li, 2)
1367     1.45136923488338
1368 
1369     Further transformations include rewriting `li` in terms of
1370     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:
1371 
1372     >>> from sympy import Si, Ci, Shi, Chi
1373     >>> li(z).rewrite(Si)
1374     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1375     >>> li(z).rewrite(Ci)
1376     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1377     >>> li(z).rewrite(Shi)
1378     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1379     >>> li(z).rewrite(Chi)
1380     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1381 
1382     See Also
1383     ========
1384 
1385     Li: Offset logarithmic integral.
1386     Ei: Exponential integral.
1387     expint: Generalised exponential integral.
1388     E1: Special case of the generalised exponential integral.
1389     Si: Sine integral.
1390     Ci: Cosine integral.
1391     Shi: Hyperbolic sine integral.
1392     Chi: Hyperbolic cosine integral.
1393 
1394     References
1395     ==========
1396 
1397     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral
1398     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1399     .. [3] http://dlmf.nist.gov/6
1400     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html
1401     """
1402 
1403 
1404     @classmethod
1405     def eval(cls, z):
1406         if z is S.Zero:
1407             return S.Zero
1408         elif z is S.One:
1409             return S.NegativeInfinity
1410         elif z is S.Infinity:
1411             return S.Infinity
1412 
1413     def fdiff(self, argindex=1):
1414         arg = self.args[0]
1415         if argindex == 1:
1416             return S.One / log(arg)
1417         else:
1418             raise ArgumentIndexError(self, argindex)
1419 
1420     def _eval_conjugate(self):
1421         z = self.args[0]
1422         # Exclude values on the branch cut (-oo, 0)
1423         if not (z.is_real and z.is_negative):
1424             return self.func(z.conjugate())
1425 
1426     def _eval_rewrite_as_Li(self, z):
1427         return Li(z) + li(2)
1428 
1429     def _eval_rewrite_as_Ei(self, z):
1430         return Ei(log(z))
1431 
1432     def _eval_rewrite_as_uppergamma(self, z):
1433         from sympy import uppergamma
1434         return (-uppergamma(0, -log(z)) +
1435                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))
1436 
1437     def _eval_rewrite_as_Si(self, z):
1438         return (Ci(I*log(z)) - I*Si(I*log(z)) -
1439                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))
1440 
1441     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1442 
1443     def _eval_rewrite_as_Shi(self, z):
1444         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))
1445 
1446     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi
1447 
1448     def _eval_rewrite_as_hyper(self, z):
1449         return (log(z)*hyper((1, 1), (2, 2), log(z)) +
1450                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)
1451 
1452     def _eval_rewrite_as_meijerg(self, z):
1453         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))
1454                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))
1455 
1456     def _eval_rewrite_as_tractable(self, z):
1457         return z * _eis(log(z))
1458 
1459 
1460 class Li(Function):
1461     r"""
1462     The offset logarithmic integral.
1463 
1464     For the use in SymPy, this function is defined as
1465 
1466     .. math:: \operatorname{Li}(x) = \operatorname{li}(x) - \operatorname{li}(2)
1467 
1468     Examples
1469     ========
1470 
1471     >>> from sympy import I, oo, Li
1472     >>> from sympy.abc import z
1473 
1474     The following special value is known:
1475 
1476     >>> Li(2)
1477     0
1478 
1479     Differentiation with respect to z is supported:
1480 
1481     >>> from sympy import diff
1482     >>> diff(Li(z), z)
1483     1/log(z)
1484 
1485     The shifted logarithmic integral can be written in terms of `li(z)`:
1486 
1487     >>> from sympy import li
1488     >>> Li(z).rewrite(li)
1489     li(z) - li(2)
1490 
1491     We can numerically evaluate the logarithmic integral to arbitrary precision
1492     on the whole complex plane (except the singular points):
1493 
1494     >>> Li(2).evalf(30)
1495     0
1496 
1497     >>> Li(4).evalf(30)
1498     1.92242131492155809316615998938
1499 
1500     See Also
1501     ========
1502 
1503     li: Logarithmic integral.
1504     Ei: Exponential integral.
1505     expint: Generalised exponential integral.
1506     E1: Special case of the generalised exponential integral.
1507     Si: Sine integral.
1508     Ci: Cosine integral.
1509     Shi: Hyperbolic sine integral.
1510     Chi: Hyperbolic cosine integral.
1511 
1512     References
1513     ==========
1514 
1515     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral
1516     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1517     .. [3] http://dlmf.nist.gov/6
1518     """
1519 
1520 
1521     @classmethod
1522     def eval(cls, z):
1523         if z is S.Infinity:
1524             return S.Infinity
1525         elif z is 2*S.One:
1526             return S.Zero
1527 
1528     def fdiff(self, argindex=1):
1529         arg = self.args[0]
1530         if argindex == 1:
1531             return S.One / log(arg)
1532         else:
1533             raise ArgumentIndexError(self, argindex)
1534 
1535     def _eval_evalf(self, prec):
1536         return self.rewrite(li).evalf(prec)
1537 
1538     def _eval_rewrite_as_li(self, z):
1539         return li(z) - li(2)
1540 
1541     def _eval_rewrite_as_tractable(self, z):
1542         return self.rewrite(li).rewrite("tractable", deep=True)
1543 
1544 ###############################################################################
1545 #################### TRIGONOMETRIC INTEGRALS ##################################
1546 ###############################################################################
1547 
1548 class TrigonometricIntegral(Function):
1549     """ Base class for trigonometric integrals. """
1550 
1551 
1552     @classmethod
1553     def eval(cls, z):
1554         if z == 0:
1555             return cls._atzero
1556         elif z is S.Infinity:
1557             return cls._atinf()
1558         elif z is S.NegativeInfinity:
1559             return cls._atneginf()
1560 
1561         nz = z.extract_multiplicatively(polar_lift(I))
1562         if nz is None and cls._trigfunc(0) == 0:
1563             nz = z.extract_multiplicatively(I)
1564         if nz is not None:
1565             return cls._Ifactor(nz, 1)
1566         nz = z.extract_multiplicatively(polar_lift(-I))
1567         if nz is not None:
1568             return cls._Ifactor(nz, -1)
1569 
1570         nz = z.extract_multiplicatively(polar_lift(-1))
1571         if nz is None and cls._trigfunc(0) == 0:
1572             nz = z.extract_multiplicatively(-1)
1573         if nz is not None:
1574             return cls._minusfactor(nz)
1575 
1576         nz, n = z.extract_branch_factor()
1577         if n == 0 and nz == z:
1578             return
1579         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)
1580 
1581     def fdiff(self, argindex=1):
1582         from sympy import unpolarify
1583         arg = unpolarify(self.args[0])
1584         if argindex == 1:
1585             return self._trigfunc(arg)/arg
1586 
1587     def _eval_rewrite_as_Ei(self, z):
1588         return self._eval_rewrite_as_expint(z).rewrite(Ei)
1589 
1590     def _eval_rewrite_as_uppergamma(self, z):
1591         from sympy import uppergamma
1592         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)
1593 
1594     def _eval_nseries(self, x, n, logx):
1595         # NOTE this is fairly inefficient
1596         from sympy import log, EulerGamma, Pow
1597         n += 1
1598         if self.args[0].subs(x, 0) != 0:
1599             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)
1600         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)
1601         if self._trigfunc(0) != 0:
1602             baseseries -= 1
1603         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)
1604         if self._trigfunc(0) != 0:
1605             baseseries += EulerGamma + log(x)
1606         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)
1607 
1608 
1609 class Si(TrigonometricIntegral):
1610     r"""
1611     Sine integral.
1612 
1613     This function is defined by
1614 
1615     .. math:: \operatorname{Si}(z) = \int_0^z \frac{\sin{t}}{t} \mathrm{d}t.
1616 
1617     It is an entire function.
1618 
1619     Examples
1620     ========
1621 
1622     >>> from sympy import Si
1623     >>> from sympy.abc import z
1624 
1625     The sine integral is an antiderivative of sin(z)/z:
1626 
1627     >>> Si(z).diff(z)
1628     sin(z)/z
1629 
1630     It is unbranched:
1631 
1632     >>> from sympy import exp_polar, I, pi
1633     >>> Si(z*exp_polar(2*I*pi))
1634     Si(z)
1635 
1636     Sine integral behaves much like ordinary sine under multiplication by ``I``:
1637 
1638     >>> Si(I*z)
1639     I*Shi(z)
1640     >>> Si(-z)
1641     -Si(z)
1642 
1643     It can also be expressed in terms of exponential integrals, but beware
1644     that the latter is branched:
1645 
1646     >>> from sympy import expint
1647     >>> Si(z).rewrite(expint)
1648     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +
1649          expint(1, z*exp_polar(I*pi/2))/2) + pi/2
1650 
1651     It can be rewritten in the form of sinc function (By definition)
1652 
1653     >>> from sympy import sinc
1654     >>> Si(z).rewrite(sinc)
1655     Integral(sinc(t), (t, 0, z))
1656 
1657     See Also
1658     ========
1659 
1660     Ci: Cosine integral.
1661     Shi: Hyperbolic sine integral.
1662     Chi: Hyperbolic cosine integral.
1663     Ei: Exponential integral.
1664     expint: Generalised exponential integral.
1665     sinc: unnormalized sinc function
1666     E1: Special case of the generalised exponential integral.
1667     li: Logarithmic integral.
1668     Li: Offset logarithmic integral.
1669 
1670     References
1671     ==========
1672 
1673     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1674 
1675     """
1676 
1677     _trigfunc = sin
1678     _atzero = S(0)
1679 
1680     @classmethod
1681     def _atinf(cls):
1682         return pi*S.Half
1683 
1684     @classmethod
1685     def _atneginf(cls):
1686         return -pi*S.Half
1687 
1688     @classmethod
1689     def _minusfactor(cls, z):
1690         return -Si(z)
1691 
1692     @classmethod
1693     def _Ifactor(cls, z, sign):
1694         return I*Shi(z)*sign
1695 
1696     def _eval_rewrite_as_expint(self, z):
1697         # XXX should we polarify z?
1698         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I
1699 
1700     def _eval_rewrite_as_sinc(self, z):
1701         from sympy import Integral
1702         t = Symbol('t', Dummy=True)
1703         return Integral(sinc(t), (t, 0, z))
1704 
1705     def _sage_(self):
1706         import sage.all as sage
1707         return sage.sin_integral(self.args[0]._sage_())
1708 
1709 class Ci(TrigonometricIntegral):
1710     r"""
1711     Cosine integral.
1712 
1713     This function is defined for positive `x` by
1714 
1715     .. math:: \operatorname{Ci}(x) = \gamma + \log{x}
1716                          + \int_0^x \frac{\cos{t} - 1}{t} \mathrm{d}t
1717            = -\int_x^\infty \frac{\cos{t}}{t} \mathrm{d}t,
1718 
1719     where `\gamma` is the Euler-Mascheroni constant.
1720 
1721     We have
1722 
1723     .. math:: \operatorname{Ci}(z) =
1724         -\frac{\operatorname{E}_1\left(e^{i\pi/2} z\right)
1725                + \operatorname{E}_1\left(e^{-i \pi/2} z\right)}{2}
1726 
1727     which holds for all polar `z` and thus provides an analytic
1728     continuation to the Riemann surface of the logarithm.
1729 
1730     The formula also holds as stated
1731     for `z \in \mathbb{C}` with `\Re(z) > 0`.
1732     By lifting to the principal branch we obtain an analytic function on the
1733     cut complex plane.
1734 
1735     Examples
1736     ========
1737 
1738     >>> from sympy import Ci
1739     >>> from sympy.abc import z
1740 
1741     The cosine integral is a primitive of `\cos(z)/z`:
1742 
1743     >>> Ci(z).diff(z)
1744     cos(z)/z
1745 
1746     It has a logarithmic branch point at the origin:
1747 
1748     >>> from sympy import exp_polar, I, pi
1749     >>> Ci(z*exp_polar(2*I*pi))
1750     Ci(z) + 2*I*pi
1751 
1752     The cosine integral behaves somewhat like ordinary `\cos` under multiplication by `i`:
1753 
1754     >>> from sympy import polar_lift
1755     >>> Ci(polar_lift(I)*z)
1756     Chi(z) + I*pi/2
1757     >>> Ci(polar_lift(-1)*z)
1758     Ci(z) + I*pi
1759 
1760     It can also be expressed in terms of exponential integrals:
1761 
1762     >>> from sympy import expint
1763     >>> Ci(z).rewrite(expint)
1764     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2
1765 
1766     See Also
1767     ========
1768 
1769     Si: Sine integral.
1770     Shi: Hyperbolic sine integral.
1771     Chi: Hyperbolic cosine integral.
1772     Ei: Exponential integral.
1773     expint: Generalised exponential integral.
1774     E1: Special case of the generalised exponential integral.
1775     li: Logarithmic integral.
1776     Li: Offset logarithmic integral.
1777 
1778     References
1779     ==========
1780 
1781     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1782 
1783     """
1784 
1785     _trigfunc = cos
1786     _atzero = S.ComplexInfinity
1787 
1788     @classmethod
1789     def _atinf(cls):
1790         return S.Zero
1791 
1792     @classmethod
1793     def _atneginf(cls):
1794         return I*pi
1795 
1796     @classmethod
1797     def _minusfactor(cls, z):
1798         return Ci(z) + I*pi
1799 
1800     @classmethod
1801     def _Ifactor(cls, z, sign):
1802         return Chi(z) + I*pi/2*sign
1803 
1804     def _eval_rewrite_as_expint(self, z):
1805         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2
1806 
1807     def _sage_(self):
1808         import sage.all as sage
1809         return sage.cos_integral(self.args[0]._sage_())
1810 
1811 
1812 class Shi(TrigonometricIntegral):
1813     r"""
1814     Sinh integral.
1815 
1816     This function is defined by
1817 
1818     .. math:: \operatorname{Shi}(z) = \int_0^z \frac{\sinh{t}}{t} \mathrm{d}t.
1819 
1820     It is an entire function.
1821 
1822     Examples
1823     ========
1824 
1825     >>> from sympy import Shi
1826     >>> from sympy.abc import z
1827 
1828     The Sinh integral is a primitive of `\sinh(z)/z`:
1829 
1830     >>> Shi(z).diff(z)
1831     sinh(z)/z
1832 
1833     It is unbranched:
1834 
1835     >>> from sympy import exp_polar, I, pi
1836     >>> Shi(z*exp_polar(2*I*pi))
1837     Shi(z)
1838 
1839     The `\sinh` integral behaves much like ordinary `\sinh` under multiplication by `i`:
1840 
1841     >>> Shi(I*z)
1842     I*Si(z)
1843     >>> Shi(-z)
1844     -Shi(z)
1845 
1846     It can also be expressed in terms of exponential integrals, but beware
1847     that the latter is branched:
1848 
1849     >>> from sympy import expint
1850     >>> Shi(z).rewrite(expint)
1851     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1852 
1853     See Also
1854     ========
1855 
1856     Si: Sine integral.
1857     Ci: Cosine integral.
1858     Chi: Hyperbolic cosine integral.
1859     Ei: Exponential integral.
1860     expint: Generalised exponential integral.
1861     E1: Special case of the generalised exponential integral.
1862     li: Logarithmic integral.
1863     Li: Offset logarithmic integral.
1864 
1865     References
1866     ==========
1867 
1868     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1869 
1870     """
1871 
1872     _trigfunc = sinh
1873     _atzero = S(0)
1874 
1875     @classmethod
1876     def _atinf(cls):
1877         return S.Infinity
1878 
1879     @classmethod
1880     def _atneginf(cls):
1881         return S.NegativeInfinity
1882 
1883     @classmethod
1884     def _minusfactor(cls, z):
1885         return -Shi(z)
1886 
1887     @classmethod
1888     def _Ifactor(cls, z, sign):
1889         return I*Si(z)*sign
1890 
1891     def _eval_rewrite_as_expint(self, z):
1892         from sympy import exp_polar
1893         # XXX should we polarify z?
1894         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2
1895 
1896     def _sage_(self):
1897         import sage.all as sage
1898         return sage.sinh_integral(self.args[0]._sage_())
1899 
1900 
1901 class Chi(TrigonometricIntegral):
1902     r"""
1903     Cosh integral.
1904 
1905     This function is defined for positive :math:`x` by
1906 
1907     .. math:: \operatorname{Chi}(x) = \gamma + \log{x}
1908                          + \int_0^x \frac{\cosh{t} - 1}{t} \mathrm{d}t,
1909 
1910     where :math:`\gamma` is the Euler-Mascheroni constant.
1911 
1912     We have
1913 
1914     .. math:: \operatorname{Chi}(z) = \operatorname{Ci}\left(e^{i \pi/2}z\right)
1915                          - i\frac{\pi}{2},
1916 
1917     which holds for all polar :math:`z` and thus provides an analytic
1918     continuation to the Riemann surface of the logarithm.
1919     By lifting to the principal branch we obtain an analytic function on the
1920     cut complex plane.
1921 
1922     Examples
1923     ========
1924 
1925     >>> from sympy import Chi
1926     >>> from sympy.abc import z
1927 
1928     The `\cosh` integral is a primitive of `\cosh(z)/z`:
1929 
1930     >>> Chi(z).diff(z)
1931     cosh(z)/z
1932 
1933     It has a logarithmic branch point at the origin:
1934 
1935     >>> from sympy import exp_polar, I, pi
1936     >>> Chi(z*exp_polar(2*I*pi))
1937     Chi(z) + 2*I*pi
1938 
1939     The `\cosh` integral behaves somewhat like ordinary `\cosh` under multiplication by `i`:
1940 
1941     >>> from sympy import polar_lift
1942     >>> Chi(polar_lift(I)*z)
1943     Ci(z) + I*pi/2
1944     >>> Chi(polar_lift(-1)*z)
1945     Chi(z) + I*pi
1946 
1947     It can also be expressed in terms of exponential integrals:
1948 
1949     >>> from sympy import expint
1950     >>> Chi(z).rewrite(expint)
1951     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1952 
1953     See Also
1954     ========
1955 
1956     Si: Sine integral.
1957     Ci: Cosine integral.
1958     Shi: Hyperbolic sine integral.
1959     Ei: Exponential integral.
1960     expint: Generalised exponential integral.
1961     E1: Special case of the generalised exponential integral.
1962     li: Logarithmic integral.
1963     Li: Offset logarithmic integral.
1964 
1965     References
1966     ==========
1967 
1968     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1969 
1970     """
1971 
1972     _trigfunc = cosh
1973     _atzero = S.ComplexInfinity
1974 
1975     @classmethod
1976     def _atinf(cls):
1977         return S.Infinity
1978 
1979     @classmethod
1980     def _atneginf(cls):
1981         return S.Infinity
1982 
1983     @classmethod
1984     def _minusfactor(cls, z):
1985         return Chi(z) + I*pi
1986 
1987     @classmethod
1988     def _Ifactor(cls, z, sign):
1989         return Ci(z) + I*pi/2*sign
1990 
1991     def _eval_rewrite_as_expint(self, z):
1992         from sympy import exp_polar
1993         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2
1994 
1995     def _latex(self, printer, exp=None):
1996         if len(self.args) != 1:
1997             raise ValueError("Arg length should be 1")
1998         if exp:
1999             return r'\operatorname{Chi}^{%s}{\left (%s \right )}' \
2000                 % (printer._print(exp), printer._print(self.args[0]))
2001         else:
2002             return r'\operatorname{Chi}{\left (%s \right )}' \
2003                 % printer._print(self.args[0])
2004 
2005     @staticmethod
2006     def _latex_no_arg(printer):
2007         return r'\operatorname{Chi}'
2008 
2009     def _sage_(self):
2010         import sage.all as sage
2011         return sage.cosh_integral(self.args[0]._sage_())
2012 
2013 
2014 ###############################################################################
2015 #################### FRESNEL INTEGRALS ########################################
2016 ###############################################################################
2017 
2018 class FresnelIntegral(Function):
2019     """ Base class for the Fresnel integrals."""
2020 
2021     unbranched = True
2022 
2023     @classmethod
2024     def eval(cls, z):
2025         # Value at zero
2026         if z is S.Zero:
2027             return S(0)
2028 
2029         # Try to pull out factors of -1 and I
2030         prefact = S.One
2031         newarg = z
2032         changed = False
2033 
2034         nz = newarg.extract_multiplicatively(-1)
2035         if nz is not None:
2036             prefact = -prefact
2037             newarg = nz
2038             changed = True
2039 
2040         nz = newarg.extract_multiplicatively(I)
2041         if nz is not None:
2042             prefact = cls._sign*I*prefact
2043             newarg = nz
2044             changed = True
2045 
2046         if changed:
2047             return prefact*cls(newarg)
2048 
2049         # Values at positive infinities signs
2050         # if any were extracted automatically
2051         if z is S.Infinity:
2052             return S.Half
2053         elif z is I*S.Infinity:
2054             return cls._sign*I*S.Half
2055 
2056     def fdiff(self, argindex=1):
2057         if argindex == 1:
2058             return self._trigfunc(S.Half*pi*self.args[0]**2)
2059         else:
2060             raise ArgumentIndexError(self, argindex)
2061 
2062     def _eval_is_real(self):
2063         return self.args[0].is_real
2064 
2065     def _eval_conjugate(self):
2066         return self.func(self.args[0].conjugate())
2067 
2068     def _as_real_imag(self, deep=True, **hints):
2069         if self.args[0].is_real:
2070             if deep:
2071                 hints['complex'] = False
2072                 return (self.expand(deep, **hints), S.Zero)
2073             else:
2074                 return (self, S.Zero)
2075         if deep:
2076             re, im = self.args[0].expand(deep, **hints).as_real_imag()
2077         else:
2078             re, im = self.args[0].as_real_imag()
2079         return (re, im)
2080 
2081     def as_real_imag(self, deep=True, **hints):
2082         # Fresnel S
2083         # http://functions.wolfram.com/06.32.19.0003.01
2084         # http://functions.wolfram.com/06.32.19.0006.01
2085         # Fresnel C
2086         # http://functions.wolfram.com/06.33.19.0003.01
2087         # http://functions.wolfram.com/06.33.19.0006.01
2088         x, y = self._as_real_imag(deep=deep, **hints)
2089         sq = -y**2/x**2
2090         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
2091         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
2092                 self.func(x + x*sqrt(sq)))
2093         return (re, im)
2094 
2095 
2096 class fresnels(FresnelIntegral):
2097     r"""
2098     Fresnel integral S.
2099 
2100     This function is defined by
2101 
2102     .. math:: \operatorname{S}(z) = \int_0^z \sin{\frac{\pi}{2} t^2} \mathrm{d}t.
2103 
2104     It is an entire function.
2105 
2106     Examples
2107     ========
2108 
2109     >>> from sympy import I, oo, fresnels
2110     >>> from sympy.abc import z
2111 
2112     Several special values are known:
2113 
2114     >>> fresnels(0)
2115     0
2116     >>> fresnels(oo)
2117     1/2
2118     >>> fresnels(-oo)
2119     -1/2
2120     >>> fresnels(I*oo)
2121     -I/2
2122     >>> fresnels(-I*oo)
2123     I/2
2124 
2125     In general one can pull out factors of -1 and `i` from the argument:
2126 
2127     >>> fresnels(-z)
2128     -fresnels(z)
2129     >>> fresnels(I*z)
2130     -I*fresnels(z)
2131 
2132     The Fresnel S integral obeys the mirror symmetry
2133     `\overline{S(z)} = S(\bar{z})`:
2134 
2135     >>> from sympy import conjugate
2136     >>> conjugate(fresnels(z))
2137     fresnels(conjugate(z))
2138 
2139     Differentiation with respect to `z` is supported:
2140 
2141     >>> from sympy import diff
2142     >>> diff(fresnels(z), z)
2143     sin(pi*z**2/2)
2144 
2145     Defining the Fresnel functions via an integral
2146 
2147     >>> from sympy import integrate, pi, sin, gamma, expand_func
2148     >>> integrate(sin(pi*z**2/2), z)
2149     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))
2150     >>> expand_func(integrate(sin(pi*z**2/2), z))
2151     fresnels(z)
2152 
2153     We can numerically evaluate the Fresnel integral to arbitrary precision
2154     on the whole complex plane:
2155 
2156     >>> fresnels(2).evalf(30)
2157     0.343415678363698242195300815958
2158 
2159     >>> fresnels(-2*I).evalf(30)
2160     0.343415678363698242195300815958*I
2161 
2162     See Also
2163     ========
2164 
2165     fresnelc: Fresnel cosine integral.
2166 
2167     References
2168     ==========
2169 
2170     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral
2171     .. [2] http://dlmf.nist.gov/7
2172     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2173     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS
2174     .. [5] The converging factors for the fresnel integrals
2175             by John W. Wrench Jr. and Vicki Alley
2176 
2177     """
2178     _trigfunc = sin
2179     _sign = -S.One
2180 
2181     @staticmethod
2182     @cacheit
2183     def taylor_term(n, x, *previous_terms):
2184         if n < 0:
2185             return S.Zero
2186         else:
2187             x = sympify(x)
2188             if len(previous_terms) > 1:
2189                 p = previous_terms[-1]
2190                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p
2191             else:
2192                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))
2193 
2194     def _eval_rewrite_as_erf(self, z):
2195         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))
2196 
2197     def _eval_rewrite_as_hyper(self, z):
2198         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)
2199 
2200     def _eval_rewrite_as_meijerg(self, z):
2201         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))
2202                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))
2203 
2204     def _eval_aseries(self, n, args0, x, logx):
2205         from sympy import Order
2206         point = args0[0]
2207 
2208         # Expansion at oo
2209         if point is S.Infinity:
2210             z = self.args[0]
2211 
2212             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8
2213             p = [(-1)**k * factorial(4*k + 1) /
2214                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2215                  for k in range(0, n)]
2216             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2217                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2218                  for k in range(1, n)]
2219 
2220             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]
2221             q = [-sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]
2222 
2223             return S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)
2224 
2225         # All other points are not handled
2226         return super(fresnels, self)._eval_aseries(n, args0, x, logx)
2227 
2228 
2229 class fresnelc(FresnelIntegral):
2230     r"""
2231     Fresnel integral C.
2232 
2233     This function is defined by
2234 
2235     .. math:: \operatorname{C}(z) = \int_0^z \cos{\frac{\pi}{2} t^2} \mathrm{d}t.
2236 
2237     It is an entire function.
2238 
2239     Examples
2240     ========
2241 
2242     >>> from sympy import I, oo, fresnelc
2243     >>> from sympy.abc import z
2244 
2245     Several special values are known:
2246 
2247     >>> fresnelc(0)
2248     0
2249     >>> fresnelc(oo)
2250     1/2
2251     >>> fresnelc(-oo)
2252     -1/2
2253     >>> fresnelc(I*oo)
2254     I/2
2255     >>> fresnelc(-I*oo)
2256     -I/2
2257 
2258     In general one can pull out factors of -1 and `i` from the argument:
2259 
2260     >>> fresnelc(-z)
2261     -fresnelc(z)
2262     >>> fresnelc(I*z)
2263     I*fresnelc(z)
2264 
2265     The Fresnel C integral obeys the mirror symmetry
2266     `\overline{C(z)} = C(\bar{z})`:
2267 
2268     >>> from sympy import conjugate
2269     >>> conjugate(fresnelc(z))
2270     fresnelc(conjugate(z))
2271 
2272     Differentiation with respect to `z` is supported:
2273 
2274     >>> from sympy import diff
2275     >>> diff(fresnelc(z), z)
2276     cos(pi*z**2/2)
2277 
2278     Defining the Fresnel functions via an integral
2279 
2280     >>> from sympy import integrate, pi, cos, gamma, expand_func
2281     >>> integrate(cos(pi*z**2/2), z)
2282     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))
2283     >>> expand_func(integrate(cos(pi*z**2/2), z))
2284     fresnelc(z)
2285 
2286     We can numerically evaluate the Fresnel integral to arbitrary precision
2287     on the whole complex plane:
2288 
2289     >>> fresnelc(2).evalf(30)
2290     0.488253406075340754500223503357
2291 
2292     >>> fresnelc(-2*I).evalf(30)
2293     -0.488253406075340754500223503357*I
2294 
2295     See Also
2296     ========
2297 
2298     fresnels: Fresnel sine integral.
2299 
2300     References
2301     ==========
2302 
2303     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral
2304     .. [2] http://dlmf.nist.gov/7
2305     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2306     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC
2307     .. [5] The converging factors for the fresnel integrals
2308             by John W. Wrench Jr. and Vicki Alley
2309     """
2310     _trigfunc = cos
2311     _sign = S.One
2312 
2313     @staticmethod
2314     @cacheit
2315     def taylor_term(n, x, *previous_terms):
2316         if n < 0:
2317             return S.Zero
2318         else:
2319             x = sympify(x)
2320             if len(previous_terms) > 1:
2321                 p = previous_terms[-1]
2322                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p
2323             else:
2324                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))
2325 
2326     def _eval_rewrite_as_erf(self, z):
2327         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))
2328 
2329     def _eval_rewrite_as_hyper(self, z):
2330         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)
2331 
2332     def _eval_rewrite_as_meijerg(self, z):
2333         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))
2334                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))
2335 
2336     def _eval_aseries(self, n, args0, x, logx):
2337         from sympy import Order
2338         point = args0[0]
2339 
2340         # Expansion at oo
2341         if point is S.Infinity:
2342             z = self.args[0]
2343 
2344             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8
2345             p = [(-1)**k * factorial(4*k + 1) /
2346                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2347                  for k in range(0, n)]
2348             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2349                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2350                  for k in range(1, n)]
2351 
2352             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]
2353             q = [ sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]
2354 
2355             return S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)
2356 
2357         # All other points are not handled
2358         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)
2359 
2360 
2361 ###############################################################################
2362 #################### HELPER FUNCTIONS #########################################
2363 ###############################################################################
2364 
2365 
2366 class _erfs(Function):
2367     """
2368     Helper function to make the `\\mathrm{erf}(z)` function
2369     tractable for the Gruntz algorithm.
2370     """
2371 
2372 
2373     def _eval_aseries(self, n, args0, x, logx):
2374         from sympy import Order
2375         point = args0[0]
2376 
2377         # Expansion at oo
2378         if point is S.Infinity:
2379             z = self.args[0]
2380             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2381                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2382             o = Order(1/z**(2*n + 1), x)
2383             # It is very inefficient to first add the order and then do the nseries
2384             return (Add(*l))._eval_nseries(x, n, logx) + o
2385 
2386         # Expansion at I*oo
2387         t = point.extract_multiplicatively(S.ImaginaryUnit)
2388         if t is S.Infinity:
2389             z = self.args[0]
2390             # TODO: is the series really correct?
2391             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2392                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2393             o = Order(1/z**(2*n + 1), x)
2394             # It is very inefficient to first add the order and then do the nseries
2395             return (Add(*l))._eval_nseries(x, n, logx) + o
2396 
2397         # All other points are not handled
2398         return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2399 
2400     def fdiff(self, argindex=1):
2401         if argindex == 1:
2402             z = self.args[0]
2403             return -2/sqrt(S.Pi) + 2*z*_erfs(z)
2404         else:
2405             raise ArgumentIndexError(self, argindex)
2406 
2407     def _eval_rewrite_as_intractable(self, z):
2408         return (S.One - erf(z))*exp(z**2)
2409 
2410 
2411 class _eis(Function):
2412     """
2413     Helper function to make the `\\mathrm{Ei}(z)` and `\\mathrm{li}(z)` functions
2414     tractable for the Gruntz algorithm.
2415     """
2416 
2417 
2418     def _eval_aseries(self, n, args0, x, logx):
2419         from sympy import Order
2420         if args0[0] != S.Infinity:
2421             return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2422 
2423         z = self.args[0]
2424         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]
2425         o = Order(1/z**(n + 1), x)
2426         # It is very inefficient to first add the order and then do the nseries
2427         return (Add(*l))._eval_nseries(x, n, logx) + o
2428 
2429 
2430     def fdiff(self, argindex=1):
2431         if argindex == 1:
2432             z = self.args[0]
2433             return S.One / z - _eis(z)
2434         else:
2435             raise ArgumentIndexError(self, argindex)
2436 
2437     def _eval_rewrite_as_intractable(self, z):
2438         return exp(-z)*Ei(z)
2439 
2440     def _eval_nseries(self, x, n, logx):
2441         x0 = self.args[0].limit(x, 0)
2442         if x0 is S.Zero:
2443             f = self._eval_rewrite_as_intractable(*self.args)
2444             return f._eval_nseries(x, n, logx)
2445         return super(_eis, self)._eval_nseries(x, n, logx)

</code><intended_behavior>Each of these methods should ensure the operations involving error functions and related special functions are executed in line with established mathematical definitions and transformations. Reversions or corrections might be needed to align the implementations with the intended mathematical behaviors, specifically reverting to functionality before the modifications introduced in SymPy 1.0.</intended_behavior>, <file>sympy/integrals/integrals.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.concrete.expr_with_limits import AddWithLimits
4 from sympy.core.add import Add
5 from sympy.core.basic import Basic
6 from sympy.core.compatibility import is_sequence, range
7 from sympy.core.containers import Tuple
8 from sympy.core.expr import Expr
9 from sympy.core.function import diff
10 from sympy.core.mul import Mul
11 from sympy.core.numbers import oo
12 from sympy.core.relational import Eq
13 from sympy.core.singleton import S
14 from sympy.core.symbol import (Dummy, Symbol, Wild)
15 from sympy.core.sympify import sympify
16 from sympy.integrals.manualintegrate import manualintegrate
17 from sympy.integrals.trigonometry import trigintegrate
18 from sympy.integrals.meijerint import meijerint_definite, meijerint_indefinite
19 from sympy.matrices import MatrixBase
20 from sympy.utilities.misc import filldedent
21 from sympy.polys import Poly, PolynomialError
22 from sympy.functions import Piecewise, sqrt, sign
23 from sympy.functions.elementary.exponential import log
24 from sympy.series import limit
25 from sympy.series.order import Order
26 
27 
28 class Integral(AddWithLimits):
29     """Represents unevaluated integral."""
30 
31     __slots__ = ['is_commutative']
32 
33     def __new__(cls, function, *symbols, **assumptions):
34         """Create an unevaluated integral.
35 
36         Arguments are an integrand followed by one or more limits.
37 
38         If no limits are given and there is only one free symbol in the
39         expression, that symbol will be used, otherwise an error will be
40         raised.
41 
42         >>> from sympy import Integral
43         >>> from sympy.abc import x, y
44         >>> Integral(x)
45         Integral(x, x)
46         >>> Integral(y)
47         Integral(y, y)
48 
49         When limits are provided, they are interpreted as follows (using
50         ``x`` as though it were the variable of integration):
51 
52             (x,) or x - indefinite integral
53             (x, a) - "evaluate at" integral is an abstract antiderivative
54             (x, a, b) - definite integral
55 
56         The ``as_dummy`` method can be used to see which symbols cannot be
57         targeted by subs: those with a preppended underscore cannot be
58         changed with ``subs``. (Also, the integration variables themselves --
59         the first element of a limit -- can never be changed by subs.)
60 
61         >>> i = Integral(x, x)
62         >>> at = Integral(x, (x, x))
63         >>> i.as_dummy()
64         Integral(x, x)
65         >>> at.as_dummy()
66         Integral(_x, (_x, x))
67 
68         """
69 
70         #This will help other classes define their own definitions
71         #of behaviour with Integral.
72         if hasattr(function, '_eval_Integral'):
73             return function._eval_Integral(*symbols, **assumptions)
74 
75         obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)
76         return obj
77 
78     def __getnewargs__(self):
79         return (self.function,) + tuple([tuple(xab) for xab in self.limits])
80 
81     @property
82     def free_symbols(self):
83         """
84         This method returns the symbols that will exist when the
85         integral is evaluated. This is useful if one is trying to
86         determine whether an integral depends on a certain
87         symbol or not.
88 
89         Examples
90         ========
91 
92         >>> from sympy import Integral
93         >>> from sympy.abc import x, y
94         >>> Integral(x, (x, y, 1)).free_symbols
95         {y}
96 
97         See Also
98         ========
99 
100         function, limits, variables
101         """
102         return AddWithLimits.free_symbols.fget(self)
103 
104     def _eval_is_zero(self):
105         # This is a very naive and quick test, not intended to do the integral to
106         # answer whether it is zero or not, e.g. Integral(sin(x), (x, 0, 2*pi))
107         # is zero but this routine should return None for that case. But, like
108         # Mul, there are trivial situations for which the integral will be
109         # zero so we check for those.
110         if self.function.is_zero:
111             return True
112         got_none = False
113         for l in self.limits:
114             if len(l) == 3:
115                 z = (l[1] == l[2]) or (l[1] - l[2]).is_zero
116                 if z:
117                     return True
118                 elif z is None:
119                     got_none = True
120         free = self.function.free_symbols
121         for xab in self.limits:
122             if len(xab) == 1:
123                 free.add(xab[0])
124                 continue
125             if len(xab) == 2 and xab[0] not in free:
126                 if xab[1].is_zero:
127                     return True
128                 elif xab[1].is_zero is None:
129                     got_none = True
130             # take integration symbol out of free since it will be replaced
131             # with the free symbols in the limits
132             free.discard(xab[0])
133             # add in the new symbols
134             for i in xab[1:]:
135                 free.update(i.free_symbols)
136         if self.function.is_zero is False and got_none is False:
137             return False
138 
139     def transform(self, x, u):
140         r"""
141         Performs a change of variables from `x` to `u` using the relationship
142         given by `x` and `u` which will define the transformations `f` and `F`
143         (which are inverses of each other) as follows:
144 
145         1) If `x` is a Symbol (which is a variable of integration) then `u`
146            will be interpreted as some function, f(u), with inverse F(u).
147            This, in effect, just makes the substitution of x with f(x).
148 
149         2) If `u` is a Symbol then `x` will be interpreted as some function,
150            F(x), with inverse f(u). This is commonly referred to as
151            u-substitution.
152 
153         Once f and F have been identified, the transformation is made as
154         follows:
155 
156         .. math:: \int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x)
157                   \frac{\mathrm{d}}{\mathrm{d}x}
158 
159         where `F(x)` is the inverse of `f(x)` and the limits and integrand have
160         been corrected so as to retain the same value after integration.
161 
162         Notes
163         =====
164 
165         The mappings, F(x) or f(u), must lead to a unique integral. Linear
166         or rational linear expression, `2*x`, `1/x` and `sqrt(x)`, will
167         always work; quadratic expressions like `x**2 - 1` are acceptable
168         as long as the resulting integrand does not depend on the sign of
169         the solutions (see examples).
170 
171         The integral will be returned unchanged if `x` is not a variable of
172         integration.
173 
174         `x` must be (or contain) only one of of the integration variables. If
175         `u` has more than one free symbol then it should be sent as a tuple
176         (`u`, `uvar`) where `uvar` identifies which variable is replacing
177         the integration variable.
178         XXX can it contain another integration variable?
179 
180         Examples
181         ========
182 
183         >>> from sympy.abc import a, b, c, d, x, u, y
184         >>> from sympy import Integral, S, cos, sqrt
185 
186         >>> i = Integral(x*cos(x**2 - 1), (x, 0, 1))
187 
188         transform can change the variable of integration
189 
190         >>> i.transform(x, u)
191         Integral(u*cos(u**2 - 1), (u, 0, 1))
192 
193         transform can perform u-substitution as long as a unique
194         integrand is obtained:
195 
196         >>> i.transform(x**2 - 1, u)
197         Integral(cos(u)/2, (u, -1, 0))
198 
199         This attempt fails because x = +/-sqrt(u + 1) and the
200         sign does not cancel out of the integrand:
201 
202         >>> Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)
203         Traceback (most recent call last):
204         ...
205         ValueError:
206         The mapping between F(x) and f(u) did not give a unique integrand.
207 
208         transform can do a substitution. Here, the previous
209         result is transformed back into the original expression
210         using "u-substitution":
211 
212         >>> ui = _
213         >>> _.transform(sqrt(u + 1), x) == i
214         True
215 
216         We can accomplish the same with a regular substitution:
217 
218         >>> ui.transform(u, x**2 - 1) == i
219         True
220 
221         If the `x` does not contain a symbol of integration then
222         the integral will be returned unchanged. Integral `i` does
223         not have an integration variable `a` so no change is made:
224 
225         >>> i.transform(a, x) == i
226         True
227 
228         When `u` has more than one free symbol the symbol that is
229         replacing `x` must be identified by passing `u` as a tuple:
230 
231         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, u))
232         Integral(a + u, (u, -a, -a + 1))
233         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, a))
234         Integral(a + u, (a, -u, -u + 1))
235 
236         See Also
237         ========
238 
239         variables : Lists the integration variables
240         as_dummy : Replace integration variables with dummy ones
241         """
242         from sympy.solvers.solvers import solve, posify
243         d = Dummy('d')
244 
245         xfree = x.free_symbols.intersection(self.variables)
246         if len(xfree) > 1:
247             raise ValueError(
248                 'F(x) can only contain one of: %s' % self.variables)
249         xvar = xfree.pop() if xfree else d
250 
251         if xvar not in self.variables:
252             return self
253 
254         u = sympify(u)
255         if isinstance(u, Expr):
256             ufree = u.free_symbols
257             if len(ufree) != 1:
258                 raise ValueError(filldedent('''
259                 When f(u) has more than one free symbol, the one replacing x
260                 must be identified: pass f(u) as (f(u), u)'''))
261             uvar = ufree.pop()
262         else:
263             u, uvar = u
264             if uvar not in u.free_symbols:
265                 raise ValueError(filldedent('''
266                 Expecting a tuple (expr, symbol) where symbol identified
267                 a free symbol in expr, but symbol is not in expr's free
268                 symbols.'''))
269             if not isinstance(uvar, Symbol):
270                 raise ValueError(filldedent('''
271                 Expecting a tuple (expr, symbol) but didn't get
272                 a symbol; got %s''' % uvar))
273 
274         if x.is_Symbol and u.is_Symbol:
275             return self.xreplace({x: u})
276 
277         if not x.is_Symbol and not u.is_Symbol:
278             raise ValueError('either x or u must be a symbol')
279 
280         if uvar == xvar:
281             return self.transform(x, (u.subs(uvar, d), d)).xreplace({d: uvar})
282 
283         if uvar in self.limits:
284             raise ValueError(filldedent('''
285             u must contain the same variable as in x
286             or a variable that is not already an integration variable'''))
287 
288         if not x.is_Symbol:
289             F = [x.subs(xvar, d)]
290             soln = solve(u - x, xvar, check=False)
291             if not soln:
292                 raise ValueError('no solution for solve(F(x) - f(u), x)')
293             f = [fi.subs(uvar, d) for fi in soln]
294         else:
295             f = [u.subs(uvar, d)]
296             pdiff, reps = posify(u - x)
297             puvar = uvar.subs([(v, k) for k, v in reps.items()])
298             soln = [s.subs(reps) for s in solve(pdiff, puvar)]
299             if not soln:
300                 raise ValueError('no solution for solve(F(x) - f(u), u)')
301             F = [fi.subs(xvar, d) for fi in soln]
302 
303         newfuncs = set([(self.function.subs(xvar, fi)*fi.diff(d)
304                         ).subs(d, uvar) for fi in f])
305         if len(newfuncs) > 1:
306             raise ValueError(filldedent('''
307             The mapping between F(x) and f(u) did not give
308             a unique integrand.'''))
309         newfunc = newfuncs.pop()
310 
311         def _calc_limit_1(F, a, b):
312             """
313             replace d with a, using subs if possible, otherwise limit
314             where sign of b is considered
315             """
316             wok = F.subs(d, a)
317             if wok is S.NaN or wok.is_finite is False and a.is_finite:
318                 return limit(sign(b)*F, d, a)
319             return wok
320 
321         def _calc_limit(a, b):
322             """
323             replace d with a, using subs if possible, otherwise limit
324             where sign of b is considered
325             """
326             avals = list({_calc_limit_1(Fi, a, b) for Fi in F})
327             if len(avals) > 1:
328                 raise ValueError(filldedent('''
329                 The mapping between F(x) and f(u) did not
330                 give a unique limit.'''))
331             return avals[0]
332 
333         newlimits = []
334         for xab in self.limits:
335             sym = xab[0]
336             if sym == xvar:
337                 if len(xab) == 3:
338                     a, b = xab[1:]
339                     a, b = _calc_limit(a, b), _calc_limit(b, a)
340                     if a - b > 0:
341                         a, b = b, a
342                         newfunc = -newfunc
343                     newlimits.append((uvar, a, b))
344                 elif len(xab) == 2:
345                     a = _calc_limit(xab[1], 1)
346                     newlimits.append((uvar, a))
347                 else:
348                     newlimits.append(uvar)
349             else:
350                 newlimits.append(xab)
351 
352         return self.func(newfunc, *newlimits)
353 
354     def doit(self, **hints):
355         """
356         Perform the integration using any hints given.
357 
358         Examples
359         ========
360 
361         >>> from sympy import Integral
362         >>> from sympy.abc import x, i
363         >>> Integral(x**i, (i, 1, 3)).doit()
364         Piecewise((2, Eq(log(x), 0)), (x**3/log(x) - x/log(x), True))
365 
366         See Also
367         ========
368 
369         sympy.integrals.trigonometry.trigintegrate
370         sympy.integrals.risch.heurisch
371         sympy.integrals.rationaltools.ratint
372         as_sum : Approximate the integral using a sum
373         """
374         if not hints.get('integrals', True):
375             return self
376 
377         deep = hints.get('deep', True)
378         meijerg = hints.get('meijerg', None)
379         conds = hints.get('conds', 'piecewise')
380         risch = hints.get('risch', None)
381         manual = hints.get('manual', None)
382 
383         if conds not in ['separate', 'piecewise', 'none']:
384             raise ValueError('conds must be one of "separate", "piecewise", '
385                              '"none", got: %s' % conds)
386 
387         if risch and any(len(xab) > 1 for xab in self.limits):
388             raise ValueError('risch=True is only allowed for indefinite integrals.')
389 
390         # check for the trivial zero
391         if self.is_zero:
392             return S.Zero
393 
394         # now compute and check the function
395         function = self.function
396         if deep:
397             function = function.doit(**hints)
398         if function.is_zero:
399             return S.Zero
400 
401         if isinstance(function, MatrixBase):
402             return function.applyfunc(lambda f: self.func(f, self.limits).doit(**hints))
403 
404         # There is no trivial answer, so continue
405 
406         undone_limits = []
407         # ulj = free symbols of any undone limits' upper and lower limits
408         ulj = set()
409         for xab in self.limits:
410             # compute uli, the free symbols in the
411             # Upper and Lower limits of limit I
412             if len(xab) == 1:
413                 uli = set(xab[:1])
414             elif len(xab) == 2:
415                 uli = xab[1].free_symbols
416             elif len(xab) == 3:
417                 uli = xab[1].free_symbols.union(xab[2].free_symbols)
418             # this integral can be done as long as there is no blocking
419             # limit that has been undone. An undone limit is blocking if
420             # it contains an integration variable that is in this limit's
421             # upper or lower free symbols or vice versa
422             if xab[0] in ulj or any(v[0] in uli for v in undone_limits):
423                 undone_limits.append(xab)
424                 ulj.update(uli)
425                 function = self.func(*([function] + [xab]))
426                 factored_function = function.factor()
427                 if not isinstance(factored_function, Integral):
428                     function = factored_function
429                 continue
430 
431             # There are a number of tradeoffs in using the Meijer G method.
432             # It can sometimes be a lot faster than other methods, and
433             # sometimes slower. And there are certain types of integrals for
434             # which it is more likely to work than others.
435             # These heuristics are incorporated in deciding what integration
436             # methods to try, in what order.
437             # See the integrate() docstring for details.
438             def try_meijerg(function, xab):
439                 ret = None
440                 if len(xab) == 3 and meijerg is not False:
441                     x, a, b = xab
442                     try:
443                         res = meijerint_definite(function, x, a, b)
444                     except NotImplementedError:
445                         from sympy.integrals.meijerint import _debug
446                         _debug('NotImplementedError from meijerint_definite')
447                         res = None
448                     if res is not None:
449                         f, cond = res
450                         if conds == 'piecewise':
451                             ret = Piecewise((f, cond),
452                                           (self.func(function, (x, a, b)), True))
453                         elif conds == 'separate':
454                             if len(self.limits) != 1:
455                                 raise ValueError('conds=separate not supported in '
456                                                  'multiple integrals')
457                             ret = f, cond
458                         else:
459                             ret = f
460                 return ret
461 
462             meijerg1 = meijerg
463             if len(xab) == 3 and xab[1].is_real and xab[2].is_real \
464                 and not function.is_Poly and \
465                     (xab[1].has(oo, -oo) or xab[2].has(oo, -oo)):
466                 ret = try_meijerg(function, xab)
467                 if ret is not None:
468                     function = ret
469                     continue
470                 else:
471                     meijerg1 = False
472 
473             # If the special meijerg code did not succeed in finding a definite
474             # integral, then the code using meijerint_indefinite will not either
475             # (it might find an antiderivative, but the answer is likely to be
476             #  nonsensical).
477             # Thus if we are requested to only use Meijer G-function methods,
478             # we give up at this stage. Otherwise we just disable G-function
479             # methods.
480             if meijerg1 is False and meijerg is True:
481                 antideriv = None
482             else:
483                 antideriv = self._eval_integral(
484                     function, xab[0],
485                     meijerg=meijerg1, risch=risch, manual=manual,
486                     conds=conds)
487                 if antideriv is None and meijerg1 is True:
488                     ret = try_meijerg(function, xab)
489                     if ret is not None:
490                         function = ret
491                         continue
492 
493             if antideriv is None:
494                 undone_limits.append(xab)
495                 function = self.func(*([function] + [xab])).factor()
496                 factored_function = function.factor()
497                 if not isinstance(factored_function, Integral):
498                     function = factored_function
499                 continue
500             else:
501                 if len(xab) == 1:
502                     function = antideriv
503                 else:
504                     if len(xab) == 3:
505                         x, a, b = xab
506                     elif len(xab) == 2:
507                         x, b = xab
508                         a = None
509                     else:
510                         raise NotImplementedError
511 
512                     if deep:
513                         if isinstance(a, Basic):
514                             a = a.doit(**hints)
515                         if isinstance(b, Basic):
516                             b = b.doit(**hints)
517 
518                     if antideriv.is_Poly:
519                         gens = list(antideriv.gens)
520                         gens.remove(x)
521 
522                         antideriv = antideriv.as_expr()
523 
524                         function = antideriv._eval_interval(x, a, b)
525                         function = Poly(function, *gens)
526                     else:
527                         def is_indef_int(g, x):
528                             return (isinstance(g, Integral) and
529                                     any(i == (x,) for i in g.limits))
530 
531                         def eval_factored(f, x, a, b):
532                             # _eval_interval for integrals with
533                             # (constant) factors
534                             # a single indefinite integral is assumed
535                             args = []
536                             for g in Mul.make_args(f):
537                                 if is_indef_int(g, x):
538                                     args.append(g._eval_interval(x, a, b))
539                                 else:
540                                     args.append(g)
541                             return Mul(*args)
542 
543                         integrals, others = [], []
544                         for f in Add.make_args(antideriv):
545                             if any(is_indef_int(g, x)
546                                    for g in Mul.make_args(f)):
547                                 integrals.append(f)
548                             else:
549                                 others.append(f)
550                         uneval = Add(*[eval_factored(f, x, a, b)
551                                        for f in integrals])
552                         try:
553                             evalued = Add(*others)._eval_interval(x, a, b)
554                             function = uneval + evalued
555                         except NotImplementedError:
556                             # This can happen if _eval_interval depends in a
557                             # complicated way on limits that cannot be computed
558                             undone_limits.append(xab)
559                             function = self.func(*([function] + [xab]))
560                             factored_function = function.factor()
561                             if not isinstance(factored_function, Integral):
562                                 function = factored_function
563         return function
564 
565     def _eval_derivative(self, sym):
566         """Evaluate the derivative of the current Integral object by
567         differentiating under the integral sign [1], using the Fundamental
568         Theorem of Calculus [2] when possible.
569 
570         Whenever an Integral is encountered that is equivalent to zero or
571         has an integrand that is independent of the variable of integration
572         those integrals are performed. All others are returned as Integral
573         instances which can be resolved with doit() (provided they are integrable).
574 
575         References:
576            [1] http://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign
577            [2] http://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus
578 
579         Examples
580         ========
581 
582         >>> from sympy import Integral
583         >>> from sympy.abc import x, y
584         >>> i = Integral(x + y, y, (y, 1, x))
585         >>> i.diff(x)
586         Integral(x + y, (y, x)) + Integral(1, y, (y, 1, x))
587         >>> i.doit().diff(x) == i.diff(x).doit()
588         True
589         >>> i.diff(y)
590         0
591 
592         The previous must be true since there is no y in the evaluated integral:
593 
594         >>> i.free_symbols
595         {x}
596         >>> i.doit()
597         2*x**3/3 - x/2 - 1/6
598 
599         """
600 
601         # differentiate under the integral sign; we do not
602         # check for regularity conditions (TODO), see issue 4215
603 
604         # get limits and the function
605         f, limits = self.function, list(self.limits)
606 
607         # the order matters if variables of integration appear in the limits
608         # so work our way in from the outside to the inside.
609         limit = limits.pop(-1)
610         if len(limit) == 3:
611             x, a, b = limit
612         elif len(limit) == 2:
613             x, b = limit
614             a = None
615         else:
616             a = b = None
617             x = limit[0]
618 
619         if limits:  # f is the argument to an integral
620             f = self.func(f, *tuple(limits))
621 
622         # assemble the pieces
623         def _do(f, ab):
624             dab_dsym = diff(ab, sym)
625             if not dab_dsym:
626                 return S.Zero
627             if isinstance(f, Integral):
628                 limits = [(x, x) if (len(l) == 1 and l[0] == x) else l
629                           for l in f.limits]
630                 f = self.func(f.function, *limits)
631             return f.subs(x, ab)*dab_dsym
632         rv = 0
633         if b is not None:
634             rv += _do(f, b)
635         if a is not None:
636             rv -= _do(f, a)
637         if len(limit) == 1 and sym == x:
638             # the dummy variable *is* also the real-world variable
639             arg = f
640             rv += arg
641         else:
642             # the dummy variable might match sym but it's
643             # only a dummy and the actual variable is determined
644             # by the limits, so mask off the variable of integration
645             # while differentiating
646             u = Dummy('u')
647             arg = f.subs(x, u).diff(sym).subs(u, x)
648             rv += self.func(arg, Tuple(x, a, b))
649         return rv
650 
651     def _eval_integral(self, f, x, meijerg=None, risch=None, manual=None,
652                        conds='piecewise'):
653         """
654         Calculate the anti-derivative to the function f(x).
655 
656         The following algorithms are applied (roughly in this order):
657 
658         1. Simple heuristics (based on pattern matching and integral table):
659 
660            - most frequently used functions (e.g. polynomials, products of trig functions)
661 
662         2. Integration of rational functions:
663 
664            - A complete algorithm for integrating rational functions is
665              implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm
666              also uses the partial fraction decomposition algorithm
667              implemented in apart() as a preprocessor to make this process
668              faster.  Note that the integral of a rational function is always
669              elementary, but in general, it may include a RootSum.
670 
671         3. Full Risch algorithm:
672 
673            - The Risch algorithm is a complete decision
674              procedure for integrating elementary functions, which means that
675              given any elementary function, it will either compute an
676              elementary antiderivative, or else prove that none exists.
677              Currently, part of transcendental case is implemented, meaning
678              elementary integrals containing exponentials, logarithms, and
679              (soon!) trigonometric functions can be computed.  The algebraic
680              case, e.g., functions containing roots, is much more difficult
681              and is not implemented yet.
682 
683            - If the routine fails (because the integrand is not elementary, or
684              because a case is not implemented yet), it continues on to the
685              next algorithms below.  If the routine proves that the integrals
686              is nonelementary, it still moves on to the algorithms below,
687              because we might be able to find a closed-form solution in terms
688              of special functions.  If risch=True, however, it will stop here.
689 
690         4. The Meijer G-Function algorithm:
691 
692            - This algorithm works by first rewriting the integrand in terms of
693              very general Meijer G-Function (meijerg in SymPy), integrating
694              it, and then rewriting the result back, if possible.  This
695              algorithm is particularly powerful for definite integrals (which
696              is actually part of a different method of Integral), since it can
697              compute closed-form solutions of definite integrals even when no
698              closed-form indefinite integral exists.  But it also is capable
699              of computing many indefinite integrals as well.
700 
701            - Another advantage of this method is that it can use some results
702              about the Meijer G-Function to give a result in terms of a
703              Piecewise expression, which allows to express conditionally
704              convergent integrals.
705 
706            - Setting meijerg=True will cause integrate() to use only this
707              method.
708 
709         5. The "manual integration" algorithm:
710 
711            - This algorithm tries to mimic how a person would find an
712              antiderivative by hand, for example by looking for a
713              substitution or applying integration by parts. This algorithm
714              does not handle as many integrands but can return results in a
715              more familiar form.
716 
717            - Sometimes this algorithm can evaluate parts of an integral; in
718              this case integrate() will try to evaluate the rest of the
719              integrand using the other methods here.
720 
721            - Setting manual=True will cause integrate() to use only this
722              method.
723 
724         6. The Heuristic Risch algorithm:
725 
726            - This is a heuristic version of the Risch algorithm, meaning that
727              it is not deterministic.  This is tried as a last resort because
728              it can be very slow.  It is still used because not enough of the
729              full Risch algorithm is implemented, so that there are still some
730              integrals that can only be computed using this method.  The goal
731              is to implement enough of the Risch and Meijer G-function methods
732              so that this can be deleted.
733 
734         """
735         from sympy.integrals.deltafunctions import deltaintegrate
736         from sympy.integrals.singularityfunctions import singularityintegrate
737         from sympy.integrals.heurisch import heurisch, heurisch_wrapper
738         from sympy.integrals.rationaltools import ratint
739         from sympy.integrals.risch import risch_integrate
740 
741         if risch:
742             try:
743                 return risch_integrate(f, x, conds=conds)
744             except NotImplementedError:
745                 return None
746 
747         if manual:
748             try:
749                 result = manualintegrate(f, x)
750                 if result is not None and result.func != Integral:
751                     return result
752             except (ValueError, PolynomialError):
753                 pass
754 
755 
756         # if it is a poly(x) then let the polynomial integrate itself (fast)
757         #
758         # It is important to make this check first, otherwise the other code
759         # will return a sympy expression instead of a Polynomial.
760         #
761         # see Polynomial for details.
762         if isinstance(f, Poly) and not meijerg:
763             return f.integrate(x)
764 
765         # Piecewise antiderivatives need to call special integrate.
766         if f.func is Piecewise:
767             return f._eval_integral(x)
768 
769         # let's cut it short if `f` does not depend on `x`
770         if not f.has(x):
771             return f*x
772 
773         # try to convert to poly(x) and then integrate if successful (fast)
774         poly = f.as_poly(x)
775         if poly is not None and not meijerg:
776             return poly.integrate().as_expr()
777 
778         if risch is not False:
779             try:
780                 result, i = risch_integrate(f, x, separate_integral=True, conds=conds)
781             except NotImplementedError:
782                 pass
783             else:
784                 if i:
785                     # There was a nonelementary integral. Try integrating it.
786                     return result + i.doit(risch=False)
787                 else:
788                     return result
789 
790         # since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...
791         # we are going to handle Add terms separately,
792         # if `f` is not Add -- we only have one term
793 
794         # Note that in general, this is a bad idea, because Integral(g1) +
795         # Integral(g2) might not be computable, even if Integral(g1 + g2) is.
796         # For example, Integral(x**x + x**x*log(x)).  But many heuristics only
797         # work term-wise.  So we compute this step last, after trying
798         # risch_integrate.  We also try risch_integrate again in this loop,
799         # because maybe the integral is a sum of an elementary part and a
800         # nonelementary part (like erf(x) + exp(x)).  risch_integrate() is
801         # quite fast, so this is acceptable.
802         parts = []
803         args = Add.make_args(f)
804         for g in args:
805             coeff, g = g.as_independent(x)
806 
807             # g(x) = const
808             if g is S.One and not meijerg:
809                 parts.append(coeff*x)
810                 continue
811 
812             # g(x) = expr + O(x**n)
813             order_term = g.getO()
814 
815             if order_term is not None:
816                 h = self._eval_integral(g.removeO(), x)
817 
818                 if h is not None:
819                     h_order_expr = self._eval_integral(order_term.expr, x)
820 
821                     if h_order_expr is not None:
822                         h_order_term = order_term.func(
823                             h_order_expr, *order_term.variables)
824                         parts.append(coeff*(h + h_order_term))
825                         continue
826 
827                 # NOTE: if there is O(x**n) and we fail to integrate then there is
828                 # no point in trying other methods because they will fail anyway.
829                 return None
830 
831             #               c
832             # g(x) = (a*x+b)
833             if g.is_Pow and not g.exp.has(x) and not meijerg:
834                 a = Wild('a', exclude=[x])
835                 b = Wild('b', exclude=[x])
836 
837                 M = g.base.match(a*x + b)
838 
839                 if M is not None:
840                     if g.exp == -1:
841                         h = log(g.base)
842                     elif conds != 'piecewise':
843                         h = g.base**(g.exp + 1) / (g.exp + 1)
844                     else:
845                         h1 = log(g.base)
846                         h2 = g.base**(g.exp + 1) / (g.exp + 1)
847                         h = Piecewise((h1, Eq(g.exp, -1)), (h2, True))
848 
849                     parts.append(coeff * h / M[a])
850                     continue
851 
852             #        poly(x)
853             # g(x) = -------
854             #        poly(x)
855             if g.is_rational_function(x) and not meijerg:
856                 parts.append(coeff * ratint(g, x))
857                 continue
858 
859             if not meijerg:
860                 # g(x) = Mul(trig)
861                 h = trigintegrate(g, x, conds=conds)
862                 if h is not None:
863                     parts.append(coeff * h)
864                     continue
865 
866                 # g(x) has at least a DiracDelta term
867                 h = deltaintegrate(g, x)
868                 if h is not None:
869                     parts.append(coeff * h)
870                     continue
871 
872                 # g(x) has at least a Singularity Function term
873                 h = singularityintegrate(g, x)
874                 if h is not None:
875                     parts.append(coeff * h)
876                     continue
877 
878                 # Try risch again.
879                 if risch is not False:
880                     try:
881                         h, i = risch_integrate(g, x, separate_integral=True, conds=conds)
882                     except NotImplementedError:
883                         h = None
884                     else:
885                         if i:
886                             h = h + i.doit(risch=False)
887 
888                         parts.append(coeff*h)
889                         continue
890 
891                 # fall back to heurisch
892                 try:
893                     if conds == 'piecewise':
894                         h = heurisch_wrapper(g, x, hints=[])
895                     else:
896                         h = heurisch(g, x, hints=[])
897                 except PolynomialError:
898                     # XXX: this exception means there is a bug in the
899                     # implementation of heuristic Risch integration
900                     # algorithm.
901                     h = None
902             else:
903                 h = None
904 
905             if meijerg is not False and h is None:
906                 # rewrite using G functions
907                 try:
908                     h = meijerint_indefinite(g, x)
909                 except NotImplementedError:
910                     from sympy.integrals.meijerint import _debug
911                     _debug('NotImplementedError from meijerint_definite')
912                     res = None
913                 if h is not None:
914                     parts.append(coeff * h)
915                     continue
916 
917             if h is None and manual is not False:
918                 try:
919                     result = manualintegrate(g, x)
920                     if result is not None and not isinstance(result, Integral):
921                         if result.has(Integral):
922                             # try to have other algorithms do the integrals
923                             # manualintegrate can't handle
924                             result = result.func(*[
925                                 arg.doit(manual=False) if arg.has(Integral) else arg
926                                 for arg in result.args
927                             ]).expand(multinomial=False,
928                                       log=False,
929                                       power_exp=False,
930                                       power_base=False)
931                         if not result.has(Integral):
932                             parts.append(coeff * result)
933                             continue
934                 except (ValueError, PolynomialError):
935                     # can't handle some SymPy expressions
936                     pass
937 
938             # if we failed maybe it was because we had
939             # a product that could have been expanded,
940             # so let's try an expansion of the whole
941             # thing before giving up; we don't try this
942             # at the outset because there are things
943             # that cannot be solved unless they are
944             # NOT expanded e.g., x**x*(1+log(x)). There
945             # should probably be a checker somewhere in this
946             # routine to look for such cases and try to do
947             # collection on the expressions if they are already
948             # in an expanded form
949             if not h and len(args) == 1:
950                 f = f.expand(mul=True, deep=False)
951                 if f.is_Add:
952                     # Note: risch will be identical on the expanded
953                     # expression, but maybe it will be able to pick out parts,
954                     # like x*(exp(x) + erf(x)).
955                     return self._eval_integral(f, x, meijerg=meijerg, risch=risch, conds=conds)
956 
957             if h is not None:
958                 parts.append(coeff * h)
959             else:
960                 return None
961 
962         return Add(*parts)
963 
964     def _eval_lseries(self, x, logx):
965         expr = self.as_dummy()
966         symb = x
967         for l in expr.limits:
968             if x in l[1:]:
969                 symb = l[0]
970                 break
971         for term in expr.function.lseries(symb, logx):
972             yield integrate(term, *expr.limits)
973 
974     def _eval_nseries(self, x, n, logx):
975         expr = self.as_dummy()
976         symb = x
977         for l in expr.limits:
978             if x in l[1:]:
979                 symb = l[0]
980                 break
981         terms, order = expr.function.nseries(
982             x=symb, n=n, logx=logx).as_coeff_add(Order)
983         order = [o.subs(symb, x) for o in order]
984         return integrate(terms, *expr.limits) + Add(*order)*x
985 
986     def _eval_as_leading_term(self, x):
987         series_gen = self.args[0].lseries(x)
988         for leading_term in series_gen:
989             if leading_term != 0:
990                 break
991         return integrate(leading_term, *self.args[1:])
992 
993     def as_sum(self, n, method="midpoint"):
994         """
995         Approximates the definite integral by a sum.
996 
997         method ... one of: left, right, midpoint, trapezoid
998 
999         These are all basically the rectangle method [1], the only difference
1000         is where the function value is taken in each interval to define the
1001         rectangle.
1002 
1003         [1] http://en.wikipedia.org/wiki/Rectangle_method
1004 
1005         Examples
1006         ========
1007 
1008         >>> from sympy import sin, sqrt
1009         >>> from sympy.abc import x
1010         >>> from sympy.integrals import Integral
1011         >>> e = Integral(sin(x), (x, 3, 7))
1012         >>> e
1013         Integral(sin(x), (x, 3, 7))
1014 
1015         For demonstration purposes, this interval will only be split into 2
1016         regions, bounded by [3, 5] and [5, 7].
1017 
1018         The left-hand rule uses function evaluations at the left of each
1019         interval:
1020 
1021         >>> e.as_sum(2, 'left')
1022         2*sin(5) + 2*sin(3)
1023 
1024         The midpoint rule uses evaluations at the center of each interval:
1025 
1026         >>> e.as_sum(2, 'midpoint')
1027         2*sin(4) + 2*sin(6)
1028 
1029         The right-hand rule uses function evaluations at the right of each
1030         interval:
1031 
1032         >>> e.as_sum(2, 'right')
1033         2*sin(5) + 2*sin(7)
1034 
1035         The trapezoid rule uses function evaluations on both sides of the
1036         intervals. This is equivalent to taking the average of the left and
1037         right hand rule results:
1038 
1039         >>> e.as_sum(2, 'trapezoid')
1040         2*sin(5) + sin(3) + sin(7)
1041         >>> (e.as_sum(2, 'left') + e.as_sum(2, 'right'))/2 == _
1042         True
1043 
1044         All but the trapexoid method may be used when dealing with a function
1045         with a discontinuity. Here, the discontinuity at x = 0 can be avoided
1046         by using the midpoint or right-hand method:
1047 
1048         >>> e = Integral(1/sqrt(x), (x, 0, 1))
1049         >>> e.as_sum(5).n(4)
1050         1.730
1051         >>> e.as_sum(10).n(4)
1052         1.809
1053         >>> e.doit().n(4)  # the actual value is 2
1054         2.000
1055 
1056         The left- or trapezoid method will encounter the discontinuity and
1057         return oo:
1058 
1059         >>> e.as_sum(5, 'left')
1060         oo
1061         >>> e.as_sum(5, 'trapezoid')
1062         oo
1063 
1064         See Also
1065         ========
1066 
1067         Integral.doit : Perform the integration using any hints
1068         """
1069 
1070         limits = self.limits
1071         if len(limits) > 1:
1072             raise NotImplementedError(
1073                 "Multidimensional midpoint rule not implemented yet")
1074         else:
1075             limit = limits[0]
1076             if len(limit) != 3:
1077                 raise ValueError("Expecting a definite integral.")
1078         if n <= 0:
1079             raise ValueError("n must be > 0")
1080         if n == oo:
1081             raise NotImplementedError("Infinite summation not yet implemented")
1082         sym, lower_limit, upper_limit = limit
1083         dx = (upper_limit - lower_limit)/n
1084 
1085         if method == 'trapezoid':
1086             l = self.function.limit(sym, lower_limit)
1087             r = self.function.limit(sym, upper_limit, "-")
1088             result = (l + r)/2
1089             for i in range(1, n):
1090                 x = lower_limit + i*dx
1091                 result += self.function.subs(sym, x)
1092             return result*dx
1093         elif method not in ('left', 'right', 'midpoint'):
1094             raise NotImplementedError("Unknown method %s" % method)
1095 
1096         result = 0
1097         for i in range(n):
1098             if method == "midpoint":
1099                 xi = lower_limit + i*dx + dx/2
1100             elif method == "left":
1101                 xi = lower_limit + i*dx
1102                 if i == 0:
1103                     result = self.function.limit(sym, lower_limit)
1104                     continue
1105             elif method == "right":
1106                 xi = lower_limit + i*dx + dx
1107                 if i == n:
1108                     result += self.function.limit(sym, upper_limit, "-")
1109                     continue
1110             result += self.function.subs(sym, xi)
1111         return result*dx
1112 
1113     def _sage_(self):
1114         import sage.all as sage
1115         f, limits = self.function._sage_(), list(self.limits)
1116         for limit in limits:
1117             if len(limit) == 1:
1118                 x = limit[0]
1119                 f = sage.integral(f,
1120                                     x._sage_(),
1121                                     hold=True)
1122             elif len(limit) == 2:
1123                 x, b = limit
1124                 f = sage.integral(f,
1125                                     x._sage_(),
1126                                     b._sage_(),
1127                                     hold=True)
1128             else:
1129                 x, a, b = limit
1130                 f = sage.integral(f,
1131                                   (x._sage_(),
1132                                     a._sage_(),
1133                                     b._sage_()),
1134                                     hold=True)
1135         return f
1136 
1137 
1138 def integrate(*args, **kwargs):
1139     """integrate(f, var, ...)
1140 
1141     Compute definite or indefinite integral of one or more variables
1142     using Risch-Norman algorithm and table lookup. This procedure is
1143     able to handle elementary algebraic and transcendental functions
1144     and also a huge class of special functions, including Airy,
1145     Bessel, Whittaker and Lambert.
1146 
1147     var can be:
1148 
1149     - a symbol                   -- indefinite integration
1150     - a tuple (symbol, a)        -- indefinite integration with result
1151                                     given with `a` replacing `symbol`
1152     - a tuple (symbol, a, b)     -- definite integration
1153 
1154     Several variables can be specified, in which case the result is
1155     multiple integration. (If var is omitted and the integrand is
1156     univariate, the indefinite integral in that variable will be performed.)
1157 
1158     Indefinite integrals are returned without terms that are independent
1159     of the integration variables. (see examples)
1160 
1161     Definite improper integrals often entail delicate convergence
1162     conditions. Pass conds='piecewise', 'separate' or 'none' to have
1163     these returned, respectively, as a Piecewise function, as a separate
1164     result (i.e. result will be a tuple), or not at all (default is
1165     'piecewise').
1166 
1167     **Strategy**
1168 
1169     SymPy uses various approaches to definite integration. One method is to
1170     find an antiderivative for the integrand, and then use the fundamental
1171     theorem of calculus. Various functions are implemented to integrate
1172     polynomial, rational and trigonometric functions, and integrands
1173     containing DiracDelta terms.
1174 
1175     SymPy also implements the part of the Risch algorithm, which is a decision
1176     procedure for integrating elementary functions, i.e., the algorithm can
1177     either find an elementary antiderivative, or prove that one does not
1178     exist.  There is also a (very successful, albeit somewhat slow) general
1179     implementation of the heuristic Risch algorithm.  This algorithm will
1180     eventually be phased out as more of the full Risch algorithm is
1181     implemented. See the docstring of Integral._eval_integral() for more
1182     details on computing the antiderivative using algebraic methods.
1183 
1184     The option risch=True can be used to use only the (full) Risch algorithm.
1185     This is useful if you want to know if an elementary function has an
1186     elementary antiderivative.  If the indefinite Integral returned by this
1187     function is an instance of NonElementaryIntegral, that means that the
1188     Risch algorithm has proven that integral to be non-elementary.  Note that
1189     by default, additional methods (such as the Meijer G method outlined
1190     below) are tried on these integrals, as they may be expressible in terms
1191     of special functions, so if you only care about elementary answers, use
1192     risch=True.  Also note that an unevaluated Integral returned by this
1193     function is not necessarily a NonElementaryIntegral, even with risch=True,
1194     as it may just be an indication that the particular part of the Risch
1195     algorithm needed to integrate that function is not yet implemented.
1196 
1197     Another family of strategies comes from re-writing the integrand in
1198     terms of so-called Meijer G-functions. Indefinite integrals of a
1199     single G-function can always be computed, and the definite integral
1200     of a product of two G-functions can be computed from zero to
1201     infinity. Various strategies are implemented to rewrite integrands
1202     as G-functions, and use this information to compute integrals (see
1203     the ``meijerint`` module).
1204 
1205     The option manual=True can be used to use only an algorithm that tries
1206     to mimic integration by hand. This algorithm does not handle as many
1207     integrands as the other algorithms implemented but may return results in
1208     a more familiar form. The ``manualintegrate`` module has functions that
1209     return the steps used (see the module docstring for more information).
1210 
1211     In general, the algebraic methods work best for computing
1212     antiderivatives of (possibly complicated) combinations of elementary
1213     functions. The G-function methods work best for computing definite
1214     integrals from zero to infinity of moderately complicated
1215     combinations of special functions, or indefinite integrals of very
1216     simple combinations of special functions.
1217 
1218     The strategy employed by the integration code is as follows:
1219 
1220     - If computing a definite integral, and both limits are real,
1221       and at least one limit is +- oo, try the G-function method of
1222       definite integration first.
1223 
1224     - Try to find an antiderivative, using all available methods, ordered
1225       by performance (that is try fastest method first, slowest last; in
1226       particular polynomial integration is tried first, Meijer
1227       G-functions second to last, and heuristic Risch last).
1228 
1229     - If still not successful, try G-functions irrespective of the
1230       limits.
1231 
1232     The option meijerg=True, False, None can be used to, respectively:
1233     always use G-function methods and no others, never use G-function
1234     methods, or use all available methods (in order as described above).
1235     It defaults to None.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy import integrate, log, exp, oo
1241     >>> from sympy.abc import a, x, y
1242 
1243     >>> integrate(x*y, x)
1244     x**2*y/2
1245 
1246     >>> integrate(log(x), x)
1247     x*log(x) - x
1248 
1249     >>> integrate(log(x), (x, 1, a))
1250     a*log(a) - a + 1
1251 
1252     >>> integrate(x)
1253     x**2/2
1254 
1255     Terms that are independent of x are dropped by indefinite integration:
1256 
1257     >>> from sympy import sqrt
1258     >>> integrate(sqrt(1 + x), (x, 0, x))
1259     2*(x + 1)**(3/2)/3 - 2/3
1260     >>> integrate(sqrt(1 + x), x)
1261     2*(x + 1)**(3/2)/3
1262 
1263     >>> integrate(x*y)
1264     Traceback (most recent call last):
1265     ...
1266     ValueError: specify integration variables to integrate x*y
1267 
1268     Note that ``integrate(x)`` syntax is meant only for convenience
1269     in interactive sessions and should be avoided in library code.
1270 
1271     >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'
1272     Piecewise((gamma(a + 1), -re(a) < 1),
1273         (Integral(x**a*exp(-x), (x, 0, oo)), True))
1274 
1275     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')
1276     gamma(a + 1)
1277 
1278     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')
1279     (gamma(a + 1), -re(a) < 1)
1280 
1281     See Also
1282     ========
1283 
1284     Integral, Integral.doit
1285 
1286     """
1287     meijerg = kwargs.pop('meijerg', None)
1288     conds = kwargs.pop('conds', 'piecewise')
1289     risch = kwargs.pop('risch', None)
1290     manual = kwargs.pop('manual', None)
1291     integral = Integral(*args, **kwargs)
1292 
1293     if isinstance(integral, Integral):
1294         return integral.doit(deep=False, meijerg=meijerg, conds=conds,
1295                              risch=risch, manual=manual)
1296     else:
1297         return integral
1298 
1299 
1300 def line_integrate(field, curve, vars):
1301     """line_integrate(field, Curve, variables)
1302 
1303     Compute the line integral.
1304 
1305     Examples
1306     ========
1307 
1308     >>> from sympy import Curve, line_integrate, E, ln
1309     >>> from sympy.abc import x, y, t
1310     >>> C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))
1311     >>> line_integrate(x + y, C, [x, y])
1312     3*sqrt(2)
1313 
1314     See Also
1315     ========
1316 
1317     integrate, Integral
1318     """
1319     from sympy.geometry import Curve
1320     F = sympify(field)
1321     if not F:
1322         raise ValueError(
1323             "Expecting function specifying field as first argument.")
1324     if not isinstance(curve, Curve):
1325         raise ValueError("Expecting Curve entity as second argument.")
1326     if not is_sequence(vars):
1327         raise ValueError("Expecting ordered iterable for variables.")
1328     if len(curve.functions) != len(vars):
1329         raise ValueError("Field variable size does not match curve dimension.")
1330 
1331     if curve.parameter in vars:
1332         raise ValueError("Curve parameter clashes with field parameters.")
1333 
1334     # Calculate derivatives for line parameter functions
1335     # F(r) -> F(r(t)) and finally F(r(t)*r'(t))
1336     Ft = F
1337     dldt = 0
1338     for i, var in enumerate(vars):
1339         _f = curve.functions[i]
1340         _dn = diff(_f, curve.parameter)
1341         # ...arc length
1342         dldt = dldt + (_dn * _dn)
1343         Ft = Ft.subs(var, _f)
1344     Ft = Ft * sqrt(dldt)
1345 
1346     integral = Integral(Ft, curve.limits).doit(deep=False)
1347     return integral

</code><intended_behavior>These integral-related functions should be carefully reviewed to ensure that modifications involving "ff" have not adversely affected the computation of integrals. The goal is to maintain or restore the precise handling of integrals, transformations, and evaluations based on the library's standards before the changes.</intended_behavior>, <file>sympy/simplify/combsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import Function, S, Mul, Pow, Add
4 from sympy.core.compatibility import ordered, default_sort_key
5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial
6 from sympy.functions import gamma, sqrt, sin
7 from sympy.polys import factor, cancel
8 
9 from sympy.utilities.timeutils import timethis
10 from sympy.utilities.iterables import sift
11 from sympy.utilities.iterables import uniq
12 
13 
14 
15 @timethis('combsimp')
16 def combsimp(expr):
17     r"""
18     Simplify combinatorial expressions.
19 
20     This function takes as input an expression containing factorials,
21     binomials, Pochhammer symbol and other "combinatorial" functions,
22     and tries to minimize the number of those functions and reduce
23     the size of their arguments.
24 
25     The algorithm works by rewriting all combinatorial functions as
26     expressions involving rising factorials (Pochhammer symbols) and
27     applies recurrence relations and other transformations applicable
28     to rising factorials, to reduce their arguments, possibly letting
29     the resulting rising factorial to cancel. Rising factorials with
30     the second argument being an integer are expanded into polynomial
31     forms and finally all other rising factorial are rewritten in terms
32     of more familiar functions. If the initial expression consisted of
33     gamma functions alone, the result is expressed in terms of gamma
34     functions. If the initial expression consists of gamma function
35     with some other combinatorial, the result is expressed in terms of
36     gamma functions.
37 
38     If the result is expressed using gamma functions, the following three
39     additional steps are performed:
40 
41     1. Reduce the number of gammas by applying the reflection theorem
42        gamma(x)*gamma(1-x) == pi/sin(pi*x).
43     2. Reduce the number of gammas by applying the multiplication theorem
44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).
45     3. Reduce the number of prefactors by absorbing them into gammas, where
46        possible.
47 
48     All transformation rules can be found (or was derived from) here:
49 
50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/
51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/
52 
53     Examples
54     ========
55 
56     >>> from sympy.simplify import combsimp
57     >>> from sympy import factorial, binomial
58     >>> from sympy.abc import n, k
59 
60     >>> combsimp(factorial(n)/factorial(n - 3))
61     n*(n - 2)*(n - 1)
62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))
63     (n + 1)/(k + 1)
64 
65     """
66 
67     # as a rule of thumb, if the expression contained gammas initially, it
68     # probably makes sense to retain them
69     as_gamma = expr.has(gamma)
70     as_factorial = expr.has(factorial)
71     as_binomial = expr.has(binomial)
72 
73 
74     expr = expr.replace(binomial,
75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))
76     expr = expr.replace(factorial,
77         lambda n: _rf(1, n.expand()))
78     expr = expr.rewrite(gamma)
79     expr = expr.replace(gamma,
80         lambda n: _rf(1, (n - 1).expand()))
81 
82     if as_gamma:
83         expr = expr.replace(_rf,
84             lambda a, b: gamma(a + b)/gamma(a))
85     else:
86         expr = expr.replace(_rf,
87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))
88 
89     def rule(n, k):
90         coeff, rewrite = S.One, False
91 
92         cn, _n = n.as_coeff_Add()
93 
94         if _n and cn.is_Integer and cn:
95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)
96             rewrite = True
97             n = _n
98 
99         # this sort of binomial has already been removed by
100         # rising factorials but is left here in case the order
101         # of rule application is changed
102         if k.is_Add:
103             ck, _k = k.as_coeff_Add()
104             if _k and ck.is_Integer and ck:
105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)
106                 rewrite = True
107                 k = _k
108 
109         if rewrite:
110             return coeff*binomial(n, k)
111 
112     expr = expr.replace(binomial, rule)
113 
114     def rule_gamma(expr, level=0):
115         """ Simplify products of gamma functions further. """
116 
117         if expr.is_Atom:
118             return expr
119 
120         def gamma_rat(x):
121             # helper to simplify ratios of gammas
122             was = x.count(gamma)
123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()
124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))
125             if xx.count(gamma) < was:
126                 x = xx
127             return x
128 
129         def gamma_factor(x):
130             # return True if there is a gamma factor in shallow args
131             if x.func is gamma:
132                 return True
133             if x.is_Add or x.is_Mul:
134                 return any(gamma_factor(xi) for xi in x.args)
135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):
136                 return gamma_factor(x.base)
137             return False
138 
139         # recursion step
140         if level == 0:
141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])
142             level += 1
143 
144         if not expr.is_Mul:
145             return expr
146 
147         # non-commutative step
148         if level == 1:
149             args, nc = expr.args_cnc()
150             if not args:
151                 return expr
152             if nc:
153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)
154             level += 1
155 
156         # pure gamma handling, not factor absorbtion
157         if level == 2:
158             sifted = sift(expr.args, gamma_factor)
159             gamma_ind = Mul(*sifted.pop(False, []))
160             d = Mul(*sifted.pop(True, []))
161             assert not sifted
162 
163             nd, dd = d.as_numer_denom()
164             for ipass in range(2):
165                 args = list(ordered(Mul.make_args(nd)))
166                 for i, ni in enumerate(args):
167                     if ni.is_Add:
168                         ni, dd = Add(*[
169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]
170                             ).as_numer_denom()
171                         args[i] = ni
172                         if not dd.has(gamma):
173                             break
174                 nd = Mul(*args)
175                 if ipass ==  0 and not gamma_factor(nd):
176                     break
177                 nd, dd = dd, nd  # now process in reversed order
178             expr = gamma_ind*nd/dd
179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):
180                 return expr
181             level += 1
182 
183         # iteration until constant
184         if level == 3:
185             while True:
186                 was = expr
187                 expr = rule_gamma(expr, 4)
188                 if expr == was:
189                     return expr
190 
191         numer_gammas = []
192         denom_gammas = []
193         numer_others = []
194         denom_others = []
195         def explicate(p):
196             if p is S.One:
197                 return None, []
198             b, e = p.as_base_exp()
199             if e.is_Integer:
200                 if b.func is gamma:
201                     return True, [b.args[0]]*e
202                 else:
203                     return False, [b]*e
204             else:
205                 return False, [p]
206 
207         newargs = list(ordered(expr.args))
208         while newargs:
209             n, d = newargs.pop().as_numer_denom()
210             isg, l = explicate(n)
211             if isg:
212                 numer_gammas.extend(l)
213             elif isg is False:
214                 numer_others.extend(l)
215             isg, l = explicate(d)
216             if isg:
217                 denom_gammas.extend(l)
218             elif isg is False:
219                 denom_others.extend(l)
220 
221         # =========== level 2 work: pure gamma manipulation =========
222 
223         # Try to reduce the number of gamma factors by applying the
224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)
225         for gammas, numer, denom in [(
226             numer_gammas, numer_others, denom_others),
227                 (denom_gammas, denom_others, numer_others)]:
228             new = []
229             while gammas:
230                 g1 = gammas.pop()
231                 if g1.is_integer:
232                     new.append(g1)
233                     continue
234                 for i, g2 in enumerate(gammas):
235                     n = g1 + g2 - 1
236                     if not n.is_Integer:
237                         continue
238                     numer.append(S.Pi)
239                     denom.append(sin(S.Pi*g1))
240                     gammas.pop(i)
241                     if n > 0:
242                         for k in range(n):
243                             numer.append(1 - g1 + k)
244                     elif n < 0:
245                         for k in range(-n):
246                             denom.append(-g1 - k)
247                     break
248                 else:
249                     new.append(g1)
250             # /!\ updating IN PLACE
251             gammas[:] = new
252 
253         # Try to reduce the number of gammas by using the duplication
254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =
255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could
256         # be done with higher argument ratios like gamma(3*x)/gamma(x),
257         # this would not reduce the number of gammas as in this case.
258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,
259                                 denom_others),
260                                (denom_gammas, numer_gammas, denom_others,
261                                 numer_others)]:
262 
263             while True:
264                 for x in ng:
265                     for y in dg:
266                         n = x - 2*y
267                         if n.is_Integer:
268                             break
269                     else:
270                         continue
271                     break
272                 else:
273                     break
274                 ng.remove(x)
275                 dg.remove(y)
276                 if n > 0:
277                     for k in range(n):
278                         no.append(2*y + k)
279                 elif n < 0:
280                     for k in range(-n):
281                         do.append(2*y - 1 - k)
282                 ng.append(y + S(1)/2)
283                 no.append(2**(2*y - 1))
284                 do.append(sqrt(S.Pi))
285 
286         # Try to reduce the number of gamma factors by applying the
287         # multiplication theorem (used when n gammas with args differing
288         # by 1/n mod 1 are encountered).
289         #
290         # run of 2 with args differing by 1/2
291         #
292         # >>> combsimp(gamma(x)*gamma(x+S.Half))
293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)
294         #
295         # run of 3 args differing by 1/3 (mod 1)
296         #
297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))
298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)
299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))
300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)
301         #
302         def _run(coeffs):
303             # find runs in coeffs such that the difference in terms (mod 1)
304             # of t1, t2, ..., tn is 1/n
305             u = list(uniq(coeffs))
306             for i in range(len(u)):
307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])
308                 for one, j in dj:
309                     if one.p == 1 and one.q != 1:
310                         n = one.q
311                         got = [i]
312                         get = list(range(1, n))
313                         for d, j in dj:
314                             m = n*d
315                             if m.is_Integer and m in get:
316                                 get.remove(m)
317                                 got.append(j)
318                                 if not get:
319                                     break
320                         else:
321                             continue
322                         for i, j in enumerate(got):
323                             c = u[j]
324                             coeffs.remove(c)
325                             got[i] = c
326                         return one.q, got[0], got[1:]
327 
328         def _mult_thm(gammas, numer, denom):
329             # pull off and analyze the leading coefficient from each gamma arg
330             # looking for runs in those Rationals
331 
332             # expr -> coeff + resid -> rats[resid] = coeff
333             rats = {}
334             for g in gammas:
335                 c, resid = g.as_coeff_Add()
336                 rats.setdefault(resid, []).append(c)
337 
338             # look for runs in Rationals for each resid
339             keys = sorted(rats, key=default_sort_key)
340             for resid in keys:
341                 coeffs = list(sorted(rats[resid]))
342                 new = []
343                 while True:
344                     run = _run(coeffs)
345                     if run is None:
346                         break
347 
348                     # process the sequence that was found:
349                     # 1) convert all the gamma functions to have the right
350                     #    argument (could be off by an integer)
351                     # 2) append the factors corresponding to the theorem
352                     # 3) append the new gamma function
353 
354                     n, ui, other = run
355 
356                     # (1)
357                     for u in other:
358                         con = resid + u - 1
359                         for k in range(int(u - ui)):
360                             numer.append(con - k)
361 
362                     con = n*(resid + ui)  # for (2) and (3)
363 
364                     # (2)
365                     numer.append((2*S.Pi)**(S(n - 1)/2)*
366                                  n**(S(1)/2 - con))
367                     # (3)
368                     new.append(con)
369 
370                 # restore resid to coeffs
371                 rats[resid] = [resid + c for c in coeffs] + new
372 
373             # rebuild the gamma arguments
374             g = []
375             for resid in keys:
376                 g += rats[resid]
377             # /!\ updating IN PLACE
378             gammas[:] = g
379 
380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),
381                                 (denom_gammas, denom_others, numer_others)]:
382             _mult_thm(l, numer, denom)
383 
384         # =========== level >= 2 work: factor absorbtion =========
385 
386         if level >= 2:
387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)
388             # and gamma(x)/(x - 1) -> gamma(x - 1)
389             # This code (in particular repeated calls to find_fuzzy) can be very
390             # slow.
391             def find_fuzzy(l, x):
392                 if not l:
393                     return
394                 S1, T1 = compute_ST(x)
395                 for y in l:
396                     S2, T2 = inv[y]
397                     if T1 != T2 or (not S1.intersection(S2) and
398                                     (S1 != set() or S2 != set())):
399                         continue
400                     # XXX we want some simplification (e.g. cancel or
401                     # simplify) but no matter what it's slow.
402                     a = len(cancel(x/y).free_symbols)
403                     b = len(x.free_symbols)
404                     c = len(y.free_symbols)
405                     # TODO is there a better heuristic?
406                     if a == 0 and (b > 0 or c > 0):
407                         return y
408 
409             # We thus try to avoid expensive calls by building the following
410             # "invariants": For every factor or gamma function argument
411             #   - the set of free symbols S
412             #   - the set of functional components T
413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset
414             # or S1 == S2 == emptyset)
415             inv = {}
416 
417             def compute_ST(expr):
418                 if expr in inv:
419                     return inv[expr]
420                 return (expr.free_symbols, expr.atoms(Function).union(
421                         set(e.exp for e in expr.atoms(Pow))))
422 
423             def update_ST(expr):
424                 inv[expr] = compute_ST(expr)
425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:
426                 update_ST(expr)
427 
428             for gammas, numer, denom in [(
429                 numer_gammas, numer_others, denom_others),
430                     (denom_gammas, denom_others, numer_others)]:
431                 new = []
432                 while gammas:
433                     g = gammas.pop()
434                     cont = True
435                     while cont:
436                         cont = False
437                         y = find_fuzzy(numer, g)
438                         if y is not None:
439                             numer.remove(y)
440                             if y != g:
441                                 numer.append(y/g)
442                                 update_ST(y/g)
443                             g += 1
444                             cont = True
445                         y = find_fuzzy(denom, g - 1)
446                         if y is not None:
447                             denom.remove(y)
448                             if y != g - 1:
449                                 numer.append((g - 1)/y)
450                                 update_ST((g - 1)/y)
451                             g -= 1
452                             cont = True
453                     new.append(g)
454                 # /!\ updating IN PLACE
455                 gammas[:] = new
456 
457         # =========== rebuild expr ==================================
458 
459         return Mul(*[gamma(g) for g in numer_gammas]) \
460             / Mul(*[gamma(g) for g in denom_gammas]) \
461             * Mul(*numer_others) / Mul(*denom_others)
462 
463     # (for some reason we cannot use Basic.replace in this case)
464     was = factor(expr)
465     expr = rule_gamma(was)
466     if expr != was:
467         expr = factor(expr)
468 
469     if not as_gamma:
470         if as_factorial:
471             expr = expr.rewrite(factorial)
472         elif as_binomial:
473             expr = expr.rewrite(binomial)
474 
475     return expr
476 
477 class _rf(Function):
478     @classmethod
479     def eval(cls, a, b):
480         if b.is_Integer:
481             if not b:
482                 return S.One
483 
484             n, result = int(b), S.One
485 
486             if n > 0:
487                 for i in range(n):
488                     result *= a + i
489 
490                 return result
491             elif n < 0:
492                 for i in range(1, -n + 1):
493                     result *= a - i
494 
495                 return 1/result
496         else:
497             if b.is_Add:
498                 c, _b = b.as_coeff_Add()
499 
500                 if c.is_Integer:
501                     if c > 0:
502                         return _rf(a, _b)*_rf(a + _b, c)
503                     elif c < 0:
504                         return _rf(a, _b)/_rf(a + _b + c, -c)
505 
506             if a.is_Add:
507                 c, _a = a.as_coeff_Add()
508 
509                 if c.is_Integer:
510                     if c > 0:
511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)
512                     elif c < 0:
513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)

</code><intended_behavior>The combinatorial simplification routines, including those that utilize "rf", should follow correct simplification logic to yield results consistent with the established combinatorial mathematics principles. If recent changes have introduced discrepancies or errors, a reversion or adjustment will be necessary to restore the accuracy of these simplifications.</intended_behavior>]
2025-10-16 01:54:49.394 | INFO     | Search completed. Bug locations: [<file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>RisingFactorial</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/combinatorial/factorials.py</file>
<class>binomial</class>
<method>_eval_rewrite_as_FallingFactorial</method>
<code>
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)

</code><intended_behavior>This function should accurately rewrite expressions that can be expressed in terms of falling factorials, ensuring mathematical consistency with definitions prior to the changes made in version 1.0. The behavior should respect the mathematical properties of falling factorials without introducing errors in simplification or computation.</intended_behavior>, <file>sympy/functions/special/error_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module contains various functions that are special cases
2     of incomplete gamma functions. It should probably be renamed. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, S, sympify, cacheit, pi, I
7 from sympy.core.function import Function, ArgumentIndexError
8 from sympy.core.symbol import Symbol
9 from sympy.functions.combinatorial.factorials import factorial
10 from sympy.functions.elementary.integers import floor
11 from sympy.functions.elementary.miscellaneous import sqrt, root
12 from sympy.functions.elementary.exponential import exp, log
13 from sympy.functions.elementary.complexes import polar_lift
14 from sympy.functions.elementary.hyperbolic import cosh, sinh
15 from sympy.functions.elementary.trigonometric import cos, sin, sinc
16 from sympy.functions.special.hyper import hyper, meijerg
17 from sympy.core.compatibility import range
18 
19 # TODO series expansions
20 # TODO see the "Note:" in Ei
21 
22 ###############################################################################
23 ################################ ERROR FUNCTION ###############################
24 ###############################################################################
25 
26 
27 class erf(Function):
28     r"""
29     The Gauss error function. This function is defined as:
30 
31     .. math ::
32         \mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} \mathrm{d}t.
33 
34     Examples
35     ========
36 
37     >>> from sympy import I, oo, erf
38     >>> from sympy.abc import z
39 
40     Several special values are known:
41 
42     >>> erf(0)
43     0
44     >>> erf(oo)
45     1
46     >>> erf(-oo)
47     -1
48     >>> erf(I*oo)
49     oo*I
50     >>> erf(-I*oo)
51     -oo*I
52 
53     In general one can pull out factors of -1 and I from the argument:
54 
55     >>> erf(-z)
56     -erf(z)
57 
58     The error function obeys the mirror symmetry:
59 
60     >>> from sympy import conjugate
61     >>> conjugate(erf(z))
62     erf(conjugate(z))
63 
64     Differentiation with respect to z is supported:
65 
66     >>> from sympy import diff
67     >>> diff(erf(z), z)
68     2*exp(-z**2)/sqrt(pi)
69 
70     We can numerically evaluate the error function to arbitrary precision
71     on the whole complex plane:
72 
73     >>> erf(4).evalf(30)
74     0.999999984582742099719981147840
75 
76     >>> erf(-4*I).evalf(30)
77     -1296959.73071763923152794095062*I
78 
79     See Also
80     ========
81 
82     erfc: Complementary error function.
83     erfi: Imaginary error function.
84     erf2: Two-argument error function.
85     erfinv: Inverse error function.
86     erfcinv: Inverse Complementary error function.
87     erf2inv: Inverse two-argument error function.
88 
89     References
90     ==========
91 
92     .. [1] http://en.wikipedia.org/wiki/Error_function
93     .. [2] http://dlmf.nist.gov/7
94     .. [3] http://mathworld.wolfram.com/Erf.html
95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf
96     """
97 
98     unbranched = True
99 
100     def fdiff(self, argindex=1):
101         if argindex == 1:
102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)
103         else:
104             raise ArgumentIndexError(self, argindex)
105 
106 
107     def inverse(self, argindex=1):
108         """
109         Returns the inverse of this function.
110         """
111         return erfinv
112 
113     @classmethod
114     def eval(cls, arg):
115         if arg.is_Number:
116             if arg is S.NaN:
117                 return S.NaN
118             elif arg is S.Infinity:
119                 return S.One
120             elif arg is S.NegativeInfinity:
121                 return S.NegativeOne
122             elif arg is S.Zero:
123                 return S.Zero
124 
125         if arg.func is erfinv:
126              return arg.args[0]
127 
128         if arg.func is erfcinv:
129             return S.One - arg.args[0]
130 
131         if arg.func is erf2inv and arg.args[0] is S.Zero:
132             return arg.args[1]
133 
134         # Try to pull out factors of I
135         t = arg.extract_multiplicatively(S.ImaginaryUnit)
136         if t is S.Infinity or t is S.NegativeInfinity:
137             return arg
138 
139         # Try to pull out factors of -1
140         if arg.could_extract_minus_sign():
141             return -cls(-arg)
142 
143     @staticmethod
144     @cacheit
145     def taylor_term(n, x, *previous_terms):
146         if n < 0 or n % 2 == 0:
147             return S.Zero
148         else:
149             x = sympify(x)
150             k = floor((n - 1)/S(2))
151             if len(previous_terms) > 2:
152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
153             else:
154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
155 
156     def _eval_conjugate(self):
157         return self.func(self.args[0].conjugate())
158 
159     def _eval_is_real(self):
160         return self.args[0].is_real
161 
162     def _eval_rewrite_as_uppergamma(self, z):
163         from sympy import uppergamma
164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
165 
166     def _eval_rewrite_as_fresnels(self, z):
167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
169 
170     def _eval_rewrite_as_fresnelc(self, z):
171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
173 
174     def _eval_rewrite_as_meijerg(self, z):
175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
176 
177     def _eval_rewrite_as_hyper(self, z):
178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
179 
180     def _eval_rewrite_as_expint(self, z):
181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)
182 
183     def _eval_rewrite_as_tractable(self, z):
184         return S.One - _erfs(z)*exp(-z**2)
185 
186     def _eval_rewrite_as_erfc(self, z):
187         return S.One - erfc(z)
188 
189     def _eval_rewrite_as_erfi(self, z):
190         return -I*erfi(I*z)
191 
192     def _eval_as_leading_term(self, x):
193         from sympy import Order
194         arg = self.args[0].as_leading_term(x)
195 
196         if x in arg.free_symbols and Order(1, x).contains(arg):
197             return 2*x/sqrt(pi)
198         else:
199             return self.func(arg)
200 
201     def as_real_imag(self, deep=True, **hints):
202         if self.args[0].is_real:
203             if deep:
204                 hints['complex'] = False
205                 return (self.expand(deep, **hints), S.Zero)
206             else:
207                 return (self, S.Zero)
208         if deep:
209             x, y = self.args[0].expand(deep, **hints).as_real_imag()
210         else:
211             x, y = self.args[0].as_real_imag()
212 
213         sq = -y**2/x**2
214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
216                     self.func(x + x*sqrt(sq)))
217         return (re, im)
218 
219 
220 class erfc(Function):
221     r"""
222     Complementary Error Function. The function is defined as:
223 
224     .. math ::
225         \mathrm{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-t^2} \mathrm{d}t
226 
227     Examples
228     ========
229 
230     >>> from sympy import I, oo, erfc
231     >>> from sympy.abc import z
232 
233     Several special values are known:
234 
235     >>> erfc(0)
236     1
237     >>> erfc(oo)
238     0
239     >>> erfc(-oo)
240     2
241     >>> erfc(I*oo)
242     -oo*I
243     >>> erfc(-I*oo)
244     oo*I
245 
246     The error function obeys the mirror symmetry:
247 
248     >>> from sympy import conjugate
249     >>> conjugate(erfc(z))
250     erfc(conjugate(z))
251 
252     Differentiation with respect to z is supported:
253 
254     >>> from sympy import diff
255     >>> diff(erfc(z), z)
256     -2*exp(-z**2)/sqrt(pi)
257 
258     It also follows
259 
260     >>> erfc(-z)
261     -erfc(z) + 2
262 
263     We can numerically evaluate the complementary error function to arbitrary precision
264     on the whole complex plane:
265 
266     >>> erfc(4).evalf(30)
267     0.0000000154172579002800188521596734869
268 
269     >>> erfc(4*I).evalf(30)
270     1.0 - 1296959.73071763923152794095062*I
271 
272     See Also
273     ========
274 
275     erf: Gaussian error function.
276     erfi: Imaginary error function.
277     erf2: Two-argument error function.
278     erfinv: Inverse error function.
279     erfcinv: Inverse Complementary error function.
280     erf2inv: Inverse two-argument error function.
281 
282     References
283     ==========
284 
285     .. [1] http://en.wikipedia.org/wiki/Error_function
286     .. [2] http://dlmf.nist.gov/7
287     .. [3] http://mathworld.wolfram.com/Erfc.html
288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc
289     """
290 
291     unbranched = True
292 
293     def fdiff(self, argindex=1):
294         if argindex == 1:
295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)
296         else:
297             raise ArgumentIndexError(self, argindex)
298 
299     def inverse(self, argindex=1):
300         """
301         Returns the inverse of this function.
302         """
303         return erfcinv
304 
305     @classmethod
306     def eval(cls, arg):
307         if arg.is_Number:
308             if arg is S.NaN:
309                 return S.NaN
310             elif arg is S.Infinity:
311                 return S.Zero
312             elif arg is S.Zero:
313                 return S.One
314 
315         if arg.func is erfinv:
316             return S.One - arg.args[0]
317 
318         if arg.func is erfcinv:
319             return arg.args[0]
320 
321         # Try to pull out factors of I
322         t = arg.extract_multiplicatively(S.ImaginaryUnit)
323         if t is S.Infinity or t is S.NegativeInfinity:
324             return -arg
325 
326         # Try to pull out factors of -1
327         if arg.could_extract_minus_sign():
328             return S(2) - cls(-arg)
329 
330     @staticmethod
331     @cacheit
332     def taylor_term(n, x, *previous_terms):
333         if n == 0:
334             return S.One
335         elif n < 0 or n % 2 == 0:
336             return S.Zero
337         else:
338             x = sympify(x)
339             k = floor((n - 1)/S(2))
340             if len(previous_terms) > 2:
341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
342             else:
343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
344 
345     def _eval_conjugate(self):
346         return self.func(self.args[0].conjugate())
347 
348     def _eval_is_real(self):
349         return self.args[0].is_real
350 
351     def _eval_rewrite_as_tractable(self, z):
352         return self.rewrite(erf).rewrite("tractable", deep=True)
353 
354     def _eval_rewrite_as_erf(self, z):
355         return S.One - erf(z)
356 
357     def _eval_rewrite_as_erfi(self, z):
358         return S.One + I*erfi(I*z)
359 
360     def _eval_rewrite_as_fresnels(self, z):
361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
363 
364     def _eval_rewrite_as_fresnelc(self, z):
365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)
366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
367 
368     def _eval_rewrite_as_meijerg(self, z):
369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
370 
371     def _eval_rewrite_as_hyper(self, z):
372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
373 
374     def _eval_rewrite_as_uppergamma(self, z):
375         from sympy import uppergamma
376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
377 
378     def _eval_rewrite_as_expint(self, z):
379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)
380 
381     def _eval_as_leading_term(self, x):
382         from sympy import Order
383         arg = self.args[0].as_leading_term(x)
384 
385         if x in arg.free_symbols and Order(1, x).contains(arg):
386             return S.One
387         else:
388             return self.func(arg)
389 
390     def as_real_imag(self, deep=True, **hints):
391         if self.args[0].is_real:
392             if deep:
393                 hints['complex'] = False
394                 return (self.expand(deep, **hints), S.Zero)
395             else:
396                 return (self, S.Zero)
397         if deep:
398             x, y = self.args[0].expand(deep, **hints).as_real_imag()
399         else:
400             x, y = self.args[0].as_real_imag()
401 
402         sq = -y**2/x**2
403         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
404         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
405                     self.func(x + x*sqrt(sq)))
406         return (re, im)
407 
408 class erfi(Function):
409     r"""
410     Imaginary error function. The function erfi is defined as:
411 
412     .. math ::
413         \mathrm{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{t^2} \mathrm{d}t
414 
415     Examples
416     ========
417 
418     >>> from sympy import I, oo, erfi
419     >>> from sympy.abc import z
420 
421     Several special values are known:
422 
423     >>> erfi(0)
424     0
425     >>> erfi(oo)
426     oo
427     >>> erfi(-oo)
428     -oo
429     >>> erfi(I*oo)
430     I
431     >>> erfi(-I*oo)
432     -I
433 
434     In general one can pull out factors of -1 and I from the argument:
435 
436     >>> erfi(-z)
437     -erfi(z)
438 
439     >>> from sympy import conjugate
440     >>> conjugate(erfi(z))
441     erfi(conjugate(z))
442 
443     Differentiation with respect to z is supported:
444 
445     >>> from sympy import diff
446     >>> diff(erfi(z), z)
447     2*exp(z**2)/sqrt(pi)
448 
449     We can numerically evaluate the imaginary error function to arbitrary precision
450     on the whole complex plane:
451 
452     >>> erfi(2).evalf(30)
453     18.5648024145755525987042919132
454 
455     >>> erfi(-2*I).evalf(30)
456     -0.995322265018952734162069256367*I
457 
458     See Also
459     ========
460 
461     erf: Gaussian error function.
462     erfc: Complementary error function.
463     erf2: Two-argument error function.
464     erfinv: Inverse error function.
465     erfcinv: Inverse Complementary error function.
466     erf2inv: Inverse two-argument error function.
467 
468     References
469     ==========
470 
471     .. [1] http://en.wikipedia.org/wiki/Error_function
472     .. [2] http://mathworld.wolfram.com/Erfi.html
473     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi
474     """
475 
476     unbranched = True
477 
478     def fdiff(self, argindex=1):
479         if argindex == 1:
480             return 2*exp(self.args[0]**2)/sqrt(S.Pi)
481         else:
482             raise ArgumentIndexError(self, argindex)
483 
484     @classmethod
485     def eval(cls, z):
486         if z.is_Number:
487             if z is S.NaN:
488                 return S.NaN
489             elif z is S.Zero:
490                 return S.Zero
491             elif z is S.Infinity:
492                 return S.Infinity
493 
494         # Try to pull out factors of -1
495         if z.could_extract_minus_sign():
496             return -cls(-z)
497 
498         # Try to pull out factors of I
499         nz = z.extract_multiplicatively(I)
500         if nz is not None:
501             if nz is S.Infinity:
502                 return I
503             if nz.func is erfinv:
504                 return I*nz.args[0]
505             if nz.func is erfcinv:
506                 return I*(S.One - nz.args[0])
507             if nz.func is erf2inv and nz.args[0] is S.Zero:
508                 return I*nz.args[1]
509 
510     @staticmethod
511     @cacheit
512     def taylor_term(n, x, *previous_terms):
513         if n < 0 or n % 2 == 0:
514             return S.Zero
515         else:
516             x = sympify(x)
517             k = floor((n - 1)/S(2))
518             if len(previous_terms) > 2:
519                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)
520             else:
521                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))
522 
523     def _eval_conjugate(self):
524         return self.func(self.args[0].conjugate())
525 
526     def _eval_is_real(self):
527         return self.args[0].is_real
528 
529     def _eval_rewrite_as_tractable(self, z):
530         return self.rewrite(erf).rewrite("tractable", deep=True)
531 
532     def _eval_rewrite_as_erf(self, z):
533         return -I*erf(I*z)
534 
535     def _eval_rewrite_as_erfc(self, z):
536         return I*erfc(I*z) - I
537 
538     def _eval_rewrite_as_fresnels(self, z):
539         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
540         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
541 
542     def _eval_rewrite_as_fresnelc(self, z):
543         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
544         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
545 
546     def _eval_rewrite_as_meijerg(self, z):
547         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)
548 
549     def _eval_rewrite_as_hyper(self, z):
550         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)
551 
552     def _eval_rewrite_as_uppergamma(self, z):
553         from sympy import uppergamma
554         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)
555 
556     def _eval_rewrite_as_expint(self, z):
557         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)
558 
559     def as_real_imag(self, deep=True, **hints):
560         if self.args[0].is_real:
561             if deep:
562                 hints['complex'] = False
563                 return (self.expand(deep, **hints), S.Zero)
564             else:
565                 return (self, S.Zero)
566         if deep:
567             x, y = self.args[0].expand(deep, **hints).as_real_imag()
568         else:
569             x, y = self.args[0].as_real_imag()
570 
571         sq = -y**2/x**2
572         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
573         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
574                     self.func(x + x*sqrt(sq)))
575         return (re, im)
576 
577 class erf2(Function):
578     r"""
579     Two-argument error function. This function is defined as:
580 
581     .. math ::
582         \mathrm{erf2}(x, y) = \frac{2}{\sqrt{\pi}} \int_x^y e^{-t^2} \mathrm{d}t
583 
584     Examples
585     ========
586 
587     >>> from sympy import I, oo, erf2
588     >>> from sympy.abc import x, y
589 
590     Several special values are known:
591 
592     >>> erf2(0, 0)
593     0
594     >>> erf2(x, x)
595     0
596     >>> erf2(x, oo)
597     -erf(x) + 1
598     >>> erf2(x, -oo)
599     -erf(x) - 1
600     >>> erf2(oo, y)
601     erf(y) - 1
602     >>> erf2(-oo, y)
603     erf(y) + 1
604 
605     In general one can pull out factors of -1:
606 
607     >>> erf2(-x, -y)
608     -erf2(x, y)
609 
610     The error function obeys the mirror symmetry:
611 
612     >>> from sympy import conjugate
613     >>> conjugate(erf2(x, y))
614     erf2(conjugate(x), conjugate(y))
615 
616     Differentiation with respect to x, y is supported:
617 
618     >>> from sympy import diff
619     >>> diff(erf2(x, y), x)
620     -2*exp(-x**2)/sqrt(pi)
621     >>> diff(erf2(x, y), y)
622     2*exp(-y**2)/sqrt(pi)
623 
624     See Also
625     ========
626 
627     erf: Gaussian error function.
628     erfc: Complementary error function.
629     erfi: Imaginary error function.
630     erfinv: Inverse error function.
631     erfcinv: Inverse Complementary error function.
632     erf2inv: Inverse two-argument error function.
633 
634     References
635     ==========
636 
637     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/
638     """
639 
640 
641     def fdiff(self, argindex):
642         x, y = self.args
643         if argindex == 1:
644             return -2*exp(-x**2)/sqrt(S.Pi)
645         elif argindex == 2:
646             return 2*exp(-y**2)/sqrt(S.Pi)
647         else:
648             raise ArgumentIndexError(self, argindex)
649 
650     @classmethod
651     def eval(cls, x, y):
652         I = S.Infinity
653         N = S.NegativeInfinity
654         O = S.Zero
655         if x is S.NaN or y is S.NaN:
656             return S.NaN
657         elif x == y:
658             return S.Zero
659         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):
660             return erf(y) - erf(x)
661 
662         if y.func is erf2inv and y.args[0] == x:
663             return y.args[1]
664 
665         #Try to pull out -1 factor
666         sign_x = x.could_extract_minus_sign()
667         sign_y = y.could_extract_minus_sign()
668         if (sign_x and sign_y):
669             return -cls(-x, -y)
670         elif (sign_x or sign_y):
671             return erf(y)-erf(x)
672 
673     def _eval_conjugate(self):
674         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
675 
676     def _eval_is_real(self):
677         return self.args[0].is_real and self.args[1].is_real
678 
679     def _eval_rewrite_as_erf(self, x, y):
680         return erf(y) - erf(x)
681 
682     def _eval_rewrite_as_erfc(self, x, y):
683         return erfc(x) - erfc(y)
684 
685     def _eval_rewrite_as_erfi(self, x, y):
686         return I*(erfi(I*x)-erfi(I*y))
687 
688     def _eval_rewrite_as_fresnels(self, x, y):
689         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)
690 
691     def _eval_rewrite_as_fresnelc(self, x, y):
692         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)
693 
694     def _eval_rewrite_as_meijerg(self, x, y):
695         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)
696 
697     def _eval_rewrite_as_hyper(self, x, y):
698         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)
699 
700     def _eval_rewrite_as_uppergamma(self, x, y):
701         from sympy import uppergamma
702         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -
703             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))
704 
705     def _eval_rewrite_as_expint(self, x, y):
706         return erf(y).rewrite(expint) - erf(x).rewrite(expint)
707 
708 class erfinv(Function):
709     r"""
710     Inverse Error Function. The erfinv function is defined as:
711 
712     .. math ::
713         \mathrm{erf}(x) = y \quad \Rightarrow \quad \mathrm{erfinv}(y) = x
714 
715     Examples
716     ========
717 
718     >>> from sympy import I, oo, erfinv
719     >>> from sympy.abc import x
720 
721     Several special values are known:
722 
723     >>> erfinv(0)
724     0
725     >>> erfinv(1)
726     oo
727 
728     Differentiation with respect to x is supported:
729 
730     >>> from sympy import diff
731     >>> diff(erfinv(x), x)
732     sqrt(pi)*exp(erfinv(x)**2)/2
733 
734     We can numerically evaluate the inverse error function to arbitrary precision
735     on [-1, 1]:
736 
737     >>> erfinv(0.2).evalf(30)
738     0.179143454621291692285822705344
739 
740     See Also
741     ========
742 
743     erf: Gaussian error function.
744     erfc: Complementary error function.
745     erfi: Imaginary error function.
746     erf2: Two-argument error function.
747     erfcinv: Inverse Complementary error function.
748     erf2inv: Inverse two-argument error function.
749 
750     References
751     ==========
752 
753     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions
754     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/
755     """
756 
757 
758     def fdiff(self, argindex =1):
759         if argindex == 1:
760             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
761         else :
762             raise ArgumentIndexError(self, argindex)
763 
764     def inverse(self, argindex=1):
765         """
766         Returns the inverse of this function.
767         """
768         return erf
769 
770     @classmethod
771     def eval(cls, z):
772         if z is S.NaN:
773             return S.NaN
774         elif z is S.NegativeOne:
775             return S.NegativeInfinity
776         elif z is S.Zero:
777             return S.Zero
778         elif z is S.One:
779             return S.Infinity
780 
781         if (z.func is erf) and z.args[0].is_real:
782             return z.args[0]
783 
784         # Try to pull out factors of -1
785         nz = z.extract_multiplicatively(-1)
786         if nz is not None and ((nz.func is erf) and (nz.args[0]).is_real):
787             return -nz.args[0]
788 
789     def _eval_rewrite_as_erfcinv(self, z):
790        return erfcinv(1-z)
791 
792 class erfcinv (Function):
793     r"""
794     Inverse Complementary Error Function. The erfcinv function is defined as:
795 
796     .. math ::
797         \mathrm{erfc}(x) = y \quad \Rightarrow \quad \mathrm{erfcinv}(y) = x
798 
799     Examples
800     ========
801 
802     >>> from sympy import I, oo, erfcinv
803     >>> from sympy.abc import x
804 
805     Several special values are known:
806 
807     >>> erfcinv(1)
808     0
809     >>> erfcinv(0)
810     oo
811 
812     Differentiation with respect to x is supported:
813 
814     >>> from sympy import diff
815     >>> diff(erfcinv(x), x)
816     -sqrt(pi)*exp(erfcinv(x)**2)/2
817 
818     See Also
819     ========
820 
821     erf: Gaussian error function.
822     erfc: Complementary error function.
823     erfi: Imaginary error function.
824     erf2: Two-argument error function.
825     erfinv: Inverse error function.
826     erf2inv: Inverse two-argument error function.
827 
828     References
829     ==========
830 
831     .. [1] http://en.wikipedia.org/wiki/Error_function#Inverse_functions
832     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/
833     """
834 
835 
836     def fdiff(self, argindex =1):
837         if argindex == 1:
838             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
839         else:
840             raise ArgumentIndexError(self, argindex)
841 
842     def inverse(self, argindex=1):
843         """
844         Returns the inverse of this function.
845         """
846         return erfc
847 
848     @classmethod
849     def eval(cls, z):
850         if z is S.NaN:
851             return S.NaN
852         elif z is S.Zero:
853             return S.Infinity
854         elif z is S.One:
855             return S.Zero
856         elif z == 2:
857             return S.NegativeInfinity
858 
859     def _eval_rewrite_as_erfinv(self, z):
860         return erfinv(1-z)
861 
862 class erf2inv(Function):
863     r"""
864     Two-argument Inverse error function. The erf2inv function is defined as:
865 
866     .. math ::
867         \mathrm{erf2}(x, w) = y \quad \Rightarrow \quad \mathrm{erf2inv}(x, y) = w
868 
869     Examples
870     ========
871 
872     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv
873     >>> from sympy.abc import x, y
874 
875     Several special values are known:
876 
877     >>> erf2inv(0, 0)
878     0
879     >>> erf2inv(1, 0)
880     1
881     >>> erf2inv(0, 1)
882     oo
883     >>> erf2inv(0, y)
884     erfinv(y)
885     >>> erf2inv(oo, y)
886     erfcinv(-y)
887 
888     Differentiation with respect to x and y is supported:
889 
890     >>> from sympy import diff
891     >>> diff(erf2inv(x, y), x)
892     exp(-x**2 + erf2inv(x, y)**2)
893     >>> diff(erf2inv(x, y), y)
894     sqrt(pi)*exp(erf2inv(x, y)**2)/2
895 
896     See Also
897     ========
898 
899     erf: Gaussian error function.
900     erfc: Complementary error function.
901     erfi: Imaginary error function.
902     erf2: Two-argument error function.
903     erfinv: Inverse error function.
904     erfcinv: Inverse complementary error function.
905 
906     References
907     ==========
908 
909     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/
910     """
911 
912 
913     def fdiff(self, argindex):
914         x, y = self.args
915         if argindex == 1:
916             return exp(self.func(x,y)**2-x**2)
917         elif argindex == 2:
918             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)
919         else:
920             raise ArgumentIndexError(self, argindex)
921 
922     @classmethod
923     def eval(cls, x, y):
924         if x is S.NaN or y is S.NaN:
925             return S.NaN
926         elif x is S.Zero and y is S.Zero:
927             return S.Zero
928         elif x is S.Zero and y is S.One:
929             return S.Infinity
930         elif x is S.One and y is S.Zero:
931             return S.One
932         elif x is S.Zero:
933             return erfinv(y)
934         elif x is S.Infinity:
935             return erfcinv(-y)
936         elif y is S.Zero:
937             return x
938         elif y is S.Infinity:
939             return erfinv(x)
940 
941 
942 ###############################################################################
943 #################### EXPONENTIAL INTEGRALS ####################################
944 ###############################################################################
945 
946 class Ei(Function):
947     r"""
948     The classical exponential integral.
949 
950     For use in SymPy, this function is defined as
951 
952     .. math:: \operatorname{Ei}(x) = \sum_{n=1}^\infty \frac{x^n}{n\, n!}
953                                      + \log(x) + \gamma,
954 
955     where `\gamma` is the Euler-Mascheroni constant.
956 
957     If `x` is a polar number, this defines an analytic function on the
958     Riemann surface of the logarithm. Otherwise this defines an analytic
959     function in the cut plane `\mathbb{C} \setminus (-\infty, 0]`.
960 
961     **Background**
962 
963     The name *exponential integral* comes from the following statement:
964 
965     .. math:: \operatorname{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t
966 
967     If the integral is interpreted as a Cauchy principal value, this statement
968     holds for `x > 0` and `\operatorname{Ei}(x)` as defined above.
969 
970     Note that we carefully avoided defining `\operatorname{Ei}(x)` for
971     negative real `x`. This is because above integral formula does not hold for
972     any polar lift of such `x`, indeed all branches of
973     `\operatorname{Ei}(x)` above the negative reals are imaginary.
974 
975     However, the following statement holds for all `x \in \mathbb{R}^*`:
976 
977     .. math:: \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t =
978               \frac{\operatorname{Ei}\left(|x|e^{i \arg(x)}\right) +
979                     \operatorname{Ei}\left(|x|e^{- i \arg(x)}\right)}{2},
980 
981     where the integral is again understood to be a principal value if
982     `x > 0`, and `|x|e^{i \arg(x)}`,
983     `|x|e^{- i \arg(x)}` denote two conjugate polar lifts of `x`.
984 
985     Examples
986     ========
987 
988     >>> from sympy import Ei, polar_lift, exp_polar, I, pi
989     >>> from sympy.abc import x
990 
991     The exponential integral in SymPy is strictly undefined for negative values
992     of the argument. For convenience, exponential integrals with negative
993     arguments are immediately converted into an expression that agrees with
994     the classical integral definition:
995 
996     >>> Ei(-1)
997     -I*pi + Ei(exp_polar(I*pi))
998 
999     This yields a real value:
1000 
1001     >>> Ei(-1).n(chop=True)
1002     -0.219383934395520
1003 
1004     On the other hand the analytic continuation is not real:
1005 
1006     >>> Ei(polar_lift(-1)).n(chop=True)
1007     -0.21938393439552 + 3.14159265358979*I
1008 
1009     The exponential integral has a logarithmic branch point at the origin:
1010 
1011     >>> Ei(x*exp_polar(2*I*pi))
1012     Ei(x) + 2*I*pi
1013 
1014     Differentiation is supported:
1015 
1016     >>> Ei(x).diff(x)
1017     exp(x)/x
1018 
1019     The exponential integral is related to many other special functions.
1020     For example:
1021 
1022     >>> from sympy import uppergamma, expint, Shi
1023     >>> Ei(x).rewrite(expint)
1024     -expint(1, x*exp_polar(I*pi)) - I*pi
1025     >>> Ei(x).rewrite(Shi)
1026     Chi(x) + Shi(x)
1027 
1028     See Also
1029     ========
1030 
1031     expint: Generalised exponential integral.
1032     E1: Special case of the generalised exponential integral.
1033     li: Logarithmic integral.
1034     Li: Offset logarithmic integral.
1035     Si: Sine integral.
1036     Ci: Cosine integral.
1037     Shi: Hyperbolic sine integral.
1038     Chi: Hyperbolic cosine integral.
1039     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.
1040 
1041     References
1042     ==========
1043 
1044     .. [1] http://dlmf.nist.gov/6.6
1045     .. [2] http://en.wikipedia.org/wiki/Exponential_integral
1046     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm
1047 
1048     """
1049 
1050 
1051     @classmethod
1052     def eval(cls, z):
1053         if z is S.Zero:
1054             return S.NegativeInfinity
1055         elif z is S.Infinity:
1056             return S.Infinity
1057         elif z is S.NegativeInfinity:
1058             return S.Zero
1059 
1060         if not z.is_polar and z.is_negative:
1061             # Note: is this a good idea?
1062             return Ei(polar_lift(z)) - pi*I
1063         nz, n = z.extract_branch_factor()
1064         if n:
1065             return Ei(nz) + 2*I*pi*n
1066 
1067     def fdiff(self, argindex=1):
1068         from sympy import unpolarify
1069         arg = unpolarify(self.args[0])
1070         if argindex == 1:
1071             return exp(arg)/arg
1072         else:
1073             raise ArgumentIndexError(self, argindex)
1074 
1075     def _eval_evalf(self, prec):
1076         if (self.args[0]/polar_lift(-1)).is_positive:
1077             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)
1078         return Function._eval_evalf(self, prec)
1079 
1080     def _eval_rewrite_as_uppergamma(self, z):
1081         from sympy import uppergamma
1082         # XXX this does not currently work usefully because uppergamma
1083         #     immediately turns into expint
1084         return -uppergamma(0, polar_lift(-1)*z) - I*pi
1085 
1086     def _eval_rewrite_as_expint(self, z):
1087         return -expint(1, polar_lift(-1)*z) - I*pi
1088 
1089     def _eval_rewrite_as_li(self, z):
1090         if isinstance(z, log):
1091             return li(z.args[0])
1092         # TODO:
1093         # Actually it only holds that:
1094         #  Ei(z) = li(exp(z))
1095         # for -pi < imag(z) <= pi
1096         return li(exp(z))
1097 
1098     def _eval_rewrite_as_Si(self, z):
1099         return Shi(z) + Chi(z)
1100     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1101     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1102     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1103 
1104     def _eval_rewrite_as_tractable(self, z):
1105         return exp(z) * _eis(z)
1106 
1107     def _eval_nseries(self, x, n, logx):
1108         x0 = self.args[0].limit(x, 0)
1109         if x0 is S.Zero:
1110             f = self._eval_rewrite_as_Si(*self.args)
1111             return f._eval_nseries(x, n, logx)
1112         return super(Ei, self)._eval_nseries(x, n, logx)
1113 
1114 
1115 class expint(Function):
1116     r"""
1117     Generalized exponential integral.
1118 
1119     This function is defined as
1120 
1121     .. math:: \operatorname{E}_\nu(z) = z^{\nu - 1} \Gamma(1 - \nu, z),
1122 
1123     where `\Gamma(1 - \nu, z)` is the upper incomplete gamma function
1124     (``uppergamma``).
1125 
1126     Hence for :math:`z` with positive real part we have
1127 
1128     .. math:: \operatorname{E}_\nu(z)
1129               =   \int_1^\infty \frac{e^{-zt}}{z^\nu} \mathrm{d}t,
1130 
1131     which explains the name.
1132 
1133     The representation as an incomplete gamma function provides an analytic
1134     continuation for :math:`\operatorname{E}_\nu(z)`. If :math:`\nu` is a
1135     non-positive integer the exponential integral is thus an unbranched
1136     function of :math:`z`, otherwise there is a branch point at the origin.
1137     Refer to the incomplete gamma function documentation for details of the
1138     branching behavior.
1139 
1140     Examples
1141     ========
1142 
1143     >>> from sympy import expint, S
1144     >>> from sympy.abc import nu, z
1145 
1146     Differentiation is supported. Differentiation with respect to z explains
1147     further the name: for integral orders, the exponential integral is an
1148     iterated integral of the exponential function.
1149 
1150     >>> expint(nu, z).diff(z)
1151     -expint(nu - 1, z)
1152 
1153     Differentiation with respect to nu has no classical expression:
1154 
1155     >>> expint(nu, z).diff(nu)
1156     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, -nu + 1), ()), z)
1157 
1158     At non-postive integer orders, the exponential integral reduces to the
1159     exponential function:
1160 
1161     >>> expint(0, z)
1162     exp(-z)/z
1163     >>> expint(-1, z)
1164     exp(-z)/z + exp(-z)/z**2
1165 
1166     At half-integers it reduces to error functions:
1167 
1168     >>> expint(S(1)/2, z)
1169     sqrt(pi)*erfc(sqrt(z))/sqrt(z)
1170 
1171     At positive integer orders it can be rewritten in terms of exponentials
1172     and expint(1, z). Use expand_func() to do this:
1173 
1174     >>> from sympy import expand_func
1175     >>> expand_func(expint(5, z))
1176     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24
1177 
1178     The generalised exponential integral is essentially equivalent to the
1179     incomplete gamma function:
1180 
1181     >>> from sympy import uppergamma
1182     >>> expint(nu, z).rewrite(uppergamma)
1183     z**(nu - 1)*uppergamma(-nu + 1, z)
1184 
1185     As such it is branched at the origin:
1186 
1187     >>> from sympy import exp_polar, pi, I
1188     >>> expint(4, z*exp_polar(2*pi*I))
1189     I*pi*z**3/3 + expint(4, z)
1190     >>> expint(nu, z*exp_polar(2*pi*I))
1191     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(-nu + 1) + expint(nu, z)
1192 
1193     See Also
1194     ========
1195 
1196     Ei: Another related function called exponential integral.
1197     E1: The classical case, returns expint(1, z).
1198     li: Logarithmic integral.
1199     Li: Offset logarithmic integral.
1200     Si: Sine integral.
1201     Ci: Cosine integral.
1202     Shi: Hyperbolic sine integral.
1203     Chi: Hyperbolic cosine integral.
1204     sympy.functions.special.gamma_functions.uppergamma
1205 
1206     References
1207     ==========
1208 
1209     .. [1] http://dlmf.nist.gov/8.19
1210     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/
1211     .. [3] http://en.wikipedia.org/wiki/Exponential_integral
1212 
1213     """
1214 
1215 
1216     @classmethod
1217     def eval(cls, nu, z):
1218         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,
1219                            factorial)
1220         nu2 = unpolarify(nu)
1221         if nu != nu2:
1222             return expint(nu2, z)
1223         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):
1224             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))
1225 
1226         # Extract branching information. This can be deduced from what is
1227         # explained in lowergamma.eval().
1228         z, n = z.extract_branch_factor()
1229         if n == 0:
1230             return
1231         if nu.is_integer:
1232             if (nu > 0) != True:
1233                 return
1234             return expint(nu, z) \
1235                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)
1236         else:
1237             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)
1238 
1239     def fdiff(self, argindex):
1240         from sympy import meijerg
1241         nu, z = self.args
1242         if argindex == 1:
1243             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)
1244         elif argindex == 2:
1245             return -expint(nu - 1, z)
1246         else:
1247             raise ArgumentIndexError(self, argindex)
1248 
1249     def _eval_rewrite_as_uppergamma(self, nu, z):
1250         from sympy import uppergamma
1251         return z**(nu - 1)*uppergamma(1 - nu, z)
1252 
1253     def _eval_rewrite_as_Ei(self, nu, z):
1254         from sympy import exp_polar, unpolarify, exp, factorial
1255         if nu == 1:
1256             return -Ei(z*exp_polar(-I*pi)) - I*pi
1257         elif nu.is_Integer and nu > 1:
1258             # DLMF, 8.19.7
1259             x = -unpolarify(z)
1260             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \
1261                 exp(x)/factorial(nu - 1) * \
1262                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])
1263         else:
1264             return self
1265 
1266     def _eval_expand_func(self, **hints):
1267         return self.rewrite(Ei).rewrite(expint, **hints)
1268 
1269     def _eval_rewrite_as_Si(self, nu, z):
1270         if nu != 1:
1271             return self
1272         return Shi(z) - Chi(z)
1273     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1274     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1275     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1276 
1277     def _eval_nseries(self, x, n, logx):
1278         if not self.args[0].has(x):
1279             nu = self.args[0]
1280             if nu == 1:
1281                 f = self._eval_rewrite_as_Si(*self.args)
1282                 return f._eval_nseries(x, n, logx)
1283             elif nu.is_Integer and nu > 1:
1284                 f = self._eval_rewrite_as_Ei(*self.args)
1285                 return f._eval_nseries(x, n, logx)
1286         return super(expint, self)._eval_nseries(x, n, logx)
1287 
1288     def _sage_(self):
1289         import sage.all as sage
1290         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())
1291 
1292 
1293 def E1(z):
1294     """
1295     Classical case of the generalized exponential integral.
1296 
1297     This is equivalent to ``expint(1, z)``.
1298 
1299     See Also
1300     ========
1301 
1302     Ei: Exponential integral.
1303     expint: Generalised exponential integral.
1304     li: Logarithmic integral.
1305     Li: Offset logarithmic integral.
1306     Si: Sine integral.
1307     Ci: Cosine integral.
1308     Shi: Hyperbolic sine integral.
1309     Chi: Hyperbolic cosine integral.
1310     """
1311     return expint(1, z)
1312 
1313 
1314 class li(Function):
1315     r"""
1316     The classical logarithmic integral.
1317 
1318     For the use in SymPy, this function is defined as
1319 
1320     .. math:: \operatorname{li}(x) = \int_0^x \frac{1}{\log(t)} \mathrm{d}t \,.
1321 
1322     Examples
1323     ========
1324 
1325     >>> from sympy import I, oo, li
1326     >>> from sympy.abc import z
1327 
1328     Several special values are known:
1329 
1330     >>> li(0)
1331     0
1332     >>> li(1)
1333     -oo
1334     >>> li(oo)
1335     oo
1336 
1337     Differentiation with respect to z is supported:
1338 
1339     >>> from sympy import diff
1340     >>> diff(li(z), z)
1341     1/log(z)
1342 
1343     Defining the `li` function via an integral:
1344 
1345 
1346     The logarithmic integral can also be defined in terms of Ei:
1347 
1348     >>> from sympy import Ei
1349     >>> li(z).rewrite(Ei)
1350     Ei(log(z))
1351     >>> diff(li(z).rewrite(Ei), z)
1352     1/log(z)
1353 
1354     We can numerically evaluate the logarithmic integral to arbitrary precision
1355     on the whole complex plane (except the singular points):
1356 
1357     >>> li(2).evalf(30)
1358     1.04516378011749278484458888919
1359 
1360     >>> li(2*I).evalf(30)
1361     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I
1362 
1363     We can even compute Soldner's constant by the help of mpmath:
1364 
1365     >>> from mpmath import findroot
1366     >>> findroot(li, 2)
1367     1.45136923488338
1368 
1369     Further transformations include rewriting `li` in terms of
1370     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:
1371 
1372     >>> from sympy import Si, Ci, Shi, Chi
1373     >>> li(z).rewrite(Si)
1374     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1375     >>> li(z).rewrite(Ci)
1376     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1377     >>> li(z).rewrite(Shi)
1378     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1379     >>> li(z).rewrite(Chi)
1380     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1381 
1382     See Also
1383     ========
1384 
1385     Li: Offset logarithmic integral.
1386     Ei: Exponential integral.
1387     expint: Generalised exponential integral.
1388     E1: Special case of the generalised exponential integral.
1389     Si: Sine integral.
1390     Ci: Cosine integral.
1391     Shi: Hyperbolic sine integral.
1392     Chi: Hyperbolic cosine integral.
1393 
1394     References
1395     ==========
1396 
1397     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral
1398     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1399     .. [3] http://dlmf.nist.gov/6
1400     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html
1401     """
1402 
1403 
1404     @classmethod
1405     def eval(cls, z):
1406         if z is S.Zero:
1407             return S.Zero
1408         elif z is S.One:
1409             return S.NegativeInfinity
1410         elif z is S.Infinity:
1411             return S.Infinity
1412 
1413     def fdiff(self, argindex=1):
1414         arg = self.args[0]
1415         if argindex == 1:
1416             return S.One / log(arg)
1417         else:
1418             raise ArgumentIndexError(self, argindex)
1419 
1420     def _eval_conjugate(self):
1421         z = self.args[0]
1422         # Exclude values on the branch cut (-oo, 0)
1423         if not (z.is_real and z.is_negative):
1424             return self.func(z.conjugate())
1425 
1426     def _eval_rewrite_as_Li(self, z):
1427         return Li(z) + li(2)
1428 
1429     def _eval_rewrite_as_Ei(self, z):
1430         return Ei(log(z))
1431 
1432     def _eval_rewrite_as_uppergamma(self, z):
1433         from sympy import uppergamma
1434         return (-uppergamma(0, -log(z)) +
1435                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))
1436 
1437     def _eval_rewrite_as_Si(self, z):
1438         return (Ci(I*log(z)) - I*Si(I*log(z)) -
1439                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))
1440 
1441     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1442 
1443     def _eval_rewrite_as_Shi(self, z):
1444         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))
1445 
1446     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi
1447 
1448     def _eval_rewrite_as_hyper(self, z):
1449         return (log(z)*hyper((1, 1), (2, 2), log(z)) +
1450                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)
1451 
1452     def _eval_rewrite_as_meijerg(self, z):
1453         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))
1454                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))
1455 
1456     def _eval_rewrite_as_tractable(self, z):
1457         return z * _eis(log(z))
1458 
1459 
1460 class Li(Function):
1461     r"""
1462     The offset logarithmic integral.
1463 
1464     For the use in SymPy, this function is defined as
1465 
1466     .. math:: \operatorname{Li}(x) = \operatorname{li}(x) - \operatorname{li}(2)
1467 
1468     Examples
1469     ========
1470 
1471     >>> from sympy import I, oo, Li
1472     >>> from sympy.abc import z
1473 
1474     The following special value is known:
1475 
1476     >>> Li(2)
1477     0
1478 
1479     Differentiation with respect to z is supported:
1480 
1481     >>> from sympy import diff
1482     >>> diff(Li(z), z)
1483     1/log(z)
1484 
1485     The shifted logarithmic integral can be written in terms of `li(z)`:
1486 
1487     >>> from sympy import li
1488     >>> Li(z).rewrite(li)
1489     li(z) - li(2)
1490 
1491     We can numerically evaluate the logarithmic integral to arbitrary precision
1492     on the whole complex plane (except the singular points):
1493 
1494     >>> Li(2).evalf(30)
1495     0
1496 
1497     >>> Li(4).evalf(30)
1498     1.92242131492155809316615998938
1499 
1500     See Also
1501     ========
1502 
1503     li: Logarithmic integral.
1504     Ei: Exponential integral.
1505     expint: Generalised exponential integral.
1506     E1: Special case of the generalised exponential integral.
1507     Si: Sine integral.
1508     Ci: Cosine integral.
1509     Shi: Hyperbolic sine integral.
1510     Chi: Hyperbolic cosine integral.
1511 
1512     References
1513     ==========
1514 
1515     .. [1] http://en.wikipedia.org/wiki/Logarithmic_integral
1516     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1517     .. [3] http://dlmf.nist.gov/6
1518     """
1519 
1520 
1521     @classmethod
1522     def eval(cls, z):
1523         if z is S.Infinity:
1524             return S.Infinity
1525         elif z is 2*S.One:
1526             return S.Zero
1527 
1528     def fdiff(self, argindex=1):
1529         arg = self.args[0]
1530         if argindex == 1:
1531             return S.One / log(arg)
1532         else:
1533             raise ArgumentIndexError(self, argindex)
1534 
1535     def _eval_evalf(self, prec):
1536         return self.rewrite(li).evalf(prec)
1537 
1538     def _eval_rewrite_as_li(self, z):
1539         return li(z) - li(2)
1540 
1541     def _eval_rewrite_as_tractable(self, z):
1542         return self.rewrite(li).rewrite("tractable", deep=True)
1543 
1544 ###############################################################################
1545 #################### TRIGONOMETRIC INTEGRALS ##################################
1546 ###############################################################################
1547 
1548 class TrigonometricIntegral(Function):
1549     """ Base class for trigonometric integrals. """
1550 
1551 
1552     @classmethod
1553     def eval(cls, z):
1554         if z == 0:
1555             return cls._atzero
1556         elif z is S.Infinity:
1557             return cls._atinf()
1558         elif z is S.NegativeInfinity:
1559             return cls._atneginf()
1560 
1561         nz = z.extract_multiplicatively(polar_lift(I))
1562         if nz is None and cls._trigfunc(0) == 0:
1563             nz = z.extract_multiplicatively(I)
1564         if nz is not None:
1565             return cls._Ifactor(nz, 1)
1566         nz = z.extract_multiplicatively(polar_lift(-I))
1567         if nz is not None:
1568             return cls._Ifactor(nz, -1)
1569 
1570         nz = z.extract_multiplicatively(polar_lift(-1))
1571         if nz is None and cls._trigfunc(0) == 0:
1572             nz = z.extract_multiplicatively(-1)
1573         if nz is not None:
1574             return cls._minusfactor(nz)
1575 
1576         nz, n = z.extract_branch_factor()
1577         if n == 0 and nz == z:
1578             return
1579         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)
1580 
1581     def fdiff(self, argindex=1):
1582         from sympy import unpolarify
1583         arg = unpolarify(self.args[0])
1584         if argindex == 1:
1585             return self._trigfunc(arg)/arg
1586 
1587     def _eval_rewrite_as_Ei(self, z):
1588         return self._eval_rewrite_as_expint(z).rewrite(Ei)
1589 
1590     def _eval_rewrite_as_uppergamma(self, z):
1591         from sympy import uppergamma
1592         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)
1593 
1594     def _eval_nseries(self, x, n, logx):
1595         # NOTE this is fairly inefficient
1596         from sympy import log, EulerGamma, Pow
1597         n += 1
1598         if self.args[0].subs(x, 0) != 0:
1599             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)
1600         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)
1601         if self._trigfunc(0) != 0:
1602             baseseries -= 1
1603         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)
1604         if self._trigfunc(0) != 0:
1605             baseseries += EulerGamma + log(x)
1606         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)
1607 
1608 
1609 class Si(TrigonometricIntegral):
1610     r"""
1611     Sine integral.
1612 
1613     This function is defined by
1614 
1615     .. math:: \operatorname{Si}(z) = \int_0^z \frac{\sin{t}}{t} \mathrm{d}t.
1616 
1617     It is an entire function.
1618 
1619     Examples
1620     ========
1621 
1622     >>> from sympy import Si
1623     >>> from sympy.abc import z
1624 
1625     The sine integral is an antiderivative of sin(z)/z:
1626 
1627     >>> Si(z).diff(z)
1628     sin(z)/z
1629 
1630     It is unbranched:
1631 
1632     >>> from sympy import exp_polar, I, pi
1633     >>> Si(z*exp_polar(2*I*pi))
1634     Si(z)
1635 
1636     Sine integral behaves much like ordinary sine under multiplication by ``I``:
1637 
1638     >>> Si(I*z)
1639     I*Shi(z)
1640     >>> Si(-z)
1641     -Si(z)
1642 
1643     It can also be expressed in terms of exponential integrals, but beware
1644     that the latter is branched:
1645 
1646     >>> from sympy import expint
1647     >>> Si(z).rewrite(expint)
1648     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +
1649          expint(1, z*exp_polar(I*pi/2))/2) + pi/2
1650 
1651     It can be rewritten in the form of sinc function (By definition)
1652 
1653     >>> from sympy import sinc
1654     >>> Si(z).rewrite(sinc)
1655     Integral(sinc(t), (t, 0, z))
1656 
1657     See Also
1658     ========
1659 
1660     Ci: Cosine integral.
1661     Shi: Hyperbolic sine integral.
1662     Chi: Hyperbolic cosine integral.
1663     Ei: Exponential integral.
1664     expint: Generalised exponential integral.
1665     sinc: unnormalized sinc function
1666     E1: Special case of the generalised exponential integral.
1667     li: Logarithmic integral.
1668     Li: Offset logarithmic integral.
1669 
1670     References
1671     ==========
1672 
1673     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1674 
1675     """
1676 
1677     _trigfunc = sin
1678     _atzero = S(0)
1679 
1680     @classmethod
1681     def _atinf(cls):
1682         return pi*S.Half
1683 
1684     @classmethod
1685     def _atneginf(cls):
1686         return -pi*S.Half
1687 
1688     @classmethod
1689     def _minusfactor(cls, z):
1690         return -Si(z)
1691 
1692     @classmethod
1693     def _Ifactor(cls, z, sign):
1694         return I*Shi(z)*sign
1695 
1696     def _eval_rewrite_as_expint(self, z):
1697         # XXX should we polarify z?
1698         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I
1699 
1700     def _eval_rewrite_as_sinc(self, z):
1701         from sympy import Integral
1702         t = Symbol('t', Dummy=True)
1703         return Integral(sinc(t), (t, 0, z))
1704 
1705     def _sage_(self):
1706         import sage.all as sage
1707         return sage.sin_integral(self.args[0]._sage_())
1708 
1709 class Ci(TrigonometricIntegral):
1710     r"""
1711     Cosine integral.
1712 
1713     This function is defined for positive `x` by
1714 
1715     .. math:: \operatorname{Ci}(x) = \gamma + \log{x}
1716                          + \int_0^x \frac{\cos{t} - 1}{t} \mathrm{d}t
1717            = -\int_x^\infty \frac{\cos{t}}{t} \mathrm{d}t,
1718 
1719     where `\gamma` is the Euler-Mascheroni constant.
1720 
1721     We have
1722 
1723     .. math:: \operatorname{Ci}(z) =
1724         -\frac{\operatorname{E}_1\left(e^{i\pi/2} z\right)
1725                + \operatorname{E}_1\left(e^{-i \pi/2} z\right)}{2}
1726 
1727     which holds for all polar `z` and thus provides an analytic
1728     continuation to the Riemann surface of the logarithm.
1729 
1730     The formula also holds as stated
1731     for `z \in \mathbb{C}` with `\Re(z) > 0`.
1732     By lifting to the principal branch we obtain an analytic function on the
1733     cut complex plane.
1734 
1735     Examples
1736     ========
1737 
1738     >>> from sympy import Ci
1739     >>> from sympy.abc import z
1740 
1741     The cosine integral is a primitive of `\cos(z)/z`:
1742 
1743     >>> Ci(z).diff(z)
1744     cos(z)/z
1745 
1746     It has a logarithmic branch point at the origin:
1747 
1748     >>> from sympy import exp_polar, I, pi
1749     >>> Ci(z*exp_polar(2*I*pi))
1750     Ci(z) + 2*I*pi
1751 
1752     The cosine integral behaves somewhat like ordinary `\cos` under multiplication by `i`:
1753 
1754     >>> from sympy import polar_lift
1755     >>> Ci(polar_lift(I)*z)
1756     Chi(z) + I*pi/2
1757     >>> Ci(polar_lift(-1)*z)
1758     Ci(z) + I*pi
1759 
1760     It can also be expressed in terms of exponential integrals:
1761 
1762     >>> from sympy import expint
1763     >>> Ci(z).rewrite(expint)
1764     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2
1765 
1766     See Also
1767     ========
1768 
1769     Si: Sine integral.
1770     Shi: Hyperbolic sine integral.
1771     Chi: Hyperbolic cosine integral.
1772     Ei: Exponential integral.
1773     expint: Generalised exponential integral.
1774     E1: Special case of the generalised exponential integral.
1775     li: Logarithmic integral.
1776     Li: Offset logarithmic integral.
1777 
1778     References
1779     ==========
1780 
1781     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1782 
1783     """
1784 
1785     _trigfunc = cos
1786     _atzero = S.ComplexInfinity
1787 
1788     @classmethod
1789     def _atinf(cls):
1790         return S.Zero
1791 
1792     @classmethod
1793     def _atneginf(cls):
1794         return I*pi
1795 
1796     @classmethod
1797     def _minusfactor(cls, z):
1798         return Ci(z) + I*pi
1799 
1800     @classmethod
1801     def _Ifactor(cls, z, sign):
1802         return Chi(z) + I*pi/2*sign
1803 
1804     def _eval_rewrite_as_expint(self, z):
1805         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2
1806 
1807     def _sage_(self):
1808         import sage.all as sage
1809         return sage.cos_integral(self.args[0]._sage_())
1810 
1811 
1812 class Shi(TrigonometricIntegral):
1813     r"""
1814     Sinh integral.
1815 
1816     This function is defined by
1817 
1818     .. math:: \operatorname{Shi}(z) = \int_0^z \frac{\sinh{t}}{t} \mathrm{d}t.
1819 
1820     It is an entire function.
1821 
1822     Examples
1823     ========
1824 
1825     >>> from sympy import Shi
1826     >>> from sympy.abc import z
1827 
1828     The Sinh integral is a primitive of `\sinh(z)/z`:
1829 
1830     >>> Shi(z).diff(z)
1831     sinh(z)/z
1832 
1833     It is unbranched:
1834 
1835     >>> from sympy import exp_polar, I, pi
1836     >>> Shi(z*exp_polar(2*I*pi))
1837     Shi(z)
1838 
1839     The `\sinh` integral behaves much like ordinary `\sinh` under multiplication by `i`:
1840 
1841     >>> Shi(I*z)
1842     I*Si(z)
1843     >>> Shi(-z)
1844     -Shi(z)
1845 
1846     It can also be expressed in terms of exponential integrals, but beware
1847     that the latter is branched:
1848 
1849     >>> from sympy import expint
1850     >>> Shi(z).rewrite(expint)
1851     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1852 
1853     See Also
1854     ========
1855 
1856     Si: Sine integral.
1857     Ci: Cosine integral.
1858     Chi: Hyperbolic cosine integral.
1859     Ei: Exponential integral.
1860     expint: Generalised exponential integral.
1861     E1: Special case of the generalised exponential integral.
1862     li: Logarithmic integral.
1863     Li: Offset logarithmic integral.
1864 
1865     References
1866     ==========
1867 
1868     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1869 
1870     """
1871 
1872     _trigfunc = sinh
1873     _atzero = S(0)
1874 
1875     @classmethod
1876     def _atinf(cls):
1877         return S.Infinity
1878 
1879     @classmethod
1880     def _atneginf(cls):
1881         return S.NegativeInfinity
1882 
1883     @classmethod
1884     def _minusfactor(cls, z):
1885         return -Shi(z)
1886 
1887     @classmethod
1888     def _Ifactor(cls, z, sign):
1889         return I*Si(z)*sign
1890 
1891     def _eval_rewrite_as_expint(self, z):
1892         from sympy import exp_polar
1893         # XXX should we polarify z?
1894         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2
1895 
1896     def _sage_(self):
1897         import sage.all as sage
1898         return sage.sinh_integral(self.args[0]._sage_())
1899 
1900 
1901 class Chi(TrigonometricIntegral):
1902     r"""
1903     Cosh integral.
1904 
1905     This function is defined for positive :math:`x` by
1906 
1907     .. math:: \operatorname{Chi}(x) = \gamma + \log{x}
1908                          + \int_0^x \frac{\cosh{t} - 1}{t} \mathrm{d}t,
1909 
1910     where :math:`\gamma` is the Euler-Mascheroni constant.
1911 
1912     We have
1913 
1914     .. math:: \operatorname{Chi}(z) = \operatorname{Ci}\left(e^{i \pi/2}z\right)
1915                          - i\frac{\pi}{2},
1916 
1917     which holds for all polar :math:`z` and thus provides an analytic
1918     continuation to the Riemann surface of the logarithm.
1919     By lifting to the principal branch we obtain an analytic function on the
1920     cut complex plane.
1921 
1922     Examples
1923     ========
1924 
1925     >>> from sympy import Chi
1926     >>> from sympy.abc import z
1927 
1928     The `\cosh` integral is a primitive of `\cosh(z)/z`:
1929 
1930     >>> Chi(z).diff(z)
1931     cosh(z)/z
1932 
1933     It has a logarithmic branch point at the origin:
1934 
1935     >>> from sympy import exp_polar, I, pi
1936     >>> Chi(z*exp_polar(2*I*pi))
1937     Chi(z) + 2*I*pi
1938 
1939     The `\cosh` integral behaves somewhat like ordinary `\cosh` under multiplication by `i`:
1940 
1941     >>> from sympy import polar_lift
1942     >>> Chi(polar_lift(I)*z)
1943     Ci(z) + I*pi/2
1944     >>> Chi(polar_lift(-1)*z)
1945     Chi(z) + I*pi
1946 
1947     It can also be expressed in terms of exponential integrals:
1948 
1949     >>> from sympy import expint
1950     >>> Chi(z).rewrite(expint)
1951     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1952 
1953     See Also
1954     ========
1955 
1956     Si: Sine integral.
1957     Ci: Cosine integral.
1958     Shi: Hyperbolic sine integral.
1959     Ei: Exponential integral.
1960     expint: Generalised exponential integral.
1961     E1: Special case of the generalised exponential integral.
1962     li: Logarithmic integral.
1963     Li: Offset logarithmic integral.
1964 
1965     References
1966     ==========
1967 
1968     .. [1] http://en.wikipedia.org/wiki/Trigonometric_integral
1969 
1970     """
1971 
1972     _trigfunc = cosh
1973     _atzero = S.ComplexInfinity
1974 
1975     @classmethod
1976     def _atinf(cls):
1977         return S.Infinity
1978 
1979     @classmethod
1980     def _atneginf(cls):
1981         return S.Infinity
1982 
1983     @classmethod
1984     def _minusfactor(cls, z):
1985         return Chi(z) + I*pi
1986 
1987     @classmethod
1988     def _Ifactor(cls, z, sign):
1989         return Ci(z) + I*pi/2*sign
1990 
1991     def _eval_rewrite_as_expint(self, z):
1992         from sympy import exp_polar
1993         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2
1994 
1995     def _latex(self, printer, exp=None):
1996         if len(self.args) != 1:
1997             raise ValueError("Arg length should be 1")
1998         if exp:
1999             return r'\operatorname{Chi}^{%s}{\left (%s \right )}' \
2000                 % (printer._print(exp), printer._print(self.args[0]))
2001         else:
2002             return r'\operatorname{Chi}{\left (%s \right )}' \
2003                 % printer._print(self.args[0])
2004 
2005     @staticmethod
2006     def _latex_no_arg(printer):
2007         return r'\operatorname{Chi}'
2008 
2009     def _sage_(self):
2010         import sage.all as sage
2011         return sage.cosh_integral(self.args[0]._sage_())
2012 
2013 
2014 ###############################################################################
2015 #################### FRESNEL INTEGRALS ########################################
2016 ###############################################################################
2017 
2018 class FresnelIntegral(Function):
2019     """ Base class for the Fresnel integrals."""
2020 
2021     unbranched = True
2022 
2023     @classmethod
2024     def eval(cls, z):
2025         # Value at zero
2026         if z is S.Zero:
2027             return S(0)
2028 
2029         # Try to pull out factors of -1 and I
2030         prefact = S.One
2031         newarg = z
2032         changed = False
2033 
2034         nz = newarg.extract_multiplicatively(-1)
2035         if nz is not None:
2036             prefact = -prefact
2037             newarg = nz
2038             changed = True
2039 
2040         nz = newarg.extract_multiplicatively(I)
2041         if nz is not None:
2042             prefact = cls._sign*I*prefact
2043             newarg = nz
2044             changed = True
2045 
2046         if changed:
2047             return prefact*cls(newarg)
2048 
2049         # Values at positive infinities signs
2050         # if any were extracted automatically
2051         if z is S.Infinity:
2052             return S.Half
2053         elif z is I*S.Infinity:
2054             return cls._sign*I*S.Half
2055 
2056     def fdiff(self, argindex=1):
2057         if argindex == 1:
2058             return self._trigfunc(S.Half*pi*self.args[0]**2)
2059         else:
2060             raise ArgumentIndexError(self, argindex)
2061 
2062     def _eval_is_real(self):
2063         return self.args[0].is_real
2064 
2065     def _eval_conjugate(self):
2066         return self.func(self.args[0].conjugate())
2067 
2068     def _as_real_imag(self, deep=True, **hints):
2069         if self.args[0].is_real:
2070             if deep:
2071                 hints['complex'] = False
2072                 return (self.expand(deep, **hints), S.Zero)
2073             else:
2074                 return (self, S.Zero)
2075         if deep:
2076             re, im = self.args[0].expand(deep, **hints).as_real_imag()
2077         else:
2078             re, im = self.args[0].as_real_imag()
2079         return (re, im)
2080 
2081     def as_real_imag(self, deep=True, **hints):
2082         # Fresnel S
2083         # http://functions.wolfram.com/06.32.19.0003.01
2084         # http://functions.wolfram.com/06.32.19.0006.01
2085         # Fresnel C
2086         # http://functions.wolfram.com/06.33.19.0003.01
2087         # http://functions.wolfram.com/06.33.19.0006.01
2088         x, y = self._as_real_imag(deep=deep, **hints)
2089         sq = -y**2/x**2
2090         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
2091         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
2092                 self.func(x + x*sqrt(sq)))
2093         return (re, im)
2094 
2095 
2096 class fresnels(FresnelIntegral):
2097     r"""
2098     Fresnel integral S.
2099 
2100     This function is defined by
2101 
2102     .. math:: \operatorname{S}(z) = \int_0^z \sin{\frac{\pi}{2} t^2} \mathrm{d}t.
2103 
2104     It is an entire function.
2105 
2106     Examples
2107     ========
2108 
2109     >>> from sympy import I, oo, fresnels
2110     >>> from sympy.abc import z
2111 
2112     Several special values are known:
2113 
2114     >>> fresnels(0)
2115     0
2116     >>> fresnels(oo)
2117     1/2
2118     >>> fresnels(-oo)
2119     -1/2
2120     >>> fresnels(I*oo)
2121     -I/2
2122     >>> fresnels(-I*oo)
2123     I/2
2124 
2125     In general one can pull out factors of -1 and `i` from the argument:
2126 
2127     >>> fresnels(-z)
2128     -fresnels(z)
2129     >>> fresnels(I*z)
2130     -I*fresnels(z)
2131 
2132     The Fresnel S integral obeys the mirror symmetry
2133     `\overline{S(z)} = S(\bar{z})`:
2134 
2135     >>> from sympy import conjugate
2136     >>> conjugate(fresnels(z))
2137     fresnels(conjugate(z))
2138 
2139     Differentiation with respect to `z` is supported:
2140 
2141     >>> from sympy import diff
2142     >>> diff(fresnels(z), z)
2143     sin(pi*z**2/2)
2144 
2145     Defining the Fresnel functions via an integral
2146 
2147     >>> from sympy import integrate, pi, sin, gamma, expand_func
2148     >>> integrate(sin(pi*z**2/2), z)
2149     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))
2150     >>> expand_func(integrate(sin(pi*z**2/2), z))
2151     fresnels(z)
2152 
2153     We can numerically evaluate the Fresnel integral to arbitrary precision
2154     on the whole complex plane:
2155 
2156     >>> fresnels(2).evalf(30)
2157     0.343415678363698242195300815958
2158 
2159     >>> fresnels(-2*I).evalf(30)
2160     0.343415678363698242195300815958*I
2161 
2162     See Also
2163     ========
2164 
2165     fresnelc: Fresnel cosine integral.
2166 
2167     References
2168     ==========
2169 
2170     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral
2171     .. [2] http://dlmf.nist.gov/7
2172     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2173     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS
2174     .. [5] The converging factors for the fresnel integrals
2175             by John W. Wrench Jr. and Vicki Alley
2176 
2177     """
2178     _trigfunc = sin
2179     _sign = -S.One
2180 
2181     @staticmethod
2182     @cacheit
2183     def taylor_term(n, x, *previous_terms):
2184         if n < 0:
2185             return S.Zero
2186         else:
2187             x = sympify(x)
2188             if len(previous_terms) > 1:
2189                 p = previous_terms[-1]
2190                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p
2191             else:
2192                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))
2193 
2194     def _eval_rewrite_as_erf(self, z):
2195         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))
2196 
2197     def _eval_rewrite_as_hyper(self, z):
2198         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)
2199 
2200     def _eval_rewrite_as_meijerg(self, z):
2201         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))
2202                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))
2203 
2204     def _eval_aseries(self, n, args0, x, logx):
2205         from sympy import Order
2206         point = args0[0]
2207 
2208         # Expansion at oo
2209         if point is S.Infinity:
2210             z = self.args[0]
2211 
2212             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8
2213             p = [(-1)**k * factorial(4*k + 1) /
2214                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2215                  for k in range(0, n)]
2216             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2217                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2218                  for k in range(1, n)]
2219 
2220             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]
2221             q = [-sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]
2222 
2223             return S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)
2224 
2225         # All other points are not handled
2226         return super(fresnels, self)._eval_aseries(n, args0, x, logx)
2227 
2228 
2229 class fresnelc(FresnelIntegral):
2230     r"""
2231     Fresnel integral C.
2232 
2233     This function is defined by
2234 
2235     .. math:: \operatorname{C}(z) = \int_0^z \cos{\frac{\pi}{2} t^2} \mathrm{d}t.
2236 
2237     It is an entire function.
2238 
2239     Examples
2240     ========
2241 
2242     >>> from sympy import I, oo, fresnelc
2243     >>> from sympy.abc import z
2244 
2245     Several special values are known:
2246 
2247     >>> fresnelc(0)
2248     0
2249     >>> fresnelc(oo)
2250     1/2
2251     >>> fresnelc(-oo)
2252     -1/2
2253     >>> fresnelc(I*oo)
2254     I/2
2255     >>> fresnelc(-I*oo)
2256     -I/2
2257 
2258     In general one can pull out factors of -1 and `i` from the argument:
2259 
2260     >>> fresnelc(-z)
2261     -fresnelc(z)
2262     >>> fresnelc(I*z)
2263     I*fresnelc(z)
2264 
2265     The Fresnel C integral obeys the mirror symmetry
2266     `\overline{C(z)} = C(\bar{z})`:
2267 
2268     >>> from sympy import conjugate
2269     >>> conjugate(fresnelc(z))
2270     fresnelc(conjugate(z))
2271 
2272     Differentiation with respect to `z` is supported:
2273 
2274     >>> from sympy import diff
2275     >>> diff(fresnelc(z), z)
2276     cos(pi*z**2/2)
2277 
2278     Defining the Fresnel functions via an integral
2279 
2280     >>> from sympy import integrate, pi, cos, gamma, expand_func
2281     >>> integrate(cos(pi*z**2/2), z)
2282     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))
2283     >>> expand_func(integrate(cos(pi*z**2/2), z))
2284     fresnelc(z)
2285 
2286     We can numerically evaluate the Fresnel integral to arbitrary precision
2287     on the whole complex plane:
2288 
2289     >>> fresnelc(2).evalf(30)
2290     0.488253406075340754500223503357
2291 
2292     >>> fresnelc(-2*I).evalf(30)
2293     -0.488253406075340754500223503357*I
2294 
2295     See Also
2296     ========
2297 
2298     fresnels: Fresnel sine integral.
2299 
2300     References
2301     ==========
2302 
2303     .. [1] http://en.wikipedia.org/wiki/Fresnel_integral
2304     .. [2] http://dlmf.nist.gov/7
2305     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2306     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC
2307     .. [5] The converging factors for the fresnel integrals
2308             by John W. Wrench Jr. and Vicki Alley
2309     """
2310     _trigfunc = cos
2311     _sign = S.One
2312 
2313     @staticmethod
2314     @cacheit
2315     def taylor_term(n, x, *previous_terms):
2316         if n < 0:
2317             return S.Zero
2318         else:
2319             x = sympify(x)
2320             if len(previous_terms) > 1:
2321                 p = previous_terms[-1]
2322                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p
2323             else:
2324                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))
2325 
2326     def _eval_rewrite_as_erf(self, z):
2327         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))
2328 
2329     def _eval_rewrite_as_hyper(self, z):
2330         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)
2331 
2332     def _eval_rewrite_as_meijerg(self, z):
2333         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))
2334                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))
2335 
2336     def _eval_aseries(self, n, args0, x, logx):
2337         from sympy import Order
2338         point = args0[0]
2339 
2340         # Expansion at oo
2341         if point is S.Infinity:
2342             z = self.args[0]
2343 
2344             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8
2345             p = [(-1)**k * factorial(4*k + 1) /
2346                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2347                  for k in range(0, n)]
2348             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2349                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2350                  for k in range(1, n)]
2351 
2352             p = [-sqrt(2/pi)*t for t in p] + [Order(1/z**n, x)]
2353             q = [ sqrt(2/pi)*t for t in q] + [Order(1/z**n, x)]
2354 
2355             return S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)).subs(x, sqrt(2/pi)*x)
2356 
2357         # All other points are not handled
2358         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)
2359 
2360 
2361 ###############################################################################
2362 #################### HELPER FUNCTIONS #########################################
2363 ###############################################################################
2364 
2365 
2366 class _erfs(Function):
2367     """
2368     Helper function to make the `\\mathrm{erf}(z)` function
2369     tractable for the Gruntz algorithm.
2370     """
2371 
2372 
2373     def _eval_aseries(self, n, args0, x, logx):
2374         from sympy import Order
2375         point = args0[0]
2376 
2377         # Expansion at oo
2378         if point is S.Infinity:
2379             z = self.args[0]
2380             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2381                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2382             o = Order(1/z**(2*n + 1), x)
2383             # It is very inefficient to first add the order and then do the nseries
2384             return (Add(*l))._eval_nseries(x, n, logx) + o
2385 
2386         # Expansion at I*oo
2387         t = point.extract_multiplicatively(S.ImaginaryUnit)
2388         if t is S.Infinity:
2389             z = self.args[0]
2390             # TODO: is the series really correct?
2391             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2392                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2393             o = Order(1/z**(2*n + 1), x)
2394             # It is very inefficient to first add the order and then do the nseries
2395             return (Add(*l))._eval_nseries(x, n, logx) + o
2396 
2397         # All other points are not handled
2398         return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2399 
2400     def fdiff(self, argindex=1):
2401         if argindex == 1:
2402             z = self.args[0]
2403             return -2/sqrt(S.Pi) + 2*z*_erfs(z)
2404         else:
2405             raise ArgumentIndexError(self, argindex)
2406 
2407     def _eval_rewrite_as_intractable(self, z):
2408         return (S.One - erf(z))*exp(z**2)
2409 
2410 
2411 class _eis(Function):
2412     """
2413     Helper function to make the `\\mathrm{Ei}(z)` and `\\mathrm{li}(z)` functions
2414     tractable for the Gruntz algorithm.
2415     """
2416 
2417 
2418     def _eval_aseries(self, n, args0, x, logx):
2419         from sympy import Order
2420         if args0[0] != S.Infinity:
2421             return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2422 
2423         z = self.args[0]
2424         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]
2425         o = Order(1/z**(n + 1), x)
2426         # It is very inefficient to first add the order and then do the nseries
2427         return (Add(*l))._eval_nseries(x, n, logx) + o
2428 
2429 
2430     def fdiff(self, argindex=1):
2431         if argindex == 1:
2432             z = self.args[0]
2433             return S.One / z - _eis(z)
2434         else:
2435             raise ArgumentIndexError(self, argindex)
2436 
2437     def _eval_rewrite_as_intractable(self, z):
2438         return exp(-z)*Ei(z)
2439 
2440     def _eval_nseries(self, x, n, logx):
2441         x0 = self.args[0].limit(x, 0)
2442         if x0 is S.Zero:
2443             f = self._eval_rewrite_as_intractable(*self.args)
2444             return f._eval_nseries(x, n, logx)
2445         return super(_eis, self)._eval_nseries(x, n, logx)

</code><intended_behavior>Each of these methods should ensure the operations involving error functions and related special functions are executed in line with established mathematical definitions and transformations. Reversions or corrections might be needed to align the implementations with the intended mathematical behaviors, specifically reverting to functionality before the modifications introduced in SymPy 1.0.</intended_behavior>, <file>sympy/integrals/integrals.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.concrete.expr_with_limits import AddWithLimits
4 from sympy.core.add import Add
5 from sympy.core.basic import Basic
6 from sympy.core.compatibility import is_sequence, range
7 from sympy.core.containers import Tuple
8 from sympy.core.expr import Expr
9 from sympy.core.function import diff
10 from sympy.core.mul import Mul
11 from sympy.core.numbers import oo
12 from sympy.core.relational import Eq
13 from sympy.core.singleton import S
14 from sympy.core.symbol import (Dummy, Symbol, Wild)
15 from sympy.core.sympify import sympify
16 from sympy.integrals.manualintegrate import manualintegrate
17 from sympy.integrals.trigonometry import trigintegrate
18 from sympy.integrals.meijerint import meijerint_definite, meijerint_indefinite
19 from sympy.matrices import MatrixBase
20 from sympy.utilities.misc import filldedent
21 from sympy.polys import Poly, PolynomialError
22 from sympy.functions import Piecewise, sqrt, sign
23 from sympy.functions.elementary.exponential import log
24 from sympy.series import limit
25 from sympy.series.order import Order
26 
27 
28 class Integral(AddWithLimits):
29     """Represents unevaluated integral."""
30 
31     __slots__ = ['is_commutative']
32 
33     def __new__(cls, function, *symbols, **assumptions):
34         """Create an unevaluated integral.
35 
36         Arguments are an integrand followed by one or more limits.
37 
38         If no limits are given and there is only one free symbol in the
39         expression, that symbol will be used, otherwise an error will be
40         raised.
41 
42         >>> from sympy import Integral
43         >>> from sympy.abc import x, y
44         >>> Integral(x)
45         Integral(x, x)
46         >>> Integral(y)
47         Integral(y, y)
48 
49         When limits are provided, they are interpreted as follows (using
50         ``x`` as though it were the variable of integration):
51 
52             (x,) or x - indefinite integral
53             (x, a) - "evaluate at" integral is an abstract antiderivative
54             (x, a, b) - definite integral
55 
56         The ``as_dummy`` method can be used to see which symbols cannot be
57         targeted by subs: those with a preppended underscore cannot be
58         changed with ``subs``. (Also, the integration variables themselves --
59         the first element of a limit -- can never be changed by subs.)
60 
61         >>> i = Integral(x, x)
62         >>> at = Integral(x, (x, x))
63         >>> i.as_dummy()
64         Integral(x, x)
65         >>> at.as_dummy()
66         Integral(_x, (_x, x))
67 
68         """
69 
70         #This will help other classes define their own definitions
71         #of behaviour with Integral.
72         if hasattr(function, '_eval_Integral'):
73             return function._eval_Integral(*symbols, **assumptions)
74 
75         obj = AddWithLimits.__new__(cls, function, *symbols, **assumptions)
76         return obj
77 
78     def __getnewargs__(self):
79         return (self.function,) + tuple([tuple(xab) for xab in self.limits])
80 
81     @property
82     def free_symbols(self):
83         """
84         This method returns the symbols that will exist when the
85         integral is evaluated. This is useful if one is trying to
86         determine whether an integral depends on a certain
87         symbol or not.
88 
89         Examples
90         ========
91 
92         >>> from sympy import Integral
93         >>> from sympy.abc import x, y
94         >>> Integral(x, (x, y, 1)).free_symbols
95         {y}
96 
97         See Also
98         ========
99 
100         function, limits, variables
101         """
102         return AddWithLimits.free_symbols.fget(self)
103 
104     def _eval_is_zero(self):
105         # This is a very naive and quick test, not intended to do the integral to
106         # answer whether it is zero or not, e.g. Integral(sin(x), (x, 0, 2*pi))
107         # is zero but this routine should return None for that case. But, like
108         # Mul, there are trivial situations for which the integral will be
109         # zero so we check for those.
110         if self.function.is_zero:
111             return True
112         got_none = False
113         for l in self.limits:
114             if len(l) == 3:
115                 z = (l[1] == l[2]) or (l[1] - l[2]).is_zero
116                 if z:
117                     return True
118                 elif z is None:
119                     got_none = True
120         free = self.function.free_symbols
121         for xab in self.limits:
122             if len(xab) == 1:
123                 free.add(xab[0])
124                 continue
125             if len(xab) == 2 and xab[0] not in free:
126                 if xab[1].is_zero:
127                     return True
128                 elif xab[1].is_zero is None:
129                     got_none = True
130             # take integration symbol out of free since it will be replaced
131             # with the free symbols in the limits
132             free.discard(xab[0])
133             # add in the new symbols
134             for i in xab[1:]:
135                 free.update(i.free_symbols)
136         if self.function.is_zero is False and got_none is False:
137             return False
138 
139     def transform(self, x, u):
140         r"""
141         Performs a change of variables from `x` to `u` using the relationship
142         given by `x` and `u` which will define the transformations `f` and `F`
143         (which are inverses of each other) as follows:
144 
145         1) If `x` is a Symbol (which is a variable of integration) then `u`
146            will be interpreted as some function, f(u), with inverse F(u).
147            This, in effect, just makes the substitution of x with f(x).
148 
149         2) If `u` is a Symbol then `x` will be interpreted as some function,
150            F(x), with inverse f(u). This is commonly referred to as
151            u-substitution.
152 
153         Once f and F have been identified, the transformation is made as
154         follows:
155 
156         .. math:: \int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x)
157                   \frac{\mathrm{d}}{\mathrm{d}x}
158 
159         where `F(x)` is the inverse of `f(x)` and the limits and integrand have
160         been corrected so as to retain the same value after integration.
161 
162         Notes
163         =====
164 
165         The mappings, F(x) or f(u), must lead to a unique integral. Linear
166         or rational linear expression, `2*x`, `1/x` and `sqrt(x)`, will
167         always work; quadratic expressions like `x**2 - 1` are acceptable
168         as long as the resulting integrand does not depend on the sign of
169         the solutions (see examples).
170 
171         The integral will be returned unchanged if `x` is not a variable of
172         integration.
173 
174         `x` must be (or contain) only one of of the integration variables. If
175         `u` has more than one free symbol then it should be sent as a tuple
176         (`u`, `uvar`) where `uvar` identifies which variable is replacing
177         the integration variable.
178         XXX can it contain another integration variable?
179 
180         Examples
181         ========
182 
183         >>> from sympy.abc import a, b, c, d, x, u, y
184         >>> from sympy import Integral, S, cos, sqrt
185 
186         >>> i = Integral(x*cos(x**2 - 1), (x, 0, 1))
187 
188         transform can change the variable of integration
189 
190         >>> i.transform(x, u)
191         Integral(u*cos(u**2 - 1), (u, 0, 1))
192 
193         transform can perform u-substitution as long as a unique
194         integrand is obtained:
195 
196         >>> i.transform(x**2 - 1, u)
197         Integral(cos(u)/2, (u, -1, 0))
198 
199         This attempt fails because x = +/-sqrt(u + 1) and the
200         sign does not cancel out of the integrand:
201 
202         >>> Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)
203         Traceback (most recent call last):
204         ...
205         ValueError:
206         The mapping between F(x) and f(u) did not give a unique integrand.
207 
208         transform can do a substitution. Here, the previous
209         result is transformed back into the original expression
210         using "u-substitution":
211 
212         >>> ui = _
213         >>> _.transform(sqrt(u + 1), x) == i
214         True
215 
216         We can accomplish the same with a regular substitution:
217 
218         >>> ui.transform(u, x**2 - 1) == i
219         True
220 
221         If the `x` does not contain a symbol of integration then
222         the integral will be returned unchanged. Integral `i` does
223         not have an integration variable `a` so no change is made:
224 
225         >>> i.transform(a, x) == i
226         True
227 
228         When `u` has more than one free symbol the symbol that is
229         replacing `x` must be identified by passing `u` as a tuple:
230 
231         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, u))
232         Integral(a + u, (u, -a, -a + 1))
233         >>> Integral(x, (x, 0, 1)).transform(x, (u + a, a))
234         Integral(a + u, (a, -u, -u + 1))
235 
236         See Also
237         ========
238 
239         variables : Lists the integration variables
240         as_dummy : Replace integration variables with dummy ones
241         """
242         from sympy.solvers.solvers import solve, posify
243         d = Dummy('d')
244 
245         xfree = x.free_symbols.intersection(self.variables)
246         if len(xfree) > 1:
247             raise ValueError(
248                 'F(x) can only contain one of: %s' % self.variables)
249         xvar = xfree.pop() if xfree else d
250 
251         if xvar not in self.variables:
252             return self
253 
254         u = sympify(u)
255         if isinstance(u, Expr):
256             ufree = u.free_symbols
257             if len(ufree) != 1:
258                 raise ValueError(filldedent('''
259                 When f(u) has more than one free symbol, the one replacing x
260                 must be identified: pass f(u) as (f(u), u)'''))
261             uvar = ufree.pop()
262         else:
263             u, uvar = u
264             if uvar not in u.free_symbols:
265                 raise ValueError(filldedent('''
266                 Expecting a tuple (expr, symbol) where symbol identified
267                 a free symbol in expr, but symbol is not in expr's free
268                 symbols.'''))
269             if not isinstance(uvar, Symbol):
270                 raise ValueError(filldedent('''
271                 Expecting a tuple (expr, symbol) but didn't get
272                 a symbol; got %s''' % uvar))
273 
274         if x.is_Symbol and u.is_Symbol:
275             return self.xreplace({x: u})
276 
277         if not x.is_Symbol and not u.is_Symbol:
278             raise ValueError('either x or u must be a symbol')
279 
280         if uvar == xvar:
281             return self.transform(x, (u.subs(uvar, d), d)).xreplace({d: uvar})
282 
283         if uvar in self.limits:
284             raise ValueError(filldedent('''
285             u must contain the same variable as in x
286             or a variable that is not already an integration variable'''))
287 
288         if not x.is_Symbol:
289             F = [x.subs(xvar, d)]
290             soln = solve(u - x, xvar, check=False)
291             if not soln:
292                 raise ValueError('no solution for solve(F(x) - f(u), x)')
293             f = [fi.subs(uvar, d) for fi in soln]
294         else:
295             f = [u.subs(uvar, d)]
296             pdiff, reps = posify(u - x)
297             puvar = uvar.subs([(v, k) for k, v in reps.items()])
298             soln = [s.subs(reps) for s in solve(pdiff, puvar)]
299             if not soln:
300                 raise ValueError('no solution for solve(F(x) - f(u), u)')
301             F = [fi.subs(xvar, d) for fi in soln]
302 
303         newfuncs = set([(self.function.subs(xvar, fi)*fi.diff(d)
304                         ).subs(d, uvar) for fi in f])
305         if len(newfuncs) > 1:
306             raise ValueError(filldedent('''
307             The mapping between F(x) and f(u) did not give
308             a unique integrand.'''))
309         newfunc = newfuncs.pop()
310 
311         def _calc_limit_1(F, a, b):
312             """
313             replace d with a, using subs if possible, otherwise limit
314             where sign of b is considered
315             """
316             wok = F.subs(d, a)
317             if wok is S.NaN or wok.is_finite is False and a.is_finite:
318                 return limit(sign(b)*F, d, a)
319             return wok
320 
321         def _calc_limit(a, b):
322             """
323             replace d with a, using subs if possible, otherwise limit
324             where sign of b is considered
325             """
326             avals = list({_calc_limit_1(Fi, a, b) for Fi in F})
327             if len(avals) > 1:
328                 raise ValueError(filldedent('''
329                 The mapping between F(x) and f(u) did not
330                 give a unique limit.'''))
331             return avals[0]
332 
333         newlimits = []
334         for xab in self.limits:
335             sym = xab[0]
336             if sym == xvar:
337                 if len(xab) == 3:
338                     a, b = xab[1:]
339                     a, b = _calc_limit(a, b), _calc_limit(b, a)
340                     if a - b > 0:
341                         a, b = b, a
342                         newfunc = -newfunc
343                     newlimits.append((uvar, a, b))
344                 elif len(xab) == 2:
345                     a = _calc_limit(xab[1], 1)
346                     newlimits.append((uvar, a))
347                 else:
348                     newlimits.append(uvar)
349             else:
350                 newlimits.append(xab)
351 
352         return self.func(newfunc, *newlimits)
353 
354     def doit(self, **hints):
355         """
356         Perform the integration using any hints given.
357 
358         Examples
359         ========
360 
361         >>> from sympy import Integral
362         >>> from sympy.abc import x, i
363         >>> Integral(x**i, (i, 1, 3)).doit()
364         Piecewise((2, Eq(log(x), 0)), (x**3/log(x) - x/log(x), True))
365 
366         See Also
367         ========
368 
369         sympy.integrals.trigonometry.trigintegrate
370         sympy.integrals.risch.heurisch
371         sympy.integrals.rationaltools.ratint
372         as_sum : Approximate the integral using a sum
373         """
374         if not hints.get('integrals', True):
375             return self
376 
377         deep = hints.get('deep', True)
378         meijerg = hints.get('meijerg', None)
379         conds = hints.get('conds', 'piecewise')
380         risch = hints.get('risch', None)
381         manual = hints.get('manual', None)
382 
383         if conds not in ['separate', 'piecewise', 'none']:
384             raise ValueError('conds must be one of "separate", "piecewise", '
385                              '"none", got: %s' % conds)
386 
387         if risch and any(len(xab) > 1 for xab in self.limits):
388             raise ValueError('risch=True is only allowed for indefinite integrals.')
389 
390         # check for the trivial zero
391         if self.is_zero:
392             return S.Zero
393 
394         # now compute and check the function
395         function = self.function
396         if deep:
397             function = function.doit(**hints)
398         if function.is_zero:
399             return S.Zero
400 
401         if isinstance(function, MatrixBase):
402             return function.applyfunc(lambda f: self.func(f, self.limits).doit(**hints))
403 
404         # There is no trivial answer, so continue
405 
406         undone_limits = []
407         # ulj = free symbols of any undone limits' upper and lower limits
408         ulj = set()
409         for xab in self.limits:
410             # compute uli, the free symbols in the
411             # Upper and Lower limits of limit I
412             if len(xab) == 1:
413                 uli = set(xab[:1])
414             elif len(xab) == 2:
415                 uli = xab[1].free_symbols
416             elif len(xab) == 3:
417                 uli = xab[1].free_symbols.union(xab[2].free_symbols)
418             # this integral can be done as long as there is no blocking
419             # limit that has been undone. An undone limit is blocking if
420             # it contains an integration variable that is in this limit's
421             # upper or lower free symbols or vice versa
422             if xab[0] in ulj or any(v[0] in uli for v in undone_limits):
423                 undone_limits.append(xab)
424                 ulj.update(uli)
425                 function = self.func(*([function] + [xab]))
426                 factored_function = function.factor()
427                 if not isinstance(factored_function, Integral):
428                     function = factored_function
429                 continue
430 
431             # There are a number of tradeoffs in using the Meijer G method.
432             # It can sometimes be a lot faster than other methods, and
433             # sometimes slower. And there are certain types of integrals for
434             # which it is more likely to work than others.
435             # These heuristics are incorporated in deciding what integration
436             # methods to try, in what order.
437             # See the integrate() docstring for details.
438             def try_meijerg(function, xab):
439                 ret = None
440                 if len(xab) == 3 and meijerg is not False:
441                     x, a, b = xab
442                     try:
443                         res = meijerint_definite(function, x, a, b)
444                     except NotImplementedError:
445                         from sympy.integrals.meijerint import _debug
446                         _debug('NotImplementedError from meijerint_definite')
447                         res = None
448                     if res is not None:
449                         f, cond = res
450                         if conds == 'piecewise':
451                             ret = Piecewise((f, cond),
452                                           (self.func(function, (x, a, b)), True))
453                         elif conds == 'separate':
454                             if len(self.limits) != 1:
455                                 raise ValueError('conds=separate not supported in '
456                                                  'multiple integrals')
457                             ret = f, cond
458                         else:
459                             ret = f
460                 return ret
461 
462             meijerg1 = meijerg
463             if len(xab) == 3 and xab[1].is_real and xab[2].is_real \
464                 and not function.is_Poly and \
465                     (xab[1].has(oo, -oo) or xab[2].has(oo, -oo)):
466                 ret = try_meijerg(function, xab)
467                 if ret is not None:
468                     function = ret
469                     continue
470                 else:
471                     meijerg1 = False
472 
473             # If the special meijerg code did not succeed in finding a definite
474             # integral, then the code using meijerint_indefinite will not either
475             # (it might find an antiderivative, but the answer is likely to be
476             #  nonsensical).
477             # Thus if we are requested to only use Meijer G-function methods,
478             # we give up at this stage. Otherwise we just disable G-function
479             # methods.
480             if meijerg1 is False and meijerg is True:
481                 antideriv = None
482             else:
483                 antideriv = self._eval_integral(
484                     function, xab[0],
485                     meijerg=meijerg1, risch=risch, manual=manual,
486                     conds=conds)
487                 if antideriv is None and meijerg1 is True:
488                     ret = try_meijerg(function, xab)
489                     if ret is not None:
490                         function = ret
491                         continue
492 
493             if antideriv is None:
494                 undone_limits.append(xab)
495                 function = self.func(*([function] + [xab])).factor()
496                 factored_function = function.factor()
497                 if not isinstance(factored_function, Integral):
498                     function = factored_function
499                 continue
500             else:
501                 if len(xab) == 1:
502                     function = antideriv
503                 else:
504                     if len(xab) == 3:
505                         x, a, b = xab
506                     elif len(xab) == 2:
507                         x, b = xab
508                         a = None
509                     else:
510                         raise NotImplementedError
511 
512                     if deep:
513                         if isinstance(a, Basic):
514                             a = a.doit(**hints)
515                         if isinstance(b, Basic):
516                             b = b.doit(**hints)
517 
518                     if antideriv.is_Poly:
519                         gens = list(antideriv.gens)
520                         gens.remove(x)
521 
522                         antideriv = antideriv.as_expr()
523 
524                         function = antideriv._eval_interval(x, a, b)
525                         function = Poly(function, *gens)
526                     else:
527                         def is_indef_int(g, x):
528                             return (isinstance(g, Integral) and
529                                     any(i == (x,) for i in g.limits))
530 
531                         def eval_factored(f, x, a, b):
532                             # _eval_interval for integrals with
533                             # (constant) factors
534                             # a single indefinite integral is assumed
535                             args = []
536                             for g in Mul.make_args(f):
537                                 if is_indef_int(g, x):
538                                     args.append(g._eval_interval(x, a, b))
539                                 else:
540                                     args.append(g)
541                             return Mul(*args)
542 
543                         integrals, others = [], []
544                         for f in Add.make_args(antideriv):
545                             if any(is_indef_int(g, x)
546                                    for g in Mul.make_args(f)):
547                                 integrals.append(f)
548                             else:
549                                 others.append(f)
550                         uneval = Add(*[eval_factored(f, x, a, b)
551                                        for f in integrals])
552                         try:
553                             evalued = Add(*others)._eval_interval(x, a, b)
554                             function = uneval + evalued
555                         except NotImplementedError:
556                             # This can happen if _eval_interval depends in a
557                             # complicated way on limits that cannot be computed
558                             undone_limits.append(xab)
559                             function = self.func(*([function] + [xab]))
560                             factored_function = function.factor()
561                             if not isinstance(factored_function, Integral):
562                                 function = factored_function
563         return function
564 
565     def _eval_derivative(self, sym):
566         """Evaluate the derivative of the current Integral object by
567         differentiating under the integral sign [1], using the Fundamental
568         Theorem of Calculus [2] when possible.
569 
570         Whenever an Integral is encountered that is equivalent to zero or
571         has an integrand that is independent of the variable of integration
572         those integrals are performed. All others are returned as Integral
573         instances which can be resolved with doit() (provided they are integrable).
574 
575         References:
576            [1] http://en.wikipedia.org/wiki/Differentiation_under_the_integral_sign
577            [2] http://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus
578 
579         Examples
580         ========
581 
582         >>> from sympy import Integral
583         >>> from sympy.abc import x, y
584         >>> i = Integral(x + y, y, (y, 1, x))
585         >>> i.diff(x)
586         Integral(x + y, (y, x)) + Integral(1, y, (y, 1, x))
587         >>> i.doit().diff(x) == i.diff(x).doit()
588         True
589         >>> i.diff(y)
590         0
591 
592         The previous must be true since there is no y in the evaluated integral:
593 
594         >>> i.free_symbols
595         {x}
596         >>> i.doit()
597         2*x**3/3 - x/2 - 1/6
598 
599         """
600 
601         # differentiate under the integral sign; we do not
602         # check for regularity conditions (TODO), see issue 4215
603 
604         # get limits and the function
605         f, limits = self.function, list(self.limits)
606 
607         # the order matters if variables of integration appear in the limits
608         # so work our way in from the outside to the inside.
609         limit = limits.pop(-1)
610         if len(limit) == 3:
611             x, a, b = limit
612         elif len(limit) == 2:
613             x, b = limit
614             a = None
615         else:
616             a = b = None
617             x = limit[0]
618 
619         if limits:  # f is the argument to an integral
620             f = self.func(f, *tuple(limits))
621 
622         # assemble the pieces
623         def _do(f, ab):
624             dab_dsym = diff(ab, sym)
625             if not dab_dsym:
626                 return S.Zero
627             if isinstance(f, Integral):
628                 limits = [(x, x) if (len(l) == 1 and l[0] == x) else l
629                           for l in f.limits]
630                 f = self.func(f.function, *limits)
631             return f.subs(x, ab)*dab_dsym
632         rv = 0
633         if b is not None:
634             rv += _do(f, b)
635         if a is not None:
636             rv -= _do(f, a)
637         if len(limit) == 1 and sym == x:
638             # the dummy variable *is* also the real-world variable
639             arg = f
640             rv += arg
641         else:
642             # the dummy variable might match sym but it's
643             # only a dummy and the actual variable is determined
644             # by the limits, so mask off the variable of integration
645             # while differentiating
646             u = Dummy('u')
647             arg = f.subs(x, u).diff(sym).subs(u, x)
648             rv += self.func(arg, Tuple(x, a, b))
649         return rv
650 
651     def _eval_integral(self, f, x, meijerg=None, risch=None, manual=None,
652                        conds='piecewise'):
653         """
654         Calculate the anti-derivative to the function f(x).
655 
656         The following algorithms are applied (roughly in this order):
657 
658         1. Simple heuristics (based on pattern matching and integral table):
659 
660            - most frequently used functions (e.g. polynomials, products of trig functions)
661 
662         2. Integration of rational functions:
663 
664            - A complete algorithm for integrating rational functions is
665              implemented (the Lazard-Rioboo-Trager algorithm).  The algorithm
666              also uses the partial fraction decomposition algorithm
667              implemented in apart() as a preprocessor to make this process
668              faster.  Note that the integral of a rational function is always
669              elementary, but in general, it may include a RootSum.
670 
671         3. Full Risch algorithm:
672 
673            - The Risch algorithm is a complete decision
674              procedure for integrating elementary functions, which means that
675              given any elementary function, it will either compute an
676              elementary antiderivative, or else prove that none exists.
677              Currently, part of transcendental case is implemented, meaning
678              elementary integrals containing exponentials, logarithms, and
679              (soon!) trigonometric functions can be computed.  The algebraic
680              case, e.g., functions containing roots, is much more difficult
681              and is not implemented yet.
682 
683            - If the routine fails (because the integrand is not elementary, or
684              because a case is not implemented yet), it continues on to the
685              next algorithms below.  If the routine proves that the integrals
686              is nonelementary, it still moves on to the algorithms below,
687              because we might be able to find a closed-form solution in terms
688              of special functions.  If risch=True, however, it will stop here.
689 
690         4. The Meijer G-Function algorithm:
691 
692            - This algorithm works by first rewriting the integrand in terms of
693              very general Meijer G-Function (meijerg in SymPy), integrating
694              it, and then rewriting the result back, if possible.  This
695              algorithm is particularly powerful for definite integrals (which
696              is actually part of a different method of Integral), since it can
697              compute closed-form solutions of definite integrals even when no
698              closed-form indefinite integral exists.  But it also is capable
699              of computing many indefinite integrals as well.
700 
701            - Another advantage of this method is that it can use some results
702              about the Meijer G-Function to give a result in terms of a
703              Piecewise expression, which allows to express conditionally
704              convergent integrals.
705 
706            - Setting meijerg=True will cause integrate() to use only this
707              method.
708 
709         5. The "manual integration" algorithm:
710 
711            - This algorithm tries to mimic how a person would find an
712              antiderivative by hand, for example by looking for a
713              substitution or applying integration by parts. This algorithm
714              does not handle as many integrands but can return results in a
715              more familiar form.
716 
717            - Sometimes this algorithm can evaluate parts of an integral; in
718              this case integrate() will try to evaluate the rest of the
719              integrand using the other methods here.
720 
721            - Setting manual=True will cause integrate() to use only this
722              method.
723 
724         6. The Heuristic Risch algorithm:
725 
726            - This is a heuristic version of the Risch algorithm, meaning that
727              it is not deterministic.  This is tried as a last resort because
728              it can be very slow.  It is still used because not enough of the
729              full Risch algorithm is implemented, so that there are still some
730              integrals that can only be computed using this method.  The goal
731              is to implement enough of the Risch and Meijer G-function methods
732              so that this can be deleted.
733 
734         """
735         from sympy.integrals.deltafunctions import deltaintegrate
736         from sympy.integrals.singularityfunctions import singularityintegrate
737         from sympy.integrals.heurisch import heurisch, heurisch_wrapper
738         from sympy.integrals.rationaltools import ratint
739         from sympy.integrals.risch import risch_integrate
740 
741         if risch:
742             try:
743                 return risch_integrate(f, x, conds=conds)
744             except NotImplementedError:
745                 return None
746 
747         if manual:
748             try:
749                 result = manualintegrate(f, x)
750                 if result is not None and result.func != Integral:
751                     return result
752             except (ValueError, PolynomialError):
753                 pass
754 
755 
756         # if it is a poly(x) then let the polynomial integrate itself (fast)
757         #
758         # It is important to make this check first, otherwise the other code
759         # will return a sympy expression instead of a Polynomial.
760         #
761         # see Polynomial for details.
762         if isinstance(f, Poly) and not meijerg:
763             return f.integrate(x)
764 
765         # Piecewise antiderivatives need to call special integrate.
766         if f.func is Piecewise:
767             return f._eval_integral(x)
768 
769         # let's cut it short if `f` does not depend on `x`
770         if not f.has(x):
771             return f*x
772 
773         # try to convert to poly(x) and then integrate if successful (fast)
774         poly = f.as_poly(x)
775         if poly is not None and not meijerg:
776             return poly.integrate().as_expr()
777 
778         if risch is not False:
779             try:
780                 result, i = risch_integrate(f, x, separate_integral=True, conds=conds)
781             except NotImplementedError:
782                 pass
783             else:
784                 if i:
785                     # There was a nonelementary integral. Try integrating it.
786                     return result + i.doit(risch=False)
787                 else:
788                     return result
789 
790         # since Integral(f=g1+g2+...) == Integral(g1) + Integral(g2) + ...
791         # we are going to handle Add terms separately,
792         # if `f` is not Add -- we only have one term
793 
794         # Note that in general, this is a bad idea, because Integral(g1) +
795         # Integral(g2) might not be computable, even if Integral(g1 + g2) is.
796         # For example, Integral(x**x + x**x*log(x)).  But many heuristics only
797         # work term-wise.  So we compute this step last, after trying
798         # risch_integrate.  We also try risch_integrate again in this loop,
799         # because maybe the integral is a sum of an elementary part and a
800         # nonelementary part (like erf(x) + exp(x)).  risch_integrate() is
801         # quite fast, so this is acceptable.
802         parts = []
803         args = Add.make_args(f)
804         for g in args:
805             coeff, g = g.as_independent(x)
806 
807             # g(x) = const
808             if g is S.One and not meijerg:
809                 parts.append(coeff*x)
810                 continue
811 
812             # g(x) = expr + O(x**n)
813             order_term = g.getO()
814 
815             if order_term is not None:
816                 h = self._eval_integral(g.removeO(), x)
817 
818                 if h is not None:
819                     h_order_expr = self._eval_integral(order_term.expr, x)
820 
821                     if h_order_expr is not None:
822                         h_order_term = order_term.func(
823                             h_order_expr, *order_term.variables)
824                         parts.append(coeff*(h + h_order_term))
825                         continue
826 
827                 # NOTE: if there is O(x**n) and we fail to integrate then there is
828                 # no point in trying other methods because they will fail anyway.
829                 return None
830 
831             #               c
832             # g(x) = (a*x+b)
833             if g.is_Pow and not g.exp.has(x) and not meijerg:
834                 a = Wild('a', exclude=[x])
835                 b = Wild('b', exclude=[x])
836 
837                 M = g.base.match(a*x + b)
838 
839                 if M is not None:
840                     if g.exp == -1:
841                         h = log(g.base)
842                     elif conds != 'piecewise':
843                         h = g.base**(g.exp + 1) / (g.exp + 1)
844                     else:
845                         h1 = log(g.base)
846                         h2 = g.base**(g.exp + 1) / (g.exp + 1)
847                         h = Piecewise((h1, Eq(g.exp, -1)), (h2, True))
848 
849                     parts.append(coeff * h / M[a])
850                     continue
851 
852             #        poly(x)
853             # g(x) = -------
854             #        poly(x)
855             if g.is_rational_function(x) and not meijerg:
856                 parts.append(coeff * ratint(g, x))
857                 continue
858 
859             if not meijerg:
860                 # g(x) = Mul(trig)
861                 h = trigintegrate(g, x, conds=conds)
862                 if h is not None:
863                     parts.append(coeff * h)
864                     continue
865 
866                 # g(x) has at least a DiracDelta term
867                 h = deltaintegrate(g, x)
868                 if h is not None:
869                     parts.append(coeff * h)
870                     continue
871 
872                 # g(x) has at least a Singularity Function term
873                 h = singularityintegrate(g, x)
874                 if h is not None:
875                     parts.append(coeff * h)
876                     continue
877 
878                 # Try risch again.
879                 if risch is not False:
880                     try:
881                         h, i = risch_integrate(g, x, separate_integral=True, conds=conds)
882                     except NotImplementedError:
883                         h = None
884                     else:
885                         if i:
886                             h = h + i.doit(risch=False)
887 
888                         parts.append(coeff*h)
889                         continue
890 
891                 # fall back to heurisch
892                 try:
893                     if conds == 'piecewise':
894                         h = heurisch_wrapper(g, x, hints=[])
895                     else:
896                         h = heurisch(g, x, hints=[])
897                 except PolynomialError:
898                     # XXX: this exception means there is a bug in the
899                     # implementation of heuristic Risch integration
900                     # algorithm.
901                     h = None
902             else:
903                 h = None
904 
905             if meijerg is not False and h is None:
906                 # rewrite using G functions
907                 try:
908                     h = meijerint_indefinite(g, x)
909                 except NotImplementedError:
910                     from sympy.integrals.meijerint import _debug
911                     _debug('NotImplementedError from meijerint_definite')
912                     res = None
913                 if h is not None:
914                     parts.append(coeff * h)
915                     continue
916 
917             if h is None and manual is not False:
918                 try:
919                     result = manualintegrate(g, x)
920                     if result is not None and not isinstance(result, Integral):
921                         if result.has(Integral):
922                             # try to have other algorithms do the integrals
923                             # manualintegrate can't handle
924                             result = result.func(*[
925                                 arg.doit(manual=False) if arg.has(Integral) else arg
926                                 for arg in result.args
927                             ]).expand(multinomial=False,
928                                       log=False,
929                                       power_exp=False,
930                                       power_base=False)
931                         if not result.has(Integral):
932                             parts.append(coeff * result)
933                             continue
934                 except (ValueError, PolynomialError):
935                     # can't handle some SymPy expressions
936                     pass
937 
938             # if we failed maybe it was because we had
939             # a product that could have been expanded,
940             # so let's try an expansion of the whole
941             # thing before giving up; we don't try this
942             # at the outset because there are things
943             # that cannot be solved unless they are
944             # NOT expanded e.g., x**x*(1+log(x)). There
945             # should probably be a checker somewhere in this
946             # routine to look for such cases and try to do
947             # collection on the expressions if they are already
948             # in an expanded form
949             if not h and len(args) == 1:
950                 f = f.expand(mul=True, deep=False)
951                 if f.is_Add:
952                     # Note: risch will be identical on the expanded
953                     # expression, but maybe it will be able to pick out parts,
954                     # like x*(exp(x) + erf(x)).
955                     return self._eval_integral(f, x, meijerg=meijerg, risch=risch, conds=conds)
956 
957             if h is not None:
958                 parts.append(coeff * h)
959             else:
960                 return None
961 
962         return Add(*parts)
963 
964     def _eval_lseries(self, x, logx):
965         expr = self.as_dummy()
966         symb = x
967         for l in expr.limits:
968             if x in l[1:]:
969                 symb = l[0]
970                 break
971         for term in expr.function.lseries(symb, logx):
972             yield integrate(term, *expr.limits)
973 
974     def _eval_nseries(self, x, n, logx):
975         expr = self.as_dummy()
976         symb = x
977         for l in expr.limits:
978             if x in l[1:]:
979                 symb = l[0]
980                 break
981         terms, order = expr.function.nseries(
982             x=symb, n=n, logx=logx).as_coeff_add(Order)
983         order = [o.subs(symb, x) for o in order]
984         return integrate(terms, *expr.limits) + Add(*order)*x
985 
986     def _eval_as_leading_term(self, x):
987         series_gen = self.args[0].lseries(x)
988         for leading_term in series_gen:
989             if leading_term != 0:
990                 break
991         return integrate(leading_term, *self.args[1:])
992 
993     def as_sum(self, n, method="midpoint"):
994         """
995         Approximates the definite integral by a sum.
996 
997         method ... one of: left, right, midpoint, trapezoid
998 
999         These are all basically the rectangle method [1], the only difference
1000         is where the function value is taken in each interval to define the
1001         rectangle.
1002 
1003         [1] http://en.wikipedia.org/wiki/Rectangle_method
1004 
1005         Examples
1006         ========
1007 
1008         >>> from sympy import sin, sqrt
1009         >>> from sympy.abc import x
1010         >>> from sympy.integrals import Integral
1011         >>> e = Integral(sin(x), (x, 3, 7))
1012         >>> e
1013         Integral(sin(x), (x, 3, 7))
1014 
1015         For demonstration purposes, this interval will only be split into 2
1016         regions, bounded by [3, 5] and [5, 7].
1017 
1018         The left-hand rule uses function evaluations at the left of each
1019         interval:
1020 
1021         >>> e.as_sum(2, 'left')
1022         2*sin(5) + 2*sin(3)
1023 
1024         The midpoint rule uses evaluations at the center of each interval:
1025 
1026         >>> e.as_sum(2, 'midpoint')
1027         2*sin(4) + 2*sin(6)
1028 
1029         The right-hand rule uses function evaluations at the right of each
1030         interval:
1031 
1032         >>> e.as_sum(2, 'right')
1033         2*sin(5) + 2*sin(7)
1034 
1035         The trapezoid rule uses function evaluations on both sides of the
1036         intervals. This is equivalent to taking the average of the left and
1037         right hand rule results:
1038 
1039         >>> e.as_sum(2, 'trapezoid')
1040         2*sin(5) + sin(3) + sin(7)
1041         >>> (e.as_sum(2, 'left') + e.as_sum(2, 'right'))/2 == _
1042         True
1043 
1044         All but the trapexoid method may be used when dealing with a function
1045         with a discontinuity. Here, the discontinuity at x = 0 can be avoided
1046         by using the midpoint or right-hand method:
1047 
1048         >>> e = Integral(1/sqrt(x), (x, 0, 1))
1049         >>> e.as_sum(5).n(4)
1050         1.730
1051         >>> e.as_sum(10).n(4)
1052         1.809
1053         >>> e.doit().n(4)  # the actual value is 2
1054         2.000
1055 
1056         The left- or trapezoid method will encounter the discontinuity and
1057         return oo:
1058 
1059         >>> e.as_sum(5, 'left')
1060         oo
1061         >>> e.as_sum(5, 'trapezoid')
1062         oo
1063 
1064         See Also
1065         ========
1066 
1067         Integral.doit : Perform the integration using any hints
1068         """
1069 
1070         limits = self.limits
1071         if len(limits) > 1:
1072             raise NotImplementedError(
1073                 "Multidimensional midpoint rule not implemented yet")
1074         else:
1075             limit = limits[0]
1076             if len(limit) != 3:
1077                 raise ValueError("Expecting a definite integral.")
1078         if n <= 0:
1079             raise ValueError("n must be > 0")
1080         if n == oo:
1081             raise NotImplementedError("Infinite summation not yet implemented")
1082         sym, lower_limit, upper_limit = limit
1083         dx = (upper_limit - lower_limit)/n
1084 
1085         if method == 'trapezoid':
1086             l = self.function.limit(sym, lower_limit)
1087             r = self.function.limit(sym, upper_limit, "-")
1088             result = (l + r)/2
1089             for i in range(1, n):
1090                 x = lower_limit + i*dx
1091                 result += self.function.subs(sym, x)
1092             return result*dx
1093         elif method not in ('left', 'right', 'midpoint'):
1094             raise NotImplementedError("Unknown method %s" % method)
1095 
1096         result = 0
1097         for i in range(n):
1098             if method == "midpoint":
1099                 xi = lower_limit + i*dx + dx/2
1100             elif method == "left":
1101                 xi = lower_limit + i*dx
1102                 if i == 0:
1103                     result = self.function.limit(sym, lower_limit)
1104                     continue
1105             elif method == "right":
1106                 xi = lower_limit + i*dx + dx
1107                 if i == n:
1108                     result += self.function.limit(sym, upper_limit, "-")
1109                     continue
1110             result += self.function.subs(sym, xi)
1111         return result*dx
1112 
1113     def _sage_(self):
1114         import sage.all as sage
1115         f, limits = self.function._sage_(), list(self.limits)
1116         for limit in limits:
1117             if len(limit) == 1:
1118                 x = limit[0]
1119                 f = sage.integral(f,
1120                                     x._sage_(),
1121                                     hold=True)
1122             elif len(limit) == 2:
1123                 x, b = limit
1124                 f = sage.integral(f,
1125                                     x._sage_(),
1126                                     b._sage_(),
1127                                     hold=True)
1128             else:
1129                 x, a, b = limit
1130                 f = sage.integral(f,
1131                                   (x._sage_(),
1132                                     a._sage_(),
1133                                     b._sage_()),
1134                                     hold=True)
1135         return f
1136 
1137 
1138 def integrate(*args, **kwargs):
1139     """integrate(f, var, ...)
1140 
1141     Compute definite or indefinite integral of one or more variables
1142     using Risch-Norman algorithm and table lookup. This procedure is
1143     able to handle elementary algebraic and transcendental functions
1144     and also a huge class of special functions, including Airy,
1145     Bessel, Whittaker and Lambert.
1146 
1147     var can be:
1148 
1149     - a symbol                   -- indefinite integration
1150     - a tuple (symbol, a)        -- indefinite integration with result
1151                                     given with `a` replacing `symbol`
1152     - a tuple (symbol, a, b)     -- definite integration
1153 
1154     Several variables can be specified, in which case the result is
1155     multiple integration. (If var is omitted and the integrand is
1156     univariate, the indefinite integral in that variable will be performed.)
1157 
1158     Indefinite integrals are returned without terms that are independent
1159     of the integration variables. (see examples)
1160 
1161     Definite improper integrals often entail delicate convergence
1162     conditions. Pass conds='piecewise', 'separate' or 'none' to have
1163     these returned, respectively, as a Piecewise function, as a separate
1164     result (i.e. result will be a tuple), or not at all (default is
1165     'piecewise').
1166 
1167     **Strategy**
1168 
1169     SymPy uses various approaches to definite integration. One method is to
1170     find an antiderivative for the integrand, and then use the fundamental
1171     theorem of calculus. Various functions are implemented to integrate
1172     polynomial, rational and trigonometric functions, and integrands
1173     containing DiracDelta terms.
1174 
1175     SymPy also implements the part of the Risch algorithm, which is a decision
1176     procedure for integrating elementary functions, i.e., the algorithm can
1177     either find an elementary antiderivative, or prove that one does not
1178     exist.  There is also a (very successful, albeit somewhat slow) general
1179     implementation of the heuristic Risch algorithm.  This algorithm will
1180     eventually be phased out as more of the full Risch algorithm is
1181     implemented. See the docstring of Integral._eval_integral() for more
1182     details on computing the antiderivative using algebraic methods.
1183 
1184     The option risch=True can be used to use only the (full) Risch algorithm.
1185     This is useful if you want to know if an elementary function has an
1186     elementary antiderivative.  If the indefinite Integral returned by this
1187     function is an instance of NonElementaryIntegral, that means that the
1188     Risch algorithm has proven that integral to be non-elementary.  Note that
1189     by default, additional methods (such as the Meijer G method outlined
1190     below) are tried on these integrals, as they may be expressible in terms
1191     of special functions, so if you only care about elementary answers, use
1192     risch=True.  Also note that an unevaluated Integral returned by this
1193     function is not necessarily a NonElementaryIntegral, even with risch=True,
1194     as it may just be an indication that the particular part of the Risch
1195     algorithm needed to integrate that function is not yet implemented.
1196 
1197     Another family of strategies comes from re-writing the integrand in
1198     terms of so-called Meijer G-functions. Indefinite integrals of a
1199     single G-function can always be computed, and the definite integral
1200     of a product of two G-functions can be computed from zero to
1201     infinity. Various strategies are implemented to rewrite integrands
1202     as G-functions, and use this information to compute integrals (see
1203     the ``meijerint`` module).
1204 
1205     The option manual=True can be used to use only an algorithm that tries
1206     to mimic integration by hand. This algorithm does not handle as many
1207     integrands as the other algorithms implemented but may return results in
1208     a more familiar form. The ``manualintegrate`` module has functions that
1209     return the steps used (see the module docstring for more information).
1210 
1211     In general, the algebraic methods work best for computing
1212     antiderivatives of (possibly complicated) combinations of elementary
1213     functions. The G-function methods work best for computing definite
1214     integrals from zero to infinity of moderately complicated
1215     combinations of special functions, or indefinite integrals of very
1216     simple combinations of special functions.
1217 
1218     The strategy employed by the integration code is as follows:
1219 
1220     - If computing a definite integral, and both limits are real,
1221       and at least one limit is +- oo, try the G-function method of
1222       definite integration first.
1223 
1224     - Try to find an antiderivative, using all available methods, ordered
1225       by performance (that is try fastest method first, slowest last; in
1226       particular polynomial integration is tried first, Meijer
1227       G-functions second to last, and heuristic Risch last).
1228 
1229     - If still not successful, try G-functions irrespective of the
1230       limits.
1231 
1232     The option meijerg=True, False, None can be used to, respectively:
1233     always use G-function methods and no others, never use G-function
1234     methods, or use all available methods (in order as described above).
1235     It defaults to None.
1236 
1237     Examples
1238     ========
1239 
1240     >>> from sympy import integrate, log, exp, oo
1241     >>> from sympy.abc import a, x, y
1242 
1243     >>> integrate(x*y, x)
1244     x**2*y/2
1245 
1246     >>> integrate(log(x), x)
1247     x*log(x) - x
1248 
1249     >>> integrate(log(x), (x, 1, a))
1250     a*log(a) - a + 1
1251 
1252     >>> integrate(x)
1253     x**2/2
1254 
1255     Terms that are independent of x are dropped by indefinite integration:
1256 
1257     >>> from sympy import sqrt
1258     >>> integrate(sqrt(1 + x), (x, 0, x))
1259     2*(x + 1)**(3/2)/3 - 2/3
1260     >>> integrate(sqrt(1 + x), x)
1261     2*(x + 1)**(3/2)/3
1262 
1263     >>> integrate(x*y)
1264     Traceback (most recent call last):
1265     ...
1266     ValueError: specify integration variables to integrate x*y
1267 
1268     Note that ``integrate(x)`` syntax is meant only for convenience
1269     in interactive sessions and should be avoided in library code.
1270 
1271     >>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'
1272     Piecewise((gamma(a + 1), -re(a) < 1),
1273         (Integral(x**a*exp(-x), (x, 0, oo)), True))
1274 
1275     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')
1276     gamma(a + 1)
1277 
1278     >>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')
1279     (gamma(a + 1), -re(a) < 1)
1280 
1281     See Also
1282     ========
1283 
1284     Integral, Integral.doit
1285 
1286     """
1287     meijerg = kwargs.pop('meijerg', None)
1288     conds = kwargs.pop('conds', 'piecewise')
1289     risch = kwargs.pop('risch', None)
1290     manual = kwargs.pop('manual', None)
1291     integral = Integral(*args, **kwargs)
1292 
1293     if isinstance(integral, Integral):
1294         return integral.doit(deep=False, meijerg=meijerg, conds=conds,
1295                              risch=risch, manual=manual)
1296     else:
1297         return integral
1298 
1299 
1300 def line_integrate(field, curve, vars):
1301     """line_integrate(field, Curve, variables)
1302 
1303     Compute the line integral.
1304 
1305     Examples
1306     ========
1307 
1308     >>> from sympy import Curve, line_integrate, E, ln
1309     >>> from sympy.abc import x, y, t
1310     >>> C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))
1311     >>> line_integrate(x + y, C, [x, y])
1312     3*sqrt(2)
1313 
1314     See Also
1315     ========
1316 
1317     integrate, Integral
1318     """
1319     from sympy.geometry import Curve
1320     F = sympify(field)
1321     if not F:
1322         raise ValueError(
1323             "Expecting function specifying field as first argument.")
1324     if not isinstance(curve, Curve):
1325         raise ValueError("Expecting Curve entity as second argument.")
1326     if not is_sequence(vars):
1327         raise ValueError("Expecting ordered iterable for variables.")
1328     if len(curve.functions) != len(vars):
1329         raise ValueError("Field variable size does not match curve dimension.")
1330 
1331     if curve.parameter in vars:
1332         raise ValueError("Curve parameter clashes with field parameters.")
1333 
1334     # Calculate derivatives for line parameter functions
1335     # F(r) -> F(r(t)) and finally F(r(t)*r'(t))
1336     Ft = F
1337     dldt = 0
1338     for i, var in enumerate(vars):
1339         _f = curve.functions[i]
1340         _dn = diff(_f, curve.parameter)
1341         # ...arc length
1342         dldt = dldt + (_dn * _dn)
1343         Ft = Ft.subs(var, _f)
1344     Ft = Ft * sqrt(dldt)
1345 
1346     integral = Integral(Ft, curve.limits).doit(deep=False)
1347     return integral

</code><intended_behavior>These integral-related functions should be carefully reviewed to ensure that modifications involving "ff" have not adversely affected the computation of integrals. The goal is to maintain or restore the precise handling of integrals, transformations, and evaluations based on the library's standards before the changes.</intended_behavior>, <file>sympy/simplify/combsimp.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import Function, S, Mul, Pow, Add
4 from sympy.core.compatibility import ordered, default_sort_key
5 from sympy.functions.combinatorial.factorials import binomial, CombinatorialFunction, factorial
6 from sympy.functions import gamma, sqrt, sin
7 from sympy.polys import factor, cancel
8 
9 from sympy.utilities.timeutils import timethis
10 from sympy.utilities.iterables import sift
11 from sympy.utilities.iterables import uniq
12 
13 
14 
15 @timethis('combsimp')
16 def combsimp(expr):
17     r"""
18     Simplify combinatorial expressions.
19 
20     This function takes as input an expression containing factorials,
21     binomials, Pochhammer symbol and other "combinatorial" functions,
22     and tries to minimize the number of those functions and reduce
23     the size of their arguments.
24 
25     The algorithm works by rewriting all combinatorial functions as
26     expressions involving rising factorials (Pochhammer symbols) and
27     applies recurrence relations and other transformations applicable
28     to rising factorials, to reduce their arguments, possibly letting
29     the resulting rising factorial to cancel. Rising factorials with
30     the second argument being an integer are expanded into polynomial
31     forms and finally all other rising factorial are rewritten in terms
32     of more familiar functions. If the initial expression consisted of
33     gamma functions alone, the result is expressed in terms of gamma
34     functions. If the initial expression consists of gamma function
35     with some other combinatorial, the result is expressed in terms of
36     gamma functions.
37 
38     If the result is expressed using gamma functions, the following three
39     additional steps are performed:
40 
41     1. Reduce the number of gammas by applying the reflection theorem
42        gamma(x)*gamma(1-x) == pi/sin(pi*x).
43     2. Reduce the number of gammas by applying the multiplication theorem
44        gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).
45     3. Reduce the number of prefactors by absorbing them into gammas, where
46        possible.
47 
48     All transformation rules can be found (or was derived from) here:
49 
50     1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/
51     2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/
52 
53     Examples
54     ========
55 
56     >>> from sympy.simplify import combsimp
57     >>> from sympy import factorial, binomial
58     >>> from sympy.abc import n, k
59 
60     >>> combsimp(factorial(n)/factorial(n - 3))
61     n*(n - 2)*(n - 1)
62     >>> combsimp(binomial(n+1, k+1)/binomial(n, k))
63     (n + 1)/(k + 1)
64 
65     """
66 
67     # as a rule of thumb, if the expression contained gammas initially, it
68     # probably makes sense to retain them
69     as_gamma = expr.has(gamma)
70     as_factorial = expr.has(factorial)
71     as_binomial = expr.has(binomial)
72 
73 
74     expr = expr.replace(binomial,
75         lambda n, k: _rf((n - k + 1).expand(), k.expand())/_rf(1, k.expand()))
76     expr = expr.replace(factorial,
77         lambda n: _rf(1, n.expand()))
78     expr = expr.rewrite(gamma)
79     expr = expr.replace(gamma,
80         lambda n: _rf(1, (n - 1).expand()))
81 
82     if as_gamma:
83         expr = expr.replace(_rf,
84             lambda a, b: gamma(a + b)/gamma(a))
85     else:
86         expr = expr.replace(_rf,
87             lambda a, b: binomial(a + b - 1, b)*gamma(b + 1))
88 
89     def rule(n, k):
90         coeff, rewrite = S.One, False
91 
92         cn, _n = n.as_coeff_Add()
93 
94         if _n and cn.is_Integer and cn:
95             coeff *= _rf(_n + 1, cn)/_rf(_n - k + 1, cn)
96             rewrite = True
97             n = _n
98 
99         # this sort of binomial has already been removed by
100         # rising factorials but is left here in case the order
101         # of rule application is changed
102         if k.is_Add:
103             ck, _k = k.as_coeff_Add()
104             if _k and ck.is_Integer and ck:
105                 coeff *= _rf(n - ck - _k + 1, ck)/_rf(_k + 1, ck)
106                 rewrite = True
107                 k = _k
108 
109         if rewrite:
110             return coeff*binomial(n, k)
111 
112     expr = expr.replace(binomial, rule)
113 
114     def rule_gamma(expr, level=0):
115         """ Simplify products of gamma functions further. """
116 
117         if expr.is_Atom:
118             return expr
119 
120         def gamma_rat(x):
121             # helper to simplify ratios of gammas
122             was = x.count(gamma)
123             xx = x.replace(gamma, lambda n: _rf(1, (n - 1).expand()
124                 ).replace(_rf, lambda a, b: gamma(a + b)/gamma(a)))
125             if xx.count(gamma) < was:
126                 x = xx
127             return x
128 
129         def gamma_factor(x):
130             # return True if there is a gamma factor in shallow args
131             if x.func is gamma:
132                 return True
133             if x.is_Add or x.is_Mul:
134                 return any(gamma_factor(xi) for xi in x.args)
135             if x.is_Pow and (x.exp.is_integer or x.base.is_positive):
136                 return gamma_factor(x.base)
137             return False
138 
139         # recursion step
140         if level == 0:
141             expr = expr.func(*[rule_gamma(x, level + 1) for x in expr.args])
142             level += 1
143 
144         if not expr.is_Mul:
145             return expr
146 
147         # non-commutative step
148         if level == 1:
149             args, nc = expr.args_cnc()
150             if not args:
151                 return expr
152             if nc:
153                 return rule_gamma(Mul._from_args(args), level + 1)*Mul._from_args(nc)
154             level += 1
155 
156         # pure gamma handling, not factor absorbtion
157         if level == 2:
158             sifted = sift(expr.args, gamma_factor)
159             gamma_ind = Mul(*sifted.pop(False, []))
160             d = Mul(*sifted.pop(True, []))
161             assert not sifted
162 
163             nd, dd = d.as_numer_denom()
164             for ipass in range(2):
165                 args = list(ordered(Mul.make_args(nd)))
166                 for i, ni in enumerate(args):
167                     if ni.is_Add:
168                         ni, dd = Add(*[
169                             rule_gamma(gamma_rat(a/dd), level + 1) for a in ni.args]
170                             ).as_numer_denom()
171                         args[i] = ni
172                         if not dd.has(gamma):
173                             break
174                 nd = Mul(*args)
175                 if ipass ==  0 and not gamma_factor(nd):
176                     break
177                 nd, dd = dd, nd  # now process in reversed order
178             expr = gamma_ind*nd/dd
179             if not (expr.is_Mul and (gamma_factor(dd) or gamma_factor(nd))):
180                 return expr
181             level += 1
182 
183         # iteration until constant
184         if level == 3:
185             while True:
186                 was = expr
187                 expr = rule_gamma(expr, 4)
188                 if expr == was:
189                     return expr
190 
191         numer_gammas = []
192         denom_gammas = []
193         numer_others = []
194         denom_others = []
195         def explicate(p):
196             if p is S.One:
197                 return None, []
198             b, e = p.as_base_exp()
199             if e.is_Integer:
200                 if b.func is gamma:
201                     return True, [b.args[0]]*e
202                 else:
203                     return False, [b]*e
204             else:
205                 return False, [p]
206 
207         newargs = list(ordered(expr.args))
208         while newargs:
209             n, d = newargs.pop().as_numer_denom()
210             isg, l = explicate(n)
211             if isg:
212                 numer_gammas.extend(l)
213             elif isg is False:
214                 numer_others.extend(l)
215             isg, l = explicate(d)
216             if isg:
217                 denom_gammas.extend(l)
218             elif isg is False:
219                 denom_others.extend(l)
220 
221         # =========== level 2 work: pure gamma manipulation =========
222 
223         # Try to reduce the number of gamma factors by applying the
224         # reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)
225         for gammas, numer, denom in [(
226             numer_gammas, numer_others, denom_others),
227                 (denom_gammas, denom_others, numer_others)]:
228             new = []
229             while gammas:
230                 g1 = gammas.pop()
231                 if g1.is_integer:
232                     new.append(g1)
233                     continue
234                 for i, g2 in enumerate(gammas):
235                     n = g1 + g2 - 1
236                     if not n.is_Integer:
237                         continue
238                     numer.append(S.Pi)
239                     denom.append(sin(S.Pi*g1))
240                     gammas.pop(i)
241                     if n > 0:
242                         for k in range(n):
243                             numer.append(1 - g1 + k)
244                     elif n < 0:
245                         for k in range(-n):
246                             denom.append(-g1 - k)
247                     break
248                 else:
249                     new.append(g1)
250             # /!\ updating IN PLACE
251             gammas[:] = new
252 
253         # Try to reduce the number of gammas by using the duplication
254         # theorem to cancel an upper and lower: gamma(2*s)/gamma(s) =
255         # 2**(2*s + 1)/(4*sqrt(pi))*gamma(s + 1/2). Although this could
256         # be done with higher argument ratios like gamma(3*x)/gamma(x),
257         # this would not reduce the number of gammas as in this case.
258         for ng, dg, no, do in [(numer_gammas, denom_gammas, numer_others,
259                                 denom_others),
260                                (denom_gammas, numer_gammas, denom_others,
261                                 numer_others)]:
262 
263             while True:
264                 for x in ng:
265                     for y in dg:
266                         n = x - 2*y
267                         if n.is_Integer:
268                             break
269                     else:
270                         continue
271                     break
272                 else:
273                     break
274                 ng.remove(x)
275                 dg.remove(y)
276                 if n > 0:
277                     for k in range(n):
278                         no.append(2*y + k)
279                 elif n < 0:
280                     for k in range(-n):
281                         do.append(2*y - 1 - k)
282                 ng.append(y + S(1)/2)
283                 no.append(2**(2*y - 1))
284                 do.append(sqrt(S.Pi))
285 
286         # Try to reduce the number of gamma factors by applying the
287         # multiplication theorem (used when n gammas with args differing
288         # by 1/n mod 1 are encountered).
289         #
290         # run of 2 with args differing by 1/2
291         #
292         # >>> combsimp(gamma(x)*gamma(x+S.Half))
293         # 2*sqrt(2)*2**(-2*x - 1/2)*sqrt(pi)*gamma(2*x)
294         #
295         # run of 3 args differing by 1/3 (mod 1)
296         #
297         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(2)/3))
298         # 6*3**(-3*x - 1/2)*pi*gamma(3*x)
299         # >>> combsimp(gamma(x)*gamma(x+S(1)/3)*gamma(x+S(5)/3))
300         # 2*3**(-3*x - 1/2)*pi*(3*x + 2)*gamma(3*x)
301         #
302         def _run(coeffs):
303             # find runs in coeffs such that the difference in terms (mod 1)
304             # of t1, t2, ..., tn is 1/n
305             u = list(uniq(coeffs))
306             for i in range(len(u)):
307                 dj = ([((u[j] - u[i]) % 1, j) for j in range(i + 1, len(u))])
308                 for one, j in dj:
309                     if one.p == 1 and one.q != 1:
310                         n = one.q
311                         got = [i]
312                         get = list(range(1, n))
313                         for d, j in dj:
314                             m = n*d
315                             if m.is_Integer and m in get:
316                                 get.remove(m)
317                                 got.append(j)
318                                 if not get:
319                                     break
320                         else:
321                             continue
322                         for i, j in enumerate(got):
323                             c = u[j]
324                             coeffs.remove(c)
325                             got[i] = c
326                         return one.q, got[0], got[1:]
327 
328         def _mult_thm(gammas, numer, denom):
329             # pull off and analyze the leading coefficient from each gamma arg
330             # looking for runs in those Rationals
331 
332             # expr -> coeff + resid -> rats[resid] = coeff
333             rats = {}
334             for g in gammas:
335                 c, resid = g.as_coeff_Add()
336                 rats.setdefault(resid, []).append(c)
337 
338             # look for runs in Rationals for each resid
339             keys = sorted(rats, key=default_sort_key)
340             for resid in keys:
341                 coeffs = list(sorted(rats[resid]))
342                 new = []
343                 while True:
344                     run = _run(coeffs)
345                     if run is None:
346                         break
347 
348                     # process the sequence that was found:
349                     # 1) convert all the gamma functions to have the right
350                     #    argument (could be off by an integer)
351                     # 2) append the factors corresponding to the theorem
352                     # 3) append the new gamma function
353 
354                     n, ui, other = run
355 
356                     # (1)
357                     for u in other:
358                         con = resid + u - 1
359                         for k in range(int(u - ui)):
360                             numer.append(con - k)
361 
362                     con = n*(resid + ui)  # for (2) and (3)
363 
364                     # (2)
365                     numer.append((2*S.Pi)**(S(n - 1)/2)*
366                                  n**(S(1)/2 - con))
367                     # (3)
368                     new.append(con)
369 
370                 # restore resid to coeffs
371                 rats[resid] = [resid + c for c in coeffs] + new
372 
373             # rebuild the gamma arguments
374             g = []
375             for resid in keys:
376                 g += rats[resid]
377             # /!\ updating IN PLACE
378             gammas[:] = g
379 
380         for l, numer, denom in [(numer_gammas, numer_others, denom_others),
381                                 (denom_gammas, denom_others, numer_others)]:
382             _mult_thm(l, numer, denom)
383 
384         # =========== level >= 2 work: factor absorbtion =========
385 
386         if level >= 2:
387             # Try to absorb factors into the gammas: x*gamma(x) -> gamma(x + 1)
388             # and gamma(x)/(x - 1) -> gamma(x - 1)
389             # This code (in particular repeated calls to find_fuzzy) can be very
390             # slow.
391             def find_fuzzy(l, x):
392                 if not l:
393                     return
394                 S1, T1 = compute_ST(x)
395                 for y in l:
396                     S2, T2 = inv[y]
397                     if T1 != T2 or (not S1.intersection(S2) and
398                                     (S1 != set() or S2 != set())):
399                         continue
400                     # XXX we want some simplification (e.g. cancel or
401                     # simplify) but no matter what it's slow.
402                     a = len(cancel(x/y).free_symbols)
403                     b = len(x.free_symbols)
404                     c = len(y.free_symbols)
405                     # TODO is there a better heuristic?
406                     if a == 0 and (b > 0 or c > 0):
407                         return y
408 
409             # We thus try to avoid expensive calls by building the following
410             # "invariants": For every factor or gamma function argument
411             #   - the set of free symbols S
412             #   - the set of functional components T
413             # We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset
414             # or S1 == S2 == emptyset)
415             inv = {}
416 
417             def compute_ST(expr):
418                 if expr in inv:
419                     return inv[expr]
420                 return (expr.free_symbols, expr.atoms(Function).union(
421                         set(e.exp for e in expr.atoms(Pow))))
422 
423             def update_ST(expr):
424                 inv[expr] = compute_ST(expr)
425             for expr in numer_gammas + denom_gammas + numer_others + denom_others:
426                 update_ST(expr)
427 
428             for gammas, numer, denom in [(
429                 numer_gammas, numer_others, denom_others),
430                     (denom_gammas, denom_others, numer_others)]:
431                 new = []
432                 while gammas:
433                     g = gammas.pop()
434                     cont = True
435                     while cont:
436                         cont = False
437                         y = find_fuzzy(numer, g)
438                         if y is not None:
439                             numer.remove(y)
440                             if y != g:
441                                 numer.append(y/g)
442                                 update_ST(y/g)
443                             g += 1
444                             cont = True
445                         y = find_fuzzy(denom, g - 1)
446                         if y is not None:
447                             denom.remove(y)
448                             if y != g - 1:
449                                 numer.append((g - 1)/y)
450                                 update_ST((g - 1)/y)
451                             g -= 1
452                             cont = True
453                     new.append(g)
454                 # /!\ updating IN PLACE
455                 gammas[:] = new
456 
457         # =========== rebuild expr ==================================
458 
459         return Mul(*[gamma(g) for g in numer_gammas]) \
460             / Mul(*[gamma(g) for g in denom_gammas]) \
461             * Mul(*numer_others) / Mul(*denom_others)
462 
463     # (for some reason we cannot use Basic.replace in this case)
464     was = factor(expr)
465     expr = rule_gamma(was)
466     if expr != was:
467         expr = factor(expr)
468 
469     if not as_gamma:
470         if as_factorial:
471             expr = expr.rewrite(factorial)
472         elif as_binomial:
473             expr = expr.rewrite(binomial)
474 
475     return expr
476 
477 class _rf(Function):
478     @classmethod
479     def eval(cls, a, b):
480         if b.is_Integer:
481             if not b:
482                 return S.One
483 
484             n, result = int(b), S.One
485 
486             if n > 0:
487                 for i in range(n):
488                     result *= a + i
489 
490                 return result
491             elif n < 0:
492                 for i in range(1, -n + 1):
493                     result *= a - i
494 
495                 return 1/result
496         else:
497             if b.is_Add:
498                 c, _b = b.as_coeff_Add()
499 
500                 if c.is_Integer:
501                     if c > 0:
502                         return _rf(a, _b)*_rf(a + _b, c)
503                     elif c < 0:
504                         return _rf(a, _b)/_rf(a + _b + c, -c)
505 
506             if a.is_Add:
507                 c, _a = a.as_coeff_Add()
508 
509                 if c.is_Integer:
510                     if c > 0:
511                         return _rf(_a, b)*_rf(_a + b, c)/_rf(_a, c)
512                     elif c < 0:
513                         return _rf(_a, b)*_rf(_a + c, -c)/_rf(_a + b + c, -c)

</code><intended_behavior>The combinatorial simplification routines, including those that utilize "rf", should follow correct simplification logic to yield results consistent with the established combinatorial mathematics principles. If recent changes have introduced discrepancies or errors, a reversion or adjustment will be necessary to restore the accuracy of these simplifications.</intended_behavior>]
2025-10-16 01:54:49.395 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 01:54:49.395 | INFO     | Search-only: skipping patch selection
2025-10-16 01:54:49.497 | INFO     | Task sympy__sympy-12798 completed successfully.
2025-10-16 01:54:49.498 | INFO     | No patch generated. You can try running ACR again.
