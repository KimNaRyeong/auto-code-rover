2025-10-15 19:27:43.871 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 19:27:46.826 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2218, output_tokens=12, cost=0.022540
2025-10-15 19:27:46.827 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 19:27:46.831 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:27:57.229 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2423, output_tokens=421, cost=0.036860
2025-10-15 19:27:57.238 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:28:01.248 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=775, output_tokens=81, cost=0.010180
2025-10-15 19:28:01.250 | DEBUG    | Extracted a valid json.
2025-10-15 19:28:01.250 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"PostManager\")",
        "search_method_in_class(\"fetch_all_posts\", \"PostManager\")",
        "search_class(\"Post\")",
        "search_class(\"Comment\")",
        "search_class(\"User\")",
        "search_method(\"save\")",
        "search_code(\"annotate\")"
    ],
    "bug_locations": []
}
2025-10-15 19:28:01.333 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 19:28:01.333 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 19:28:17.902 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3667, output_tokens=712, cost=0.058030
2025-10-15 19:28:17.909 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:28:26.745 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4595, output_tokens=357, cost=0.056660
2025-10-15 19:28:26.753 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:28:30.252 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=711, output_tokens=140, cost=0.011310
2025-10-15 19:28:30.253 | DEBUG    | Extracted a valid json.
2025-10-15 19:28:30.253 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "",
            "class": "PostManager",
            "method": "fetch_all_posts",
            "intended_behavior": "Ensure that the subquery passed to annotate(likes=Count(\"liked_by\")) returns a single column as expected by the SQL engine. This might involve verifying that the Count aggregation on a related field (liked_by) is formulated correctly and that any subquery involved directly or indirectly through model relationships generates a valid SQL query compatible with both SQLite and PostgreSQL requirements. The intended behavior is to count related objects without causing SQL errors, maintaining functionality across Django versions."
        }
    ]
}
2025-10-15 19:28:30.257 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-15 19:28:30.258 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-15 19:28:30.258 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:28:45.994 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4986, output_tokens=643, cost=0.069150
2025-10-15 19:28:46.004 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:28:47.485 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=997, output_tokens=44, cost=0.011290
2025-10-15 19:28:47.486 | DEBUG    | Extracted a valid json.
2025-10-15 19:28:47.486 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"annotate(likes=Count(\\\"liked_by\\\"))\")",
        "search_code(\"Exists\")"
    ],
    "bug_locations": []
}
2025-10-15 19:28:47.577 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 19:28:47.578 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 19:29:01.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6071, output_tokens=624, cost=0.079430
2025-10-15 19:29:01.813 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 19:29:17.536 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6911, output_tokens=494, cost=0.083930
2025-10-15 19:29:17.546 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 19:29:24.579 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=848, output_tokens=183, cost=0.013970
2025-10-15 19:29:24.580 | DEBUG    | Extracted a valid json.
2025-10-15 19:29:24.580 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "models.py",
            "class": "PostManager",
            "method": "fetch_all_posts",
            "intended_behavior": "The method `fetch_all_posts` in the `PostManager` class should properly manage the construction of a queryset that includes annotations, especially when using `Count` in combination with `Exists` for subqueries. Ensure that any subquery is specifically designed to return only the necessary column(s) required for the count operation, avoiding the inclusion of unnecessary data. Properly integrate with Django's ORM layer to leverage `Exists` in a way that neither disrupts the aggregation nor violates SQL constraints regarding expected results of a sub-select. Refactor `annotate` calls and ensure compatibility with both SQLite and PostgreSQL by adhering to stricter SQL standards relating to subqueries."
        }
    ]
}
2025-10-15 19:29:24.592 | DEBUG    | Bug location extracted successfully: [<file>django/forms/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Helper functions for creating Form classes from Django models
3 and database field objects.
4 """
5 from itertools import chain
6 
7 from django.core.exceptions import (
8     NON_FIELD_ERRORS,
9     FieldError,
10     ImproperlyConfigured,
11     ValidationError,
12 )
13 from django.forms.fields import ChoiceField, Field
14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
15 from django.forms.formsets import BaseFormSet, formset_factory
16 from django.forms.utils import ErrorList
17 from django.forms.widgets import (
18     HiddenInput,
19     MultipleHiddenInput,
20     RadioSelect,
21     SelectMultiple,
22 )
23 from django.utils.text import capfirst, get_text_list
24 from django.utils.translation import gettext
25 from django.utils.translation import gettext_lazy as _
26 
27 __all__ = (
28     "ModelForm",
29     "BaseModelForm",
30     "model_to_dict",
31     "fields_for_model",
32     "ModelChoiceField",
33     "ModelMultipleChoiceField",
34     "ALL_FIELDS",
35     "BaseModelFormSet",
36     "modelformset_factory",
37     "BaseInlineFormSet",
38     "inlineformset_factory",
39     "modelform_factory",
40 )
41 
42 ALL_FIELDS = "__all__"
43 
44 
45 def construct_instance(form, instance, fields=None, exclude=None):
46     """
47     Construct and return a model instance from the bound ``form``'s
48     ``cleaned_data``, but do not save the returned instance to the database.
49     """
50     from django.db import models
51 
52     opts = instance._meta
53 
54     cleaned_data = form.cleaned_data
55     file_field_list = []
56     for f in opts.fields:
57         if (
58             not f.editable
59             or isinstance(f, models.AutoField)
60             or f.name not in cleaned_data
61         ):
62             continue
63         if fields is not None and f.name not in fields:
64             continue
65         if exclude and f.name in exclude:
66             continue
67         # Leave defaults for fields that aren't in POST data, except for
68         # checkbox inputs because they don't appear in POST data if not checked.
69         if (
70             f.has_default()
71             and form[f.name].field.widget.value_omitted_from_data(
72                 form.data, form.files, form.add_prefix(f.name)
73             )
74             and cleaned_data.get(f.name) in form[f.name].field.empty_values
75         ):
76             continue
77         # Defer saving file-type fields until after the other fields, so a
78         # callable upload_to can use the values from other fields.
79         if isinstance(f, models.FileField):
80             file_field_list.append(f)
81         else:
82             f.save_form_data(instance, cleaned_data[f.name])
83 
84     for f in file_field_list:
85         f.save_form_data(instance, cleaned_data[f.name])
86 
87     return instance
88 
89 
90 # ModelForms #################################################################
91 
92 
93 def model_to_dict(instance, fields=None, exclude=None):
94     """
95     Return a dict containing the data in ``instance`` suitable for passing as
96     a Form's ``initial`` keyword argument.
97 
98     ``fields`` is an optional list of field names. If provided, return only the
99     named.
100 
101     ``exclude`` is an optional list of field names. If provided, exclude the
102     named from the returned dict, even if they are listed in the ``fields``
103     argument.
104     """
105     opts = instance._meta
106     data = {}
107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):
108         if not getattr(f, "editable", False):
109             continue
110         if fields is not None and f.name not in fields:
111             continue
112         if exclude and f.name in exclude:
113             continue
114         data[f.name] = f.value_from_object(instance)
115     return data
116 
117 
118 def apply_limit_choices_to_to_formfield(formfield):
119     """Apply limit_choices_to to the formfield's queryset if needed."""
120     from django.db.models import Exists, OuterRef, Q
121 
122     if hasattr(formfield, "queryset") and hasattr(formfield, "get_limit_choices_to"):
123         limit_choices_to = formfield.get_limit_choices_to()
124         if limit_choices_to:
125             complex_filter = limit_choices_to
126             if not isinstance(complex_filter, Q):
127                 complex_filter = Q(**limit_choices_to)
128             complex_filter &= Q(pk=OuterRef("pk"))
129             # Use Exists() to avoid potential duplicates.
130             formfield.queryset = formfield.queryset.filter(
131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),
132             )
133 
134 
135 def fields_for_model(
136     model,
137     fields=None,
138     exclude=None,
139     widgets=None,
140     formfield_callback=None,
141     localized_fields=None,
142     labels=None,
143     help_texts=None,
144     error_messages=None,
145     field_classes=None,
146     *,
147     apply_limit_choices_to=True,
148 ):
149     """
150     Return a dictionary containing form fields for the given model.
151 
152     ``fields`` is an optional list of field names. If provided, return only the
153     named fields.
154 
155     ``exclude`` is an optional list of field names. If provided, exclude the
156     named fields from the returned fields, even if they are listed in the
157     ``fields`` argument.
158 
159     ``widgets`` is a dictionary of model field names mapped to a widget.
160 
161     ``formfield_callback`` is a callable that takes a model field and returns
162     a form field.
163 
164     ``localized_fields`` is a list of names of fields which should be localized.
165 
166     ``labels`` is a dictionary of model field names mapped to a label.
167 
168     ``help_texts`` is a dictionary of model field names mapped to a help text.
169 
170     ``error_messages`` is a dictionary of model field names mapped to a
171     dictionary of error messages.
172 
173     ``field_classes`` is a dictionary of model field names mapped to a form
174     field class.
175 
176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
177     should be applied to a field's queryset.
178     """
179     field_dict = {}
180     ignored = []
181     opts = model._meta
182     # Avoid circular import
183     from django.db.models import Field as ModelField
184 
185     sortable_private_fields = [
186         f for f in opts.private_fields if isinstance(f, ModelField)
187     ]
188     for f in sorted(
189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)
190     ):
191         if not getattr(f, "editable", False):
192             if (
193                 fields is not None
194                 and f.name in fields
195                 and (exclude is None or f.name not in exclude)
196             ):
197                 raise FieldError(
198                     "'%s' cannot be specified for %s model form as it is a "
199                     "non-editable field" % (f.name, model.__name__)
200                 )
201             continue
202         if fields is not None and f.name not in fields:
203             continue
204         if exclude and f.name in exclude:
205             continue
206 
207         kwargs = {}
208         if widgets and f.name in widgets:
209             kwargs["widget"] = widgets[f.name]
210         if localized_fields == ALL_FIELDS or (
211             localized_fields and f.name in localized_fields
212         ):
213             kwargs["localize"] = True
214         if labels and f.name in labels:
215             kwargs["label"] = labels[f.name]
216         if help_texts and f.name in help_texts:
217             kwargs["help_text"] = help_texts[f.name]
218         if error_messages and f.name in error_messages:
219             kwargs["error_messages"] = error_messages[f.name]
220         if field_classes and f.name in field_classes:
221             kwargs["form_class"] = field_classes[f.name]
222 
223         if formfield_callback is None:
224             formfield = f.formfield(**kwargs)
225         elif not callable(formfield_callback):
226             raise TypeError("formfield_callback must be a function or callable")
227         else:
228             formfield = formfield_callback(f, **kwargs)
229 
230         if formfield:
231             if apply_limit_choices_to:
232                 apply_limit_choices_to_to_formfield(formfield)
233             field_dict[f.name] = formfield
234         else:
235             ignored.append(f.name)
236     if fields:
237         field_dict = {
238             f: field_dict.get(f)
239             for f in fields
240             if (not exclude or f not in exclude) and f not in ignored
241         }
242     return field_dict
243 
244 
245 class ModelFormOptions:
246     def __init__(self, options=None):
247         self.model = getattr(options, "model", None)
248         self.fields = getattr(options, "fields", None)
249         self.exclude = getattr(options, "exclude", None)
250         self.widgets = getattr(options, "widgets", None)
251         self.localized_fields = getattr(options, "localized_fields", None)
252         self.labels = getattr(options, "labels", None)
253         self.help_texts = getattr(options, "help_texts", None)
254         self.error_messages = getattr(options, "error_messages", None)
255         self.field_classes = getattr(options, "field_classes", None)
256         self.formfield_callback = getattr(options, "formfield_callback", None)
257 
258 
259 class ModelFormMetaclass(DeclarativeFieldsMetaclass):
260     def __new__(mcs, name, bases, attrs):
261         new_class = super().__new__(mcs, name, bases, attrs)
262 
263         if bases == (BaseModelForm,):
264             return new_class
265 
266         opts = new_class._meta = ModelFormOptions(getattr(new_class, "Meta", None))
267 
268         # We check if a string was passed to `fields` or `exclude`,
269         # which is likely to be a mistake where the user typed ('foo') instead
270         # of ('foo',)
271         for opt in ["fields", "exclude", "localized_fields"]:
272             value = getattr(opts, opt)
273             if isinstance(value, str) and value != ALL_FIELDS:
274                 msg = (
275                     "%(model)s.Meta.%(opt)s cannot be a string. "
276                     "Did you mean to type: ('%(value)s',)?"
277                     % {
278                         "model": new_class.__name__,
279                         "opt": opt,
280                         "value": value,
281                     }
282                 )
283                 raise TypeError(msg)
284 
285         if opts.model:
286             # If a model is defined, extract form fields from it.
287             if opts.fields is None and opts.exclude is None:
288                 raise ImproperlyConfigured(
289                     "Creating a ModelForm without either the 'fields' attribute "
290                     "or the 'exclude' attribute is prohibited; form %s "
291                     "needs updating." % name
292                 )
293 
294             if opts.fields == ALL_FIELDS:
295                 # Sentinel for fields_for_model to indicate "get the list of
296                 # fields from the model"
297                 opts.fields = None
298 
299             fields = fields_for_model(
300                 opts.model,
301                 opts.fields,
302                 opts.exclude,
303                 opts.widgets,
304                 opts.formfield_callback,
305                 opts.localized_fields,
306                 opts.labels,
307                 opts.help_texts,
308                 opts.error_messages,
309                 opts.field_classes,
310                 # limit_choices_to will be applied during ModelForm.__init__().
311                 apply_limit_choices_to=False,
312             )
313 
314             # make sure opts.fields doesn't specify an invalid field
315             none_model_fields = {k for k, v in fields.items() if not v}
316             missing_fields = none_model_fields.difference(new_class.declared_fields)
317             if missing_fields:
318                 message = "Unknown field(s) (%s) specified for %s"
319                 message = message % (", ".join(missing_fields), opts.model.__name__)
320                 raise FieldError(message)
321             # Override default model fields with any custom declared ones
322             # (plus, include all the other declared fields).
323             fields.update(new_class.declared_fields)
324         else:
325             fields = new_class.declared_fields
326 
327         new_class.base_fields = fields
328 
329         return new_class
330 
331 
332 class BaseModelForm(BaseForm):
333     def __init__(
334         self,
335         data=None,
336         files=None,
337         auto_id="id_%s",
338         prefix=None,
339         initial=None,
340         error_class=ErrorList,
341         label_suffix=None,
342         empty_permitted=False,
343         instance=None,
344         use_required_attribute=None,
345         renderer=None,
346     ):
347         opts = self._meta
348         if opts.model is None:
349             raise ValueError("ModelForm has no model class specified.")
350         if instance is None:
351             # if we didn't get an instance, instantiate a new one
352             self.instance = opts.model()
353             object_data = {}
354         else:
355             self.instance = instance
356             object_data = model_to_dict(instance, opts.fields, opts.exclude)
357         # if initial was provided, it should override the values from instance
358         if initial is not None:
359             object_data.update(initial)
360         # self._validate_unique will be set to True by BaseModelForm.clean().
361         # It is False by default so overriding self.clean() and failing to call
362         # super will stop validate_unique from being called.
363         self._validate_unique = False
364         super().__init__(
365             data,
366             files,
367             auto_id,
368             prefix,
369             object_data,
370             error_class,
371             label_suffix,
372             empty_permitted,
373             use_required_attribute=use_required_attribute,
374             renderer=renderer,
375         )
376         for formfield in self.fields.values():
377             apply_limit_choices_to_to_formfield(formfield)
378 
379     def _get_validation_exclusions(self):
380         """
381         For backwards-compatibility, exclude several types of fields from model
382         validation. See tickets #12507, #12521, #12553.
383         """
384         exclude = set()
385         # Build up a list of fields that should be excluded from model field
386         # validation and unique checks.
387         for f in self.instance._meta.fields:
388             field = f.name
389             # Exclude fields that aren't on the form. The developer may be
390             # adding these values to the model after form validation.
391             if field not in self.fields:
392                 exclude.add(f.name)
393 
394             # Don't perform model validation on fields that were defined
395             # manually on the form and excluded via the ModelForm's Meta
396             # class. See #12901.
397             elif self._meta.fields and field not in self._meta.fields:
398                 exclude.add(f.name)
399             elif self._meta.exclude and field in self._meta.exclude:
400                 exclude.add(f.name)
401 
402             # Exclude fields that failed form validation. There's no need for
403             # the model fields to validate them as well.
404             elif field in self._errors:
405                 exclude.add(f.name)
406 
407             # Exclude empty fields that are not required by the form, if the
408             # underlying model field is required. This keeps the model field
409             # from raising a required error. Note: don't exclude the field from
410             # validation if the model field allows blanks. If it does, the blank
411             # value may be included in a unique check, so cannot be excluded
412             # from validation.
413             else:
414                 form_field = self.fields[field]
415                 field_value = self.cleaned_data.get(field)
416                 if (
417                     not f.blank
418                     and not form_field.required
419                     and field_value in form_field.empty_values
420                 ):
421                     exclude.add(f.name)
422         return exclude
423 
424     def clean(self):
425         self._validate_unique = True
426         return self.cleaned_data
427 
428     def _update_errors(self, errors):
429         # Override any validation error messages defined at the model level
430         # with those defined at the form level.
431         opts = self._meta
432 
433         # Allow the model generated by construct_instance() to raise
434         # ValidationError and have them handled in the same way as others.
435         if hasattr(errors, "error_dict"):
436             error_dict = errors.error_dict
437         else:
438             error_dict = {NON_FIELD_ERRORS: errors}
439 
440         for field, messages in error_dict.items():
441             if (
442                 field == NON_FIELD_ERRORS
443                 and opts.error_messages
444                 and NON_FIELD_ERRORS in opts.error_messages
445             ):
446                 error_messages = opts.error_messages[NON_FIELD_ERRORS]
447             elif field in self.fields:
448                 error_messages = self.fields[field].error_messages
449             else:
450                 continue
451 
452             for message in messages:
453                 if (
454                     isinstance(message, ValidationError)
455                     and message.code in error_messages
456                 ):
457                     message.message = error_messages[message.code]
458 
459         self.add_error(None, errors)
460 
461     def _post_clean(self):
462         opts = self._meta
463 
464         exclude = self._get_validation_exclusions()
465 
466         # Foreign Keys being used to represent inline relationships
467         # are excluded from basic field value validation. This is for two
468         # reasons: firstly, the value may not be supplied (#12507; the
469         # case of providing new values to the admin); secondly the
470         # object being referred to may not yet fully exist (#12749).
471         # However, these fields *must* be included in uniqueness checks,
472         # so this can't be part of _get_validation_exclusions().
473         for name, field in self.fields.items():
474             if isinstance(field, InlineForeignKeyField):
475                 exclude.add(name)
476 
477         try:
478             self.instance = construct_instance(
479                 self, self.instance, opts.fields, opts.exclude
480             )
481         except ValidationError as e:
482             self._update_errors(e)
483 
484         try:
485             self.instance.full_clean(exclude=exclude, validate_unique=False)
486         except ValidationError as e:
487             self._update_errors(e)
488 
489         # Validate uniqueness if needed.
490         if self._validate_unique:
491             self.validate_unique()
492 
493     def validate_unique(self):
494         """
495         Call the instance's validate_unique() method and update the form's
496         validation errors if any were raised.
497         """
498         exclude = self._get_validation_exclusions()
499         try:
500             self.instance.validate_unique(exclude=exclude)
501         except ValidationError as e:
502             self._update_errors(e)
503 
504     def _save_m2m(self):
505         """
506         Save the many-to-many fields and generic relations for this form.
507         """
508         cleaned_data = self.cleaned_data
509         exclude = self._meta.exclude
510         fields = self._meta.fields
511         opts = self.instance._meta
512         # Note that for historical reasons we want to include also
513         # private_fields here. (GenericRelation was previously a fake
514         # m2m field).
515         for f in chain(opts.many_to_many, opts.private_fields):
516             if not hasattr(f, "save_form_data"):
517                 continue
518             if fields and f.name not in fields:
519                 continue
520             if exclude and f.name in exclude:
521                 continue
522             if f.name in cleaned_data:
523                 f.save_form_data(self.instance, cleaned_data[f.name])
524 
525     def save(self, commit=True):
526         """
527         Save this form's self.instance object if commit=True. Otherwise, add
528         a save_m2m() method to the form which can be called after the instance
529         is saved manually at a later time. Return the model instance.
530         """
531         if self.errors:
532             raise ValueError(
533                 "The %s could not be %s because the data didn't validate."
534                 % (
535                     self.instance._meta.object_name,
536                     "created" if self.instance._state.adding else "changed",
537                 )
538             )
539         if commit:
540             # If committing, save the instance and the m2m data immediately.
541             self.instance.save()
542             self._save_m2m()
543         else:
544             # If not committing, add a method to the form to allow deferred
545             # saving of m2m data.
546             self.save_m2m = self._save_m2m
547         return self.instance
548 
549     save.alters_data = True
550 
551 
552 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):
553     pass
554 
555 
556 def modelform_factory(
557     model,
558     form=ModelForm,
559     fields=None,
560     exclude=None,
561     formfield_callback=None,
562     widgets=None,
563     localized_fields=None,
564     labels=None,
565     help_texts=None,
566     error_messages=None,
567     field_classes=None,
568 ):
569     """
570     Return a ModelForm containing form fields for the given model. You can
571     optionally pass a `form` argument to use as a starting point for
572     constructing the ModelForm.
573 
574     ``fields`` is an optional list of field names. If provided, include only
575     the named fields in the returned fields. If omitted or '__all__', use all
576     fields.
577 
578     ``exclude`` is an optional list of field names. If provided, exclude the
579     named fields from the returned fields, even if they are listed in the
580     ``fields`` argument.
581 
582     ``widgets`` is a dictionary of model field names mapped to a widget.
583 
584     ``localized_fields`` is a list of names of fields which should be localized.
585 
586     ``formfield_callback`` is a callable that takes a model field and returns
587     a form field.
588 
589     ``labels`` is a dictionary of model field names mapped to a label.
590 
591     ``help_texts`` is a dictionary of model field names mapped to a help text.
592 
593     ``error_messages`` is a dictionary of model field names mapped to a
594     dictionary of error messages.
595 
596     ``field_classes`` is a dictionary of model field names mapped to a form
597     field class.
598     """
599     # Create the inner Meta class. FIXME: ideally, we should be able to
600     # construct a ModelForm without creating and passing in a temporary
601     # inner class.
602 
603     # Build up a list of attributes that the Meta object will have.
604     attrs = {"model": model}
605     if fields is not None:
606         attrs["fields"] = fields
607     if exclude is not None:
608         attrs["exclude"] = exclude
609     if widgets is not None:
610         attrs["widgets"] = widgets
611     if localized_fields is not None:
612         attrs["localized_fields"] = localized_fields
613     if labels is not None:
614         attrs["labels"] = labels
615     if help_texts is not None:
616         attrs["help_texts"] = help_texts
617     if error_messages is not None:
618         attrs["error_messages"] = error_messages
619     if field_classes is not None:
620         attrs["field_classes"] = field_classes
621 
622     # If parent form class already has an inner Meta, the Meta we're
623     # creating needs to inherit from the parent's inner meta.
624     bases = (form.Meta,) if hasattr(form, "Meta") else ()
625     Meta = type("Meta", bases, attrs)
626     if formfield_callback:
627         Meta.formfield_callback = staticmethod(formfield_callback)
628     # Give this new form class a reasonable name.
629     class_name = model.__name__ + "Form"
630 
631     # Class attributes for the new form class.
632     form_class_attrs = {"Meta": Meta}
633 
634     if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
635         raise ImproperlyConfigured(
636             "Calling modelform_factory without defining 'fields' or "
637             "'exclude' explicitly is prohibited."
638         )
639 
640     # Instantiate type(form) in order to use the same metaclass as form.
641     return type(form)(class_name, (form,), form_class_attrs)
642 
643 
644 # ModelFormSets ##############################################################
645 
646 
647 class BaseModelFormSet(BaseFormSet):
648     """
649     A ``FormSet`` for editing a queryset and/or adding new objects to it.
650     """
651 
652     model = None
653     edit_only = False
654 
655     # Set of fields that must be unique among forms of this set.
656     unique_fields = set()
657 
658     def __init__(
659         self,
660         data=None,
661         files=None,
662         auto_id="id_%s",
663         prefix=None,
664         queryset=None,
665         *,
666         initial=None,
667         **kwargs,
668     ):
669         self.queryset = queryset
670         self.initial_extra = initial
671         super().__init__(
672             **{
673                 "data": data,
674                 "files": files,
675                 "auto_id": auto_id,
676                 "prefix": prefix,
677                 **kwargs,
678             }
679         )
680 
681     def initial_form_count(self):
682         """Return the number of forms that are required in this FormSet."""
683         if not self.is_bound:
684             return len(self.get_queryset())
685         return super().initial_form_count()
686 
687     def _existing_object(self, pk):
688         if not hasattr(self, "_object_dict"):
689             self._object_dict = {o.pk: o for o in self.get_queryset()}
690         return self._object_dict.get(pk)
691 
692     def _get_to_python(self, field):
693         """
694         If the field is a related field, fetch the concrete field's (that
695         is, the ultimate pointed-to field's) to_python.
696         """
697         while field.remote_field is not None:
698             field = field.remote_field.get_related_field()
699         return field.to_python
700 
701     def _construct_form(self, i, **kwargs):
702         pk_required = i < self.initial_form_count()
703         if pk_required:
704             if self.is_bound:
705                 pk_key = "%s-%s" % (self.add_prefix(i), self.model._meta.pk.name)
706                 try:
707                     pk = self.data[pk_key]
708                 except KeyError:
709                     # The primary key is missing. The user may have tampered
710                     # with POST data.
711                     pass
712                 else:
713                     to_python = self._get_to_python(self.model._meta.pk)
714                     try:
715                         pk = to_python(pk)
716                     except ValidationError:
717                         # The primary key exists but is an invalid value. The
718                         # user may have tampered with POST data.
719                         pass
720                     else:
721                         kwargs["instance"] = self._existing_object(pk)
722             else:
723                 kwargs["instance"] = self.get_queryset()[i]
724         elif self.initial_extra:
725             # Set initial values for extra forms
726             try:
727                 kwargs["initial"] = self.initial_extra[i - self.initial_form_count()]
728             except IndexError:
729                 pass
730         form = super()._construct_form(i, **kwargs)
731         if pk_required:
732             form.fields[self.model._meta.pk.name].required = True
733         return form
734 
735     def get_queryset(self):
736         if not hasattr(self, "_queryset"):
737             if self.queryset is not None:
738                 qs = self.queryset
739             else:
740                 qs = self.model._default_manager.get_queryset()
741 
742             # If the queryset isn't already ordered we need to add an
743             # artificial ordering here to make sure that all formsets
744             # constructed from this queryset have the same form order.
745             if not qs.ordered:
746                 qs = qs.order_by(self.model._meta.pk.name)
747 
748             # Removed queryset limiting here. As per discussion re: #13023
749             # on django-dev, max_num should not prevent existing
750             # related objects/inlines from being displayed.
751             self._queryset = qs
752         return self._queryset
753 
754     def save_new(self, form, commit=True):
755         """Save and return a new model instance for the given form."""
756         return form.save(commit=commit)
757 
758     def save_existing(self, form, instance, commit=True):
759         """Save and return an existing model instance for the given form."""
760         return form.save(commit=commit)
761 
762     def delete_existing(self, obj, commit=True):
763         """Deletes an existing model instance."""
764         if commit:
765             obj.delete()
766 
767     def save(self, commit=True):
768         """
769         Save model instances for every form, adding and changing instances
770         as necessary, and return the list of instances.
771         """
772         if not commit:
773             self.saved_forms = []
774 
775             def save_m2m():
776                 for form in self.saved_forms:
777                     form.save_m2m()
778 
779             self.save_m2m = save_m2m
780         if self.edit_only:
781             return self.save_existing_objects(commit)
782         else:
783             return self.save_existing_objects(commit) + self.save_new_objects(commit)
784 
785     save.alters_data = True
786 
787     def clean(self):
788         self.validate_unique()
789 
790     def validate_unique(self):
791         # Collect unique_checks and date_checks to run from all the forms.
792         all_unique_checks = set()
793         all_date_checks = set()
794         forms_to_delete = self.deleted_forms
795         valid_forms = [
796             form
797             for form in self.forms
798             if form.is_valid() and form not in forms_to_delete
799         ]
800         for form in valid_forms:
801             exclude = form._get_validation_exclusions()
802             unique_checks, date_checks = form.instance._get_unique_checks(
803                 exclude=exclude,
804                 include_meta_constraints=True,
805             )
806             all_unique_checks.update(unique_checks)
807             all_date_checks.update(date_checks)
808 
809         errors = []
810         # Do each of the unique checks (unique and unique_together)
811         for uclass, unique_check in all_unique_checks:
812             seen_data = set()
813             for form in valid_forms:
814                 # Get the data for the set of fields that must be unique among
815                 # the forms.
816                 row_data = (
817                     field if field in self.unique_fields else form.cleaned_data[field]
818                     for field in unique_check
819                     if field in form.cleaned_data
820                 )
821                 # Reduce Model instances to their primary key values
822                 row_data = tuple(
823                     d._get_pk_val() if hasattr(d, "_get_pk_val")
824                     # Prevent "unhashable type: list" errors later on.
825                     else tuple(d) if isinstance(d, list) else d
826                     for d in row_data
827                 )
828                 if row_data and None not in row_data:
829                     # if we've already seen it then we have a uniqueness failure
830                     if row_data in seen_data:
831                         # poke error messages into the right places and mark
832                         # the form as invalid
833                         errors.append(self.get_unique_error_message(unique_check))
834                         form._errors[NON_FIELD_ERRORS] = self.error_class(
835                             [self.get_form_error()],
836                             renderer=self.renderer,
837                         )
838                         # Remove the data from the cleaned_data dict since it
839                         # was invalid.
840                         for field in unique_check:
841                             if field in form.cleaned_data:
842                                 del form.cleaned_data[field]
843                     # mark the data as seen
844                     seen_data.add(row_data)
845         # iterate over each of the date checks now
846         for date_check in all_date_checks:
847             seen_data = set()
848             uclass, lookup, field, unique_for = date_check
849             for form in valid_forms:
850                 # see if we have data for both fields
851                 if (
852                     form.cleaned_data
853                     and form.cleaned_data[field] is not None
854                     and form.cleaned_data[unique_for] is not None
855                 ):
856                     # if it's a date lookup we need to get the data for all the fields
857                     if lookup == "date":
858                         date = form.cleaned_data[unique_for]
859                         date_data = (date.year, date.month, date.day)
860                     # otherwise it's just the attribute on the date/datetime
861                     # object
862                     else:
863                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)
864                     data = (form.cleaned_data[field],) + date_data
865                     # if we've already seen it then we have a uniqueness failure
866                     if data in seen_data:
867                         # poke error messages into the right places and mark
868                         # the form as invalid
869                         errors.append(self.get_date_error_message(date_check))
870                         form._errors[NON_FIELD_ERRORS] = self.error_class(
871                             [self.get_form_error()],
872                             renderer=self.renderer,
873                         )
874                         # Remove the data from the cleaned_data dict since it
875                         # was invalid.
876                         del form.cleaned_data[field]
877                     # mark the data as seen
878                     seen_data.add(data)
879 
880         if errors:
881             raise ValidationError(errors)
882 
883     def get_unique_error_message(self, unique_check):
884         if len(unique_check) == 1:
885             return gettext("Please correct the duplicate data for %(field)s.") % {
886                 "field": unique_check[0],
887             }
888         else:
889             return gettext(
890                 "Please correct the duplicate data for %(field)s, which must be unique."
891             ) % {
892                 "field": get_text_list(unique_check, _("and")),
893             }
894 
895     def get_date_error_message(self, date_check):
896         return gettext(
897             "Please correct the duplicate data for %(field_name)s "
898             "which must be unique for the %(lookup)s in %(date_field)s."
899         ) % {
900             "field_name": date_check[2],
901             "date_field": date_check[3],
902             "lookup": str(date_check[1]),
903         }
904 
905     def get_form_error(self):
906         return gettext("Please correct the duplicate values below.")
907 
908     def save_existing_objects(self, commit=True):
909         self.changed_objects = []
910         self.deleted_objects = []
911         if not self.initial_forms:
912             return []
913 
914         saved_instances = []
915         forms_to_delete = self.deleted_forms
916         for form in self.initial_forms:
917             obj = form.instance
918             # If the pk is None, it means either:
919             # 1. The object is an unexpected empty model, created by invalid
920             #    POST data such as an object outside the formset's queryset.
921             # 2. The object was already deleted from the database.
922             if obj.pk is None:
923                 continue
924             if form in forms_to_delete:
925                 self.deleted_objects.append(obj)
926                 self.delete_existing(obj, commit=commit)
927             elif form.has_changed():
928                 self.changed_objects.append((obj, form.changed_data))
929                 saved_instances.append(self.save_existing(form, obj, commit=commit))
930                 if not commit:
931                     self.saved_forms.append(form)
932         return saved_instances
933 
934     def save_new_objects(self, commit=True):
935         self.new_objects = []
936         for form in self.extra_forms:
937             if not form.has_changed():
938                 continue
939             # If someone has marked an add form for deletion, don't save the
940             # object.
941             if self.can_delete and self._should_delete_form(form):
942                 continue
943             self.new_objects.append(self.save_new(form, commit=commit))
944             if not commit:
945                 self.saved_forms.append(form)
946         return self.new_objects
947 
948     def add_fields(self, form, index):
949         """Add a hidden field for the object's primary key."""
950         from django.db.models import AutoField, ForeignKey, OneToOneField
951 
952         self._pk_field = pk = self.model._meta.pk
953         # If a pk isn't editable, then it won't be on the form, so we need to
954         # add it here so we can tell which object is which when we get the
955         # data back. Generally, pk.editable should be false, but for some
956         # reason, auto_created pk fields and AutoField's editable attribute is
957         # True, so check for that as well.
958 
959         def pk_is_not_editable(pk):
960             return (
961                 (not pk.editable)
962                 or (pk.auto_created or isinstance(pk, AutoField))
963                 or (
964                     pk.remote_field
965                     and pk.remote_field.parent_link
966                     and pk_is_not_editable(pk.remote_field.model._meta.pk)
967                 )
968             )
969 
970         if pk_is_not_editable(pk) or pk.name not in form.fields:
971             if form.is_bound:
972                 # If we're adding the related instance, ignore its primary key
973                 # as it could be an auto-generated default which isn't actually
974                 # in the database.
975                 pk_value = None if form.instance._state.adding else form.instance.pk
976             else:
977                 try:
978                     if index is not None:
979                         pk_value = self.get_queryset()[index].pk
980                     else:
981                         pk_value = None
982                 except IndexError:
983                     pk_value = None
984             if isinstance(pk, (ForeignKey, OneToOneField)):
985                 qs = pk.remote_field.model._default_manager.get_queryset()
986             else:
987                 qs = self.model._default_manager.get_queryset()
988             qs = qs.using(form.instance._state.db)
989             if form._meta.widgets:
990                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)
991             else:
992                 widget = HiddenInput
993             form.fields[self._pk_field.name] = ModelChoiceField(
994                 qs, initial=pk_value, required=False, widget=widget
995             )
996         super().add_fields(form, index)
997 
998 
999 def modelformset_factory(
1000     model,
1001     form=ModelForm,
1002     formfield_callback=None,
1003     formset=BaseModelFormSet,
1004     extra=1,
1005     can_delete=False,
1006     can_order=False,
1007     max_num=None,
1008     fields=None,
1009     exclude=None,
1010     widgets=None,
1011     validate_max=False,
1012     localized_fields=None,
1013     labels=None,
1014     help_texts=None,
1015     error_messages=None,
1016     min_num=None,
1017     validate_min=False,
1018     field_classes=None,
1019     absolute_max=None,
1020     can_delete_extra=True,
1021     renderer=None,
1022     edit_only=False,
1023 ):
1024     """Return a FormSet class for the given Django model class."""
1025     meta = getattr(form, "Meta", None)
1026     if (
1027         getattr(meta, "fields", fields) is None
1028         and getattr(meta, "exclude", exclude) is None
1029     ):
1030         raise ImproperlyConfigured(
1031             "Calling modelformset_factory without defining 'fields' or "
1032             "'exclude' explicitly is prohibited."
1033         )
1034 
1035     form = modelform_factory(
1036         model,
1037         form=form,
1038         fields=fields,
1039         exclude=exclude,
1040         formfield_callback=formfield_callback,
1041         widgets=widgets,
1042         localized_fields=localized_fields,
1043         labels=labels,
1044         help_texts=help_texts,
1045         error_messages=error_messages,
1046         field_classes=field_classes,
1047     )
1048     FormSet = formset_factory(
1049         form,
1050         formset,
1051         extra=extra,
1052         min_num=min_num,
1053         max_num=max_num,
1054         can_order=can_order,
1055         can_delete=can_delete,
1056         validate_min=validate_min,
1057         validate_max=validate_max,
1058         absolute_max=absolute_max,
1059         can_delete_extra=can_delete_extra,
1060         renderer=renderer,
1061     )
1062     FormSet.model = model
1063     FormSet.edit_only = edit_only
1064     return FormSet
1065 
1066 
1067 # InlineFormSets #############################################################
1068 
1069 
1070 class BaseInlineFormSet(BaseModelFormSet):
1071     """A formset for child objects related to a parent."""
1072 
1073     def __init__(
1074         self,
1075         data=None,
1076         files=None,
1077         instance=None,
1078         save_as_new=False,
1079         prefix=None,
1080         queryset=None,
1081         **kwargs,
1082     ):
1083         if instance is None:
1084             self.instance = self.fk.remote_field.model()
1085         else:
1086             self.instance = instance
1087         self.save_as_new = save_as_new
1088         if queryset is None:
1089             queryset = self.model._default_manager
1090         if self.instance.pk is not None:
1091             qs = queryset.filter(**{self.fk.name: self.instance})
1092         else:
1093             qs = queryset.none()
1094         self.unique_fields = {self.fk.name}
1095         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)
1096 
1097         # Add the generated field to form._meta.fields if it's defined to make
1098         # sure validation isn't skipped on that field.
1099         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
1100             if isinstance(self.form._meta.fields, tuple):
1101                 self.form._meta.fields = list(self.form._meta.fields)
1102             self.form._meta.fields.append(self.fk.name)
1103 
1104     def initial_form_count(self):
1105         if self.save_as_new:
1106             return 0
1107         return super().initial_form_count()
1108 
1109     def _construct_form(self, i, **kwargs):
1110         form = super()._construct_form(i, **kwargs)
1111         if self.save_as_new:
1112             mutable = getattr(form.data, "_mutable", None)
1113             # Allow modifying an immutable QueryDict.
1114             if mutable is not None:
1115                 form.data._mutable = True
1116             # Remove the primary key from the form's data, we are only
1117             # creating new instances
1118             form.data[form.add_prefix(self._pk_field.name)] = None
1119             # Remove the foreign key from the form's data
1120             form.data[form.add_prefix(self.fk.name)] = None
1121             if mutable is not None:
1122                 form.data._mutable = mutable
1123 
1124         # Set the fk value here so that the form can do its validation.
1125         fk_value = self.instance.pk
1126         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1127             fk_value = getattr(self.instance, self.fk.remote_field.field_name)
1128             fk_value = getattr(fk_value, "pk", fk_value)
1129         setattr(form.instance, self.fk.get_attname(), fk_value)
1130         return form
1131 
1132     @classmethod
1133     def get_default_prefix(cls):
1134         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace("+", "")
1135 
1136     def save_new(self, form, commit=True):
1137         # Ensure the latest copy of the related instance is present on each
1138         # form (it may have been saved after the formset was originally
1139         # instantiated).
1140         setattr(form.instance, self.fk.name, self.instance)
1141         return super().save_new(form, commit=commit)
1142 
1143     def add_fields(self, form, index):
1144         super().add_fields(form, index)
1145         if self._pk_field == self.fk:
1146             name = self._pk_field.name
1147             kwargs = {"pk_field": True}
1148         else:
1149             # The foreign key field might not be on the form, so we poke at the
1150             # Model field to get the label, since we need that for error messages.
1151             name = self.fk.name
1152             kwargs = {
1153                 "label": getattr(
1154                     form.fields.get(name), "label", capfirst(self.fk.verbose_name)
1155                 )
1156             }
1157 
1158         # The InlineForeignKeyField assumes that the foreign key relation is
1159         # based on the parent model's pk. If this isn't the case, set to_field
1160         # to correctly resolve the initial form value.
1161         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1162             kwargs["to_field"] = self.fk.remote_field.field_name
1163 
1164         # If we're adding a new object, ignore a parent's auto-generated key
1165         # as it will be regenerated on the save request.
1166         if self.instance._state.adding:
1167             if kwargs.get("to_field") is not None:
1168                 to_field = self.instance._meta.get_field(kwargs["to_field"])
1169             else:
1170                 to_field = self.instance._meta.pk
1171             if to_field.has_default():
1172                 setattr(self.instance, to_field.attname, None)
1173 
1174         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)
1175 
1176     def get_unique_error_message(self, unique_check):
1177         unique_check = [field for field in unique_check if field != self.fk.name]
1178         return super().get_unique_error_message(unique_check)
1179 
1180 
1181 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):
1182     """
1183     Find and return the ForeignKey from model to parent if there is one
1184     (return None if can_fail is True and no such field exists). If fk_name is
1185     provided, assume it is the name of the ForeignKey field. Unless can_fail is
1186     True, raise an exception if there isn't a ForeignKey from model to
1187     parent_model.
1188     """
1189     # avoid circular import
1190     from django.db.models import ForeignKey
1191 
1192     opts = model._meta
1193     if fk_name:
1194         fks_to_parent = [f for f in opts.fields if f.name == fk_name]
1195         if len(fks_to_parent) == 1:
1196             fk = fks_to_parent[0]
1197             parent_list = parent_model._meta.get_parent_list()
1198             if (
1199                 not isinstance(fk, ForeignKey)
1200                 or (
1201                     # ForeignKey to proxy models.
1202                     fk.remote_field.model._meta.proxy
1203                     and fk.remote_field.model._meta.proxy_for_model not in parent_list
1204                 )
1205                 or (
1206                     # ForeignKey to concrete models.
1207                     not fk.remote_field.model._meta.proxy
1208                     and fk.remote_field.model != parent_model
1209                     and fk.remote_field.model not in parent_list
1210                 )
1211             ):
1212                 raise ValueError(
1213                     "fk_name '%s' is not a ForeignKey to '%s'."
1214                     % (fk_name, parent_model._meta.label)
1215                 )
1216         elif not fks_to_parent:
1217             raise ValueError(
1218                 "'%s' has no field named '%s'." % (model._meta.label, fk_name)
1219             )
1220     else:
1221         # Try to discover what the ForeignKey from model to parent_model is
1222         parent_list = parent_model._meta.get_parent_list()
1223         fks_to_parent = [
1224             f
1225             for f in opts.fields
1226             if isinstance(f, ForeignKey)
1227             and (
1228                 f.remote_field.model == parent_model
1229                 or f.remote_field.model in parent_list
1230                 or (
1231                     f.remote_field.model._meta.proxy
1232                     and f.remote_field.model._meta.proxy_for_model in parent_list
1233                 )
1234             )
1235         ]
1236         if len(fks_to_parent) == 1:
1237             fk = fks_to_parent[0]
1238         elif not fks_to_parent:
1239             if can_fail:
1240                 return
1241             raise ValueError(
1242                 "'%s' has no ForeignKey to '%s'."
1243                 % (
1244                     model._meta.label,
1245                     parent_model._meta.label,
1246                 )
1247             )
1248         else:
1249             raise ValueError(
1250                 "'%s' has more than one ForeignKey to '%s'. You must specify "
1251                 "a 'fk_name' attribute."
1252                 % (
1253                     model._meta.label,
1254                     parent_model._meta.label,
1255                 )
1256             )
1257     return fk
1258 
1259 
1260 def inlineformset_factory(
1261     parent_model,
1262     model,
1263     form=ModelForm,
1264     formset=BaseInlineFormSet,
1265     fk_name=None,
1266     fields=None,
1267     exclude=None,
1268     extra=3,
1269     can_order=False,
1270     can_delete=True,
1271     max_num=None,
1272     formfield_callback=None,
1273     widgets=None,
1274     validate_max=False,
1275     localized_fields=None,
1276     labels=None,
1277     help_texts=None,
1278     error_messages=None,
1279     min_num=None,
1280     validate_min=False,
1281     field_classes=None,
1282     absolute_max=None,
1283     can_delete_extra=True,
1284     renderer=None,
1285     edit_only=False,
1286 ):
1287     """
1288     Return an ``InlineFormSet`` for the given kwargs.
1289 
1290     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1291     to ``parent_model``.
1292     """
1293     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1294     # enforce a max_num=1 when the foreign key to the parent model is unique.
1295     if fk.unique:
1296         max_num = 1
1297     kwargs = {
1298         "form": form,
1299         "formfield_callback": formfield_callback,
1300         "formset": formset,
1301         "extra": extra,
1302         "can_delete": can_delete,
1303         "can_order": can_order,
1304         "fields": fields,
1305         "exclude": exclude,
1306         "min_num": min_num,
1307         "max_num": max_num,
1308         "widgets": widgets,
1309         "validate_min": validate_min,
1310         "validate_max": validate_max,
1311         "localized_fields": localized_fields,
1312         "labels": labels,
1313         "help_texts": help_texts,
1314         "error_messages": error_messages,
1315         "field_classes": field_classes,
1316         "absolute_max": absolute_max,
1317         "can_delete_extra": can_delete_extra,
1318         "renderer": renderer,
1319         "edit_only": edit_only,
1320     }
1321     FormSet = modelformset_factory(model, **kwargs)
1322     FormSet.fk = fk
1323     return FormSet
1324 
1325 
1326 # Fields #####################################################################
1327 
1328 
1329 class InlineForeignKeyField(Field):
1330     """
1331     A basic integer field that deals with validating the given value to a
1332     given parent instance in an inline.
1333     """
1334 
1335     widget = HiddenInput
1336     default_error_messages = {
1337         "invalid_choice": _("The inline value did not match the parent instance."),
1338     }
1339 
1340     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):
1341         self.parent_instance = parent_instance
1342         self.pk_field = pk_field
1343         self.to_field = to_field
1344         if self.parent_instance is not None:
1345             if self.to_field:
1346                 kwargs["initial"] = getattr(self.parent_instance, self.to_field)
1347             else:
1348                 kwargs["initial"] = self.parent_instance.pk
1349         kwargs["required"] = False
1350         super().__init__(*args, **kwargs)
1351 
1352     def clean(self, value):
1353         if value in self.empty_values:
1354             if self.pk_field:
1355                 return None
1356             # if there is no value act as we did before.
1357             return self.parent_instance
1358         # ensure the we compare the values as equal types.
1359         if self.to_field:
1360             orig = getattr(self.parent_instance, self.to_field)
1361         else:
1362             orig = self.parent_instance.pk
1363         if str(value) != str(orig):
1364             raise ValidationError(
1365                 self.error_messages["invalid_choice"], code="invalid_choice"
1366             )
1367         return self.parent_instance
1368 
1369     def has_changed(self, initial, data):
1370         return False
1371 
1372 
1373 class ModelChoiceIteratorValue:
1374     def __init__(self, value, instance):
1375         self.value = value
1376         self.instance = instance
1377 
1378     def __str__(self):
1379         return str(self.value)
1380 
1381     def __hash__(self):
1382         return hash(self.value)
1383 
1384     def __eq__(self, other):
1385         if isinstance(other, ModelChoiceIteratorValue):
1386             other = other.value
1387         return self.value == other
1388 
1389 
1390 class ModelChoiceIterator:
1391     def __init__(self, field):
1392         self.field = field
1393         self.queryset = field.queryset
1394 
1395     def __iter__(self):
1396         if self.field.empty_label is not None:
1397             yield ("", self.field.empty_label)
1398         queryset = self.queryset
1399         # Can't use iterator() when queryset uses prefetch_related()
1400         if not queryset._prefetch_related_lookups:
1401             queryset = queryset.iterator()
1402         for obj in queryset:
1403             yield self.choice(obj)
1404 
1405     def __len__(self):
1406         # count() adds a query but uses less memory since the QuerySet results
1407         # won't be cached. In most cases, the choices will only be iterated on,
1408         # and __len__() won't be called.
1409         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)
1410 
1411     def __bool__(self):
1412         return self.field.empty_label is not None or self.queryset.exists()
1413 
1414     def choice(self, obj):
1415         return (
1416             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),
1417             self.field.label_from_instance(obj),
1418         )
1419 
1420 
1421 class ModelChoiceField(ChoiceField):
1422     """A ChoiceField whose choices are a model QuerySet."""
1423 
1424     # This class is a subclass of ChoiceField for purity, but it doesn't
1425     # actually use any of ChoiceField's implementation.
1426     default_error_messages = {
1427         "invalid_choice": _(
1428             "Select a valid choice. That choice is not one of the available choices."
1429         ),
1430     }
1431     iterator = ModelChoiceIterator
1432 
1433     def __init__(
1434         self,
1435         queryset,
1436         *,
1437         empty_label="---------",
1438         required=True,
1439         widget=None,
1440         label=None,
1441         initial=None,
1442         help_text="",
1443         to_field_name=None,
1444         limit_choices_to=None,
1445         blank=False,
1446         **kwargs,
1447     ):
1448         # Call Field instead of ChoiceField __init__() because we don't need
1449         # ChoiceField.__init__().
1450         Field.__init__(
1451             self,
1452             required=required,
1453             widget=widget,
1454             label=label,
1455             initial=initial,
1456             help_text=help_text,
1457             **kwargs,
1458         )
1459         if (required and initial is not None) or (
1460             isinstance(self.widget, RadioSelect) and not blank
1461         ):
1462             self.empty_label = None
1463         else:
1464             self.empty_label = empty_label
1465         self.queryset = queryset
1466         self.limit_choices_to = limit_choices_to  # limit the queryset later.
1467         self.to_field_name = to_field_name
1468 
1469     def get_limit_choices_to(self):
1470         """
1471         Return ``limit_choices_to`` for this form field.
1472 
1473         If it is a callable, invoke it and return the result.
1474         """
1475         if callable(self.limit_choices_to):
1476             return self.limit_choices_to()
1477         return self.limit_choices_to
1478 
1479     def __deepcopy__(self, memo):
1480         result = super(ChoiceField, self).__deepcopy__(memo)
1481         # Need to force a new ModelChoiceIterator to be created, bug #11183
1482         if self.queryset is not None:
1483             result.queryset = self.queryset.all()
1484         return result
1485 
1486     def _get_queryset(self):
1487         return self._queryset
1488 
1489     def _set_queryset(self, queryset):
1490         self._queryset = None if queryset is None else queryset.all()
1491         self.widget.choices = self.choices
1492 
1493     queryset = property(_get_queryset, _set_queryset)
1494 
1495     # this method will be used to create object labels by the QuerySetIterator.
1496     # Override it to customize the label.
1497     def label_from_instance(self, obj):
1498         """
1499         Convert objects into strings and generate the labels for the choices
1500         presented by this object. Subclasses can override this method to
1501         customize the display of the choices.
1502         """
1503         return str(obj)
1504 
1505     def _get_choices(self):
1506         # If self._choices is set, then somebody must have manually set
1507         # the property self.choices. In this case, just return self._choices.
1508         if hasattr(self, "_choices"):
1509             return self._choices
1510 
1511         # Otherwise, execute the QuerySet in self.queryset to determine the
1512         # choices dynamically. Return a fresh ModelChoiceIterator that has not been
1513         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
1514         # time _get_choices() is called (and, thus, each time self.choices is
1515         # accessed) so that we can ensure the QuerySet has not been consumed. This
1516         # construct might look complicated but it allows for lazy evaluation of
1517         # the queryset.
1518         return self.iterator(self)
1519 
1520     choices = property(_get_choices, ChoiceField._set_choices)
1521 
1522     def prepare_value(self, value):
1523         if hasattr(value, "_meta"):
1524             if self.to_field_name:
1525                 return value.serializable_value(self.to_field_name)
1526             else:
1527                 return value.pk
1528         return super().prepare_value(value)
1529 
1530     def to_python(self, value):
1531         if value in self.empty_values:
1532             return None
1533         try:
1534             key = self.to_field_name or "pk"
1535             if isinstance(value, self.queryset.model):
1536                 value = getattr(value, key)
1537             value = self.queryset.get(**{key: value})
1538         except (ValueError, TypeError, self.queryset.model.DoesNotExist):
1539             raise ValidationError(
1540                 self.error_messages["invalid_choice"],
1541                 code="invalid_choice",
1542                 params={"value": value},
1543             )
1544         return value
1545 
1546     def validate(self, value):
1547         return Field.validate(self, value)
1548 
1549     def has_changed(self, initial, data):
1550         if self.disabled:
1551             return False
1552         initial_value = initial if initial is not None else ""
1553         data_value = data if data is not None else ""
1554         return str(self.prepare_value(initial_value)) != str(data_value)
1555 
1556 
1557 class ModelMultipleChoiceField(ModelChoiceField):
1558     """A MultipleChoiceField whose choices are a model QuerySet."""
1559 
1560     widget = SelectMultiple
1561     hidden_widget = MultipleHiddenInput
1562     default_error_messages = {
1563         "invalid_list": _("Enter a list of values."),
1564         "invalid_choice": _(
1565             "Select a valid choice. %(value)s is not one of the available choices."
1566         ),
1567         "invalid_pk_value": _("“%(pk)s” is not a valid value."),
1568     }
1569 
1570     def __init__(self, queryset, **kwargs):
1571         super().__init__(queryset, empty_label=None, **kwargs)
1572 
1573     def to_python(self, value):
1574         if not value:
1575             return []
1576         return list(self._check_values(value))
1577 
1578     def clean(self, value):
1579         value = self.prepare_value(value)
1580         if self.required and not value:
1581             raise ValidationError(self.error_messages["required"], code="required")
1582         elif not self.required and not value:
1583             return self.queryset.none()
1584         if not isinstance(value, (list, tuple)):
1585             raise ValidationError(
1586                 self.error_messages["invalid_list"],
1587                 code="invalid_list",
1588             )
1589         qs = self._check_values(value)
1590         # Since this overrides the inherited ModelChoiceField.clean
1591         # we run custom validators here
1592         self.run_validators(value)
1593         return qs
1594 
1595     def _check_values(self, value):
1596         """
1597         Given a list of possible PK values, return a QuerySet of the
1598         corresponding objects. Raise a ValidationError if a given value is
1599         invalid (not a valid PK, not in the queryset, etc.)
1600         """
1601         key = self.to_field_name or "pk"
1602         # deduplicate given values to avoid creating many querysets or
1603         # requiring the database backend deduplicate efficiently.
1604         try:
1605             value = frozenset(value)
1606         except TypeError:
1607             # list of lists isn't hashable, for example
1608             raise ValidationError(
1609                 self.error_messages["invalid_list"],
1610                 code="invalid_list",
1611             )
1612         for pk in value:
1613             try:
1614                 self.queryset.filter(**{key: pk})
1615             except (ValueError, TypeError):
1616                 raise ValidationError(
1617                     self.error_messages["invalid_pk_value"],
1618                     code="invalid_pk_value",
1619                     params={"pk": pk},
1620                 )
1621         qs = self.queryset.filter(**{"%s__in" % key: value})
1622         pks = {str(getattr(o, key)) for o in qs}
1623         for val in value:
1624             if str(val) not in pks:
1625                 raise ValidationError(
1626                     self.error_messages["invalid_choice"],
1627                     code="invalid_choice",
1628                     params={"value": val},
1629                 )
1630         return qs
1631 
1632     def prepare_value(self, value):
1633         if (
1634             hasattr(value, "__iter__")
1635             and not isinstance(value, str)
1636             and not hasattr(value, "_meta")
1637         ):
1638             prepare_value = super().prepare_value
1639             return [prepare_value(v) for v in value]
1640         return super().prepare_value(value)
1641 
1642     def has_changed(self, initial, data):
1643         if self.disabled:
1644             return False
1645         if initial is None:
1646             initial = []
1647         if data is None:
1648             data = []
1649         if len(initial) != len(data):
1650             return True
1651         initial_set = {str(value) for value in self.prepare_value(initial)}
1652         data_set = {str(value) for value in data}
1653         return data_set != initial_set
1654 
1655 
1656 def modelform_defines_fields(form_class):
1657     return hasattr(form_class, "_meta") and (
1658         form_class._meta.fields is not None or form_class._meta.exclude is not None
1659     )

</code><intended_behavior>The method `fetch_all_posts` in the `PostManager` class should properly manage the construction of a queryset that includes annotations, especially when using `Count` in combination with `Exists` for subqueries. Ensure that any subquery is specifically designed to return only the necessary column(s) required for the count operation, avoiding the inclusion of unnecessary data. Properly integrate with Django's ORM layer to leverage `Exists` in a way that neither disrupts the aggregation nor violates SQL constraints regarding expected results of a sub-select. Refactor `annotate` calls and ensure compatibility with both SQLite and PostgreSQL by adhering to stricter SQL standards relating to subqueries.</intended_behavior>]
2025-10-15 19:29:24.592 | INFO     | Search completed. Bug locations: [<file>django/forms/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Helper functions for creating Form classes from Django models
3 and database field objects.
4 """
5 from itertools import chain
6 
7 from django.core.exceptions import (
8     NON_FIELD_ERRORS,
9     FieldError,
10     ImproperlyConfigured,
11     ValidationError,
12 )
13 from django.forms.fields import ChoiceField, Field
14 from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
15 from django.forms.formsets import BaseFormSet, formset_factory
16 from django.forms.utils import ErrorList
17 from django.forms.widgets import (
18     HiddenInput,
19     MultipleHiddenInput,
20     RadioSelect,
21     SelectMultiple,
22 )
23 from django.utils.text import capfirst, get_text_list
24 from django.utils.translation import gettext
25 from django.utils.translation import gettext_lazy as _
26 
27 __all__ = (
28     "ModelForm",
29     "BaseModelForm",
30     "model_to_dict",
31     "fields_for_model",
32     "ModelChoiceField",
33     "ModelMultipleChoiceField",
34     "ALL_FIELDS",
35     "BaseModelFormSet",
36     "modelformset_factory",
37     "BaseInlineFormSet",
38     "inlineformset_factory",
39     "modelform_factory",
40 )
41 
42 ALL_FIELDS = "__all__"
43 
44 
45 def construct_instance(form, instance, fields=None, exclude=None):
46     """
47     Construct and return a model instance from the bound ``form``'s
48     ``cleaned_data``, but do not save the returned instance to the database.
49     """
50     from django.db import models
51 
52     opts = instance._meta
53 
54     cleaned_data = form.cleaned_data
55     file_field_list = []
56     for f in opts.fields:
57         if (
58             not f.editable
59             or isinstance(f, models.AutoField)
60             or f.name not in cleaned_data
61         ):
62             continue
63         if fields is not None and f.name not in fields:
64             continue
65         if exclude and f.name in exclude:
66             continue
67         # Leave defaults for fields that aren't in POST data, except for
68         # checkbox inputs because they don't appear in POST data if not checked.
69         if (
70             f.has_default()
71             and form[f.name].field.widget.value_omitted_from_data(
72                 form.data, form.files, form.add_prefix(f.name)
73             )
74             and cleaned_data.get(f.name) in form[f.name].field.empty_values
75         ):
76             continue
77         # Defer saving file-type fields until after the other fields, so a
78         # callable upload_to can use the values from other fields.
79         if isinstance(f, models.FileField):
80             file_field_list.append(f)
81         else:
82             f.save_form_data(instance, cleaned_data[f.name])
83 
84     for f in file_field_list:
85         f.save_form_data(instance, cleaned_data[f.name])
86 
87     return instance
88 
89 
90 # ModelForms #################################################################
91 
92 
93 def model_to_dict(instance, fields=None, exclude=None):
94     """
95     Return a dict containing the data in ``instance`` suitable for passing as
96     a Form's ``initial`` keyword argument.
97 
98     ``fields`` is an optional list of field names. If provided, return only the
99     named.
100 
101     ``exclude`` is an optional list of field names. If provided, exclude the
102     named from the returned dict, even if they are listed in the ``fields``
103     argument.
104     """
105     opts = instance._meta
106     data = {}
107     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):
108         if not getattr(f, "editable", False):
109             continue
110         if fields is not None and f.name not in fields:
111             continue
112         if exclude and f.name in exclude:
113             continue
114         data[f.name] = f.value_from_object(instance)
115     return data
116 
117 
118 def apply_limit_choices_to_to_formfield(formfield):
119     """Apply limit_choices_to to the formfield's queryset if needed."""
120     from django.db.models import Exists, OuterRef, Q
121 
122     if hasattr(formfield, "queryset") and hasattr(formfield, "get_limit_choices_to"):
123         limit_choices_to = formfield.get_limit_choices_to()
124         if limit_choices_to:
125             complex_filter = limit_choices_to
126             if not isinstance(complex_filter, Q):
127                 complex_filter = Q(**limit_choices_to)
128             complex_filter &= Q(pk=OuterRef("pk"))
129             # Use Exists() to avoid potential duplicates.
130             formfield.queryset = formfield.queryset.filter(
131                 Exists(formfield.queryset.model._base_manager.filter(complex_filter)),
132             )
133 
134 
135 def fields_for_model(
136     model,
137     fields=None,
138     exclude=None,
139     widgets=None,
140     formfield_callback=None,
141     localized_fields=None,
142     labels=None,
143     help_texts=None,
144     error_messages=None,
145     field_classes=None,
146     *,
147     apply_limit_choices_to=True,
148 ):
149     """
150     Return a dictionary containing form fields for the given model.
151 
152     ``fields`` is an optional list of field names. If provided, return only the
153     named fields.
154 
155     ``exclude`` is an optional list of field names. If provided, exclude the
156     named fields from the returned fields, even if they are listed in the
157     ``fields`` argument.
158 
159     ``widgets`` is a dictionary of model field names mapped to a widget.
160 
161     ``formfield_callback`` is a callable that takes a model field and returns
162     a form field.
163 
164     ``localized_fields`` is a list of names of fields which should be localized.
165 
166     ``labels`` is a dictionary of model field names mapped to a label.
167 
168     ``help_texts`` is a dictionary of model field names mapped to a help text.
169 
170     ``error_messages`` is a dictionary of model field names mapped to a
171     dictionary of error messages.
172 
173     ``field_classes`` is a dictionary of model field names mapped to a form
174     field class.
175 
176     ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
177     should be applied to a field's queryset.
178     """
179     field_dict = {}
180     ignored = []
181     opts = model._meta
182     # Avoid circular import
183     from django.db.models import Field as ModelField
184 
185     sortable_private_fields = [
186         f for f in opts.private_fields if isinstance(f, ModelField)
187     ]
188     for f in sorted(
189         chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)
190     ):
191         if not getattr(f, "editable", False):
192             if (
193                 fields is not None
194                 and f.name in fields
195                 and (exclude is None or f.name not in exclude)
196             ):
197                 raise FieldError(
198                     "'%s' cannot be specified for %s model form as it is a "
199                     "non-editable field" % (f.name, model.__name__)
200                 )
201             continue
202         if fields is not None and f.name not in fields:
203             continue
204         if exclude and f.name in exclude:
205             continue
206 
207         kwargs = {}
208         if widgets and f.name in widgets:
209             kwargs["widget"] = widgets[f.name]
210         if localized_fields == ALL_FIELDS or (
211             localized_fields and f.name in localized_fields
212         ):
213             kwargs["localize"] = True
214         if labels and f.name in labels:
215             kwargs["label"] = labels[f.name]
216         if help_texts and f.name in help_texts:
217             kwargs["help_text"] = help_texts[f.name]
218         if error_messages and f.name in error_messages:
219             kwargs["error_messages"] = error_messages[f.name]
220         if field_classes and f.name in field_classes:
221             kwargs["form_class"] = field_classes[f.name]
222 
223         if formfield_callback is None:
224             formfield = f.formfield(**kwargs)
225         elif not callable(formfield_callback):
226             raise TypeError("formfield_callback must be a function or callable")
227         else:
228             formfield = formfield_callback(f, **kwargs)
229 
230         if formfield:
231             if apply_limit_choices_to:
232                 apply_limit_choices_to_to_formfield(formfield)
233             field_dict[f.name] = formfield
234         else:
235             ignored.append(f.name)
236     if fields:
237         field_dict = {
238             f: field_dict.get(f)
239             for f in fields
240             if (not exclude or f not in exclude) and f not in ignored
241         }
242     return field_dict
243 
244 
245 class ModelFormOptions:
246     def __init__(self, options=None):
247         self.model = getattr(options, "model", None)
248         self.fields = getattr(options, "fields", None)
249         self.exclude = getattr(options, "exclude", None)
250         self.widgets = getattr(options, "widgets", None)
251         self.localized_fields = getattr(options, "localized_fields", None)
252         self.labels = getattr(options, "labels", None)
253         self.help_texts = getattr(options, "help_texts", None)
254         self.error_messages = getattr(options, "error_messages", None)
255         self.field_classes = getattr(options, "field_classes", None)
256         self.formfield_callback = getattr(options, "formfield_callback", None)
257 
258 
259 class ModelFormMetaclass(DeclarativeFieldsMetaclass):
260     def __new__(mcs, name, bases, attrs):
261         new_class = super().__new__(mcs, name, bases, attrs)
262 
263         if bases == (BaseModelForm,):
264             return new_class
265 
266         opts = new_class._meta = ModelFormOptions(getattr(new_class, "Meta", None))
267 
268         # We check if a string was passed to `fields` or `exclude`,
269         # which is likely to be a mistake where the user typed ('foo') instead
270         # of ('foo',)
271         for opt in ["fields", "exclude", "localized_fields"]:
272             value = getattr(opts, opt)
273             if isinstance(value, str) and value != ALL_FIELDS:
274                 msg = (
275                     "%(model)s.Meta.%(opt)s cannot be a string. "
276                     "Did you mean to type: ('%(value)s',)?"
277                     % {
278                         "model": new_class.__name__,
279                         "opt": opt,
280                         "value": value,
281                     }
282                 )
283                 raise TypeError(msg)
284 
285         if opts.model:
286             # If a model is defined, extract form fields from it.
287             if opts.fields is None and opts.exclude is None:
288                 raise ImproperlyConfigured(
289                     "Creating a ModelForm without either the 'fields' attribute "
290                     "or the 'exclude' attribute is prohibited; form %s "
291                     "needs updating." % name
292                 )
293 
294             if opts.fields == ALL_FIELDS:
295                 # Sentinel for fields_for_model to indicate "get the list of
296                 # fields from the model"
297                 opts.fields = None
298 
299             fields = fields_for_model(
300                 opts.model,
301                 opts.fields,
302                 opts.exclude,
303                 opts.widgets,
304                 opts.formfield_callback,
305                 opts.localized_fields,
306                 opts.labels,
307                 opts.help_texts,
308                 opts.error_messages,
309                 opts.field_classes,
310                 # limit_choices_to will be applied during ModelForm.__init__().
311                 apply_limit_choices_to=False,
312             )
313 
314             # make sure opts.fields doesn't specify an invalid field
315             none_model_fields = {k for k, v in fields.items() if not v}
316             missing_fields = none_model_fields.difference(new_class.declared_fields)
317             if missing_fields:
318                 message = "Unknown field(s) (%s) specified for %s"
319                 message = message % (", ".join(missing_fields), opts.model.__name__)
320                 raise FieldError(message)
321             # Override default model fields with any custom declared ones
322             # (plus, include all the other declared fields).
323             fields.update(new_class.declared_fields)
324         else:
325             fields = new_class.declared_fields
326 
327         new_class.base_fields = fields
328 
329         return new_class
330 
331 
332 class BaseModelForm(BaseForm):
333     def __init__(
334         self,
335         data=None,
336         files=None,
337         auto_id="id_%s",
338         prefix=None,
339         initial=None,
340         error_class=ErrorList,
341         label_suffix=None,
342         empty_permitted=False,
343         instance=None,
344         use_required_attribute=None,
345         renderer=None,
346     ):
347         opts = self._meta
348         if opts.model is None:
349             raise ValueError("ModelForm has no model class specified.")
350         if instance is None:
351             # if we didn't get an instance, instantiate a new one
352             self.instance = opts.model()
353             object_data = {}
354         else:
355             self.instance = instance
356             object_data = model_to_dict(instance, opts.fields, opts.exclude)
357         # if initial was provided, it should override the values from instance
358         if initial is not None:
359             object_data.update(initial)
360         # self._validate_unique will be set to True by BaseModelForm.clean().
361         # It is False by default so overriding self.clean() and failing to call
362         # super will stop validate_unique from being called.
363         self._validate_unique = False
364         super().__init__(
365             data,
366             files,
367             auto_id,
368             prefix,
369             object_data,
370             error_class,
371             label_suffix,
372             empty_permitted,
373             use_required_attribute=use_required_attribute,
374             renderer=renderer,
375         )
376         for formfield in self.fields.values():
377             apply_limit_choices_to_to_formfield(formfield)
378 
379     def _get_validation_exclusions(self):
380         """
381         For backwards-compatibility, exclude several types of fields from model
382         validation. See tickets #12507, #12521, #12553.
383         """
384         exclude = set()
385         # Build up a list of fields that should be excluded from model field
386         # validation and unique checks.
387         for f in self.instance._meta.fields:
388             field = f.name
389             # Exclude fields that aren't on the form. The developer may be
390             # adding these values to the model after form validation.
391             if field not in self.fields:
392                 exclude.add(f.name)
393 
394             # Don't perform model validation on fields that were defined
395             # manually on the form and excluded via the ModelForm's Meta
396             # class. See #12901.
397             elif self._meta.fields and field not in self._meta.fields:
398                 exclude.add(f.name)
399             elif self._meta.exclude and field in self._meta.exclude:
400                 exclude.add(f.name)
401 
402             # Exclude fields that failed form validation. There's no need for
403             # the model fields to validate them as well.
404             elif field in self._errors:
405                 exclude.add(f.name)
406 
407             # Exclude empty fields that are not required by the form, if the
408             # underlying model field is required. This keeps the model field
409             # from raising a required error. Note: don't exclude the field from
410             # validation if the model field allows blanks. If it does, the blank
411             # value may be included in a unique check, so cannot be excluded
412             # from validation.
413             else:
414                 form_field = self.fields[field]
415                 field_value = self.cleaned_data.get(field)
416                 if (
417                     not f.blank
418                     and not form_field.required
419                     and field_value in form_field.empty_values
420                 ):
421                     exclude.add(f.name)
422         return exclude
423 
424     def clean(self):
425         self._validate_unique = True
426         return self.cleaned_data
427 
428     def _update_errors(self, errors):
429         # Override any validation error messages defined at the model level
430         # with those defined at the form level.
431         opts = self._meta
432 
433         # Allow the model generated by construct_instance() to raise
434         # ValidationError and have them handled in the same way as others.
435         if hasattr(errors, "error_dict"):
436             error_dict = errors.error_dict
437         else:
438             error_dict = {NON_FIELD_ERRORS: errors}
439 
440         for field, messages in error_dict.items():
441             if (
442                 field == NON_FIELD_ERRORS
443                 and opts.error_messages
444                 and NON_FIELD_ERRORS in opts.error_messages
445             ):
446                 error_messages = opts.error_messages[NON_FIELD_ERRORS]
447             elif field in self.fields:
448                 error_messages = self.fields[field].error_messages
449             else:
450                 continue
451 
452             for message in messages:
453                 if (
454                     isinstance(message, ValidationError)
455                     and message.code in error_messages
456                 ):
457                     message.message = error_messages[message.code]
458 
459         self.add_error(None, errors)
460 
461     def _post_clean(self):
462         opts = self._meta
463 
464         exclude = self._get_validation_exclusions()
465 
466         # Foreign Keys being used to represent inline relationships
467         # are excluded from basic field value validation. This is for two
468         # reasons: firstly, the value may not be supplied (#12507; the
469         # case of providing new values to the admin); secondly the
470         # object being referred to may not yet fully exist (#12749).
471         # However, these fields *must* be included in uniqueness checks,
472         # so this can't be part of _get_validation_exclusions().
473         for name, field in self.fields.items():
474             if isinstance(field, InlineForeignKeyField):
475                 exclude.add(name)
476 
477         try:
478             self.instance = construct_instance(
479                 self, self.instance, opts.fields, opts.exclude
480             )
481         except ValidationError as e:
482             self._update_errors(e)
483 
484         try:
485             self.instance.full_clean(exclude=exclude, validate_unique=False)
486         except ValidationError as e:
487             self._update_errors(e)
488 
489         # Validate uniqueness if needed.
490         if self._validate_unique:
491             self.validate_unique()
492 
493     def validate_unique(self):
494         """
495         Call the instance's validate_unique() method and update the form's
496         validation errors if any were raised.
497         """
498         exclude = self._get_validation_exclusions()
499         try:
500             self.instance.validate_unique(exclude=exclude)
501         except ValidationError as e:
502             self._update_errors(e)
503 
504     def _save_m2m(self):
505         """
506         Save the many-to-many fields and generic relations for this form.
507         """
508         cleaned_data = self.cleaned_data
509         exclude = self._meta.exclude
510         fields = self._meta.fields
511         opts = self.instance._meta
512         # Note that for historical reasons we want to include also
513         # private_fields here. (GenericRelation was previously a fake
514         # m2m field).
515         for f in chain(opts.many_to_many, opts.private_fields):
516             if not hasattr(f, "save_form_data"):
517                 continue
518             if fields and f.name not in fields:
519                 continue
520             if exclude and f.name in exclude:
521                 continue
522             if f.name in cleaned_data:
523                 f.save_form_data(self.instance, cleaned_data[f.name])
524 
525     def save(self, commit=True):
526         """
527         Save this form's self.instance object if commit=True. Otherwise, add
528         a save_m2m() method to the form which can be called after the instance
529         is saved manually at a later time. Return the model instance.
530         """
531         if self.errors:
532             raise ValueError(
533                 "The %s could not be %s because the data didn't validate."
534                 % (
535                     self.instance._meta.object_name,
536                     "created" if self.instance._state.adding else "changed",
537                 )
538             )
539         if commit:
540             # If committing, save the instance and the m2m data immediately.
541             self.instance.save()
542             self._save_m2m()
543         else:
544             # If not committing, add a method to the form to allow deferred
545             # saving of m2m data.
546             self.save_m2m = self._save_m2m
547         return self.instance
548 
549     save.alters_data = True
550 
551 
552 class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):
553     pass
554 
555 
556 def modelform_factory(
557     model,
558     form=ModelForm,
559     fields=None,
560     exclude=None,
561     formfield_callback=None,
562     widgets=None,
563     localized_fields=None,
564     labels=None,
565     help_texts=None,
566     error_messages=None,
567     field_classes=None,
568 ):
569     """
570     Return a ModelForm containing form fields for the given model. You can
571     optionally pass a `form` argument to use as a starting point for
572     constructing the ModelForm.
573 
574     ``fields`` is an optional list of field names. If provided, include only
575     the named fields in the returned fields. If omitted or '__all__', use all
576     fields.
577 
578     ``exclude`` is an optional list of field names. If provided, exclude the
579     named fields from the returned fields, even if they are listed in the
580     ``fields`` argument.
581 
582     ``widgets`` is a dictionary of model field names mapped to a widget.
583 
584     ``localized_fields`` is a list of names of fields which should be localized.
585 
586     ``formfield_callback`` is a callable that takes a model field and returns
587     a form field.
588 
589     ``labels`` is a dictionary of model field names mapped to a label.
590 
591     ``help_texts`` is a dictionary of model field names mapped to a help text.
592 
593     ``error_messages`` is a dictionary of model field names mapped to a
594     dictionary of error messages.
595 
596     ``field_classes`` is a dictionary of model field names mapped to a form
597     field class.
598     """
599     # Create the inner Meta class. FIXME: ideally, we should be able to
600     # construct a ModelForm without creating and passing in a temporary
601     # inner class.
602 
603     # Build up a list of attributes that the Meta object will have.
604     attrs = {"model": model}
605     if fields is not None:
606         attrs["fields"] = fields
607     if exclude is not None:
608         attrs["exclude"] = exclude
609     if widgets is not None:
610         attrs["widgets"] = widgets
611     if localized_fields is not None:
612         attrs["localized_fields"] = localized_fields
613     if labels is not None:
614         attrs["labels"] = labels
615     if help_texts is not None:
616         attrs["help_texts"] = help_texts
617     if error_messages is not None:
618         attrs["error_messages"] = error_messages
619     if field_classes is not None:
620         attrs["field_classes"] = field_classes
621 
622     # If parent form class already has an inner Meta, the Meta we're
623     # creating needs to inherit from the parent's inner meta.
624     bases = (form.Meta,) if hasattr(form, "Meta") else ()
625     Meta = type("Meta", bases, attrs)
626     if formfield_callback:
627         Meta.formfield_callback = staticmethod(formfield_callback)
628     # Give this new form class a reasonable name.
629     class_name = model.__name__ + "Form"
630 
631     # Class attributes for the new form class.
632     form_class_attrs = {"Meta": Meta}
633 
634     if getattr(Meta, "fields", None) is None and getattr(Meta, "exclude", None) is None:
635         raise ImproperlyConfigured(
636             "Calling modelform_factory without defining 'fields' or "
637             "'exclude' explicitly is prohibited."
638         )
639 
640     # Instantiate type(form) in order to use the same metaclass as form.
641     return type(form)(class_name, (form,), form_class_attrs)
642 
643 
644 # ModelFormSets ##############################################################
645 
646 
647 class BaseModelFormSet(BaseFormSet):
648     """
649     A ``FormSet`` for editing a queryset and/or adding new objects to it.
650     """
651 
652     model = None
653     edit_only = False
654 
655     # Set of fields that must be unique among forms of this set.
656     unique_fields = set()
657 
658     def __init__(
659         self,
660         data=None,
661         files=None,
662         auto_id="id_%s",
663         prefix=None,
664         queryset=None,
665         *,
666         initial=None,
667         **kwargs,
668     ):
669         self.queryset = queryset
670         self.initial_extra = initial
671         super().__init__(
672             **{
673                 "data": data,
674                 "files": files,
675                 "auto_id": auto_id,
676                 "prefix": prefix,
677                 **kwargs,
678             }
679         )
680 
681     def initial_form_count(self):
682         """Return the number of forms that are required in this FormSet."""
683         if not self.is_bound:
684             return len(self.get_queryset())
685         return super().initial_form_count()
686 
687     def _existing_object(self, pk):
688         if not hasattr(self, "_object_dict"):
689             self._object_dict = {o.pk: o for o in self.get_queryset()}
690         return self._object_dict.get(pk)
691 
692     def _get_to_python(self, field):
693         """
694         If the field is a related field, fetch the concrete field's (that
695         is, the ultimate pointed-to field's) to_python.
696         """
697         while field.remote_field is not None:
698             field = field.remote_field.get_related_field()
699         return field.to_python
700 
701     def _construct_form(self, i, **kwargs):
702         pk_required = i < self.initial_form_count()
703         if pk_required:
704             if self.is_bound:
705                 pk_key = "%s-%s" % (self.add_prefix(i), self.model._meta.pk.name)
706                 try:
707                     pk = self.data[pk_key]
708                 except KeyError:
709                     # The primary key is missing. The user may have tampered
710                     # with POST data.
711                     pass
712                 else:
713                     to_python = self._get_to_python(self.model._meta.pk)
714                     try:
715                         pk = to_python(pk)
716                     except ValidationError:
717                         # The primary key exists but is an invalid value. The
718                         # user may have tampered with POST data.
719                         pass
720                     else:
721                         kwargs["instance"] = self._existing_object(pk)
722             else:
723                 kwargs["instance"] = self.get_queryset()[i]
724         elif self.initial_extra:
725             # Set initial values for extra forms
726             try:
727                 kwargs["initial"] = self.initial_extra[i - self.initial_form_count()]
728             except IndexError:
729                 pass
730         form = super()._construct_form(i, **kwargs)
731         if pk_required:
732             form.fields[self.model._meta.pk.name].required = True
733         return form
734 
735     def get_queryset(self):
736         if not hasattr(self, "_queryset"):
737             if self.queryset is not None:
738                 qs = self.queryset
739             else:
740                 qs = self.model._default_manager.get_queryset()
741 
742             # If the queryset isn't already ordered we need to add an
743             # artificial ordering here to make sure that all formsets
744             # constructed from this queryset have the same form order.
745             if not qs.ordered:
746                 qs = qs.order_by(self.model._meta.pk.name)
747 
748             # Removed queryset limiting here. As per discussion re: #13023
749             # on django-dev, max_num should not prevent existing
750             # related objects/inlines from being displayed.
751             self._queryset = qs
752         return self._queryset
753 
754     def save_new(self, form, commit=True):
755         """Save and return a new model instance for the given form."""
756         return form.save(commit=commit)
757 
758     def save_existing(self, form, instance, commit=True):
759         """Save and return an existing model instance for the given form."""
760         return form.save(commit=commit)
761 
762     def delete_existing(self, obj, commit=True):
763         """Deletes an existing model instance."""
764         if commit:
765             obj.delete()
766 
767     def save(self, commit=True):
768         """
769         Save model instances for every form, adding and changing instances
770         as necessary, and return the list of instances.
771         """
772         if not commit:
773             self.saved_forms = []
774 
775             def save_m2m():
776                 for form in self.saved_forms:
777                     form.save_m2m()
778 
779             self.save_m2m = save_m2m
780         if self.edit_only:
781             return self.save_existing_objects(commit)
782         else:
783             return self.save_existing_objects(commit) + self.save_new_objects(commit)
784 
785     save.alters_data = True
786 
787     def clean(self):
788         self.validate_unique()
789 
790     def validate_unique(self):
791         # Collect unique_checks and date_checks to run from all the forms.
792         all_unique_checks = set()
793         all_date_checks = set()
794         forms_to_delete = self.deleted_forms
795         valid_forms = [
796             form
797             for form in self.forms
798             if form.is_valid() and form not in forms_to_delete
799         ]
800         for form in valid_forms:
801             exclude = form._get_validation_exclusions()
802             unique_checks, date_checks = form.instance._get_unique_checks(
803                 exclude=exclude,
804                 include_meta_constraints=True,
805             )
806             all_unique_checks.update(unique_checks)
807             all_date_checks.update(date_checks)
808 
809         errors = []
810         # Do each of the unique checks (unique and unique_together)
811         for uclass, unique_check in all_unique_checks:
812             seen_data = set()
813             for form in valid_forms:
814                 # Get the data for the set of fields that must be unique among
815                 # the forms.
816                 row_data = (
817                     field if field in self.unique_fields else form.cleaned_data[field]
818                     for field in unique_check
819                     if field in form.cleaned_data
820                 )
821                 # Reduce Model instances to their primary key values
822                 row_data = tuple(
823                     d._get_pk_val() if hasattr(d, "_get_pk_val")
824                     # Prevent "unhashable type: list" errors later on.
825                     else tuple(d) if isinstance(d, list) else d
826                     for d in row_data
827                 )
828                 if row_data and None not in row_data:
829                     # if we've already seen it then we have a uniqueness failure
830                     if row_data in seen_data:
831                         # poke error messages into the right places and mark
832                         # the form as invalid
833                         errors.append(self.get_unique_error_message(unique_check))
834                         form._errors[NON_FIELD_ERRORS] = self.error_class(
835                             [self.get_form_error()],
836                             renderer=self.renderer,
837                         )
838                         # Remove the data from the cleaned_data dict since it
839                         # was invalid.
840                         for field in unique_check:
841                             if field in form.cleaned_data:
842                                 del form.cleaned_data[field]
843                     # mark the data as seen
844                     seen_data.add(row_data)
845         # iterate over each of the date checks now
846         for date_check in all_date_checks:
847             seen_data = set()
848             uclass, lookup, field, unique_for = date_check
849             for form in valid_forms:
850                 # see if we have data for both fields
851                 if (
852                     form.cleaned_data
853                     and form.cleaned_data[field] is not None
854                     and form.cleaned_data[unique_for] is not None
855                 ):
856                     # if it's a date lookup we need to get the data for all the fields
857                     if lookup == "date":
858                         date = form.cleaned_data[unique_for]
859                         date_data = (date.year, date.month, date.day)
860                     # otherwise it's just the attribute on the date/datetime
861                     # object
862                     else:
863                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)
864                     data = (form.cleaned_data[field],) + date_data
865                     # if we've already seen it then we have a uniqueness failure
866                     if data in seen_data:
867                         # poke error messages into the right places and mark
868                         # the form as invalid
869                         errors.append(self.get_date_error_message(date_check))
870                         form._errors[NON_FIELD_ERRORS] = self.error_class(
871                             [self.get_form_error()],
872                             renderer=self.renderer,
873                         )
874                         # Remove the data from the cleaned_data dict since it
875                         # was invalid.
876                         del form.cleaned_data[field]
877                     # mark the data as seen
878                     seen_data.add(data)
879 
880         if errors:
881             raise ValidationError(errors)
882 
883     def get_unique_error_message(self, unique_check):
884         if len(unique_check) == 1:
885             return gettext("Please correct the duplicate data for %(field)s.") % {
886                 "field": unique_check[0],
887             }
888         else:
889             return gettext(
890                 "Please correct the duplicate data for %(field)s, which must be unique."
891             ) % {
892                 "field": get_text_list(unique_check, _("and")),
893             }
894 
895     def get_date_error_message(self, date_check):
896         return gettext(
897             "Please correct the duplicate data for %(field_name)s "
898             "which must be unique for the %(lookup)s in %(date_field)s."
899         ) % {
900             "field_name": date_check[2],
901             "date_field": date_check[3],
902             "lookup": str(date_check[1]),
903         }
904 
905     def get_form_error(self):
906         return gettext("Please correct the duplicate values below.")
907 
908     def save_existing_objects(self, commit=True):
909         self.changed_objects = []
910         self.deleted_objects = []
911         if not self.initial_forms:
912             return []
913 
914         saved_instances = []
915         forms_to_delete = self.deleted_forms
916         for form in self.initial_forms:
917             obj = form.instance
918             # If the pk is None, it means either:
919             # 1. The object is an unexpected empty model, created by invalid
920             #    POST data such as an object outside the formset's queryset.
921             # 2. The object was already deleted from the database.
922             if obj.pk is None:
923                 continue
924             if form in forms_to_delete:
925                 self.deleted_objects.append(obj)
926                 self.delete_existing(obj, commit=commit)
927             elif form.has_changed():
928                 self.changed_objects.append((obj, form.changed_data))
929                 saved_instances.append(self.save_existing(form, obj, commit=commit))
930                 if not commit:
931                     self.saved_forms.append(form)
932         return saved_instances
933 
934     def save_new_objects(self, commit=True):
935         self.new_objects = []
936         for form in self.extra_forms:
937             if not form.has_changed():
938                 continue
939             # If someone has marked an add form for deletion, don't save the
940             # object.
941             if self.can_delete and self._should_delete_form(form):
942                 continue
943             self.new_objects.append(self.save_new(form, commit=commit))
944             if not commit:
945                 self.saved_forms.append(form)
946         return self.new_objects
947 
948     def add_fields(self, form, index):
949         """Add a hidden field for the object's primary key."""
950         from django.db.models import AutoField, ForeignKey, OneToOneField
951 
952         self._pk_field = pk = self.model._meta.pk
953         # If a pk isn't editable, then it won't be on the form, so we need to
954         # add it here so we can tell which object is which when we get the
955         # data back. Generally, pk.editable should be false, but for some
956         # reason, auto_created pk fields and AutoField's editable attribute is
957         # True, so check for that as well.
958 
959         def pk_is_not_editable(pk):
960             return (
961                 (not pk.editable)
962                 or (pk.auto_created or isinstance(pk, AutoField))
963                 or (
964                     pk.remote_field
965                     and pk.remote_field.parent_link
966                     and pk_is_not_editable(pk.remote_field.model._meta.pk)
967                 )
968             )
969 
970         if pk_is_not_editable(pk) or pk.name not in form.fields:
971             if form.is_bound:
972                 # If we're adding the related instance, ignore its primary key
973                 # as it could be an auto-generated default which isn't actually
974                 # in the database.
975                 pk_value = None if form.instance._state.adding else form.instance.pk
976             else:
977                 try:
978                     if index is not None:
979                         pk_value = self.get_queryset()[index].pk
980                     else:
981                         pk_value = None
982                 except IndexError:
983                     pk_value = None
984             if isinstance(pk, (ForeignKey, OneToOneField)):
985                 qs = pk.remote_field.model._default_manager.get_queryset()
986             else:
987                 qs = self.model._default_manager.get_queryset()
988             qs = qs.using(form.instance._state.db)
989             if form._meta.widgets:
990                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)
991             else:
992                 widget = HiddenInput
993             form.fields[self._pk_field.name] = ModelChoiceField(
994                 qs, initial=pk_value, required=False, widget=widget
995             )
996         super().add_fields(form, index)
997 
998 
999 def modelformset_factory(
1000     model,
1001     form=ModelForm,
1002     formfield_callback=None,
1003     formset=BaseModelFormSet,
1004     extra=1,
1005     can_delete=False,
1006     can_order=False,
1007     max_num=None,
1008     fields=None,
1009     exclude=None,
1010     widgets=None,
1011     validate_max=False,
1012     localized_fields=None,
1013     labels=None,
1014     help_texts=None,
1015     error_messages=None,
1016     min_num=None,
1017     validate_min=False,
1018     field_classes=None,
1019     absolute_max=None,
1020     can_delete_extra=True,
1021     renderer=None,
1022     edit_only=False,
1023 ):
1024     """Return a FormSet class for the given Django model class."""
1025     meta = getattr(form, "Meta", None)
1026     if (
1027         getattr(meta, "fields", fields) is None
1028         and getattr(meta, "exclude", exclude) is None
1029     ):
1030         raise ImproperlyConfigured(
1031             "Calling modelformset_factory without defining 'fields' or "
1032             "'exclude' explicitly is prohibited."
1033         )
1034 
1035     form = modelform_factory(
1036         model,
1037         form=form,
1038         fields=fields,
1039         exclude=exclude,
1040         formfield_callback=formfield_callback,
1041         widgets=widgets,
1042         localized_fields=localized_fields,
1043         labels=labels,
1044         help_texts=help_texts,
1045         error_messages=error_messages,
1046         field_classes=field_classes,
1047     )
1048     FormSet = formset_factory(
1049         form,
1050         formset,
1051         extra=extra,
1052         min_num=min_num,
1053         max_num=max_num,
1054         can_order=can_order,
1055         can_delete=can_delete,
1056         validate_min=validate_min,
1057         validate_max=validate_max,
1058         absolute_max=absolute_max,
1059         can_delete_extra=can_delete_extra,
1060         renderer=renderer,
1061     )
1062     FormSet.model = model
1063     FormSet.edit_only = edit_only
1064     return FormSet
1065 
1066 
1067 # InlineFormSets #############################################################
1068 
1069 
1070 class BaseInlineFormSet(BaseModelFormSet):
1071     """A formset for child objects related to a parent."""
1072 
1073     def __init__(
1074         self,
1075         data=None,
1076         files=None,
1077         instance=None,
1078         save_as_new=False,
1079         prefix=None,
1080         queryset=None,
1081         **kwargs,
1082     ):
1083         if instance is None:
1084             self.instance = self.fk.remote_field.model()
1085         else:
1086             self.instance = instance
1087         self.save_as_new = save_as_new
1088         if queryset is None:
1089             queryset = self.model._default_manager
1090         if self.instance.pk is not None:
1091             qs = queryset.filter(**{self.fk.name: self.instance})
1092         else:
1093             qs = queryset.none()
1094         self.unique_fields = {self.fk.name}
1095         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)
1096 
1097         # Add the generated field to form._meta.fields if it's defined to make
1098         # sure validation isn't skipped on that field.
1099         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:
1100             if isinstance(self.form._meta.fields, tuple):
1101                 self.form._meta.fields = list(self.form._meta.fields)
1102             self.form._meta.fields.append(self.fk.name)
1103 
1104     def initial_form_count(self):
1105         if self.save_as_new:
1106             return 0
1107         return super().initial_form_count()
1108 
1109     def _construct_form(self, i, **kwargs):
1110         form = super()._construct_form(i, **kwargs)
1111         if self.save_as_new:
1112             mutable = getattr(form.data, "_mutable", None)
1113             # Allow modifying an immutable QueryDict.
1114             if mutable is not None:
1115                 form.data._mutable = True
1116             # Remove the primary key from the form's data, we are only
1117             # creating new instances
1118             form.data[form.add_prefix(self._pk_field.name)] = None
1119             # Remove the foreign key from the form's data
1120             form.data[form.add_prefix(self.fk.name)] = None
1121             if mutable is not None:
1122                 form.data._mutable = mutable
1123 
1124         # Set the fk value here so that the form can do its validation.
1125         fk_value = self.instance.pk
1126         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1127             fk_value = getattr(self.instance, self.fk.remote_field.field_name)
1128             fk_value = getattr(fk_value, "pk", fk_value)
1129         setattr(form.instance, self.fk.get_attname(), fk_value)
1130         return form
1131 
1132     @classmethod
1133     def get_default_prefix(cls):
1134         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace("+", "")
1135 
1136     def save_new(self, form, commit=True):
1137         # Ensure the latest copy of the related instance is present on each
1138         # form (it may have been saved after the formset was originally
1139         # instantiated).
1140         setattr(form.instance, self.fk.name, self.instance)
1141         return super().save_new(form, commit=commit)
1142 
1143     def add_fields(self, form, index):
1144         super().add_fields(form, index)
1145         if self._pk_field == self.fk:
1146             name = self._pk_field.name
1147             kwargs = {"pk_field": True}
1148         else:
1149             # The foreign key field might not be on the form, so we poke at the
1150             # Model field to get the label, since we need that for error messages.
1151             name = self.fk.name
1152             kwargs = {
1153                 "label": getattr(
1154                     form.fields.get(name), "label", capfirst(self.fk.verbose_name)
1155                 )
1156             }
1157 
1158         # The InlineForeignKeyField assumes that the foreign key relation is
1159         # based on the parent model's pk. If this isn't the case, set to_field
1160         # to correctly resolve the initial form value.
1161         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:
1162             kwargs["to_field"] = self.fk.remote_field.field_name
1163 
1164         # If we're adding a new object, ignore a parent's auto-generated key
1165         # as it will be regenerated on the save request.
1166         if self.instance._state.adding:
1167             if kwargs.get("to_field") is not None:
1168                 to_field = self.instance._meta.get_field(kwargs["to_field"])
1169             else:
1170                 to_field = self.instance._meta.pk
1171             if to_field.has_default():
1172                 setattr(self.instance, to_field.attname, None)
1173 
1174         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)
1175 
1176     def get_unique_error_message(self, unique_check):
1177         unique_check = [field for field in unique_check if field != self.fk.name]
1178         return super().get_unique_error_message(unique_check)
1179 
1180 
1181 def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):
1182     """
1183     Find and return the ForeignKey from model to parent if there is one
1184     (return None if can_fail is True and no such field exists). If fk_name is
1185     provided, assume it is the name of the ForeignKey field. Unless can_fail is
1186     True, raise an exception if there isn't a ForeignKey from model to
1187     parent_model.
1188     """
1189     # avoid circular import
1190     from django.db.models import ForeignKey
1191 
1192     opts = model._meta
1193     if fk_name:
1194         fks_to_parent = [f for f in opts.fields if f.name == fk_name]
1195         if len(fks_to_parent) == 1:
1196             fk = fks_to_parent[0]
1197             parent_list = parent_model._meta.get_parent_list()
1198             if (
1199                 not isinstance(fk, ForeignKey)
1200                 or (
1201                     # ForeignKey to proxy models.
1202                     fk.remote_field.model._meta.proxy
1203                     and fk.remote_field.model._meta.proxy_for_model not in parent_list
1204                 )
1205                 or (
1206                     # ForeignKey to concrete models.
1207                     not fk.remote_field.model._meta.proxy
1208                     and fk.remote_field.model != parent_model
1209                     and fk.remote_field.model not in parent_list
1210                 )
1211             ):
1212                 raise ValueError(
1213                     "fk_name '%s' is not a ForeignKey to '%s'."
1214                     % (fk_name, parent_model._meta.label)
1215                 )
1216         elif not fks_to_parent:
1217             raise ValueError(
1218                 "'%s' has no field named '%s'." % (model._meta.label, fk_name)
1219             )
1220     else:
1221         # Try to discover what the ForeignKey from model to parent_model is
1222         parent_list = parent_model._meta.get_parent_list()
1223         fks_to_parent = [
1224             f
1225             for f in opts.fields
1226             if isinstance(f, ForeignKey)
1227             and (
1228                 f.remote_field.model == parent_model
1229                 or f.remote_field.model in parent_list
1230                 or (
1231                     f.remote_field.model._meta.proxy
1232                     and f.remote_field.model._meta.proxy_for_model in parent_list
1233                 )
1234             )
1235         ]
1236         if len(fks_to_parent) == 1:
1237             fk = fks_to_parent[0]
1238         elif not fks_to_parent:
1239             if can_fail:
1240                 return
1241             raise ValueError(
1242                 "'%s' has no ForeignKey to '%s'."
1243                 % (
1244                     model._meta.label,
1245                     parent_model._meta.label,
1246                 )
1247             )
1248         else:
1249             raise ValueError(
1250                 "'%s' has more than one ForeignKey to '%s'. You must specify "
1251                 "a 'fk_name' attribute."
1252                 % (
1253                     model._meta.label,
1254                     parent_model._meta.label,
1255                 )
1256             )
1257     return fk
1258 
1259 
1260 def inlineformset_factory(
1261     parent_model,
1262     model,
1263     form=ModelForm,
1264     formset=BaseInlineFormSet,
1265     fk_name=None,
1266     fields=None,
1267     exclude=None,
1268     extra=3,
1269     can_order=False,
1270     can_delete=True,
1271     max_num=None,
1272     formfield_callback=None,
1273     widgets=None,
1274     validate_max=False,
1275     localized_fields=None,
1276     labels=None,
1277     help_texts=None,
1278     error_messages=None,
1279     min_num=None,
1280     validate_min=False,
1281     field_classes=None,
1282     absolute_max=None,
1283     can_delete_extra=True,
1284     renderer=None,
1285     edit_only=False,
1286 ):
1287     """
1288     Return an ``InlineFormSet`` for the given kwargs.
1289 
1290     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``
1291     to ``parent_model``.
1292     """
1293     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)
1294     # enforce a max_num=1 when the foreign key to the parent model is unique.
1295     if fk.unique:
1296         max_num = 1
1297     kwargs = {
1298         "form": form,
1299         "formfield_callback": formfield_callback,
1300         "formset": formset,
1301         "extra": extra,
1302         "can_delete": can_delete,
1303         "can_order": can_order,
1304         "fields": fields,
1305         "exclude": exclude,
1306         "min_num": min_num,
1307         "max_num": max_num,
1308         "widgets": widgets,
1309         "validate_min": validate_min,
1310         "validate_max": validate_max,
1311         "localized_fields": localized_fields,
1312         "labels": labels,
1313         "help_texts": help_texts,
1314         "error_messages": error_messages,
1315         "field_classes": field_classes,
1316         "absolute_max": absolute_max,
1317         "can_delete_extra": can_delete_extra,
1318         "renderer": renderer,
1319         "edit_only": edit_only,
1320     }
1321     FormSet = modelformset_factory(model, **kwargs)
1322     FormSet.fk = fk
1323     return FormSet
1324 
1325 
1326 # Fields #####################################################################
1327 
1328 
1329 class InlineForeignKeyField(Field):
1330     """
1331     A basic integer field that deals with validating the given value to a
1332     given parent instance in an inline.
1333     """
1334 
1335     widget = HiddenInput
1336     default_error_messages = {
1337         "invalid_choice": _("The inline value did not match the parent instance."),
1338     }
1339 
1340     def __init__(self, parent_instance, *args, pk_field=False, to_field=None, **kwargs):
1341         self.parent_instance = parent_instance
1342         self.pk_field = pk_field
1343         self.to_field = to_field
1344         if self.parent_instance is not None:
1345             if self.to_field:
1346                 kwargs["initial"] = getattr(self.parent_instance, self.to_field)
1347             else:
1348                 kwargs["initial"] = self.parent_instance.pk
1349         kwargs["required"] = False
1350         super().__init__(*args, **kwargs)
1351 
1352     def clean(self, value):
1353         if value in self.empty_values:
1354             if self.pk_field:
1355                 return None
1356             # if there is no value act as we did before.
1357             return self.parent_instance
1358         # ensure the we compare the values as equal types.
1359         if self.to_field:
1360             orig = getattr(self.parent_instance, self.to_field)
1361         else:
1362             orig = self.parent_instance.pk
1363         if str(value) != str(orig):
1364             raise ValidationError(
1365                 self.error_messages["invalid_choice"], code="invalid_choice"
1366             )
1367         return self.parent_instance
1368 
1369     def has_changed(self, initial, data):
1370         return False
1371 
1372 
1373 class ModelChoiceIteratorValue:
1374     def __init__(self, value, instance):
1375         self.value = value
1376         self.instance = instance
1377 
1378     def __str__(self):
1379         return str(self.value)
1380 
1381     def __hash__(self):
1382         return hash(self.value)
1383 
1384     def __eq__(self, other):
1385         if isinstance(other, ModelChoiceIteratorValue):
1386             other = other.value
1387         return self.value == other
1388 
1389 
1390 class ModelChoiceIterator:
1391     def __init__(self, field):
1392         self.field = field
1393         self.queryset = field.queryset
1394 
1395     def __iter__(self):
1396         if self.field.empty_label is not None:
1397             yield ("", self.field.empty_label)
1398         queryset = self.queryset
1399         # Can't use iterator() when queryset uses prefetch_related()
1400         if not queryset._prefetch_related_lookups:
1401             queryset = queryset.iterator()
1402         for obj in queryset:
1403             yield self.choice(obj)
1404 
1405     def __len__(self):
1406         # count() adds a query but uses less memory since the QuerySet results
1407         # won't be cached. In most cases, the choices will only be iterated on,
1408         # and __len__() won't be called.
1409         return self.queryset.count() + (1 if self.field.empty_label is not None else 0)
1410 
1411     def __bool__(self):
1412         return self.field.empty_label is not None or self.queryset.exists()
1413 
1414     def choice(self, obj):
1415         return (
1416             ModelChoiceIteratorValue(self.field.prepare_value(obj), obj),
1417             self.field.label_from_instance(obj),
1418         )
1419 
1420 
1421 class ModelChoiceField(ChoiceField):
1422     """A ChoiceField whose choices are a model QuerySet."""
1423 
1424     # This class is a subclass of ChoiceField for purity, but it doesn't
1425     # actually use any of ChoiceField's implementation.
1426     default_error_messages = {
1427         "invalid_choice": _(
1428             "Select a valid choice. That choice is not one of the available choices."
1429         ),
1430     }
1431     iterator = ModelChoiceIterator
1432 
1433     def __init__(
1434         self,
1435         queryset,
1436         *,
1437         empty_label="---------",
1438         required=True,
1439         widget=None,
1440         label=None,
1441         initial=None,
1442         help_text="",
1443         to_field_name=None,
1444         limit_choices_to=None,
1445         blank=False,
1446         **kwargs,
1447     ):
1448         # Call Field instead of ChoiceField __init__() because we don't need
1449         # ChoiceField.__init__().
1450         Field.__init__(
1451             self,
1452             required=required,
1453             widget=widget,
1454             label=label,
1455             initial=initial,
1456             help_text=help_text,
1457             **kwargs,
1458         )
1459         if (required and initial is not None) or (
1460             isinstance(self.widget, RadioSelect) and not blank
1461         ):
1462             self.empty_label = None
1463         else:
1464             self.empty_label = empty_label
1465         self.queryset = queryset
1466         self.limit_choices_to = limit_choices_to  # limit the queryset later.
1467         self.to_field_name = to_field_name
1468 
1469     def get_limit_choices_to(self):
1470         """
1471         Return ``limit_choices_to`` for this form field.
1472 
1473         If it is a callable, invoke it and return the result.
1474         """
1475         if callable(self.limit_choices_to):
1476             return self.limit_choices_to()
1477         return self.limit_choices_to
1478 
1479     def __deepcopy__(self, memo):
1480         result = super(ChoiceField, self).__deepcopy__(memo)
1481         # Need to force a new ModelChoiceIterator to be created, bug #11183
1482         if self.queryset is not None:
1483             result.queryset = self.queryset.all()
1484         return result
1485 
1486     def _get_queryset(self):
1487         return self._queryset
1488 
1489     def _set_queryset(self, queryset):
1490         self._queryset = None if queryset is None else queryset.all()
1491         self.widget.choices = self.choices
1492 
1493     queryset = property(_get_queryset, _set_queryset)
1494 
1495     # this method will be used to create object labels by the QuerySetIterator.
1496     # Override it to customize the label.
1497     def label_from_instance(self, obj):
1498         """
1499         Convert objects into strings and generate the labels for the choices
1500         presented by this object. Subclasses can override this method to
1501         customize the display of the choices.
1502         """
1503         return str(obj)
1504 
1505     def _get_choices(self):
1506         # If self._choices is set, then somebody must have manually set
1507         # the property self.choices. In this case, just return self._choices.
1508         if hasattr(self, "_choices"):
1509             return self._choices
1510 
1511         # Otherwise, execute the QuerySet in self.queryset to determine the
1512         # choices dynamically. Return a fresh ModelChoiceIterator that has not been
1513         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*
1514         # time _get_choices() is called (and, thus, each time self.choices is
1515         # accessed) so that we can ensure the QuerySet has not been consumed. This
1516         # construct might look complicated but it allows for lazy evaluation of
1517         # the queryset.
1518         return self.iterator(self)
1519 
1520     choices = property(_get_choices, ChoiceField._set_choices)
1521 
1522     def prepare_value(self, value):
1523         if hasattr(value, "_meta"):
1524             if self.to_field_name:
1525                 return value.serializable_value(self.to_field_name)
1526             else:
1527                 return value.pk
1528         return super().prepare_value(value)
1529 
1530     def to_python(self, value):
1531         if value in self.empty_values:
1532             return None
1533         try:
1534             key = self.to_field_name or "pk"
1535             if isinstance(value, self.queryset.model):
1536                 value = getattr(value, key)
1537             value = self.queryset.get(**{key: value})
1538         except (ValueError, TypeError, self.queryset.model.DoesNotExist):
1539             raise ValidationError(
1540                 self.error_messages["invalid_choice"],
1541                 code="invalid_choice",
1542                 params={"value": value},
1543             )
1544         return value
1545 
1546     def validate(self, value):
1547         return Field.validate(self, value)
1548 
1549     def has_changed(self, initial, data):
1550         if self.disabled:
1551             return False
1552         initial_value = initial if initial is not None else ""
1553         data_value = data if data is not None else ""
1554         return str(self.prepare_value(initial_value)) != str(data_value)
1555 
1556 
1557 class ModelMultipleChoiceField(ModelChoiceField):
1558     """A MultipleChoiceField whose choices are a model QuerySet."""
1559 
1560     widget = SelectMultiple
1561     hidden_widget = MultipleHiddenInput
1562     default_error_messages = {
1563         "invalid_list": _("Enter a list of values."),
1564         "invalid_choice": _(
1565             "Select a valid choice. %(value)s is not one of the available choices."
1566         ),
1567         "invalid_pk_value": _("“%(pk)s” is not a valid value."),
1568     }
1569 
1570     def __init__(self, queryset, **kwargs):
1571         super().__init__(queryset, empty_label=None, **kwargs)
1572 
1573     def to_python(self, value):
1574         if not value:
1575             return []
1576         return list(self._check_values(value))
1577 
1578     def clean(self, value):
1579         value = self.prepare_value(value)
1580         if self.required and not value:
1581             raise ValidationError(self.error_messages["required"], code="required")
1582         elif not self.required and not value:
1583             return self.queryset.none()
1584         if not isinstance(value, (list, tuple)):
1585             raise ValidationError(
1586                 self.error_messages["invalid_list"],
1587                 code="invalid_list",
1588             )
1589         qs = self._check_values(value)
1590         # Since this overrides the inherited ModelChoiceField.clean
1591         # we run custom validators here
1592         self.run_validators(value)
1593         return qs
1594 
1595     def _check_values(self, value):
1596         """
1597         Given a list of possible PK values, return a QuerySet of the
1598         corresponding objects. Raise a ValidationError if a given value is
1599         invalid (not a valid PK, not in the queryset, etc.)
1600         """
1601         key = self.to_field_name or "pk"
1602         # deduplicate given values to avoid creating many querysets or
1603         # requiring the database backend deduplicate efficiently.
1604         try:
1605             value = frozenset(value)
1606         except TypeError:
1607             # list of lists isn't hashable, for example
1608             raise ValidationError(
1609                 self.error_messages["invalid_list"],
1610                 code="invalid_list",
1611             )
1612         for pk in value:
1613             try:
1614                 self.queryset.filter(**{key: pk})
1615             except (ValueError, TypeError):
1616                 raise ValidationError(
1617                     self.error_messages["invalid_pk_value"],
1618                     code="invalid_pk_value",
1619                     params={"pk": pk},
1620                 )
1621         qs = self.queryset.filter(**{"%s__in" % key: value})
1622         pks = {str(getattr(o, key)) for o in qs}
1623         for val in value:
1624             if str(val) not in pks:
1625                 raise ValidationError(
1626                     self.error_messages["invalid_choice"],
1627                     code="invalid_choice",
1628                     params={"value": val},
1629                 )
1630         return qs
1631 
1632     def prepare_value(self, value):
1633         if (
1634             hasattr(value, "__iter__")
1635             and not isinstance(value, str)
1636             and not hasattr(value, "_meta")
1637         ):
1638             prepare_value = super().prepare_value
1639             return [prepare_value(v) for v in value]
1640         return super().prepare_value(value)
1641 
1642     def has_changed(self, initial, data):
1643         if self.disabled:
1644             return False
1645         if initial is None:
1646             initial = []
1647         if data is None:
1648             data = []
1649         if len(initial) != len(data):
1650             return True
1651         initial_set = {str(value) for value in self.prepare_value(initial)}
1652         data_set = {str(value) for value in data}
1653         return data_set != initial_set
1654 
1655 
1656 def modelform_defines_fields(form_class):
1657     return hasattr(form_class, "_meta") and (
1658         form_class._meta.fields is not None or form_class._meta.exclude is not None
1659     )

</code><intended_behavior>The method `fetch_all_posts` in the `PostManager` class should properly manage the construction of a queryset that includes annotations, especially when using `Count` in combination with `Exists` for subqueries. Ensure that any subquery is specifically designed to return only the necessary column(s) required for the count operation, avoiding the inclusion of unnecessary data. Properly integrate with Django's ORM layer to leverage `Exists` in a way that neither disrupts the aggregation nor violates SQL constraints regarding expected results of a sub-select. Refactor `annotate` calls and ensure compatibility with both SQLite and PostgreSQL by adhering to stricter SQL standards relating to subqueries.</intended_behavior>]
2025-10-15 19:29:24.593 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 19:29:24.593 | INFO     | Search-only: skipping patch selection
2025-10-15 19:29:24.763 | INFO     | Task django__django-16037 completed successfully.
2025-10-15 19:29:24.764 | INFO     | No patch generated. You can try running ACR again.
