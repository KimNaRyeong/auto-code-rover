[
    {
        "rel_file_path": "sklearn/utils/sparsefuncs.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/utils/sparsefuncs.py",
        "start": 348,
        "end": 368,
        "class_name": null,
        "method_name": "_min_or_max_axis",
        "code": "348 def _min_or_max_axis(X, axis, min_or_max):\n349     N = X.shape[axis]\n350     if N == 0:\n351         raise ValueError(\"zero-size array to reduction operation\")\n352     M = X.shape[1 - axis]\n353     mat = X.tocsc() if axis == 0 else X.tocsr()\n354     mat.sum_duplicates()\n355     major_index, value = _minor_reduce(mat, min_or_max)\n356     not_full = np.diff(mat.indptr)[major_index] < N\n357     value[not_full] = min_or_max(value[not_full], 0)\n358     mask = value != 0\n359     major_index = np.compress(mask, major_index)\n360     value = np.compress(mask, value)\n361 \n362     if axis == 0:\n363         res = sp.coo_matrix((value, (np.zeros(len(value)), major_index)),\n364                             dtype=X.dtype, shape=(1, M))\n365     else:\n366         res = sp.coo_matrix((value, (major_index, np.zeros(len(value)))),\n367                             dtype=X.dtype, shape=(M, 1))\n368     return res.A.ravel()\n",
        "intended_behavior": "The method should safely and efficiently compute the minimum or maximum values along a specified axis of a sparse matrix. To resolve the issue, the method needs to be adjusted to handle `indptr` arrays with `dtype=int64` on 32-bit systems without causing a `TypeError`. This could involve ensuring any operations that involve `indptr` explicitly check and handle the `dtype` in a manner that's compatible with both 32-bit and 64-bit systems. For example, if the computation requires indexing with `indptr`, it might be necessary to safely cast `indptr` to `int32` when on a 32-bit system, but only if it can be done without losing data (i.e., the indices actually fit in an `int32`). Additionally, care must be taken to avoid changing the behavior for systems where `int64` indices are already handled correctly."
    },
    {
        "rel_file_path": "sklearn/utils/sparsefuncs.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.21/sklearn/utils/sparsefuncs.py",
        "start": 371,
        "end": 387,
        "class_name": null,
        "method_name": "_sparse_min_or_max",
        "code": "371 def _sparse_min_or_max(X, axis, min_or_max):\n372     if axis is None:\n373         if 0 in X.shape:\n374             raise ValueError(\"zero-size array to reduction operation\")\n375         zero = X.dtype.type(0)\n376         if X.nnz == 0:\n377             return zero\n378         m = min_or_max.reduce(X.data.ravel())\n379         if X.nnz != np.product(X.shape):\n380             m = min_or_max(zero, m)\n381         return m\n382     if axis < 0:\n383         axis += 2\n384     if (axis == 0) or (axis == 1):\n385         return _min_or_max_axis(X, axis, min_or_max)\n386     else:\n387         raise ValueError(\"invalid axis, use 0 for rows, or 1 for columns\")\n",
        "intended_behavior": "This function is responsible for delegating the `min` or `max` operation to the appropriate handler based on the axis specified. To address the bug, the function must ensure that any handling or manipulation of `indptr` is performed safely, respecting the dtype of `indptr` and the operating system's architecture. This might involve verifying and adjusting the dtype of `indptr` before performing operations that could lead to unsafe casting. Specifically, in operations that could raise a `TypeError` due to dtype mismatch, the code should include checks or conversions that safely accommodate `int64` `indptr` on a 32-bit system without affecting the logic for systems that do not exhibit this issue."
    }
]