[
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/views/main.py",
        "start": 1,
        "end": 509,
        "class_name": null,
        "method_name": null,
        "code": "1 from datetime import datetime, timedelta\n2 \n3 from django import forms\n4 from django.conf import settings\n5 from django.contrib import messages\n6 from django.contrib.admin import FieldListFilter\n7 from django.contrib.admin.exceptions import (\n8     DisallowedModelAdminLookup, DisallowedModelAdminToField,\n9 )\n10 from django.contrib.admin.options import (\n11     IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,\n12 )\n13 from django.contrib.admin.utils import (\n14     get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,\n15 )\n16 from django.core.exceptions import (\n17     FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,\n18 )\n19 from django.core.paginator import InvalidPage\n20 from django.db.models import F, Field, ManyToOneRel, OrderBy\n21 from django.db.models.expressions import Combinable\n22 from django.urls import reverse\n23 from django.utils.http import urlencode\n24 from django.utils.timezone import make_aware\n25 from django.utils.translation import gettext\n26 \n27 # Changelist settings\n28 ALL_VAR = 'all'\n29 ORDER_VAR = 'o'\n30 ORDER_TYPE_VAR = 'ot'\n31 PAGE_VAR = 'p'\n32 SEARCH_VAR = 'q'\n33 ERROR_FLAG = 'e'\n34 \n35 IGNORED_PARAMS = (\n36     ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)\n37 \n38 \n39 class ChangeListSearchForm(forms.Form):\n40     def __init__(self, *args, **kwargs):\n41         super().__init__(*args, **kwargs)\n42         # Populate \"fields\" dynamically because SEARCH_VAR is a variable:\n43         self.fields = {\n44             SEARCH_VAR: forms.CharField(required=False, strip=False),\n45         }\n46 \n47 \n48 class ChangeList:\n49     search_form_class = ChangeListSearchForm\n50 \n51     def __init__(self, request, model, list_display, list_display_links,\n52                  list_filter, date_hierarchy, search_fields, list_select_related,\n53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):\n54         self.model = model\n55         self.opts = model._meta\n56         self.lookup_opts = self.opts\n57         self.root_queryset = model_admin.get_queryset(request)\n58         self.list_display = list_display\n59         self.list_display_links = list_display_links\n60         self.list_filter = list_filter\n61         self.has_filters = None\n62         self.date_hierarchy = date_hierarchy\n63         self.search_fields = search_fields\n64         self.list_select_related = list_select_related\n65         self.list_per_page = list_per_page\n66         self.list_max_show_all = list_max_show_all\n67         self.model_admin = model_admin\n68         self.preserved_filters = model_admin.get_preserved_filters(request)\n69         self.sortable_by = sortable_by\n70 \n71         # Get search parameters from the query string.\n72         _search_form = self.search_form_class(request.GET)\n73         if not _search_form.is_valid():\n74             for error in _search_form.errors.values():\n75                 messages.error(request, ', '.join(error))\n76         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''\n77         try:\n78             self.page_num = int(request.GET.get(PAGE_VAR, 0))\n79         except ValueError:\n80             self.page_num = 0\n81         self.show_all = ALL_VAR in request.GET\n82         self.is_popup = IS_POPUP_VAR in request.GET\n83         to_field = request.GET.get(TO_FIELD_VAR)\n84         if to_field and not model_admin.to_field_allowed(request, to_field):\n85             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n86         self.to_field = to_field\n87         self.params = dict(request.GET.items())\n88         if PAGE_VAR in self.params:\n89             del self.params[PAGE_VAR]\n90         if ERROR_FLAG in self.params:\n91             del self.params[ERROR_FLAG]\n92 \n93         if self.is_popup:\n94             self.list_editable = ()\n95         else:\n96             self.list_editable = list_editable\n97         self.queryset = self.get_queryset(request)\n98         self.get_results(request)\n99         if self.is_popup:\n100             title = gettext('Select %s')\n101         elif self.model_admin.has_change_permission(request):\n102             title = gettext('Select %s to change')\n103         else:\n104             title = gettext('Select %s to view')\n105         self.title = title % self.opts.verbose_name\n106         self.pk_attname = self.lookup_opts.pk.attname\n107 \n108     def get_filters_params(self, params=None):\n109         \"\"\"\n110         Return all params except IGNORED_PARAMS.\n111         \"\"\"\n112         params = params or self.params\n113         lookup_params = params.copy()  # a dictionary of the query string\n114         # Remove all the parameters that are globally and systematically\n115         # ignored.\n116         for ignored in IGNORED_PARAMS:\n117             if ignored in lookup_params:\n118                 del lookup_params[ignored]\n119         return lookup_params\n120 \n121     def get_filters(self, request):\n122         lookup_params = self.get_filters_params()\n123         use_distinct = False\n124 \n125         for key, value in lookup_params.items():\n126             if not self.model_admin.lookup_allowed(key, value):\n127                 raise DisallowedModelAdminLookup(\"Filtering by %s not allowed\" % key)\n128 \n129         filter_specs = []\n130         for list_filter in self.list_filter:\n131             if callable(list_filter):\n132                 # This is simply a custom list filter class.\n133                 spec = list_filter(request, lookup_params, self.model, self.model_admin)\n134             else:\n135                 field_path = None\n136                 if isinstance(list_filter, (tuple, list)):\n137                     # This is a custom FieldListFilter class for a given field.\n138                     field, field_list_filter_class = list_filter\n139                 else:\n140                     # This is simply a field name, so use the default\n141                     # FieldListFilter class that has been registered for the\n142                     # type of the given field.\n143                     field, field_list_filter_class = list_filter, FieldListFilter.create\n144                 if not isinstance(field, Field):\n145                     field_path = field\n146                     field = get_fields_from_path(self.model, field_path)[-1]\n147 \n148                 lookup_params_count = len(lookup_params)\n149                 spec = field_list_filter_class(\n150                     field, request, lookup_params,\n151                     self.model, self.model_admin, field_path=field_path,\n152                 )\n153                 # field_list_filter_class removes any lookup_params it\n154                 # processes. If that happened, check if distinct() is needed to\n155                 # remove duplicate results.\n156                 if lookup_params_count > len(lookup_params):\n157                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)\n158             if spec and spec.has_output():\n159                 filter_specs.append(spec)\n160 \n161         if self.date_hierarchy:\n162             # Create bounded lookup parameters so that the query is more\n163             # efficient.\n164             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)\n165             if year is not None:\n166                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)\n167                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)\n168                 try:\n169                     from_date = datetime(\n170                         int(year),\n171                         int(month if month is not None else 1),\n172                         int(day if day is not None else 1),\n173                     )\n174                 except ValueError as e:\n175                     raise IncorrectLookupParameters(e) from e\n176                 if day:\n177                     to_date = from_date + timedelta(days=1)\n178                 elif month:\n179                     # In this branch, from_date will always be the first of a\n180                     # month, so advancing 32 days gives the next month.\n181                     to_date = (from_date + timedelta(days=32)).replace(day=1)\n182                 else:\n183                     to_date = from_date.replace(year=from_date.year + 1)\n184                 if settings.USE_TZ:\n185                     from_date = make_aware(from_date)\n186                     to_date = make_aware(to_date)\n187                 lookup_params.update({\n188                     '%s__gte' % self.date_hierarchy: from_date,\n189                     '%s__lt' % self.date_hierarchy: to_date,\n190                 })\n191 \n192         # At this point, all the parameters used by the various ListFilters\n193         # have been removed from lookup_params, which now only contains other\n194         # parameters passed via the query string. We now loop through the\n195         # remaining parameters both to ensure that all the parameters are valid\n196         # fields and to determine if at least one of them needs distinct(). If\n197         # the lookup parameters aren't real fields, then bail out.\n198         try:\n199             for key, value in lookup_params.items():\n200                 lookup_params[key] = prepare_lookup_value(key, value)\n201                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)\n202             return filter_specs, bool(filter_specs), lookup_params, use_distinct\n203         except FieldDoesNotExist as e:\n204             raise IncorrectLookupParameters(e) from e\n205 \n206     def get_query_string(self, new_params=None, remove=None):\n207         if new_params is None:\n208             new_params = {}\n209         if remove is None:\n210             remove = []\n211         p = self.params.copy()\n212         for r in remove:\n213             for k in list(p):\n214                 if k.startswith(r):\n215                     del p[k]\n216         for k, v in new_params.items():\n217             if v is None:\n218                 if k in p:\n219                     del p[k]\n220             else:\n221                 p[k] = v\n222         return '?%s' % urlencode(sorted(p.items()))\n223 \n224     def get_results(self, request):\n225         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)\n226         # Get the number of objects, with admin filters applied.\n227         result_count = paginator.count\n228 \n229         # Get the total number of objects, with no admin filters applied.\n230         if self.model_admin.show_full_result_count:\n231             full_result_count = self.root_queryset.count()\n232         else:\n233             full_result_count = None\n234         can_show_all = result_count <= self.list_max_show_all\n235         multi_page = result_count > self.list_per_page\n236 \n237         # Get the list of objects to display on this page.\n238         if (self.show_all and can_show_all) or not multi_page:\n239             result_list = self.queryset._clone()\n240         else:\n241             try:\n242                 result_list = paginator.page(self.page_num + 1).object_list\n243             except InvalidPage:\n244                 raise IncorrectLookupParameters\n245 \n246         self.result_count = result_count\n247         self.show_full_result_count = self.model_admin.show_full_result_count\n248         # Admin actions are shown if there is at least one entry\n249         # or if entries are not counted because show_full_result_count is disabled\n250         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)\n251         self.full_result_count = full_result_count\n252         self.result_list = result_list\n253         self.can_show_all = can_show_all\n254         self.multi_page = multi_page\n255         self.paginator = paginator\n256 \n257     def _get_default_ordering(self):\n258         ordering = []\n259         if self.model_admin.ordering:\n260             ordering = self.model_admin.ordering\n261         elif self.lookup_opts.ordering:\n262             ordering = self.lookup_opts.ordering\n263         return ordering\n264 \n265     def get_ordering_field(self, field_name):\n266         \"\"\"\n267         Return the proper model field name corresponding to the given\n268         field_name to use for ordering. field_name may either be the name of a\n269         proper model field or the name of a method (on the admin or model) or a\n270         callable with the 'admin_order_field' attribute. Return None if no\n271         proper model field name can be matched.\n272         \"\"\"\n273         try:\n274             field = self.lookup_opts.get_field(field_name)\n275             return field.name\n276         except FieldDoesNotExist:\n277             # See whether field_name is a name of a non-field\n278             # that allows sorting.\n279             if callable(field_name):\n280                 attr = field_name\n281             elif hasattr(self.model_admin, field_name):\n282                 attr = getattr(self.model_admin, field_name)\n283             else:\n284                 attr = getattr(self.model, field_name)\n285             if isinstance(attr, property) and hasattr(attr, 'fget'):\n286                 attr = attr.fget\n287             return getattr(attr, 'admin_order_field', None)\n288 \n289     def get_ordering(self, request, queryset):\n290         \"\"\"\n291         Return the list of ordering fields for the change list.\n292         First check the get_ordering() method in model admin, then check\n293         the object's default ordering. Then, any manually-specified ordering\n294         from the query string overrides anything. Finally, a deterministic\n295         order is guaranteed by calling _get_deterministic_ordering() with the\n296         constructed ordering.\n297         \"\"\"\n298         params = self.params\n299         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())\n300         if ORDER_VAR in params:\n301             # Clear ordering and used params\n302             ordering = []\n303             order_params = params[ORDER_VAR].split('.')\n304             for p in order_params:\n305                 try:\n306                     none, pfx, idx = p.rpartition('-')\n307                     field_name = self.list_display[int(idx)]\n308                     order_field = self.get_ordering_field(field_name)\n309                     if not order_field:\n310                         continue  # No 'admin_order_field', skip it\n311                     if isinstance(order_field, OrderBy):\n312                         if pfx == '-':\n313                             order_field = order_field.copy()\n314                             order_field.reverse_ordering()\n315                         ordering.append(order_field)\n316                     elif hasattr(order_field, 'resolve_expression'):\n317                         # order_field is an expression.\n318                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())\n319                     # reverse order if order_field has already \"-\" as prefix\n320                     elif order_field.startswith('-') and pfx == '-':\n321                         ordering.append(order_field[1:])\n322                     else:\n323                         ordering.append(pfx + order_field)\n324                 except (IndexError, ValueError):\n325                     continue  # Invalid ordering specified, skip it.\n326 \n327         # Add the given query's ordering fields, if any.\n328         ordering.extend(queryset.query.order_by)\n329 \n330         return self._get_deterministic_ordering(ordering)\n331 \n332     def _get_deterministic_ordering(self, ordering):\n333         \"\"\"\n334         Ensure a deterministic order across all database backends. Search for a\n335         single field or unique together set of fields providing a total\n336         ordering. If these are missing, augment the ordering with a descendant\n337         primary key.\n338         \"\"\"\n339         ordering = list(ordering)\n340         ordering_fields = set()\n341         total_ordering_fields = {'pk'} | {\n342             field.attname for field in self.lookup_opts.fields\n343             if field.unique and not field.null\n344         }\n345         for part in ordering:\n346             # Search for single field providing a total ordering.\n347             field_name = None\n348             if isinstance(part, str):\n349                 field_name = part.lstrip('-')\n350             elif isinstance(part, F):\n351                 field_name = part.name\n352             elif isinstance(part, OrderBy) and isinstance(part.expression, F):\n353                 field_name = part.expression.name\n354             if field_name:\n355                 # Normalize attname references by using get_field().\n356                 try:\n357                     field = self.lookup_opts.get_field(field_name)\n358                 except FieldDoesNotExist:\n359                     # Could be \"?\" for random ordering or a related field\n360                     # lookup. Skip this part of introspection for now.\n361                     continue\n362                 # Ordering by a related field name orders by the referenced\n363                 # model's ordering. Skip this part of introspection for now.\n364                 if field.remote_field and field_name == field.name:\n365                     continue\n366                 if field.attname in total_ordering_fields:\n367                     break\n368                 ordering_fields.add(field.attname)\n369         else:\n370             # No single total ordering field, try unique_together and total\n371             # unique constraints.\n372             constraint_field_names = (\n373                 *self.lookup_opts.unique_together,\n374                 *(\n375                     constraint.fields\n376                     for constraint in self.lookup_opts.total_unique_constraints\n377                 ),\n378             )\n379             for field_names in constraint_field_names:\n380                 # Normalize attname references by using get_field().\n381                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]\n382                 # Composite unique constraints containing a nullable column\n383                 # cannot ensure total ordering.\n384                 if any(field.null for field in fields):\n385                     continue\n386                 if ordering_fields.issuperset(field.attname for field in fields):\n387                     break\n388             else:\n389                 # If no set of unique fields is present in the ordering, rely\n390                 # on the primary key to provide total ordering.\n391                 ordering.append('-pk')\n392         return ordering\n393 \n394     def get_ordering_field_columns(self):\n395         \"\"\"\n396         Return a dictionary of ordering field column numbers and asc/desc.\n397         \"\"\"\n398         # We must cope with more than one column having the same underlying sort\n399         # field, so we base things on column numbers.\n400         ordering = self._get_default_ordering()\n401         ordering_fields = {}\n402         if ORDER_VAR not in self.params:\n403             # for ordering specified on ModelAdmin or model Meta, we don't know\n404             # the right column numbers absolutely, because there might be more\n405             # than one column associated with that ordering, so we guess.\n406             for field in ordering:\n407                 if isinstance(field, (Combinable, OrderBy)):\n408                     if not isinstance(field, OrderBy):\n409                         field = field.asc()\n410                     if isinstance(field.expression, F):\n411                         order_type = 'desc' if field.descending else 'asc'\n412                         field = field.expression.name\n413                     else:\n414                         continue\n415                 elif field.startswith('-'):\n416                     field = field[1:]\n417                     order_type = 'desc'\n418                 else:\n419                     order_type = 'asc'\n420                 for index, attr in enumerate(self.list_display):\n421                     if self.get_ordering_field(attr) == field:\n422                         ordering_fields[index] = order_type\n423                         break\n424         else:\n425             for p in self.params[ORDER_VAR].split('.'):\n426                 none, pfx, idx = p.rpartition('-')\n427                 try:\n428                     idx = int(idx)\n429                 except ValueError:\n430                     continue  # skip it\n431                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'\n432         return ordering_fields\n433 \n434     def get_queryset(self, request):\n435         # First, we collect all the declared list filters.\n436         (self.filter_specs, self.has_filters, remaining_lookup_params,\n437          filters_use_distinct) = self.get_filters(request)\n438 \n439         # Then, we let every list filter modify the queryset to its liking.\n440         qs = self.root_queryset\n441         for filter_spec in self.filter_specs:\n442             new_qs = filter_spec.queryset(request, qs)\n443             if new_qs is not None:\n444                 qs = new_qs\n445 \n446         try:\n447             # Finally, we apply the remaining lookup parameters from the query\n448             # string (i.e. those that haven't already been processed by the\n449             # filters).\n450             qs = qs.filter(**remaining_lookup_params)\n451         except (SuspiciousOperation, ImproperlyConfigured):\n452             # Allow certain types of errors to be re-raised as-is so that the\n453             # caller can treat them in a special way.\n454             raise\n455         except Exception as e:\n456             # Every other error is caught with a naked except, because we don't\n457             # have any other way of validating lookup parameters. They might be\n458             # invalid if the keyword arguments are incorrect, or if the values\n459             # are not in the correct type, so we might get FieldError,\n460             # ValueError, ValidationError, or ?.\n461             raise IncorrectLookupParameters(e)\n462 \n463         if not qs.query.select_related:\n464             qs = self.apply_select_related(qs)\n465 \n466         # Set ordering.\n467         ordering = self.get_ordering(request, qs)\n468         qs = qs.order_by(*ordering)\n469 \n470         # Apply search results\n471         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)\n472 \n473         # Remove duplicates from results, if necessary\n474         if filters_use_distinct | search_use_distinct:\n475             return qs.distinct()\n476         else:\n477             return qs\n478 \n479     def apply_select_related(self, qs):\n480         if self.list_select_related is True:\n481             return qs.select_related()\n482 \n483         if self.list_select_related is False:\n484             if self.has_related_field_in_list_display():\n485                 return qs.select_related()\n486 \n487         if self.list_select_related:\n488             return qs.select_related(*self.list_select_related)\n489         return qs\n490 \n491     def has_related_field_in_list_display(self):\n492         for field_name in self.list_display:\n493             try:\n494                 field = self.lookup_opts.get_field(field_name)\n495             except FieldDoesNotExist:\n496                 pass\n497             else:\n498                 if isinstance(field.remote_field, ManyToOneRel):\n499                     # <FK>_id field names don't require a join.\n500                     if field_name != field.get_attname():\n501                         return True\n502         return False\n503 \n504     def url_for_result(self, result):\n505         pk = getattr(result, self.pk_attname)\n506         return reverse('admin:%s_%s_change' % (self.opts.app_label,\n507                                                self.opts.model_name),\n508                        args=(quote(pk),),\n509                        current_app=self.model_admin.admin_site.name)\n",
        "intended_behavior": "The code in this file responsible for handling date hierarchies needs to be adjusted so that it accounts for user-specific timezones when determining the start and end of the month. This means ensuring that when filtering by month, the calculation of date boundaries (e.g., the first and last day of the month) should consider the user's timezone. Any logic that computes these boundaries must correctly translate dates to avoid including days from the adjacent month due to timezone offsets. Importantly, this fix must preserve existing functionality for users in the UTC timezone or when timezone support is disabled, ensuring backward compatibility."
    },
    {
        "rel_file_path": "django/utils/timezone.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/utils/timezone.py",
        "start": 1,
        "end": 251,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Timezone-related classes and functions.\n3 \"\"\"\n4 \n5 import functools\n6 from contextlib import ContextDecorator\n7 from datetime import datetime, timedelta, timezone, tzinfo\n8 \n9 import pytz\n10 from asgiref.local import Local\n11 \n12 from django.conf import settings\n13 \n14 __all__ = [\n15     'utc', 'get_fixed_timezone',\n16     'get_default_timezone', 'get_default_timezone_name',\n17     'get_current_timezone', 'get_current_timezone_name',\n18     'activate', 'deactivate', 'override',\n19     'localtime', 'now',\n20     'is_aware', 'is_naive', 'make_aware', 'make_naive',\n21 ]\n22 \n23 \n24 # UTC time zone as a tzinfo instance.\n25 utc = pytz.utc\n26 \n27 \n28 def get_fixed_timezone(offset):\n29     \"\"\"Return a tzinfo instance with a fixed offset from UTC.\"\"\"\n30     if isinstance(offset, timedelta):\n31         offset = offset.total_seconds() // 60\n32     sign = '-' if offset < 0 else '+'\n33     hhmm = '%02d%02d' % divmod(abs(offset), 60)\n34     name = sign + hhmm\n35     return timezone(timedelta(minutes=offset), name)\n36 \n37 \n38 # In order to avoid accessing settings at compile time,\n39 # wrap the logic in a function and cache the result.\n40 @functools.lru_cache()\n41 def get_default_timezone():\n42     \"\"\"\n43     Return the default time zone as a tzinfo instance.\n44 \n45     This is the time zone defined by settings.TIME_ZONE.\n46     \"\"\"\n47     return pytz.timezone(settings.TIME_ZONE)\n48 \n49 \n50 # This function exists for consistency with get_current_timezone_name\n51 def get_default_timezone_name():\n52     \"\"\"Return the name of the default time zone.\"\"\"\n53     return _get_timezone_name(get_default_timezone())\n54 \n55 \n56 _active = Local()\n57 \n58 \n59 def get_current_timezone():\n60     \"\"\"Return the currently active time zone as a tzinfo instance.\"\"\"\n61     return getattr(_active, \"value\", get_default_timezone())\n62 \n63 \n64 def get_current_timezone_name():\n65     \"\"\"Return the name of the currently active time zone.\"\"\"\n66     return _get_timezone_name(get_current_timezone())\n67 \n68 \n69 def _get_timezone_name(timezone):\n70     \"\"\"Return the name of ``timezone``.\"\"\"\n71     return timezone.tzname(None)\n72 \n73 # Timezone selection functions.\n74 \n75 # These functions don't change os.environ['TZ'] and call time.tzset()\n76 # because it isn't thread safe.\n77 \n78 \n79 def activate(timezone):\n80     \"\"\"\n81     Set the time zone for the current thread.\n82 \n83     The ``timezone`` argument must be an instance of a tzinfo subclass or a\n84     time zone name.\n85     \"\"\"\n86     if isinstance(timezone, tzinfo):\n87         _active.value = timezone\n88     elif isinstance(timezone, str):\n89         _active.value = pytz.timezone(timezone)\n90     else:\n91         raise ValueError(\"Invalid timezone: %r\" % timezone)\n92 \n93 \n94 def deactivate():\n95     \"\"\"\n96     Unset the time zone for the current thread.\n97 \n98     Django will then use the time zone defined by settings.TIME_ZONE.\n99     \"\"\"\n100     if hasattr(_active, \"value\"):\n101         del _active.value\n102 \n103 \n104 class override(ContextDecorator):\n105     \"\"\"\n106     Temporarily set the time zone for the current thread.\n107 \n108     This is a context manager that uses django.utils.timezone.activate()\n109     to set the timezone on entry and restores the previously active timezone\n110     on exit.\n111 \n112     The ``timezone`` argument must be an instance of a ``tzinfo`` subclass, a\n113     time zone name, or ``None``. If it is ``None``, Django enables the default\n114     time zone.\n115     \"\"\"\n116     def __init__(self, timezone):\n117         self.timezone = timezone\n118 \n119     def __enter__(self):\n120         self.old_timezone = getattr(_active, 'value', None)\n121         if self.timezone is None:\n122             deactivate()\n123         else:\n124             activate(self.timezone)\n125 \n126     def __exit__(self, exc_type, exc_value, traceback):\n127         if self.old_timezone is None:\n128             deactivate()\n129         else:\n130             _active.value = self.old_timezone\n131 \n132 \n133 # Templates\n134 \n135 def template_localtime(value, use_tz=None):\n136     \"\"\"\n137     Check if value is a datetime and converts it to local time if necessary.\n138 \n139     If use_tz is provided and is not None, that will force the value to\n140     be converted (or not), overriding the value of settings.USE_TZ.\n141 \n142     This function is designed for use by the template engine.\n143     \"\"\"\n144     should_convert = (\n145         isinstance(value, datetime) and\n146         (settings.USE_TZ if use_tz is None else use_tz) and\n147         not is_naive(value) and\n148         getattr(value, 'convert_to_local_time', True)\n149     )\n150     return localtime(value) if should_convert else value\n151 \n152 \n153 # Utilities\n154 \n155 def localtime(value=None, timezone=None):\n156     \"\"\"\n157     Convert an aware datetime.datetime to local time.\n158 \n159     Only aware datetimes are allowed. When value is omitted, it defaults to\n160     now().\n161 \n162     Local time is defined by the current time zone, unless another time zone\n163     is specified.\n164     \"\"\"\n165     if value is None:\n166         value = now()\n167     if timezone is None:\n168         timezone = get_current_timezone()\n169     # Emulate the behavior of astimezone() on Python < 3.6.\n170     if is_naive(value):\n171         raise ValueError(\"localtime() cannot be applied to a naive datetime\")\n172     return value.astimezone(timezone)\n173 \n174 \n175 def localdate(value=None, timezone=None):\n176     \"\"\"\n177     Convert an aware datetime to local time and return the value's date.\n178 \n179     Only aware datetimes are allowed. When value is omitted, it defaults to\n180     now().\n181 \n182     Local time is defined by the current time zone, unless another time zone is\n183     specified.\n184     \"\"\"\n185     return localtime(value, timezone).date()\n186 \n187 \n188 def now():\n189     \"\"\"\n190     Return an aware or naive datetime.datetime, depending on settings.USE_TZ.\n191     \"\"\"\n192     if settings.USE_TZ:\n193         # timeit shows that datetime.now(tz=utc) is 24% slower\n194         return datetime.utcnow().replace(tzinfo=utc)\n195     else:\n196         return datetime.now()\n197 \n198 \n199 # By design, these four functions don't perform any checks on their arguments.\n200 # The caller should ensure that they don't receive an invalid value like None.\n201 \n202 def is_aware(value):\n203     \"\"\"\n204     Determine if a given datetime.datetime is aware.\n205 \n206     The concept is defined in Python's docs:\n207     https://docs.python.org/library/datetime.html#datetime.tzinfo\n208 \n209     Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n210     value.utcoffset() implements the appropriate logic.\n211     \"\"\"\n212     return value.utcoffset() is not None\n213 \n214 \n215 def is_naive(value):\n216     \"\"\"\n217     Determine if a given datetime.datetime is naive.\n218 \n219     The concept is defined in Python's docs:\n220     https://docs.python.org/library/datetime.html#datetime.tzinfo\n221 \n222     Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n223     value.utcoffset() implements the appropriate logic.\n224     \"\"\"\n225     return value.utcoffset() is None\n226 \n227 \n228 def make_aware(value, timezone=None, is_dst=None):\n229     \"\"\"Make a naive datetime.datetime in a given time zone aware.\"\"\"\n230     if timezone is None:\n231         timezone = get_current_timezone()\n232     if hasattr(timezone, 'localize'):\n233         # This method is available for pytz time zones.\n234         return timezone.localize(value, is_dst=is_dst)\n235     else:\n236         # Check that we won't overwrite the timezone of an aware datetime.\n237         if is_aware(value):\n238             raise ValueError(\n239                 \"make_aware expects a naive datetime, got %s\" % value)\n240         # This may be wrong around DST changes!\n241         return value.replace(tzinfo=timezone)\n242 \n243 \n244 def make_naive(value, timezone=None):\n245     \"\"\"Make an aware datetime.datetime naive in a given time zone.\"\"\"\n246     if timezone is None:\n247         timezone = get_current_timezone()\n248     # Emulate the behavior of astimezone() on Python < 3.6.\n249     if is_naive(value):\n250         raise ValueError(\"make_naive() cannot be applied to a naive datetime\")\n251     return value.astimezone(timezone).replace(tzinfo=None)\n",
        "intended_behavior": "Ensure that this utility file's functions, which are likely used across the admin interface for timezone adjustments, accurately handle the conversion of dates to and from the user's timezone in a way that does not inadvertently shift dates across month boundaries. As this file contains timezone utilities used throughout Django, the modifications here should be made cautiously to ensure that changes do not adversely affect other parts of the framework. It should offer a reliable way to perform date boundary calculations that are sensitive to the timezone, perhaps by providing utility functions specifically designed to calculate start and end dates of months within the correct timezone context."
    }
]