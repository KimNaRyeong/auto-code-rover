2025-10-16 02:52:55.069 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 02:53:04.425 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=488, output_tokens=12, cost=0.005240
2025-10-16 02:53:04.426 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-16 02:53:04.429 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:53:12.295 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=621, output_tokens=290, cost=0.014910
2025-10-16 02:53:12.299 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:53:14.687 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=644, output_tokens=82, cost=0.008900
2025-10-16 02:53:14.688 | DEBUG    | Extracted a valid json.
2025-10-16 02:53:14.688 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"OneMatrix\")",
        "search_class(\"ZeroMatrix\")",
        "search_class(\"Identity\")",
        "search_code(\"str printer\")",
        "search_code(\"pretty printer\")",
        "search_code(\"MathML presentation printer\")",
        "search_code(\"unicode double struck characters\")"
    ],
    "bug_locations": []
}
2025-10-16 02:53:14.841 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:53:14.841 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:53:33.933 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1963, output_tokens=813, cost=0.044020
2025-10-16 02:53:33.946 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:53:45.067 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2992, output_tokens=494, cost=0.044740
2025-10-16 02:53:45.078 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:53:54.497 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=848, output_tokens=362, cost=0.019340
2025-10-16 02:53:54.499 | DEBUG    | Extracted a valid json.
2025-10-16 02:53:54.499 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"MathML\")", "search_code_in_file(\"unicode\", \"sympy/printing/pretty.py\")"],
    "bug_locations": [
        {
            "file": "sympy/matrices/expressions/matexpr.py",
            "class": "OneMatrix",
            "method": "",
            "intended_behavior": "Implement or ensure that methods relevant to printing, such as `__str__`, `_pretty`, and any MathML related method, are either appropriately defined or overridden in the `OneMatrix` class so that they can present `OneMatrix` instances using the specified unicode double struck characters or MathML presentation tags. This should be done while ensuring that existing functionality, such as matrix operations and shape definitions, remains unaffected."
        },
        {
            "file": "sympy/matrices/expressions/matexpr.py",
            "class": "ZeroMatrix",
            "method": "",
            "intended_behavior": "Similar to `OneMatrix`, ensure that printing methods in the `ZeroMatrix` class can output representations using improved unicode or MathML formatting. It's especially important for the zero matrix to be easily distinguishable and to adhere to the aesthetic improvements suggested by the issue for better visual distinction."
        },
        {
            "file": "sympy/matrices/expressions/matexpr.py",
            "class": "Identity",
            "method": "",
            "intended_behavior": "Ensure that `Identity` matrices are printed in a way that clearly distinguishes them as identity matrices, possibly using the proposed unicode double struck characters. Like with `OneMatrix` and `ZeroMatrix`, this should not interfere with the essential functionalities of identity matrices but should only enhance their presentation."
        }
    ]
}
2025-10-16 02:53:54.740 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 02:53:54.741 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 02:54:09.304 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3723, output_tokens=590, cost=0.054930
2025-10-16 02:54:09.310 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 02:54:18.291 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4529, output_tokens=401, cost=0.057320
2025-10-16 02:54:18.295 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 02:54:25.698 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=755, output_tokens=273, cost=0.015740
2025-10-16 02:54:25.699 | DEBUG    | Extracted a valid json.
2025-10-16 02:54:25.699 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/mathml.py",
            "class": "",
            "method": "",
            "intended_behavior": "Extend the existing MathML printing support to include custom handling for `OneMatrix`, `ZeroMatrix`, and `Identity` classes. This includes defining appropriate MathML elements and attributes that accurately represent these special matrices. The goal here is to ensure that these matrices are distinguishable and correctly represented within MathML outputs, facilitating improved presentation in web environments."
        },
        {
            "file": "sympy/matrices/expressions/matexpr.py",
            "class": "OneMatrix, ZeroMatrix, Identity",
            "method": "",
            "intended_behavior": "While the specific presentation enhancements via unicode pretty printing were not directly identified due to the search limitations, it's assumed that within each of these classes, or perhaps through a common superclass or utility module, methods or functionalities might be added or extended to support improved unicode pretty printing. This could involve specifying unicode representations for these matrices and ensuring that these representations are invoked during the pretty-printing process. The goal is to maintain readability and distinction among `ZeroMatrix`, `Identity`, and `OneMatrix` in non-MathML contexts as well."
        }
    ]
}
2025-10-16 02:54:25.709 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/mathml.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A MathML printer.
3 """
4 
5 from __future__ import print_function, division
6 
7 from sympy import sympify, S, Mul
8 from sympy.core.compatibility import range, string_types, default_sort_key
9 from sympy.core.function import _coeff_isneg
10 from sympy.printing.conventions import split_super_sub, requires_partial
11 from sympy.printing.precedence import precedence_traditional, PRECEDENCE
12 from sympy.printing.pretty.pretty_symbology import greek_unicode
13 from sympy.printing.printer import Printer
14 
15 import mpmath.libmp as mlib
16 from mpmath.libmp import prec_to_dps
17 
18 class MathMLPrinterBase(Printer):
19     """Contains common code required for MathMLContentPrinter and
20     MathMLPresentationPrinter.
21     """
22 
23     _default_settings = {
24         "order": None,
25         "encoding": "utf-8",
26         "fold_frac_powers": False,
27         "fold_func_brackets": False,
28         "fold_short_frac": None,
29         "inv_trig_style": "abbreviated",
30         "ln_notation": False,
31         "long_frac_ratio": None,
32         "mat_delim": "[",
33         "mat_symbol_style": "plain",
34         "mul_symbol": None,
35         "root_notation": True,
36         "symbol_names": {},
37         "mul_symbol_mathml_numbers": '&#xB7;',
38     }
39 
40     def __init__(self, settings=None):
41         Printer.__init__(self, settings)
42         from xml.dom.minidom import Document, Text
43 
44         self.dom = Document()
45 
46         # Workaround to allow strings to remain unescaped
47         # Based on
48         # https://stackoverflow.com/questions/38015864/python-xml-dom-minidom-\
49         #                              please-dont-escape-my-strings/38041194
50         class RawText(Text):
51             def writexml(self, writer, indent='', addindent='', newl=''):
52                 if self.data:
53                     writer.write(u'{}{}{}'.format(indent, self.data, newl))
54 
55         def createRawTextNode(data):
56             r = RawText()
57             r.data = data
58             r.ownerDocument = self.dom
59             return r
60 
61         self.dom.createTextNode = createRawTextNode
62 
63     def doprint(self, expr):
64         """
65         Prints the expression as MathML.
66         """
67         mathML = Printer._print(self, expr)
68         unistr = mathML.toxml()
69         xmlbstr = unistr.encode('ascii', 'xmlcharrefreplace')
70         res = xmlbstr.decode()
71         return res
72 
73     def apply_patch(self):
74         # Applying the patch of xml.dom.minidom bug
75         # Date: 2011-11-18
76         # Description: http://ronrothman.com/public/leftbraned/xml-dom-minidom\
77         #                   -toprettyxml-and-silly-whitespace/#best-solution
78         # Issue: http://bugs.python.org/issue4147
79         # Patch: http://hg.python.org/cpython/rev/7262f8f276ff/
80 
81         from xml.dom.minidom import Element, Text, Node, _write_data
82 
83         def writexml(self, writer, indent="", addindent="", newl=""):
84             # indent = current indentation
85             # addindent = indentation to add to higher levels
86             # newl = newline string
87             writer.write(indent + "<" + self.tagName)
88 
89             attrs = self._get_attributes()
90             a_names = list(attrs.keys())
91             a_names.sort()
92 
93             for a_name in a_names:
94                 writer.write(" %s=\"" % a_name)
95                 _write_data(writer, attrs[a_name].value)
96                 writer.write("\"")
97             if self.childNodes:
98                 writer.write(">")
99                 if (len(self.childNodes) == 1 and
100                         self.childNodes[0].nodeType == Node.TEXT_NODE):
101                     self.childNodes[0].writexml(writer, '', '', '')
102                 else:
103                     writer.write(newl)
104                     for node in self.childNodes:
105                         node.writexml(
106                             writer, indent + addindent, addindent, newl)
107                     writer.write(indent)
108                 writer.write("</%s>%s" % (self.tagName, newl))
109             else:
110                 writer.write("/>%s" % (newl))
111         self._Element_writexml_old = Element.writexml
112         Element.writexml = writexml
113 
114         def writexml(self, writer, indent="", addindent="", newl=""):
115             _write_data(writer, "%s%s%s" % (indent, self.data, newl))
116         self._Text_writexml_old = Text.writexml
117         Text.writexml = writexml
118 
119     def restore_patch(self):
120         from xml.dom.minidom import Element, Text
121         Element.writexml = self._Element_writexml_old
122         Text.writexml = self._Text_writexml_old
123 
124 
125 class MathMLContentPrinter(MathMLPrinterBase):
126     """Prints an expression to the Content MathML markup language.
127 
128     References: https://www.w3.org/TR/MathML2/chapter4.html
129     """
130     printmethod = "_mathml_content"
131 
132     def mathml_tag(self, e):
133         """Returns the MathML tag for an expression."""
134         translate = {
135             'Add': 'plus',
136             'Mul': 'times',
137             'Derivative': 'diff',
138             'Number': 'cn',
139             'int': 'cn',
140             'Pow': 'power',
141             'Symbol': 'ci',
142             'MatrixSymbol': 'ci',
143             'RandomSymbol': 'ci',
144             'Integral': 'int',
145             'Sum': 'sum',
146             'sin': 'sin',
147             'cos': 'cos',
148             'tan': 'tan',
149             'cot': 'cot',
150             'asin': 'arcsin',
151             'asinh': 'arcsinh',
152             'acos': 'arccos',
153             'acosh': 'arccosh',
154             'atan': 'arctan',
155             'atanh': 'arctanh',
156             'acot': 'arccot',
157             'atan2': 'arctan',
158             'log': 'ln',
159             'Equality': 'eq',
160             'Unequality': 'neq',
161             'GreaterThan': 'geq',
162             'LessThan': 'leq',
163             'StrictGreaterThan': 'gt',
164             'StrictLessThan': 'lt',
165         }
166 
167         for cls in e.__class__.__mro__:
168             n = cls.__name__
169             if n in translate:
170                 return translate[n]
171         # Not found in the MRO set
172         n = e.__class__.__name__
173         return n.lower()
174 
175     def _print_Mul(self, expr):
176 
177         if _coeff_isneg(expr):
178             x = self.dom.createElement('apply')
179             x.appendChild(self.dom.createElement('minus'))
180             x.appendChild(self._print_Mul(-expr))
181             return x
182 
183         from sympy.simplify import fraction
184         numer, denom = fraction(expr)
185 
186         if denom is not S.One:
187             x = self.dom.createElement('apply')
188             x.appendChild(self.dom.createElement('divide'))
189             x.appendChild(self._print(numer))
190             x.appendChild(self._print(denom))
191             return x
192 
193         coeff, terms = expr.as_coeff_mul()
194         if coeff is S.One and len(terms) == 1:
195             # XXX since the negative coefficient has been handled, I don't
196             # think a coeff of 1 can remain
197             return self._print(terms[0])
198 
199         if self.order != 'old':
200             terms = Mul._from_args(terms).as_ordered_factors()
201 
202         x = self.dom.createElement('apply')
203         x.appendChild(self.dom.createElement('times'))
204         if coeff != 1:
205             x.appendChild(self._print(coeff))
206         for term in terms:
207             x.appendChild(self._print(term))
208         return x
209 
210     def _print_Add(self, expr, order=None):
211         args = self._as_ordered_terms(expr, order=order)
212         lastProcessed = self._print(args[0])
213         plusNodes = []
214         for arg in args[1:]:
215             if _coeff_isneg(arg):
216                 # use minus
217                 x = self.dom.createElement('apply')
218                 x.appendChild(self.dom.createElement('minus'))
219                 x.appendChild(lastProcessed)
220                 x.appendChild(self._print(-arg))
221                 # invert expression since this is now minused
222                 lastProcessed = x
223                 if arg == args[-1]:
224                     plusNodes.append(lastProcessed)
225             else:
226                 plusNodes.append(lastProcessed)
227                 lastProcessed = self._print(arg)
228                 if arg == args[-1]:
229                     plusNodes.append(self._print(arg))
230         if len(plusNodes) == 1:
231             return lastProcessed
232         x = self.dom.createElement('apply')
233         x.appendChild(self.dom.createElement('plus'))
234         while plusNodes:
235             x.appendChild(plusNodes.pop(0))
236         return x
237 
238     def _print_MatrixBase(self, m):
239         x = self.dom.createElement('matrix')
240         for i in range(m.rows):
241             x_r = self.dom.createElement('matrixrow')
242             for j in range(m.cols):
243                 x_r.appendChild(self._print(m[i, j]))
244             x.appendChild(x_r)
245         return x
246 
247     def _print_Rational(self, e):
248         if e.q == 1:
249             # don't divide
250             x = self.dom.createElement('cn')
251             x.appendChild(self.dom.createTextNode(str(e.p)))
252             return x
253         x = self.dom.createElement('apply')
254         x.appendChild(self.dom.createElement('divide'))
255         # numerator
256         xnum = self.dom.createElement('cn')
257         xnum.appendChild(self.dom.createTextNode(str(e.p)))
258         # denominator
259         xdenom = self.dom.createElement('cn')
260         xdenom.appendChild(self.dom.createTextNode(str(e.q)))
261         x.appendChild(xnum)
262         x.appendChild(xdenom)
263         return x
264 
265     def _print_Limit(self, e):
266         x = self.dom.createElement('apply')
267         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
268 
269         x_1 = self.dom.createElement('bvar')
270         x_2 = self.dom.createElement('lowlimit')
271         x_1.appendChild(self._print(e.args[1]))
272         x_2.appendChild(self._print(e.args[2]))
273 
274         x.appendChild(x_1)
275         x.appendChild(x_2)
276         x.appendChild(self._print(e.args[0]))
277         return x
278 
279     def _print_ImaginaryUnit(self, e):
280         return self.dom.createElement('imaginaryi')
281 
282     def _print_EulerGamma(self, e):
283         return self.dom.createElement('eulergamma')
284 
285     def _print_GoldenRatio(self, e):
286         """We use unicode #x3c6 for Greek letter phi as defined here
287         http://www.w3.org/2003/entities/2007doc/isogrk1.html"""
288         x = self.dom.createElement('cn')
289         x.appendChild(self.dom.createTextNode(u"\N{GREEK SMALL LETTER PHI}"))
290         return x
291 
292     def _print_Exp1(self, e):
293         return self.dom.createElement('exponentiale')
294 
295     def _print_Pi(self, e):
296         return self.dom.createElement('pi')
297 
298     def _print_Infinity(self, e):
299         return self.dom.createElement('infinity')
300 
301     def _print_NegativeInfinity(self, e):
302         x = self.dom.createElement('apply')
303         x.appendChild(self.dom.createElement('minus'))
304         x.appendChild(self.dom.createElement('infinity'))
305         return x
306 
307     def _print_Integral(self, e):
308         def lime_recur(limits):
309             x = self.dom.createElement('apply')
310             x.appendChild(self.dom.createElement(self.mathml_tag(e)))
311             bvar_elem = self.dom.createElement('bvar')
312             bvar_elem.appendChild(self._print(limits[0][0]))
313             x.appendChild(bvar_elem)
314 
315             if len(limits[0]) == 3:
316                 low_elem = self.dom.createElement('lowlimit')
317                 low_elem.appendChild(self._print(limits[0][1]))
318                 x.appendChild(low_elem)
319                 up_elem = self.dom.createElement('uplimit')
320                 up_elem.appendChild(self._print(limits[0][2]))
321                 x.appendChild(up_elem)
322             if len(limits[0]) == 2:
323                 up_elem = self.dom.createElement('uplimit')
324                 up_elem.appendChild(self._print(limits[0][1]))
325                 x.appendChild(up_elem)
326             if len(limits) == 1:
327                 x.appendChild(self._print(e.function))
328             else:
329                 x.appendChild(lime_recur(limits[1:]))
330             return x
331 
332         limits = list(e.limits)
333         limits.reverse()
334         return lime_recur(limits)
335 
336     def _print_Sum(self, e):
337         # Printer can be shared because Sum and Integral have the
338         # same internal representation.
339         return self._print_Integral(e)
340 
341     def _print_Symbol(self, sym):
342         ci = self.dom.createElement(self.mathml_tag(sym))
343 
344         def join(items):
345             if len(items) > 1:
346                 mrow = self.dom.createElement('mml:mrow')
347                 for i, item in enumerate(items):
348                     if i > 0:
349                         mo = self.dom.createElement('mml:mo')
350                         mo.appendChild(self.dom.createTextNode(" "))
351                         mrow.appendChild(mo)
352                     mi = self.dom.createElement('mml:mi')
353                     mi.appendChild(self.dom.createTextNode(item))
354                     mrow.appendChild(mi)
355                 return mrow
356             else:
357                 mi = self.dom.createElement('mml:mi')
358                 mi.appendChild(self.dom.createTextNode(items[0]))
359                 return mi
360 
361         # translate name, supers and subs to unicode characters
362         def translate(s):
363             if s in greek_unicode:
364                 return greek_unicode.get(s)
365             else:
366                 return s
367 
368         name, supers, subs = split_super_sub(sym.name)
369         name = translate(name)
370         supers = [translate(sup) for sup in supers]
371         subs = [translate(sub) for sub in subs]
372 
373         mname = self.dom.createElement('mml:mi')
374         mname.appendChild(self.dom.createTextNode(name))
375         if not supers:
376             if not subs:
377                 ci.appendChild(self.dom.createTextNode(name))
378             else:
379                 msub = self.dom.createElement('mml:msub')
380                 msub.appendChild(mname)
381                 msub.appendChild(join(subs))
382                 ci.appendChild(msub)
383         else:
384             if not subs:
385                 msup = self.dom.createElement('mml:msup')
386                 msup.appendChild(mname)
387                 msup.appendChild(join(supers))
388                 ci.appendChild(msup)
389             else:
390                 msubsup = self.dom.createElement('mml:msubsup')
391                 msubsup.appendChild(mname)
392                 msubsup.appendChild(join(subs))
393                 msubsup.appendChild(join(supers))
394                 ci.appendChild(msubsup)
395         return ci
396 
397     _print_MatrixSymbol = _print_Symbol
398     _print_RandomSymbol = _print_Symbol
399 
400     def _print_Pow(self, e):
401         # Here we use root instead of power if the exponent is the reciprocal
402         # of an integer
403         if (self._settings['root_notation'] and e.exp.is_Rational
404                 and e.exp.p == 1):
405             x = self.dom.createElement('apply')
406             x.appendChild(self.dom.createElement('root'))
407             if e.exp.q != 2:
408                 xmldeg = self.dom.createElement('degree')
409                 xmlci = self.dom.createElement('ci')
410                 xmlci.appendChild(self.dom.createTextNode(str(e.exp.q)))
411                 xmldeg.appendChild(xmlci)
412                 x.appendChild(xmldeg)
413             x.appendChild(self._print(e.base))
414             return x
415 
416         x = self.dom.createElement('apply')
417         x_1 = self.dom.createElement(self.mathml_tag(e))
418         x.appendChild(x_1)
419         x.appendChild(self._print(e.base))
420         x.appendChild(self._print(e.exp))
421         return x
422 
423     def _print_Number(self, e):
424         x = self.dom.createElement(self.mathml_tag(e))
425         x.appendChild(self.dom.createTextNode(str(e)))
426         return x
427 
428     def _print_Derivative(self, e):
429         x = self.dom.createElement('apply')
430         diff_symbol = self.mathml_tag(e)
431         if requires_partial(e):
432             diff_symbol = 'partialdiff'
433         x.appendChild(self.dom.createElement(diff_symbol))
434         x_1 = self.dom.createElement('bvar')
435 
436         for sym, times in reversed(e.variable_count):
437             x_1.appendChild(self._print(sym))
438             if times > 1:
439                 degree = self.dom.createElement('degree')
440                 degree.appendChild(self._print(sympify(times)))
441                 x_1.appendChild(degree)
442 
443         x.appendChild(x_1)
444         x.appendChild(self._print(e.expr))
445         return x
446 
447     def _print_Function(self, e):
448         x = self.dom.createElement("apply")
449         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
450         for arg in e.args:
451             x.appendChild(self._print(arg))
452         return x
453 
454     def _print_Basic(self, e):
455         x = self.dom.createElement(self.mathml_tag(e))
456         for arg in e.args:
457             x.appendChild(self._print(arg))
458         return x
459 
460     def _print_AssocOp(self, e):
461         x = self.dom.createElement('apply')
462         x_1 = self.dom.createElement(self.mathml_tag(e))
463         x.appendChild(x_1)
464         for arg in e.args:
465             x.appendChild(self._print(arg))
466         return x
467 
468     def _print_Relational(self, e):
469         x = self.dom.createElement('apply')
470         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
471         x.appendChild(self._print(e.lhs))
472         x.appendChild(self._print(e.rhs))
473         return x
474 
475     def _print_list(self, seq):
476         """MathML reference for the <list> element:
477         http://www.w3.org/TR/MathML2/chapter4.html#contm.list"""
478         dom_element = self.dom.createElement('list')
479         for item in seq:
480             dom_element.appendChild(self._print(item))
481         return dom_element
482 
483     def _print_int(self, p):
484         dom_element = self.dom.createElement(self.mathml_tag(p))
485         dom_element.appendChild(self.dom.createTextNode(str(p)))
486         return dom_element
487 
488 
489 class MathMLPresentationPrinter(MathMLPrinterBase):
490     """Prints an expression to the Presentation MathML markup language.
491 
492     References: https://www.w3.org/TR/MathML2/chapter3.html
493     """
494     printmethod = "_mathml_presentation"
495 
496     def mathml_tag(self, e):
497         """Returns the MathML tag for an expression."""
498         translate = {
499             'Number': 'mn',
500             'Limit': '&#x2192;',
501             'Derivative': '&dd;',
502             'int': 'mn',
503             'Symbol': 'mi',
504             'Integral': '&int;',
505             'Sum': '&#x2211;',
506             'sin': 'sin',
507             'cos': 'cos',
508             'tan': 'tan',
509             'cot': 'cot',
510             'asin': 'arcsin',
511             'asinh': 'arcsinh',
512             'acos': 'arccos',
513             'acosh': 'arccosh',
514             'atan': 'arctan',
515             'atanh': 'arctanh',
516             'acot': 'arccot',
517             'atan2': 'arctan',
518             'Equality': '=',
519             'Unequality': '&#x2260;',
520             'GreaterThan': '&#x2265;',
521             'LessThan': '&#x2264;',
522             'StrictGreaterThan': '>',
523             'StrictLessThan': '<',
524             'lerchphi': '&#x3A6;',
525             'zeta': '&#x3B6;',
526             'dirichlet_eta': '&#x3B7;',
527             'elliptic_k': '&#x39A;',
528             'lowergamma': '&#x3B3;',
529             'uppergamma': '&#x393;',
530             'gamma': '&#x393;',
531             'totient': '&#x3D5;',
532             'reduced_totient': '&#x3BB;',
533             'primenu': '&#x3BD;',
534             'primeomega': '&#x3A9;',
535             'fresnels': 'S',
536             'fresnelc': 'C',
537             'Heaviside': '&#x398;',
538             'BooleanTrue': 'True',
539             'BooleanFalse': 'False',
540             'NoneType': 'None',
541         }
542 
543         def mul_symbol_selection():
544             if (self._settings["mul_symbol"] is None or
545                     self._settings["mul_symbol"] == 'None'):
546                 return '&InvisibleTimes;'
547             elif self._settings["mul_symbol"] == 'times':
548                 return '&#xD7;'
549             elif self._settings["mul_symbol"] == 'dot':
550                 return '&#xB7;'
551             elif self._settings["mul_symbol"] == 'ldot':
552                 return '&#x2024;'
553             elif not isinstance(self._settings["mul_symbol"], string_types):
554                 raise TypeError
555             else:
556                 return self._settings["mul_symbol"]
557         for cls in e.__class__.__mro__:
558             n = cls.__name__
559             if n in translate:
560                 return translate[n]
561         # Not found in the MRO set
562         if e.__class__.__name__ == "Mul":
563             return mul_symbol_selection()
564         n = e.__class__.__name__
565         return n.lower()
566 
567     def parenthesize(self, item, level, strict=False):
568         prec_val = precedence_traditional(item)
569         if (prec_val < level) or ((not strict) and prec_val <= level):
570             brac = self.dom.createElement('mfenced')
571             brac.appendChild(self._print(item))
572             return brac
573         else:
574             return self._print(item)
575 
576     def _print_Mul(self, expr):
577 
578         def multiply(expr, mrow):
579             from sympy.simplify import fraction
580             numer, denom = fraction(expr)
581             if denom is not S.One:
582                 frac = self.dom.createElement('mfrac')
583                 if self._settings["fold_short_frac"] and len(str(expr)) < 7:
584                     frac.setAttribute('bevelled', 'true')
585                 xnum = self._print(numer)
586                 xden = self._print(denom)
587                 frac.appendChild(xnum)
588                 frac.appendChild(xden)
589                 mrow.appendChild(frac)
590                 return mrow
591 
592             coeff, terms = expr.as_coeff_mul()
593             if coeff is S.One and len(terms) == 1:
594                 mrow.appendChild(self._print(terms[0]))
595                 return mrow
596             if self.order != 'old':
597                 terms = Mul._from_args(terms).as_ordered_factors()
598 
599             if coeff != 1:
600                 x = self._print(coeff)
601                 y = self.dom.createElement('mo')
602                 y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
603                 mrow.appendChild(x)
604                 mrow.appendChild(y)
605             for term in terms:
606                 x = self._print(term)
607                 mrow.appendChild(x)
608                 if not term == terms[-1]:
609                     y = self.dom.createElement('mo')
610                     y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
611                     mrow.appendChild(y)
612             return mrow
613         mrow = self.dom.createElement('mrow')
614         if _coeff_isneg(expr):
615             x = self.dom.createElement('mo')
616             x.appendChild(self.dom.createTextNode('-'))
617             mrow.appendChild(x)
618             mrow = multiply(-expr, mrow)
619         else:
620             mrow = multiply(expr, mrow)
621 
622         return mrow
623 
624     def _print_Add(self, expr, order=None):
625         mrow = self.dom.createElement('mrow')
626         args = self._as_ordered_terms(expr, order=order)
627         mrow.appendChild(self._print(args[0]))
628         for arg in args[1:]:
629             if _coeff_isneg(arg):
630                 # use minus
631                 x = self.dom.createElement('mo')
632                 x.appendChild(self.dom.createTextNode('-'))
633                 y = self._print(-arg)
634                 # invert expression since this is now minused
635             else:
636                 x = self.dom.createElement('mo')
637                 x.appendChild(self.dom.createTextNode('+'))
638                 y = self._print(arg)
639             mrow.appendChild(x)
640             mrow.appendChild(y)
641 
642         return mrow
643 
644     def _print_MatrixBase(self, m):
645         table = self.dom.createElement('mtable')
646         for i in range(m.rows):
647             x = self.dom.createElement('mtr')
648             for j in range(m.cols):
649                 y = self.dom.createElement('mtd')
650                 y.appendChild(self._print(m[i, j]))
651                 x.appendChild(y)
652             table.appendChild(x)
653         if self._settings["mat_delim"] == '':
654             return table
655         brac = self.dom.createElement('mfenced')
656         if self._settings["mat_delim"] == "[":
657             brac.setAttribute('open', '[')
658             brac.setAttribute('close', ']')
659         brac.appendChild(table)
660         return brac
661 
662     def _get_printed_Rational(self, e, folded=None):
663         if e.p < 0:
664             p = -e.p
665         else:
666             p = e.p
667         x = self.dom.createElement('mfrac')
668         if folded or self._settings["fold_short_frac"]:
669             x.setAttribute('bevelled', 'true')
670         x.appendChild(self._print(p))
671         x.appendChild(self._print(e.q))
672         if e.p < 0:
673             mrow = self.dom.createElement('mrow')
674             mo = self.dom.createElement('mo')
675             mo.appendChild(self.dom.createTextNode('-'))
676             mrow.appendChild(mo)
677             mrow.appendChild(x)
678             return mrow
679         else:
680             return x
681 
682     def _print_Rational(self, e):
683         if e.q == 1:
684             # don't divide
685             return self._print(e.p)
686 
687         return self._get_printed_Rational(e, self._settings["fold_short_frac"])
688 
689     def _print_Limit(self, e):
690         mrow = self.dom.createElement('mrow')
691         munder = self.dom.createElement('munder')
692         mi = self.dom.createElement('mi')
693         mi.appendChild(self.dom.createTextNode('lim'))
694 
695         x = self.dom.createElement('mrow')
696         x_1 = self._print(e.args[1])
697         arrow = self.dom.createElement('mo')
698         arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
699         x_2 = self._print(e.args[2])
700         x.appendChild(x_1)
701         x.appendChild(arrow)
702         x.appendChild(x_2)
703 
704         munder.appendChild(mi)
705         munder.appendChild(x)
706         mrow.appendChild(munder)
707         mrow.appendChild(self._print(e.args[0]))
708 
709         return mrow
710 
711     def _print_ImaginaryUnit(self, e):
712         x = self.dom.createElement('mi')
713         x.appendChild(self.dom.createTextNode('&ImaginaryI;'))
714         return x
715 
716     def _print_GoldenRatio(self, e):
717         x = self.dom.createElement('mi')
718         x.appendChild(self.dom.createTextNode('&#x3A6;'))
719         return x
720 
721     def _print_Exp1(self, e):
722         x = self.dom.createElement('mi')
723         x.appendChild(self.dom.createTextNode('&ExponentialE;'))
724         return x
725 
726     def _print_Pi(self, e):
727         x = self.dom.createElement('mi')
728         x.appendChild(self.dom.createTextNode('&pi;'))
729         return x
730 
731     def _print_Infinity(self, e):
732         x = self.dom.createElement('mi')
733         x.appendChild(self.dom.createTextNode('&#x221E;'))
734         return x
735 
736     def _print_NegativeInfinity(self, e):
737         mrow = self.dom.createElement('mrow')
738         y = self.dom.createElement('mo')
739         y.appendChild(self.dom.createTextNode('-'))
740         x = self._print_Infinity(e)
741         mrow.appendChild(y)
742         mrow.appendChild(x)
743         return mrow
744 
745     def _print_Integral(self, expr):
746         intsymbols = {1: "&#x222B;", 2: "&#x222C;", 3: "&#x222D;"}
747 
748         mrow = self.dom.createElement('mrow')
749         if len(expr.limits) <= 3 and all(len(lim) == 1 for lim in expr.limits):
750             # Only up to three-integral signs exists
751             mo = self.dom.createElement('mo')
752             mo.appendChild(self.dom.createTextNode(intsymbols[len(expr.limits)]))
753             mrow.appendChild(mo)
754         else:
755             # Either more than three or limits provided
756             for lim in reversed(expr.limits):
757                 mo = self.dom.createElement('mo')
758                 mo.appendChild(self.dom.createTextNode(intsymbols[1]))
759                 if len(lim) == 1:
760                     mrow.appendChild(mo)
761                 if len(lim) == 2:
762                     msup = self.dom.createElement('msup')
763                     msup.appendChild(mo)
764                     msup.appendChild(self._print(lim[1]))
765                     mrow.appendChild(msup)
766                 if len(lim) == 3:
767                     msubsup = self.dom.createElement('msubsup')
768                     msubsup.appendChild(mo)
769                     msubsup.appendChild(self._print(lim[1]))
770                     msubsup.appendChild(self._print(lim[2]))
771                     mrow.appendChild(msubsup)
772         # print function
773         mrow.appendChild(self.parenthesize(expr.function, PRECEDENCE["Mul"],
774                                            strict=True))
775         # print integration variables
776         for lim in reversed(expr.limits):
777             d = self.dom.createElement('mo')
778             d.appendChild(self.dom.createTextNode('&dd;'))
779             mrow.appendChild(d)
780             mrow.appendChild(self._print(lim[0]))
781         return mrow
782 
783     def _print_Sum(self, e):
784         limits = list(e.limits)
785         subsup = self.dom.createElement('munderover')
786         low_elem = self._print(limits[0][1])
787         up_elem = self._print(limits[0][2])
788         summand = self.dom.createElement('mo')
789         summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
790 
791         low = self.dom.createElement('mrow')
792         var = self._print(limits[0][0])
793         equal = self.dom.createElement('mo')
794         equal.appendChild(self.dom.createTextNode('='))
795         low.appendChild(var)
796         low.appendChild(equal)
797         low.appendChild(low_elem)
798 
799         subsup.appendChild(summand)
800         subsup.appendChild(low)
801         subsup.appendChild(up_elem)
802 
803         mrow = self.dom.createElement('mrow')
804         mrow.appendChild(subsup)
805         if len(str(e.function)) == 1:
806             mrow.appendChild(self._print(e.function))
807         else:
808             fence = self.dom.createElement('mfenced')
809             fence.appendChild(self._print(e.function))
810             mrow.appendChild(fence)
811 
812         return mrow
813 
814     def _print_Symbol(self, sym, style='plain'):
815         def join(items):
816             if len(items) > 1:
817                 mrow = self.dom.createElement('mrow')
818                 for i, item in enumerate(items):
819                     if i > 0:
820                         mo = self.dom.createElement('mo')
821                         mo.appendChild(self.dom.createTextNode(" "))
822                         mrow.appendChild(mo)
823                     mi = self.dom.createElement('mi')
824                     mi.appendChild(self.dom.createTextNode(item))
825                     mrow.appendChild(mi)
826                 return mrow
827             else:
828                 mi = self.dom.createElement('mi')
829                 mi.appendChild(self.dom.createTextNode(items[0]))
830                 return mi
831 
832         # translate name, supers and subs to unicode characters
833         def translate(s):
834             if s in greek_unicode:
835                 return greek_unicode.get(s)
836             else:
837                 return s
838 
839         name, supers, subs = split_super_sub(sym.name)
840         name = translate(name)
841         supers = [translate(sup) for sup in supers]
842         subs = [translate(sub) for sub in subs]
843 
844         mname = self.dom.createElement('mi')
845         mname.appendChild(self.dom.createTextNode(name))
846         if len(supers) == 0:
847             if len(subs) == 0:
848                 x = mname
849             else:
850                 x = self.dom.createElement('msub')
851                 x.appendChild(mname)
852                 x.appendChild(join(subs))
853         else:
854             if len(subs) == 0:
855                 x = self.dom.createElement('msup')
856                 x.appendChild(mname)
857                 x.appendChild(join(supers))
858             else:
859                 x = self.dom.createElement('msubsup')
860                 x.appendChild(mname)
861                 x.appendChild(join(subs))
862                 x.appendChild(join(supers))
863         # Set bold font?
864         if style == 'bold':
865             x.setAttribute('mathvariant', 'bold')
866         return x
867 
868     def _print_MatrixSymbol(self, sym):
869         return self._print_Symbol(sym,
870                                   style=self._settings['mat_symbol_style'])
871 
872     _print_RandomSymbol = _print_Symbol
873 
874     def _print_conjugate(self, expr):
875         enc = self.dom.createElement('menclose')
876         enc.setAttribute('notation', 'top')
877         enc.appendChild(self._print(expr.args[0]))
878         return enc
879 
880     def _print_operator_after(self, op, expr):
881         row = self.dom.createElement('mrow')
882         row.appendChild(self.parenthesize(expr, PRECEDENCE["Func"]))
883         mo = self.dom.createElement('mo')
884         mo.appendChild(self.dom.createTextNode(op))
885         row.appendChild(mo)
886         return row
887 
888     def _print_factorial(self, expr):
889         return self._print_operator_after('!', expr.args[0])
890 
891     def _print_factorial2(self, expr):
892         return self._print_operator_after('!!', expr.args[0])
893 
894     def _print_binomial(self, expr):
895         brac = self.dom.createElement('mfenced')
896         frac = self.dom.createElement('mfrac')
897         frac.setAttribute('linethickness', '0')
898         frac.appendChild(self._print(expr.args[0]))
899         frac.appendChild(self._print(expr.args[1]))
900         brac.appendChild(frac)
901         return brac
902 
903     def _print_Pow(self, e):
904         # Here we use root instead of power if the exponent is the
905         # reciprocal of an integer
906         if (e.exp.is_Rational and abs(e.exp.p) == 1 and e.exp.q != 1 and
907                 self._settings['root_notation']):
908             if e.exp.q == 2:
909                 x = self.dom.createElement('msqrt')
910                 x.appendChild(self._print(e.base))
911             if e.exp.q != 2:
912                 x = self.dom.createElement('mroot')
913                 x.appendChild(self._print(e.base))
914                 x.appendChild(self._print(e.exp.q))
915             if e.exp.p == -1:
916                 frac = self.dom.createElement('mfrac')
917                 frac.appendChild(self._print(1))
918                 frac.appendChild(x)
919                 return frac
920             else:
921                 return x
922 
923         if e.exp.is_Rational and e.exp.q != 1:
924             if e.exp.is_negative:
925                 top = self.dom.createElement('mfrac')
926                 top.appendChild(self._print(1))
927                 x = self.dom.createElement('msup')
928                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
929                 x.appendChild(self._get_printed_Rational(-e.exp,
930                                     self._settings['fold_frac_powers']))
931                 top.appendChild(x)
932                 return top
933             else:
934                 x = self.dom.createElement('msup')
935                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
936                 x.appendChild(self._get_printed_Rational(e.exp,
937                                     self._settings['fold_frac_powers']))
938                 return x
939 
940         if e.exp.is_negative:
941                 top = self.dom.createElement('mfrac')
942                 top.appendChild(self._print(1))
943                 if e.exp == -1:
944                     top.appendChild(self._print(e.base))
945                 else:
946                     x = self.dom.createElement('msup')
947                     x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
948                     x.appendChild(self._print(-e.exp))
949                     top.appendChild(x)
950                 return top
951 
952         x = self.dom.createElement('msup')
953         x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
954         x.appendChild(self._print(e.exp))
955         return x
956 
957     def _print_Number(self, e):
958         x = self.dom.createElement(self.mathml_tag(e))
959         x.appendChild(self.dom.createTextNode(str(e)))
960         return x
961 
962     def _print_AccumulationBounds(self, i):
963         brac = self.dom.createElement('mfenced')
964         brac.setAttribute('open', u'\u27e8')
965         brac.setAttribute('close', u'\u27e9')
966         brac.appendChild(self._print(i.min))
967         brac.appendChild(self._print(i.max))
968         return brac
969 
970     def _print_Derivative(self, e):
971 
972         if requires_partial(e):
973             d = '&#x2202;'
974         else:
975             d = self.mathml_tag(e)
976 
977         # Determine denominator
978         m = self.dom.createElement('mrow')
979         dim = 0  # Total diff dimension, for numerator
980         for sym, num in reversed(e.variable_count):
981             dim += num
982             if num >= 2:
983                 x = self.dom.createElement('msup')
984                 xx = self.dom.createElement('mo')
985                 xx.appendChild(self.dom.createTextNode(d))
986                 x.appendChild(xx)
987                 x.appendChild(self._print(num))
988             else:
989                 x = self.dom.createElement('mo')
990                 x.appendChild(self.dom.createTextNode(d))
991             m.appendChild(x)
992             y = self._print(sym)
993             m.appendChild(y)
994 
995         mnum = self.dom.createElement('mrow')
996         if dim >= 2:
997             x = self.dom.createElement('msup')
998             xx = self.dom.createElement('mo')
999             xx.appendChild(self.dom.createTextNode(d))
1000             x.appendChild(xx)
1001             x.appendChild(self._print(dim))
1002         else:
1003             x = self.dom.createElement('mo')
1004             x.appendChild(self.dom.createTextNode(d))
1005 
1006         mnum.appendChild(x)
1007         mrow = self.dom.createElement('mrow')
1008         frac = self.dom.createElement('mfrac')
1009         frac.appendChild(mnum)
1010         frac.appendChild(m)
1011         mrow.appendChild(frac)
1012 
1013         # Print function
1014         mrow.appendChild(self._print(e.expr))
1015 
1016         return mrow
1017 
1018     def _print_Function(self, e):
1019         mrow = self.dom.createElement('mrow')
1020         x = self.dom.createElement('mi')
1021         if self.mathml_tag(e) == 'log' and self._settings["ln_notation"]:
1022             x.appendChild(self.dom.createTextNode('ln'))
1023         else:
1024             x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1025         y = self.dom.createElement('mfenced')
1026         for arg in e.args:
1027             y.appendChild(self._print(arg))
1028         mrow.appendChild(x)
1029         mrow.appendChild(y)
1030         return mrow
1031 
1032     def _print_Float(self, expr):
1033         # Based off of that in StrPrinter
1034         dps = prec_to_dps(expr._prec)
1035         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
1036 
1037         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
1038         # thus we use the number separator
1039         separator = self._settings['mul_symbol_mathml_numbers']
1040         mrow = self.dom.createElement('mrow')
1041         if 'e' in str_real:
1042             (mant, exp) = str_real.split('e')
1043 
1044             if exp[0] == '+':
1045                 exp = exp[1:]
1046 
1047             mn = self.dom.createElement('mn')
1048             mn.appendChild(self.dom.createTextNode(mant))
1049             mrow.appendChild(mn)
1050             mo = self.dom.createElement('mo')
1051             mo.appendChild(self.dom.createTextNode(separator))
1052             mrow.appendChild(mo)
1053             msup = self.dom.createElement('msup')
1054             mn = self.dom.createElement('mn')
1055             mn.appendChild(self.dom.createTextNode("10"))
1056             msup.appendChild(mn)
1057             mn = self.dom.createElement('mn')
1058             mn.appendChild(self.dom.createTextNode(exp))
1059             msup.appendChild(mn)
1060             mrow.appendChild(msup)
1061             return mrow
1062         elif str_real == "+inf":
1063             return self._print_Infinity(None)
1064         elif str_real == "-inf":
1065             return self._print_NegativeInfinity(None)
1066         else:
1067             mn = self.dom.createElement('mn')
1068             mn.appendChild(self.dom.createTextNode(str_real))
1069             return mn
1070 
1071     def _print_polylog(self, expr):
1072         mrow = self.dom.createElement('mrow')
1073         m = self.dom.createElement('msub')
1074 
1075         mi = self.dom.createElement('mi')
1076         mi.appendChild(self.dom.createTextNode('Li'))
1077         m.appendChild(mi)
1078         m.appendChild(self._print(expr.args[0]))
1079         mrow.appendChild(m)
1080         brac = self.dom.createElement('mfenced')
1081         brac.appendChild(self._print(expr.args[1]))
1082         mrow.appendChild(brac)
1083         return mrow
1084 
1085     def _print_Basic(self, e):
1086         mrow = self.dom.createElement('mrow')
1087         mi = self.dom.createElement('mi')
1088         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1089         mrow.appendChild(mi)
1090         brac = self.dom.createElement('mfenced')
1091         for arg in e.args:
1092             brac.appendChild(self._print(arg))
1093         mrow.appendChild(brac)
1094         return mrow
1095 
1096     def _print_Tuple(self, e):
1097         mrow = self.dom.createElement('mrow')
1098         x = self.dom.createElement('mfenced')
1099         for arg in e.args:
1100             x.appendChild(self._print(arg))
1101         mrow.appendChild(x)
1102         return mrow
1103 
1104     def _print_Interval(self, i):
1105         mrow = self.dom.createElement('mrow')
1106         brac = self.dom.createElement('mfenced')
1107         if i.start == i.end:
1108             # Most often, this type of Interval is converted to a FiniteSet
1109             brac.setAttribute('open', '{')
1110             brac.setAttribute('close', '}')
1111             brac.appendChild(self._print(i.start))
1112         else:
1113             if i.left_open:
1114                 brac.setAttribute('open', '(')
1115             else:
1116                 brac.setAttribute('open', '[')
1117 
1118             if i.right_open:
1119                 brac.setAttribute('close', ')')
1120             else:
1121                 brac.setAttribute('close', ']')
1122             brac.appendChild(self._print(i.start))
1123             brac.appendChild(self._print(i.end))
1124 
1125         mrow.appendChild(brac)
1126         return mrow
1127 
1128     def _print_Abs(self, expr, exp=None):
1129         mrow = self.dom.createElement('mrow')
1130         x = self.dom.createElement('mfenced')
1131         x.setAttribute('open', '|')
1132         x.setAttribute('close', '|')
1133         x.appendChild(self._print(expr.args[0]))
1134         mrow.appendChild(x)
1135         return mrow
1136 
1137     _print_Determinant = _print_Abs
1138 
1139     def _print_re_im(self, c, expr):
1140         mrow = self.dom.createElement('mrow')
1141         mi = self.dom.createElement('mi')
1142         mi.setAttribute('mathvariant', 'fraktur')
1143         mi.appendChild(self.dom.createTextNode(c))
1144         mrow.appendChild(mi)
1145         brac = self.dom.createElement('mfenced')
1146         brac.appendChild(self._print(expr))
1147         mrow.appendChild(brac)
1148         return mrow
1149 
1150     def _print_re(self, expr, exp=None):
1151         return self._print_re_im('R', expr.args[0])
1152 
1153     def _print_im(self, expr, exp=None):
1154         return self._print_re_im('I', expr.args[0])
1155 
1156     def _print_AssocOp(self, e):
1157         mrow = self.dom.createElement('mrow')
1158         mi = self.dom.createElement('mi')
1159         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1160         mrow.appendChild(mi)
1161         for arg in e.args:
1162             mrow.appendChild(self._print(arg))
1163         return mrow
1164 
1165     def _print_SetOp(self, expr, symbol):
1166         mrow = self.dom.createElement('mrow')
1167         mrow.appendChild(self._print(expr.args[0]))
1168         for arg in expr.args[1:]:
1169             x = self.dom.createElement('mo')
1170             x.appendChild(self.dom.createTextNode(symbol))
1171             y = self._print(arg)
1172             mrow.appendChild(x)
1173             mrow.appendChild(y)
1174         return mrow
1175 
1176     def _print_Union(self, expr):
1177         return self._print_SetOp(expr, '&#x222A;')
1178 
1179     def _print_Intersection(self, expr):
1180         return self._print_SetOp(expr, '&#x2229;')
1181 
1182     def _print_Complement(self, expr):
1183         return self._print_SetOp(expr, '&#x2216;')
1184 
1185     def _print_SymmetricDifference(self, expr):
1186         return self._print_SetOp(expr, '&#x2206;')
1187 
1188     def _print_FiniteSet(self, s):
1189         return self._print_set(s.args)
1190 
1191     def _print_set(self, s):
1192         items = sorted(s, key=default_sort_key)
1193         brac = self.dom.createElement('mfenced')
1194         brac.setAttribute('open', '{')
1195         brac.setAttribute('close', '}')
1196         for item in items:
1197             brac.appendChild(self._print(item))
1198         return brac
1199 
1200     _print_frozenset = _print_set
1201 
1202     def _print_LogOp(self, args, symbol):
1203         mrow = self.dom.createElement('mrow')
1204         if args[0].is_Boolean and not args[0].is_Not:
1205             brac = self.dom.createElement('mfenced')
1206             brac.appendChild(self._print(args[0]))
1207             mrow.appendChild(brac)
1208         else:
1209             mrow.appendChild(self._print(args[0]))
1210         for arg in args[1:]:
1211             x = self.dom.createElement('mo')
1212             x.appendChild(self.dom.createTextNode(symbol))
1213             if arg.is_Boolean and not arg.is_Not:
1214                 y = self.dom.createElement('mfenced')
1215                 y.appendChild(self._print(arg))
1216             else:
1217                 y = self._print(arg)
1218             mrow.appendChild(x)
1219             mrow.appendChild(y)
1220         return mrow
1221 
1222     def _print_BasisDependent(self, expr):
1223         from sympy.vector import Vector
1224 
1225         if expr == expr.zero:
1226             # Not clear if this is ever called
1227             return self._print(expr.zero)
1228         if isinstance(expr, Vector):
1229             items = expr.separate().items()
1230         else:
1231             items = [(0, expr)]
1232 
1233         mrow = self.dom.createElement('mrow')
1234         for system, vect in items:
1235             inneritems = list(vect.components.items())
1236             inneritems.sort(key = lambda x:x[0].__str__())
1237             for i, (k, v) in enumerate(inneritems):
1238                 if v == 1:
1239                     if i: # No + for first item
1240                         mo = self.dom.createElement('mo')
1241                         mo.appendChild(self.dom.createTextNode('+'))
1242                         mrow.appendChild(mo)
1243                     mrow.appendChild(self._print(k))
1244                 elif v == -1:
1245                     mo = self.dom.createElement('mo')
1246                     mo.appendChild(self.dom.createTextNode('-'))
1247                     mrow.appendChild(mo)
1248                     mrow.appendChild(self._print(k))
1249                 else:
1250                     if i: # No + for first item
1251                         mo = self.dom.createElement('mo')
1252                         mo.appendChild(self.dom.createTextNode('+'))
1253                         mrow.appendChild(mo)
1254                     mbrac = self.dom.createElement('mfenced')
1255                     mbrac.appendChild(self._print(v))
1256                     mrow.appendChild(mbrac)
1257                     mo = self.dom.createElement('mo')
1258                     mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
1259                     mrow.appendChild(mo)
1260                     mrow.appendChild(self._print(k))
1261         return mrow
1262 
1263 
1264     def _print_And(self, expr):
1265         args = sorted(expr.args, key=default_sort_key)
1266         return self._print_LogOp(args, '&#x2227;')
1267 
1268     def _print_Or(self, expr):
1269         args = sorted(expr.args, key=default_sort_key)
1270         return self._print_LogOp(args, '&#x2228;')
1271 
1272     def _print_Xor(self, expr):
1273         args = sorted(expr.args, key=default_sort_key)
1274         return self._print_LogOp(args, '&#x22BB;')
1275 
1276     def _print_Implies(self, expr):
1277         return self._print_LogOp(expr.args, '&#x21D2;')
1278 
1279     def _print_Equivalent(self, expr):
1280         args = sorted(expr.args, key=default_sort_key)
1281         return self._print_LogOp(args, '&#x21D4;')
1282 
1283     def _print_Not(self, e):
1284         mrow = self.dom.createElement('mrow')
1285         mo = self.dom.createElement('mo')
1286         mo.appendChild(self.dom.createTextNode('&#xAC;'))
1287         mrow.appendChild(mo)
1288         if (e.args[0].is_Boolean):
1289             x = self.dom.createElement('mfenced')
1290             x.appendChild(self._print(e.args[0]))
1291         else:
1292             x = self._print(e.args[0])
1293         mrow.appendChild(x)
1294         return mrow
1295 
1296     def _print_bool(self, e):
1297         mi = self.dom.createElement('mi')
1298         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1299         return mi
1300 
1301     _print_BooleanTrue = _print_bool
1302     _print_BooleanFalse = _print_bool
1303 
1304     def _print_NoneType(self, e):
1305         mi = self.dom.createElement('mi')
1306         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1307         return mi
1308 
1309     def _print_Range(self, s):
1310         dots = u"\u2026"
1311         brac = self.dom.createElement('mfenced')
1312         brac.setAttribute('open', '{')
1313         brac.setAttribute('close', '}')
1314 
1315         if s.start.is_infinite:
1316             printset = dots, s[-1] - s.step, s[-1]
1317         elif s.stop.is_infinite:
1318             it = iter(s)
1319             printset = next(it), next(it), dots
1320         elif len(s) > 4:
1321             it = iter(s)
1322             printset = next(it), next(it), dots, s[-1]
1323         else:
1324             printset = tuple(s)
1325 
1326         for el in printset:
1327             if el == dots:
1328                 mi = self.dom.createElement('mi')
1329                 mi.appendChild(self.dom.createTextNode(dots))
1330                 brac.appendChild(mi)
1331             else:
1332                 brac.appendChild(self._print(el))
1333 
1334         return brac
1335 
1336     def _hprint_variadic_function(self, expr):
1337         args = sorted(expr.args, key=default_sort_key)
1338         mrow = self.dom.createElement('mrow')
1339         mo = self.dom.createElement('mo')
1340         mo.appendChild(self.dom.createTextNode((str(expr.func)).lower()))
1341         mrow.appendChild(mo)
1342         brac = self.dom.createElement('mfenced')
1343         for symbol in args:
1344             brac.appendChild(self._print(symbol))
1345         mrow.appendChild(brac)
1346         return mrow
1347 
1348     _print_Min = _print_Max = _hprint_variadic_function
1349 
1350     def _print_exp(self, expr):
1351         msup = self.dom.createElement('msup')
1352         msup.appendChild(self._print_Exp1(None))
1353         msup.appendChild(self._print(expr.args[0]))
1354         return msup
1355 
1356     def _print_Relational(self, e):
1357         mrow = self.dom.createElement('mrow')
1358         mrow.appendChild(self._print(e.lhs))
1359         x = self.dom.createElement('mo')
1360         x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1361         mrow.appendChild(x)
1362         mrow.appendChild(self._print(e.rhs))
1363         return mrow
1364 
1365     def _print_int(self, p):
1366         dom_element = self.dom.createElement(self.mathml_tag(p))
1367         dom_element.appendChild(self.dom.createTextNode(str(p)))
1368         return dom_element
1369 
1370     def _print_BaseScalar(self, e):
1371         msub = self.dom.createElement('msub')
1372         index, system = e._id
1373         mi = self.dom.createElement('mi')
1374         mi.setAttribute('mathvariant', 'bold')
1375         mi.appendChild(self.dom.createTextNode(system._variable_names[index]))
1376         msub.appendChild(mi)
1377         mi = self.dom.createElement('mi')
1378         mi.setAttribute('mathvariant', 'bold')
1379         mi.appendChild(self.dom.createTextNode(system._name))
1380         msub.appendChild(mi)
1381         return msub
1382 
1383     def _print_BaseVector(self, e):
1384         msub = self.dom.createElement('msub')
1385         index, system = e._id
1386         mover = self.dom.createElement('mover')
1387         mi = self.dom.createElement('mi')
1388         mi.setAttribute('mathvariant', 'bold')
1389         mi.appendChild(self.dom.createTextNode(system._vector_names[index]))
1390         mover.appendChild(mi)
1391         mo = self.dom.createElement('mo')
1392         mo.appendChild(self.dom.createTextNode('^'))
1393         mover.appendChild(mo)
1394         msub.appendChild(mover)
1395         mi = self.dom.createElement('mi')
1396         mi.setAttribute('mathvariant', 'bold')
1397         mi.appendChild(self.dom.createTextNode(system._name))
1398         msub.appendChild(mi)
1399         return msub
1400 
1401     def _print_VectorZero(self, e):
1402         mover = self.dom.createElement('mover')
1403         mi = self.dom.createElement('mi')
1404         mi.setAttribute('mathvariant', 'bold')
1405         mi.appendChild(self.dom.createTextNode("0"))
1406         mover.appendChild(mi)
1407         mo = self.dom.createElement('mo')
1408         mo.appendChild(self.dom.createTextNode('^'))
1409         mover.appendChild(mo)
1410         return mover
1411 
1412     def _print_Cross(self, expr):
1413         mrow = self.dom.createElement('mrow')
1414         vec1 = expr._expr1
1415         vec2 = expr._expr2
1416         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
1417         mo = self.dom.createElement('mo')
1418         mo.appendChild(self.dom.createTextNode('&#xD7;'))
1419         mrow.appendChild(mo)
1420         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
1421         return mrow
1422 
1423     def _print_Curl(self, expr):
1424         mrow = self.dom.createElement('mrow')
1425         mo = self.dom.createElement('mo')
1426         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1427         mrow.appendChild(mo)
1428         mo = self.dom.createElement('mo')
1429         mo.appendChild(self.dom.createTextNode('&#xD7;'))
1430         mrow.appendChild(mo)
1431         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1432         return mrow
1433 
1434     def _print_Divergence(self, expr):
1435         mrow = self.dom.createElement('mrow')
1436         mo = self.dom.createElement('mo')
1437         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1438         mrow.appendChild(mo)
1439         mo = self.dom.createElement('mo')
1440         mo.appendChild(self.dom.createTextNode('&#xB7;'))
1441         mrow.appendChild(mo)
1442         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1443         return mrow
1444 
1445     def _print_Dot(self, expr):
1446         mrow = self.dom.createElement('mrow')
1447         vec1 = expr._expr1
1448         vec2 = expr._expr2
1449         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
1450         mo = self.dom.createElement('mo')
1451         mo.appendChild(self.dom.createTextNode('&#xB7;'))
1452         mrow.appendChild(mo)
1453         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
1454         return mrow
1455 
1456     def _print_Gradient(self, expr):
1457         mrow = self.dom.createElement('mrow')
1458         mo = self.dom.createElement('mo')
1459         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1460         mrow.appendChild(mo)
1461         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1462         return mrow
1463 
1464     def _print_Laplacian(self, expr):
1465         mrow = self.dom.createElement('mrow')
1466         mo = self.dom.createElement('mo')
1467         mo.appendChild(self.dom.createTextNode('&#x2206;'))
1468         mrow.appendChild(mo)
1469         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1470         return mrow
1471 
1472     def _print_Integers(self, e):
1473         x = self.dom.createElement('mi')
1474         x.setAttribute('mathvariant', 'normal')
1475         x.appendChild(self.dom.createTextNode('&#x2124;'))
1476         return x
1477 
1478     def _print_Complexes(self, e):
1479         x = self.dom.createElement('mi')
1480         x.setAttribute('mathvariant', 'normal')
1481         x.appendChild(self.dom.createTextNode('&#x2102;'))
1482         return x
1483 
1484     def _print_Reals(self, e):
1485         x = self.dom.createElement('mi')
1486         x.setAttribute('mathvariant', 'normal')
1487         x.appendChild(self.dom.createTextNode('&#x211D;'))
1488         return x
1489 
1490     def _print_Naturals(self, e):
1491         x = self.dom.createElement('mi')
1492         x.setAttribute('mathvariant', 'normal')
1493         x.appendChild(self.dom.createTextNode('&#x2115;'))
1494         return x
1495 
1496     def _print_Naturals0(self, e):
1497         sub = self.dom.createElement('msub')
1498         x = self.dom.createElement('mi')
1499         x.setAttribute('mathvariant', 'normal')
1500         x.appendChild(self.dom.createTextNode('&#x2115;'))
1501         sub.appendChild(x)
1502         sub.appendChild(self._print(S.Zero))
1503         return sub
1504 
1505     def _print_SingularityFunction(self, expr):
1506         shift = expr.args[0] - expr.args[1]
1507         power = expr.args[2]
1508         sup = self.dom.createElement('msup')
1509         brac = self.dom.createElement('mfenced')
1510         brac.setAttribute('open', u'\u27e8')
1511         brac.setAttribute('close', u'\u27e9')
1512         brac.appendChild(self._print(shift))
1513         sup.appendChild(brac)
1514         sup.appendChild(self._print(power))
1515         return sup
1516 
1517     def _print_NaN(self, e):
1518         x = self.dom.createElement('mi')
1519         x.appendChild(self.dom.createTextNode('NaN'))
1520         return x
1521 
1522     def _print_bernoulli(self, e):
1523         sub = self.dom.createElement('msub')
1524         mi = self.dom.createElement('mi')
1525         mi.appendChild(self.dom.createTextNode('B'))
1526         sub.appendChild(mi)
1527         sub.appendChild(self._print(e.args[0]))
1528         return sub
1529 
1530     _print_bell = _print_bernoulli
1531 
1532     def _print_catalan(self, e):
1533         sub = self.dom.createElement('msub')
1534         mi = self.dom.createElement('mi')
1535         mi.appendChild(self.dom.createTextNode('C'))
1536         sub.appendChild(mi)
1537         sub.appendChild(self._print(e.args[0]))
1538         return sub
1539 
1540     def _print_fibonacci(self, e):
1541         sub = self.dom.createElement('msub')
1542         mi = self.dom.createElement('mi')
1543         mi.appendChild(self.dom.createTextNode('F'))
1544         sub.appendChild(mi)
1545         sub.appendChild(self._print(e.args[0]))
1546         return sub
1547 
1548     def _print_lucas(self, e):
1549         sub = self.dom.createElement('msub')
1550         mi = self.dom.createElement('mi')
1551         mi.appendChild(self.dom.createTextNode('L'))
1552         sub.appendChild(mi)
1553         sub.appendChild(self._print(e.args[0]))
1554         return sub
1555 
1556     def _print_tribonacci(self, e):
1557         sub = self.dom.createElement('msub')
1558         mi = self.dom.createElement('mi')
1559         mi.appendChild(self.dom.createTextNode('T'))
1560         sub.appendChild(mi)
1561         sub.appendChild(self._print(e.args[0]))
1562         return sub
1563 
1564     def _print_ComplexInfinity(self, e):
1565         x = self.dom.createElement('mover')
1566         mo = self.dom.createElement('mo')
1567         mo.appendChild(self.dom.createTextNode('&#x221E;'))
1568         x.appendChild(mo)
1569         mo = self.dom.createElement('mo')
1570         mo.appendChild(self.dom.createTextNode('~'))
1571         x.appendChild(mo)
1572         return x
1573 
1574     def _print_EmptySet(self, e):
1575         x = self.dom.createElement('mo')
1576         x.appendChild(self.dom.createTextNode('&#x2205;'))
1577         return x
1578 
1579     def _print_UniversalSet(self, e):
1580         x = self.dom.createElement('mo')
1581         x.appendChild(self.dom.createTextNode('&#x1D54C;'))
1582         return x
1583 
1584     def _print_Adjoint(self, expr):
1585         from sympy.matrices import MatrixSymbol
1586         mat = expr.arg
1587         sup = self.dom.createElement('msup')
1588         if not isinstance(mat, MatrixSymbol):
1589             brac = self.dom.createElement('mfenced')
1590             brac.appendChild(self._print(mat))
1591             sup.appendChild(brac)
1592         else:
1593             sup.appendChild(self._print(mat))
1594         mo = self.dom.createElement('mo')
1595         mo.appendChild(self.dom.createTextNode('&#x2020;'))
1596         sup.appendChild(mo)
1597         return sup
1598 
1599     def _print_Transpose(self, expr):
1600         from sympy.matrices import MatrixSymbol
1601         mat = expr.arg
1602         sup = self.dom.createElement('msup')
1603         if not isinstance(mat, MatrixSymbol):
1604             brac = self.dom.createElement('mfenced')
1605             brac.appendChild(self._print(mat))
1606             sup.appendChild(brac)
1607         else:
1608             sup.appendChild(self._print(mat))
1609         mo = self.dom.createElement('mo')
1610         mo.appendChild(self.dom.createTextNode('T'))
1611         sup.appendChild(mo)
1612         return sup
1613 
1614     def _print_Inverse(self, expr):
1615         from sympy.matrices import MatrixSymbol
1616         mat = expr.arg
1617         sup = self.dom.createElement('msup')
1618         if not isinstance(mat, MatrixSymbol):
1619             brac = self.dom.createElement('mfenced')
1620             brac.appendChild(self._print(mat))
1621             sup.appendChild(brac)
1622         else:
1623             sup.appendChild(self._print(mat))
1624         sup.appendChild(self._print(-1))
1625         return sup
1626 
1627     def _print_MatMul(self, expr):
1628         from sympy import MatMul
1629 
1630         x = self.dom.createElement('mrow')
1631         args = expr.args
1632         if isinstance(args[0], Mul):
1633             args = args[0].as_ordered_factors() + list(args[1:])
1634         else:
1635             args = list(args)
1636 
1637         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1638             if args[0] == -1:
1639                 args = args[1:]
1640             else:
1641                 args[0] = -args[0]
1642             mo = self.dom.createElement('mo')
1643             mo.appendChild(self.dom.createTextNode('-'))
1644             x.appendChild(mo)
1645 
1646         for arg in args[:-1]:
1647             x.appendChild(self.parenthesize(arg, precedence_traditional(expr),
1648                                             False))
1649             mo = self.dom.createElement('mo')
1650             mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
1651             x.appendChild(mo)
1652         x.appendChild(self.parenthesize(args[-1], precedence_traditional(expr),
1653                                         False))
1654         return x
1655 
1656     def _print_MatPow(self, expr):
1657         from sympy.matrices import MatrixSymbol
1658         base, exp = expr.base, expr.exp
1659         sup = self.dom.createElement('msup')
1660         if not isinstance(base, MatrixSymbol):
1661             brac = self.dom.createElement('mfenced')
1662             brac.appendChild(self._print(base))
1663             sup.appendChild(brac)
1664         else:
1665             sup.appendChild(self._print(base))
1666         sup.appendChild(self._print(exp))
1667         return sup
1668 
1669     def _print_HadamardProduct(self, expr):
1670         x = self.dom.createElement('mrow')
1671         args = expr.args
1672         for arg in args[:-1]:
1673             x.appendChild(
1674                 self.parenthesize(arg, precedence_traditional(expr), False))
1675             mo = self.dom.createElement('mo')
1676             mo.appendChild(self.dom.createTextNode('&#x2218;'))
1677             x.appendChild(mo)
1678         x.appendChild(
1679             self.parenthesize(args[-1], precedence_traditional(expr), False))
1680         return x
1681 
1682     def _print_ZeroMatrix(self, Z):
1683         x = self.dom.createElement('mn')
1684         x.appendChild(self.dom.createTextNode('&#x1D7D8'))
1685         return x
1686 
1687     def _print_Identity(self, I):
1688         x = self.dom.createElement('mi')
1689         x.appendChild(self.dom.createTextNode('&#x1D540;'))
1690         return x
1691 
1692     def _print_floor(self, e):
1693         mrow = self.dom.createElement('mrow')
1694         x = self.dom.createElement('mfenced')
1695         x.setAttribute('open', u'\u230A')
1696         x.setAttribute('close', u'\u230B')
1697         x.appendChild(self._print(e.args[0]))
1698         mrow.appendChild(x)
1699         return mrow
1700 
1701     def _print_ceiling(self, e):
1702         mrow = self.dom.createElement('mrow')
1703         x = self.dom.createElement('mfenced')
1704         x.setAttribute('open', u'\u2308')
1705         x.setAttribute('close', u'\u2309')
1706         x.appendChild(self._print(e.args[0]))
1707         mrow.appendChild(x)
1708         return mrow
1709 
1710     def _print_Lambda(self, e):
1711         x = self.dom.createElement('mfenced')
1712         mrow = self.dom.createElement('mrow')
1713         symbols = e.args[0]
1714         if len(symbols) == 1:
1715             symbols = self._print(symbols[0])
1716         else:
1717             symbols = self._print(symbols)
1718         mrow.appendChild(symbols)
1719         mo = self.dom.createElement('mo')
1720         mo.appendChild(self.dom.createTextNode('&#x21A6;'))
1721         mrow.appendChild(mo)
1722         mrow.appendChild(self._print(e.args[1]))
1723         x.appendChild(mrow)
1724         return x
1725 
1726     def _print_tuple(self, e):
1727         x = self.dom.createElement('mfenced')
1728         for i in e:
1729             x.appendChild(self._print(i))
1730         return x
1731 
1732     def _print_IndexedBase(self, e):
1733         return self._print(e.label)
1734 
1735     def _print_Indexed(self, e):
1736         x = self.dom.createElement('msub')
1737         x.appendChild(self._print(e.base))
1738         if len(e.indices) == 1:
1739             x.appendChild(self._print(e.indices[0]))
1740             return x
1741         x.appendChild(self._print(e.indices))
1742         return x
1743 
1744     def _print_MatrixElement(self, e):
1745         x = self.dom.createElement('msub')
1746         x.appendChild(self.parenthesize(e.parent, PRECEDENCE["Atom"], strict = True))
1747         brac = self.dom.createElement('mfenced')
1748         brac.setAttribute("open", "")
1749         brac.setAttribute("close", "")
1750         for i in e.indices:
1751             brac.appendChild(self._print(i))
1752         x.appendChild(brac)
1753         return x
1754 
1755     def _print_elliptic_f(self, e):
1756         x = self.dom.createElement('mrow')
1757         mi = self.dom.createElement('mi')
1758         mi.appendChild(self.dom.createTextNode('&#x1d5a5;'))
1759         x.appendChild(mi)
1760         y = self.dom.createElement('mfenced')
1761         y.setAttribute("separators", "|")
1762         for i in e.args:
1763             y.appendChild(self._print(i))
1764         x.appendChild(y)
1765         return x
1766 
1767     def _print_elliptic_e(self, e):
1768         x = self.dom.createElement('mrow')
1769         mi = self.dom.createElement('mi')
1770         mi.appendChild(self.dom.createTextNode('&#x1d5a4;'))
1771         x.appendChild(mi)
1772         y = self.dom.createElement('mfenced')
1773         y.setAttribute("separators", "|")
1774         for i in e.args:
1775             y.appendChild(self._print(i))
1776         x.appendChild(y)
1777         return x
1778 
1779     def _print_elliptic_pi(self, e):
1780         x = self.dom.createElement('mrow')
1781         mi = self.dom.createElement('mi')
1782         mi.appendChild(self.dom.createTextNode('&#x1d6f1;'))
1783         x.appendChild(mi)
1784         y = self.dom.createElement('mfenced')
1785         if len(e.args) == 2:
1786             y.setAttribute("separators", "|")
1787         else:
1788             y.setAttribute("separators", ";|")
1789         for i in e.args:
1790             y.appendChild(self._print(i))
1791         x.appendChild(y)
1792         return x
1793 
1794     def _print_Ei(self, e):
1795         x = self.dom.createElement('mrow')
1796         mi = self.dom.createElement('mi')
1797         mi.appendChild(self.dom.createTextNode('Ei'))
1798         x.appendChild(mi)
1799         x.appendChild(self._print(e.args))
1800         return x
1801 
1802     def _print_expint(self, e):
1803         x = self.dom.createElement('mrow')
1804         y = self.dom.createElement('msub')
1805         mo = self.dom.createElement('mo')
1806         mo.appendChild(self.dom.createTextNode('E'))
1807         y.appendChild(mo)
1808         y.appendChild(self._print(e.args[0]))
1809         x.appendChild(y)
1810         x.appendChild(self._print(e.args[1:]))
1811         return x
1812 
1813     def _print_jacobi(self, e):
1814         x = self.dom.createElement('mrow')
1815         y = self.dom.createElement('msubsup')
1816         mo = self.dom.createElement('mo')
1817         mo.appendChild(self.dom.createTextNode('P'))
1818         y.appendChild(mo)
1819         y.appendChild(self._print(e.args[0]))
1820         y.appendChild(self._print(e.args[1:3]))
1821         x.appendChild(y)
1822         x.appendChild(self._print(e.args[3:]))
1823         return x
1824 
1825     def _print_gegenbauer(self, e):
1826         x = self.dom.createElement('mrow')
1827         y = self.dom.createElement('msubsup')
1828         mo = self.dom.createElement('mo')
1829         mo.appendChild(self.dom.createTextNode('C'))
1830         y.appendChild(mo)
1831         y.appendChild(self._print(e.args[0]))
1832         y.appendChild(self._print(e.args[1:2]))
1833         x.appendChild(y)
1834         x.appendChild(self._print(e.args[2:]))
1835         return x
1836 
1837     def _print_chebyshevt(self, e):
1838         x = self.dom.createElement('mrow')
1839         y = self.dom.createElement('msub')
1840         mo = self.dom.createElement('mo')
1841         mo.appendChild(self.dom.createTextNode('T'))
1842         y.appendChild(mo)
1843         y.appendChild(self._print(e.args[0]))
1844         x.appendChild(y)
1845         x.appendChild(self._print(e.args[1:]))
1846         return x
1847 
1848     def _print_chebyshevu(self, e):
1849         x = self.dom.createElement('mrow')
1850         y = self.dom.createElement('msub')
1851         mo = self.dom.createElement('mo')
1852         mo.appendChild(self.dom.createTextNode('U'))
1853         y.appendChild(mo)
1854         y.appendChild(self._print(e.args[0]))
1855         x.appendChild(y)
1856         x.appendChild(self._print(e.args[1:]))
1857         return x
1858 
1859     def _print_legendre(self, e):
1860         x = self.dom.createElement('mrow')
1861         y = self.dom.createElement('msub')
1862         mo = self.dom.createElement('mo')
1863         mo.appendChild(self.dom.createTextNode('P'))
1864         y.appendChild(mo)
1865         y.appendChild(self._print(e.args[0]))
1866         x.appendChild(y)
1867         x.appendChild(self._print(e.args[1:]))
1868         return x
1869 
1870     def _print_assoc_legendre(self, e):
1871         x = self.dom.createElement('mrow')
1872         y = self.dom.createElement('msubsup')
1873         mo = self.dom.createElement('mo')
1874         mo.appendChild(self.dom.createTextNode('P'))
1875         y.appendChild(mo)
1876         y.appendChild(self._print(e.args[0]))
1877         y.appendChild(self._print(e.args[1:2]))
1878         x.appendChild(y)
1879         x.appendChild(self._print(e.args[2:]))
1880         return x
1881 
1882     def _print_laguerre(self, e):
1883         x = self.dom.createElement('mrow')
1884         y = self.dom.createElement('msub')
1885         mo = self.dom.createElement('mo')
1886         mo.appendChild(self.dom.createTextNode('L'))
1887         y.appendChild(mo)
1888         y.appendChild(self._print(e.args[0]))
1889         x.appendChild(y)
1890         x.appendChild(self._print(e.args[1:]))
1891         return x
1892 
1893     def _print_assoc_laguerre(self, e):
1894         x = self.dom.createElement('mrow')
1895         y = self.dom.createElement('msubsup')
1896         mo = self.dom.createElement('mo')
1897         mo.appendChild(self.dom.createTextNode('L'))
1898         y.appendChild(mo)
1899         y.appendChild(self._print(e.args[0]))
1900         y.appendChild(self._print(e.args[1:2]))
1901         x.appendChild(y)
1902         x.appendChild(self._print(e.args[2:]))
1903         return x
1904 
1905     def _print_hermite(self, e):
1906         x = self.dom.createElement('mrow')
1907         y = self.dom.createElement('msub')
1908         mo = self.dom.createElement('mo')
1909         mo.appendChild(self.dom.createTextNode('H'))
1910         y.appendChild(mo)
1911         y.appendChild(self._print(e.args[0]))
1912         x.appendChild(y)
1913         x.appendChild(self._print(e.args[1:]))
1914         return x
1915 
1916 
1917 def mathml(expr, printer='content', **settings):
1918     """Returns the MathML representation of expr. If printer is presentation
1919     then prints Presentation MathML else prints content MathML.
1920     """
1921     if printer == 'presentation':
1922         return MathMLPresentationPrinter(settings).doprint(expr)
1923     else:
1924         return MathMLContentPrinter(settings).doprint(expr)
1925 
1926 
1927 def print_mathml(expr, printer='content', **settings):
1928     """
1929     Prints a pretty representation of the MathML code for expr. If printer is
1930     presentation then prints Presentation MathML else prints content MathML.
1931 
1932     Examples
1933     ========
1934 
1935     >>> ##
1936     >>> from sympy.printing.mathml import print_mathml
1937     >>> from sympy.abc import x
1938     >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE
1939     <apply>
1940         <plus/>
1941         <ci>x</ci>
1942         <cn>1</cn>
1943     </apply>
1944     >>> print_mathml(x+1, printer='presentation')
1945     <mrow>
1946         <mi>x</mi>
1947         <mo>+</mo>
1948         <mn>1</mn>
1949     </mrow>
1950 
1951     """
1952     if printer == 'presentation':
1953         s = MathMLPresentationPrinter(settings)
1954     else:
1955         s = MathMLContentPrinter(settings)
1956     xml = s._print(sympify(expr))
1957     s.apply_patch()
1958     pretty_xml = xml.toprettyxml()
1959     s.restore_patch()
1960 
1961     print(pretty_xml)
1962 
1963 
1964 # For backward compatibility
1965 MathMLPrinter = MathMLContentPrinter

</code><intended_behavior>Extend the existing MathML printing support to include custom handling for `OneMatrix`, `ZeroMatrix`, and `Identity` classes. This includes defining appropriate MathML elements and attributes that accurately represent these special matrices. The goal here is to ensure that these matrices are distinguishable and correctly represented within MathML outputs, facilitating improved presentation in web environments.</intended_behavior>, <file>sympy/matrices/expressions/matexpr.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from functools import wraps, reduce
4 import collections
5 
6 from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq, Mul, Add
7 from sympy.core.decorators import call_highest_priority
8 from sympy.core.compatibility import range, SYMPY_INTS, default_sort_key, string_types
9 from sympy.core.sympify import SympifyError, _sympify
10 from sympy.functions import conjugate, adjoint
11 from sympy.functions.special.tensor_functions import KroneckerDelta
12 from sympy.matrices import ShapeError
13 from sympy.simplify import simplify
14 from sympy.utilities.misc import filldedent
15 
16 
17 def _sympifyit(arg, retval=None):
18     # This version of _sympifyit sympifies MutableMatrix objects
19     def deco(func):
20         @wraps(func)
21         def __sympifyit_wrapper(a, b):
22             try:
23                 b = _sympify(b)
24                 return func(a, b)
25             except SympifyError:
26                 return retval
27 
28         return __sympifyit_wrapper
29 
30     return deco
31 
32 
33 class MatrixExpr(Expr):
34     """Superclass for Matrix Expressions
35 
36     MatrixExprs represent abstract matrices, linear transformations represented
37     within a particular basis.
38 
39     Examples
40     ========
41 
42     >>> from sympy import MatrixSymbol
43     >>> A = MatrixSymbol('A', 3, 3)
44     >>> y = MatrixSymbol('y', 3, 1)
45     >>> x = (A.T*A).I * A * y
46 
47     See Also
48     ========
49 
50     MatrixSymbol, MatAdd, MatMul, Transpose, Inverse
51     """
52 
53     # Should not be considered iterable by the
54     # sympy.core.compatibility.iterable function. Subclass that actually are
55     # iterable (i.e., explicit matrices) should set this to True.
56     _iterable = False
57 
58     _op_priority = 11.0
59 
60     is_Matrix = True
61     is_MatrixExpr = True
62     is_Identity = None
63     is_Inverse = False
64     is_Transpose = False
65     is_ZeroMatrix = False
66     is_MatAdd = False
67     is_MatMul = False
68 
69     is_commutative = False
70     is_number = False
71     is_symbol = False
72     is_scalar = False
73 
74     def __new__(cls, *args, **kwargs):
75         args = map(_sympify, args)
76         return Basic.__new__(cls, *args, **kwargs)
77 
78     # The following is adapted from the core Expr object
79     def __neg__(self):
80         return MatMul(S.NegativeOne, self).doit()
81 
82     def __abs__(self):
83         raise NotImplementedError
84 
85     @_sympifyit('other', NotImplemented)
86     @call_highest_priority('__radd__')
87     def __add__(self, other):
88         return MatAdd(self, other, check=True).doit()
89 
90     @_sympifyit('other', NotImplemented)
91     @call_highest_priority('__add__')
92     def __radd__(self, other):
93         return MatAdd(other, self, check=True).doit()
94 
95     @_sympifyit('other', NotImplemented)
96     @call_highest_priority('__rsub__')
97     def __sub__(self, other):
98         return MatAdd(self, -other, check=True).doit()
99 
100     @_sympifyit('other', NotImplemented)
101     @call_highest_priority('__sub__')
102     def __rsub__(self, other):
103         return MatAdd(other, -self, check=True).doit()
104 
105     @_sympifyit('other', NotImplemented)
106     @call_highest_priority('__rmul__')
107     def __mul__(self, other):
108         return MatMul(self, other).doit()
109 
110     @_sympifyit('other', NotImplemented)
111     @call_highest_priority('__rmul__')
112     def __matmul__(self, other):
113         return MatMul(self, other).doit()
114 
115     @_sympifyit('other', NotImplemented)
116     @call_highest_priority('__mul__')
117     def __rmul__(self, other):
118         return MatMul(other, self).doit()
119 
120     @_sympifyit('other', NotImplemented)
121     @call_highest_priority('__mul__')
122     def __rmatmul__(self, other):
123         return MatMul(other, self).doit()
124 
125     @_sympifyit('other', NotImplemented)
126     @call_highest_priority('__rpow__')
127     def __pow__(self, other):
128         if not self.is_square:
129             raise ShapeError("Power of non-square matrix %s" % self)
130         elif self.is_Identity:
131             return self
132         elif other is S.Zero:
133             return Identity(self.rows)
134         elif other is S.One:
135             return self
136         return MatPow(self, other).doit(deep=False)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__pow__')
140     def __rpow__(self, other):
141         raise NotImplementedError("Matrix Power not defined")
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__rdiv__')
145     def __div__(self, other):
146         return self * other**S.NegativeOne
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__div__')
150     def __rdiv__(self, other):
151         raise NotImplementedError()
152         #return MatMul(other, Pow(self, S.NegativeOne))
153 
154     __truediv__ = __div__
155     __rtruediv__ = __rdiv__
156 
157     @property
158     def rows(self):
159         return self.shape[0]
160 
161     @property
162     def cols(self):
163         return self.shape[1]
164 
165     @property
166     def is_square(self):
167         return self.rows == self.cols
168 
169     def _eval_conjugate(self):
170         from sympy.matrices.expressions.adjoint import Adjoint
171         from sympy.matrices.expressions.transpose import Transpose
172         return Adjoint(Transpose(self))
173 
174     def as_real_imag(self):
175         from sympy import I
176         real = (S(1)/2) * (self + self._eval_conjugate())
177         im = (self - self._eval_conjugate())/(2*I)
178         return (real, im)
179 
180     def _eval_inverse(self):
181         from sympy.matrices.expressions.inverse import Inverse
182         return Inverse(self)
183 
184     def _eval_transpose(self):
185         return Transpose(self)
186 
187     def _eval_power(self, exp):
188         return MatPow(self, exp)
189 
190     def _eval_simplify(self, **kwargs):
191         if self.is_Atom:
192             return self
193         else:
194             return self.__class__(*[simplify(x, **kwargs) for x in self.args])
195 
196     def _eval_adjoint(self):
197         from sympy.matrices.expressions.adjoint import Adjoint
198         return Adjoint(self)
199 
200     def _eval_derivative(self, x):
201         # x is a scalar:
202         return ZeroMatrix(self.shape[0], self.shape[1])
203 
204     def _eval_derivative_array(self, x):
205         if isinstance(x, MatrixExpr):
206             return _matrix_derivative(self, x)
207         else:
208             return self._eval_derivative(x)
209 
210     def _eval_derivative_n_times(self, x, n):
211         return Basic._eval_derivative_n_times(self, x, n)
212 
213     def _visit_eval_derivative_scalar(self, x):
214         # `x` is a scalar:
215         if x.has(self):
216             return _matrix_derivative(x, self)
217         else:
218             return ZeroMatrix(*self.shape)
219 
220     def _visit_eval_derivative_array(self, x):
221         if x.has(self):
222             return _matrix_derivative(x, self)
223         else:
224             from sympy import Derivative
225             return Derivative(x, self)
226 
227     def _accept_eval_derivative(self, s):
228         return s._visit_eval_derivative_array(self)
229 
230     def _entry(self, i, j, **kwargs):
231         raise NotImplementedError(
232             "Indexing not implemented for %s" % self.__class__.__name__)
233 
234     def adjoint(self):
235         return adjoint(self)
236 
237     def as_coeff_Mul(self, rational=False):
238         """Efficiently extract the coefficient of a product. """
239         return S.One, self
240 
241     def conjugate(self):
242         return conjugate(self)
243 
244     def transpose(self):
245         from sympy.matrices.expressions.transpose import transpose
246         return transpose(self)
247 
248     T = property(transpose, None, None, 'Matrix transposition.')
249 
250     def inverse(self):
251         return self._eval_inverse()
252 
253     inv = inverse
254 
255     @property
256     def I(self):
257         return self.inverse()
258 
259     def valid_index(self, i, j):
260         def is_valid(idx):
261             return isinstance(idx, (int, Integer, Symbol, Expr))
262         return (is_valid(i) and is_valid(j) and
263                 (self.rows is None or
264                 (0 <= i) != False and (i < self.rows) != False) and
265                 (0 <= j) != False and (j < self.cols) != False)
266 
267     def __getitem__(self, key):
268         if not isinstance(key, tuple) and isinstance(key, slice):
269             from sympy.matrices.expressions.slice import MatrixSlice
270             return MatrixSlice(self, key, (0, None, 1))
271         if isinstance(key, tuple) and len(key) == 2:
272             i, j = key
273             if isinstance(i, slice) or isinstance(j, slice):
274                 from sympy.matrices.expressions.slice import MatrixSlice
275                 return MatrixSlice(self, i, j)
276             i, j = _sympify(i), _sympify(j)
277             if self.valid_index(i, j) != False:
278                 return self._entry(i, j)
279             else:
280                 raise IndexError("Invalid indices (%s, %s)" % (i, j))
281         elif isinstance(key, (SYMPY_INTS, Integer)):
282             # row-wise decomposition of matrix
283             rows, cols = self.shape
284             # allow single indexing if number of columns is known
285             if not isinstance(cols, Integer):
286                 raise IndexError(filldedent('''
287                     Single indexing is only supported when the number
288                     of columns is known.'''))
289             key = _sympify(key)
290             i = key // cols
291             j = key % cols
292             if self.valid_index(i, j) != False:
293                 return self._entry(i, j)
294             else:
295                 raise IndexError("Invalid index %s" % key)
296         elif isinstance(key, (Symbol, Expr)):
297                 raise IndexError(filldedent('''
298                     Only integers may be used when addressing the matrix
299                     with a single index.'''))
300         raise IndexError("Invalid index, wanted %s[i,j]" % self)
301 
302     def as_explicit(self):
303         """
304         Returns a dense Matrix with elements represented explicitly
305 
306         Returns an object of type ImmutableDenseMatrix.
307 
308         Examples
309         ========
310 
311         >>> from sympy import Identity
312         >>> I = Identity(3)
313         >>> I
314         I
315         >>> I.as_explicit()
316         Matrix([
317         [1, 0, 0],
318         [0, 1, 0],
319         [0, 0, 1]])
320 
321         See Also
322         ========
323         as_mutable: returns mutable Matrix type
324 
325         """
326         from sympy.matrices.immutable import ImmutableDenseMatrix
327         return ImmutableDenseMatrix([[    self[i, j]
328                             for j in range(self.cols)]
329                             for i in range(self.rows)])
330 
331     def as_mutable(self):
332         """
333         Returns a dense, mutable matrix with elements represented explicitly
334 
335         Examples
336         ========
337 
338         >>> from sympy import Identity
339         >>> I = Identity(3)
340         >>> I
341         I
342         >>> I.shape
343         (3, 3)
344         >>> I.as_mutable()
345         Matrix([
346         [1, 0, 0],
347         [0, 1, 0],
348         [0, 0, 1]])
349 
350         See Also
351         ========
352         as_explicit: returns ImmutableDenseMatrix
353         """
354         return self.as_explicit().as_mutable()
355 
356     def __array__(self):
357         from numpy import empty
358         a = empty(self.shape, dtype=object)
359         for i in range(self.rows):
360             for j in range(self.cols):
361                 a[i, j] = self[i, j]
362         return a
363 
364     def equals(self, other):
365         """
366         Test elementwise equality between matrices, potentially of different
367         types
368 
369         >>> from sympy import Identity, eye
370         >>> Identity(3).equals(eye(3))
371         True
372         """
373         return self.as_explicit().equals(other)
374 
375     def canonicalize(self):
376         return self
377 
378     def as_coeff_mmul(self):
379         return 1, MatMul(self)
380 
381     @staticmethod
382     def from_index_summation(expr, first_index=None, last_index=None, dimensions=None):
383         r"""
384         Parse expression of matrices with explicitly summed indices into a
385         matrix expression without indices, if possible.
386 
387         This transformation expressed in mathematical notation:
388 
389         `\sum_{j=0}^{N-1} A_{i,j} B_{j,k} \Longrightarrow \mathbf{A}\cdot \mathbf{B}`
390 
391         Optional parameter ``first_index``: specify which free index to use as
392         the index starting the expression.
393 
394         Examples
395         ========
396 
397         >>> from sympy import MatrixSymbol, MatrixExpr, Sum, Symbol
398         >>> from sympy.abc import i, j, k, l, N
399         >>> A = MatrixSymbol("A", N, N)
400         >>> B = MatrixSymbol("B", N, N)
401         >>> expr = Sum(A[i, j]*B[j, k], (j, 0, N-1))
402         >>> MatrixExpr.from_index_summation(expr)
403         A*B
404 
405         Transposition is detected:
406 
407         >>> expr = Sum(A[j, i]*B[j, k], (j, 0, N-1))
408         >>> MatrixExpr.from_index_summation(expr)
409         A.T*B
410 
411         Detect the trace:
412 
413         >>> expr = Sum(A[i, i], (i, 0, N-1))
414         >>> MatrixExpr.from_index_summation(expr)
415         Trace(A)
416 
417         More complicated expressions:
418 
419         >>> expr = Sum(A[i, j]*B[k, j]*A[l, k], (j, 0, N-1), (k, 0, N-1))
420         >>> MatrixExpr.from_index_summation(expr)
421         A*B.T*A.T
422         """
423         from sympy import Sum, Mul, Add, MatMul, transpose, trace
424         from sympy.strategies.traverse import bottom_up
425 
426         def remove_matelement(expr, i1, i2):
427 
428             def repl_match(pos):
429                 def func(x):
430                     if not isinstance(x, MatrixElement):
431                         return False
432                     if x.args[pos] != i1:
433                         return False
434                     if x.args[3-pos] == 0:
435                         if x.args[0].shape[2-pos] == 1:
436                             return True
437                         else:
438                             return False
439                     return True
440                 return func
441 
442             expr = expr.replace(repl_match(1),
443                 lambda x: x.args[0])
444             expr = expr.replace(repl_match(2),
445                 lambda x: transpose(x.args[0]))
446 
447             # Make sure that all Mul are transformed to MatMul and that they
448             # are flattened:
449             rule = bottom_up(lambda x: reduce(lambda a, b: a*b, x.args) if isinstance(x, (Mul, MatMul)) else x)
450             return rule(expr)
451 
452         def recurse_expr(expr, index_ranges={}):
453             if expr.is_Mul:
454                 nonmatargs = []
455                 pos_arg = []
456                 pos_ind = []
457                 dlinks = {}
458                 link_ind = []
459                 counter = 0
460                 args_ind = []
461                 for arg in expr.args:
462                     retvals = recurse_expr(arg, index_ranges)
463                     assert isinstance(retvals, list)
464                     if isinstance(retvals, list):
465                         for i in retvals:
466                             args_ind.append(i)
467                     else:
468                         args_ind.append(retvals)
469                 for arg_symbol, arg_indices in args_ind:
470                     if arg_indices is None:
471                         nonmatargs.append(arg_symbol)
472                         continue
473                     if isinstance(arg_symbol, MatrixElement):
474                         arg_symbol = arg_symbol.args[0]
475                     pos_arg.append(arg_symbol)
476                     pos_ind.append(arg_indices)
477                     link_ind.append([None]*len(arg_indices))
478                     for i, ind in enumerate(arg_indices):
479                         if ind in dlinks:
480                             other_i = dlinks[ind]
481                             link_ind[counter][i] = other_i
482                             link_ind[other_i[0]][other_i[1]] = (counter, i)
483                         dlinks[ind] = (counter, i)
484                     counter += 1
485                 counter2 = 0
486                 lines = {}
487                 while counter2 < len(link_ind):
488                     for i, e in enumerate(link_ind):
489                         if None in e:
490                             line_start_index = (i, e.index(None))
491                             break
492                     cur_ind_pos = line_start_index
493                     cur_line = []
494                     index1 = pos_ind[cur_ind_pos[0]][cur_ind_pos[1]]
495                     while True:
496                         d, r = cur_ind_pos
497                         if pos_arg[d] != 1:
498                             if r % 2 == 1:
499                                 cur_line.append(transpose(pos_arg[d]))
500                             else:
501                                 cur_line.append(pos_arg[d])
502                         next_ind_pos = link_ind[d][1-r]
503                         counter2 += 1
504                         # Mark as visited, there will be no `None` anymore:
505                         link_ind[d] = (-1, -1)
506                         if next_ind_pos is None:
507                             index2 = pos_ind[d][1-r]
508                             lines[(index1, index2)] = cur_line
509                             break
510                         cur_ind_pos = next_ind_pos
511                 lines = {k: MatMul.fromiter(v) if len(v) != 1 else v[0] for k, v in lines.items()}
512                 return [(Mul.fromiter(nonmatargs), None)] + [
513                     (MatrixElement(a, i, j), (i, j)) for (i, j), a in lines.items()
514                 ]
515             elif expr.is_Add:
516                 res = [recurse_expr(i) for i in expr.args]
517                 d = collections.defaultdict(list)
518                 for res_addend in res:
519                     scalar = 1
520                     for elem, indices in res_addend:
521                         if indices is None:
522                             scalar = elem
523                             continue
524                         indices = tuple(sorted(indices, key=default_sort_key))
525                         d[indices].append(scalar*remove_matelement(elem, *indices))
526                         scalar = 1
527                 return [(MatrixElement(Add.fromiter(v), *k), k) for k, v in d.items()]
528             elif isinstance(expr, KroneckerDelta):
529                 i1, i2 = expr.args
530                 if dimensions is not None:
531                     identity = Identity(dimensions[0])
532                 else:
533                     identity = S.One
534                 return [(MatrixElement(identity, i1, i2), (i1, i2))]
535             elif isinstance(expr, MatrixElement):
536                 matrix_symbol, i1, i2 = expr.args
537                 if i1 in index_ranges:
538                     r1, r2 = index_ranges[i1]
539                     if r1 != 0 or matrix_symbol.shape[0] != r2+1:
540                         raise ValueError("index range mismatch: {0} vs. (0, {1})".format(
541                             (r1, r2), matrix_symbol.shape[0]))
542                 if i2 in index_ranges:
543                     r1, r2 = index_ranges[i2]
544                     if r1 != 0 or matrix_symbol.shape[1] != r2+1:
545                         raise ValueError("index range mismatch: {0} vs. (0, {1})".format(
546                             (r1, r2), matrix_symbol.shape[1]))
547                 if (i1 == i2) and (i1 in index_ranges):
548                     return [(trace(matrix_symbol), None)]
549                 return [(MatrixElement(matrix_symbol, i1, i2), (i1, i2))]
550             elif isinstance(expr, Sum):
551                 return recurse_expr(
552                     expr.args[0],
553                     index_ranges={i[0]: i[1:] for i in expr.args[1:]}
554                 )
555             else:
556                 return [(expr, None)]
557 
558         retvals = recurse_expr(expr)
559         factors, indices = zip(*retvals)
560         retexpr = Mul.fromiter(factors)
561         if len(indices) == 0 or list(set(indices)) == [None]:
562             return retexpr
563         if first_index is None:
564             for i in indices:
565                 if i is not None:
566                     ind0 = i
567                     break
568             return remove_matelement(retexpr, *ind0)
569         else:
570             return remove_matelement(retexpr, first_index, last_index)
571 
572     def applyfunc(self, func):
573         from .applyfunc import ElementwiseApplyFunction
574         return ElementwiseApplyFunction(func, self)
575 
576     def _eval_Eq(self, other):
577         if not isinstance(other, MatrixExpr):
578             return False
579         if self.shape != other.shape:
580             return False
581         if (self - other).is_ZeroMatrix:
582             return True
583         return Eq(self, other, evaluate=False)
584 
585 def get_postprocessor(cls):
586     def _postprocessor(expr):
587         # To avoid circular imports, we can't have MatMul/MatAdd on the top level
588         mat_class = {Mul: MatMul, Add: MatAdd}[cls]
589         nonmatrices = []
590         matrices = []
591         for term in expr.args:
592             if isinstance(term, MatrixExpr):
593                 matrices.append(term)
594             else:
595                 nonmatrices.append(term)
596 
597         if not matrices:
598             return cls._from_args(nonmatrices)
599 
600         if nonmatrices:
601             if cls == Mul:
602                 for i in range(len(matrices)):
603                     if not matrices[i].is_MatrixExpr:
604                         # If one of the matrices explicit, absorb the scalar into it
605                         # (doit will combine all explicit matrices into one, so it
606                         # doesn't matter which)
607                         matrices[i] = matrices[i].__mul__(cls._from_args(nonmatrices))
608                         nonmatrices = []
609                         break
610 
611             else:
612                 # Maintain the ability to create Add(scalar, matrix) without
613                 # raising an exception. That way different algorithms can
614                 # replace matrix expressions with non-commutative symbols to
615                 # manipulate them like non-commutative scalars.
616                 return cls._from_args(nonmatrices + [mat_class(*matrices).doit(deep=False)])
617 
618         return mat_class(cls._from_args(nonmatrices), *matrices).doit(deep=False)
619     return _postprocessor
620 
621 
622 Basic._constructor_postprocessor_mapping[MatrixExpr] = {
623     "Mul": [get_postprocessor(Mul)],
624     "Add": [get_postprocessor(Add)],
625 }
626 
627 
628 def _matrix_derivative(expr, x):
629     from sympy import Derivative
630     lines = expr._eval_derivative_matrix_lines(x)
631 
632     parts = [i.build() for i in lines]
633 
634     from sympy.codegen.array_utils import recognize_matrix_expression
635 
636     parts = [[recognize_matrix_expression(j).doit() for j in i] for i in parts]
637 
638     def _get_shape(elem):
639         if isinstance(elem, MatrixExpr):
640             return elem.shape
641         return (1, 1)
642 
643     def get_rank(parts):
644         return sum([j not in (1, None) for i in parts for j in _get_shape(i)])
645 
646     ranks = [get_rank(i) for i in parts]
647     rank = ranks[0]
648 
649     def contract_one_dims(parts):
650         if len(parts) == 1:
651             return parts[0]
652         else:
653             p1, p2 = parts[:2]
654             if p2.is_Matrix:
655                 p2 = p2.T
656             pbase = p1*p2
657             if len(parts) == 2:
658                 return pbase
659             else:  # len(parts) > 2
660                 if pbase.is_Matrix:
661                     raise ValueError("")
662                 return pbase*Mul.fromiter(parts[2:])
663 
664     if rank <= 2:
665         return Add.fromiter([contract_one_dims(i) for i in parts])
666 
667     return Derivative(expr, x)
668 
669 
670 class MatrixElement(Expr):
671     parent = property(lambda self: self.args[0])
672     i = property(lambda self: self.args[1])
673     j = property(lambda self: self.args[2])
674     _diff_wrt = True
675     is_symbol = True
676     is_commutative = True
677 
678     def __new__(cls, name, n, m):
679         n, m = map(_sympify, (n, m))
680         from sympy import MatrixBase
681         if isinstance(name, (MatrixBase,)):
682             if n.is_Integer and m.is_Integer:
683                 return name[n, m]
684         if isinstance(name, string_types):
685             name = Symbol(name)
686         name = _sympify(name)
687         obj = Expr.__new__(cls, name, n, m)
688         return obj
689 
690     def doit(self, **kwargs):
691         deep = kwargs.get('deep', True)
692         if deep:
693             args = [arg.doit(**kwargs) for arg in self.args]
694         else:
695             args = self.args
696         return args[0][args[1], args[2]]
697 
698     @property
699     def indices(self):
700         return self.args[1:]
701 
702     def _eval_derivative(self, v):
703         from sympy import Sum, symbols, Dummy
704 
705         if not isinstance(v, MatrixElement):
706             from sympy import MatrixBase
707             if isinstance(self.parent, MatrixBase):
708                 return self.parent.diff(v)[self.i, self.j]
709             return S.Zero
710 
711         M = self.args[0]
712 
713         if M == v.args[0]:
714             return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])
715 
716         if isinstance(M, Inverse):
717             i, j = self.args[1:]
718             i1, i2 = symbols("z1, z2", cls=Dummy)
719             Y = M.args[0]
720             r1, r2 = Y.shape
721             return -Sum(M[i, i1]*Y[i1, i2].diff(v)*M[i2, j], (i1, 0, r1-1), (i2, 0, r2-1))
722 
723         if self.has(v.args[0]):
724             return None
725 
726         return S.Zero
727 
728 
729 class MatrixSymbol(MatrixExpr):
730     """Symbolic representation of a Matrix object
731 
732     Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and
733     can be included in Matrix Expressions
734 
735     Examples
736     ========
737 
738     >>> from sympy import MatrixSymbol, Identity
739     >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix
740     >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix
741     >>> A.shape
742     (3, 4)
743     >>> 2*A*B + Identity(3)
744     I + 2*A*B
745     """
746     is_commutative = False
747     is_symbol = True
748     _diff_wrt = True
749 
750     def __new__(cls, name, n, m):
751         n, m = _sympify(n), _sympify(m)
752         if isinstance(name, string_types):
753             name = Symbol(name)
754         obj = Basic.__new__(cls, name, n, m)
755         return obj
756 
757     def _hashable_content(self):
758         return (self.name, self.shape)
759 
760     @property
761     def shape(self):
762         return self.args[1:3]
763 
764     @property
765     def name(self):
766         return self.args[0].name
767 
768     def _eval_subs(self, old, new):
769         # only do substitutions in shape
770         shape = Tuple(*self.shape)._subs(old, new)
771         return MatrixSymbol(self.name, *shape)
772 
773     def __call__(self, *args):
774         raise TypeError("%s object is not callable" % self.__class__)
775 
776     def _entry(self, i, j, **kwargs):
777         return MatrixElement(self, i, j)
778 
779     @property
780     def free_symbols(self):
781         return set((self,))
782 
783     def doit(self, **hints):
784         if hints.get('deep', True):
785             return type(self)(self.name, self.args[1].doit(**hints),
786                     self.args[2].doit(**hints))
787         else:
788             return self
789 
790     def _eval_simplify(self, **kwargs):
791         return self
792 
793     def _eval_derivative_matrix_lines(self, x):
794         if self != x:
795             first = ZeroMatrix(x.shape[0], self.shape[0]) if self.shape[0] != 1 else S.Zero
796             second = ZeroMatrix(x.shape[1], self.shape[1]) if self.shape[1] != 1 else S.Zero
797             return [_LeftRightArgs(
798                 [first, second],
799             )]
800         else:
801             first = Identity(self.shape[0]) if self.shape[0] != 1 else S.One
802             second = Identity(self.shape[1]) if self.shape[1] != 1 else S.One
803             return [_LeftRightArgs(
804                 [first, second],
805             )]
806 
807 
808 class Identity(MatrixExpr):
809     """The Matrix Identity I - multiplicative identity
810 
811     Examples
812     ========
813 
814     >>> from sympy.matrices import Identity, MatrixSymbol
815     >>> A = MatrixSymbol('A', 3, 5)
816     >>> I = Identity(3)
817     >>> I*A
818     A
819     """
820 
821     is_Identity = True
822 
823     def __new__(cls, n):
824         return super(Identity, cls).__new__(cls, _sympify(n))
825 
826     @property
827     def rows(self):
828         return self.args[0]
829 
830     @property
831     def cols(self):
832         return self.args[0]
833 
834     @property
835     def shape(self):
836         return (self.args[0], self.args[0])
837 
838     @property
839     def is_square(self):
840         return True
841 
842     def _eval_transpose(self):
843         return self
844 
845     def _eval_trace(self):
846         return self.rows
847 
848     def _eval_inverse(self):
849         return self
850 
851     def conjugate(self):
852         return self
853 
854     def _entry(self, i, j, **kwargs):
855         eq = Eq(i, j)
856         if eq is S.true:
857             return S.One
858         elif eq is S.false:
859             return S.Zero
860         return KroneckerDelta(i, j)
861 
862     def _eval_determinant(self):
863         return S.One
864 
865 class GenericIdentity(Identity):
866     """
867     An identity matrix without a specified shape
868 
869     This exists primarily so MatMul() with no arguments can return something
870     meaningful.
871     """
872     def __new__(cls):
873         # super(Identity, cls) instead of super(GenericIdentity, cls) because
874         # Identity.__new__ doesn't have the same signature
875         return super(Identity, cls).__new__(cls)
876 
877     @property
878     def rows(self):
879         raise TypeError("GenericIdentity does not have a specified shape")
880 
881     @property
882     def cols(self):
883         raise TypeError("GenericIdentity does not have a specified shape")
884 
885     @property
886     def shape(self):
887         raise TypeError("GenericIdentity does not have a specified shape")
888 
889     # Avoid Matrix.__eq__ which might call .shape
890     def __eq__(self, other):
891         return isinstance(other, GenericIdentity)
892 
893     def __ne__(self, other):
894         return not (self == other)
895 
896     def __hash__(self):
897         return super(GenericIdentity, self).__hash__()
898 
899 
900 class ZeroMatrix(MatrixExpr):
901     """The Matrix Zero 0 - additive identity
902 
903     Examples
904     ========
905 
906     >>> from sympy import MatrixSymbol, ZeroMatrix
907     >>> A = MatrixSymbol('A', 3, 5)
908     >>> Z = ZeroMatrix(3, 5)
909     >>> A + Z
910     A
911     >>> Z*A.T
912     0
913     """
914     is_ZeroMatrix = True
915 
916     def __new__(cls, m, n):
917         return super(ZeroMatrix, cls).__new__(cls, m, n)
918 
919     @property
920     def shape(self):
921         return (self.args[0], self.args[1])
922 
923     @_sympifyit('other', NotImplemented)
924     @call_highest_priority('__rpow__')
925     def __pow__(self, other):
926         if other != 1 and not self.is_square:
927             raise ShapeError("Power of non-square matrix %s" % self)
928         if other == 0:
929             return Identity(self.rows)
930         if other < 1:
931             raise ValueError("Matrix det == 0; not invertible.")
932         return self
933 
934     def _eval_transpose(self):
935         return ZeroMatrix(self.cols, self.rows)
936 
937     def _eval_trace(self):
938         return S.Zero
939 
940     def _eval_determinant(self):
941         return S.Zero
942 
943     def conjugate(self):
944         return self
945 
946     def _entry(self, i, j, **kwargs):
947         return S.Zero
948 
949     def __nonzero__(self):
950         return False
951 
952     __bool__ = __nonzero__
953 
954 
955 class GenericZeroMatrix(ZeroMatrix):
956     """
957     A zero matrix without a specified shape
958 
959     This exists primarily so MatAdd() with no arguments can return something
960     meaningful.
961     """
962     def __new__(cls):
963         # super(ZeroMatrix, cls) instead of super(GenericZeroMatrix, cls)
964         # because ZeroMatrix.__new__ doesn't have the same signature
965         return super(ZeroMatrix, cls).__new__(cls)
966 
967     @property
968     def rows(self):
969         raise TypeError("GenericZeroMatrix does not have a specified shape")
970 
971     @property
972     def cols(self):
973         raise TypeError("GenericZeroMatrix does not have a specified shape")
974 
975     @property
976     def shape(self):
977         raise TypeError("GenericZeroMatrix does not have a specified shape")
978 
979     # Avoid Matrix.__eq__ which might call .shape
980     def __eq__(self, other):
981         return isinstance(other, GenericZeroMatrix)
982 
983     def __ne__(self, other):
984         return not (self == other)
985 
986     def __hash__(self):
987         return super(GenericZeroMatrix, self).__hash__()
988 
989 
990 class OneMatrix(MatrixExpr):
991     """
992     Matrix whose all entries are ones.
993     """
994     def __new__(cls, m, n):
995         obj = super(OneMatrix, cls).__new__(cls, m, n)
996         return obj
997 
998     @property
999     def shape(self):
1000         return self._args
1001 
1002     def as_explicit(self):
1003         from sympy import ImmutableDenseMatrix
1004         return ImmutableDenseMatrix.ones(*self.shape)
1005 
1006     def _eval_transpose(self):
1007         return OneMatrix(self.cols, self.rows)
1008 
1009     def _eval_trace(self):
1010         return S.One*self.rows
1011 
1012     def _eval_determinant(self):
1013         condition = Eq(self.shape[0], 1) & Eq(self.shape[1], 1)
1014         if condition == True:
1015             return S.One
1016         elif condition == False:
1017             return S.Zero
1018         else:
1019             from sympy import Determinant
1020             return Determinant(self)
1021 
1022     def conjugate(self):
1023         return self
1024 
1025     def _entry(self, i, j, **kwargs):
1026         return S.One
1027 
1028 
1029 def matrix_symbols(expr):
1030     return [sym for sym in expr.free_symbols if sym.is_Matrix]
1031 
1032 
1033 class _LeftRightArgs(object):
1034     r"""
1035     Helper class to compute matrix derivatives.
1036 
1037     The logic: when an expression is derived by a matrix `X_{mn}`, two lines of
1038     matrix multiplications are created: the one contracted to `m` (first line),
1039     and the one contracted to `n` (second line).
1040 
1041     Transposition flips the side by which new matrices are connected to the
1042     lines.
1043 
1044     The trace connects the end of the two lines.
1045     """
1046 
1047     def __init__(self, lines, higher=S.One):
1048         self._lines = [i for i in lines]
1049         self._first_pointer_parent = self._lines
1050         self._first_pointer_index = 0
1051         self._first_line_index = 0
1052         self._second_pointer_parent = self._lines
1053         self._second_pointer_index = 1
1054         self._second_line_index = 1
1055         self.higher = higher
1056 
1057     @property
1058     def first_pointer(self):
1059        return self._first_pointer_parent[self._first_pointer_index]
1060 
1061     @first_pointer.setter
1062     def first_pointer(self, value):
1063         self._first_pointer_parent[self._first_pointer_index] = value
1064 
1065     @property
1066     def second_pointer(self):
1067         return self._second_pointer_parent[self._second_pointer_index]
1068 
1069     @second_pointer.setter
1070     def second_pointer(self, value):
1071         self._second_pointer_parent[self._second_pointer_index] = value
1072 
1073     def __repr__(self):
1074         try:
1075             built = [self._build(i) for i in self._lines]
1076         except Exception:
1077             built = self._lines
1078         return "_LeftRightArgs(lines=%s, higher=%s)" % (
1079             built,
1080             self.higher,
1081         )
1082 
1083     def transpose(self):
1084         self._first_pointer_parent, self._second_pointer_parent = self._second_pointer_parent, self._first_pointer_parent
1085         self._first_pointer_index, self._second_pointer_index = self._second_pointer_index, self._first_pointer_index
1086         self._first_line_index, self._second_line_index = self._second_line_index, self._first_line_index
1087         return self
1088 
1089     @staticmethod
1090     def _build(expr):
1091         from sympy.core.expr import ExprBuilder
1092         if isinstance(expr, ExprBuilder):
1093             return expr.build()
1094         if isinstance(expr, list):
1095             if len(expr) == 1:
1096                 return expr[0]
1097             else:
1098                 return expr[0](*[_LeftRightArgs._build(i) for i in expr[1]])
1099         else:
1100             return expr
1101 
1102     def build(self):
1103         data = [self._build(i) for i in self._lines]
1104         if self.higher != 1:
1105             data += [self._build(self.higher)]
1106         data = [i.doit() for i in data]
1107         return data
1108 
1109     def matrix_form(self):
1110         if self.first != 1 and self.higher != 1:
1111             raise ValueError("higher dimensional array cannot be represented")
1112 
1113         def _get_shape(elem):
1114             if isinstance(elem, MatrixExpr):
1115                 return elem.shape
1116             return (None, None)
1117 
1118         if _get_shape(self.first)[1] != _get_shape(self.second)[1]:
1119             # Remove one-dimensional identity matrices:
1120             # (this is needed by `a.diff(a)` where `a` is a vector)
1121             if _get_shape(self.second) == (1, 1):
1122                 return self.first*self.second[0, 0]
1123             if _get_shape(self.first) == (1, 1):
1124                 return self.first[1, 1]*self.second.T
1125             raise ValueError("incompatible shapes")
1126         if self.first != 1:
1127             return self.first*self.second.T
1128         else:
1129             return self.higher
1130 
1131     def rank(self):
1132         """
1133         Number of dimensions different from trivial (warning: not related to
1134         matrix rank).
1135         """
1136         rank = 0
1137         if self.first != 1:
1138             rank += sum([i != 1 for i in self.first.shape])
1139         if self.second != 1:
1140             rank += sum([i != 1 for i in self.second.shape])
1141         if self.higher != 1:
1142             rank += 2
1143         return rank
1144 
1145     def _multiply_pointer(self, pointer, other):
1146         from sympy.core.expr import ExprBuilder
1147         from sympy.codegen.array_utils import CodegenArrayContraction, CodegenArrayTensorProduct
1148 
1149         subexpr = ExprBuilder(
1150             CodegenArrayContraction,
1151             [
1152                 ExprBuilder(
1153                     CodegenArrayTensorProduct,
1154                     [
1155                         pointer,
1156                         other
1157                     ]
1158                 ),
1159                 (1, 2)
1160             ],
1161             validator=CodegenArrayContraction._validate
1162         )
1163 
1164         return subexpr
1165 
1166     def append_first(self, other):
1167         self.first_pointer *= other
1168 
1169     def append_second(self, other):
1170         self.second_pointer *= other
1171 
1172     def __hash__(self):
1173         return hash((self.first, self.second))
1174 
1175     def __eq__(self, other):
1176         if not isinstance(other, _LeftRightArgs):
1177             return False
1178         return (self.first == other.first) and (self.second == other.second)
1179 
1180 
1181 def _make_matrix(x):
1182     from sympy import ImmutableDenseMatrix
1183     if isinstance(x, MatrixExpr):
1184         return x
1185     return ImmutableDenseMatrix([[x]])
1186 
1187 
1188 from .matmul import MatMul
1189 from .matadd import MatAdd
1190 from .matpow import MatPow
1191 from .transpose import Transpose
1192 from .inverse import Inverse

</code><intended_behavior>While the specific presentation enhancements via unicode pretty printing were not directly identified due to the search limitations, it's assumed that within each of these classes, or perhaps through a common superclass or utility module, methods or functionalities might be added or extended to support improved unicode pretty printing. This could involve specifying unicode representations for these matrices and ensuring that these representations are invoked during the pretty-printing process. The goal is to maintain readability and distinction among `ZeroMatrix`, `Identity`, and `OneMatrix` in non-MathML contexts as well.</intended_behavior>]
2025-10-16 02:54:25.709 | INFO     | Search completed. Bug locations: [<file>sympy/printing/mathml.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 A MathML printer.
3 """
4 
5 from __future__ import print_function, division
6 
7 from sympy import sympify, S, Mul
8 from sympy.core.compatibility import range, string_types, default_sort_key
9 from sympy.core.function import _coeff_isneg
10 from sympy.printing.conventions import split_super_sub, requires_partial
11 from sympy.printing.precedence import precedence_traditional, PRECEDENCE
12 from sympy.printing.pretty.pretty_symbology import greek_unicode
13 from sympy.printing.printer import Printer
14 
15 import mpmath.libmp as mlib
16 from mpmath.libmp import prec_to_dps
17 
18 class MathMLPrinterBase(Printer):
19     """Contains common code required for MathMLContentPrinter and
20     MathMLPresentationPrinter.
21     """
22 
23     _default_settings = {
24         "order": None,
25         "encoding": "utf-8",
26         "fold_frac_powers": False,
27         "fold_func_brackets": False,
28         "fold_short_frac": None,
29         "inv_trig_style": "abbreviated",
30         "ln_notation": False,
31         "long_frac_ratio": None,
32         "mat_delim": "[",
33         "mat_symbol_style": "plain",
34         "mul_symbol": None,
35         "root_notation": True,
36         "symbol_names": {},
37         "mul_symbol_mathml_numbers": '&#xB7;',
38     }
39 
40     def __init__(self, settings=None):
41         Printer.__init__(self, settings)
42         from xml.dom.minidom import Document, Text
43 
44         self.dom = Document()
45 
46         # Workaround to allow strings to remain unescaped
47         # Based on
48         # https://stackoverflow.com/questions/38015864/python-xml-dom-minidom-\
49         #                              please-dont-escape-my-strings/38041194
50         class RawText(Text):
51             def writexml(self, writer, indent='', addindent='', newl=''):
52                 if self.data:
53                     writer.write(u'{}{}{}'.format(indent, self.data, newl))
54 
55         def createRawTextNode(data):
56             r = RawText()
57             r.data = data
58             r.ownerDocument = self.dom
59             return r
60 
61         self.dom.createTextNode = createRawTextNode
62 
63     def doprint(self, expr):
64         """
65         Prints the expression as MathML.
66         """
67         mathML = Printer._print(self, expr)
68         unistr = mathML.toxml()
69         xmlbstr = unistr.encode('ascii', 'xmlcharrefreplace')
70         res = xmlbstr.decode()
71         return res
72 
73     def apply_patch(self):
74         # Applying the patch of xml.dom.minidom bug
75         # Date: 2011-11-18
76         # Description: http://ronrothman.com/public/leftbraned/xml-dom-minidom\
77         #                   -toprettyxml-and-silly-whitespace/#best-solution
78         # Issue: http://bugs.python.org/issue4147
79         # Patch: http://hg.python.org/cpython/rev/7262f8f276ff/
80 
81         from xml.dom.minidom import Element, Text, Node, _write_data
82 
83         def writexml(self, writer, indent="", addindent="", newl=""):
84             # indent = current indentation
85             # addindent = indentation to add to higher levels
86             # newl = newline string
87             writer.write(indent + "<" + self.tagName)
88 
89             attrs = self._get_attributes()
90             a_names = list(attrs.keys())
91             a_names.sort()
92 
93             for a_name in a_names:
94                 writer.write(" %s=\"" % a_name)
95                 _write_data(writer, attrs[a_name].value)
96                 writer.write("\"")
97             if self.childNodes:
98                 writer.write(">")
99                 if (len(self.childNodes) == 1 and
100                         self.childNodes[0].nodeType == Node.TEXT_NODE):
101                     self.childNodes[0].writexml(writer, '', '', '')
102                 else:
103                     writer.write(newl)
104                     for node in self.childNodes:
105                         node.writexml(
106                             writer, indent + addindent, addindent, newl)
107                     writer.write(indent)
108                 writer.write("</%s>%s" % (self.tagName, newl))
109             else:
110                 writer.write("/>%s" % (newl))
111         self._Element_writexml_old = Element.writexml
112         Element.writexml = writexml
113 
114         def writexml(self, writer, indent="", addindent="", newl=""):
115             _write_data(writer, "%s%s%s" % (indent, self.data, newl))
116         self._Text_writexml_old = Text.writexml
117         Text.writexml = writexml
118 
119     def restore_patch(self):
120         from xml.dom.minidom import Element, Text
121         Element.writexml = self._Element_writexml_old
122         Text.writexml = self._Text_writexml_old
123 
124 
125 class MathMLContentPrinter(MathMLPrinterBase):
126     """Prints an expression to the Content MathML markup language.
127 
128     References: https://www.w3.org/TR/MathML2/chapter4.html
129     """
130     printmethod = "_mathml_content"
131 
132     def mathml_tag(self, e):
133         """Returns the MathML tag for an expression."""
134         translate = {
135             'Add': 'plus',
136             'Mul': 'times',
137             'Derivative': 'diff',
138             'Number': 'cn',
139             'int': 'cn',
140             'Pow': 'power',
141             'Symbol': 'ci',
142             'MatrixSymbol': 'ci',
143             'RandomSymbol': 'ci',
144             'Integral': 'int',
145             'Sum': 'sum',
146             'sin': 'sin',
147             'cos': 'cos',
148             'tan': 'tan',
149             'cot': 'cot',
150             'asin': 'arcsin',
151             'asinh': 'arcsinh',
152             'acos': 'arccos',
153             'acosh': 'arccosh',
154             'atan': 'arctan',
155             'atanh': 'arctanh',
156             'acot': 'arccot',
157             'atan2': 'arctan',
158             'log': 'ln',
159             'Equality': 'eq',
160             'Unequality': 'neq',
161             'GreaterThan': 'geq',
162             'LessThan': 'leq',
163             'StrictGreaterThan': 'gt',
164             'StrictLessThan': 'lt',
165         }
166 
167         for cls in e.__class__.__mro__:
168             n = cls.__name__
169             if n in translate:
170                 return translate[n]
171         # Not found in the MRO set
172         n = e.__class__.__name__
173         return n.lower()
174 
175     def _print_Mul(self, expr):
176 
177         if _coeff_isneg(expr):
178             x = self.dom.createElement('apply')
179             x.appendChild(self.dom.createElement('minus'))
180             x.appendChild(self._print_Mul(-expr))
181             return x
182 
183         from sympy.simplify import fraction
184         numer, denom = fraction(expr)
185 
186         if denom is not S.One:
187             x = self.dom.createElement('apply')
188             x.appendChild(self.dom.createElement('divide'))
189             x.appendChild(self._print(numer))
190             x.appendChild(self._print(denom))
191             return x
192 
193         coeff, terms = expr.as_coeff_mul()
194         if coeff is S.One and len(terms) == 1:
195             # XXX since the negative coefficient has been handled, I don't
196             # think a coeff of 1 can remain
197             return self._print(terms[0])
198 
199         if self.order != 'old':
200             terms = Mul._from_args(terms).as_ordered_factors()
201 
202         x = self.dom.createElement('apply')
203         x.appendChild(self.dom.createElement('times'))
204         if coeff != 1:
205             x.appendChild(self._print(coeff))
206         for term in terms:
207             x.appendChild(self._print(term))
208         return x
209 
210     def _print_Add(self, expr, order=None):
211         args = self._as_ordered_terms(expr, order=order)
212         lastProcessed = self._print(args[0])
213         plusNodes = []
214         for arg in args[1:]:
215             if _coeff_isneg(arg):
216                 # use minus
217                 x = self.dom.createElement('apply')
218                 x.appendChild(self.dom.createElement('minus'))
219                 x.appendChild(lastProcessed)
220                 x.appendChild(self._print(-arg))
221                 # invert expression since this is now minused
222                 lastProcessed = x
223                 if arg == args[-1]:
224                     plusNodes.append(lastProcessed)
225             else:
226                 plusNodes.append(lastProcessed)
227                 lastProcessed = self._print(arg)
228                 if arg == args[-1]:
229                     plusNodes.append(self._print(arg))
230         if len(plusNodes) == 1:
231             return lastProcessed
232         x = self.dom.createElement('apply')
233         x.appendChild(self.dom.createElement('plus'))
234         while plusNodes:
235             x.appendChild(plusNodes.pop(0))
236         return x
237 
238     def _print_MatrixBase(self, m):
239         x = self.dom.createElement('matrix')
240         for i in range(m.rows):
241             x_r = self.dom.createElement('matrixrow')
242             for j in range(m.cols):
243                 x_r.appendChild(self._print(m[i, j]))
244             x.appendChild(x_r)
245         return x
246 
247     def _print_Rational(self, e):
248         if e.q == 1:
249             # don't divide
250             x = self.dom.createElement('cn')
251             x.appendChild(self.dom.createTextNode(str(e.p)))
252             return x
253         x = self.dom.createElement('apply')
254         x.appendChild(self.dom.createElement('divide'))
255         # numerator
256         xnum = self.dom.createElement('cn')
257         xnum.appendChild(self.dom.createTextNode(str(e.p)))
258         # denominator
259         xdenom = self.dom.createElement('cn')
260         xdenom.appendChild(self.dom.createTextNode(str(e.q)))
261         x.appendChild(xnum)
262         x.appendChild(xdenom)
263         return x
264 
265     def _print_Limit(self, e):
266         x = self.dom.createElement('apply')
267         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
268 
269         x_1 = self.dom.createElement('bvar')
270         x_2 = self.dom.createElement('lowlimit')
271         x_1.appendChild(self._print(e.args[1]))
272         x_2.appendChild(self._print(e.args[2]))
273 
274         x.appendChild(x_1)
275         x.appendChild(x_2)
276         x.appendChild(self._print(e.args[0]))
277         return x
278 
279     def _print_ImaginaryUnit(self, e):
280         return self.dom.createElement('imaginaryi')
281 
282     def _print_EulerGamma(self, e):
283         return self.dom.createElement('eulergamma')
284 
285     def _print_GoldenRatio(self, e):
286         """We use unicode #x3c6 for Greek letter phi as defined here
287         http://www.w3.org/2003/entities/2007doc/isogrk1.html"""
288         x = self.dom.createElement('cn')
289         x.appendChild(self.dom.createTextNode(u"\N{GREEK SMALL LETTER PHI}"))
290         return x
291 
292     def _print_Exp1(self, e):
293         return self.dom.createElement('exponentiale')
294 
295     def _print_Pi(self, e):
296         return self.dom.createElement('pi')
297 
298     def _print_Infinity(self, e):
299         return self.dom.createElement('infinity')
300 
301     def _print_NegativeInfinity(self, e):
302         x = self.dom.createElement('apply')
303         x.appendChild(self.dom.createElement('minus'))
304         x.appendChild(self.dom.createElement('infinity'))
305         return x
306 
307     def _print_Integral(self, e):
308         def lime_recur(limits):
309             x = self.dom.createElement('apply')
310             x.appendChild(self.dom.createElement(self.mathml_tag(e)))
311             bvar_elem = self.dom.createElement('bvar')
312             bvar_elem.appendChild(self._print(limits[0][0]))
313             x.appendChild(bvar_elem)
314 
315             if len(limits[0]) == 3:
316                 low_elem = self.dom.createElement('lowlimit')
317                 low_elem.appendChild(self._print(limits[0][1]))
318                 x.appendChild(low_elem)
319                 up_elem = self.dom.createElement('uplimit')
320                 up_elem.appendChild(self._print(limits[0][2]))
321                 x.appendChild(up_elem)
322             if len(limits[0]) == 2:
323                 up_elem = self.dom.createElement('uplimit')
324                 up_elem.appendChild(self._print(limits[0][1]))
325                 x.appendChild(up_elem)
326             if len(limits) == 1:
327                 x.appendChild(self._print(e.function))
328             else:
329                 x.appendChild(lime_recur(limits[1:]))
330             return x
331 
332         limits = list(e.limits)
333         limits.reverse()
334         return lime_recur(limits)
335 
336     def _print_Sum(self, e):
337         # Printer can be shared because Sum and Integral have the
338         # same internal representation.
339         return self._print_Integral(e)
340 
341     def _print_Symbol(self, sym):
342         ci = self.dom.createElement(self.mathml_tag(sym))
343 
344         def join(items):
345             if len(items) > 1:
346                 mrow = self.dom.createElement('mml:mrow')
347                 for i, item in enumerate(items):
348                     if i > 0:
349                         mo = self.dom.createElement('mml:mo')
350                         mo.appendChild(self.dom.createTextNode(" "))
351                         mrow.appendChild(mo)
352                     mi = self.dom.createElement('mml:mi')
353                     mi.appendChild(self.dom.createTextNode(item))
354                     mrow.appendChild(mi)
355                 return mrow
356             else:
357                 mi = self.dom.createElement('mml:mi')
358                 mi.appendChild(self.dom.createTextNode(items[0]))
359                 return mi
360 
361         # translate name, supers and subs to unicode characters
362         def translate(s):
363             if s in greek_unicode:
364                 return greek_unicode.get(s)
365             else:
366                 return s
367 
368         name, supers, subs = split_super_sub(sym.name)
369         name = translate(name)
370         supers = [translate(sup) for sup in supers]
371         subs = [translate(sub) for sub in subs]
372 
373         mname = self.dom.createElement('mml:mi')
374         mname.appendChild(self.dom.createTextNode(name))
375         if not supers:
376             if not subs:
377                 ci.appendChild(self.dom.createTextNode(name))
378             else:
379                 msub = self.dom.createElement('mml:msub')
380                 msub.appendChild(mname)
381                 msub.appendChild(join(subs))
382                 ci.appendChild(msub)
383         else:
384             if not subs:
385                 msup = self.dom.createElement('mml:msup')
386                 msup.appendChild(mname)
387                 msup.appendChild(join(supers))
388                 ci.appendChild(msup)
389             else:
390                 msubsup = self.dom.createElement('mml:msubsup')
391                 msubsup.appendChild(mname)
392                 msubsup.appendChild(join(subs))
393                 msubsup.appendChild(join(supers))
394                 ci.appendChild(msubsup)
395         return ci
396 
397     _print_MatrixSymbol = _print_Symbol
398     _print_RandomSymbol = _print_Symbol
399 
400     def _print_Pow(self, e):
401         # Here we use root instead of power if the exponent is the reciprocal
402         # of an integer
403         if (self._settings['root_notation'] and e.exp.is_Rational
404                 and e.exp.p == 1):
405             x = self.dom.createElement('apply')
406             x.appendChild(self.dom.createElement('root'))
407             if e.exp.q != 2:
408                 xmldeg = self.dom.createElement('degree')
409                 xmlci = self.dom.createElement('ci')
410                 xmlci.appendChild(self.dom.createTextNode(str(e.exp.q)))
411                 xmldeg.appendChild(xmlci)
412                 x.appendChild(xmldeg)
413             x.appendChild(self._print(e.base))
414             return x
415 
416         x = self.dom.createElement('apply')
417         x_1 = self.dom.createElement(self.mathml_tag(e))
418         x.appendChild(x_1)
419         x.appendChild(self._print(e.base))
420         x.appendChild(self._print(e.exp))
421         return x
422 
423     def _print_Number(self, e):
424         x = self.dom.createElement(self.mathml_tag(e))
425         x.appendChild(self.dom.createTextNode(str(e)))
426         return x
427 
428     def _print_Derivative(self, e):
429         x = self.dom.createElement('apply')
430         diff_symbol = self.mathml_tag(e)
431         if requires_partial(e):
432             diff_symbol = 'partialdiff'
433         x.appendChild(self.dom.createElement(diff_symbol))
434         x_1 = self.dom.createElement('bvar')
435 
436         for sym, times in reversed(e.variable_count):
437             x_1.appendChild(self._print(sym))
438             if times > 1:
439                 degree = self.dom.createElement('degree')
440                 degree.appendChild(self._print(sympify(times)))
441                 x_1.appendChild(degree)
442 
443         x.appendChild(x_1)
444         x.appendChild(self._print(e.expr))
445         return x
446 
447     def _print_Function(self, e):
448         x = self.dom.createElement("apply")
449         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
450         for arg in e.args:
451             x.appendChild(self._print(arg))
452         return x
453 
454     def _print_Basic(self, e):
455         x = self.dom.createElement(self.mathml_tag(e))
456         for arg in e.args:
457             x.appendChild(self._print(arg))
458         return x
459 
460     def _print_AssocOp(self, e):
461         x = self.dom.createElement('apply')
462         x_1 = self.dom.createElement(self.mathml_tag(e))
463         x.appendChild(x_1)
464         for arg in e.args:
465             x.appendChild(self._print(arg))
466         return x
467 
468     def _print_Relational(self, e):
469         x = self.dom.createElement('apply')
470         x.appendChild(self.dom.createElement(self.mathml_tag(e)))
471         x.appendChild(self._print(e.lhs))
472         x.appendChild(self._print(e.rhs))
473         return x
474 
475     def _print_list(self, seq):
476         """MathML reference for the <list> element:
477         http://www.w3.org/TR/MathML2/chapter4.html#contm.list"""
478         dom_element = self.dom.createElement('list')
479         for item in seq:
480             dom_element.appendChild(self._print(item))
481         return dom_element
482 
483     def _print_int(self, p):
484         dom_element = self.dom.createElement(self.mathml_tag(p))
485         dom_element.appendChild(self.dom.createTextNode(str(p)))
486         return dom_element
487 
488 
489 class MathMLPresentationPrinter(MathMLPrinterBase):
490     """Prints an expression to the Presentation MathML markup language.
491 
492     References: https://www.w3.org/TR/MathML2/chapter3.html
493     """
494     printmethod = "_mathml_presentation"
495 
496     def mathml_tag(self, e):
497         """Returns the MathML tag for an expression."""
498         translate = {
499             'Number': 'mn',
500             'Limit': '&#x2192;',
501             'Derivative': '&dd;',
502             'int': 'mn',
503             'Symbol': 'mi',
504             'Integral': '&int;',
505             'Sum': '&#x2211;',
506             'sin': 'sin',
507             'cos': 'cos',
508             'tan': 'tan',
509             'cot': 'cot',
510             'asin': 'arcsin',
511             'asinh': 'arcsinh',
512             'acos': 'arccos',
513             'acosh': 'arccosh',
514             'atan': 'arctan',
515             'atanh': 'arctanh',
516             'acot': 'arccot',
517             'atan2': 'arctan',
518             'Equality': '=',
519             'Unequality': '&#x2260;',
520             'GreaterThan': '&#x2265;',
521             'LessThan': '&#x2264;',
522             'StrictGreaterThan': '>',
523             'StrictLessThan': '<',
524             'lerchphi': '&#x3A6;',
525             'zeta': '&#x3B6;',
526             'dirichlet_eta': '&#x3B7;',
527             'elliptic_k': '&#x39A;',
528             'lowergamma': '&#x3B3;',
529             'uppergamma': '&#x393;',
530             'gamma': '&#x393;',
531             'totient': '&#x3D5;',
532             'reduced_totient': '&#x3BB;',
533             'primenu': '&#x3BD;',
534             'primeomega': '&#x3A9;',
535             'fresnels': 'S',
536             'fresnelc': 'C',
537             'Heaviside': '&#x398;',
538             'BooleanTrue': 'True',
539             'BooleanFalse': 'False',
540             'NoneType': 'None',
541         }
542 
543         def mul_symbol_selection():
544             if (self._settings["mul_symbol"] is None or
545                     self._settings["mul_symbol"] == 'None'):
546                 return '&InvisibleTimes;'
547             elif self._settings["mul_symbol"] == 'times':
548                 return '&#xD7;'
549             elif self._settings["mul_symbol"] == 'dot':
550                 return '&#xB7;'
551             elif self._settings["mul_symbol"] == 'ldot':
552                 return '&#x2024;'
553             elif not isinstance(self._settings["mul_symbol"], string_types):
554                 raise TypeError
555             else:
556                 return self._settings["mul_symbol"]
557         for cls in e.__class__.__mro__:
558             n = cls.__name__
559             if n in translate:
560                 return translate[n]
561         # Not found in the MRO set
562         if e.__class__.__name__ == "Mul":
563             return mul_symbol_selection()
564         n = e.__class__.__name__
565         return n.lower()
566 
567     def parenthesize(self, item, level, strict=False):
568         prec_val = precedence_traditional(item)
569         if (prec_val < level) or ((not strict) and prec_val <= level):
570             brac = self.dom.createElement('mfenced')
571             brac.appendChild(self._print(item))
572             return brac
573         else:
574             return self._print(item)
575 
576     def _print_Mul(self, expr):
577 
578         def multiply(expr, mrow):
579             from sympy.simplify import fraction
580             numer, denom = fraction(expr)
581             if denom is not S.One:
582                 frac = self.dom.createElement('mfrac')
583                 if self._settings["fold_short_frac"] and len(str(expr)) < 7:
584                     frac.setAttribute('bevelled', 'true')
585                 xnum = self._print(numer)
586                 xden = self._print(denom)
587                 frac.appendChild(xnum)
588                 frac.appendChild(xden)
589                 mrow.appendChild(frac)
590                 return mrow
591 
592             coeff, terms = expr.as_coeff_mul()
593             if coeff is S.One and len(terms) == 1:
594                 mrow.appendChild(self._print(terms[0]))
595                 return mrow
596             if self.order != 'old':
597                 terms = Mul._from_args(terms).as_ordered_factors()
598 
599             if coeff != 1:
600                 x = self._print(coeff)
601                 y = self.dom.createElement('mo')
602                 y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
603                 mrow.appendChild(x)
604                 mrow.appendChild(y)
605             for term in terms:
606                 x = self._print(term)
607                 mrow.appendChild(x)
608                 if not term == terms[-1]:
609                     y = self.dom.createElement('mo')
610                     y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))
611                     mrow.appendChild(y)
612             return mrow
613         mrow = self.dom.createElement('mrow')
614         if _coeff_isneg(expr):
615             x = self.dom.createElement('mo')
616             x.appendChild(self.dom.createTextNode('-'))
617             mrow.appendChild(x)
618             mrow = multiply(-expr, mrow)
619         else:
620             mrow = multiply(expr, mrow)
621 
622         return mrow
623 
624     def _print_Add(self, expr, order=None):
625         mrow = self.dom.createElement('mrow')
626         args = self._as_ordered_terms(expr, order=order)
627         mrow.appendChild(self._print(args[0]))
628         for arg in args[1:]:
629             if _coeff_isneg(arg):
630                 # use minus
631                 x = self.dom.createElement('mo')
632                 x.appendChild(self.dom.createTextNode('-'))
633                 y = self._print(-arg)
634                 # invert expression since this is now minused
635             else:
636                 x = self.dom.createElement('mo')
637                 x.appendChild(self.dom.createTextNode('+'))
638                 y = self._print(arg)
639             mrow.appendChild(x)
640             mrow.appendChild(y)
641 
642         return mrow
643 
644     def _print_MatrixBase(self, m):
645         table = self.dom.createElement('mtable')
646         for i in range(m.rows):
647             x = self.dom.createElement('mtr')
648             for j in range(m.cols):
649                 y = self.dom.createElement('mtd')
650                 y.appendChild(self._print(m[i, j]))
651                 x.appendChild(y)
652             table.appendChild(x)
653         if self._settings["mat_delim"] == '':
654             return table
655         brac = self.dom.createElement('mfenced')
656         if self._settings["mat_delim"] == "[":
657             brac.setAttribute('open', '[')
658             brac.setAttribute('close', ']')
659         brac.appendChild(table)
660         return brac
661 
662     def _get_printed_Rational(self, e, folded=None):
663         if e.p < 0:
664             p = -e.p
665         else:
666             p = e.p
667         x = self.dom.createElement('mfrac')
668         if folded or self._settings["fold_short_frac"]:
669             x.setAttribute('bevelled', 'true')
670         x.appendChild(self._print(p))
671         x.appendChild(self._print(e.q))
672         if e.p < 0:
673             mrow = self.dom.createElement('mrow')
674             mo = self.dom.createElement('mo')
675             mo.appendChild(self.dom.createTextNode('-'))
676             mrow.appendChild(mo)
677             mrow.appendChild(x)
678             return mrow
679         else:
680             return x
681 
682     def _print_Rational(self, e):
683         if e.q == 1:
684             # don't divide
685             return self._print(e.p)
686 
687         return self._get_printed_Rational(e, self._settings["fold_short_frac"])
688 
689     def _print_Limit(self, e):
690         mrow = self.dom.createElement('mrow')
691         munder = self.dom.createElement('munder')
692         mi = self.dom.createElement('mi')
693         mi.appendChild(self.dom.createTextNode('lim'))
694 
695         x = self.dom.createElement('mrow')
696         x_1 = self._print(e.args[1])
697         arrow = self.dom.createElement('mo')
698         arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
699         x_2 = self._print(e.args[2])
700         x.appendChild(x_1)
701         x.appendChild(arrow)
702         x.appendChild(x_2)
703 
704         munder.appendChild(mi)
705         munder.appendChild(x)
706         mrow.appendChild(munder)
707         mrow.appendChild(self._print(e.args[0]))
708 
709         return mrow
710 
711     def _print_ImaginaryUnit(self, e):
712         x = self.dom.createElement('mi')
713         x.appendChild(self.dom.createTextNode('&ImaginaryI;'))
714         return x
715 
716     def _print_GoldenRatio(self, e):
717         x = self.dom.createElement('mi')
718         x.appendChild(self.dom.createTextNode('&#x3A6;'))
719         return x
720 
721     def _print_Exp1(self, e):
722         x = self.dom.createElement('mi')
723         x.appendChild(self.dom.createTextNode('&ExponentialE;'))
724         return x
725 
726     def _print_Pi(self, e):
727         x = self.dom.createElement('mi')
728         x.appendChild(self.dom.createTextNode('&pi;'))
729         return x
730 
731     def _print_Infinity(self, e):
732         x = self.dom.createElement('mi')
733         x.appendChild(self.dom.createTextNode('&#x221E;'))
734         return x
735 
736     def _print_NegativeInfinity(self, e):
737         mrow = self.dom.createElement('mrow')
738         y = self.dom.createElement('mo')
739         y.appendChild(self.dom.createTextNode('-'))
740         x = self._print_Infinity(e)
741         mrow.appendChild(y)
742         mrow.appendChild(x)
743         return mrow
744 
745     def _print_Integral(self, expr):
746         intsymbols = {1: "&#x222B;", 2: "&#x222C;", 3: "&#x222D;"}
747 
748         mrow = self.dom.createElement('mrow')
749         if len(expr.limits) <= 3 and all(len(lim) == 1 for lim in expr.limits):
750             # Only up to three-integral signs exists
751             mo = self.dom.createElement('mo')
752             mo.appendChild(self.dom.createTextNode(intsymbols[len(expr.limits)]))
753             mrow.appendChild(mo)
754         else:
755             # Either more than three or limits provided
756             for lim in reversed(expr.limits):
757                 mo = self.dom.createElement('mo')
758                 mo.appendChild(self.dom.createTextNode(intsymbols[1]))
759                 if len(lim) == 1:
760                     mrow.appendChild(mo)
761                 if len(lim) == 2:
762                     msup = self.dom.createElement('msup')
763                     msup.appendChild(mo)
764                     msup.appendChild(self._print(lim[1]))
765                     mrow.appendChild(msup)
766                 if len(lim) == 3:
767                     msubsup = self.dom.createElement('msubsup')
768                     msubsup.appendChild(mo)
769                     msubsup.appendChild(self._print(lim[1]))
770                     msubsup.appendChild(self._print(lim[2]))
771                     mrow.appendChild(msubsup)
772         # print function
773         mrow.appendChild(self.parenthesize(expr.function, PRECEDENCE["Mul"],
774                                            strict=True))
775         # print integration variables
776         for lim in reversed(expr.limits):
777             d = self.dom.createElement('mo')
778             d.appendChild(self.dom.createTextNode('&dd;'))
779             mrow.appendChild(d)
780             mrow.appendChild(self._print(lim[0]))
781         return mrow
782 
783     def _print_Sum(self, e):
784         limits = list(e.limits)
785         subsup = self.dom.createElement('munderover')
786         low_elem = self._print(limits[0][1])
787         up_elem = self._print(limits[0][2])
788         summand = self.dom.createElement('mo')
789         summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
790 
791         low = self.dom.createElement('mrow')
792         var = self._print(limits[0][0])
793         equal = self.dom.createElement('mo')
794         equal.appendChild(self.dom.createTextNode('='))
795         low.appendChild(var)
796         low.appendChild(equal)
797         low.appendChild(low_elem)
798 
799         subsup.appendChild(summand)
800         subsup.appendChild(low)
801         subsup.appendChild(up_elem)
802 
803         mrow = self.dom.createElement('mrow')
804         mrow.appendChild(subsup)
805         if len(str(e.function)) == 1:
806             mrow.appendChild(self._print(e.function))
807         else:
808             fence = self.dom.createElement('mfenced')
809             fence.appendChild(self._print(e.function))
810             mrow.appendChild(fence)
811 
812         return mrow
813 
814     def _print_Symbol(self, sym, style='plain'):
815         def join(items):
816             if len(items) > 1:
817                 mrow = self.dom.createElement('mrow')
818                 for i, item in enumerate(items):
819                     if i > 0:
820                         mo = self.dom.createElement('mo')
821                         mo.appendChild(self.dom.createTextNode(" "))
822                         mrow.appendChild(mo)
823                     mi = self.dom.createElement('mi')
824                     mi.appendChild(self.dom.createTextNode(item))
825                     mrow.appendChild(mi)
826                 return mrow
827             else:
828                 mi = self.dom.createElement('mi')
829                 mi.appendChild(self.dom.createTextNode(items[0]))
830                 return mi
831 
832         # translate name, supers and subs to unicode characters
833         def translate(s):
834             if s in greek_unicode:
835                 return greek_unicode.get(s)
836             else:
837                 return s
838 
839         name, supers, subs = split_super_sub(sym.name)
840         name = translate(name)
841         supers = [translate(sup) for sup in supers]
842         subs = [translate(sub) for sub in subs]
843 
844         mname = self.dom.createElement('mi')
845         mname.appendChild(self.dom.createTextNode(name))
846         if len(supers) == 0:
847             if len(subs) == 0:
848                 x = mname
849             else:
850                 x = self.dom.createElement('msub')
851                 x.appendChild(mname)
852                 x.appendChild(join(subs))
853         else:
854             if len(subs) == 0:
855                 x = self.dom.createElement('msup')
856                 x.appendChild(mname)
857                 x.appendChild(join(supers))
858             else:
859                 x = self.dom.createElement('msubsup')
860                 x.appendChild(mname)
861                 x.appendChild(join(subs))
862                 x.appendChild(join(supers))
863         # Set bold font?
864         if style == 'bold':
865             x.setAttribute('mathvariant', 'bold')
866         return x
867 
868     def _print_MatrixSymbol(self, sym):
869         return self._print_Symbol(sym,
870                                   style=self._settings['mat_symbol_style'])
871 
872     _print_RandomSymbol = _print_Symbol
873 
874     def _print_conjugate(self, expr):
875         enc = self.dom.createElement('menclose')
876         enc.setAttribute('notation', 'top')
877         enc.appendChild(self._print(expr.args[0]))
878         return enc
879 
880     def _print_operator_after(self, op, expr):
881         row = self.dom.createElement('mrow')
882         row.appendChild(self.parenthesize(expr, PRECEDENCE["Func"]))
883         mo = self.dom.createElement('mo')
884         mo.appendChild(self.dom.createTextNode(op))
885         row.appendChild(mo)
886         return row
887 
888     def _print_factorial(self, expr):
889         return self._print_operator_after('!', expr.args[0])
890 
891     def _print_factorial2(self, expr):
892         return self._print_operator_after('!!', expr.args[0])
893 
894     def _print_binomial(self, expr):
895         brac = self.dom.createElement('mfenced')
896         frac = self.dom.createElement('mfrac')
897         frac.setAttribute('linethickness', '0')
898         frac.appendChild(self._print(expr.args[0]))
899         frac.appendChild(self._print(expr.args[1]))
900         brac.appendChild(frac)
901         return brac
902 
903     def _print_Pow(self, e):
904         # Here we use root instead of power if the exponent is the
905         # reciprocal of an integer
906         if (e.exp.is_Rational and abs(e.exp.p) == 1 and e.exp.q != 1 and
907                 self._settings['root_notation']):
908             if e.exp.q == 2:
909                 x = self.dom.createElement('msqrt')
910                 x.appendChild(self._print(e.base))
911             if e.exp.q != 2:
912                 x = self.dom.createElement('mroot')
913                 x.appendChild(self._print(e.base))
914                 x.appendChild(self._print(e.exp.q))
915             if e.exp.p == -1:
916                 frac = self.dom.createElement('mfrac')
917                 frac.appendChild(self._print(1))
918                 frac.appendChild(x)
919                 return frac
920             else:
921                 return x
922 
923         if e.exp.is_Rational and e.exp.q != 1:
924             if e.exp.is_negative:
925                 top = self.dom.createElement('mfrac')
926                 top.appendChild(self._print(1))
927                 x = self.dom.createElement('msup')
928                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
929                 x.appendChild(self._get_printed_Rational(-e.exp,
930                                     self._settings['fold_frac_powers']))
931                 top.appendChild(x)
932                 return top
933             else:
934                 x = self.dom.createElement('msup')
935                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
936                 x.appendChild(self._get_printed_Rational(e.exp,
937                                     self._settings['fold_frac_powers']))
938                 return x
939 
940         if e.exp.is_negative:
941                 top = self.dom.createElement('mfrac')
942                 top.appendChild(self._print(1))
943                 if e.exp == -1:
944                     top.appendChild(self._print(e.base))
945                 else:
946                     x = self.dom.createElement('msup')
947                     x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
948                     x.appendChild(self._print(-e.exp))
949                     top.appendChild(x)
950                 return top
951 
952         x = self.dom.createElement('msup')
953         x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))
954         x.appendChild(self._print(e.exp))
955         return x
956 
957     def _print_Number(self, e):
958         x = self.dom.createElement(self.mathml_tag(e))
959         x.appendChild(self.dom.createTextNode(str(e)))
960         return x
961 
962     def _print_AccumulationBounds(self, i):
963         brac = self.dom.createElement('mfenced')
964         brac.setAttribute('open', u'\u27e8')
965         brac.setAttribute('close', u'\u27e9')
966         brac.appendChild(self._print(i.min))
967         brac.appendChild(self._print(i.max))
968         return brac
969 
970     def _print_Derivative(self, e):
971 
972         if requires_partial(e):
973             d = '&#x2202;'
974         else:
975             d = self.mathml_tag(e)
976 
977         # Determine denominator
978         m = self.dom.createElement('mrow')
979         dim = 0  # Total diff dimension, for numerator
980         for sym, num in reversed(e.variable_count):
981             dim += num
982             if num >= 2:
983                 x = self.dom.createElement('msup')
984                 xx = self.dom.createElement('mo')
985                 xx.appendChild(self.dom.createTextNode(d))
986                 x.appendChild(xx)
987                 x.appendChild(self._print(num))
988             else:
989                 x = self.dom.createElement('mo')
990                 x.appendChild(self.dom.createTextNode(d))
991             m.appendChild(x)
992             y = self._print(sym)
993             m.appendChild(y)
994 
995         mnum = self.dom.createElement('mrow')
996         if dim >= 2:
997             x = self.dom.createElement('msup')
998             xx = self.dom.createElement('mo')
999             xx.appendChild(self.dom.createTextNode(d))
1000             x.appendChild(xx)
1001             x.appendChild(self._print(dim))
1002         else:
1003             x = self.dom.createElement('mo')
1004             x.appendChild(self.dom.createTextNode(d))
1005 
1006         mnum.appendChild(x)
1007         mrow = self.dom.createElement('mrow')
1008         frac = self.dom.createElement('mfrac')
1009         frac.appendChild(mnum)
1010         frac.appendChild(m)
1011         mrow.appendChild(frac)
1012 
1013         # Print function
1014         mrow.appendChild(self._print(e.expr))
1015 
1016         return mrow
1017 
1018     def _print_Function(self, e):
1019         mrow = self.dom.createElement('mrow')
1020         x = self.dom.createElement('mi')
1021         if self.mathml_tag(e) == 'log' and self._settings["ln_notation"]:
1022             x.appendChild(self.dom.createTextNode('ln'))
1023         else:
1024             x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1025         y = self.dom.createElement('mfenced')
1026         for arg in e.args:
1027             y.appendChild(self._print(arg))
1028         mrow.appendChild(x)
1029         mrow.appendChild(y)
1030         return mrow
1031 
1032     def _print_Float(self, expr):
1033         # Based off of that in StrPrinter
1034         dps = prec_to_dps(expr._prec)
1035         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
1036 
1037         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
1038         # thus we use the number separator
1039         separator = self._settings['mul_symbol_mathml_numbers']
1040         mrow = self.dom.createElement('mrow')
1041         if 'e' in str_real:
1042             (mant, exp) = str_real.split('e')
1043 
1044             if exp[0] == '+':
1045                 exp = exp[1:]
1046 
1047             mn = self.dom.createElement('mn')
1048             mn.appendChild(self.dom.createTextNode(mant))
1049             mrow.appendChild(mn)
1050             mo = self.dom.createElement('mo')
1051             mo.appendChild(self.dom.createTextNode(separator))
1052             mrow.appendChild(mo)
1053             msup = self.dom.createElement('msup')
1054             mn = self.dom.createElement('mn')
1055             mn.appendChild(self.dom.createTextNode("10"))
1056             msup.appendChild(mn)
1057             mn = self.dom.createElement('mn')
1058             mn.appendChild(self.dom.createTextNode(exp))
1059             msup.appendChild(mn)
1060             mrow.appendChild(msup)
1061             return mrow
1062         elif str_real == "+inf":
1063             return self._print_Infinity(None)
1064         elif str_real == "-inf":
1065             return self._print_NegativeInfinity(None)
1066         else:
1067             mn = self.dom.createElement('mn')
1068             mn.appendChild(self.dom.createTextNode(str_real))
1069             return mn
1070 
1071     def _print_polylog(self, expr):
1072         mrow = self.dom.createElement('mrow')
1073         m = self.dom.createElement('msub')
1074 
1075         mi = self.dom.createElement('mi')
1076         mi.appendChild(self.dom.createTextNode('Li'))
1077         m.appendChild(mi)
1078         m.appendChild(self._print(expr.args[0]))
1079         mrow.appendChild(m)
1080         brac = self.dom.createElement('mfenced')
1081         brac.appendChild(self._print(expr.args[1]))
1082         mrow.appendChild(brac)
1083         return mrow
1084 
1085     def _print_Basic(self, e):
1086         mrow = self.dom.createElement('mrow')
1087         mi = self.dom.createElement('mi')
1088         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1089         mrow.appendChild(mi)
1090         brac = self.dom.createElement('mfenced')
1091         for arg in e.args:
1092             brac.appendChild(self._print(arg))
1093         mrow.appendChild(brac)
1094         return mrow
1095 
1096     def _print_Tuple(self, e):
1097         mrow = self.dom.createElement('mrow')
1098         x = self.dom.createElement('mfenced')
1099         for arg in e.args:
1100             x.appendChild(self._print(arg))
1101         mrow.appendChild(x)
1102         return mrow
1103 
1104     def _print_Interval(self, i):
1105         mrow = self.dom.createElement('mrow')
1106         brac = self.dom.createElement('mfenced')
1107         if i.start == i.end:
1108             # Most often, this type of Interval is converted to a FiniteSet
1109             brac.setAttribute('open', '{')
1110             brac.setAttribute('close', '}')
1111             brac.appendChild(self._print(i.start))
1112         else:
1113             if i.left_open:
1114                 brac.setAttribute('open', '(')
1115             else:
1116                 brac.setAttribute('open', '[')
1117 
1118             if i.right_open:
1119                 brac.setAttribute('close', ')')
1120             else:
1121                 brac.setAttribute('close', ']')
1122             brac.appendChild(self._print(i.start))
1123             brac.appendChild(self._print(i.end))
1124 
1125         mrow.appendChild(brac)
1126         return mrow
1127 
1128     def _print_Abs(self, expr, exp=None):
1129         mrow = self.dom.createElement('mrow')
1130         x = self.dom.createElement('mfenced')
1131         x.setAttribute('open', '|')
1132         x.setAttribute('close', '|')
1133         x.appendChild(self._print(expr.args[0]))
1134         mrow.appendChild(x)
1135         return mrow
1136 
1137     _print_Determinant = _print_Abs
1138 
1139     def _print_re_im(self, c, expr):
1140         mrow = self.dom.createElement('mrow')
1141         mi = self.dom.createElement('mi')
1142         mi.setAttribute('mathvariant', 'fraktur')
1143         mi.appendChild(self.dom.createTextNode(c))
1144         mrow.appendChild(mi)
1145         brac = self.dom.createElement('mfenced')
1146         brac.appendChild(self._print(expr))
1147         mrow.appendChild(brac)
1148         return mrow
1149 
1150     def _print_re(self, expr, exp=None):
1151         return self._print_re_im('R', expr.args[0])
1152 
1153     def _print_im(self, expr, exp=None):
1154         return self._print_re_im('I', expr.args[0])
1155 
1156     def _print_AssocOp(self, e):
1157         mrow = self.dom.createElement('mrow')
1158         mi = self.dom.createElement('mi')
1159         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1160         mrow.appendChild(mi)
1161         for arg in e.args:
1162             mrow.appendChild(self._print(arg))
1163         return mrow
1164 
1165     def _print_SetOp(self, expr, symbol):
1166         mrow = self.dom.createElement('mrow')
1167         mrow.appendChild(self._print(expr.args[0]))
1168         for arg in expr.args[1:]:
1169             x = self.dom.createElement('mo')
1170             x.appendChild(self.dom.createTextNode(symbol))
1171             y = self._print(arg)
1172             mrow.appendChild(x)
1173             mrow.appendChild(y)
1174         return mrow
1175 
1176     def _print_Union(self, expr):
1177         return self._print_SetOp(expr, '&#x222A;')
1178 
1179     def _print_Intersection(self, expr):
1180         return self._print_SetOp(expr, '&#x2229;')
1181 
1182     def _print_Complement(self, expr):
1183         return self._print_SetOp(expr, '&#x2216;')
1184 
1185     def _print_SymmetricDifference(self, expr):
1186         return self._print_SetOp(expr, '&#x2206;')
1187 
1188     def _print_FiniteSet(self, s):
1189         return self._print_set(s.args)
1190 
1191     def _print_set(self, s):
1192         items = sorted(s, key=default_sort_key)
1193         brac = self.dom.createElement('mfenced')
1194         brac.setAttribute('open', '{')
1195         brac.setAttribute('close', '}')
1196         for item in items:
1197             brac.appendChild(self._print(item))
1198         return brac
1199 
1200     _print_frozenset = _print_set
1201 
1202     def _print_LogOp(self, args, symbol):
1203         mrow = self.dom.createElement('mrow')
1204         if args[0].is_Boolean and not args[0].is_Not:
1205             brac = self.dom.createElement('mfenced')
1206             brac.appendChild(self._print(args[0]))
1207             mrow.appendChild(brac)
1208         else:
1209             mrow.appendChild(self._print(args[0]))
1210         for arg in args[1:]:
1211             x = self.dom.createElement('mo')
1212             x.appendChild(self.dom.createTextNode(symbol))
1213             if arg.is_Boolean and not arg.is_Not:
1214                 y = self.dom.createElement('mfenced')
1215                 y.appendChild(self._print(arg))
1216             else:
1217                 y = self._print(arg)
1218             mrow.appendChild(x)
1219             mrow.appendChild(y)
1220         return mrow
1221 
1222     def _print_BasisDependent(self, expr):
1223         from sympy.vector import Vector
1224 
1225         if expr == expr.zero:
1226             # Not clear if this is ever called
1227             return self._print(expr.zero)
1228         if isinstance(expr, Vector):
1229             items = expr.separate().items()
1230         else:
1231             items = [(0, expr)]
1232 
1233         mrow = self.dom.createElement('mrow')
1234         for system, vect in items:
1235             inneritems = list(vect.components.items())
1236             inneritems.sort(key = lambda x:x[0].__str__())
1237             for i, (k, v) in enumerate(inneritems):
1238                 if v == 1:
1239                     if i: # No + for first item
1240                         mo = self.dom.createElement('mo')
1241                         mo.appendChild(self.dom.createTextNode('+'))
1242                         mrow.appendChild(mo)
1243                     mrow.appendChild(self._print(k))
1244                 elif v == -1:
1245                     mo = self.dom.createElement('mo')
1246                     mo.appendChild(self.dom.createTextNode('-'))
1247                     mrow.appendChild(mo)
1248                     mrow.appendChild(self._print(k))
1249                 else:
1250                     if i: # No + for first item
1251                         mo = self.dom.createElement('mo')
1252                         mo.appendChild(self.dom.createTextNode('+'))
1253                         mrow.appendChild(mo)
1254                     mbrac = self.dom.createElement('mfenced')
1255                     mbrac.appendChild(self._print(v))
1256                     mrow.appendChild(mbrac)
1257                     mo = self.dom.createElement('mo')
1258                     mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
1259                     mrow.appendChild(mo)
1260                     mrow.appendChild(self._print(k))
1261         return mrow
1262 
1263 
1264     def _print_And(self, expr):
1265         args = sorted(expr.args, key=default_sort_key)
1266         return self._print_LogOp(args, '&#x2227;')
1267 
1268     def _print_Or(self, expr):
1269         args = sorted(expr.args, key=default_sort_key)
1270         return self._print_LogOp(args, '&#x2228;')
1271 
1272     def _print_Xor(self, expr):
1273         args = sorted(expr.args, key=default_sort_key)
1274         return self._print_LogOp(args, '&#x22BB;')
1275 
1276     def _print_Implies(self, expr):
1277         return self._print_LogOp(expr.args, '&#x21D2;')
1278 
1279     def _print_Equivalent(self, expr):
1280         args = sorted(expr.args, key=default_sort_key)
1281         return self._print_LogOp(args, '&#x21D4;')
1282 
1283     def _print_Not(self, e):
1284         mrow = self.dom.createElement('mrow')
1285         mo = self.dom.createElement('mo')
1286         mo.appendChild(self.dom.createTextNode('&#xAC;'))
1287         mrow.appendChild(mo)
1288         if (e.args[0].is_Boolean):
1289             x = self.dom.createElement('mfenced')
1290             x.appendChild(self._print(e.args[0]))
1291         else:
1292             x = self._print(e.args[0])
1293         mrow.appendChild(x)
1294         return mrow
1295 
1296     def _print_bool(self, e):
1297         mi = self.dom.createElement('mi')
1298         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1299         return mi
1300 
1301     _print_BooleanTrue = _print_bool
1302     _print_BooleanFalse = _print_bool
1303 
1304     def _print_NoneType(self, e):
1305         mi = self.dom.createElement('mi')
1306         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1307         return mi
1308 
1309     def _print_Range(self, s):
1310         dots = u"\u2026"
1311         brac = self.dom.createElement('mfenced')
1312         brac.setAttribute('open', '{')
1313         brac.setAttribute('close', '}')
1314 
1315         if s.start.is_infinite:
1316             printset = dots, s[-1] - s.step, s[-1]
1317         elif s.stop.is_infinite:
1318             it = iter(s)
1319             printset = next(it), next(it), dots
1320         elif len(s) > 4:
1321             it = iter(s)
1322             printset = next(it), next(it), dots, s[-1]
1323         else:
1324             printset = tuple(s)
1325 
1326         for el in printset:
1327             if el == dots:
1328                 mi = self.dom.createElement('mi')
1329                 mi.appendChild(self.dom.createTextNode(dots))
1330                 brac.appendChild(mi)
1331             else:
1332                 brac.appendChild(self._print(el))
1333 
1334         return brac
1335 
1336     def _hprint_variadic_function(self, expr):
1337         args = sorted(expr.args, key=default_sort_key)
1338         mrow = self.dom.createElement('mrow')
1339         mo = self.dom.createElement('mo')
1340         mo.appendChild(self.dom.createTextNode((str(expr.func)).lower()))
1341         mrow.appendChild(mo)
1342         brac = self.dom.createElement('mfenced')
1343         for symbol in args:
1344             brac.appendChild(self._print(symbol))
1345         mrow.appendChild(brac)
1346         return mrow
1347 
1348     _print_Min = _print_Max = _hprint_variadic_function
1349 
1350     def _print_exp(self, expr):
1351         msup = self.dom.createElement('msup')
1352         msup.appendChild(self._print_Exp1(None))
1353         msup.appendChild(self._print(expr.args[0]))
1354         return msup
1355 
1356     def _print_Relational(self, e):
1357         mrow = self.dom.createElement('mrow')
1358         mrow.appendChild(self._print(e.lhs))
1359         x = self.dom.createElement('mo')
1360         x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))
1361         mrow.appendChild(x)
1362         mrow.appendChild(self._print(e.rhs))
1363         return mrow
1364 
1365     def _print_int(self, p):
1366         dom_element = self.dom.createElement(self.mathml_tag(p))
1367         dom_element.appendChild(self.dom.createTextNode(str(p)))
1368         return dom_element
1369 
1370     def _print_BaseScalar(self, e):
1371         msub = self.dom.createElement('msub')
1372         index, system = e._id
1373         mi = self.dom.createElement('mi')
1374         mi.setAttribute('mathvariant', 'bold')
1375         mi.appendChild(self.dom.createTextNode(system._variable_names[index]))
1376         msub.appendChild(mi)
1377         mi = self.dom.createElement('mi')
1378         mi.setAttribute('mathvariant', 'bold')
1379         mi.appendChild(self.dom.createTextNode(system._name))
1380         msub.appendChild(mi)
1381         return msub
1382 
1383     def _print_BaseVector(self, e):
1384         msub = self.dom.createElement('msub')
1385         index, system = e._id
1386         mover = self.dom.createElement('mover')
1387         mi = self.dom.createElement('mi')
1388         mi.setAttribute('mathvariant', 'bold')
1389         mi.appendChild(self.dom.createTextNode(system._vector_names[index]))
1390         mover.appendChild(mi)
1391         mo = self.dom.createElement('mo')
1392         mo.appendChild(self.dom.createTextNode('^'))
1393         mover.appendChild(mo)
1394         msub.appendChild(mover)
1395         mi = self.dom.createElement('mi')
1396         mi.setAttribute('mathvariant', 'bold')
1397         mi.appendChild(self.dom.createTextNode(system._name))
1398         msub.appendChild(mi)
1399         return msub
1400 
1401     def _print_VectorZero(self, e):
1402         mover = self.dom.createElement('mover')
1403         mi = self.dom.createElement('mi')
1404         mi.setAttribute('mathvariant', 'bold')
1405         mi.appendChild(self.dom.createTextNode("0"))
1406         mover.appendChild(mi)
1407         mo = self.dom.createElement('mo')
1408         mo.appendChild(self.dom.createTextNode('^'))
1409         mover.appendChild(mo)
1410         return mover
1411 
1412     def _print_Cross(self, expr):
1413         mrow = self.dom.createElement('mrow')
1414         vec1 = expr._expr1
1415         vec2 = expr._expr2
1416         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
1417         mo = self.dom.createElement('mo')
1418         mo.appendChild(self.dom.createTextNode('&#xD7;'))
1419         mrow.appendChild(mo)
1420         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
1421         return mrow
1422 
1423     def _print_Curl(self, expr):
1424         mrow = self.dom.createElement('mrow')
1425         mo = self.dom.createElement('mo')
1426         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1427         mrow.appendChild(mo)
1428         mo = self.dom.createElement('mo')
1429         mo.appendChild(self.dom.createTextNode('&#xD7;'))
1430         mrow.appendChild(mo)
1431         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1432         return mrow
1433 
1434     def _print_Divergence(self, expr):
1435         mrow = self.dom.createElement('mrow')
1436         mo = self.dom.createElement('mo')
1437         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1438         mrow.appendChild(mo)
1439         mo = self.dom.createElement('mo')
1440         mo.appendChild(self.dom.createTextNode('&#xB7;'))
1441         mrow.appendChild(mo)
1442         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1443         return mrow
1444 
1445     def _print_Dot(self, expr):
1446         mrow = self.dom.createElement('mrow')
1447         vec1 = expr._expr1
1448         vec2 = expr._expr2
1449         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))
1450         mo = self.dom.createElement('mo')
1451         mo.appendChild(self.dom.createTextNode('&#xB7;'))
1452         mrow.appendChild(mo)
1453         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))
1454         return mrow
1455 
1456     def _print_Gradient(self, expr):
1457         mrow = self.dom.createElement('mrow')
1458         mo = self.dom.createElement('mo')
1459         mo.appendChild(self.dom.createTextNode('&#x2207;'))
1460         mrow.appendChild(mo)
1461         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1462         return mrow
1463 
1464     def _print_Laplacian(self, expr):
1465         mrow = self.dom.createElement('mrow')
1466         mo = self.dom.createElement('mo')
1467         mo.appendChild(self.dom.createTextNode('&#x2206;'))
1468         mrow.appendChild(mo)
1469         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))
1470         return mrow
1471 
1472     def _print_Integers(self, e):
1473         x = self.dom.createElement('mi')
1474         x.setAttribute('mathvariant', 'normal')
1475         x.appendChild(self.dom.createTextNode('&#x2124;'))
1476         return x
1477 
1478     def _print_Complexes(self, e):
1479         x = self.dom.createElement('mi')
1480         x.setAttribute('mathvariant', 'normal')
1481         x.appendChild(self.dom.createTextNode('&#x2102;'))
1482         return x
1483 
1484     def _print_Reals(self, e):
1485         x = self.dom.createElement('mi')
1486         x.setAttribute('mathvariant', 'normal')
1487         x.appendChild(self.dom.createTextNode('&#x211D;'))
1488         return x
1489 
1490     def _print_Naturals(self, e):
1491         x = self.dom.createElement('mi')
1492         x.setAttribute('mathvariant', 'normal')
1493         x.appendChild(self.dom.createTextNode('&#x2115;'))
1494         return x
1495 
1496     def _print_Naturals0(self, e):
1497         sub = self.dom.createElement('msub')
1498         x = self.dom.createElement('mi')
1499         x.setAttribute('mathvariant', 'normal')
1500         x.appendChild(self.dom.createTextNode('&#x2115;'))
1501         sub.appendChild(x)
1502         sub.appendChild(self._print(S.Zero))
1503         return sub
1504 
1505     def _print_SingularityFunction(self, expr):
1506         shift = expr.args[0] - expr.args[1]
1507         power = expr.args[2]
1508         sup = self.dom.createElement('msup')
1509         brac = self.dom.createElement('mfenced')
1510         brac.setAttribute('open', u'\u27e8')
1511         brac.setAttribute('close', u'\u27e9')
1512         brac.appendChild(self._print(shift))
1513         sup.appendChild(brac)
1514         sup.appendChild(self._print(power))
1515         return sup
1516 
1517     def _print_NaN(self, e):
1518         x = self.dom.createElement('mi')
1519         x.appendChild(self.dom.createTextNode('NaN'))
1520         return x
1521 
1522     def _print_bernoulli(self, e):
1523         sub = self.dom.createElement('msub')
1524         mi = self.dom.createElement('mi')
1525         mi.appendChild(self.dom.createTextNode('B'))
1526         sub.appendChild(mi)
1527         sub.appendChild(self._print(e.args[0]))
1528         return sub
1529 
1530     _print_bell = _print_bernoulli
1531 
1532     def _print_catalan(self, e):
1533         sub = self.dom.createElement('msub')
1534         mi = self.dom.createElement('mi')
1535         mi.appendChild(self.dom.createTextNode('C'))
1536         sub.appendChild(mi)
1537         sub.appendChild(self._print(e.args[0]))
1538         return sub
1539 
1540     def _print_fibonacci(self, e):
1541         sub = self.dom.createElement('msub')
1542         mi = self.dom.createElement('mi')
1543         mi.appendChild(self.dom.createTextNode('F'))
1544         sub.appendChild(mi)
1545         sub.appendChild(self._print(e.args[0]))
1546         return sub
1547 
1548     def _print_lucas(self, e):
1549         sub = self.dom.createElement('msub')
1550         mi = self.dom.createElement('mi')
1551         mi.appendChild(self.dom.createTextNode('L'))
1552         sub.appendChild(mi)
1553         sub.appendChild(self._print(e.args[0]))
1554         return sub
1555 
1556     def _print_tribonacci(self, e):
1557         sub = self.dom.createElement('msub')
1558         mi = self.dom.createElement('mi')
1559         mi.appendChild(self.dom.createTextNode('T'))
1560         sub.appendChild(mi)
1561         sub.appendChild(self._print(e.args[0]))
1562         return sub
1563 
1564     def _print_ComplexInfinity(self, e):
1565         x = self.dom.createElement('mover')
1566         mo = self.dom.createElement('mo')
1567         mo.appendChild(self.dom.createTextNode('&#x221E;'))
1568         x.appendChild(mo)
1569         mo = self.dom.createElement('mo')
1570         mo.appendChild(self.dom.createTextNode('~'))
1571         x.appendChild(mo)
1572         return x
1573 
1574     def _print_EmptySet(self, e):
1575         x = self.dom.createElement('mo')
1576         x.appendChild(self.dom.createTextNode('&#x2205;'))
1577         return x
1578 
1579     def _print_UniversalSet(self, e):
1580         x = self.dom.createElement('mo')
1581         x.appendChild(self.dom.createTextNode('&#x1D54C;'))
1582         return x
1583 
1584     def _print_Adjoint(self, expr):
1585         from sympy.matrices import MatrixSymbol
1586         mat = expr.arg
1587         sup = self.dom.createElement('msup')
1588         if not isinstance(mat, MatrixSymbol):
1589             brac = self.dom.createElement('mfenced')
1590             brac.appendChild(self._print(mat))
1591             sup.appendChild(brac)
1592         else:
1593             sup.appendChild(self._print(mat))
1594         mo = self.dom.createElement('mo')
1595         mo.appendChild(self.dom.createTextNode('&#x2020;'))
1596         sup.appendChild(mo)
1597         return sup
1598 
1599     def _print_Transpose(self, expr):
1600         from sympy.matrices import MatrixSymbol
1601         mat = expr.arg
1602         sup = self.dom.createElement('msup')
1603         if not isinstance(mat, MatrixSymbol):
1604             brac = self.dom.createElement('mfenced')
1605             brac.appendChild(self._print(mat))
1606             sup.appendChild(brac)
1607         else:
1608             sup.appendChild(self._print(mat))
1609         mo = self.dom.createElement('mo')
1610         mo.appendChild(self.dom.createTextNode('T'))
1611         sup.appendChild(mo)
1612         return sup
1613 
1614     def _print_Inverse(self, expr):
1615         from sympy.matrices import MatrixSymbol
1616         mat = expr.arg
1617         sup = self.dom.createElement('msup')
1618         if not isinstance(mat, MatrixSymbol):
1619             brac = self.dom.createElement('mfenced')
1620             brac.appendChild(self._print(mat))
1621             sup.appendChild(brac)
1622         else:
1623             sup.appendChild(self._print(mat))
1624         sup.appendChild(self._print(-1))
1625         return sup
1626 
1627     def _print_MatMul(self, expr):
1628         from sympy import MatMul
1629 
1630         x = self.dom.createElement('mrow')
1631         args = expr.args
1632         if isinstance(args[0], Mul):
1633             args = args[0].as_ordered_factors() + list(args[1:])
1634         else:
1635             args = list(args)
1636 
1637         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1638             if args[0] == -1:
1639                 args = args[1:]
1640             else:
1641                 args[0] = -args[0]
1642             mo = self.dom.createElement('mo')
1643             mo.appendChild(self.dom.createTextNode('-'))
1644             x.appendChild(mo)
1645 
1646         for arg in args[:-1]:
1647             x.appendChild(self.parenthesize(arg, precedence_traditional(expr),
1648                                             False))
1649             mo = self.dom.createElement('mo')
1650             mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))
1651             x.appendChild(mo)
1652         x.appendChild(self.parenthesize(args[-1], precedence_traditional(expr),
1653                                         False))
1654         return x
1655 
1656     def _print_MatPow(self, expr):
1657         from sympy.matrices import MatrixSymbol
1658         base, exp = expr.base, expr.exp
1659         sup = self.dom.createElement('msup')
1660         if not isinstance(base, MatrixSymbol):
1661             brac = self.dom.createElement('mfenced')
1662             brac.appendChild(self._print(base))
1663             sup.appendChild(brac)
1664         else:
1665             sup.appendChild(self._print(base))
1666         sup.appendChild(self._print(exp))
1667         return sup
1668 
1669     def _print_HadamardProduct(self, expr):
1670         x = self.dom.createElement('mrow')
1671         args = expr.args
1672         for arg in args[:-1]:
1673             x.appendChild(
1674                 self.parenthesize(arg, precedence_traditional(expr), False))
1675             mo = self.dom.createElement('mo')
1676             mo.appendChild(self.dom.createTextNode('&#x2218;'))
1677             x.appendChild(mo)
1678         x.appendChild(
1679             self.parenthesize(args[-1], precedence_traditional(expr), False))
1680         return x
1681 
1682     def _print_ZeroMatrix(self, Z):
1683         x = self.dom.createElement('mn')
1684         x.appendChild(self.dom.createTextNode('&#x1D7D8'))
1685         return x
1686 
1687     def _print_Identity(self, I):
1688         x = self.dom.createElement('mi')
1689         x.appendChild(self.dom.createTextNode('&#x1D540;'))
1690         return x
1691 
1692     def _print_floor(self, e):
1693         mrow = self.dom.createElement('mrow')
1694         x = self.dom.createElement('mfenced')
1695         x.setAttribute('open', u'\u230A')
1696         x.setAttribute('close', u'\u230B')
1697         x.appendChild(self._print(e.args[0]))
1698         mrow.appendChild(x)
1699         return mrow
1700 
1701     def _print_ceiling(self, e):
1702         mrow = self.dom.createElement('mrow')
1703         x = self.dom.createElement('mfenced')
1704         x.setAttribute('open', u'\u2308')
1705         x.setAttribute('close', u'\u2309')
1706         x.appendChild(self._print(e.args[0]))
1707         mrow.appendChild(x)
1708         return mrow
1709 
1710     def _print_Lambda(self, e):
1711         x = self.dom.createElement('mfenced')
1712         mrow = self.dom.createElement('mrow')
1713         symbols = e.args[0]
1714         if len(symbols) == 1:
1715             symbols = self._print(symbols[0])
1716         else:
1717             symbols = self._print(symbols)
1718         mrow.appendChild(symbols)
1719         mo = self.dom.createElement('mo')
1720         mo.appendChild(self.dom.createTextNode('&#x21A6;'))
1721         mrow.appendChild(mo)
1722         mrow.appendChild(self._print(e.args[1]))
1723         x.appendChild(mrow)
1724         return x
1725 
1726     def _print_tuple(self, e):
1727         x = self.dom.createElement('mfenced')
1728         for i in e:
1729             x.appendChild(self._print(i))
1730         return x
1731 
1732     def _print_IndexedBase(self, e):
1733         return self._print(e.label)
1734 
1735     def _print_Indexed(self, e):
1736         x = self.dom.createElement('msub')
1737         x.appendChild(self._print(e.base))
1738         if len(e.indices) == 1:
1739             x.appendChild(self._print(e.indices[0]))
1740             return x
1741         x.appendChild(self._print(e.indices))
1742         return x
1743 
1744     def _print_MatrixElement(self, e):
1745         x = self.dom.createElement('msub')
1746         x.appendChild(self.parenthesize(e.parent, PRECEDENCE["Atom"], strict = True))
1747         brac = self.dom.createElement('mfenced')
1748         brac.setAttribute("open", "")
1749         brac.setAttribute("close", "")
1750         for i in e.indices:
1751             brac.appendChild(self._print(i))
1752         x.appendChild(brac)
1753         return x
1754 
1755     def _print_elliptic_f(self, e):
1756         x = self.dom.createElement('mrow')
1757         mi = self.dom.createElement('mi')
1758         mi.appendChild(self.dom.createTextNode('&#x1d5a5;'))
1759         x.appendChild(mi)
1760         y = self.dom.createElement('mfenced')
1761         y.setAttribute("separators", "|")
1762         for i in e.args:
1763             y.appendChild(self._print(i))
1764         x.appendChild(y)
1765         return x
1766 
1767     def _print_elliptic_e(self, e):
1768         x = self.dom.createElement('mrow')
1769         mi = self.dom.createElement('mi')
1770         mi.appendChild(self.dom.createTextNode('&#x1d5a4;'))
1771         x.appendChild(mi)
1772         y = self.dom.createElement('mfenced')
1773         y.setAttribute("separators", "|")
1774         for i in e.args:
1775             y.appendChild(self._print(i))
1776         x.appendChild(y)
1777         return x
1778 
1779     def _print_elliptic_pi(self, e):
1780         x = self.dom.createElement('mrow')
1781         mi = self.dom.createElement('mi')
1782         mi.appendChild(self.dom.createTextNode('&#x1d6f1;'))
1783         x.appendChild(mi)
1784         y = self.dom.createElement('mfenced')
1785         if len(e.args) == 2:
1786             y.setAttribute("separators", "|")
1787         else:
1788             y.setAttribute("separators", ";|")
1789         for i in e.args:
1790             y.appendChild(self._print(i))
1791         x.appendChild(y)
1792         return x
1793 
1794     def _print_Ei(self, e):
1795         x = self.dom.createElement('mrow')
1796         mi = self.dom.createElement('mi')
1797         mi.appendChild(self.dom.createTextNode('Ei'))
1798         x.appendChild(mi)
1799         x.appendChild(self._print(e.args))
1800         return x
1801 
1802     def _print_expint(self, e):
1803         x = self.dom.createElement('mrow')
1804         y = self.dom.createElement('msub')
1805         mo = self.dom.createElement('mo')
1806         mo.appendChild(self.dom.createTextNode('E'))
1807         y.appendChild(mo)
1808         y.appendChild(self._print(e.args[0]))
1809         x.appendChild(y)
1810         x.appendChild(self._print(e.args[1:]))
1811         return x
1812 
1813     def _print_jacobi(self, e):
1814         x = self.dom.createElement('mrow')
1815         y = self.dom.createElement('msubsup')
1816         mo = self.dom.createElement('mo')
1817         mo.appendChild(self.dom.createTextNode('P'))
1818         y.appendChild(mo)
1819         y.appendChild(self._print(e.args[0]))
1820         y.appendChild(self._print(e.args[1:3]))
1821         x.appendChild(y)
1822         x.appendChild(self._print(e.args[3:]))
1823         return x
1824 
1825     def _print_gegenbauer(self, e):
1826         x = self.dom.createElement('mrow')
1827         y = self.dom.createElement('msubsup')
1828         mo = self.dom.createElement('mo')
1829         mo.appendChild(self.dom.createTextNode('C'))
1830         y.appendChild(mo)
1831         y.appendChild(self._print(e.args[0]))
1832         y.appendChild(self._print(e.args[1:2]))
1833         x.appendChild(y)
1834         x.appendChild(self._print(e.args[2:]))
1835         return x
1836 
1837     def _print_chebyshevt(self, e):
1838         x = self.dom.createElement('mrow')
1839         y = self.dom.createElement('msub')
1840         mo = self.dom.createElement('mo')
1841         mo.appendChild(self.dom.createTextNode('T'))
1842         y.appendChild(mo)
1843         y.appendChild(self._print(e.args[0]))
1844         x.appendChild(y)
1845         x.appendChild(self._print(e.args[1:]))
1846         return x
1847 
1848     def _print_chebyshevu(self, e):
1849         x = self.dom.createElement('mrow')
1850         y = self.dom.createElement('msub')
1851         mo = self.dom.createElement('mo')
1852         mo.appendChild(self.dom.createTextNode('U'))
1853         y.appendChild(mo)
1854         y.appendChild(self._print(e.args[0]))
1855         x.appendChild(y)
1856         x.appendChild(self._print(e.args[1:]))
1857         return x
1858 
1859     def _print_legendre(self, e):
1860         x = self.dom.createElement('mrow')
1861         y = self.dom.createElement('msub')
1862         mo = self.dom.createElement('mo')
1863         mo.appendChild(self.dom.createTextNode('P'))
1864         y.appendChild(mo)
1865         y.appendChild(self._print(e.args[0]))
1866         x.appendChild(y)
1867         x.appendChild(self._print(e.args[1:]))
1868         return x
1869 
1870     def _print_assoc_legendre(self, e):
1871         x = self.dom.createElement('mrow')
1872         y = self.dom.createElement('msubsup')
1873         mo = self.dom.createElement('mo')
1874         mo.appendChild(self.dom.createTextNode('P'))
1875         y.appendChild(mo)
1876         y.appendChild(self._print(e.args[0]))
1877         y.appendChild(self._print(e.args[1:2]))
1878         x.appendChild(y)
1879         x.appendChild(self._print(e.args[2:]))
1880         return x
1881 
1882     def _print_laguerre(self, e):
1883         x = self.dom.createElement('mrow')
1884         y = self.dom.createElement('msub')
1885         mo = self.dom.createElement('mo')
1886         mo.appendChild(self.dom.createTextNode('L'))
1887         y.appendChild(mo)
1888         y.appendChild(self._print(e.args[0]))
1889         x.appendChild(y)
1890         x.appendChild(self._print(e.args[1:]))
1891         return x
1892 
1893     def _print_assoc_laguerre(self, e):
1894         x = self.dom.createElement('mrow')
1895         y = self.dom.createElement('msubsup')
1896         mo = self.dom.createElement('mo')
1897         mo.appendChild(self.dom.createTextNode('L'))
1898         y.appendChild(mo)
1899         y.appendChild(self._print(e.args[0]))
1900         y.appendChild(self._print(e.args[1:2]))
1901         x.appendChild(y)
1902         x.appendChild(self._print(e.args[2:]))
1903         return x
1904 
1905     def _print_hermite(self, e):
1906         x = self.dom.createElement('mrow')
1907         y = self.dom.createElement('msub')
1908         mo = self.dom.createElement('mo')
1909         mo.appendChild(self.dom.createTextNode('H'))
1910         y.appendChild(mo)
1911         y.appendChild(self._print(e.args[0]))
1912         x.appendChild(y)
1913         x.appendChild(self._print(e.args[1:]))
1914         return x
1915 
1916 
1917 def mathml(expr, printer='content', **settings):
1918     """Returns the MathML representation of expr. If printer is presentation
1919     then prints Presentation MathML else prints content MathML.
1920     """
1921     if printer == 'presentation':
1922         return MathMLPresentationPrinter(settings).doprint(expr)
1923     else:
1924         return MathMLContentPrinter(settings).doprint(expr)
1925 
1926 
1927 def print_mathml(expr, printer='content', **settings):
1928     """
1929     Prints a pretty representation of the MathML code for expr. If printer is
1930     presentation then prints Presentation MathML else prints content MathML.
1931 
1932     Examples
1933     ========
1934 
1935     >>> ##
1936     >>> from sympy.printing.mathml import print_mathml
1937     >>> from sympy.abc import x
1938     >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE
1939     <apply>
1940         <plus/>
1941         <ci>x</ci>
1942         <cn>1</cn>
1943     </apply>
1944     >>> print_mathml(x+1, printer='presentation')
1945     <mrow>
1946         <mi>x</mi>
1947         <mo>+</mo>
1948         <mn>1</mn>
1949     </mrow>
1950 
1951     """
1952     if printer == 'presentation':
1953         s = MathMLPresentationPrinter(settings)
1954     else:
1955         s = MathMLContentPrinter(settings)
1956     xml = s._print(sympify(expr))
1957     s.apply_patch()
1958     pretty_xml = xml.toprettyxml()
1959     s.restore_patch()
1960 
1961     print(pretty_xml)
1962 
1963 
1964 # For backward compatibility
1965 MathMLPrinter = MathMLContentPrinter

</code><intended_behavior>Extend the existing MathML printing support to include custom handling for `OneMatrix`, `ZeroMatrix`, and `Identity` classes. This includes defining appropriate MathML elements and attributes that accurately represent these special matrices. The goal here is to ensure that these matrices are distinguishable and correctly represented within MathML outputs, facilitating improved presentation in web environments.</intended_behavior>, <file>sympy/matrices/expressions/matexpr.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from functools import wraps, reduce
4 import collections
5 
6 from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq, Mul, Add
7 from sympy.core.decorators import call_highest_priority
8 from sympy.core.compatibility import range, SYMPY_INTS, default_sort_key, string_types
9 from sympy.core.sympify import SympifyError, _sympify
10 from sympy.functions import conjugate, adjoint
11 from sympy.functions.special.tensor_functions import KroneckerDelta
12 from sympy.matrices import ShapeError
13 from sympy.simplify import simplify
14 from sympy.utilities.misc import filldedent
15 
16 
17 def _sympifyit(arg, retval=None):
18     # This version of _sympifyit sympifies MutableMatrix objects
19     def deco(func):
20         @wraps(func)
21         def __sympifyit_wrapper(a, b):
22             try:
23                 b = _sympify(b)
24                 return func(a, b)
25             except SympifyError:
26                 return retval
27 
28         return __sympifyit_wrapper
29 
30     return deco
31 
32 
33 class MatrixExpr(Expr):
34     """Superclass for Matrix Expressions
35 
36     MatrixExprs represent abstract matrices, linear transformations represented
37     within a particular basis.
38 
39     Examples
40     ========
41 
42     >>> from sympy import MatrixSymbol
43     >>> A = MatrixSymbol('A', 3, 3)
44     >>> y = MatrixSymbol('y', 3, 1)
45     >>> x = (A.T*A).I * A * y
46 
47     See Also
48     ========
49 
50     MatrixSymbol, MatAdd, MatMul, Transpose, Inverse
51     """
52 
53     # Should not be considered iterable by the
54     # sympy.core.compatibility.iterable function. Subclass that actually are
55     # iterable (i.e., explicit matrices) should set this to True.
56     _iterable = False
57 
58     _op_priority = 11.0
59 
60     is_Matrix = True
61     is_MatrixExpr = True
62     is_Identity = None
63     is_Inverse = False
64     is_Transpose = False
65     is_ZeroMatrix = False
66     is_MatAdd = False
67     is_MatMul = False
68 
69     is_commutative = False
70     is_number = False
71     is_symbol = False
72     is_scalar = False
73 
74     def __new__(cls, *args, **kwargs):
75         args = map(_sympify, args)
76         return Basic.__new__(cls, *args, **kwargs)
77 
78     # The following is adapted from the core Expr object
79     def __neg__(self):
80         return MatMul(S.NegativeOne, self).doit()
81 
82     def __abs__(self):
83         raise NotImplementedError
84 
85     @_sympifyit('other', NotImplemented)
86     @call_highest_priority('__radd__')
87     def __add__(self, other):
88         return MatAdd(self, other, check=True).doit()
89 
90     @_sympifyit('other', NotImplemented)
91     @call_highest_priority('__add__')
92     def __radd__(self, other):
93         return MatAdd(other, self, check=True).doit()
94 
95     @_sympifyit('other', NotImplemented)
96     @call_highest_priority('__rsub__')
97     def __sub__(self, other):
98         return MatAdd(self, -other, check=True).doit()
99 
100     @_sympifyit('other', NotImplemented)
101     @call_highest_priority('__sub__')
102     def __rsub__(self, other):
103         return MatAdd(other, -self, check=True).doit()
104 
105     @_sympifyit('other', NotImplemented)
106     @call_highest_priority('__rmul__')
107     def __mul__(self, other):
108         return MatMul(self, other).doit()
109 
110     @_sympifyit('other', NotImplemented)
111     @call_highest_priority('__rmul__')
112     def __matmul__(self, other):
113         return MatMul(self, other).doit()
114 
115     @_sympifyit('other', NotImplemented)
116     @call_highest_priority('__mul__')
117     def __rmul__(self, other):
118         return MatMul(other, self).doit()
119 
120     @_sympifyit('other', NotImplemented)
121     @call_highest_priority('__mul__')
122     def __rmatmul__(self, other):
123         return MatMul(other, self).doit()
124 
125     @_sympifyit('other', NotImplemented)
126     @call_highest_priority('__rpow__')
127     def __pow__(self, other):
128         if not self.is_square:
129             raise ShapeError("Power of non-square matrix %s" % self)
130         elif self.is_Identity:
131             return self
132         elif other is S.Zero:
133             return Identity(self.rows)
134         elif other is S.One:
135             return self
136         return MatPow(self, other).doit(deep=False)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__pow__')
140     def __rpow__(self, other):
141         raise NotImplementedError("Matrix Power not defined")
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__rdiv__')
145     def __div__(self, other):
146         return self * other**S.NegativeOne
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__div__')
150     def __rdiv__(self, other):
151         raise NotImplementedError()
152         #return MatMul(other, Pow(self, S.NegativeOne))
153 
154     __truediv__ = __div__
155     __rtruediv__ = __rdiv__
156 
157     @property
158     def rows(self):
159         return self.shape[0]
160 
161     @property
162     def cols(self):
163         return self.shape[1]
164 
165     @property
166     def is_square(self):
167         return self.rows == self.cols
168 
169     def _eval_conjugate(self):
170         from sympy.matrices.expressions.adjoint import Adjoint
171         from sympy.matrices.expressions.transpose import Transpose
172         return Adjoint(Transpose(self))
173 
174     def as_real_imag(self):
175         from sympy import I
176         real = (S(1)/2) * (self + self._eval_conjugate())
177         im = (self - self._eval_conjugate())/(2*I)
178         return (real, im)
179 
180     def _eval_inverse(self):
181         from sympy.matrices.expressions.inverse import Inverse
182         return Inverse(self)
183 
184     def _eval_transpose(self):
185         return Transpose(self)
186 
187     def _eval_power(self, exp):
188         return MatPow(self, exp)
189 
190     def _eval_simplify(self, **kwargs):
191         if self.is_Atom:
192             return self
193         else:
194             return self.__class__(*[simplify(x, **kwargs) for x in self.args])
195 
196     def _eval_adjoint(self):
197         from sympy.matrices.expressions.adjoint import Adjoint
198         return Adjoint(self)
199 
200     def _eval_derivative(self, x):
201         # x is a scalar:
202         return ZeroMatrix(self.shape[0], self.shape[1])
203 
204     def _eval_derivative_array(self, x):
205         if isinstance(x, MatrixExpr):
206             return _matrix_derivative(self, x)
207         else:
208             return self._eval_derivative(x)
209 
210     def _eval_derivative_n_times(self, x, n):
211         return Basic._eval_derivative_n_times(self, x, n)
212 
213     def _visit_eval_derivative_scalar(self, x):
214         # `x` is a scalar:
215         if x.has(self):
216             return _matrix_derivative(x, self)
217         else:
218             return ZeroMatrix(*self.shape)
219 
220     def _visit_eval_derivative_array(self, x):
221         if x.has(self):
222             return _matrix_derivative(x, self)
223         else:
224             from sympy import Derivative
225             return Derivative(x, self)
226 
227     def _accept_eval_derivative(self, s):
228         return s._visit_eval_derivative_array(self)
229 
230     def _entry(self, i, j, **kwargs):
231         raise NotImplementedError(
232             "Indexing not implemented for %s" % self.__class__.__name__)
233 
234     def adjoint(self):
235         return adjoint(self)
236 
237     def as_coeff_Mul(self, rational=False):
238         """Efficiently extract the coefficient of a product. """
239         return S.One, self
240 
241     def conjugate(self):
242         return conjugate(self)
243 
244     def transpose(self):
245         from sympy.matrices.expressions.transpose import transpose
246         return transpose(self)
247 
248     T = property(transpose, None, None, 'Matrix transposition.')
249 
250     def inverse(self):
251         return self._eval_inverse()
252 
253     inv = inverse
254 
255     @property
256     def I(self):
257         return self.inverse()
258 
259     def valid_index(self, i, j):
260         def is_valid(idx):
261             return isinstance(idx, (int, Integer, Symbol, Expr))
262         return (is_valid(i) and is_valid(j) and
263                 (self.rows is None or
264                 (0 <= i) != False and (i < self.rows) != False) and
265                 (0 <= j) != False and (j < self.cols) != False)
266 
267     def __getitem__(self, key):
268         if not isinstance(key, tuple) and isinstance(key, slice):
269             from sympy.matrices.expressions.slice import MatrixSlice
270             return MatrixSlice(self, key, (0, None, 1))
271         if isinstance(key, tuple) and len(key) == 2:
272             i, j = key
273             if isinstance(i, slice) or isinstance(j, slice):
274                 from sympy.matrices.expressions.slice import MatrixSlice
275                 return MatrixSlice(self, i, j)
276             i, j = _sympify(i), _sympify(j)
277             if self.valid_index(i, j) != False:
278                 return self._entry(i, j)
279             else:
280                 raise IndexError("Invalid indices (%s, %s)" % (i, j))
281         elif isinstance(key, (SYMPY_INTS, Integer)):
282             # row-wise decomposition of matrix
283             rows, cols = self.shape
284             # allow single indexing if number of columns is known
285             if not isinstance(cols, Integer):
286                 raise IndexError(filldedent('''
287                     Single indexing is only supported when the number
288                     of columns is known.'''))
289             key = _sympify(key)
290             i = key // cols
291             j = key % cols
292             if self.valid_index(i, j) != False:
293                 return self._entry(i, j)
294             else:
295                 raise IndexError("Invalid index %s" % key)
296         elif isinstance(key, (Symbol, Expr)):
297                 raise IndexError(filldedent('''
298                     Only integers may be used when addressing the matrix
299                     with a single index.'''))
300         raise IndexError("Invalid index, wanted %s[i,j]" % self)
301 
302     def as_explicit(self):
303         """
304         Returns a dense Matrix with elements represented explicitly
305 
306         Returns an object of type ImmutableDenseMatrix.
307 
308         Examples
309         ========
310 
311         >>> from sympy import Identity
312         >>> I = Identity(3)
313         >>> I
314         I
315         >>> I.as_explicit()
316         Matrix([
317         [1, 0, 0],
318         [0, 1, 0],
319         [0, 0, 1]])
320 
321         See Also
322         ========
323         as_mutable: returns mutable Matrix type
324 
325         """
326         from sympy.matrices.immutable import ImmutableDenseMatrix
327         return ImmutableDenseMatrix([[    self[i, j]
328                             for j in range(self.cols)]
329                             for i in range(self.rows)])
330 
331     def as_mutable(self):
332         """
333         Returns a dense, mutable matrix with elements represented explicitly
334 
335         Examples
336         ========
337 
338         >>> from sympy import Identity
339         >>> I = Identity(3)
340         >>> I
341         I
342         >>> I.shape
343         (3, 3)
344         >>> I.as_mutable()
345         Matrix([
346         [1, 0, 0],
347         [0, 1, 0],
348         [0, 0, 1]])
349 
350         See Also
351         ========
352         as_explicit: returns ImmutableDenseMatrix
353         """
354         return self.as_explicit().as_mutable()
355 
356     def __array__(self):
357         from numpy import empty
358         a = empty(self.shape, dtype=object)
359         for i in range(self.rows):
360             for j in range(self.cols):
361                 a[i, j] = self[i, j]
362         return a
363 
364     def equals(self, other):
365         """
366         Test elementwise equality between matrices, potentially of different
367         types
368 
369         >>> from sympy import Identity, eye
370         >>> Identity(3).equals(eye(3))
371         True
372         """
373         return self.as_explicit().equals(other)
374 
375     def canonicalize(self):
376         return self
377 
378     def as_coeff_mmul(self):
379         return 1, MatMul(self)
380 
381     @staticmethod
382     def from_index_summation(expr, first_index=None, last_index=None, dimensions=None):
383         r"""
384         Parse expression of matrices with explicitly summed indices into a
385         matrix expression without indices, if possible.
386 
387         This transformation expressed in mathematical notation:
388 
389         `\sum_{j=0}^{N-1} A_{i,j} B_{j,k} \Longrightarrow \mathbf{A}\cdot \mathbf{B}`
390 
391         Optional parameter ``first_index``: specify which free index to use as
392         the index starting the expression.
393 
394         Examples
395         ========
396 
397         >>> from sympy import MatrixSymbol, MatrixExpr, Sum, Symbol
398         >>> from sympy.abc import i, j, k, l, N
399         >>> A = MatrixSymbol("A", N, N)
400         >>> B = MatrixSymbol("B", N, N)
401         >>> expr = Sum(A[i, j]*B[j, k], (j, 0, N-1))
402         >>> MatrixExpr.from_index_summation(expr)
403         A*B
404 
405         Transposition is detected:
406 
407         >>> expr = Sum(A[j, i]*B[j, k], (j, 0, N-1))
408         >>> MatrixExpr.from_index_summation(expr)
409         A.T*B
410 
411         Detect the trace:
412 
413         >>> expr = Sum(A[i, i], (i, 0, N-1))
414         >>> MatrixExpr.from_index_summation(expr)
415         Trace(A)
416 
417         More complicated expressions:
418 
419         >>> expr = Sum(A[i, j]*B[k, j]*A[l, k], (j, 0, N-1), (k, 0, N-1))
420         >>> MatrixExpr.from_index_summation(expr)
421         A*B.T*A.T
422         """
423         from sympy import Sum, Mul, Add, MatMul, transpose, trace
424         from sympy.strategies.traverse import bottom_up
425 
426         def remove_matelement(expr, i1, i2):
427 
428             def repl_match(pos):
429                 def func(x):
430                     if not isinstance(x, MatrixElement):
431                         return False
432                     if x.args[pos] != i1:
433                         return False
434                     if x.args[3-pos] == 0:
435                         if x.args[0].shape[2-pos] == 1:
436                             return True
437                         else:
438                             return False
439                     return True
440                 return func
441 
442             expr = expr.replace(repl_match(1),
443                 lambda x: x.args[0])
444             expr = expr.replace(repl_match(2),
445                 lambda x: transpose(x.args[0]))
446 
447             # Make sure that all Mul are transformed to MatMul and that they
448             # are flattened:
449             rule = bottom_up(lambda x: reduce(lambda a, b: a*b, x.args) if isinstance(x, (Mul, MatMul)) else x)
450             return rule(expr)
451 
452         def recurse_expr(expr, index_ranges={}):
453             if expr.is_Mul:
454                 nonmatargs = []
455                 pos_arg = []
456                 pos_ind = []
457                 dlinks = {}
458                 link_ind = []
459                 counter = 0
460                 args_ind = []
461                 for arg in expr.args:
462                     retvals = recurse_expr(arg, index_ranges)
463                     assert isinstance(retvals, list)
464                     if isinstance(retvals, list):
465                         for i in retvals:
466                             args_ind.append(i)
467                     else:
468                         args_ind.append(retvals)
469                 for arg_symbol, arg_indices in args_ind:
470                     if arg_indices is None:
471                         nonmatargs.append(arg_symbol)
472                         continue
473                     if isinstance(arg_symbol, MatrixElement):
474                         arg_symbol = arg_symbol.args[0]
475                     pos_arg.append(arg_symbol)
476                     pos_ind.append(arg_indices)
477                     link_ind.append([None]*len(arg_indices))
478                     for i, ind in enumerate(arg_indices):
479                         if ind in dlinks:
480                             other_i = dlinks[ind]
481                             link_ind[counter][i] = other_i
482                             link_ind[other_i[0]][other_i[1]] = (counter, i)
483                         dlinks[ind] = (counter, i)
484                     counter += 1
485                 counter2 = 0
486                 lines = {}
487                 while counter2 < len(link_ind):
488                     for i, e in enumerate(link_ind):
489                         if None in e:
490                             line_start_index = (i, e.index(None))
491                             break
492                     cur_ind_pos = line_start_index
493                     cur_line = []
494                     index1 = pos_ind[cur_ind_pos[0]][cur_ind_pos[1]]
495                     while True:
496                         d, r = cur_ind_pos
497                         if pos_arg[d] != 1:
498                             if r % 2 == 1:
499                                 cur_line.append(transpose(pos_arg[d]))
500                             else:
501                                 cur_line.append(pos_arg[d])
502                         next_ind_pos = link_ind[d][1-r]
503                         counter2 += 1
504                         # Mark as visited, there will be no `None` anymore:
505                         link_ind[d] = (-1, -1)
506                         if next_ind_pos is None:
507                             index2 = pos_ind[d][1-r]
508                             lines[(index1, index2)] = cur_line
509                             break
510                         cur_ind_pos = next_ind_pos
511                 lines = {k: MatMul.fromiter(v) if len(v) != 1 else v[0] for k, v in lines.items()}
512                 return [(Mul.fromiter(nonmatargs), None)] + [
513                     (MatrixElement(a, i, j), (i, j)) for (i, j), a in lines.items()
514                 ]
515             elif expr.is_Add:
516                 res = [recurse_expr(i) for i in expr.args]
517                 d = collections.defaultdict(list)
518                 for res_addend in res:
519                     scalar = 1
520                     for elem, indices in res_addend:
521                         if indices is None:
522                             scalar = elem
523                             continue
524                         indices = tuple(sorted(indices, key=default_sort_key))
525                         d[indices].append(scalar*remove_matelement(elem, *indices))
526                         scalar = 1
527                 return [(MatrixElement(Add.fromiter(v), *k), k) for k, v in d.items()]
528             elif isinstance(expr, KroneckerDelta):
529                 i1, i2 = expr.args
530                 if dimensions is not None:
531                     identity = Identity(dimensions[0])
532                 else:
533                     identity = S.One
534                 return [(MatrixElement(identity, i1, i2), (i1, i2))]
535             elif isinstance(expr, MatrixElement):
536                 matrix_symbol, i1, i2 = expr.args
537                 if i1 in index_ranges:
538                     r1, r2 = index_ranges[i1]
539                     if r1 != 0 or matrix_symbol.shape[0] != r2+1:
540                         raise ValueError("index range mismatch: {0} vs. (0, {1})".format(
541                             (r1, r2), matrix_symbol.shape[0]))
542                 if i2 in index_ranges:
543                     r1, r2 = index_ranges[i2]
544                     if r1 != 0 or matrix_symbol.shape[1] != r2+1:
545                         raise ValueError("index range mismatch: {0} vs. (0, {1})".format(
546                             (r1, r2), matrix_symbol.shape[1]))
547                 if (i1 == i2) and (i1 in index_ranges):
548                     return [(trace(matrix_symbol), None)]
549                 return [(MatrixElement(matrix_symbol, i1, i2), (i1, i2))]
550             elif isinstance(expr, Sum):
551                 return recurse_expr(
552                     expr.args[0],
553                     index_ranges={i[0]: i[1:] for i in expr.args[1:]}
554                 )
555             else:
556                 return [(expr, None)]
557 
558         retvals = recurse_expr(expr)
559         factors, indices = zip(*retvals)
560         retexpr = Mul.fromiter(factors)
561         if len(indices) == 0 or list(set(indices)) == [None]:
562             return retexpr
563         if first_index is None:
564             for i in indices:
565                 if i is not None:
566                     ind0 = i
567                     break
568             return remove_matelement(retexpr, *ind0)
569         else:
570             return remove_matelement(retexpr, first_index, last_index)
571 
572     def applyfunc(self, func):
573         from .applyfunc import ElementwiseApplyFunction
574         return ElementwiseApplyFunction(func, self)
575 
576     def _eval_Eq(self, other):
577         if not isinstance(other, MatrixExpr):
578             return False
579         if self.shape != other.shape:
580             return False
581         if (self - other).is_ZeroMatrix:
582             return True
583         return Eq(self, other, evaluate=False)
584 
585 def get_postprocessor(cls):
586     def _postprocessor(expr):
587         # To avoid circular imports, we can't have MatMul/MatAdd on the top level
588         mat_class = {Mul: MatMul, Add: MatAdd}[cls]
589         nonmatrices = []
590         matrices = []
591         for term in expr.args:
592             if isinstance(term, MatrixExpr):
593                 matrices.append(term)
594             else:
595                 nonmatrices.append(term)
596 
597         if not matrices:
598             return cls._from_args(nonmatrices)
599 
600         if nonmatrices:
601             if cls == Mul:
602                 for i in range(len(matrices)):
603                     if not matrices[i].is_MatrixExpr:
604                         # If one of the matrices explicit, absorb the scalar into it
605                         # (doit will combine all explicit matrices into one, so it
606                         # doesn't matter which)
607                         matrices[i] = matrices[i].__mul__(cls._from_args(nonmatrices))
608                         nonmatrices = []
609                         break
610 
611             else:
612                 # Maintain the ability to create Add(scalar, matrix) without
613                 # raising an exception. That way different algorithms can
614                 # replace matrix expressions with non-commutative symbols to
615                 # manipulate them like non-commutative scalars.
616                 return cls._from_args(nonmatrices + [mat_class(*matrices).doit(deep=False)])
617 
618         return mat_class(cls._from_args(nonmatrices), *matrices).doit(deep=False)
619     return _postprocessor
620 
621 
622 Basic._constructor_postprocessor_mapping[MatrixExpr] = {
623     "Mul": [get_postprocessor(Mul)],
624     "Add": [get_postprocessor(Add)],
625 }
626 
627 
628 def _matrix_derivative(expr, x):
629     from sympy import Derivative
630     lines = expr._eval_derivative_matrix_lines(x)
631 
632     parts = [i.build() for i in lines]
633 
634     from sympy.codegen.array_utils import recognize_matrix_expression
635 
636     parts = [[recognize_matrix_expression(j).doit() for j in i] for i in parts]
637 
638     def _get_shape(elem):
639         if isinstance(elem, MatrixExpr):
640             return elem.shape
641         return (1, 1)
642 
643     def get_rank(parts):
644         return sum([j not in (1, None) for i in parts for j in _get_shape(i)])
645 
646     ranks = [get_rank(i) for i in parts]
647     rank = ranks[0]
648 
649     def contract_one_dims(parts):
650         if len(parts) == 1:
651             return parts[0]
652         else:
653             p1, p2 = parts[:2]
654             if p2.is_Matrix:
655                 p2 = p2.T
656             pbase = p1*p2
657             if len(parts) == 2:
658                 return pbase
659             else:  # len(parts) > 2
660                 if pbase.is_Matrix:
661                     raise ValueError("")
662                 return pbase*Mul.fromiter(parts[2:])
663 
664     if rank <= 2:
665         return Add.fromiter([contract_one_dims(i) for i in parts])
666 
667     return Derivative(expr, x)
668 
669 
670 class MatrixElement(Expr):
671     parent = property(lambda self: self.args[0])
672     i = property(lambda self: self.args[1])
673     j = property(lambda self: self.args[2])
674     _diff_wrt = True
675     is_symbol = True
676     is_commutative = True
677 
678     def __new__(cls, name, n, m):
679         n, m = map(_sympify, (n, m))
680         from sympy import MatrixBase
681         if isinstance(name, (MatrixBase,)):
682             if n.is_Integer and m.is_Integer:
683                 return name[n, m]
684         if isinstance(name, string_types):
685             name = Symbol(name)
686         name = _sympify(name)
687         obj = Expr.__new__(cls, name, n, m)
688         return obj
689 
690     def doit(self, **kwargs):
691         deep = kwargs.get('deep', True)
692         if deep:
693             args = [arg.doit(**kwargs) for arg in self.args]
694         else:
695             args = self.args
696         return args[0][args[1], args[2]]
697 
698     @property
699     def indices(self):
700         return self.args[1:]
701 
702     def _eval_derivative(self, v):
703         from sympy import Sum, symbols, Dummy
704 
705         if not isinstance(v, MatrixElement):
706             from sympy import MatrixBase
707             if isinstance(self.parent, MatrixBase):
708                 return self.parent.diff(v)[self.i, self.j]
709             return S.Zero
710 
711         M = self.args[0]
712 
713         if M == v.args[0]:
714             return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])
715 
716         if isinstance(M, Inverse):
717             i, j = self.args[1:]
718             i1, i2 = symbols("z1, z2", cls=Dummy)
719             Y = M.args[0]
720             r1, r2 = Y.shape
721             return -Sum(M[i, i1]*Y[i1, i2].diff(v)*M[i2, j], (i1, 0, r1-1), (i2, 0, r2-1))
722 
723         if self.has(v.args[0]):
724             return None
725 
726         return S.Zero
727 
728 
729 class MatrixSymbol(MatrixExpr):
730     """Symbolic representation of a Matrix object
731 
732     Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and
733     can be included in Matrix Expressions
734 
735     Examples
736     ========
737 
738     >>> from sympy import MatrixSymbol, Identity
739     >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix
740     >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix
741     >>> A.shape
742     (3, 4)
743     >>> 2*A*B + Identity(3)
744     I + 2*A*B
745     """
746     is_commutative = False
747     is_symbol = True
748     _diff_wrt = True
749 
750     def __new__(cls, name, n, m):
751         n, m = _sympify(n), _sympify(m)
752         if isinstance(name, string_types):
753             name = Symbol(name)
754         obj = Basic.__new__(cls, name, n, m)
755         return obj
756 
757     def _hashable_content(self):
758         return (self.name, self.shape)
759 
760     @property
761     def shape(self):
762         return self.args[1:3]
763 
764     @property
765     def name(self):
766         return self.args[0].name
767 
768     def _eval_subs(self, old, new):
769         # only do substitutions in shape
770         shape = Tuple(*self.shape)._subs(old, new)
771         return MatrixSymbol(self.name, *shape)
772 
773     def __call__(self, *args):
774         raise TypeError("%s object is not callable" % self.__class__)
775 
776     def _entry(self, i, j, **kwargs):
777         return MatrixElement(self, i, j)
778 
779     @property
780     def free_symbols(self):
781         return set((self,))
782 
783     def doit(self, **hints):
784         if hints.get('deep', True):
785             return type(self)(self.name, self.args[1].doit(**hints),
786                     self.args[2].doit(**hints))
787         else:
788             return self
789 
790     def _eval_simplify(self, **kwargs):
791         return self
792 
793     def _eval_derivative_matrix_lines(self, x):
794         if self != x:
795             first = ZeroMatrix(x.shape[0], self.shape[0]) if self.shape[0] != 1 else S.Zero
796             second = ZeroMatrix(x.shape[1], self.shape[1]) if self.shape[1] != 1 else S.Zero
797             return [_LeftRightArgs(
798                 [first, second],
799             )]
800         else:
801             first = Identity(self.shape[0]) if self.shape[0] != 1 else S.One
802             second = Identity(self.shape[1]) if self.shape[1] != 1 else S.One
803             return [_LeftRightArgs(
804                 [first, second],
805             )]
806 
807 
808 class Identity(MatrixExpr):
809     """The Matrix Identity I - multiplicative identity
810 
811     Examples
812     ========
813 
814     >>> from sympy.matrices import Identity, MatrixSymbol
815     >>> A = MatrixSymbol('A', 3, 5)
816     >>> I = Identity(3)
817     >>> I*A
818     A
819     """
820 
821     is_Identity = True
822 
823     def __new__(cls, n):
824         return super(Identity, cls).__new__(cls, _sympify(n))
825 
826     @property
827     def rows(self):
828         return self.args[0]
829 
830     @property
831     def cols(self):
832         return self.args[0]
833 
834     @property
835     def shape(self):
836         return (self.args[0], self.args[0])
837 
838     @property
839     def is_square(self):
840         return True
841 
842     def _eval_transpose(self):
843         return self
844 
845     def _eval_trace(self):
846         return self.rows
847 
848     def _eval_inverse(self):
849         return self
850 
851     def conjugate(self):
852         return self
853 
854     def _entry(self, i, j, **kwargs):
855         eq = Eq(i, j)
856         if eq is S.true:
857             return S.One
858         elif eq is S.false:
859             return S.Zero
860         return KroneckerDelta(i, j)
861 
862     def _eval_determinant(self):
863         return S.One
864 
865 class GenericIdentity(Identity):
866     """
867     An identity matrix without a specified shape
868 
869     This exists primarily so MatMul() with no arguments can return something
870     meaningful.
871     """
872     def __new__(cls):
873         # super(Identity, cls) instead of super(GenericIdentity, cls) because
874         # Identity.__new__ doesn't have the same signature
875         return super(Identity, cls).__new__(cls)
876 
877     @property
878     def rows(self):
879         raise TypeError("GenericIdentity does not have a specified shape")
880 
881     @property
882     def cols(self):
883         raise TypeError("GenericIdentity does not have a specified shape")
884 
885     @property
886     def shape(self):
887         raise TypeError("GenericIdentity does not have a specified shape")
888 
889     # Avoid Matrix.__eq__ which might call .shape
890     def __eq__(self, other):
891         return isinstance(other, GenericIdentity)
892 
893     def __ne__(self, other):
894         return not (self == other)
895 
896     def __hash__(self):
897         return super(GenericIdentity, self).__hash__()
898 
899 
900 class ZeroMatrix(MatrixExpr):
901     """The Matrix Zero 0 - additive identity
902 
903     Examples
904     ========
905 
906     >>> from sympy import MatrixSymbol, ZeroMatrix
907     >>> A = MatrixSymbol('A', 3, 5)
908     >>> Z = ZeroMatrix(3, 5)
909     >>> A + Z
910     A
911     >>> Z*A.T
912     0
913     """
914     is_ZeroMatrix = True
915 
916     def __new__(cls, m, n):
917         return super(ZeroMatrix, cls).__new__(cls, m, n)
918 
919     @property
920     def shape(self):
921         return (self.args[0], self.args[1])
922 
923     @_sympifyit('other', NotImplemented)
924     @call_highest_priority('__rpow__')
925     def __pow__(self, other):
926         if other != 1 and not self.is_square:
927             raise ShapeError("Power of non-square matrix %s" % self)
928         if other == 0:
929             return Identity(self.rows)
930         if other < 1:
931             raise ValueError("Matrix det == 0; not invertible.")
932         return self
933 
934     def _eval_transpose(self):
935         return ZeroMatrix(self.cols, self.rows)
936 
937     def _eval_trace(self):
938         return S.Zero
939 
940     def _eval_determinant(self):
941         return S.Zero
942 
943     def conjugate(self):
944         return self
945 
946     def _entry(self, i, j, **kwargs):
947         return S.Zero
948 
949     def __nonzero__(self):
950         return False
951 
952     __bool__ = __nonzero__
953 
954 
955 class GenericZeroMatrix(ZeroMatrix):
956     """
957     A zero matrix without a specified shape
958 
959     This exists primarily so MatAdd() with no arguments can return something
960     meaningful.
961     """
962     def __new__(cls):
963         # super(ZeroMatrix, cls) instead of super(GenericZeroMatrix, cls)
964         # because ZeroMatrix.__new__ doesn't have the same signature
965         return super(ZeroMatrix, cls).__new__(cls)
966 
967     @property
968     def rows(self):
969         raise TypeError("GenericZeroMatrix does not have a specified shape")
970 
971     @property
972     def cols(self):
973         raise TypeError("GenericZeroMatrix does not have a specified shape")
974 
975     @property
976     def shape(self):
977         raise TypeError("GenericZeroMatrix does not have a specified shape")
978 
979     # Avoid Matrix.__eq__ which might call .shape
980     def __eq__(self, other):
981         return isinstance(other, GenericZeroMatrix)
982 
983     def __ne__(self, other):
984         return not (self == other)
985 
986     def __hash__(self):
987         return super(GenericZeroMatrix, self).__hash__()
988 
989 
990 class OneMatrix(MatrixExpr):
991     """
992     Matrix whose all entries are ones.
993     """
994     def __new__(cls, m, n):
995         obj = super(OneMatrix, cls).__new__(cls, m, n)
996         return obj
997 
998     @property
999     def shape(self):
1000         return self._args
1001 
1002     def as_explicit(self):
1003         from sympy import ImmutableDenseMatrix
1004         return ImmutableDenseMatrix.ones(*self.shape)
1005 
1006     def _eval_transpose(self):
1007         return OneMatrix(self.cols, self.rows)
1008 
1009     def _eval_trace(self):
1010         return S.One*self.rows
1011 
1012     def _eval_determinant(self):
1013         condition = Eq(self.shape[0], 1) & Eq(self.shape[1], 1)
1014         if condition == True:
1015             return S.One
1016         elif condition == False:
1017             return S.Zero
1018         else:
1019             from sympy import Determinant
1020             return Determinant(self)
1021 
1022     def conjugate(self):
1023         return self
1024 
1025     def _entry(self, i, j, **kwargs):
1026         return S.One
1027 
1028 
1029 def matrix_symbols(expr):
1030     return [sym for sym in expr.free_symbols if sym.is_Matrix]
1031 
1032 
1033 class _LeftRightArgs(object):
1034     r"""
1035     Helper class to compute matrix derivatives.
1036 
1037     The logic: when an expression is derived by a matrix `X_{mn}`, two lines of
1038     matrix multiplications are created: the one contracted to `m` (first line),
1039     and the one contracted to `n` (second line).
1040 
1041     Transposition flips the side by which new matrices are connected to the
1042     lines.
1043 
1044     The trace connects the end of the two lines.
1045     """
1046 
1047     def __init__(self, lines, higher=S.One):
1048         self._lines = [i for i in lines]
1049         self._first_pointer_parent = self._lines
1050         self._first_pointer_index = 0
1051         self._first_line_index = 0
1052         self._second_pointer_parent = self._lines
1053         self._second_pointer_index = 1
1054         self._second_line_index = 1
1055         self.higher = higher
1056 
1057     @property
1058     def first_pointer(self):
1059        return self._first_pointer_parent[self._first_pointer_index]
1060 
1061     @first_pointer.setter
1062     def first_pointer(self, value):
1063         self._first_pointer_parent[self._first_pointer_index] = value
1064 
1065     @property
1066     def second_pointer(self):
1067         return self._second_pointer_parent[self._second_pointer_index]
1068 
1069     @second_pointer.setter
1070     def second_pointer(self, value):
1071         self._second_pointer_parent[self._second_pointer_index] = value
1072 
1073     def __repr__(self):
1074         try:
1075             built = [self._build(i) for i in self._lines]
1076         except Exception:
1077             built = self._lines
1078         return "_LeftRightArgs(lines=%s, higher=%s)" % (
1079             built,
1080             self.higher,
1081         )
1082 
1083     def transpose(self):
1084         self._first_pointer_parent, self._second_pointer_parent = self._second_pointer_parent, self._first_pointer_parent
1085         self._first_pointer_index, self._second_pointer_index = self._second_pointer_index, self._first_pointer_index
1086         self._first_line_index, self._second_line_index = self._second_line_index, self._first_line_index
1087         return self
1088 
1089     @staticmethod
1090     def _build(expr):
1091         from sympy.core.expr import ExprBuilder
1092         if isinstance(expr, ExprBuilder):
1093             return expr.build()
1094         if isinstance(expr, list):
1095             if len(expr) == 1:
1096                 return expr[0]
1097             else:
1098                 return expr[0](*[_LeftRightArgs._build(i) for i in expr[1]])
1099         else:
1100             return expr
1101 
1102     def build(self):
1103         data = [self._build(i) for i in self._lines]
1104         if self.higher != 1:
1105             data += [self._build(self.higher)]
1106         data = [i.doit() for i in data]
1107         return data
1108 
1109     def matrix_form(self):
1110         if self.first != 1 and self.higher != 1:
1111             raise ValueError("higher dimensional array cannot be represented")
1112 
1113         def _get_shape(elem):
1114             if isinstance(elem, MatrixExpr):
1115                 return elem.shape
1116             return (None, None)
1117 
1118         if _get_shape(self.first)[1] != _get_shape(self.second)[1]:
1119             # Remove one-dimensional identity matrices:
1120             # (this is needed by `a.diff(a)` where `a` is a vector)
1121             if _get_shape(self.second) == (1, 1):
1122                 return self.first*self.second[0, 0]
1123             if _get_shape(self.first) == (1, 1):
1124                 return self.first[1, 1]*self.second.T
1125             raise ValueError("incompatible shapes")
1126         if self.first != 1:
1127             return self.first*self.second.T
1128         else:
1129             return self.higher
1130 
1131     def rank(self):
1132         """
1133         Number of dimensions different from trivial (warning: not related to
1134         matrix rank).
1135         """
1136         rank = 0
1137         if self.first != 1:
1138             rank += sum([i != 1 for i in self.first.shape])
1139         if self.second != 1:
1140             rank += sum([i != 1 for i in self.second.shape])
1141         if self.higher != 1:
1142             rank += 2
1143         return rank
1144 
1145     def _multiply_pointer(self, pointer, other):
1146         from sympy.core.expr import ExprBuilder
1147         from sympy.codegen.array_utils import CodegenArrayContraction, CodegenArrayTensorProduct
1148 
1149         subexpr = ExprBuilder(
1150             CodegenArrayContraction,
1151             [
1152                 ExprBuilder(
1153                     CodegenArrayTensorProduct,
1154                     [
1155                         pointer,
1156                         other
1157                     ]
1158                 ),
1159                 (1, 2)
1160             ],
1161             validator=CodegenArrayContraction._validate
1162         )
1163 
1164         return subexpr
1165 
1166     def append_first(self, other):
1167         self.first_pointer *= other
1168 
1169     def append_second(self, other):
1170         self.second_pointer *= other
1171 
1172     def __hash__(self):
1173         return hash((self.first, self.second))
1174 
1175     def __eq__(self, other):
1176         if not isinstance(other, _LeftRightArgs):
1177             return False
1178         return (self.first == other.first) and (self.second == other.second)
1179 
1180 
1181 def _make_matrix(x):
1182     from sympy import ImmutableDenseMatrix
1183     if isinstance(x, MatrixExpr):
1184         return x
1185     return ImmutableDenseMatrix([[x]])
1186 
1187 
1188 from .matmul import MatMul
1189 from .matadd import MatAdd
1190 from .matpow import MatPow
1191 from .transpose import Transpose
1192 from .inverse import Inverse

</code><intended_behavior>While the specific presentation enhancements via unicode pretty printing were not directly identified due to the search limitations, it's assumed that within each of these classes, or perhaps through a common superclass or utility module, methods or functionalities might be added or extended to support improved unicode pretty printing. This could involve specifying unicode representations for these matrices and ensuring that these representations are invoked during the pretty-printing process. The goal is to maintain readability and distinction among `ZeroMatrix`, `Identity`, and `OneMatrix` in non-MathML contexts as well.</intended_behavior>]
2025-10-16 02:54:25.709 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 02:54:25.710 | INFO     | Search-only: skipping patch selection
2025-10-16 02:54:25.784 | INFO     | Task sympy__sympy-16906 completed successfully.
2025-10-16 02:54:25.785 | INFO     | No patch generated. You can try running ACR again.
