[
    {
        "rel_file_path": "sympy/printing/mathml.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/printing/mathml.py",
        "start": 1,
        "end": 1965,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 A MathML printer.\n3 \"\"\"\n4 \n5 from __future__ import print_function, division\n6 \n7 from sympy import sympify, S, Mul\n8 from sympy.core.compatibility import range, string_types, default_sort_key\n9 from sympy.core.function import _coeff_isneg\n10 from sympy.printing.conventions import split_super_sub, requires_partial\n11 from sympy.printing.precedence import precedence_traditional, PRECEDENCE\n12 from sympy.printing.pretty.pretty_symbology import greek_unicode\n13 from sympy.printing.printer import Printer\n14 \n15 import mpmath.libmp as mlib\n16 from mpmath.libmp import prec_to_dps\n17 \n18 class MathMLPrinterBase(Printer):\n19     \"\"\"Contains common code required for MathMLContentPrinter and\n20     MathMLPresentationPrinter.\n21     \"\"\"\n22 \n23     _default_settings = {\n24         \"order\": None,\n25         \"encoding\": \"utf-8\",\n26         \"fold_frac_powers\": False,\n27         \"fold_func_brackets\": False,\n28         \"fold_short_frac\": None,\n29         \"inv_trig_style\": \"abbreviated\",\n30         \"ln_notation\": False,\n31         \"long_frac_ratio\": None,\n32         \"mat_delim\": \"[\",\n33         \"mat_symbol_style\": \"plain\",\n34         \"mul_symbol\": None,\n35         \"root_notation\": True,\n36         \"symbol_names\": {},\n37         \"mul_symbol_mathml_numbers\": '&#xB7;',\n38     }\n39 \n40     def __init__(self, settings=None):\n41         Printer.__init__(self, settings)\n42         from xml.dom.minidom import Document, Text\n43 \n44         self.dom = Document()\n45 \n46         # Workaround to allow strings to remain unescaped\n47         # Based on\n48         # https://stackoverflow.com/questions/38015864/python-xml-dom-minidom-\\\n49         #                              please-dont-escape-my-strings/38041194\n50         class RawText(Text):\n51             def writexml(self, writer, indent='', addindent='', newl=''):\n52                 if self.data:\n53                     writer.write(u'{}{}{}'.format(indent, self.data, newl))\n54 \n55         def createRawTextNode(data):\n56             r = RawText()\n57             r.data = data\n58             r.ownerDocument = self.dom\n59             return r\n60 \n61         self.dom.createTextNode = createRawTextNode\n62 \n63     def doprint(self, expr):\n64         \"\"\"\n65         Prints the expression as MathML.\n66         \"\"\"\n67         mathML = Printer._print(self, expr)\n68         unistr = mathML.toxml()\n69         xmlbstr = unistr.encode('ascii', 'xmlcharrefreplace')\n70         res = xmlbstr.decode()\n71         return res\n72 \n73     def apply_patch(self):\n74         # Applying the patch of xml.dom.minidom bug\n75         # Date: 2011-11-18\n76         # Description: http://ronrothman.com/public/leftbraned/xml-dom-minidom\\\n77         #                   -toprettyxml-and-silly-whitespace/#best-solution\n78         # Issue: http://bugs.python.org/issue4147\n79         # Patch: http://hg.python.org/cpython/rev/7262f8f276ff/\n80 \n81         from xml.dom.minidom import Element, Text, Node, _write_data\n82 \n83         def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n84             # indent = current indentation\n85             # addindent = indentation to add to higher levels\n86             # newl = newline string\n87             writer.write(indent + \"<\" + self.tagName)\n88 \n89             attrs = self._get_attributes()\n90             a_names = list(attrs.keys())\n91             a_names.sort()\n92 \n93             for a_name in a_names:\n94                 writer.write(\" %s=\\\"\" % a_name)\n95                 _write_data(writer, attrs[a_name].value)\n96                 writer.write(\"\\\"\")\n97             if self.childNodes:\n98                 writer.write(\">\")\n99                 if (len(self.childNodes) == 1 and\n100                         self.childNodes[0].nodeType == Node.TEXT_NODE):\n101                     self.childNodes[0].writexml(writer, '', '', '')\n102                 else:\n103                     writer.write(newl)\n104                     for node in self.childNodes:\n105                         node.writexml(\n106                             writer, indent + addindent, addindent, newl)\n107                     writer.write(indent)\n108                 writer.write(\"</%s>%s\" % (self.tagName, newl))\n109             else:\n110                 writer.write(\"/>%s\" % (newl))\n111         self._Element_writexml_old = Element.writexml\n112         Element.writexml = writexml\n113 \n114         def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n115             _write_data(writer, \"%s%s%s\" % (indent, self.data, newl))\n116         self._Text_writexml_old = Text.writexml\n117         Text.writexml = writexml\n118 \n119     def restore_patch(self):\n120         from xml.dom.minidom import Element, Text\n121         Element.writexml = self._Element_writexml_old\n122         Text.writexml = self._Text_writexml_old\n123 \n124 \n125 class MathMLContentPrinter(MathMLPrinterBase):\n126     \"\"\"Prints an expression to the Content MathML markup language.\n127 \n128     References: https://www.w3.org/TR/MathML2/chapter4.html\n129     \"\"\"\n130     printmethod = \"_mathml_content\"\n131 \n132     def mathml_tag(self, e):\n133         \"\"\"Returns the MathML tag for an expression.\"\"\"\n134         translate = {\n135             'Add': 'plus',\n136             'Mul': 'times',\n137             'Derivative': 'diff',\n138             'Number': 'cn',\n139             'int': 'cn',\n140             'Pow': 'power',\n141             'Symbol': 'ci',\n142             'MatrixSymbol': 'ci',\n143             'RandomSymbol': 'ci',\n144             'Integral': 'int',\n145             'Sum': 'sum',\n146             'sin': 'sin',\n147             'cos': 'cos',\n148             'tan': 'tan',\n149             'cot': 'cot',\n150             'asin': 'arcsin',\n151             'asinh': 'arcsinh',\n152             'acos': 'arccos',\n153             'acosh': 'arccosh',\n154             'atan': 'arctan',\n155             'atanh': 'arctanh',\n156             'acot': 'arccot',\n157             'atan2': 'arctan',\n158             'log': 'ln',\n159             'Equality': 'eq',\n160             'Unequality': 'neq',\n161             'GreaterThan': 'geq',\n162             'LessThan': 'leq',\n163             'StrictGreaterThan': 'gt',\n164             'StrictLessThan': 'lt',\n165         }\n166 \n167         for cls in e.__class__.__mro__:\n168             n = cls.__name__\n169             if n in translate:\n170                 return translate[n]\n171         # Not found in the MRO set\n172         n = e.__class__.__name__\n173         return n.lower()\n174 \n175     def _print_Mul(self, expr):\n176 \n177         if _coeff_isneg(expr):\n178             x = self.dom.createElement('apply')\n179             x.appendChild(self.dom.createElement('minus'))\n180             x.appendChild(self._print_Mul(-expr))\n181             return x\n182 \n183         from sympy.simplify import fraction\n184         numer, denom = fraction(expr)\n185 \n186         if denom is not S.One:\n187             x = self.dom.createElement('apply')\n188             x.appendChild(self.dom.createElement('divide'))\n189             x.appendChild(self._print(numer))\n190             x.appendChild(self._print(denom))\n191             return x\n192 \n193         coeff, terms = expr.as_coeff_mul()\n194         if coeff is S.One and len(terms) == 1:\n195             # XXX since the negative coefficient has been handled, I don't\n196             # think a coeff of 1 can remain\n197             return self._print(terms[0])\n198 \n199         if self.order != 'old':\n200             terms = Mul._from_args(terms).as_ordered_factors()\n201 \n202         x = self.dom.createElement('apply')\n203         x.appendChild(self.dom.createElement('times'))\n204         if coeff != 1:\n205             x.appendChild(self._print(coeff))\n206         for term in terms:\n207             x.appendChild(self._print(term))\n208         return x\n209 \n210     def _print_Add(self, expr, order=None):\n211         args = self._as_ordered_terms(expr, order=order)\n212         lastProcessed = self._print(args[0])\n213         plusNodes = []\n214         for arg in args[1:]:\n215             if _coeff_isneg(arg):\n216                 # use minus\n217                 x = self.dom.createElement('apply')\n218                 x.appendChild(self.dom.createElement('minus'))\n219                 x.appendChild(lastProcessed)\n220                 x.appendChild(self._print(-arg))\n221                 # invert expression since this is now minused\n222                 lastProcessed = x\n223                 if arg == args[-1]:\n224                     plusNodes.append(lastProcessed)\n225             else:\n226                 plusNodes.append(lastProcessed)\n227                 lastProcessed = self._print(arg)\n228                 if arg == args[-1]:\n229                     plusNodes.append(self._print(arg))\n230         if len(plusNodes) == 1:\n231             return lastProcessed\n232         x = self.dom.createElement('apply')\n233         x.appendChild(self.dom.createElement('plus'))\n234         while plusNodes:\n235             x.appendChild(plusNodes.pop(0))\n236         return x\n237 \n238     def _print_MatrixBase(self, m):\n239         x = self.dom.createElement('matrix')\n240         for i in range(m.rows):\n241             x_r = self.dom.createElement('matrixrow')\n242             for j in range(m.cols):\n243                 x_r.appendChild(self._print(m[i, j]))\n244             x.appendChild(x_r)\n245         return x\n246 \n247     def _print_Rational(self, e):\n248         if e.q == 1:\n249             # don't divide\n250             x = self.dom.createElement('cn')\n251             x.appendChild(self.dom.createTextNode(str(e.p)))\n252             return x\n253         x = self.dom.createElement('apply')\n254         x.appendChild(self.dom.createElement('divide'))\n255         # numerator\n256         xnum = self.dom.createElement('cn')\n257         xnum.appendChild(self.dom.createTextNode(str(e.p)))\n258         # denominator\n259         xdenom = self.dom.createElement('cn')\n260         xdenom.appendChild(self.dom.createTextNode(str(e.q)))\n261         x.appendChild(xnum)\n262         x.appendChild(xdenom)\n263         return x\n264 \n265     def _print_Limit(self, e):\n266         x = self.dom.createElement('apply')\n267         x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n268 \n269         x_1 = self.dom.createElement('bvar')\n270         x_2 = self.dom.createElement('lowlimit')\n271         x_1.appendChild(self._print(e.args[1]))\n272         x_2.appendChild(self._print(e.args[2]))\n273 \n274         x.appendChild(x_1)\n275         x.appendChild(x_2)\n276         x.appendChild(self._print(e.args[0]))\n277         return x\n278 \n279     def _print_ImaginaryUnit(self, e):\n280         return self.dom.createElement('imaginaryi')\n281 \n282     def _print_EulerGamma(self, e):\n283         return self.dom.createElement('eulergamma')\n284 \n285     def _print_GoldenRatio(self, e):\n286         \"\"\"We use unicode #x3c6 for Greek letter phi as defined here\n287         http://www.w3.org/2003/entities/2007doc/isogrk1.html\"\"\"\n288         x = self.dom.createElement('cn')\n289         x.appendChild(self.dom.createTextNode(u\"\\N{GREEK SMALL LETTER PHI}\"))\n290         return x\n291 \n292     def _print_Exp1(self, e):\n293         return self.dom.createElement('exponentiale')\n294 \n295     def _print_Pi(self, e):\n296         return self.dom.createElement('pi')\n297 \n298     def _print_Infinity(self, e):\n299         return self.dom.createElement('infinity')\n300 \n301     def _print_NegativeInfinity(self, e):\n302         x = self.dom.createElement('apply')\n303         x.appendChild(self.dom.createElement('minus'))\n304         x.appendChild(self.dom.createElement('infinity'))\n305         return x\n306 \n307     def _print_Integral(self, e):\n308         def lime_recur(limits):\n309             x = self.dom.createElement('apply')\n310             x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n311             bvar_elem = self.dom.createElement('bvar')\n312             bvar_elem.appendChild(self._print(limits[0][0]))\n313             x.appendChild(bvar_elem)\n314 \n315             if len(limits[0]) == 3:\n316                 low_elem = self.dom.createElement('lowlimit')\n317                 low_elem.appendChild(self._print(limits[0][1]))\n318                 x.appendChild(low_elem)\n319                 up_elem = self.dom.createElement('uplimit')\n320                 up_elem.appendChild(self._print(limits[0][2]))\n321                 x.appendChild(up_elem)\n322             if len(limits[0]) == 2:\n323                 up_elem = self.dom.createElement('uplimit')\n324                 up_elem.appendChild(self._print(limits[0][1]))\n325                 x.appendChild(up_elem)\n326             if len(limits) == 1:\n327                 x.appendChild(self._print(e.function))\n328             else:\n329                 x.appendChild(lime_recur(limits[1:]))\n330             return x\n331 \n332         limits = list(e.limits)\n333         limits.reverse()\n334         return lime_recur(limits)\n335 \n336     def _print_Sum(self, e):\n337         # Printer can be shared because Sum and Integral have the\n338         # same internal representation.\n339         return self._print_Integral(e)\n340 \n341     def _print_Symbol(self, sym):\n342         ci = self.dom.createElement(self.mathml_tag(sym))\n343 \n344         def join(items):\n345             if len(items) > 1:\n346                 mrow = self.dom.createElement('mml:mrow')\n347                 for i, item in enumerate(items):\n348                     if i > 0:\n349                         mo = self.dom.createElement('mml:mo')\n350                         mo.appendChild(self.dom.createTextNode(\" \"))\n351                         mrow.appendChild(mo)\n352                     mi = self.dom.createElement('mml:mi')\n353                     mi.appendChild(self.dom.createTextNode(item))\n354                     mrow.appendChild(mi)\n355                 return mrow\n356             else:\n357                 mi = self.dom.createElement('mml:mi')\n358                 mi.appendChild(self.dom.createTextNode(items[0]))\n359                 return mi\n360 \n361         # translate name, supers and subs to unicode characters\n362         def translate(s):\n363             if s in greek_unicode:\n364                 return greek_unicode.get(s)\n365             else:\n366                 return s\n367 \n368         name, supers, subs = split_super_sub(sym.name)\n369         name = translate(name)\n370         supers = [translate(sup) for sup in supers]\n371         subs = [translate(sub) for sub in subs]\n372 \n373         mname = self.dom.createElement('mml:mi')\n374         mname.appendChild(self.dom.createTextNode(name))\n375         if not supers:\n376             if not subs:\n377                 ci.appendChild(self.dom.createTextNode(name))\n378             else:\n379                 msub = self.dom.createElement('mml:msub')\n380                 msub.appendChild(mname)\n381                 msub.appendChild(join(subs))\n382                 ci.appendChild(msub)\n383         else:\n384             if not subs:\n385                 msup = self.dom.createElement('mml:msup')\n386                 msup.appendChild(mname)\n387                 msup.appendChild(join(supers))\n388                 ci.appendChild(msup)\n389             else:\n390                 msubsup = self.dom.createElement('mml:msubsup')\n391                 msubsup.appendChild(mname)\n392                 msubsup.appendChild(join(subs))\n393                 msubsup.appendChild(join(supers))\n394                 ci.appendChild(msubsup)\n395         return ci\n396 \n397     _print_MatrixSymbol = _print_Symbol\n398     _print_RandomSymbol = _print_Symbol\n399 \n400     def _print_Pow(self, e):\n401         # Here we use root instead of power if the exponent is the reciprocal\n402         # of an integer\n403         if (self._settings['root_notation'] and e.exp.is_Rational\n404                 and e.exp.p == 1):\n405             x = self.dom.createElement('apply')\n406             x.appendChild(self.dom.createElement('root'))\n407             if e.exp.q != 2:\n408                 xmldeg = self.dom.createElement('degree')\n409                 xmlci = self.dom.createElement('ci')\n410                 xmlci.appendChild(self.dom.createTextNode(str(e.exp.q)))\n411                 xmldeg.appendChild(xmlci)\n412                 x.appendChild(xmldeg)\n413             x.appendChild(self._print(e.base))\n414             return x\n415 \n416         x = self.dom.createElement('apply')\n417         x_1 = self.dom.createElement(self.mathml_tag(e))\n418         x.appendChild(x_1)\n419         x.appendChild(self._print(e.base))\n420         x.appendChild(self._print(e.exp))\n421         return x\n422 \n423     def _print_Number(self, e):\n424         x = self.dom.createElement(self.mathml_tag(e))\n425         x.appendChild(self.dom.createTextNode(str(e)))\n426         return x\n427 \n428     def _print_Derivative(self, e):\n429         x = self.dom.createElement('apply')\n430         diff_symbol = self.mathml_tag(e)\n431         if requires_partial(e):\n432             diff_symbol = 'partialdiff'\n433         x.appendChild(self.dom.createElement(diff_symbol))\n434         x_1 = self.dom.createElement('bvar')\n435 \n436         for sym, times in reversed(e.variable_count):\n437             x_1.appendChild(self._print(sym))\n438             if times > 1:\n439                 degree = self.dom.createElement('degree')\n440                 degree.appendChild(self._print(sympify(times)))\n441                 x_1.appendChild(degree)\n442 \n443         x.appendChild(x_1)\n444         x.appendChild(self._print(e.expr))\n445         return x\n446 \n447     def _print_Function(self, e):\n448         x = self.dom.createElement(\"apply\")\n449         x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n450         for arg in e.args:\n451             x.appendChild(self._print(arg))\n452         return x\n453 \n454     def _print_Basic(self, e):\n455         x = self.dom.createElement(self.mathml_tag(e))\n456         for arg in e.args:\n457             x.appendChild(self._print(arg))\n458         return x\n459 \n460     def _print_AssocOp(self, e):\n461         x = self.dom.createElement('apply')\n462         x_1 = self.dom.createElement(self.mathml_tag(e))\n463         x.appendChild(x_1)\n464         for arg in e.args:\n465             x.appendChild(self._print(arg))\n466         return x\n467 \n468     def _print_Relational(self, e):\n469         x = self.dom.createElement('apply')\n470         x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n471         x.appendChild(self._print(e.lhs))\n472         x.appendChild(self._print(e.rhs))\n473         return x\n474 \n475     def _print_list(self, seq):\n476         \"\"\"MathML reference for the <list> element:\n477         http://www.w3.org/TR/MathML2/chapter4.html#contm.list\"\"\"\n478         dom_element = self.dom.createElement('list')\n479         for item in seq:\n480             dom_element.appendChild(self._print(item))\n481         return dom_element\n482 \n483     def _print_int(self, p):\n484         dom_element = self.dom.createElement(self.mathml_tag(p))\n485         dom_element.appendChild(self.dom.createTextNode(str(p)))\n486         return dom_element\n487 \n488 \n489 class MathMLPresentationPrinter(MathMLPrinterBase):\n490     \"\"\"Prints an expression to the Presentation MathML markup language.\n491 \n492     References: https://www.w3.org/TR/MathML2/chapter3.html\n493     \"\"\"\n494     printmethod = \"_mathml_presentation\"\n495 \n496     def mathml_tag(self, e):\n497         \"\"\"Returns the MathML tag for an expression.\"\"\"\n498         translate = {\n499             'Number': 'mn',\n500             'Limit': '&#x2192;',\n501             'Derivative': '&dd;',\n502             'int': 'mn',\n503             'Symbol': 'mi',\n504             'Integral': '&int;',\n505             'Sum': '&#x2211;',\n506             'sin': 'sin',\n507             'cos': 'cos',\n508             'tan': 'tan',\n509             'cot': 'cot',\n510             'asin': 'arcsin',\n511             'asinh': 'arcsinh',\n512             'acos': 'arccos',\n513             'acosh': 'arccosh',\n514             'atan': 'arctan',\n515             'atanh': 'arctanh',\n516             'acot': 'arccot',\n517             'atan2': 'arctan',\n518             'Equality': '=',\n519             'Unequality': '&#x2260;',\n520             'GreaterThan': '&#x2265;',\n521             'LessThan': '&#x2264;',\n522             'StrictGreaterThan': '>',\n523             'StrictLessThan': '<',\n524             'lerchphi': '&#x3A6;',\n525             'zeta': '&#x3B6;',\n526             'dirichlet_eta': '&#x3B7;',\n527             'elliptic_k': '&#x39A;',\n528             'lowergamma': '&#x3B3;',\n529             'uppergamma': '&#x393;',\n530             'gamma': '&#x393;',\n531             'totient': '&#x3D5;',\n532             'reduced_totient': '&#x3BB;',\n533             'primenu': '&#x3BD;',\n534             'primeomega': '&#x3A9;',\n535             'fresnels': 'S',\n536             'fresnelc': 'C',\n537             'Heaviside': '&#x398;',\n538             'BooleanTrue': 'True',\n539             'BooleanFalse': 'False',\n540             'NoneType': 'None',\n541         }\n542 \n543         def mul_symbol_selection():\n544             if (self._settings[\"mul_symbol\"] is None or\n545                     self._settings[\"mul_symbol\"] == 'None'):\n546                 return '&InvisibleTimes;'\n547             elif self._settings[\"mul_symbol\"] == 'times':\n548                 return '&#xD7;'\n549             elif self._settings[\"mul_symbol\"] == 'dot':\n550                 return '&#xB7;'\n551             elif self._settings[\"mul_symbol\"] == 'ldot':\n552                 return '&#x2024;'\n553             elif not isinstance(self._settings[\"mul_symbol\"], string_types):\n554                 raise TypeError\n555             else:\n556                 return self._settings[\"mul_symbol\"]\n557         for cls in e.__class__.__mro__:\n558             n = cls.__name__\n559             if n in translate:\n560                 return translate[n]\n561         # Not found in the MRO set\n562         if e.__class__.__name__ == \"Mul\":\n563             return mul_symbol_selection()\n564         n = e.__class__.__name__\n565         return n.lower()\n566 \n567     def parenthesize(self, item, level, strict=False):\n568         prec_val = precedence_traditional(item)\n569         if (prec_val < level) or ((not strict) and prec_val <= level):\n570             brac = self.dom.createElement('mfenced')\n571             brac.appendChild(self._print(item))\n572             return brac\n573         else:\n574             return self._print(item)\n575 \n576     def _print_Mul(self, expr):\n577 \n578         def multiply(expr, mrow):\n579             from sympy.simplify import fraction\n580             numer, denom = fraction(expr)\n581             if denom is not S.One:\n582                 frac = self.dom.createElement('mfrac')\n583                 if self._settings[\"fold_short_frac\"] and len(str(expr)) < 7:\n584                     frac.setAttribute('bevelled', 'true')\n585                 xnum = self._print(numer)\n586                 xden = self._print(denom)\n587                 frac.appendChild(xnum)\n588                 frac.appendChild(xden)\n589                 mrow.appendChild(frac)\n590                 return mrow\n591 \n592             coeff, terms = expr.as_coeff_mul()\n593             if coeff is S.One and len(terms) == 1:\n594                 mrow.appendChild(self._print(terms[0]))\n595                 return mrow\n596             if self.order != 'old':\n597                 terms = Mul._from_args(terms).as_ordered_factors()\n598 \n599             if coeff != 1:\n600                 x = self._print(coeff)\n601                 y = self.dom.createElement('mo')\n602                 y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n603                 mrow.appendChild(x)\n604                 mrow.appendChild(y)\n605             for term in terms:\n606                 x = self._print(term)\n607                 mrow.appendChild(x)\n608                 if not term == terms[-1]:\n609                     y = self.dom.createElement('mo')\n610                     y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n611                     mrow.appendChild(y)\n612             return mrow\n613         mrow = self.dom.createElement('mrow')\n614         if _coeff_isneg(expr):\n615             x = self.dom.createElement('mo')\n616             x.appendChild(self.dom.createTextNode('-'))\n617             mrow.appendChild(x)\n618             mrow = multiply(-expr, mrow)\n619         else:\n620             mrow = multiply(expr, mrow)\n621 \n622         return mrow\n623 \n624     def _print_Add(self, expr, order=None):\n625         mrow = self.dom.createElement('mrow')\n626         args = self._as_ordered_terms(expr, order=order)\n627         mrow.appendChild(self._print(args[0]))\n628         for arg in args[1:]:\n629             if _coeff_isneg(arg):\n630                 # use minus\n631                 x = self.dom.createElement('mo')\n632                 x.appendChild(self.dom.createTextNode('-'))\n633                 y = self._print(-arg)\n634                 # invert expression since this is now minused\n635             else:\n636                 x = self.dom.createElement('mo')\n637                 x.appendChild(self.dom.createTextNode('+'))\n638                 y = self._print(arg)\n639             mrow.appendChild(x)\n640             mrow.appendChild(y)\n641 \n642         return mrow\n643 \n644     def _print_MatrixBase(self, m):\n645         table = self.dom.createElement('mtable')\n646         for i in range(m.rows):\n647             x = self.dom.createElement('mtr')\n648             for j in range(m.cols):\n649                 y = self.dom.createElement('mtd')\n650                 y.appendChild(self._print(m[i, j]))\n651                 x.appendChild(y)\n652             table.appendChild(x)\n653         if self._settings[\"mat_delim\"] == '':\n654             return table\n655         brac = self.dom.createElement('mfenced')\n656         if self._settings[\"mat_delim\"] == \"[\":\n657             brac.setAttribute('open', '[')\n658             brac.setAttribute('close', ']')\n659         brac.appendChild(table)\n660         return brac\n661 \n662     def _get_printed_Rational(self, e, folded=None):\n663         if e.p < 0:\n664             p = -e.p\n665         else:\n666             p = e.p\n667         x = self.dom.createElement('mfrac')\n668         if folded or self._settings[\"fold_short_frac\"]:\n669             x.setAttribute('bevelled', 'true')\n670         x.appendChild(self._print(p))\n671         x.appendChild(self._print(e.q))\n672         if e.p < 0:\n673             mrow = self.dom.createElement('mrow')\n674             mo = self.dom.createElement('mo')\n675             mo.appendChild(self.dom.createTextNode('-'))\n676             mrow.appendChild(mo)\n677             mrow.appendChild(x)\n678             return mrow\n679         else:\n680             return x\n681 \n682     def _print_Rational(self, e):\n683         if e.q == 1:\n684             # don't divide\n685             return self._print(e.p)\n686 \n687         return self._get_printed_Rational(e, self._settings[\"fold_short_frac\"])\n688 \n689     def _print_Limit(self, e):\n690         mrow = self.dom.createElement('mrow')\n691         munder = self.dom.createElement('munder')\n692         mi = self.dom.createElement('mi')\n693         mi.appendChild(self.dom.createTextNode('lim'))\n694 \n695         x = self.dom.createElement('mrow')\n696         x_1 = self._print(e.args[1])\n697         arrow = self.dom.createElement('mo')\n698         arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n699         x_2 = self._print(e.args[2])\n700         x.appendChild(x_1)\n701         x.appendChild(arrow)\n702         x.appendChild(x_2)\n703 \n704         munder.appendChild(mi)\n705         munder.appendChild(x)\n706         mrow.appendChild(munder)\n707         mrow.appendChild(self._print(e.args[0]))\n708 \n709         return mrow\n710 \n711     def _print_ImaginaryUnit(self, e):\n712         x = self.dom.createElement('mi')\n713         x.appendChild(self.dom.createTextNode('&ImaginaryI;'))\n714         return x\n715 \n716     def _print_GoldenRatio(self, e):\n717         x = self.dom.createElement('mi')\n718         x.appendChild(self.dom.createTextNode('&#x3A6;'))\n719         return x\n720 \n721     def _print_Exp1(self, e):\n722         x = self.dom.createElement('mi')\n723         x.appendChild(self.dom.createTextNode('&ExponentialE;'))\n724         return x\n725 \n726     def _print_Pi(self, e):\n727         x = self.dom.createElement('mi')\n728         x.appendChild(self.dom.createTextNode('&pi;'))\n729         return x\n730 \n731     def _print_Infinity(self, e):\n732         x = self.dom.createElement('mi')\n733         x.appendChild(self.dom.createTextNode('&#x221E;'))\n734         return x\n735 \n736     def _print_NegativeInfinity(self, e):\n737         mrow = self.dom.createElement('mrow')\n738         y = self.dom.createElement('mo')\n739         y.appendChild(self.dom.createTextNode('-'))\n740         x = self._print_Infinity(e)\n741         mrow.appendChild(y)\n742         mrow.appendChild(x)\n743         return mrow\n744 \n745     def _print_Integral(self, expr):\n746         intsymbols = {1: \"&#x222B;\", 2: \"&#x222C;\", 3: \"&#x222D;\"}\n747 \n748         mrow = self.dom.createElement('mrow')\n749         if len(expr.limits) <= 3 and all(len(lim) == 1 for lim in expr.limits):\n750             # Only up to three-integral signs exists\n751             mo = self.dom.createElement('mo')\n752             mo.appendChild(self.dom.createTextNode(intsymbols[len(expr.limits)]))\n753             mrow.appendChild(mo)\n754         else:\n755             # Either more than three or limits provided\n756             for lim in reversed(expr.limits):\n757                 mo = self.dom.createElement('mo')\n758                 mo.appendChild(self.dom.createTextNode(intsymbols[1]))\n759                 if len(lim) == 1:\n760                     mrow.appendChild(mo)\n761                 if len(lim) == 2:\n762                     msup = self.dom.createElement('msup')\n763                     msup.appendChild(mo)\n764                     msup.appendChild(self._print(lim[1]))\n765                     mrow.appendChild(msup)\n766                 if len(lim) == 3:\n767                     msubsup = self.dom.createElement('msubsup')\n768                     msubsup.appendChild(mo)\n769                     msubsup.appendChild(self._print(lim[1]))\n770                     msubsup.appendChild(self._print(lim[2]))\n771                     mrow.appendChild(msubsup)\n772         # print function\n773         mrow.appendChild(self.parenthesize(expr.function, PRECEDENCE[\"Mul\"],\n774                                            strict=True))\n775         # print integration variables\n776         for lim in reversed(expr.limits):\n777             d = self.dom.createElement('mo')\n778             d.appendChild(self.dom.createTextNode('&dd;'))\n779             mrow.appendChild(d)\n780             mrow.appendChild(self._print(lim[0]))\n781         return mrow\n782 \n783     def _print_Sum(self, e):\n784         limits = list(e.limits)\n785         subsup = self.dom.createElement('munderover')\n786         low_elem = self._print(limits[0][1])\n787         up_elem = self._print(limits[0][2])\n788         summand = self.dom.createElement('mo')\n789         summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n790 \n791         low = self.dom.createElement('mrow')\n792         var = self._print(limits[0][0])\n793         equal = self.dom.createElement('mo')\n794         equal.appendChild(self.dom.createTextNode('='))\n795         low.appendChild(var)\n796         low.appendChild(equal)\n797         low.appendChild(low_elem)\n798 \n799         subsup.appendChild(summand)\n800         subsup.appendChild(low)\n801         subsup.appendChild(up_elem)\n802 \n803         mrow = self.dom.createElement('mrow')\n804         mrow.appendChild(subsup)\n805         if len(str(e.function)) == 1:\n806             mrow.appendChild(self._print(e.function))\n807         else:\n808             fence = self.dom.createElement('mfenced')\n809             fence.appendChild(self._print(e.function))\n810             mrow.appendChild(fence)\n811 \n812         return mrow\n813 \n814     def _print_Symbol(self, sym, style='plain'):\n815         def join(items):\n816             if len(items) > 1:\n817                 mrow = self.dom.createElement('mrow')\n818                 for i, item in enumerate(items):\n819                     if i > 0:\n820                         mo = self.dom.createElement('mo')\n821                         mo.appendChild(self.dom.createTextNode(\" \"))\n822                         mrow.appendChild(mo)\n823                     mi = self.dom.createElement('mi')\n824                     mi.appendChild(self.dom.createTextNode(item))\n825                     mrow.appendChild(mi)\n826                 return mrow\n827             else:\n828                 mi = self.dom.createElement('mi')\n829                 mi.appendChild(self.dom.createTextNode(items[0]))\n830                 return mi\n831 \n832         # translate name, supers and subs to unicode characters\n833         def translate(s):\n834             if s in greek_unicode:\n835                 return greek_unicode.get(s)\n836             else:\n837                 return s\n838 \n839         name, supers, subs = split_super_sub(sym.name)\n840         name = translate(name)\n841         supers = [translate(sup) for sup in supers]\n842         subs = [translate(sub) for sub in subs]\n843 \n844         mname = self.dom.createElement('mi')\n845         mname.appendChild(self.dom.createTextNode(name))\n846         if len(supers) == 0:\n847             if len(subs) == 0:\n848                 x = mname\n849             else:\n850                 x = self.dom.createElement('msub')\n851                 x.appendChild(mname)\n852                 x.appendChild(join(subs))\n853         else:\n854             if len(subs) == 0:\n855                 x = self.dom.createElement('msup')\n856                 x.appendChild(mname)\n857                 x.appendChild(join(supers))\n858             else:\n859                 x = self.dom.createElement('msubsup')\n860                 x.appendChild(mname)\n861                 x.appendChild(join(subs))\n862                 x.appendChild(join(supers))\n863         # Set bold font?\n864         if style == 'bold':\n865             x.setAttribute('mathvariant', 'bold')\n866         return x\n867 \n868     def _print_MatrixSymbol(self, sym):\n869         return self._print_Symbol(sym,\n870                                   style=self._settings['mat_symbol_style'])\n871 \n872     _print_RandomSymbol = _print_Symbol\n873 \n874     def _print_conjugate(self, expr):\n875         enc = self.dom.createElement('menclose')\n876         enc.setAttribute('notation', 'top')\n877         enc.appendChild(self._print(expr.args[0]))\n878         return enc\n879 \n880     def _print_operator_after(self, op, expr):\n881         row = self.dom.createElement('mrow')\n882         row.appendChild(self.parenthesize(expr, PRECEDENCE[\"Func\"]))\n883         mo = self.dom.createElement('mo')\n884         mo.appendChild(self.dom.createTextNode(op))\n885         row.appendChild(mo)\n886         return row\n887 \n888     def _print_factorial(self, expr):\n889         return self._print_operator_after('!', expr.args[0])\n890 \n891     def _print_factorial2(self, expr):\n892         return self._print_operator_after('!!', expr.args[0])\n893 \n894     def _print_binomial(self, expr):\n895         brac = self.dom.createElement('mfenced')\n896         frac = self.dom.createElement('mfrac')\n897         frac.setAttribute('linethickness', '0')\n898         frac.appendChild(self._print(expr.args[0]))\n899         frac.appendChild(self._print(expr.args[1]))\n900         brac.appendChild(frac)\n901         return brac\n902 \n903     def _print_Pow(self, e):\n904         # Here we use root instead of power if the exponent is the\n905         # reciprocal of an integer\n906         if (e.exp.is_Rational and abs(e.exp.p) == 1 and e.exp.q != 1 and\n907                 self._settings['root_notation']):\n908             if e.exp.q == 2:\n909                 x = self.dom.createElement('msqrt')\n910                 x.appendChild(self._print(e.base))\n911             if e.exp.q != 2:\n912                 x = self.dom.createElement('mroot')\n913                 x.appendChild(self._print(e.base))\n914                 x.appendChild(self._print(e.exp.q))\n915             if e.exp.p == -1:\n916                 frac = self.dom.createElement('mfrac')\n917                 frac.appendChild(self._print(1))\n918                 frac.appendChild(x)\n919                 return frac\n920             else:\n921                 return x\n922 \n923         if e.exp.is_Rational and e.exp.q != 1:\n924             if e.exp.is_negative:\n925                 top = self.dom.createElement('mfrac')\n926                 top.appendChild(self._print(1))\n927                 x = self.dom.createElement('msup')\n928                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n929                 x.appendChild(self._get_printed_Rational(-e.exp,\n930                                     self._settings['fold_frac_powers']))\n931                 top.appendChild(x)\n932                 return top\n933             else:\n934                 x = self.dom.createElement('msup')\n935                 x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n936                 x.appendChild(self._get_printed_Rational(e.exp,\n937                                     self._settings['fold_frac_powers']))\n938                 return x\n939 \n940         if e.exp.is_negative:\n941                 top = self.dom.createElement('mfrac')\n942                 top.appendChild(self._print(1))\n943                 if e.exp == -1:\n944                     top.appendChild(self._print(e.base))\n945                 else:\n946                     x = self.dom.createElement('msup')\n947                     x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n948                     x.appendChild(self._print(-e.exp))\n949                     top.appendChild(x)\n950                 return top\n951 \n952         x = self.dom.createElement('msup')\n953         x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n954         x.appendChild(self._print(e.exp))\n955         return x\n956 \n957     def _print_Number(self, e):\n958         x = self.dom.createElement(self.mathml_tag(e))\n959         x.appendChild(self.dom.createTextNode(str(e)))\n960         return x\n961 \n962     def _print_AccumulationBounds(self, i):\n963         brac = self.dom.createElement('mfenced')\n964         brac.setAttribute('open', u'\\u27e8')\n965         brac.setAttribute('close', u'\\u27e9')\n966         brac.appendChild(self._print(i.min))\n967         brac.appendChild(self._print(i.max))\n968         return brac\n969 \n970     def _print_Derivative(self, e):\n971 \n972         if requires_partial(e):\n973             d = '&#x2202;'\n974         else:\n975             d = self.mathml_tag(e)\n976 \n977         # Determine denominator\n978         m = self.dom.createElement('mrow')\n979         dim = 0  # Total diff dimension, for numerator\n980         for sym, num in reversed(e.variable_count):\n981             dim += num\n982             if num >= 2:\n983                 x = self.dom.createElement('msup')\n984                 xx = self.dom.createElement('mo')\n985                 xx.appendChild(self.dom.createTextNode(d))\n986                 x.appendChild(xx)\n987                 x.appendChild(self._print(num))\n988             else:\n989                 x = self.dom.createElement('mo')\n990                 x.appendChild(self.dom.createTextNode(d))\n991             m.appendChild(x)\n992             y = self._print(sym)\n993             m.appendChild(y)\n994 \n995         mnum = self.dom.createElement('mrow')\n996         if dim >= 2:\n997             x = self.dom.createElement('msup')\n998             xx = self.dom.createElement('mo')\n999             xx.appendChild(self.dom.createTextNode(d))\n1000             x.appendChild(xx)\n1001             x.appendChild(self._print(dim))\n1002         else:\n1003             x = self.dom.createElement('mo')\n1004             x.appendChild(self.dom.createTextNode(d))\n1005 \n1006         mnum.appendChild(x)\n1007         mrow = self.dom.createElement('mrow')\n1008         frac = self.dom.createElement('mfrac')\n1009         frac.appendChild(mnum)\n1010         frac.appendChild(m)\n1011         mrow.appendChild(frac)\n1012 \n1013         # Print function\n1014         mrow.appendChild(self._print(e.expr))\n1015 \n1016         return mrow\n1017 \n1018     def _print_Function(self, e):\n1019         mrow = self.dom.createElement('mrow')\n1020         x = self.dom.createElement('mi')\n1021         if self.mathml_tag(e) == 'log' and self._settings[\"ln_notation\"]:\n1022             x.appendChild(self.dom.createTextNode('ln'))\n1023         else:\n1024             x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1025         y = self.dom.createElement('mfenced')\n1026         for arg in e.args:\n1027             y.appendChild(self._print(arg))\n1028         mrow.appendChild(x)\n1029         mrow.appendChild(y)\n1030         return mrow\n1031 \n1032     def _print_Float(self, expr):\n1033         # Based off of that in StrPrinter\n1034         dps = prec_to_dps(expr._prec)\n1035         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n1036 \n1037         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n1038         # thus we use the number separator\n1039         separator = self._settings['mul_symbol_mathml_numbers']\n1040         mrow = self.dom.createElement('mrow')\n1041         if 'e' in str_real:\n1042             (mant, exp) = str_real.split('e')\n1043 \n1044             if exp[0] == '+':\n1045                 exp = exp[1:]\n1046 \n1047             mn = self.dom.createElement('mn')\n1048             mn.appendChild(self.dom.createTextNode(mant))\n1049             mrow.appendChild(mn)\n1050             mo = self.dom.createElement('mo')\n1051             mo.appendChild(self.dom.createTextNode(separator))\n1052             mrow.appendChild(mo)\n1053             msup = self.dom.createElement('msup')\n1054             mn = self.dom.createElement('mn')\n1055             mn.appendChild(self.dom.createTextNode(\"10\"))\n1056             msup.appendChild(mn)\n1057             mn = self.dom.createElement('mn')\n1058             mn.appendChild(self.dom.createTextNode(exp))\n1059             msup.appendChild(mn)\n1060             mrow.appendChild(msup)\n1061             return mrow\n1062         elif str_real == \"+inf\":\n1063             return self._print_Infinity(None)\n1064         elif str_real == \"-inf\":\n1065             return self._print_NegativeInfinity(None)\n1066         else:\n1067             mn = self.dom.createElement('mn')\n1068             mn.appendChild(self.dom.createTextNode(str_real))\n1069             return mn\n1070 \n1071     def _print_polylog(self, expr):\n1072         mrow = self.dom.createElement('mrow')\n1073         m = self.dom.createElement('msub')\n1074 \n1075         mi = self.dom.createElement('mi')\n1076         mi.appendChild(self.dom.createTextNode('Li'))\n1077         m.appendChild(mi)\n1078         m.appendChild(self._print(expr.args[0]))\n1079         mrow.appendChild(m)\n1080         brac = self.dom.createElement('mfenced')\n1081         brac.appendChild(self._print(expr.args[1]))\n1082         mrow.appendChild(brac)\n1083         return mrow\n1084 \n1085     def _print_Basic(self, e):\n1086         mrow = self.dom.createElement('mrow')\n1087         mi = self.dom.createElement('mi')\n1088         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1089         mrow.appendChild(mi)\n1090         brac = self.dom.createElement('mfenced')\n1091         for arg in e.args:\n1092             brac.appendChild(self._print(arg))\n1093         mrow.appendChild(brac)\n1094         return mrow\n1095 \n1096     def _print_Tuple(self, e):\n1097         mrow = self.dom.createElement('mrow')\n1098         x = self.dom.createElement('mfenced')\n1099         for arg in e.args:\n1100             x.appendChild(self._print(arg))\n1101         mrow.appendChild(x)\n1102         return mrow\n1103 \n1104     def _print_Interval(self, i):\n1105         mrow = self.dom.createElement('mrow')\n1106         brac = self.dom.createElement('mfenced')\n1107         if i.start == i.end:\n1108             # Most often, this type of Interval is converted to a FiniteSet\n1109             brac.setAttribute('open', '{')\n1110             brac.setAttribute('close', '}')\n1111             brac.appendChild(self._print(i.start))\n1112         else:\n1113             if i.left_open:\n1114                 brac.setAttribute('open', '(')\n1115             else:\n1116                 brac.setAttribute('open', '[')\n1117 \n1118             if i.right_open:\n1119                 brac.setAttribute('close', ')')\n1120             else:\n1121                 brac.setAttribute('close', ']')\n1122             brac.appendChild(self._print(i.start))\n1123             brac.appendChild(self._print(i.end))\n1124 \n1125         mrow.appendChild(brac)\n1126         return mrow\n1127 \n1128     def _print_Abs(self, expr, exp=None):\n1129         mrow = self.dom.createElement('mrow')\n1130         x = self.dom.createElement('mfenced')\n1131         x.setAttribute('open', '|')\n1132         x.setAttribute('close', '|')\n1133         x.appendChild(self._print(expr.args[0]))\n1134         mrow.appendChild(x)\n1135         return mrow\n1136 \n1137     _print_Determinant = _print_Abs\n1138 \n1139     def _print_re_im(self, c, expr):\n1140         mrow = self.dom.createElement('mrow')\n1141         mi = self.dom.createElement('mi')\n1142         mi.setAttribute('mathvariant', 'fraktur')\n1143         mi.appendChild(self.dom.createTextNode(c))\n1144         mrow.appendChild(mi)\n1145         brac = self.dom.createElement('mfenced')\n1146         brac.appendChild(self._print(expr))\n1147         mrow.appendChild(brac)\n1148         return mrow\n1149 \n1150     def _print_re(self, expr, exp=None):\n1151         return self._print_re_im('R', expr.args[0])\n1152 \n1153     def _print_im(self, expr, exp=None):\n1154         return self._print_re_im('I', expr.args[0])\n1155 \n1156     def _print_AssocOp(self, e):\n1157         mrow = self.dom.createElement('mrow')\n1158         mi = self.dom.createElement('mi')\n1159         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1160         mrow.appendChild(mi)\n1161         for arg in e.args:\n1162             mrow.appendChild(self._print(arg))\n1163         return mrow\n1164 \n1165     def _print_SetOp(self, expr, symbol):\n1166         mrow = self.dom.createElement('mrow')\n1167         mrow.appendChild(self._print(expr.args[0]))\n1168         for arg in expr.args[1:]:\n1169             x = self.dom.createElement('mo')\n1170             x.appendChild(self.dom.createTextNode(symbol))\n1171             y = self._print(arg)\n1172             mrow.appendChild(x)\n1173             mrow.appendChild(y)\n1174         return mrow\n1175 \n1176     def _print_Union(self, expr):\n1177         return self._print_SetOp(expr, '&#x222A;')\n1178 \n1179     def _print_Intersection(self, expr):\n1180         return self._print_SetOp(expr, '&#x2229;')\n1181 \n1182     def _print_Complement(self, expr):\n1183         return self._print_SetOp(expr, '&#x2216;')\n1184 \n1185     def _print_SymmetricDifference(self, expr):\n1186         return self._print_SetOp(expr, '&#x2206;')\n1187 \n1188     def _print_FiniteSet(self, s):\n1189         return self._print_set(s.args)\n1190 \n1191     def _print_set(self, s):\n1192         items = sorted(s, key=default_sort_key)\n1193         brac = self.dom.createElement('mfenced')\n1194         brac.setAttribute('open', '{')\n1195         brac.setAttribute('close', '}')\n1196         for item in items:\n1197             brac.appendChild(self._print(item))\n1198         return brac\n1199 \n1200     _print_frozenset = _print_set\n1201 \n1202     def _print_LogOp(self, args, symbol):\n1203         mrow = self.dom.createElement('mrow')\n1204         if args[0].is_Boolean and not args[0].is_Not:\n1205             brac = self.dom.createElement('mfenced')\n1206             brac.appendChild(self._print(args[0]))\n1207             mrow.appendChild(brac)\n1208         else:\n1209             mrow.appendChild(self._print(args[0]))\n1210         for arg in args[1:]:\n1211             x = self.dom.createElement('mo')\n1212             x.appendChild(self.dom.createTextNode(symbol))\n1213             if arg.is_Boolean and not arg.is_Not:\n1214                 y = self.dom.createElement('mfenced')\n1215                 y.appendChild(self._print(arg))\n1216             else:\n1217                 y = self._print(arg)\n1218             mrow.appendChild(x)\n1219             mrow.appendChild(y)\n1220         return mrow\n1221 \n1222     def _print_BasisDependent(self, expr):\n1223         from sympy.vector import Vector\n1224 \n1225         if expr == expr.zero:\n1226             # Not clear if this is ever called\n1227             return self._print(expr.zero)\n1228         if isinstance(expr, Vector):\n1229             items = expr.separate().items()\n1230         else:\n1231             items = [(0, expr)]\n1232 \n1233         mrow = self.dom.createElement('mrow')\n1234         for system, vect in items:\n1235             inneritems = list(vect.components.items())\n1236             inneritems.sort(key = lambda x:x[0].__str__())\n1237             for i, (k, v) in enumerate(inneritems):\n1238                 if v == 1:\n1239                     if i: # No + for first item\n1240                         mo = self.dom.createElement('mo')\n1241                         mo.appendChild(self.dom.createTextNode('+'))\n1242                         mrow.appendChild(mo)\n1243                     mrow.appendChild(self._print(k))\n1244                 elif v == -1:\n1245                     mo = self.dom.createElement('mo')\n1246                     mo.appendChild(self.dom.createTextNode('-'))\n1247                     mrow.appendChild(mo)\n1248                     mrow.appendChild(self._print(k))\n1249                 else:\n1250                     if i: # No + for first item\n1251                         mo = self.dom.createElement('mo')\n1252                         mo.appendChild(self.dom.createTextNode('+'))\n1253                         mrow.appendChild(mo)\n1254                     mbrac = self.dom.createElement('mfenced')\n1255                     mbrac.appendChild(self._print(v))\n1256                     mrow.appendChild(mbrac)\n1257                     mo = self.dom.createElement('mo')\n1258                     mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))\n1259                     mrow.appendChild(mo)\n1260                     mrow.appendChild(self._print(k))\n1261         return mrow\n1262 \n1263 \n1264     def _print_And(self, expr):\n1265         args = sorted(expr.args, key=default_sort_key)\n1266         return self._print_LogOp(args, '&#x2227;')\n1267 \n1268     def _print_Or(self, expr):\n1269         args = sorted(expr.args, key=default_sort_key)\n1270         return self._print_LogOp(args, '&#x2228;')\n1271 \n1272     def _print_Xor(self, expr):\n1273         args = sorted(expr.args, key=default_sort_key)\n1274         return self._print_LogOp(args, '&#x22BB;')\n1275 \n1276     def _print_Implies(self, expr):\n1277         return self._print_LogOp(expr.args, '&#x21D2;')\n1278 \n1279     def _print_Equivalent(self, expr):\n1280         args = sorted(expr.args, key=default_sort_key)\n1281         return self._print_LogOp(args, '&#x21D4;')\n1282 \n1283     def _print_Not(self, e):\n1284         mrow = self.dom.createElement('mrow')\n1285         mo = self.dom.createElement('mo')\n1286         mo.appendChild(self.dom.createTextNode('&#xAC;'))\n1287         mrow.appendChild(mo)\n1288         if (e.args[0].is_Boolean):\n1289             x = self.dom.createElement('mfenced')\n1290             x.appendChild(self._print(e.args[0]))\n1291         else:\n1292             x = self._print(e.args[0])\n1293         mrow.appendChild(x)\n1294         return mrow\n1295 \n1296     def _print_bool(self, e):\n1297         mi = self.dom.createElement('mi')\n1298         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1299         return mi\n1300 \n1301     _print_BooleanTrue = _print_bool\n1302     _print_BooleanFalse = _print_bool\n1303 \n1304     def _print_NoneType(self, e):\n1305         mi = self.dom.createElement('mi')\n1306         mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1307         return mi\n1308 \n1309     def _print_Range(self, s):\n1310         dots = u\"\\u2026\"\n1311         brac = self.dom.createElement('mfenced')\n1312         brac.setAttribute('open', '{')\n1313         brac.setAttribute('close', '}')\n1314 \n1315         if s.start.is_infinite:\n1316             printset = dots, s[-1] - s.step, s[-1]\n1317         elif s.stop.is_infinite:\n1318             it = iter(s)\n1319             printset = next(it), next(it), dots\n1320         elif len(s) > 4:\n1321             it = iter(s)\n1322             printset = next(it), next(it), dots, s[-1]\n1323         else:\n1324             printset = tuple(s)\n1325 \n1326         for el in printset:\n1327             if el == dots:\n1328                 mi = self.dom.createElement('mi')\n1329                 mi.appendChild(self.dom.createTextNode(dots))\n1330                 brac.appendChild(mi)\n1331             else:\n1332                 brac.appendChild(self._print(el))\n1333 \n1334         return brac\n1335 \n1336     def _hprint_variadic_function(self, expr):\n1337         args = sorted(expr.args, key=default_sort_key)\n1338         mrow = self.dom.createElement('mrow')\n1339         mo = self.dom.createElement('mo')\n1340         mo.appendChild(self.dom.createTextNode((str(expr.func)).lower()))\n1341         mrow.appendChild(mo)\n1342         brac = self.dom.createElement('mfenced')\n1343         for symbol in args:\n1344             brac.appendChild(self._print(symbol))\n1345         mrow.appendChild(brac)\n1346         return mrow\n1347 \n1348     _print_Min = _print_Max = _hprint_variadic_function\n1349 \n1350     def _print_exp(self, expr):\n1351         msup = self.dom.createElement('msup')\n1352         msup.appendChild(self._print_Exp1(None))\n1353         msup.appendChild(self._print(expr.args[0]))\n1354         return msup\n1355 \n1356     def _print_Relational(self, e):\n1357         mrow = self.dom.createElement('mrow')\n1358         mrow.appendChild(self._print(e.lhs))\n1359         x = self.dom.createElement('mo')\n1360         x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n1361         mrow.appendChild(x)\n1362         mrow.appendChild(self._print(e.rhs))\n1363         return mrow\n1364 \n1365     def _print_int(self, p):\n1366         dom_element = self.dom.createElement(self.mathml_tag(p))\n1367         dom_element.appendChild(self.dom.createTextNode(str(p)))\n1368         return dom_element\n1369 \n1370     def _print_BaseScalar(self, e):\n1371         msub = self.dom.createElement('msub')\n1372         index, system = e._id\n1373         mi = self.dom.createElement('mi')\n1374         mi.setAttribute('mathvariant', 'bold')\n1375         mi.appendChild(self.dom.createTextNode(system._variable_names[index]))\n1376         msub.appendChild(mi)\n1377         mi = self.dom.createElement('mi')\n1378         mi.setAttribute('mathvariant', 'bold')\n1379         mi.appendChild(self.dom.createTextNode(system._name))\n1380         msub.appendChild(mi)\n1381         return msub\n1382 \n1383     def _print_BaseVector(self, e):\n1384         msub = self.dom.createElement('msub')\n1385         index, system = e._id\n1386         mover = self.dom.createElement('mover')\n1387         mi = self.dom.createElement('mi')\n1388         mi.setAttribute('mathvariant', 'bold')\n1389         mi.appendChild(self.dom.createTextNode(system._vector_names[index]))\n1390         mover.appendChild(mi)\n1391         mo = self.dom.createElement('mo')\n1392         mo.appendChild(self.dom.createTextNode('^'))\n1393         mover.appendChild(mo)\n1394         msub.appendChild(mover)\n1395         mi = self.dom.createElement('mi')\n1396         mi.setAttribute('mathvariant', 'bold')\n1397         mi.appendChild(self.dom.createTextNode(system._name))\n1398         msub.appendChild(mi)\n1399         return msub\n1400 \n1401     def _print_VectorZero(self, e):\n1402         mover = self.dom.createElement('mover')\n1403         mi = self.dom.createElement('mi')\n1404         mi.setAttribute('mathvariant', 'bold')\n1405         mi.appendChild(self.dom.createTextNode(\"0\"))\n1406         mover.appendChild(mi)\n1407         mo = self.dom.createElement('mo')\n1408         mo.appendChild(self.dom.createTextNode('^'))\n1409         mover.appendChild(mo)\n1410         return mover\n1411 \n1412     def _print_Cross(self, expr):\n1413         mrow = self.dom.createElement('mrow')\n1414         vec1 = expr._expr1\n1415         vec2 = expr._expr2\n1416         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))\n1417         mo = self.dom.createElement('mo')\n1418         mo.appendChild(self.dom.createTextNode('&#xD7;'))\n1419         mrow.appendChild(mo)\n1420         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))\n1421         return mrow\n1422 \n1423     def _print_Curl(self, expr):\n1424         mrow = self.dom.createElement('mrow')\n1425         mo = self.dom.createElement('mo')\n1426         mo.appendChild(self.dom.createTextNode('&#x2207;'))\n1427         mrow.appendChild(mo)\n1428         mo = self.dom.createElement('mo')\n1429         mo.appendChild(self.dom.createTextNode('&#xD7;'))\n1430         mrow.appendChild(mo)\n1431         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n1432         return mrow\n1433 \n1434     def _print_Divergence(self, expr):\n1435         mrow = self.dom.createElement('mrow')\n1436         mo = self.dom.createElement('mo')\n1437         mo.appendChild(self.dom.createTextNode('&#x2207;'))\n1438         mrow.appendChild(mo)\n1439         mo = self.dom.createElement('mo')\n1440         mo.appendChild(self.dom.createTextNode('&#xB7;'))\n1441         mrow.appendChild(mo)\n1442         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n1443         return mrow\n1444 \n1445     def _print_Dot(self, expr):\n1446         mrow = self.dom.createElement('mrow')\n1447         vec1 = expr._expr1\n1448         vec2 = expr._expr2\n1449         mrow.appendChild(self.parenthesize(vec1, PRECEDENCE['Mul']))\n1450         mo = self.dom.createElement('mo')\n1451         mo.appendChild(self.dom.createTextNode('&#xB7;'))\n1452         mrow.appendChild(mo)\n1453         mrow.appendChild(self.parenthesize(vec2, PRECEDENCE['Mul']))\n1454         return mrow\n1455 \n1456     def _print_Gradient(self, expr):\n1457         mrow = self.dom.createElement('mrow')\n1458         mo = self.dom.createElement('mo')\n1459         mo.appendChild(self.dom.createTextNode('&#x2207;'))\n1460         mrow.appendChild(mo)\n1461         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n1462         return mrow\n1463 \n1464     def _print_Laplacian(self, expr):\n1465         mrow = self.dom.createElement('mrow')\n1466         mo = self.dom.createElement('mo')\n1467         mo.appendChild(self.dom.createTextNode('&#x2206;'))\n1468         mrow.appendChild(mo)\n1469         mrow.appendChild(self.parenthesize(expr._expr, PRECEDENCE['Mul']))\n1470         return mrow\n1471 \n1472     def _print_Integers(self, e):\n1473         x = self.dom.createElement('mi')\n1474         x.setAttribute('mathvariant', 'normal')\n1475         x.appendChild(self.dom.createTextNode('&#x2124;'))\n1476         return x\n1477 \n1478     def _print_Complexes(self, e):\n1479         x = self.dom.createElement('mi')\n1480         x.setAttribute('mathvariant', 'normal')\n1481         x.appendChild(self.dom.createTextNode('&#x2102;'))\n1482         return x\n1483 \n1484     def _print_Reals(self, e):\n1485         x = self.dom.createElement('mi')\n1486         x.setAttribute('mathvariant', 'normal')\n1487         x.appendChild(self.dom.createTextNode('&#x211D;'))\n1488         return x\n1489 \n1490     def _print_Naturals(self, e):\n1491         x = self.dom.createElement('mi')\n1492         x.setAttribute('mathvariant', 'normal')\n1493         x.appendChild(self.dom.createTextNode('&#x2115;'))\n1494         return x\n1495 \n1496     def _print_Naturals0(self, e):\n1497         sub = self.dom.createElement('msub')\n1498         x = self.dom.createElement('mi')\n1499         x.setAttribute('mathvariant', 'normal')\n1500         x.appendChild(self.dom.createTextNode('&#x2115;'))\n1501         sub.appendChild(x)\n1502         sub.appendChild(self._print(S.Zero))\n1503         return sub\n1504 \n1505     def _print_SingularityFunction(self, expr):\n1506         shift = expr.args[0] - expr.args[1]\n1507         power = expr.args[2]\n1508         sup = self.dom.createElement('msup')\n1509         brac = self.dom.createElement('mfenced')\n1510         brac.setAttribute('open', u'\\u27e8')\n1511         brac.setAttribute('close', u'\\u27e9')\n1512         brac.appendChild(self._print(shift))\n1513         sup.appendChild(brac)\n1514         sup.appendChild(self._print(power))\n1515         return sup\n1516 \n1517     def _print_NaN(self, e):\n1518         x = self.dom.createElement('mi')\n1519         x.appendChild(self.dom.createTextNode('NaN'))\n1520         return x\n1521 \n1522     def _print_bernoulli(self, e):\n1523         sub = self.dom.createElement('msub')\n1524         mi = self.dom.createElement('mi')\n1525         mi.appendChild(self.dom.createTextNode('B'))\n1526         sub.appendChild(mi)\n1527         sub.appendChild(self._print(e.args[0]))\n1528         return sub\n1529 \n1530     _print_bell = _print_bernoulli\n1531 \n1532     def _print_catalan(self, e):\n1533         sub = self.dom.createElement('msub')\n1534         mi = self.dom.createElement('mi')\n1535         mi.appendChild(self.dom.createTextNode('C'))\n1536         sub.appendChild(mi)\n1537         sub.appendChild(self._print(e.args[0]))\n1538         return sub\n1539 \n1540     def _print_fibonacci(self, e):\n1541         sub = self.dom.createElement('msub')\n1542         mi = self.dom.createElement('mi')\n1543         mi.appendChild(self.dom.createTextNode('F'))\n1544         sub.appendChild(mi)\n1545         sub.appendChild(self._print(e.args[0]))\n1546         return sub\n1547 \n1548     def _print_lucas(self, e):\n1549         sub = self.dom.createElement('msub')\n1550         mi = self.dom.createElement('mi')\n1551         mi.appendChild(self.dom.createTextNode('L'))\n1552         sub.appendChild(mi)\n1553         sub.appendChild(self._print(e.args[0]))\n1554         return sub\n1555 \n1556     def _print_tribonacci(self, e):\n1557         sub = self.dom.createElement('msub')\n1558         mi = self.dom.createElement('mi')\n1559         mi.appendChild(self.dom.createTextNode('T'))\n1560         sub.appendChild(mi)\n1561         sub.appendChild(self._print(e.args[0]))\n1562         return sub\n1563 \n1564     def _print_ComplexInfinity(self, e):\n1565         x = self.dom.createElement('mover')\n1566         mo = self.dom.createElement('mo')\n1567         mo.appendChild(self.dom.createTextNode('&#x221E;'))\n1568         x.appendChild(mo)\n1569         mo = self.dom.createElement('mo')\n1570         mo.appendChild(self.dom.createTextNode('~'))\n1571         x.appendChild(mo)\n1572         return x\n1573 \n1574     def _print_EmptySet(self, e):\n1575         x = self.dom.createElement('mo')\n1576         x.appendChild(self.dom.createTextNode('&#x2205;'))\n1577         return x\n1578 \n1579     def _print_UniversalSet(self, e):\n1580         x = self.dom.createElement('mo')\n1581         x.appendChild(self.dom.createTextNode('&#x1D54C;'))\n1582         return x\n1583 \n1584     def _print_Adjoint(self, expr):\n1585         from sympy.matrices import MatrixSymbol\n1586         mat = expr.arg\n1587         sup = self.dom.createElement('msup')\n1588         if not isinstance(mat, MatrixSymbol):\n1589             brac = self.dom.createElement('mfenced')\n1590             brac.appendChild(self._print(mat))\n1591             sup.appendChild(brac)\n1592         else:\n1593             sup.appendChild(self._print(mat))\n1594         mo = self.dom.createElement('mo')\n1595         mo.appendChild(self.dom.createTextNode('&#x2020;'))\n1596         sup.appendChild(mo)\n1597         return sup\n1598 \n1599     def _print_Transpose(self, expr):\n1600         from sympy.matrices import MatrixSymbol\n1601         mat = expr.arg\n1602         sup = self.dom.createElement('msup')\n1603         if not isinstance(mat, MatrixSymbol):\n1604             brac = self.dom.createElement('mfenced')\n1605             brac.appendChild(self._print(mat))\n1606             sup.appendChild(brac)\n1607         else:\n1608             sup.appendChild(self._print(mat))\n1609         mo = self.dom.createElement('mo')\n1610         mo.appendChild(self.dom.createTextNode('T'))\n1611         sup.appendChild(mo)\n1612         return sup\n1613 \n1614     def _print_Inverse(self, expr):\n1615         from sympy.matrices import MatrixSymbol\n1616         mat = expr.arg\n1617         sup = self.dom.createElement('msup')\n1618         if not isinstance(mat, MatrixSymbol):\n1619             brac = self.dom.createElement('mfenced')\n1620             brac.appendChild(self._print(mat))\n1621             sup.appendChild(brac)\n1622         else:\n1623             sup.appendChild(self._print(mat))\n1624         sup.appendChild(self._print(-1))\n1625         return sup\n1626 \n1627     def _print_MatMul(self, expr):\n1628         from sympy import MatMul\n1629 \n1630         x = self.dom.createElement('mrow')\n1631         args = expr.args\n1632         if isinstance(args[0], Mul):\n1633             args = args[0].as_ordered_factors() + list(args[1:])\n1634         else:\n1635             args = list(args)\n1636 \n1637         if isinstance(expr, MatMul) and _coeff_isneg(expr):\n1638             if args[0] == -1:\n1639                 args = args[1:]\n1640             else:\n1641                 args[0] = -args[0]\n1642             mo = self.dom.createElement('mo')\n1643             mo.appendChild(self.dom.createTextNode('-'))\n1644             x.appendChild(mo)\n1645 \n1646         for arg in args[:-1]:\n1647             x.appendChild(self.parenthesize(arg, precedence_traditional(expr),\n1648                                             False))\n1649             mo = self.dom.createElement('mo')\n1650             mo.appendChild(self.dom.createTextNode('&InvisibleTimes;'))\n1651             x.appendChild(mo)\n1652         x.appendChild(self.parenthesize(args[-1], precedence_traditional(expr),\n1653                                         False))\n1654         return x\n1655 \n1656     def _print_MatPow(self, expr):\n1657         from sympy.matrices import MatrixSymbol\n1658         base, exp = expr.base, expr.exp\n1659         sup = self.dom.createElement('msup')\n1660         if not isinstance(base, MatrixSymbol):\n1661             brac = self.dom.createElement('mfenced')\n1662             brac.appendChild(self._print(base))\n1663             sup.appendChild(brac)\n1664         else:\n1665             sup.appendChild(self._print(base))\n1666         sup.appendChild(self._print(exp))\n1667         return sup\n1668 \n1669     def _print_HadamardProduct(self, expr):\n1670         x = self.dom.createElement('mrow')\n1671         args = expr.args\n1672         for arg in args[:-1]:\n1673             x.appendChild(\n1674                 self.parenthesize(arg, precedence_traditional(expr), False))\n1675             mo = self.dom.createElement('mo')\n1676             mo.appendChild(self.dom.createTextNode('&#x2218;'))\n1677             x.appendChild(mo)\n1678         x.appendChild(\n1679             self.parenthesize(args[-1], precedence_traditional(expr), False))\n1680         return x\n1681 \n1682     def _print_ZeroMatrix(self, Z):\n1683         x = self.dom.createElement('mn')\n1684         x.appendChild(self.dom.createTextNode('&#x1D7D8'))\n1685         return x\n1686 \n1687     def _print_Identity(self, I):\n1688         x = self.dom.createElement('mi')\n1689         x.appendChild(self.dom.createTextNode('&#x1D540;'))\n1690         return x\n1691 \n1692     def _print_floor(self, e):\n1693         mrow = self.dom.createElement('mrow')\n1694         x = self.dom.createElement('mfenced')\n1695         x.setAttribute('open', u'\\u230A')\n1696         x.setAttribute('close', u'\\u230B')\n1697         x.appendChild(self._print(e.args[0]))\n1698         mrow.appendChild(x)\n1699         return mrow\n1700 \n1701     def _print_ceiling(self, e):\n1702         mrow = self.dom.createElement('mrow')\n1703         x = self.dom.createElement('mfenced')\n1704         x.setAttribute('open', u'\\u2308')\n1705         x.setAttribute('close', u'\\u2309')\n1706         x.appendChild(self._print(e.args[0]))\n1707         mrow.appendChild(x)\n1708         return mrow\n1709 \n1710     def _print_Lambda(self, e):\n1711         x = self.dom.createElement('mfenced')\n1712         mrow = self.dom.createElement('mrow')\n1713         symbols = e.args[0]\n1714         if len(symbols) == 1:\n1715             symbols = self._print(symbols[0])\n1716         else:\n1717             symbols = self._print(symbols)\n1718         mrow.appendChild(symbols)\n1719         mo = self.dom.createElement('mo')\n1720         mo.appendChild(self.dom.createTextNode('&#x21A6;'))\n1721         mrow.appendChild(mo)\n1722         mrow.appendChild(self._print(e.args[1]))\n1723         x.appendChild(mrow)\n1724         return x\n1725 \n1726     def _print_tuple(self, e):\n1727         x = self.dom.createElement('mfenced')\n1728         for i in e:\n1729             x.appendChild(self._print(i))\n1730         return x\n1731 \n1732     def _print_IndexedBase(self, e):\n1733         return self._print(e.label)\n1734 \n1735     def _print_Indexed(self, e):\n1736         x = self.dom.createElement('msub')\n1737         x.appendChild(self._print(e.base))\n1738         if len(e.indices) == 1:\n1739             x.appendChild(self._print(e.indices[0]))\n1740             return x\n1741         x.appendChild(self._print(e.indices))\n1742         return x\n1743 \n1744     def _print_MatrixElement(self, e):\n1745         x = self.dom.createElement('msub')\n1746         x.appendChild(self.parenthesize(e.parent, PRECEDENCE[\"Atom\"], strict = True))\n1747         brac = self.dom.createElement('mfenced')\n1748         brac.setAttribute(\"open\", \"\")\n1749         brac.setAttribute(\"close\", \"\")\n1750         for i in e.indices:\n1751             brac.appendChild(self._print(i))\n1752         x.appendChild(brac)\n1753         return x\n1754 \n1755     def _print_elliptic_f(self, e):\n1756         x = self.dom.createElement('mrow')\n1757         mi = self.dom.createElement('mi')\n1758         mi.appendChild(self.dom.createTextNode('&#x1d5a5;'))\n1759         x.appendChild(mi)\n1760         y = self.dom.createElement('mfenced')\n1761         y.setAttribute(\"separators\", \"|\")\n1762         for i in e.args:\n1763             y.appendChild(self._print(i))\n1764         x.appendChild(y)\n1765         return x\n1766 \n1767     def _print_elliptic_e(self, e):\n1768         x = self.dom.createElement('mrow')\n1769         mi = self.dom.createElement('mi')\n1770         mi.appendChild(self.dom.createTextNode('&#x1d5a4;'))\n1771         x.appendChild(mi)\n1772         y = self.dom.createElement('mfenced')\n1773         y.setAttribute(\"separators\", \"|\")\n1774         for i in e.args:\n1775             y.appendChild(self._print(i))\n1776         x.appendChild(y)\n1777         return x\n1778 \n1779     def _print_elliptic_pi(self, e):\n1780         x = self.dom.createElement('mrow')\n1781         mi = self.dom.createElement('mi')\n1782         mi.appendChild(self.dom.createTextNode('&#x1d6f1;'))\n1783         x.appendChild(mi)\n1784         y = self.dom.createElement('mfenced')\n1785         if len(e.args) == 2:\n1786             y.setAttribute(\"separators\", \"|\")\n1787         else:\n1788             y.setAttribute(\"separators\", \";|\")\n1789         for i in e.args:\n1790             y.appendChild(self._print(i))\n1791         x.appendChild(y)\n1792         return x\n1793 \n1794     def _print_Ei(self, e):\n1795         x = self.dom.createElement('mrow')\n1796         mi = self.dom.createElement('mi')\n1797         mi.appendChild(self.dom.createTextNode('Ei'))\n1798         x.appendChild(mi)\n1799         x.appendChild(self._print(e.args))\n1800         return x\n1801 \n1802     def _print_expint(self, e):\n1803         x = self.dom.createElement('mrow')\n1804         y = self.dom.createElement('msub')\n1805         mo = self.dom.createElement('mo')\n1806         mo.appendChild(self.dom.createTextNode('E'))\n1807         y.appendChild(mo)\n1808         y.appendChild(self._print(e.args[0]))\n1809         x.appendChild(y)\n1810         x.appendChild(self._print(e.args[1:]))\n1811         return x\n1812 \n1813     def _print_jacobi(self, e):\n1814         x = self.dom.createElement('mrow')\n1815         y = self.dom.createElement('msubsup')\n1816         mo = self.dom.createElement('mo')\n1817         mo.appendChild(self.dom.createTextNode('P'))\n1818         y.appendChild(mo)\n1819         y.appendChild(self._print(e.args[0]))\n1820         y.appendChild(self._print(e.args[1:3]))\n1821         x.appendChild(y)\n1822         x.appendChild(self._print(e.args[3:]))\n1823         return x\n1824 \n1825     def _print_gegenbauer(self, e):\n1826         x = self.dom.createElement('mrow')\n1827         y = self.dom.createElement('msubsup')\n1828         mo = self.dom.createElement('mo')\n1829         mo.appendChild(self.dom.createTextNode('C'))\n1830         y.appendChild(mo)\n1831         y.appendChild(self._print(e.args[0]))\n1832         y.appendChild(self._print(e.args[1:2]))\n1833         x.appendChild(y)\n1834         x.appendChild(self._print(e.args[2:]))\n1835         return x\n1836 \n1837     def _print_chebyshevt(self, e):\n1838         x = self.dom.createElement('mrow')\n1839         y = self.dom.createElement('msub')\n1840         mo = self.dom.createElement('mo')\n1841         mo.appendChild(self.dom.createTextNode('T'))\n1842         y.appendChild(mo)\n1843         y.appendChild(self._print(e.args[0]))\n1844         x.appendChild(y)\n1845         x.appendChild(self._print(e.args[1:]))\n1846         return x\n1847 \n1848     def _print_chebyshevu(self, e):\n1849         x = self.dom.createElement('mrow')\n1850         y = self.dom.createElement('msub')\n1851         mo = self.dom.createElement('mo')\n1852         mo.appendChild(self.dom.createTextNode('U'))\n1853         y.appendChild(mo)\n1854         y.appendChild(self._print(e.args[0]))\n1855         x.appendChild(y)\n1856         x.appendChild(self._print(e.args[1:]))\n1857         return x\n1858 \n1859     def _print_legendre(self, e):\n1860         x = self.dom.createElement('mrow')\n1861         y = self.dom.createElement('msub')\n1862         mo = self.dom.createElement('mo')\n1863         mo.appendChild(self.dom.createTextNode('P'))\n1864         y.appendChild(mo)\n1865         y.appendChild(self._print(e.args[0]))\n1866         x.appendChild(y)\n1867         x.appendChild(self._print(e.args[1:]))\n1868         return x\n1869 \n1870     def _print_assoc_legendre(self, e):\n1871         x = self.dom.createElement('mrow')\n1872         y = self.dom.createElement('msubsup')\n1873         mo = self.dom.createElement('mo')\n1874         mo.appendChild(self.dom.createTextNode('P'))\n1875         y.appendChild(mo)\n1876         y.appendChild(self._print(e.args[0]))\n1877         y.appendChild(self._print(e.args[1:2]))\n1878         x.appendChild(y)\n1879         x.appendChild(self._print(e.args[2:]))\n1880         return x\n1881 \n1882     def _print_laguerre(self, e):\n1883         x = self.dom.createElement('mrow')\n1884         y = self.dom.createElement('msub')\n1885         mo = self.dom.createElement('mo')\n1886         mo.appendChild(self.dom.createTextNode('L'))\n1887         y.appendChild(mo)\n1888         y.appendChild(self._print(e.args[0]))\n1889         x.appendChild(y)\n1890         x.appendChild(self._print(e.args[1:]))\n1891         return x\n1892 \n1893     def _print_assoc_laguerre(self, e):\n1894         x = self.dom.createElement('mrow')\n1895         y = self.dom.createElement('msubsup')\n1896         mo = self.dom.createElement('mo')\n1897         mo.appendChild(self.dom.createTextNode('L'))\n1898         y.appendChild(mo)\n1899         y.appendChild(self._print(e.args[0]))\n1900         y.appendChild(self._print(e.args[1:2]))\n1901         x.appendChild(y)\n1902         x.appendChild(self._print(e.args[2:]))\n1903         return x\n1904 \n1905     def _print_hermite(self, e):\n1906         x = self.dom.createElement('mrow')\n1907         y = self.dom.createElement('msub')\n1908         mo = self.dom.createElement('mo')\n1909         mo.appendChild(self.dom.createTextNode('H'))\n1910         y.appendChild(mo)\n1911         y.appendChild(self._print(e.args[0]))\n1912         x.appendChild(y)\n1913         x.appendChild(self._print(e.args[1:]))\n1914         return x\n1915 \n1916 \n1917 def mathml(expr, printer='content', **settings):\n1918     \"\"\"Returns the MathML representation of expr. If printer is presentation\n1919     then prints Presentation MathML else prints content MathML.\n1920     \"\"\"\n1921     if printer == 'presentation':\n1922         return MathMLPresentationPrinter(settings).doprint(expr)\n1923     else:\n1924         return MathMLContentPrinter(settings).doprint(expr)\n1925 \n1926 \n1927 def print_mathml(expr, printer='content', **settings):\n1928     \"\"\"\n1929     Prints a pretty representation of the MathML code for expr. If printer is\n1930     presentation then prints Presentation MathML else prints content MathML.\n1931 \n1932     Examples\n1933     ========\n1934 \n1935     >>> ##\n1936     >>> from sympy.printing.mathml import print_mathml\n1937     >>> from sympy.abc import x\n1938     >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE\n1939     <apply>\n1940         <plus/>\n1941         <ci>x</ci>\n1942         <cn>1</cn>\n1943     </apply>\n1944     >>> print_mathml(x+1, printer='presentation')\n1945     <mrow>\n1946         <mi>x</mi>\n1947         <mo>+</mo>\n1948         <mn>1</mn>\n1949     </mrow>\n1950 \n1951     \"\"\"\n1952     if printer == 'presentation':\n1953         s = MathMLPresentationPrinter(settings)\n1954     else:\n1955         s = MathMLContentPrinter(settings)\n1956     xml = s._print(sympify(expr))\n1957     s.apply_patch()\n1958     pretty_xml = xml.toprettyxml()\n1959     s.restore_patch()\n1960 \n1961     print(pretty_xml)\n1962 \n1963 \n1964 # For backward compatibility\n1965 MathMLPrinter = MathMLContentPrinter\n",
        "intended_behavior": "Extend the existing MathML printing support to include custom handling for `OneMatrix`, `ZeroMatrix`, and `Identity` classes. This includes defining appropriate MathML elements and attributes that accurately represent these special matrices. The goal here is to ensure that these matrices are distinguishable and correctly represented within MathML outputs, facilitating improved presentation in web environments."
    },
    {
        "rel_file_path": "sympy/matrices/expressions/matexpr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/matrices/expressions/matexpr.py",
        "start": 1,
        "end": 1192,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from functools import wraps, reduce\n4 import collections\n5 \n6 from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq, Mul, Add\n7 from sympy.core.decorators import call_highest_priority\n8 from sympy.core.compatibility import range, SYMPY_INTS, default_sort_key, string_types\n9 from sympy.core.sympify import SympifyError, _sympify\n10 from sympy.functions import conjugate, adjoint\n11 from sympy.functions.special.tensor_functions import KroneckerDelta\n12 from sympy.matrices import ShapeError\n13 from sympy.simplify import simplify\n14 from sympy.utilities.misc import filldedent\n15 \n16 \n17 def _sympifyit(arg, retval=None):\n18     # This version of _sympifyit sympifies MutableMatrix objects\n19     def deco(func):\n20         @wraps(func)\n21         def __sympifyit_wrapper(a, b):\n22             try:\n23                 b = _sympify(b)\n24                 return func(a, b)\n25             except SympifyError:\n26                 return retval\n27 \n28         return __sympifyit_wrapper\n29 \n30     return deco\n31 \n32 \n33 class MatrixExpr(Expr):\n34     \"\"\"Superclass for Matrix Expressions\n35 \n36     MatrixExprs represent abstract matrices, linear transformations represented\n37     within a particular basis.\n38 \n39     Examples\n40     ========\n41 \n42     >>> from sympy import MatrixSymbol\n43     >>> A = MatrixSymbol('A', 3, 3)\n44     >>> y = MatrixSymbol('y', 3, 1)\n45     >>> x = (A.T*A).I * A * y\n46 \n47     See Also\n48     ========\n49 \n50     MatrixSymbol, MatAdd, MatMul, Transpose, Inverse\n51     \"\"\"\n52 \n53     # Should not be considered iterable by the\n54     # sympy.core.compatibility.iterable function. Subclass that actually are\n55     # iterable (i.e., explicit matrices) should set this to True.\n56     _iterable = False\n57 \n58     _op_priority = 11.0\n59 \n60     is_Matrix = True\n61     is_MatrixExpr = True\n62     is_Identity = None\n63     is_Inverse = False\n64     is_Transpose = False\n65     is_ZeroMatrix = False\n66     is_MatAdd = False\n67     is_MatMul = False\n68 \n69     is_commutative = False\n70     is_number = False\n71     is_symbol = False\n72     is_scalar = False\n73 \n74     def __new__(cls, *args, **kwargs):\n75         args = map(_sympify, args)\n76         return Basic.__new__(cls, *args, **kwargs)\n77 \n78     # The following is adapted from the core Expr object\n79     def __neg__(self):\n80         return MatMul(S.NegativeOne, self).doit()\n81 \n82     def __abs__(self):\n83         raise NotImplementedError\n84 \n85     @_sympifyit('other', NotImplemented)\n86     @call_highest_priority('__radd__')\n87     def __add__(self, other):\n88         return MatAdd(self, other, check=True).doit()\n89 \n90     @_sympifyit('other', NotImplemented)\n91     @call_highest_priority('__add__')\n92     def __radd__(self, other):\n93         return MatAdd(other, self, check=True).doit()\n94 \n95     @_sympifyit('other', NotImplemented)\n96     @call_highest_priority('__rsub__')\n97     def __sub__(self, other):\n98         return MatAdd(self, -other, check=True).doit()\n99 \n100     @_sympifyit('other', NotImplemented)\n101     @call_highest_priority('__sub__')\n102     def __rsub__(self, other):\n103         return MatAdd(other, -self, check=True).doit()\n104 \n105     @_sympifyit('other', NotImplemented)\n106     @call_highest_priority('__rmul__')\n107     def __mul__(self, other):\n108         return MatMul(self, other).doit()\n109 \n110     @_sympifyit('other', NotImplemented)\n111     @call_highest_priority('__rmul__')\n112     def __matmul__(self, other):\n113         return MatMul(self, other).doit()\n114 \n115     @_sympifyit('other', NotImplemented)\n116     @call_highest_priority('__mul__')\n117     def __rmul__(self, other):\n118         return MatMul(other, self).doit()\n119 \n120     @_sympifyit('other', NotImplemented)\n121     @call_highest_priority('__mul__')\n122     def __rmatmul__(self, other):\n123         return MatMul(other, self).doit()\n124 \n125     @_sympifyit('other', NotImplemented)\n126     @call_highest_priority('__rpow__')\n127     def __pow__(self, other):\n128         if not self.is_square:\n129             raise ShapeError(\"Power of non-square matrix %s\" % self)\n130         elif self.is_Identity:\n131             return self\n132         elif other is S.Zero:\n133             return Identity(self.rows)\n134         elif other is S.One:\n135             return self\n136         return MatPow(self, other).doit(deep=False)\n137 \n138     @_sympifyit('other', NotImplemented)\n139     @call_highest_priority('__pow__')\n140     def __rpow__(self, other):\n141         raise NotImplementedError(\"Matrix Power not defined\")\n142 \n143     @_sympifyit('other', NotImplemented)\n144     @call_highest_priority('__rdiv__')\n145     def __div__(self, other):\n146         return self * other**S.NegativeOne\n147 \n148     @_sympifyit('other', NotImplemented)\n149     @call_highest_priority('__div__')\n150     def __rdiv__(self, other):\n151         raise NotImplementedError()\n152         #return MatMul(other, Pow(self, S.NegativeOne))\n153 \n154     __truediv__ = __div__\n155     __rtruediv__ = __rdiv__\n156 \n157     @property\n158     def rows(self):\n159         return self.shape[0]\n160 \n161     @property\n162     def cols(self):\n163         return self.shape[1]\n164 \n165     @property\n166     def is_square(self):\n167         return self.rows == self.cols\n168 \n169     def _eval_conjugate(self):\n170         from sympy.matrices.expressions.adjoint import Adjoint\n171         from sympy.matrices.expressions.transpose import Transpose\n172         return Adjoint(Transpose(self))\n173 \n174     def as_real_imag(self):\n175         from sympy import I\n176         real = (S(1)/2) * (self + self._eval_conjugate())\n177         im = (self - self._eval_conjugate())/(2*I)\n178         return (real, im)\n179 \n180     def _eval_inverse(self):\n181         from sympy.matrices.expressions.inverse import Inverse\n182         return Inverse(self)\n183 \n184     def _eval_transpose(self):\n185         return Transpose(self)\n186 \n187     def _eval_power(self, exp):\n188         return MatPow(self, exp)\n189 \n190     def _eval_simplify(self, **kwargs):\n191         if self.is_Atom:\n192             return self\n193         else:\n194             return self.__class__(*[simplify(x, **kwargs) for x in self.args])\n195 \n196     def _eval_adjoint(self):\n197         from sympy.matrices.expressions.adjoint import Adjoint\n198         return Adjoint(self)\n199 \n200     def _eval_derivative(self, x):\n201         # x is a scalar:\n202         return ZeroMatrix(self.shape[0], self.shape[1])\n203 \n204     def _eval_derivative_array(self, x):\n205         if isinstance(x, MatrixExpr):\n206             return _matrix_derivative(self, x)\n207         else:\n208             return self._eval_derivative(x)\n209 \n210     def _eval_derivative_n_times(self, x, n):\n211         return Basic._eval_derivative_n_times(self, x, n)\n212 \n213     def _visit_eval_derivative_scalar(self, x):\n214         # `x` is a scalar:\n215         if x.has(self):\n216             return _matrix_derivative(x, self)\n217         else:\n218             return ZeroMatrix(*self.shape)\n219 \n220     def _visit_eval_derivative_array(self, x):\n221         if x.has(self):\n222             return _matrix_derivative(x, self)\n223         else:\n224             from sympy import Derivative\n225             return Derivative(x, self)\n226 \n227     def _accept_eval_derivative(self, s):\n228         return s._visit_eval_derivative_array(self)\n229 \n230     def _entry(self, i, j, **kwargs):\n231         raise NotImplementedError(\n232             \"Indexing not implemented for %s\" % self.__class__.__name__)\n233 \n234     def adjoint(self):\n235         return adjoint(self)\n236 \n237     def as_coeff_Mul(self, rational=False):\n238         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n239         return S.One, self\n240 \n241     def conjugate(self):\n242         return conjugate(self)\n243 \n244     def transpose(self):\n245         from sympy.matrices.expressions.transpose import transpose\n246         return transpose(self)\n247 \n248     T = property(transpose, None, None, 'Matrix transposition.')\n249 \n250     def inverse(self):\n251         return self._eval_inverse()\n252 \n253     inv = inverse\n254 \n255     @property\n256     def I(self):\n257         return self.inverse()\n258 \n259     def valid_index(self, i, j):\n260         def is_valid(idx):\n261             return isinstance(idx, (int, Integer, Symbol, Expr))\n262         return (is_valid(i) and is_valid(j) and\n263                 (self.rows is None or\n264                 (0 <= i) != False and (i < self.rows) != False) and\n265                 (0 <= j) != False and (j < self.cols) != False)\n266 \n267     def __getitem__(self, key):\n268         if not isinstance(key, tuple) and isinstance(key, slice):\n269             from sympy.matrices.expressions.slice import MatrixSlice\n270             return MatrixSlice(self, key, (0, None, 1))\n271         if isinstance(key, tuple) and len(key) == 2:\n272             i, j = key\n273             if isinstance(i, slice) or isinstance(j, slice):\n274                 from sympy.matrices.expressions.slice import MatrixSlice\n275                 return MatrixSlice(self, i, j)\n276             i, j = _sympify(i), _sympify(j)\n277             if self.valid_index(i, j) != False:\n278                 return self._entry(i, j)\n279             else:\n280                 raise IndexError(\"Invalid indices (%s, %s)\" % (i, j))\n281         elif isinstance(key, (SYMPY_INTS, Integer)):\n282             # row-wise decomposition of matrix\n283             rows, cols = self.shape\n284             # allow single indexing if number of columns is known\n285             if not isinstance(cols, Integer):\n286                 raise IndexError(filldedent('''\n287                     Single indexing is only supported when the number\n288                     of columns is known.'''))\n289             key = _sympify(key)\n290             i = key // cols\n291             j = key % cols\n292             if self.valid_index(i, j) != False:\n293                 return self._entry(i, j)\n294             else:\n295                 raise IndexError(\"Invalid index %s\" % key)\n296         elif isinstance(key, (Symbol, Expr)):\n297                 raise IndexError(filldedent('''\n298                     Only integers may be used when addressing the matrix\n299                     with a single index.'''))\n300         raise IndexError(\"Invalid index, wanted %s[i,j]\" % self)\n301 \n302     def as_explicit(self):\n303         \"\"\"\n304         Returns a dense Matrix with elements represented explicitly\n305 \n306         Returns an object of type ImmutableDenseMatrix.\n307 \n308         Examples\n309         ========\n310 \n311         >>> from sympy import Identity\n312         >>> I = Identity(3)\n313         >>> I\n314         I\n315         >>> I.as_explicit()\n316         Matrix([\n317         [1, 0, 0],\n318         [0, 1, 0],\n319         [0, 0, 1]])\n320 \n321         See Also\n322         ========\n323         as_mutable: returns mutable Matrix type\n324 \n325         \"\"\"\n326         from sympy.matrices.immutable import ImmutableDenseMatrix\n327         return ImmutableDenseMatrix([[    self[i, j]\n328                             for j in range(self.cols)]\n329                             for i in range(self.rows)])\n330 \n331     def as_mutable(self):\n332         \"\"\"\n333         Returns a dense, mutable matrix with elements represented explicitly\n334 \n335         Examples\n336         ========\n337 \n338         >>> from sympy import Identity\n339         >>> I = Identity(3)\n340         >>> I\n341         I\n342         >>> I.shape\n343         (3, 3)\n344         >>> I.as_mutable()\n345         Matrix([\n346         [1, 0, 0],\n347         [0, 1, 0],\n348         [0, 0, 1]])\n349 \n350         See Also\n351         ========\n352         as_explicit: returns ImmutableDenseMatrix\n353         \"\"\"\n354         return self.as_explicit().as_mutable()\n355 \n356     def __array__(self):\n357         from numpy import empty\n358         a = empty(self.shape, dtype=object)\n359         for i in range(self.rows):\n360             for j in range(self.cols):\n361                 a[i, j] = self[i, j]\n362         return a\n363 \n364     def equals(self, other):\n365         \"\"\"\n366         Test elementwise equality between matrices, potentially of different\n367         types\n368 \n369         >>> from sympy import Identity, eye\n370         >>> Identity(3).equals(eye(3))\n371         True\n372         \"\"\"\n373         return self.as_explicit().equals(other)\n374 \n375     def canonicalize(self):\n376         return self\n377 \n378     def as_coeff_mmul(self):\n379         return 1, MatMul(self)\n380 \n381     @staticmethod\n382     def from_index_summation(expr, first_index=None, last_index=None, dimensions=None):\n383         r\"\"\"\n384         Parse expression of matrices with explicitly summed indices into a\n385         matrix expression without indices, if possible.\n386 \n387         This transformation expressed in mathematical notation:\n388 \n389         `\\sum_{j=0}^{N-1} A_{i,j} B_{j,k} \\Longrightarrow \\mathbf{A}\\cdot \\mathbf{B}`\n390 \n391         Optional parameter ``first_index``: specify which free index to use as\n392         the index starting the expression.\n393 \n394         Examples\n395         ========\n396 \n397         >>> from sympy import MatrixSymbol, MatrixExpr, Sum, Symbol\n398         >>> from sympy.abc import i, j, k, l, N\n399         >>> A = MatrixSymbol(\"A\", N, N)\n400         >>> B = MatrixSymbol(\"B\", N, N)\n401         >>> expr = Sum(A[i, j]*B[j, k], (j, 0, N-1))\n402         >>> MatrixExpr.from_index_summation(expr)\n403         A*B\n404 \n405         Transposition is detected:\n406 \n407         >>> expr = Sum(A[j, i]*B[j, k], (j, 0, N-1))\n408         >>> MatrixExpr.from_index_summation(expr)\n409         A.T*B\n410 \n411         Detect the trace:\n412 \n413         >>> expr = Sum(A[i, i], (i, 0, N-1))\n414         >>> MatrixExpr.from_index_summation(expr)\n415         Trace(A)\n416 \n417         More complicated expressions:\n418 \n419         >>> expr = Sum(A[i, j]*B[k, j]*A[l, k], (j, 0, N-1), (k, 0, N-1))\n420         >>> MatrixExpr.from_index_summation(expr)\n421         A*B.T*A.T\n422         \"\"\"\n423         from sympy import Sum, Mul, Add, MatMul, transpose, trace\n424         from sympy.strategies.traverse import bottom_up\n425 \n426         def remove_matelement(expr, i1, i2):\n427 \n428             def repl_match(pos):\n429                 def func(x):\n430                     if not isinstance(x, MatrixElement):\n431                         return False\n432                     if x.args[pos] != i1:\n433                         return False\n434                     if x.args[3-pos] == 0:\n435                         if x.args[0].shape[2-pos] == 1:\n436                             return True\n437                         else:\n438                             return False\n439                     return True\n440                 return func\n441 \n442             expr = expr.replace(repl_match(1),\n443                 lambda x: x.args[0])\n444             expr = expr.replace(repl_match(2),\n445                 lambda x: transpose(x.args[0]))\n446 \n447             # Make sure that all Mul are transformed to MatMul and that they\n448             # are flattened:\n449             rule = bottom_up(lambda x: reduce(lambda a, b: a*b, x.args) if isinstance(x, (Mul, MatMul)) else x)\n450             return rule(expr)\n451 \n452         def recurse_expr(expr, index_ranges={}):\n453             if expr.is_Mul:\n454                 nonmatargs = []\n455                 pos_arg = []\n456                 pos_ind = []\n457                 dlinks = {}\n458                 link_ind = []\n459                 counter = 0\n460                 args_ind = []\n461                 for arg in expr.args:\n462                     retvals = recurse_expr(arg, index_ranges)\n463                     assert isinstance(retvals, list)\n464                     if isinstance(retvals, list):\n465                         for i in retvals:\n466                             args_ind.append(i)\n467                     else:\n468                         args_ind.append(retvals)\n469                 for arg_symbol, arg_indices in args_ind:\n470                     if arg_indices is None:\n471                         nonmatargs.append(arg_symbol)\n472                         continue\n473                     if isinstance(arg_symbol, MatrixElement):\n474                         arg_symbol = arg_symbol.args[0]\n475                     pos_arg.append(arg_symbol)\n476                     pos_ind.append(arg_indices)\n477                     link_ind.append([None]*len(arg_indices))\n478                     for i, ind in enumerate(arg_indices):\n479                         if ind in dlinks:\n480                             other_i = dlinks[ind]\n481                             link_ind[counter][i] = other_i\n482                             link_ind[other_i[0]][other_i[1]] = (counter, i)\n483                         dlinks[ind] = (counter, i)\n484                     counter += 1\n485                 counter2 = 0\n486                 lines = {}\n487                 while counter2 < len(link_ind):\n488                     for i, e in enumerate(link_ind):\n489                         if None in e:\n490                             line_start_index = (i, e.index(None))\n491                             break\n492                     cur_ind_pos = line_start_index\n493                     cur_line = []\n494                     index1 = pos_ind[cur_ind_pos[0]][cur_ind_pos[1]]\n495                     while True:\n496                         d, r = cur_ind_pos\n497                         if pos_arg[d] != 1:\n498                             if r % 2 == 1:\n499                                 cur_line.append(transpose(pos_arg[d]))\n500                             else:\n501                                 cur_line.append(pos_arg[d])\n502                         next_ind_pos = link_ind[d][1-r]\n503                         counter2 += 1\n504                         # Mark as visited, there will be no `None` anymore:\n505                         link_ind[d] = (-1, -1)\n506                         if next_ind_pos is None:\n507                             index2 = pos_ind[d][1-r]\n508                             lines[(index1, index2)] = cur_line\n509                             break\n510                         cur_ind_pos = next_ind_pos\n511                 lines = {k: MatMul.fromiter(v) if len(v) != 1 else v[0] for k, v in lines.items()}\n512                 return [(Mul.fromiter(nonmatargs), None)] + [\n513                     (MatrixElement(a, i, j), (i, j)) for (i, j), a in lines.items()\n514                 ]\n515             elif expr.is_Add:\n516                 res = [recurse_expr(i) for i in expr.args]\n517                 d = collections.defaultdict(list)\n518                 for res_addend in res:\n519                     scalar = 1\n520                     for elem, indices in res_addend:\n521                         if indices is None:\n522                             scalar = elem\n523                             continue\n524                         indices = tuple(sorted(indices, key=default_sort_key))\n525                         d[indices].append(scalar*remove_matelement(elem, *indices))\n526                         scalar = 1\n527                 return [(MatrixElement(Add.fromiter(v), *k), k) for k, v in d.items()]\n528             elif isinstance(expr, KroneckerDelta):\n529                 i1, i2 = expr.args\n530                 if dimensions is not None:\n531                     identity = Identity(dimensions[0])\n532                 else:\n533                     identity = S.One\n534                 return [(MatrixElement(identity, i1, i2), (i1, i2))]\n535             elif isinstance(expr, MatrixElement):\n536                 matrix_symbol, i1, i2 = expr.args\n537                 if i1 in index_ranges:\n538                     r1, r2 = index_ranges[i1]\n539                     if r1 != 0 or matrix_symbol.shape[0] != r2+1:\n540                         raise ValueError(\"index range mismatch: {0} vs. (0, {1})\".format(\n541                             (r1, r2), matrix_symbol.shape[0]))\n542                 if i2 in index_ranges:\n543                     r1, r2 = index_ranges[i2]\n544                     if r1 != 0 or matrix_symbol.shape[1] != r2+1:\n545                         raise ValueError(\"index range mismatch: {0} vs. (0, {1})\".format(\n546                             (r1, r2), matrix_symbol.shape[1]))\n547                 if (i1 == i2) and (i1 in index_ranges):\n548                     return [(trace(matrix_symbol), None)]\n549                 return [(MatrixElement(matrix_symbol, i1, i2), (i1, i2))]\n550             elif isinstance(expr, Sum):\n551                 return recurse_expr(\n552                     expr.args[0],\n553                     index_ranges={i[0]: i[1:] for i in expr.args[1:]}\n554                 )\n555             else:\n556                 return [(expr, None)]\n557 \n558         retvals = recurse_expr(expr)\n559         factors, indices = zip(*retvals)\n560         retexpr = Mul.fromiter(factors)\n561         if len(indices) == 0 or list(set(indices)) == [None]:\n562             return retexpr\n563         if first_index is None:\n564             for i in indices:\n565                 if i is not None:\n566                     ind0 = i\n567                     break\n568             return remove_matelement(retexpr, *ind0)\n569         else:\n570             return remove_matelement(retexpr, first_index, last_index)\n571 \n572     def applyfunc(self, func):\n573         from .applyfunc import ElementwiseApplyFunction\n574         return ElementwiseApplyFunction(func, self)\n575 \n576     def _eval_Eq(self, other):\n577         if not isinstance(other, MatrixExpr):\n578             return False\n579         if self.shape != other.shape:\n580             return False\n581         if (self - other).is_ZeroMatrix:\n582             return True\n583         return Eq(self, other, evaluate=False)\n584 \n585 def get_postprocessor(cls):\n586     def _postprocessor(expr):\n587         # To avoid circular imports, we can't have MatMul/MatAdd on the top level\n588         mat_class = {Mul: MatMul, Add: MatAdd}[cls]\n589         nonmatrices = []\n590         matrices = []\n591         for term in expr.args:\n592             if isinstance(term, MatrixExpr):\n593                 matrices.append(term)\n594             else:\n595                 nonmatrices.append(term)\n596 \n597         if not matrices:\n598             return cls._from_args(nonmatrices)\n599 \n600         if nonmatrices:\n601             if cls == Mul:\n602                 for i in range(len(matrices)):\n603                     if not matrices[i].is_MatrixExpr:\n604                         # If one of the matrices explicit, absorb the scalar into it\n605                         # (doit will combine all explicit matrices into one, so it\n606                         # doesn't matter which)\n607                         matrices[i] = matrices[i].__mul__(cls._from_args(nonmatrices))\n608                         nonmatrices = []\n609                         break\n610 \n611             else:\n612                 # Maintain the ability to create Add(scalar, matrix) without\n613                 # raising an exception. That way different algorithms can\n614                 # replace matrix expressions with non-commutative symbols to\n615                 # manipulate them like non-commutative scalars.\n616                 return cls._from_args(nonmatrices + [mat_class(*matrices).doit(deep=False)])\n617 \n618         return mat_class(cls._from_args(nonmatrices), *matrices).doit(deep=False)\n619     return _postprocessor\n620 \n621 \n622 Basic._constructor_postprocessor_mapping[MatrixExpr] = {\n623     \"Mul\": [get_postprocessor(Mul)],\n624     \"Add\": [get_postprocessor(Add)],\n625 }\n626 \n627 \n628 def _matrix_derivative(expr, x):\n629     from sympy import Derivative\n630     lines = expr._eval_derivative_matrix_lines(x)\n631 \n632     parts = [i.build() for i in lines]\n633 \n634     from sympy.codegen.array_utils import recognize_matrix_expression\n635 \n636     parts = [[recognize_matrix_expression(j).doit() for j in i] for i in parts]\n637 \n638     def _get_shape(elem):\n639         if isinstance(elem, MatrixExpr):\n640             return elem.shape\n641         return (1, 1)\n642 \n643     def get_rank(parts):\n644         return sum([j not in (1, None) for i in parts for j in _get_shape(i)])\n645 \n646     ranks = [get_rank(i) for i in parts]\n647     rank = ranks[0]\n648 \n649     def contract_one_dims(parts):\n650         if len(parts) == 1:\n651             return parts[0]\n652         else:\n653             p1, p2 = parts[:2]\n654             if p2.is_Matrix:\n655                 p2 = p2.T\n656             pbase = p1*p2\n657             if len(parts) == 2:\n658                 return pbase\n659             else:  # len(parts) > 2\n660                 if pbase.is_Matrix:\n661                     raise ValueError(\"\")\n662                 return pbase*Mul.fromiter(parts[2:])\n663 \n664     if rank <= 2:\n665         return Add.fromiter([contract_one_dims(i) for i in parts])\n666 \n667     return Derivative(expr, x)\n668 \n669 \n670 class MatrixElement(Expr):\n671     parent = property(lambda self: self.args[0])\n672     i = property(lambda self: self.args[1])\n673     j = property(lambda self: self.args[2])\n674     _diff_wrt = True\n675     is_symbol = True\n676     is_commutative = True\n677 \n678     def __new__(cls, name, n, m):\n679         n, m = map(_sympify, (n, m))\n680         from sympy import MatrixBase\n681         if isinstance(name, (MatrixBase,)):\n682             if n.is_Integer and m.is_Integer:\n683                 return name[n, m]\n684         if isinstance(name, string_types):\n685             name = Symbol(name)\n686         name = _sympify(name)\n687         obj = Expr.__new__(cls, name, n, m)\n688         return obj\n689 \n690     def doit(self, **kwargs):\n691         deep = kwargs.get('deep', True)\n692         if deep:\n693             args = [arg.doit(**kwargs) for arg in self.args]\n694         else:\n695             args = self.args\n696         return args[0][args[1], args[2]]\n697 \n698     @property\n699     def indices(self):\n700         return self.args[1:]\n701 \n702     def _eval_derivative(self, v):\n703         from sympy import Sum, symbols, Dummy\n704 \n705         if not isinstance(v, MatrixElement):\n706             from sympy import MatrixBase\n707             if isinstance(self.parent, MatrixBase):\n708                 return self.parent.diff(v)[self.i, self.j]\n709             return S.Zero\n710 \n711         M = self.args[0]\n712 \n713         if M == v.args[0]:\n714             return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])\n715 \n716         if isinstance(M, Inverse):\n717             i, j = self.args[1:]\n718             i1, i2 = symbols(\"z1, z2\", cls=Dummy)\n719             Y = M.args[0]\n720             r1, r2 = Y.shape\n721             return -Sum(M[i, i1]*Y[i1, i2].diff(v)*M[i2, j], (i1, 0, r1-1), (i2, 0, r2-1))\n722 \n723         if self.has(v.args[0]):\n724             return None\n725 \n726         return S.Zero\n727 \n728 \n729 class MatrixSymbol(MatrixExpr):\n730     \"\"\"Symbolic representation of a Matrix object\n731 \n732     Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and\n733     can be included in Matrix Expressions\n734 \n735     Examples\n736     ========\n737 \n738     >>> from sympy import MatrixSymbol, Identity\n739     >>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix\n740     >>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix\n741     >>> A.shape\n742     (3, 4)\n743     >>> 2*A*B + Identity(3)\n744     I + 2*A*B\n745     \"\"\"\n746     is_commutative = False\n747     is_symbol = True\n748     _diff_wrt = True\n749 \n750     def __new__(cls, name, n, m):\n751         n, m = _sympify(n), _sympify(m)\n752         if isinstance(name, string_types):\n753             name = Symbol(name)\n754         obj = Basic.__new__(cls, name, n, m)\n755         return obj\n756 \n757     def _hashable_content(self):\n758         return (self.name, self.shape)\n759 \n760     @property\n761     def shape(self):\n762         return self.args[1:3]\n763 \n764     @property\n765     def name(self):\n766         return self.args[0].name\n767 \n768     def _eval_subs(self, old, new):\n769         # only do substitutions in shape\n770         shape = Tuple(*self.shape)._subs(old, new)\n771         return MatrixSymbol(self.name, *shape)\n772 \n773     def __call__(self, *args):\n774         raise TypeError(\"%s object is not callable\" % self.__class__)\n775 \n776     def _entry(self, i, j, **kwargs):\n777         return MatrixElement(self, i, j)\n778 \n779     @property\n780     def free_symbols(self):\n781         return set((self,))\n782 \n783     def doit(self, **hints):\n784         if hints.get('deep', True):\n785             return type(self)(self.name, self.args[1].doit(**hints),\n786                     self.args[2].doit(**hints))\n787         else:\n788             return self\n789 \n790     def _eval_simplify(self, **kwargs):\n791         return self\n792 \n793     def _eval_derivative_matrix_lines(self, x):\n794         if self != x:\n795             first = ZeroMatrix(x.shape[0], self.shape[0]) if self.shape[0] != 1 else S.Zero\n796             second = ZeroMatrix(x.shape[1], self.shape[1]) if self.shape[1] != 1 else S.Zero\n797             return [_LeftRightArgs(\n798                 [first, second],\n799             )]\n800         else:\n801             first = Identity(self.shape[0]) if self.shape[0] != 1 else S.One\n802             second = Identity(self.shape[1]) if self.shape[1] != 1 else S.One\n803             return [_LeftRightArgs(\n804                 [first, second],\n805             )]\n806 \n807 \n808 class Identity(MatrixExpr):\n809     \"\"\"The Matrix Identity I - multiplicative identity\n810 \n811     Examples\n812     ========\n813 \n814     >>> from sympy.matrices import Identity, MatrixSymbol\n815     >>> A = MatrixSymbol('A', 3, 5)\n816     >>> I = Identity(3)\n817     >>> I*A\n818     A\n819     \"\"\"\n820 \n821     is_Identity = True\n822 \n823     def __new__(cls, n):\n824         return super(Identity, cls).__new__(cls, _sympify(n))\n825 \n826     @property\n827     def rows(self):\n828         return self.args[0]\n829 \n830     @property\n831     def cols(self):\n832         return self.args[0]\n833 \n834     @property\n835     def shape(self):\n836         return (self.args[0], self.args[0])\n837 \n838     @property\n839     def is_square(self):\n840         return True\n841 \n842     def _eval_transpose(self):\n843         return self\n844 \n845     def _eval_trace(self):\n846         return self.rows\n847 \n848     def _eval_inverse(self):\n849         return self\n850 \n851     def conjugate(self):\n852         return self\n853 \n854     def _entry(self, i, j, **kwargs):\n855         eq = Eq(i, j)\n856         if eq is S.true:\n857             return S.One\n858         elif eq is S.false:\n859             return S.Zero\n860         return KroneckerDelta(i, j)\n861 \n862     def _eval_determinant(self):\n863         return S.One\n864 \n865 class GenericIdentity(Identity):\n866     \"\"\"\n867     An identity matrix without a specified shape\n868 \n869     This exists primarily so MatMul() with no arguments can return something\n870     meaningful.\n871     \"\"\"\n872     def __new__(cls):\n873         # super(Identity, cls) instead of super(GenericIdentity, cls) because\n874         # Identity.__new__ doesn't have the same signature\n875         return super(Identity, cls).__new__(cls)\n876 \n877     @property\n878     def rows(self):\n879         raise TypeError(\"GenericIdentity does not have a specified shape\")\n880 \n881     @property\n882     def cols(self):\n883         raise TypeError(\"GenericIdentity does not have a specified shape\")\n884 \n885     @property\n886     def shape(self):\n887         raise TypeError(\"GenericIdentity does not have a specified shape\")\n888 \n889     # Avoid Matrix.__eq__ which might call .shape\n890     def __eq__(self, other):\n891         return isinstance(other, GenericIdentity)\n892 \n893     def __ne__(self, other):\n894         return not (self == other)\n895 \n896     def __hash__(self):\n897         return super(GenericIdentity, self).__hash__()\n898 \n899 \n900 class ZeroMatrix(MatrixExpr):\n901     \"\"\"The Matrix Zero 0 - additive identity\n902 \n903     Examples\n904     ========\n905 \n906     >>> from sympy import MatrixSymbol, ZeroMatrix\n907     >>> A = MatrixSymbol('A', 3, 5)\n908     >>> Z = ZeroMatrix(3, 5)\n909     >>> A + Z\n910     A\n911     >>> Z*A.T\n912     0\n913     \"\"\"\n914     is_ZeroMatrix = True\n915 \n916     def __new__(cls, m, n):\n917         return super(ZeroMatrix, cls).__new__(cls, m, n)\n918 \n919     @property\n920     def shape(self):\n921         return (self.args[0], self.args[1])\n922 \n923     @_sympifyit('other', NotImplemented)\n924     @call_highest_priority('__rpow__')\n925     def __pow__(self, other):\n926         if other != 1 and not self.is_square:\n927             raise ShapeError(\"Power of non-square matrix %s\" % self)\n928         if other == 0:\n929             return Identity(self.rows)\n930         if other < 1:\n931             raise ValueError(\"Matrix det == 0; not invertible.\")\n932         return self\n933 \n934     def _eval_transpose(self):\n935         return ZeroMatrix(self.cols, self.rows)\n936 \n937     def _eval_trace(self):\n938         return S.Zero\n939 \n940     def _eval_determinant(self):\n941         return S.Zero\n942 \n943     def conjugate(self):\n944         return self\n945 \n946     def _entry(self, i, j, **kwargs):\n947         return S.Zero\n948 \n949     def __nonzero__(self):\n950         return False\n951 \n952     __bool__ = __nonzero__\n953 \n954 \n955 class GenericZeroMatrix(ZeroMatrix):\n956     \"\"\"\n957     A zero matrix without a specified shape\n958 \n959     This exists primarily so MatAdd() with no arguments can return something\n960     meaningful.\n961     \"\"\"\n962     def __new__(cls):\n963         # super(ZeroMatrix, cls) instead of super(GenericZeroMatrix, cls)\n964         # because ZeroMatrix.__new__ doesn't have the same signature\n965         return super(ZeroMatrix, cls).__new__(cls)\n966 \n967     @property\n968     def rows(self):\n969         raise TypeError(\"GenericZeroMatrix does not have a specified shape\")\n970 \n971     @property\n972     def cols(self):\n973         raise TypeError(\"GenericZeroMatrix does not have a specified shape\")\n974 \n975     @property\n976     def shape(self):\n977         raise TypeError(\"GenericZeroMatrix does not have a specified shape\")\n978 \n979     # Avoid Matrix.__eq__ which might call .shape\n980     def __eq__(self, other):\n981         return isinstance(other, GenericZeroMatrix)\n982 \n983     def __ne__(self, other):\n984         return not (self == other)\n985 \n986     def __hash__(self):\n987         return super(GenericZeroMatrix, self).__hash__()\n988 \n989 \n990 class OneMatrix(MatrixExpr):\n991     \"\"\"\n992     Matrix whose all entries are ones.\n993     \"\"\"\n994     def __new__(cls, m, n):\n995         obj = super(OneMatrix, cls).__new__(cls, m, n)\n996         return obj\n997 \n998     @property\n999     def shape(self):\n1000         return self._args\n1001 \n1002     def as_explicit(self):\n1003         from sympy import ImmutableDenseMatrix\n1004         return ImmutableDenseMatrix.ones(*self.shape)\n1005 \n1006     def _eval_transpose(self):\n1007         return OneMatrix(self.cols, self.rows)\n1008 \n1009     def _eval_trace(self):\n1010         return S.One*self.rows\n1011 \n1012     def _eval_determinant(self):\n1013         condition = Eq(self.shape[0], 1) & Eq(self.shape[1], 1)\n1014         if condition == True:\n1015             return S.One\n1016         elif condition == False:\n1017             return S.Zero\n1018         else:\n1019             from sympy import Determinant\n1020             return Determinant(self)\n1021 \n1022     def conjugate(self):\n1023         return self\n1024 \n1025     def _entry(self, i, j, **kwargs):\n1026         return S.One\n1027 \n1028 \n1029 def matrix_symbols(expr):\n1030     return [sym for sym in expr.free_symbols if sym.is_Matrix]\n1031 \n1032 \n1033 class _LeftRightArgs(object):\n1034     r\"\"\"\n1035     Helper class to compute matrix derivatives.\n1036 \n1037     The logic: when an expression is derived by a matrix `X_{mn}`, two lines of\n1038     matrix multiplications are created: the one contracted to `m` (first line),\n1039     and the one contracted to `n` (second line).\n1040 \n1041     Transposition flips the side by which new matrices are connected to the\n1042     lines.\n1043 \n1044     The trace connects the end of the two lines.\n1045     \"\"\"\n1046 \n1047     def __init__(self, lines, higher=S.One):\n1048         self._lines = [i for i in lines]\n1049         self._first_pointer_parent = self._lines\n1050         self._first_pointer_index = 0\n1051         self._first_line_index = 0\n1052         self._second_pointer_parent = self._lines\n1053         self._second_pointer_index = 1\n1054         self._second_line_index = 1\n1055         self.higher = higher\n1056 \n1057     @property\n1058     def first_pointer(self):\n1059        return self._first_pointer_parent[self._first_pointer_index]\n1060 \n1061     @first_pointer.setter\n1062     def first_pointer(self, value):\n1063         self._first_pointer_parent[self._first_pointer_index] = value\n1064 \n1065     @property\n1066     def second_pointer(self):\n1067         return self._second_pointer_parent[self._second_pointer_index]\n1068 \n1069     @second_pointer.setter\n1070     def second_pointer(self, value):\n1071         self._second_pointer_parent[self._second_pointer_index] = value\n1072 \n1073     def __repr__(self):\n1074         try:\n1075             built = [self._build(i) for i in self._lines]\n1076         except Exception:\n1077             built = self._lines\n1078         return \"_LeftRightArgs(lines=%s, higher=%s)\" % (\n1079             built,\n1080             self.higher,\n1081         )\n1082 \n1083     def transpose(self):\n1084         self._first_pointer_parent, self._second_pointer_parent = self._second_pointer_parent, self._first_pointer_parent\n1085         self._first_pointer_index, self._second_pointer_index = self._second_pointer_index, self._first_pointer_index\n1086         self._first_line_index, self._second_line_index = self._second_line_index, self._first_line_index\n1087         return self\n1088 \n1089     @staticmethod\n1090     def _build(expr):\n1091         from sympy.core.expr import ExprBuilder\n1092         if isinstance(expr, ExprBuilder):\n1093             return expr.build()\n1094         if isinstance(expr, list):\n1095             if len(expr) == 1:\n1096                 return expr[0]\n1097             else:\n1098                 return expr[0](*[_LeftRightArgs._build(i) for i in expr[1]])\n1099         else:\n1100             return expr\n1101 \n1102     def build(self):\n1103         data = [self._build(i) for i in self._lines]\n1104         if self.higher != 1:\n1105             data += [self._build(self.higher)]\n1106         data = [i.doit() for i in data]\n1107         return data\n1108 \n1109     def matrix_form(self):\n1110         if self.first != 1 and self.higher != 1:\n1111             raise ValueError(\"higher dimensional array cannot be represented\")\n1112 \n1113         def _get_shape(elem):\n1114             if isinstance(elem, MatrixExpr):\n1115                 return elem.shape\n1116             return (None, None)\n1117 \n1118         if _get_shape(self.first)[1] != _get_shape(self.second)[1]:\n1119             # Remove one-dimensional identity matrices:\n1120             # (this is needed by `a.diff(a)` where `a` is a vector)\n1121             if _get_shape(self.second) == (1, 1):\n1122                 return self.first*self.second[0, 0]\n1123             if _get_shape(self.first) == (1, 1):\n1124                 return self.first[1, 1]*self.second.T\n1125             raise ValueError(\"incompatible shapes\")\n1126         if self.first != 1:\n1127             return self.first*self.second.T\n1128         else:\n1129             return self.higher\n1130 \n1131     def rank(self):\n1132         \"\"\"\n1133         Number of dimensions different from trivial (warning: not related to\n1134         matrix rank).\n1135         \"\"\"\n1136         rank = 0\n1137         if self.first != 1:\n1138             rank += sum([i != 1 for i in self.first.shape])\n1139         if self.second != 1:\n1140             rank += sum([i != 1 for i in self.second.shape])\n1141         if self.higher != 1:\n1142             rank += 2\n1143         return rank\n1144 \n1145     def _multiply_pointer(self, pointer, other):\n1146         from sympy.core.expr import ExprBuilder\n1147         from sympy.codegen.array_utils import CodegenArrayContraction, CodegenArrayTensorProduct\n1148 \n1149         subexpr = ExprBuilder(\n1150             CodegenArrayContraction,\n1151             [\n1152                 ExprBuilder(\n1153                     CodegenArrayTensorProduct,\n1154                     [\n1155                         pointer,\n1156                         other\n1157                     ]\n1158                 ),\n1159                 (1, 2)\n1160             ],\n1161             validator=CodegenArrayContraction._validate\n1162         )\n1163 \n1164         return subexpr\n1165 \n1166     def append_first(self, other):\n1167         self.first_pointer *= other\n1168 \n1169     def append_second(self, other):\n1170         self.second_pointer *= other\n1171 \n1172     def __hash__(self):\n1173         return hash((self.first, self.second))\n1174 \n1175     def __eq__(self, other):\n1176         if not isinstance(other, _LeftRightArgs):\n1177             return False\n1178         return (self.first == other.first) and (self.second == other.second)\n1179 \n1180 \n1181 def _make_matrix(x):\n1182     from sympy import ImmutableDenseMatrix\n1183     if isinstance(x, MatrixExpr):\n1184         return x\n1185     return ImmutableDenseMatrix([[x]])\n1186 \n1187 \n1188 from .matmul import MatMul\n1189 from .matadd import MatAdd\n1190 from .matpow import MatPow\n1191 from .transpose import Transpose\n1192 from .inverse import Inverse\n",
        "intended_behavior": "While the specific presentation enhancements via unicode pretty printing were not directly identified due to the search limitations, it's assumed that within each of these classes, or perhaps through a common superclass or utility module, methods or functionalities might be added or extended to support improved unicode pretty printing. This could involve specifying unicode representations for these matrices and ensuring that these representations are invoked during the pretty-printing process. The goal is to maintain readability and distinction among `ZeroMatrix`, `Identity`, and `OneMatrix` in non-MathML contexts as well."
    }
]