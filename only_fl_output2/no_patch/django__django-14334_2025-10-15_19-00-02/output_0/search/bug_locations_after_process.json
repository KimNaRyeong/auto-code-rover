[
    {
        "rel_file_path": "django/utils/translation/trans_real.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/utils/translation/trans_real.py",
        "start": 464,
        "end": 495,
        "class_name": null,
        "method_name": "get_supported_language_variant",
        "code": "464 def get_supported_language_variant(lang_code, strict=False):\n465     \"\"\"\n466     Return the language code that's listed in supported languages, possibly\n467     selecting a more generic variant. Raise LookupError if nothing is found.\n468 \n469     If `strict` is False (the default), look for a country-specific variant\n470     when neither the language code nor its generic variant is found.\n471 \n472     lru_cache should have a maxsize to prevent from memory exhaustion attacks,\n473     as the provided language codes are taken from the HTTP request. See also\n474     <https://www.djangoproject.com/weblog/2007/oct/26/security-fix/>.\n475     \"\"\"\n476     if lang_code:\n477         # If 'fr-ca' is not supported, try special fallback or language-only 'fr'.\n478         possible_lang_codes = [lang_code]\n479         try:\n480             possible_lang_codes.extend(LANG_INFO[lang_code]['fallback'])\n481         except KeyError:\n482             pass\n483         generic_lang_code = lang_code.split('-')[0]\n484         possible_lang_codes.append(generic_lang_code)\n485         supported_lang_codes = get_languages()\n486 \n487         for code in possible_lang_codes:\n488             if code in supported_lang_codes and check_for_language(code):\n489                 return code\n490         if not strict:\n491             # if fr-fr is not supported, try fr-ca.\n492             for supported_code in supported_lang_codes:\n493                 if supported_code.startswith(generic_lang_code + '-'):\n494                     return supported_code\n495     raise LookupError(lang_code)\n",
        "intended_behavior": "The `get_supported_language_variant` function should be enhanced to more accurately prioritize and select language codes that include script or regional subtags, particularly in scenarios where multiple options (like `zh-hans` and `zh-hant`) are available. This involves:\n\n- Improving the logic that generates `possible_lang_codes` to ensure that if a language code with a script or region is requested (e.g., `zh-Hant-HK`), the method should prioritize finding a match for this specific request over a more general language code that might also be a valid match but not as specific (e.g., preferring `zh-Hant` over `zh-Hans` when `zh-Hant-HK` is requested).\n- In the part of the code that iterates through `possible_lang_codes` and checks these against `supported_lang_codes`, the function should implement a more nuanced selection process. This might involve checking all possible variations of the language code (including both script and regional specificity) before defaulting to a more generic code.\n- The lookup process should explicitly account for script variations (such as `Hans` and `Hant` for Chinese) as well as regional variations, ensuring that the most appropriate and specific match is selected according to the preferences expressed in the `Accept-Language` header and available in `settings.LANGUAGES`.\n\nThis enhancement should maintain the method's existing functionality for languages without script or regional variations, ensuring that the method continues to select the best match for language codes that do not include such specificity."
    }
]