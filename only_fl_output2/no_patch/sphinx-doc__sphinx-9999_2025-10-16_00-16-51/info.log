2025-10-16 00:16:51.283 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 00:16:54.010 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1989, output_tokens=12, cost=0.020250
2025-10-16 00:17:23.554 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2169, output_tokens=1024, cost=0.052410
2025-10-16 00:17:24.550 | INFO     | registered non reproducing test 0
2025-10-16 00:17:46.763 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3766, output_tokens=843, cost=0.062950
2025-10-16 00:17:47.753 | INFO     | registered non reproducing test 1
2025-10-16 00:18:09.832 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3334, output_tokens=994, cost=0.063160
2025-10-16 00:18:10.823 | INFO     | registered non reproducing test 2
2025-10-16 00:18:10.824 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 00:18:10.830 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:18:16.818 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2264, output_tokens=217, cost=0.029150
2025-10-16 00:18:16.839 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:18:19.317 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=571, output_tokens=48, cost=0.007150
2025-10-16 00:18:19.318 | DEBUG    | Extracted a valid json.
2025-10-16 00:18:19.318 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"render rst to LaTeX\")",
        "search_code(\"glossary LaTeX\")",
        "search_code(\"rst LaTeX conversion\")"
    ],
    "bug_locations": []
}
2025-10-16 00:18:19.334 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 00:18:19.334 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 00:18:24.979 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2661, output_tokens=256, cost=0.034290
2025-10-16 00:18:24.990 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 00:18:37.198 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3133, output_tokens=476, cost=0.045610
2025-10-16 00:18:37.202 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 00:18:44.199 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=830, output_tokens=228, cost=0.015140
2025-10-16 00:18:44.200 | DEBUG    | Extracted a valid json.
2025-10-16 00:18:44.200 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "writers/latex.py",
            "class": "LaTeXBuilder",
            "method": "",
            "intended_behavior": "The method(s) responsible for processing `:samp:` should ensure that separate instances are treated as distinct inline elements, preserving any natural whitespace (including new lines) from the rst source when converting to LaTeX. This might involve adjusting the conversion logic to include newline characters or ensuring that the LaTeX commands generated for these elements do not automatically strip or ignore whitespace that is significant in the source document."
        },
        {
            "file": "writers/latex.py",
            "class": "",
            "method": "",
            "intended_behavior": "The glossary processing method should maintain compact formatting between terms that share a common description, avoiding excessive vertical whitespace in the LaTeX output. This might involve introducing or modifying spacing controls in the LaTeX commands generated for glossary entries or improving the handling of grouped glossary terms to ensure that the LaTeX output closely mirrors the intended layout specified in the rst document."
        }
    ]
}
2025-10-16 00:18:44.209 | DEBUG    | Bug location extracted successfully: [<file>sphinx/builders/latex/__init__.py</file>
<class>LaTeXBuilder</class>
<method>None</method>
<code>
106 class LaTeXBuilder(Builder):
107     """
108     Builds LaTeX output to create PDF.
109     """
110     name = 'latex'
111     format = 'latex'
112     epilog = __('The LaTeX files are in %(outdir)s.')
113     if os.name == 'posix':
114         epilog += __("\nRun 'make' in that directory to run these through "
115                      "(pdf)latex\n"
116                      "(use `make latexpdf' here to do that automatically).")
117 
118     supported_image_types = ['application/pdf', 'image/png', 'image/jpeg']
119     supported_remote_images = False
120     default_translator_class = LaTeXTranslator
121 
122     def init(self) -> None:
123         self.babel: ExtBabel = None
124         self.context: Dict[str, Any] = {}
125         self.docnames: Iterable[str] = {}
126         self.document_data: List[Tuple[str, str, str, str, str, bool]] = []
127         self.themes = ThemeFactory(self.app)
128         texescape.init()
129 
130         self.init_context()
131         self.init_babel()
132         self.init_multilingual()
133 
134     def get_outdated_docs(self) -> Union[str, List[str]]:
135         return 'all documents'  # for now
136 
137     def get_target_uri(self, docname: str, typ: str = None) -> str:
138         if docname not in self.docnames:
139             raise NoUri(docname, typ)
140         else:
141             return '%' + docname
142 
143     def get_relative_uri(self, from_: str, to: str, typ: str = None) -> str:
144         # ignore source path
145         return self.get_target_uri(to, typ)
146 
147     def init_document_data(self) -> None:
148         preliminary_document_data = [list(x) for x in self.config.latex_documents]
149         if not preliminary_document_data:
150             logger.warning(__('no "latex_documents" config value found; no documents '
151                               'will be written'))
152             return
153         # assign subdirs to titles
154         self.titles: List[Tuple[str, str]] = []
155         for entry in preliminary_document_data:
156             docname = entry[0]
157             if docname not in self.env.all_docs:
158                 logger.warning(__('"latex_documents" config value references unknown '
159                                   'document %s'), docname)
160                 continue
161             self.document_data.append(entry)  # type: ignore
162             if docname.endswith(SEP + 'index'):
163                 docname = docname[:-5]
164             self.titles.append((docname, entry[2]))
165 
166     def init_context(self) -> None:
167         self.context = DEFAULT_SETTINGS.copy()
168 
169         # Add special settings for latex_engine
170         self.context.update(ADDITIONAL_SETTINGS.get(self.config.latex_engine, {}))
171 
172         # Add special settings for (latex_engine, language_code)
173         if self.config.language:
174             key = (self.config.latex_engine, self.config.language[:2])
175             self.context.update(ADDITIONAL_SETTINGS.get(key, {}))
176 
177         # Apply user settings to context
178         self.context.update(self.config.latex_elements)
179         self.context['release'] = self.config.release
180         self.context['use_xindy'] = self.config.latex_use_xindy
181 
182         if self.config.today:
183             self.context['date'] = self.config.today
184         else:
185             self.context['date'] = format_date(self.config.today_fmt or _('%b %d, %Y'),
186                                                language=self.config.language)
187 
188         if self.config.latex_logo:
189             self.context['logofilename'] = path.basename(self.config.latex_logo)
190 
191         # for compatibilities
192         self.context['indexname'] = _('Index')
193         if self.config.release:
194             # Show the release label only if release value exists
195             self.context.setdefault('releasename', _('Release'))
196 
197     def update_context(self) -> None:
198         """Update template variables for .tex file just before writing."""
199         # Apply extension settings to context
200         registry = self.app.registry
201         self.context['packages'] = registry.latex_packages
202         self.context['packages_after_hyperref'] = registry.latex_packages_after_hyperref
203 
204     def init_babel(self) -> None:
205         self.babel = ExtBabel(self.config.language, not self.context['babel'])
206         if self.config.language and not self.babel.is_supported_language():
207             # emit warning if specified language is invalid
208             # (only emitting, nothing changed to processing)
209             logger.warning(__('no Babel option known for language %r'),
210                            self.config.language)
211 
212     def init_multilingual(self) -> None:
213         if self.context['latex_engine'] == 'pdflatex':
214             if not self.babel.uses_cyrillic():
215                 if 'X2' in self.context['fontenc']:
216                     self.context['substitutefont'] = '\\usepackage{substitutefont}'
217                     self.context['textcyrillic'] = ('\\usepackage[Xtwo]'
218                                                     '{sphinxpackagecyrillic}')
219                 elif 'T2A' in self.context['fontenc']:
220                     self.context['substitutefont'] = '\\usepackage{substitutefont}'
221                     self.context['textcyrillic'] = ('\\usepackage[TtwoA]'
222                                                     '{sphinxpackagecyrillic}')
223             if 'LGR' in self.context['fontenc']:
224                 self.context['substitutefont'] = '\\usepackage{substitutefont}'
225             else:
226                 self.context['textgreek'] = ''
227             if self.context['substitutefont'] == '':
228                 self.context['fontsubstitution'] = ''
229 
230         # 'babel' key is public and user setting must be obeyed
231         if self.context['babel']:
232             self.context['classoptions'] += ',' + self.babel.get_language()
233             # this branch is not taken for xelatex/lualatex if default settings
234             self.context['multilingual'] = self.context['babel']
235             if self.config.language:
236                 self.context['shorthandoff'] = SHORTHANDOFF
237 
238                 # Times fonts don't work with Cyrillic languages
239                 if self.babel.uses_cyrillic() and 'fontpkg' not in self.config.latex_elements:
240                     self.context['fontpkg'] = ''
241         elif self.context['polyglossia']:
242             self.context['classoptions'] += ',' + self.babel.get_language()
243             options = self.babel.get_mainlanguage_options()
244             if options:
245                 language = r'\setmainlanguage[%s]{%s}' % (options, self.babel.get_language())
246             else:
247                 language = r'\setmainlanguage{%s}' % self.babel.get_language()
248 
249             self.context['multilingual'] = '%s\n%s' % (self.context['polyglossia'], language)
250 
251     def write_stylesheet(self) -> None:
252         highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style)
253         stylesheet = path.join(self.outdir, 'sphinxhighlight.sty')
254         with open(stylesheet, 'w') as f:
255             f.write('\\NeedsTeXFormat{LaTeX2e}[1995/12/01]\n')
256             f.write('\\ProvidesPackage{sphinxhighlight}'
257                     '[2016/05/29 stylesheet for highlighting with pygments]\n')
258             f.write('% Its contents depend on pygments_style configuration variable.\n\n')
259             f.write(highlighter.get_stylesheet())
260 
261     def write(self, *ignored: Any) -> None:
262         docwriter = LaTeXWriter(self)
263         docsettings: Any = OptionParser(
264             defaults=self.env.settings,
265             components=(docwriter,),
266             read_config_files=True).get_default_values()
267 
268         self.init_document_data()
269         self.write_stylesheet()
270 
271         for entry in self.document_data:
272             docname, targetname, title, author, themename = entry[:5]
273             theme = self.themes.get(themename)
274             toctree_only = False
275             if len(entry) > 5:
276                 toctree_only = entry[5]
277             destination = SphinxFileOutput(destination_path=path.join(self.outdir, targetname),
278                                            encoding='utf-8', overwrite_if_changed=True)
279             with progress_message(__("processing %s") % targetname):
280                 doctree = self.env.get_doctree(docname)
281                 toctree = next(iter(doctree.traverse(addnodes.toctree)), None)
282                 if toctree and toctree.get('maxdepth') > 0:
283                     tocdepth = toctree.get('maxdepth')
284                 else:
285                     tocdepth = None
286 
287                 doctree = self.assemble_doctree(
288                     docname, toctree_only,
289                     appendices=(self.config.latex_appendices if theme.name != 'howto' else []))
290                 doctree['docclass'] = theme.docclass
291                 doctree['contentsname'] = self.get_contentsname(docname)
292                 doctree['tocdepth'] = tocdepth
293                 self.post_process_images(doctree)
294                 self.update_doc_context(title, author, theme)
295                 self.update_context()
296 
297             with progress_message(__("writing")):
298                 docsettings._author = author
299                 docsettings._title = title
300                 docsettings._contentsname = doctree['contentsname']
301                 docsettings._docname = docname
302                 docsettings._docclass = theme.name
303 
304                 doctree.settings = docsettings
305                 docwriter.theme = theme
306                 docwriter.write(doctree, destination)
307 
308     def get_contentsname(self, indexfile: str) -> str:
309         tree = self.env.get_doctree(indexfile)
310         contentsname = None
311         for toctree in tree.traverse(addnodes.toctree):
312             if 'caption' in toctree:
313                 contentsname = toctree['caption']
314                 break
315 
316         return contentsname
317 
318     def update_doc_context(self, title: str, author: str, theme: Theme) -> None:
319         self.context['title'] = title
320         self.context['author'] = author
321         self.context['docclass'] = theme.docclass
322         self.context['papersize'] = theme.papersize
323         self.context['pointsize'] = theme.pointsize
324         self.context['wrapperclass'] = theme.wrapperclass
325 
326     def assemble_doctree(self, indexfile: str, toctree_only: bool, appendices: List[str]) -> nodes.document:  # NOQA
327         self.docnames = set([indexfile] + appendices)
328         logger.info(darkgreen(indexfile) + " ", nonl=True)
329         tree = self.env.get_doctree(indexfile)
330         tree['docname'] = indexfile
331         if toctree_only:
332             # extract toctree nodes from the tree and put them in a
333             # fresh document
334             new_tree = new_document('<latex output>')
335             new_sect = nodes.section()
336             new_sect += nodes.title('<Set title in conf.py>',
337                                     '<Set title in conf.py>')
338             new_tree += new_sect
339             for node in tree.traverse(addnodes.toctree):
340                 new_sect += node
341             tree = new_tree
342         largetree = inline_all_toctrees(self, self.docnames, indexfile, tree,
343                                         darkgreen, [indexfile])
344         largetree['docname'] = indexfile
345         for docname in appendices:
346             appendix = self.env.get_doctree(docname)
347             appendix['docname'] = docname
348             largetree.append(appendix)
349         logger.info('')
350         logger.info(__("resolving references..."))
351         self.env.resolve_references(largetree, indexfile, self)
352         # resolve :ref:s to distant tex files -- we can't add a cross-reference,
353         # but append the document name
354         for pendingnode in largetree.traverse(addnodes.pending_xref):
355             docname = pendingnode['refdocname']
356             sectname = pendingnode['refsectname']
357             newnodes: List[Node] = [nodes.emphasis(sectname, sectname)]
358             for subdir, title in self.titles:
359                 if docname.startswith(subdir):
360                     newnodes.append(nodes.Text(_(' (in '), _(' (in ')))
361                     newnodes.append(nodes.emphasis(title, title))
362                     newnodes.append(nodes.Text(')', ')'))
363                     break
364             else:
365                 pass
366             pendingnode.replace_self(newnodes)
367         return largetree
368 
369     def finish(self) -> None:
370         self.copy_image_files()
371         self.write_message_catalog()
372         self.copy_support_files()
373 
374         if self.config.latex_additional_files:
375             self.copy_latex_additional_files()
376 
377     @progress_message(__('copying TeX support files'))
378     def copy_support_files(self) -> None:
379         """copy TeX support files from texinputs."""
380         # configure usage of xindy (impacts Makefile and latexmkrc)
381         # FIXME: convert this rather to a confval with suitable default
382         #        according to language ? but would require extra documentation
383         if self.config.language:
384             xindy_lang_option = \
385                 XINDY_LANG_OPTIONS.get(self.config.language[:2],
386                                        '-L general -C utf8 ')
387             xindy_cyrillic = self.config.language[:2] in XINDY_CYRILLIC_SCRIPTS
388         else:
389             xindy_lang_option = '-L english -C utf8 '
390             xindy_cyrillic = False
391         context = {
392             'latex_engine':      self.config.latex_engine,
393             'xindy_use':         self.config.latex_use_xindy,
394             'xindy_lang_option': xindy_lang_option,
395             'xindy_cyrillic':    xindy_cyrillic,
396         }
397         logger.info(bold(__('copying TeX support files...')))
398         staticdirname = path.join(package_dir, 'texinputs')
399         for filename in os.listdir(staticdirname):
400             if not filename.startswith('.'):
401                 copy_asset_file(path.join(staticdirname, filename),
402                                 self.outdir, context=context)
403 
404         # use pre-1.6.x Makefile for make latexpdf on Windows
405         if os.name == 'nt':
406             staticdirname = path.join(package_dir, 'texinputs_win')
407             copy_asset_file(path.join(staticdirname, 'Makefile_t'),
408                             self.outdir, context=context)
409 
410     @progress_message(__('copying additional files'))
411     def copy_latex_additional_files(self) -> None:
412         for filename in self.config.latex_additional_files:
413             logger.info(' ' + filename, nonl=True)
414             copy_asset_file(path.join(self.confdir, filename), self.outdir)
415 
416     def copy_image_files(self) -> None:
417         if self.images:
418             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
419             for src in status_iterator(self.images, __('copying images... '), "brown",
420                                        len(self.images), self.app.verbosity,
421                                        stringify_func=stringify_func):
422                 dest = self.images[src]
423                 try:
424                     copy_asset_file(path.join(self.srcdir, src),
425                                     path.join(self.outdir, dest))
426                 except Exception as err:
427                     logger.warning(__('cannot copy image file %r: %s'),
428                                    path.join(self.srcdir, src), err)
429         if self.config.latex_logo:
430             if not path.isfile(path.join(self.confdir, self.config.latex_logo)):
431                 raise SphinxError(__('logo file %r does not exist') % self.config.latex_logo)
432             else:
433                 copy_asset_file(path.join(self.confdir, self.config.latex_logo), self.outdir)
434 
435     def write_message_catalog(self) -> None:
436         formats = self.config.numfig_format
437         context = {
438             'addtocaptions': r'\@iden',
439             'figurename': formats.get('figure', '').split('%s', 1),
440             'tablename': formats.get('table', '').split('%s', 1),
441             'literalblockname': formats.get('code-block', '').split('%s', 1)
442         }
443 
444         if self.context['babel'] or self.context['polyglossia']:
445             context['addtocaptions'] = r'\addto\captions%s' % self.babel.get_language()
446 
447         filename = path.join(package_dir, 'templates', 'latex', 'sphinxmessages.sty_t')
448         copy_asset_file(filename, self.outdir, context=context, renderer=LaTeXRenderer())

</code><intended_behavior>The method(s) responsible for processing `:samp:` should ensure that separate instances are treated as distinct inline elements, preserving any natural whitespace (including new lines) from the rst source when converting to LaTeX. This might involve adjusting the conversion logic to include newline characters or ensuring that the LaTeX commands generated for these elements do not automatically strip or ignore whitespace that is significant in the source document.</intended_behavior>, <file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.latex
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Custom docutils writer for LaTeX.
6 
7     Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
8     docutils sandbox.
9 
10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
11     :license: BSD, see LICENSE for details.
12 """
13 
14 import re
15 import warnings
16 from collections import defaultdict
17 from os import path
18 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
19 
20 from docutils import nodes, writers
21 from docutils.nodes import Element, Node, Text
22 
23 from sphinx import addnodes, highlighting
24 from sphinx.deprecation import RemovedInSphinx70Warning
25 from sphinx.domains import IndexEntry
26 from sphinx.domains.std import StandardDomain
27 from sphinx.errors import SphinxError
28 from sphinx.locale import _, __, admonitionlabels
29 from sphinx.util import logging, split_into, texescape
30 from sphinx.util.docutils import SphinxTranslator
31 from sphinx.util.nodes import clean_astext, get_prev_node
32 from sphinx.util.template import LaTeXRenderer
33 from sphinx.util.texescape import tex_replace_map
34 
35 try:
36     from docutils.utils.roman import toRoman
37 except ImportError:
38     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
39     from roman import toRoman  # type: ignore
40 
41 if TYPE_CHECKING:
42     from sphinx.builders.latex import LaTeXBuilder
43     from sphinx.builders.latex.theming import Theme
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 MAX_CITATION_LABEL_LENGTH = 8
49 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
50                      "subsubsection", "paragraph", "subparagraph"]
51 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
52                                    {
53                                        'arabic': r'\arabic',
54                                        'loweralpha': r'\alph',
55                                        'upperalpha': r'\Alph',
56                                        'lowerroman': r'\roman',
57                                        'upperroman': r'\Roman',
58                                    })
59 
60 CR = '\n'
61 BLANKLINE = '\n\n'
62 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
63 
64 
65 class collected_footnote(nodes.footnote):
66     """Footnotes that are collected are assigned this class."""
67 
68 
69 class UnsupportedError(SphinxError):
70     category = 'Markup is unsupported in LaTeX'
71 
72 
73 class LaTeXWriter(writers.Writer):
74 
75     supported = ('sphinxlatex',)
76 
77     settings_spec = ('LaTeX writer options', '', (
78         ('Document name', ['--docname'], {'default': ''}),
79         ('Document class', ['--docclass'], {'default': 'manual'}),
80         ('Author', ['--author'], {'default': ''}),
81     ))
82     settings_defaults: Dict = {}
83 
84     output = None
85 
86     def __init__(self, builder: "LaTeXBuilder") -> None:
87         super().__init__()
88         self.builder = builder
89         self.theme: Theme = None
90 
91     def translate(self) -> None:
92         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
93         self.document.walkabout(visitor)
94         self.output = cast(LaTeXTranslator, visitor).astext()
95 
96 
97 # Helper classes
98 
99 class Table:
100     """A table data"""
101 
102     def __init__(self, node: Element) -> None:
103         self.header: List[str] = []
104         self.body: List[str] = []
105         self.align = node.get('align', 'default')
106         self.classes: List[str] = node.get('classes', [])
107         self.colcount = 0
108         self.colspec: str = None
109         self.colwidths: List[int] = []
110         self.has_problematic = False
111         self.has_oldproblematic = False
112         self.has_verbatim = False
113         self.caption: List[str] = None
114         self.stubs: List[int] = []
115 
116         # current position
117         self.col = 0
118         self.row = 0
119 
120         # A dict mapping a table location to a cell_id (cell = rectangular area)
121         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
122         self.cell_id = 0  # last assigned cell_id
123 
124     def is_longtable(self) -> bool:
125         """True if and only if table uses longtable environment."""
126         return self.row > 30 or 'longtable' in self.classes
127 
128     def get_table_type(self) -> str:
129         """Returns the LaTeX environment name for the table.
130 
131         The class currently supports:
132 
133         * longtable
134         * tabular
135         * tabulary
136         """
137         if self.is_longtable():
138             return 'longtable'
139         elif self.has_verbatim:
140             return 'tabular'
141         elif self.colspec:
142             return 'tabulary'
143         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
144             return 'tabular'
145         else:
146             return 'tabulary'
147 
148     def get_colspec(self) -> str:
149         """Returns a column spec of table.
150 
151         This is what LaTeX calls the 'preamble argument' of the used table environment.
152 
153         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
154         """
155         if self.colspec:
156             return self.colspec
157         elif self.colwidths and 'colwidths-given' in self.classes:
158             total = sum(self.colwidths)
159             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
160             return '{|%s|}' % '|'.join(colspecs) + CR
161         elif self.has_problematic:
162             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
163         elif self.get_table_type() == 'tabulary':
164             # sphinx.sty sets T to be J by default.
165             return '{|' + ('T|' * self.colcount) + '}' + CR
166         elif self.has_oldproblematic:
167             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
168         else:
169             return '{|' + ('l|' * self.colcount) + '}' + CR
170 
171     def add_cell(self, height: int, width: int) -> None:
172         """Adds a new cell to a table.
173 
174         It will be located at current position: (``self.row``, ``self.col``).
175         """
176         self.cell_id += 1
177         for col in range(width):
178             for row in range(height):
179                 assert self.cells[(self.row + row, self.col + col)] == 0
180                 self.cells[(self.row + row, self.col + col)] = self.cell_id
181 
182     def cell(self, row: int = None, col: int = None) -> "TableCell":
183         """Returns a cell object (i.e. rectangular area) containing given position.
184 
185         If no option arguments: ``row`` or ``col`` are given, the current position;
186         ``self.row`` and ``self.col`` are used to get a cell object by default.
187         """
188         try:
189             if row is None:
190                 row = self.row
191             if col is None:
192                 col = self.col
193             return TableCell(self, row, col)
194         except IndexError:
195             return None
196 
197 
198 class TableCell:
199     """Data of a cell in a table."""
200 
201     def __init__(self, table: Table, row: int, col: int) -> None:
202         if table.cells[(row, col)] == 0:
203             raise IndexError
204 
205         self.table = table
206         self.cell_id = table.cells[(row, col)]
207         self.row = row
208         self.col = col
209 
210         # adjust position for multirow/multicol cell
211         while table.cells[(self.row - 1, self.col)] == self.cell_id:
212             self.row -= 1
213         while table.cells[(self.row, self.col - 1)] == self.cell_id:
214             self.col -= 1
215 
216     @property
217     def width(self) -> int:
218         """Returns the cell width."""
219         width = 0
220         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
221             width += 1
222         return width
223 
224     @property
225     def height(self) -> int:
226         """Returns the cell height."""
227         height = 0
228         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
229             height += 1
230         return height
231 
232 
233 def escape_abbr(text: str) -> str:
234     """Adjust spacing after abbreviations."""
235     return re.sub(r'\.(?=\s|$)', r'.\@', text)
236 
237 
238 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
239     """Convert `width_str` with rst length to LaTeX length."""
240     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
241     if not match:
242         raise ValueError
243     res = width_str
244     amount, unit = match.groups()[:2]
245     if scale == 100:
246         float(amount)  # validate amount is float
247         if unit in ('', "px"):
248             res = r"%s\sphinxpxdimen" % amount
249         elif unit == 'pt':
250             res = '%sbp' % amount  # convert to 'bp'
251         elif unit == "%":
252             res = r"%.3f\linewidth" % (float(amount) / 100.0)
253     else:
254         amount_float = float(amount) * scale / 100.0
255         if unit in ('', "px"):
256             res = r"%.5f\sphinxpxdimen" % amount_float
257         elif unit == 'pt':
258             res = '%.5fbp' % amount_float
259         elif unit == "%":
260             res = r"%.5f\linewidth" % (amount_float / 100.0)
261         else:
262             res = "%.5f%s" % (amount_float, unit)
263     return res
264 
265 
266 class LaTeXTranslator(SphinxTranslator):
267     builder: "LaTeXBuilder" = None
268 
269     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
270     # default is originally 3. For book/report, 2 is already LaTeX default.
271     ignore_missing_images = False
272 
273     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
274                  theme: "Theme") -> None:
275         super().__init__(document, builder)
276         self.body: List[str] = []
277         self.theme = theme
278 
279         # flags
280         self.in_title = 0
281         self.in_production_list = 0
282         self.in_footnote = 0
283         self.in_caption = 0
284         self.in_term = 0
285         self.needs_linetrimming = 0
286         self.in_minipage = 0
287         self.no_latex_floats = 0
288         self.first_document = 1
289         self.this_is_the_title = 1
290         self.literal_whitespace = 0
291         self.in_parsed_literal = 0
292         self.compact_list = 0
293         self.first_param = 0
294 
295         sphinxpkgoptions = []
296 
297         # sort out some elements
298         self.elements = self.builder.context.copy()
299 
300         # initial section names
301         self.sectionnames = LATEXSECTIONNAMES[:]
302         if self.theme.toplevel_sectioning == 'section':
303             self.sectionnames.remove('chapter')
304 
305         # determine top section level
306         self.top_sectionlevel = 1
307         if self.config.latex_toplevel_sectioning:
308             try:
309                 self.top_sectionlevel = \
310                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
311             except ValueError:
312                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
313                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
314 
315         if self.config.numfig:
316             self.numfig_secnum_depth = self.config.numfig_secnum_depth
317             if self.numfig_secnum_depth > 0:  # default is 1
318                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
319                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
320                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
321                    self.top_sectionlevel > 0:
322                     self.numfig_secnum_depth += self.top_sectionlevel
323                 else:
324                     self.numfig_secnum_depth += self.top_sectionlevel - 1
325                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
326                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
327                                                len(LATEXSECTIONNAMES) - 1)
328                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
329                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
330             else:
331                 sphinxpkgoptions.append('nonumfigreset')
332 
333         if self.config.numfig and self.config.math_numfig:
334             sphinxpkgoptions.append('mathnumfig')
335 
336         if (self.config.language not in {None, 'en', 'ja'} and
337                 'fncychap' not in self.config.latex_elements):
338             # use Sonny style if any language specified (except English)
339             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
340                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
341                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
342 
343         self.babel = self.builder.babel
344         if self.config.language and not self.babel.is_supported_language():
345             # emit warning if specified language is invalid
346             # (only emitting, nothing changed to processing)
347             logger.warning(__('no Babel option known for language %r'),
348                            self.config.language)
349 
350         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
351         if self.document.get('tocdepth'):
352             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
353             #   tocdepth = -1: show only parts
354             #   tocdepth =  0: show parts and chapters
355             #   tocdepth =  1: show parts, chapters and sections
356             #   tocdepth =  2: show parts, chapters, sections and subsections
357             #   ...
358             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
359             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
360                self.top_sectionlevel > 0:
361                 tocdepth += 1  # because top_sectionlevel is shifted by -1
362             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
363                 logger.warning(__('too large :maxdepth:, ignored.'))
364                 tocdepth = len(LATEXSECTIONNAMES) - 2
365 
366             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
367             minsecnumdepth = max(minsecnumdepth, tocdepth)
368 
369         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
370             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
371 
372         if minsecnumdepth > self.secnumdepth:
373             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
374                                            minsecnumdepth
375 
376         contentsname = document.get('contentsname')
377         if contentsname:
378             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
379                                                                     contentsname)
380 
381         if self.elements['maxlistdepth']:
382             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
383         if sphinxpkgoptions:
384             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
385         if self.elements['sphinxsetup']:
386             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
387         if self.elements['extraclassoptions']:
388             self.elements['classoptions'] += ',' + \
389                                              self.elements['extraclassoptions']
390 
391         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
392                                                        latex_engine=self.config.latex_engine)
393         self.context: List[Any] = []
394         self.descstack: List[str] = []
395         self.tables: List[Table] = []
396         self.next_table_colspec: str = None
397         self.bodystack: List[List[str]] = []
398         self.footnote_restricted: Element = None
399         self.pending_footnotes: List[nodes.footnote_reference] = []
400         self.curfilestack: List[str] = []
401         self.handled_abbrs: Set[str] = set()
402 
403     def pushbody(self, newbody: List[str]) -> None:
404         self.bodystack.append(self.body)
405         self.body = newbody
406 
407     def popbody(self) -> List[str]:
408         body = self.body
409         self.body = self.bodystack.pop()
410         return body
411 
412     def astext(self) -> str:
413         self.elements.update({
414             'body': ''.join(self.body),
415             'indices': self.generate_indices()
416         })
417         return self.render('latex.tex_t', self.elements)
418 
419     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
420         if withdoc:
421             id = self.curfilestack[-1] + ':' + id
422         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
423 
424     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
425         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
426         if anchor:
427             return r'\phantomsection' + labels
428         else:
429             return labels
430 
431     def hyperlink(self, id: str) -> str:
432         return r'{\hyperref[%s]{' % self.idescape(id)
433 
434     def hyperpageref(self, id: str) -> str:
435         return r'\autopageref*{%s}' % self.idescape(id)
436 
437     def escape(self, s: str) -> str:
438         return texescape.escape(s, self.config.latex_engine)
439 
440     def idescape(self, id: str) -> str:
441         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
442             encode('ascii', 'backslashreplace').decode('ascii').\
443             replace('\\', '_')
444 
445     def babel_renewcommand(self, command: str, definition: str) -> str:
446         if self.elements['multilingual']:
447             prefix = r'\addto\captions%s{' % self.babel.get_language()
448             suffix = '}'
449         else:  # babel is disabled (mainly for Japanese environment)
450             prefix = ''
451             suffix = ''
452 
453         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
454 
455     def generate_indices(self) -> str:
456         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
457             ret.append(r'\begin{sphinxtheindex}' + CR)
458             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
459             for i, (letter, entries) in enumerate(content):
460                 if i > 0:
461                     ret.append(r'\indexspace' + CR)
462                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
463                 for entry in entries:
464                     if not entry[3]:
465                         continue
466                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
467                                self.encode(entry[0]))
468                     if entry[4]:
469                         # add "extra" info
470                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
471                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
472                                (entry[2], self.idescape(entry[3])) + CR)
473             ret.append(r'\end{sphinxtheindex}' + CR)
474 
475         ret = []
476         # latex_domain_indices can be False/True or a list of index names
477         indices_config = self.config.latex_domain_indices
478         if indices_config:
479             for domain in self.builder.env.domains.values():
480                 for indexcls in domain.indices:
481                     indexname = '%s-%s' % (domain.name, indexcls.name)
482                     if isinstance(indices_config, list):
483                         if indexname not in indices_config:
484                             continue
485                     content, collapsed = indexcls(domain).generate(
486                         self.builder.docnames)
487                     if not content:
488                         continue
489                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
490                     generate(content, collapsed)
491 
492         return ''.join(ret)
493 
494     def render(self, template_name: str, variables: Dict) -> str:
495         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
496         for template_dir in self.config.templates_path:
497             template = path.join(self.builder.confdir, template_dir,
498                                  template_name)
499             if path.exists(template):
500                 return renderer.render(template, variables)
501 
502         return renderer.render(template_name, variables)
503 
504     @property
505     def table(self) -> Table:
506         """Get current table."""
507         if self.tables:
508             return self.tables[-1]
509         else:
510             return None
511 
512     def visit_document(self, node: Element) -> None:
513         self.curfilestack.append(node.get('docname', ''))
514         if self.first_document == 1:
515             # the first document is all the regular content ...
516             self.first_document = 0
517         elif self.first_document == 0:
518             # ... and all others are the appendices
519             self.body.append(CR + r'\appendix' + CR)
520             self.first_document = -1
521         if 'docname' in node:
522             self.body.append(self.hypertarget(':doc'))
523         # "- 1" because the level is increased before the title is visited
524         self.sectionlevel = self.top_sectionlevel - 1
525 
526     def depart_document(self, node: Element) -> None:
527         pass
528 
529     def visit_start_of_file(self, node: Element) -> None:
530         self.curfilestack.append(node['docname'])
531 
532     def depart_start_of_file(self, node: Element) -> None:
533         self.curfilestack.pop()
534 
535     def visit_section(self, node: Element) -> None:
536         if not self.this_is_the_title:
537             self.sectionlevel += 1
538         self.body.append(BLANKLINE)
539 
540     def depart_section(self, node: Element) -> None:
541         self.sectionlevel = max(self.sectionlevel - 1,
542                                 self.top_sectionlevel - 1)
543 
544     def visit_problematic(self, node: Element) -> None:
545         self.body.append(r'{\color{red}\bfseries{}')
546 
547     def depart_problematic(self, node: Element) -> None:
548         self.body.append('}')
549 
550     def visit_topic(self, node: Element) -> None:
551         self.in_minipage = 1
552         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
553 
554     def depart_topic(self, node: Element) -> None:
555         self.in_minipage = 0
556         self.body.append(r'\end{sphinxShadowBox}' + CR)
557     visit_sidebar = visit_topic
558     depart_sidebar = depart_topic
559 
560     def visit_glossary(self, node: Element) -> None:
561         pass
562 
563     def depart_glossary(self, node: Element) -> None:
564         pass
565 
566     def visit_productionlist(self, node: Element) -> None:
567         self.body.append(BLANKLINE)
568         self.body.append(r'\begin{productionlist}' + CR)
569         self.in_production_list = 1
570 
571     def depart_productionlist(self, node: Element) -> None:
572         self.body.append(r'\end{productionlist}' + BLANKLINE)
573         self.in_production_list = 0
574 
575     def visit_production(self, node: Element) -> None:
576         if node['tokenname']:
577             tn = node['tokenname']
578             self.body.append(self.hypertarget('grammar-token-' + tn))
579             self.body.append(r'\production{%s}{' % self.encode(tn))
580         else:
581             self.body.append(r'\productioncont{')
582 
583     def depart_production(self, node: Element) -> None:
584         self.body.append('}' + CR)
585 
586     def visit_transition(self, node: Element) -> None:
587         self.body.append(self.elements['transition'])
588 
589     def depart_transition(self, node: Element) -> None:
590         pass
591 
592     def visit_title(self, node: Element) -> None:
593         parent = node.parent
594         if isinstance(parent, addnodes.seealso):
595             # the environment already handles this
596             raise nodes.SkipNode
597         elif isinstance(parent, nodes.section):
598             if self.this_is_the_title:
599                 if len(node.children) != 1 and not isinstance(node.children[0],
600                                                               nodes.Text):
601                     logger.warning(__('document title is not a single Text node'),
602                                    location=node)
603                 if not self.elements['title']:
604                     # text needs to be escaped since it is inserted into
605                     # the output literally
606                     self.elements['title'] = self.escape(node.astext())
607                 self.this_is_the_title = 0
608                 raise nodes.SkipNode
609             else:
610                 short = ''
611                 if list(node.traverse(nodes.image)):
612                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
613 
614                 try:
615                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
616                 except IndexError:
617                     # just use "subparagraph", it's not numbered anyway
618                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
619                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
620         elif isinstance(parent, nodes.topic):
621             self.body.append(r'\sphinxstyletopictitle{')
622             self.context.append('}' + CR)
623         elif isinstance(parent, nodes.sidebar):
624             self.body.append(r'\sphinxstylesidebartitle{')
625             self.context.append('}' + CR)
626         elif isinstance(parent, nodes.Admonition):
627             self.body.append('{')
628             self.context.append('}' + CR)
629         elif isinstance(parent, nodes.table):
630             # Redirect body output until title is finished.
631             self.pushbody([])
632         else:
633             logger.warning(__('encountered title node not in section, topic, table, '
634                               'admonition or sidebar'),
635                            location=node)
636             self.body.append(r'\sphinxstyleothertitle{')
637             self.context.append('}' + CR)
638         self.in_title = 1
639 
640     def depart_title(self, node: Element) -> None:
641         self.in_title = 0
642         if isinstance(node.parent, nodes.table):
643             self.table.caption = self.popbody()
644         else:
645             self.body.append(self.context.pop())
646 
647     def visit_subtitle(self, node: Element) -> None:
648         if isinstance(node.parent, nodes.sidebar):
649             self.body.append(r'\sphinxstylesidebarsubtitle{')
650             self.context.append('}' + CR)
651         else:
652             self.context.append('')
653 
654     def depart_subtitle(self, node: Element) -> None:
655         self.body.append(self.context.pop())
656 
657     #############################################################
658     # Domain-specific object descriptions
659     #############################################################
660 
661     # Top-level nodes for descriptions
662     ##################################
663 
664     def visit_desc(self, node: Element) -> None:
665         if self.config.latex_show_urls == 'footnote':
666             self.body.append(BLANKLINE)
667             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
668         else:
669             self.body.append(BLANKLINE)
670             self.body.append(r'\begin{fulllineitems}' + CR)
671         if self.table:
672             self.table.has_problematic = True
673 
674     def depart_desc(self, node: Element) -> None:
675         if self.config.latex_show_urls == 'footnote':
676             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
677         else:
678             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
679 
680     def _visit_signature_line(self, node: Element) -> None:
681         for child in node:
682             if isinstance(child, addnodes.desc_parameterlist):
683                 self.body.append(r'\pysiglinewithargsret{')
684                 break
685         else:
686             self.body.append(r'\pysigline{')
687 
688     def _depart_signature_line(self, node: Element) -> None:
689         self.body.append('}')
690 
691     def visit_desc_signature(self, node: Element) -> None:
692         if node.parent['objtype'] != 'describe' and node['ids']:
693             hyper = self.hypertarget(node['ids'][0])
694         else:
695             hyper = ''
696         self.body.append(hyper)
697         if not node.get('is_multiline'):
698             self._visit_signature_line(node)
699         else:
700             self.body.append('%' + CR)
701             self.body.append(r'\pysigstartmultiline' + CR)
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append('%' + CR)
708             self.body.append(r'\pysigstopmultiline')
709 
710     def visit_desc_signature_line(self, node: Element) -> None:
711         self._visit_signature_line(node)
712 
713     def depart_desc_signature_line(self, node: Element) -> None:
714         self._depart_signature_line(node)
715 
716     def visit_desc_content(self, node: Element) -> None:
717         pass
718 
719     def depart_desc_content(self, node: Element) -> None:
720         pass
721 
722     def visit_desc_inline(self, node: Element) -> None:
723         self.body.append(r'\sphinxcode{\sphinxupquote{')
724 
725     def depart_desc_inline(self, node: Element) -> None:
726         self.body.append('}}')
727 
728     # Nodes for high-level structure in signatures
729     ##############################################
730 
731     def visit_desc_name(self, node: Element) -> None:
732         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
733         self.literal_whitespace += 1
734 
735     def depart_desc_name(self, node: Element) -> None:
736         self.body.append('}}')
737         self.literal_whitespace -= 1
738 
739     def visit_desc_addname(self, node: Element) -> None:
740         self.body.append(r'\sphinxcode{\sphinxupquote{')
741         self.literal_whitespace += 1
742 
743     def depart_desc_addname(self, node: Element) -> None:
744         self.body.append('}}')
745         self.literal_whitespace -= 1
746 
747     def visit_desc_type(self, node: Element) -> None:
748         pass
749 
750     def depart_desc_type(self, node: Element) -> None:
751         pass
752 
753     def visit_desc_returns(self, node: Element) -> None:
754         self.body.append(r'{ $\rightarrow$ ')
755 
756     def depart_desc_returns(self, node: Element) -> None:
757         self.body.append(r'}')
758 
759     def visit_desc_parameterlist(self, node: Element) -> None:
760         # close name, open parameterlist
761         self.body.append('}{')
762         self.first_param = 1
763 
764     def depart_desc_parameterlist(self, node: Element) -> None:
765         # close parameterlist, open return annotation
766         self.body.append('}{')
767 
768     def visit_desc_parameter(self, node: Element) -> None:
769         if not self.first_param:
770             self.body.append(', ')
771         else:
772             self.first_param = 0
773         if not node.hasattr('noemph'):
774             self.body.append(r'\emph{')
775 
776     def depart_desc_parameter(self, node: Element) -> None:
777         if not node.hasattr('noemph'):
778             self.body.append('}')
779 
780     def visit_desc_optional(self, node: Element) -> None:
781         self.body.append(r'\sphinxoptional{')
782 
783     def depart_desc_optional(self, node: Element) -> None:
784         self.body.append('}')
785 
786     def visit_desc_annotation(self, node: Element) -> None:
787         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
788 
789     def depart_desc_annotation(self, node: Element) -> None:
790         self.body.append('}}')
791 
792     ##############################################
793 
794     def visit_seealso(self, node: Element) -> None:
795         self.body.append(BLANKLINE)
796         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
797         self.body.append(r'\nopagebreak' + BLANKLINE)
798 
799     def depart_seealso(self, node: Element) -> None:
800         self.body.append(BLANKLINE)
801 
802     def visit_rubric(self, node: Element) -> None:
803         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
804             raise nodes.SkipNode
805         self.body.append(r'\subsubsection*{')
806         self.context.append('}' + CR)
807         self.in_title = 1
808 
809     def depart_rubric(self, node: Element) -> None:
810         self.in_title = 0
811         self.body.append(self.context.pop())
812 
813     def visit_footnote(self, node: Element) -> None:
814         self.in_footnote += 1
815         label = cast(nodes.label, node[0])
816         if 'auto' not in node:
817             self.body.append(r'\sphinxstepexplicit ')
818         if self.in_parsed_literal:
819             self.body.append(r'\begin{footnote}[%s]' % label.astext())
820         else:
821             self.body.append('%' + CR)
822             self.body.append(r'\begin{footnote}[%s]' % label.astext())
823         if 'auto' not in node:
824             self.body.append(r'\phantomsection'
825                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
826         self.body.append(r'\sphinxAtStartFootnote' + CR)
827 
828     def depart_footnote(self, node: Element) -> None:
829         if self.in_parsed_literal:
830             self.body.append(r'\end{footnote}')
831         else:
832             self.body.append('%' + CR)
833             self.body.append(r'\end{footnote}')
834         self.in_footnote -= 1
835 
836     def visit_label(self, node: Element) -> None:
837         raise nodes.SkipNode
838 
839     def visit_tabular_col_spec(self, node: Element) -> None:
840         self.next_table_colspec = node['spec']
841         raise nodes.SkipNode
842 
843     def visit_table(self, node: Element) -> None:
844         if len(self.tables) == 1:
845             if self.table.get_table_type() == 'longtable':
846                 raise UnsupportedError(
847                     '%s:%s: longtable does not support nesting a table.' %
848                     (self.curfilestack[-1], node.line or ''))
849             else:
850                 # change type of parent table to tabular
851                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
852                 self.table.has_problematic = True
853         elif len(self.tables) > 2:
854             raise UnsupportedError(
855                 '%s:%s: deeply nested tables are not implemented.' %
856                 (self.curfilestack[-1], node.line or ''))
857 
858         self.tables.append(Table(node))
859         if self.next_table_colspec:
860             self.table.colspec = '{%s}' % self.next_table_colspec + CR
861             if 'colwidths-given' in node.get('classes', []):
862                 logger.info(__('both tabularcolumns and :widths: option are given. '
863                                ':widths: is ignored.'), location=node)
864         self.next_table_colspec = None
865 
866     def depart_table(self, node: Element) -> None:
867         labels = self.hypertarget_to(node)
868         table_type = self.table.get_table_type()
869         table = self.render(table_type + '.tex_t',
870                             dict(table=self.table, labels=labels))
871         self.body.append(BLANKLINE)
872         self.body.append(table)
873         self.body.append(CR)
874 
875         self.tables.pop()
876 
877     def visit_colspec(self, node: Element) -> None:
878         self.table.colcount += 1
879         if 'colwidth' in node:
880             self.table.colwidths.append(node['colwidth'])
881         if 'stub' in node:
882             self.table.stubs.append(self.table.colcount - 1)
883 
884     def depart_colspec(self, node: Element) -> None:
885         pass
886 
887     def visit_tgroup(self, node: Element) -> None:
888         pass
889 
890     def depart_tgroup(self, node: Element) -> None:
891         pass
892 
893     def visit_thead(self, node: Element) -> None:
894         # Redirect head output until header is finished.
895         self.pushbody(self.table.header)
896 
897     def depart_thead(self, node: Element) -> None:
898         self.popbody()
899 
900     def visit_tbody(self, node: Element) -> None:
901         # Redirect body output until table is finished.
902         self.pushbody(self.table.body)
903 
904     def depart_tbody(self, node: Element) -> None:
905         self.popbody()
906 
907     def visit_row(self, node: Element) -> None:
908         self.table.col = 0
909 
910         # fill columns if the row starts with the bottom of multirow cell
911         while True:
912             cell = self.table.cell(self.table.row, self.table.col)
913             if cell is None:  # not a bottom of multirow cell
914                 break
915             else:  # a bottom of multirow cell
916                 self.table.col += cell.width
917                 if cell.col:
918                     self.body.append('&')
919                 if cell.width == 1:
920                     # insert suitable strut for equalizing row heights in given multirow
921                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
922                 else:  # use \multicolumn for wide multirow cell
923                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
924                                      (cell.width, cell.cell_id))
925 
926     def depart_row(self, node: Element) -> None:
927         self.body.append(r'\\' + CR)
928         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
929         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
930         if all(underlined):
931             self.body.append(r'\hline')
932         else:
933             i = 0
934             underlined.extend([False])  # sentinel
935             while i < len(underlined):
936                 if underlined[i] is True:
937                     j = underlined[i:].index(False)
938                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
939                     i += j
940                 i += 1
941         self.table.row += 1
942 
943     def visit_entry(self, node: Element) -> None:
944         if self.table.col > 0:
945             self.body.append('&')
946         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
947         cell = self.table.cell()
948         context = ''
949         if cell.width > 1:
950             if self.config.latex_use_latex_multicolumn:
951                 if self.table.col == 0:
952                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
953                 else:
954                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
955                 context = '}%' + CR
956             else:
957                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
958                 context = r'\sphinxstopmulticolumn' + CR
959         if cell.height > 1:
960             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
961             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
962             context = '}%' + CR + context
963         if cell.width > 1 or cell.height > 1:
964             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
965                              % (cell.width, self.table.colcount) + CR)
966             context = (r'\par' + CR + r'\vskip-\baselineskip'
967                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
968             self.needs_linetrimming = 1
969         if len(list(node.traverse(nodes.paragraph))) >= 2:
970             self.table.has_oldproblematic = True
971         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
972             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
973                 pass
974             else:
975                 self.body.append(r'\sphinxstyletheadfamily ')
976         if self.needs_linetrimming:
977             self.pushbody([])
978         self.context.append(context)
979 
980     def depart_entry(self, node: Element) -> None:
981         if self.needs_linetrimming:
982             self.needs_linetrimming = 0
983             body = self.popbody()
984 
985             # Remove empty lines from top of merged cell
986             while body and body[0] == CR:
987                 body.pop(0)
988             self.body.extend(body)
989 
990         self.body.append(self.context.pop())
991 
992         cell = self.table.cell()
993         self.table.col += cell.width
994 
995         # fill columns if next ones are a bottom of wide-multirow cell
996         while True:
997             nextcell = self.table.cell()
998             if nextcell is None:  # not a bottom of multirow cell
999                 break
1000             else:  # a bottom part of multirow cell
1001                 self.table.col += nextcell.width
1002                 self.body.append('&')
1003                 if nextcell.width == 1:
1004                     # insert suitable strut for equalizing row heights in multirow
1005                     # they also serve to clear colour panels which would hide the text
1006                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1007                 else:
1008                     # use \multicolumn for wide multirow cell
1009                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1010                                      (nextcell.width, nextcell.cell_id))
1011 
1012     def visit_acks(self, node: Element) -> None:
1013         # this is a list in the source, but should be rendered as a
1014         # comma-separated list here
1015         bullet_list = cast(nodes.bullet_list, node[0])
1016         list_items = cast(Iterable[nodes.list_item], bullet_list)
1017         self.body.append(BLANKLINE)
1018         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1019         self.body.append(BLANKLINE)
1020         raise nodes.SkipNode
1021 
1022     def visit_bullet_list(self, node: Element) -> None:
1023         if not self.compact_list:
1024             self.body.append(r'\begin{itemize}' + CR)
1025         if self.table:
1026             self.table.has_problematic = True
1027 
1028     def depart_bullet_list(self, node: Element) -> None:
1029         if not self.compact_list:
1030             self.body.append(r'\end{itemize}' + CR)
1031 
1032     def visit_enumerated_list(self, node: Element) -> None:
1033         def get_enumtype(node: Element) -> str:
1034             enumtype = node.get('enumtype', 'arabic')
1035             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1036                 # fallback to arabic if alphabet counter overflows
1037                 enumtype = 'arabic'
1038 
1039             return enumtype
1040 
1041         def get_nested_level(node: Element) -> int:
1042             if node is None:
1043                 return 0
1044             elif isinstance(node, nodes.enumerated_list):
1045                 return get_nested_level(node.parent) + 1
1046             else:
1047                 return get_nested_level(node.parent)
1048 
1049         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1050         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1051         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1052         prefix = node.get('prefix', '')
1053         suffix = node.get('suffix', '.')
1054 
1055         self.body.append(r'\begin{enumerate}' + CR)
1056         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1057                          (style, enum, enumnext, prefix, suffix) + CR)
1058         if 'start' in node:
1059             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1060         if self.table:
1061             self.table.has_problematic = True
1062 
1063     def depart_enumerated_list(self, node: Element) -> None:
1064         self.body.append(r'\end{enumerate}' + CR)
1065 
1066     def visit_list_item(self, node: Element) -> None:
1067         # Append "{}" in case the next character is "[", which would break
1068         # LaTeX's list environment (no numbering and the "[" is not printed).
1069         self.body.append(r'\item {} ')
1070 
1071     def depart_list_item(self, node: Element) -> None:
1072         self.body.append(CR)
1073 
1074     def visit_definition_list(self, node: Element) -> None:
1075         self.body.append(r'\begin{description}' + CR)
1076         if self.table:
1077             self.table.has_problematic = True
1078 
1079     def depart_definition_list(self, node: Element) -> None:
1080         self.body.append(r'\end{description}' + CR)
1081 
1082     def visit_definition_list_item(self, node: Element) -> None:
1083         pass
1084 
1085     def depart_definition_list_item(self, node: Element) -> None:
1086         pass
1087 
1088     def visit_term(self, node: Element) -> None:
1089         self.in_term += 1
1090         ctx = ''
1091         if node.get('ids'):
1092             ctx = r'\phantomsection'
1093             for node_id in node['ids']:
1094                 ctx += self.hypertarget(node_id, anchor=False)
1095         ctx += r'}] \leavevmode'
1096         self.body.append(r'\item[{')
1097         self.context.append(ctx)
1098 
1099     def depart_term(self, node: Element) -> None:
1100         self.body.append(self.context.pop())
1101         self.in_term -= 1
1102 
1103     def visit_classifier(self, node: Element) -> None:
1104         self.body.append('{[}')
1105 
1106     def depart_classifier(self, node: Element) -> None:
1107         self.body.append('{]}')
1108 
1109     def visit_definition(self, node: Element) -> None:
1110         pass
1111 
1112     def depart_definition(self, node: Element) -> None:
1113         self.body.append(CR)
1114 
1115     def visit_field_list(self, node: Element) -> None:
1116         self.body.append(r'\begin{quote}\begin{description}' + CR)
1117         if self.table:
1118             self.table.has_problematic = True
1119 
1120     def depart_field_list(self, node: Element) -> None:
1121         self.body.append(r'\end{description}\end{quote}' + CR)
1122 
1123     def visit_field(self, node: Element) -> None:
1124         pass
1125 
1126     def depart_field(self, node: Element) -> None:
1127         pass
1128 
1129     visit_field_name = visit_term
1130     depart_field_name = depart_term
1131 
1132     visit_field_body = visit_definition
1133     depart_field_body = depart_definition
1134 
1135     def visit_paragraph(self, node: Element) -> None:
1136         index = node.parent.index(node)
1137         if (index > 0 and isinstance(node.parent, nodes.compound) and
1138                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1139                 not isinstance(node.parent[index - 1], nodes.compound)):
1140             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1141             self.body.append(r'\noindent' + CR)
1142         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1143             # don't insert blank line, if the paragraph is second child of a footnote
1144             # (first one is label node)
1145             pass
1146         else:
1147             # the \sphinxAtStartPar is to allow hyphenation of first word of
1148             # a paragraph in narrow contexts such as in a table cell
1149             # added as two items (cf. line trimming in depart_entry())
1150             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1151 
1152     def depart_paragraph(self, node: Element) -> None:
1153         self.body.append(CR)
1154 
1155     def visit_centered(self, node: Element) -> None:
1156         self.body.append(CR + r'\begin{center}')
1157         if self.table:
1158             self.table.has_problematic = True
1159 
1160     def depart_centered(self, node: Element) -> None:
1161         self.body.append(CR + r'\end{center}')
1162 
1163     def visit_hlist(self, node: Element) -> None:
1164         self.compact_list += 1
1165         ncolumns = node['ncolumns']
1166         if self.compact_list > 1:
1167             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1168         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1169         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1170                          r'\setlength{\parskip}{0pt}' + CR)
1171         if self.table:
1172             self.table.has_problematic = True
1173 
1174     def depart_hlist(self, node: Element) -> None:
1175         self.compact_list -= 1
1176         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1177 
1178     def visit_hlistcol(self, node: Element) -> None:
1179         pass
1180 
1181     def depart_hlistcol(self, node: Element) -> None:
1182         # \columnbreak would guarantee same columns as in html output.  But
1183         # some testing with long items showed that columns may be too uneven.
1184         # And in case only of short items, the automatic column breaks should
1185         # match the ones pre-computed by the hlist() directive.
1186         # self.body.append(r'\columnbreak\n')
1187         pass
1188 
1189     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1190         try:
1191             return rstdim_to_latexdim(width_str, scale)
1192         except ValueError:
1193             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1194             return None
1195 
1196     def is_inline(self, node: Element) -> bool:
1197         """Check whether a node represents an inline element."""
1198         return isinstance(node.parent, nodes.TextElement)
1199 
1200     def visit_image(self, node: Element) -> None:
1201         pre: List[str] = []  # in reverse order
1202         post: List[str] = []
1203         include_graphics_options = []
1204         has_hyperlink = isinstance(node.parent, nodes.reference)
1205         if has_hyperlink:
1206             is_inline = self.is_inline(node.parent)
1207         else:
1208             is_inline = self.is_inline(node)
1209         if 'width' in node:
1210             if 'scale' in node:
1211                 w = self.latex_image_length(node['width'], node['scale'])
1212             else:
1213                 w = self.latex_image_length(node['width'])
1214             if w:
1215                 include_graphics_options.append('width=%s' % w)
1216         if 'height' in node:
1217             if 'scale' in node:
1218                 h = self.latex_image_length(node['height'], node['scale'])
1219             else:
1220                 h = self.latex_image_length(node['height'])
1221             if h:
1222                 include_graphics_options.append('height=%s' % h)
1223         if 'scale' in node:
1224             if not include_graphics_options:
1225                 # if no "width" nor "height", \sphinxincludegraphics will fit
1226                 # to the available text width if oversized after rescaling.
1227                 include_graphics_options.append('scale=%s'
1228                                                 % (float(node['scale']) / 100.0))
1229         if 'align' in node:
1230             align_prepost = {
1231                 # By default latex aligns the top of an image.
1232                 (1, 'top'): ('', ''),
1233                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1234                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1235                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1236                 # These 2 don't exactly do the right thing.  The image should
1237                 # be floated alongside the paragraph.  See
1238                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1239                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1240                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1241             }
1242             try:
1243                 pre.append(align_prepost[is_inline, node['align']][0])
1244                 post.append(align_prepost[is_inline, node['align']][1])
1245             except KeyError:
1246                 pass
1247         if self.in_parsed_literal:
1248             pre.append(r'{\sphinxunactivateextrasandspace ')
1249             post.append('}')
1250         if not is_inline and not has_hyperlink:
1251             pre.append(CR + r'\noindent')
1252             post.append(CR)
1253         pre.reverse()
1254         if node['uri'] in self.builder.images:
1255             uri = self.builder.images[node['uri']]
1256         else:
1257             # missing image!
1258             if self.ignore_missing_images:
1259                 return
1260             uri = node['uri']
1261         if uri.find('://') != -1:
1262             # ignore remote images
1263             return
1264         self.body.extend(pre)
1265         options = ''
1266         if include_graphics_options:
1267             options = '[%s]' % ','.join(include_graphics_options)
1268         base, ext = path.splitext(uri)
1269         if self.in_title and base:
1270             # Lowercase tokens forcely because some fncychap themes capitalize
1271             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1272             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1273                              (options, base, ext))
1274         else:
1275             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1276                              (options, base, ext))
1277         self.body.extend(post)
1278 
1279     def depart_image(self, node: Element) -> None:
1280         pass
1281 
1282     def visit_figure(self, node: Element) -> None:
1283         align = self.elements['figure_align']
1284         if self.no_latex_floats:
1285             align = "H"
1286         if self.table:
1287             # TODO: support align option
1288             if 'width' in node:
1289                 length = self.latex_image_length(node['width'])
1290                 if length:
1291                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1292                     self.body.append(r'\centering' + CR)
1293             else:
1294                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1295                 self.body.append(r'\centering' + CR)
1296             if any(isinstance(child, nodes.caption) for child in node):
1297                 self.body.append(r'\capstart')
1298             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1299         elif node.get('align', '') in ('left', 'right'):
1300             length = None
1301             if 'width' in node:
1302                 length = self.latex_image_length(node['width'])
1303             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1304                 length = self.latex_image_length(node[0]['width'])
1305             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1306                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1307             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1308                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1309             self.body.append(r'\centering')
1310             self.context.append(r'\end{wrapfigure}' + CR)
1311         elif self.in_minipage:
1312             self.body.append(CR + r'\begin{center}')
1313             self.context.append(r'\end{center}' + CR)
1314         else:
1315             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1316             self.body.append(r'\centering' + CR)
1317             if any(isinstance(child, nodes.caption) for child in node):
1318                 self.body.append(r'\capstart' + CR)
1319             self.context.append(r'\end{figure}' + CR)
1320 
1321     def depart_figure(self, node: Element) -> None:
1322         self.body.append(self.context.pop())
1323 
1324     def visit_caption(self, node: Element) -> None:
1325         self.in_caption += 1
1326         if isinstance(node.parent, captioned_literal_block):
1327             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1328         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1329             self.body.append(r'\captionof{figure}{')
1330         elif self.table and node.parent.tagname == 'figure':
1331             self.body.append(r'\sphinxfigcaption{')
1332         else:
1333             self.body.append(r'\caption{')
1334 
1335     def depart_caption(self, node: Element) -> None:
1336         self.body.append('}')
1337         if isinstance(node.parent, nodes.figure):
1338             labels = self.hypertarget_to(node.parent)
1339             self.body.append(labels)
1340         self.in_caption -= 1
1341 
1342     def visit_legend(self, node: Element) -> None:
1343         self.body.append(CR + r'\begin{sphinxlegend}')
1344 
1345     def depart_legend(self, node: Element) -> None:
1346         self.body.append(r'\end{sphinxlegend}' + CR)
1347 
1348     def visit_admonition(self, node: Element) -> None:
1349         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1350         self.no_latex_floats += 1
1351 
1352     def depart_admonition(self, node: Element) -> None:
1353         self.body.append(r'\end{sphinxadmonition}' + CR)
1354         self.no_latex_floats -= 1
1355 
1356     def _visit_named_admonition(self, node: Element) -> None:
1357         label = admonitionlabels[node.tagname]
1358         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1359                          (node.tagname, label))
1360         self.no_latex_floats += 1
1361 
1362     def _depart_named_admonition(self, node: Element) -> None:
1363         self.body.append(r'\end{sphinxadmonition}' + CR)
1364         self.no_latex_floats -= 1
1365 
1366     visit_attention = _visit_named_admonition
1367     depart_attention = _depart_named_admonition
1368     visit_caution = _visit_named_admonition
1369     depart_caution = _depart_named_admonition
1370     visit_danger = _visit_named_admonition
1371     depart_danger = _depart_named_admonition
1372     visit_error = _visit_named_admonition
1373     depart_error = _depart_named_admonition
1374     visit_hint = _visit_named_admonition
1375     depart_hint = _depart_named_admonition
1376     visit_important = _visit_named_admonition
1377     depart_important = _depart_named_admonition
1378     visit_note = _visit_named_admonition
1379     depart_note = _depart_named_admonition
1380     visit_tip = _visit_named_admonition
1381     depart_tip = _depart_named_admonition
1382     visit_warning = _visit_named_admonition
1383     depart_warning = _depart_named_admonition
1384 
1385     def visit_versionmodified(self, node: Element) -> None:
1386         pass
1387 
1388     def depart_versionmodified(self, node: Element) -> None:
1389         pass
1390 
1391     def visit_target(self, node: Element) -> None:
1392         def add_target(id: str) -> None:
1393             # indexing uses standard LaTeX index markup, so the targets
1394             # will be generated differently
1395             if id.startswith('index-'):
1396                 return
1397 
1398             # equations also need no extra blank line nor hypertarget
1399             # TODO: fix this dependency on mathbase extension internals
1400             if id.startswith('equation-'):
1401                 return
1402 
1403             # insert blank line, if the target follows a paragraph node
1404             index = node.parent.index(node)
1405             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1406                 self.body.append(CR)
1407 
1408             # do not generate \phantomsection in \section{}
1409             anchor = not self.in_title
1410             self.body.append(self.hypertarget(id, anchor=anchor))
1411 
1412         # skip if visitor for next node supports hyperlink
1413         next_node: Node = node
1414         while isinstance(next_node, nodes.target):
1415             next_node = next_node.next_node(ascend=True)
1416 
1417         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1418         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1419             return
1420         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1421             return
1422 
1423         if 'refuri' in node:
1424             return
1425         if 'anonymous' in node:
1426             return
1427         if node.get('refid'):
1428             prev_node = get_prev_node(node)
1429             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1430                 # a target for a hyperlink reference having alias
1431                 pass
1432             else:
1433                 add_target(node['refid'])
1434         for id in node['ids']:
1435             add_target(id)
1436 
1437     def depart_target(self, node: Element) -> None:
1438         pass
1439 
1440     def visit_attribution(self, node: Element) -> None:
1441         self.body.append(CR + r'\begin{flushright}' + CR)
1442         self.body.append('---')
1443 
1444     def depart_attribution(self, node: Element) -> None:
1445         self.body.append(CR + r'\end{flushright}' + CR)
1446 
1447     def visit_index(self, node: Element) -> None:
1448         def escape(value: str) -> str:
1449             value = self.encode(value)
1450             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1451             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1452             value = value.replace('"', '""')
1453             value = value.replace('@', '"@')
1454             value = value.replace('!', '"!')
1455             value = value.replace('|', r'\textbar{}')
1456             return value
1457 
1458         def style(string: str) -> str:
1459             match = EXTRA_RE.match(string)
1460             if match:
1461                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1462             else:
1463                 return r'\spxentry{%s}' % string
1464 
1465         if not node.get('inline', True):
1466             self.body.append(CR)
1467         entries = node['entries']
1468         for type, string, tid, ismain, key_ in entries:
1469             m = ''
1470             if ismain:
1471                 m = '|spxpagem'
1472             try:
1473                 if type == 'single':
1474                     try:
1475                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1476                         P1, P2 = style(p1), style(p2)
1477                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1478                     except ValueError:
1479                         p = escape(split_into(1, 'single', string)[0])
1480                         P = style(p)
1481                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1482                 elif type == 'pair':
1483                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1484                     P1, P2 = style(p1), style(p2)
1485                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1486                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1487                 elif type == 'triple':
1488                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1489                     P1, P2, P3 = style(p1), style(p2), style(p3)
1490                     self.body.append(
1491                         r'\index{%s@%s!%s %s@%s %s%s}'
1492                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1493                         r'\index{%s@%s!%s %s@%s %s%s}' %
1494                         (p1, P1, p2, p3, P2, P3, m,
1495                          p2, P2, p3, p1, P3, P1, m,
1496                          p3, P3, p1, p2, P1, P2, m))
1497                 elif type == 'see':
1498                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1499                     P1 = style(p1)
1500                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1501                 elif type == 'seealso':
1502                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1503                     P1 = style(p1)
1504                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1505                 else:
1506                     logger.warning(__('unknown index entry type %s found'), type)
1507             except ValueError as err:
1508                 logger.warning(str(err))
1509         if not node.get('inline', True):
1510             self.body.append(r'\ignorespaces ')
1511         raise nodes.SkipNode
1512 
1513     def visit_raw(self, node: Element) -> None:
1514         if not self.is_inline(node):
1515             self.body.append(CR)
1516         if 'latex' in node.get('format', '').split():
1517             self.body.append(node.astext())
1518         if not self.is_inline(node):
1519             self.body.append(CR)
1520         raise nodes.SkipNode
1521 
1522     def visit_reference(self, node: Element) -> None:
1523         if not self.in_title:
1524             for id in node.get('ids'):
1525                 anchor = not self.in_caption
1526                 self.body += self.hypertarget(id, anchor=anchor)
1527         if not self.is_inline(node):
1528             self.body.append(CR)
1529         uri = node.get('refuri', '')
1530         if not uri and node.get('refid'):
1531             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1532         if self.in_title or not uri:
1533             self.context.append('')
1534         elif uri.startswith('#'):
1535             # references to labels in the same document
1536             id = self.curfilestack[-1] + ':' + uri[1:]
1537             self.body.append(self.hyperlink(id))
1538             self.body.append(r'\emph{')
1539             if self.config.latex_show_pagerefs and not \
1540                     self.in_production_list:
1541                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1542             else:
1543                 self.context.append('}}}')
1544         elif uri.startswith('%'):
1545             # references to documents or labels inside documents
1546             hashindex = uri.find('#')
1547             if hashindex == -1:
1548                 # reference to the document
1549                 id = uri[1:] + '::doc'
1550             else:
1551                 # reference to a label
1552                 id = uri[1:].replace('#', ':')
1553             self.body.append(self.hyperlink(id))
1554             if (len(node) and
1555                     isinstance(node[0], nodes.Element) and
1556                     'std-term' in node[0].get('classes', [])):
1557                 # don't add a pageref for glossary terms
1558                 self.context.append('}}}')
1559                 # mark up as termreference
1560                 self.body.append(r'\sphinxtermref{')
1561             else:
1562                 self.body.append(r'\sphinxcrossref{')
1563                 if self.config.latex_show_pagerefs and not self.in_production_list:
1564                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1565                 else:
1566                     self.context.append('}}}')
1567         else:
1568             if len(node) == 1 and uri == node[0]:
1569                 if node.get('nolinkurl'):
1570                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1571                 else:
1572                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1573                 raise nodes.SkipNode
1574             else:
1575                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1576                 self.context.append('}')
1577 
1578     def depart_reference(self, node: Element) -> None:
1579         self.body.append(self.context.pop())
1580         if not self.is_inline(node):
1581             self.body.append(CR)
1582 
1583     def visit_number_reference(self, node: Element) -> None:
1584         if node.get('refid'):
1585             id = self.curfilestack[-1] + ':' + node['refid']
1586         else:
1587             id = node.get('refuri', '')[1:].replace('#', ':')
1588 
1589         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1590         if r'\{name\}' in title or r'\{number\}' in title:
1591             # new style format (cf. "Fig.%{number}")
1592             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1593             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1594                                              number=r'\ref{%s}' % self.idescape(id))
1595         else:
1596             # old style format (cf. "Fig.%{number}")
1597             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1598         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1599         self.body.append(hyperref)
1600 
1601         raise nodes.SkipNode
1602 
1603     def visit_download_reference(self, node: Element) -> None:
1604         pass
1605 
1606     def depart_download_reference(self, node: Element) -> None:
1607         pass
1608 
1609     def visit_pending_xref(self, node: Element) -> None:
1610         pass
1611 
1612     def depart_pending_xref(self, node: Element) -> None:
1613         pass
1614 
1615     def visit_emphasis(self, node: Element) -> None:
1616         self.body.append(r'\sphinxstyleemphasis{')
1617 
1618     def depart_emphasis(self, node: Element) -> None:
1619         self.body.append('}')
1620 
1621     def visit_literal_emphasis(self, node: Element) -> None:
1622         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1623 
1624     def depart_literal_emphasis(self, node: Element) -> None:
1625         self.body.append('}}')
1626 
1627     def visit_strong(self, node: Element) -> None:
1628         self.body.append(r'\sphinxstylestrong{')
1629 
1630     def depart_strong(self, node: Element) -> None:
1631         self.body.append('}')
1632 
1633     def visit_literal_strong(self, node: Element) -> None:
1634         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1635 
1636     def depart_literal_strong(self, node: Element) -> None:
1637         self.body.append('}}')
1638 
1639     def visit_abbreviation(self, node: Element) -> None:
1640         abbr = node.astext()
1641         self.body.append(r'\sphinxstyleabbreviation{')
1642         # spell out the explanation once
1643         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1644             self.context.append('} (%s)' % self.encode(node['explanation']))
1645             self.handled_abbrs.add(abbr)
1646         else:
1647             self.context.append('}')
1648 
1649     def depart_abbreviation(self, node: Element) -> None:
1650         self.body.append(self.context.pop())
1651 
1652     def visit_manpage(self, node: Element) -> None:
1653         return self.visit_literal_emphasis(node)
1654 
1655     def depart_manpage(self, node: Element) -> None:
1656         return self.depart_literal_emphasis(node)
1657 
1658     def visit_title_reference(self, node: Element) -> None:
1659         self.body.append(r'\sphinxtitleref{')
1660 
1661     def depart_title_reference(self, node: Element) -> None:
1662         self.body.append('}')
1663 
1664     def visit_thebibliography(self, node: Element) -> None:
1665         citations = cast(Iterable[nodes.citation], node)
1666         labels = (cast(nodes.label, citation[0]) for citation in citations)
1667         longest_label = max((label.astext() for label in labels), key=len)
1668         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1669             # adjust max width of citation labels not to break the layout
1670             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1671 
1672         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1673                          self.encode(longest_label) + CR)
1674 
1675     def depart_thebibliography(self, node: Element) -> None:
1676         self.body.append(r'\end{sphinxthebibliography}' + CR)
1677 
1678     def visit_citation(self, node: Element) -> None:
1679         label = cast(nodes.label, node[0])
1680         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1681                                                    node['docname'], node['ids'][0]))
1682 
1683     def depart_citation(self, node: Element) -> None:
1684         pass
1685 
1686     def visit_citation_reference(self, node: Element) -> None:
1687         if self.in_title:
1688             pass
1689         else:
1690             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1691             raise nodes.SkipNode
1692 
1693     def depart_citation_reference(self, node: Element) -> None:
1694         pass
1695 
1696     def visit_literal(self, node: Element) -> None:
1697         if self.in_title:
1698             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1699         elif 'kbd' in node['classes']:
1700             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1701         else:
1702             self.body.append(r'\sphinxcode{\sphinxupquote{')
1703 
1704     def depart_literal(self, node: Element) -> None:
1705         self.body.append('}}')
1706 
1707     def visit_footnote_reference(self, node: Element) -> None:
1708         raise nodes.SkipNode
1709 
1710     def visit_footnotemark(self, node: Element) -> None:
1711         self.body.append(r'\sphinxfootnotemark[')
1712 
1713     def depart_footnotemark(self, node: Element) -> None:
1714         self.body.append(']')
1715 
1716     def visit_footnotetext(self, node: Element) -> None:
1717         label = cast(nodes.label, node[0])
1718         self.body.append('%' + CR)
1719         self.body.append(r'\begin{footnotetext}[%s]'
1720                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1721                          % (label.astext(), label.astext()) + CR)
1722         self.body.append(r'\sphinxAtStartFootnote' + CR)
1723 
1724     def depart_footnotetext(self, node: Element) -> None:
1725         # the \ignorespaces in particular for after table header use
1726         self.body.append('%' + CR)
1727         self.body.append(r'\end{footnotetext}\ignorespaces ')
1728 
1729     def visit_captioned_literal_block(self, node: Element) -> None:
1730         pass
1731 
1732     def depart_captioned_literal_block(self, node: Element) -> None:
1733         pass
1734 
1735     def visit_literal_block(self, node: Element) -> None:
1736         if node.rawsource != node.astext():
1737             # most probably a parsed-literal block -- don't highlight
1738             self.in_parsed_literal += 1
1739             self.body.append(r'\begin{sphinxalltt}' + CR)
1740         else:
1741             labels = self.hypertarget_to(node)
1742             if isinstance(node.parent, captioned_literal_block):
1743                 labels += self.hypertarget_to(node.parent)
1744             if labels and not self.in_footnote:
1745                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1746 
1747             lang = node.get('language', 'default')
1748             linenos = node.get('linenos', False)
1749             highlight_args = node.get('highlight_args', {})
1750             highlight_args['force'] = node.get('force', False)
1751             opts = self.config.highlight_options.get(lang, {})
1752 
1753             hlcode = self.highlighter.highlight_block(
1754                 node.rawsource, lang, opts=opts, linenos=linenos,
1755                 location=node, **highlight_args
1756             )
1757             if self.in_footnote:
1758                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1759                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1760                                         r'\begin{sphinxVerbatim}')
1761             # if in table raise verbatim flag to avoid "tabulary" environment
1762             # and opt for sphinxVerbatimintable to handle caption & long lines
1763             elif self.table:
1764                 self.table.has_problematic = True
1765                 self.table.has_verbatim = True
1766                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1767                                         r'\begin{sphinxVerbatimintable}')
1768             else:
1769                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1770                                         r'\begin{sphinxVerbatim}')
1771             # get consistent trailer
1772             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1773             if self.table and not self.in_footnote:
1774                 hlcode += r'\end{sphinxVerbatimintable}'
1775             else:
1776                 hlcode += r'\end{sphinxVerbatim}'
1777 
1778             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1779             if hllines:
1780                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1781             self.body.append(CR + hlcode + CR)
1782             if hllines:
1783                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1784             raise nodes.SkipNode
1785 
1786     def depart_literal_block(self, node: Element) -> None:
1787         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1788         self.in_parsed_literal -= 1
1789     visit_doctest_block = visit_literal_block
1790     depart_doctest_block = depart_literal_block
1791 
1792     def visit_line(self, node: Element) -> None:
1793         self.body.append(r'\item[] ')
1794 
1795     def depart_line(self, node: Element) -> None:
1796         self.body.append(CR)
1797 
1798     def visit_line_block(self, node: Element) -> None:
1799         if isinstance(node.parent, nodes.line_block):
1800             self.body.append(r'\item[]' + CR)
1801             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1802         else:
1803             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1804         if self.table:
1805             self.table.has_problematic = True
1806 
1807     def depart_line_block(self, node: Element) -> None:
1808         self.body.append(r'\end{DUlineblock}' + CR)
1809 
1810     def visit_block_quote(self, node: Element) -> None:
1811         # If the block quote contains a single object and that object
1812         # is a list, then generate a list not a block quote.
1813         # This lets us indent lists.
1814         done = 0
1815         if len(node.children) == 1:
1816             child = node.children[0]
1817             if isinstance(child, nodes.bullet_list) or \
1818                     isinstance(child, nodes.enumerated_list):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, nodes.bullet_list) or \
1830                     isinstance(child, nodes.enumerated_list):
1831                 done = 1
1832         if not done:
1833             self.body.append(r'\end{quote}' + CR)
1834 
1835     # option node handling copied from docutils' latex writer
1836 
1837     def visit_option(self, node: Element) -> None:
1838         if self.context[-1]:
1839             # this is not the first option
1840             self.body.append(', ')
1841 
1842     def depart_option(self, node: Element) -> None:
1843         # flag that the first option is done.
1844         self.context[-1] += 1
1845 
1846     def visit_option_argument(self, node: Element) -> None:
1847         """The delimiter between an option and its argument."""
1848         self.body.append(node.get('delimiter', ' '))
1849 
1850     def depart_option_argument(self, node: Element) -> None:
1851         pass
1852 
1853     def visit_option_group(self, node: Element) -> None:
1854         self.body.append(r'\item [')
1855         # flag for first option
1856         self.context.append(0)
1857 
1858     def depart_option_group(self, node: Element) -> None:
1859         self.context.pop()  # the flag
1860         self.body.append('] ')
1861 
1862     def visit_option_list(self, node: Element) -> None:
1863         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1864         if self.table:
1865             self.table.has_problematic = True
1866 
1867     def depart_option_list(self, node: Element) -> None:
1868         self.body.append(r'\end{optionlist}' + CR)
1869 
1870     def visit_option_list_item(self, node: Element) -> None:
1871         pass
1872 
1873     def depart_option_list_item(self, node: Element) -> None:
1874         pass
1875 
1876     def visit_option_string(self, node: Element) -> None:
1877         ostring = node.astext()
1878         self.body.append(self.encode(ostring))
1879         raise nodes.SkipNode
1880 
1881     def visit_description(self, node: Element) -> None:
1882         self.body.append(' ')
1883 
1884     def depart_description(self, node: Element) -> None:
1885         pass
1886 
1887     def visit_superscript(self, node: Element) -> None:
1888         self.body.append(r'$^{\text{')
1889 
1890     def depart_superscript(self, node: Element) -> None:
1891         self.body.append('}}$')
1892 
1893     def visit_subscript(self, node: Element) -> None:
1894         self.body.append(r'$_{\text{')
1895 
1896     def depart_subscript(self, node: Element) -> None:
1897         self.body.append('}}$')
1898 
1899     def visit_inline(self, node: Element) -> None:
1900         classes = node.get('classes', [])
1901         if classes in [['menuselection']]:
1902             self.body.append(r'\sphinxmenuselection{')
1903             self.context.append('}')
1904         elif classes in [['guilabel']]:
1905             self.body.append(r'\sphinxguilabel{')
1906             self.context.append('}')
1907         elif classes in [['accelerator']]:
1908             self.body.append(r'\sphinxaccelerator{')
1909             self.context.append('}')
1910         elif classes and not self.in_title:
1911             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1912             self.context.append('}')
1913         else:
1914             self.context.append('')
1915 
1916     def depart_inline(self, node: Element) -> None:
1917         self.body.append(self.context.pop())
1918 
1919     def visit_generated(self, node: Element) -> None:
1920         pass
1921 
1922     def depart_generated(self, node: Element) -> None:
1923         pass
1924 
1925     def visit_compound(self, node: Element) -> None:
1926         pass
1927 
1928     def depart_compound(self, node: Element) -> None:
1929         pass
1930 
1931     def visit_container(self, node: Element) -> None:
1932         classes = node.get('classes', [])
1933         for c in classes:
1934             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1935 
1936     def depart_container(self, node: Element) -> None:
1937         classes = node.get('classes', [])
1938         for c in classes:
1939             self.body.append('\n\\end{sphinxuseclass}')
1940 
1941     def visit_decoration(self, node: Element) -> None:
1942         pass
1943 
1944     def depart_decoration(self, node: Element) -> None:
1945         pass
1946 
1947     # docutils-generated elements that we don't support
1948 
1949     def visit_header(self, node: Element) -> None:
1950         raise nodes.SkipNode
1951 
1952     def visit_footer(self, node: Element) -> None:
1953         raise nodes.SkipNode
1954 
1955     def visit_docinfo(self, node: Element) -> None:
1956         raise nodes.SkipNode
1957 
1958     # text handling
1959 
1960     def encode(self, text: str) -> str:
1961         text = self.escape(text)
1962         if self.literal_whitespace:
1963             # Insert a blank before the newline, to avoid
1964             # ! LaTeX Error: There's no line here to end.
1965             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1966         return text
1967 
1968     def encode_uri(self, text: str) -> str:
1969         # TODO: it is probably wrong that this uses texescape.escape()
1970         #       this must be checked against hyperref package exact dealings
1971         #       mainly, %, #, {, } and \ need escaping via a \ escape
1972         # in \href, the tilde is allowed and must be represented literally
1973         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1974             replace(r'\sphinxhyphen{}', '-').\
1975             replace(r'\textquotesingle{}', "'")
1976 
1977     def visit_Text(self, node: Text) -> None:
1978         text = self.encode(node.astext())
1979         self.body.append(text)
1980 
1981     def depart_Text(self, node: Text) -> None:
1982         pass
1983 
1984     def visit_comment(self, node: Element) -> None:
1985         raise nodes.SkipNode
1986 
1987     def visit_meta(self, node: Element) -> None:
1988         # only valid for HTML
1989         raise nodes.SkipNode
1990 
1991     def visit_system_message(self, node: Element) -> None:
1992         pass
1993 
1994     def depart_system_message(self, node: Element) -> None:
1995         self.body.append(CR)
1996 
1997     def visit_math(self, node: Element) -> None:
1998         if self.in_title:
1999             self.body.append(r'\protect\(%s\protect\)' % node.astext())
2000         else:
2001             self.body.append(r'\(%s\)' % node.astext())
2002         raise nodes.SkipNode
2003 
2004     def visit_math_block(self, node: Element) -> None:
2005         if node.get('label'):
2006             label = "equation:%s:%s" % (node['docname'], node['label'])
2007         else:
2008             label = None
2009 
2010         if node.get('nowrap'):
2011             if label:
2012                 self.body.append(r'\label{%s}' % label)
2013             self.body.append(node.astext())
2014         else:
2015             from sphinx.util.math import wrap_displaymath
2016             self.body.append(wrap_displaymath(node.astext(), label,
2017                                               self.config.math_number_all))
2018         raise nodes.SkipNode
2019 
2020     def visit_math_reference(self, node: Element) -> None:
2021         label = "equation:%s:%s" % (node['docname'], node['target'])
2022         eqref_format = self.config.math_eqref_format
2023         if eqref_format:
2024             try:
2025                 ref = r'\ref{%s}' % label
2026                 self.body.append(eqref_format.format(number=ref))
2027             except KeyError as exc:
2028                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2029                                location=node)
2030                 self.body.append(r'\eqref{%s}' % label)
2031         else:
2032             self.body.append(r'\eqref{%s}' % label)
2033 
2034     def depart_math_reference(self, node: Element) -> None:
2035         pass
2036 
2037     def unknown_visit(self, node: Node) -> None:
2038         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
2039 
2040     @property
2041     def docclasses(self) -> Tuple[str, str]:
2042         """Prepends prefix to sphinx document classes"""
2043         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2044                       RemovedInSphinx70Warning, stacklevel=2)
2045         return ('howto', 'manual')
2046 
2047 
2048 # FIXME: Workaround to avoid circular import
2049 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2050 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2051     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2052 )

</code><intended_behavior>The glossary processing method should maintain compact formatting between terms that share a common description, avoiding excessive vertical whitespace in the LaTeX output. This might involve introducing or modifying spacing controls in the LaTeX commands generated for glossary entries or improving the handling of grouped glossary terms to ensure that the LaTeX output closely mirrors the intended layout specified in the rst document.</intended_behavior>]
2025-10-16 00:18:44.210 | INFO     | Search completed. Bug locations: [<file>sphinx/builders/latex/__init__.py</file>
<class>LaTeXBuilder</class>
<method>None</method>
<code>
106 class LaTeXBuilder(Builder):
107     """
108     Builds LaTeX output to create PDF.
109     """
110     name = 'latex'
111     format = 'latex'
112     epilog = __('The LaTeX files are in %(outdir)s.')
113     if os.name == 'posix':
114         epilog += __("\nRun 'make' in that directory to run these through "
115                      "(pdf)latex\n"
116                      "(use `make latexpdf' here to do that automatically).")
117 
118     supported_image_types = ['application/pdf', 'image/png', 'image/jpeg']
119     supported_remote_images = False
120     default_translator_class = LaTeXTranslator
121 
122     def init(self) -> None:
123         self.babel: ExtBabel = None
124         self.context: Dict[str, Any] = {}
125         self.docnames: Iterable[str] = {}
126         self.document_data: List[Tuple[str, str, str, str, str, bool]] = []
127         self.themes = ThemeFactory(self.app)
128         texescape.init()
129 
130         self.init_context()
131         self.init_babel()
132         self.init_multilingual()
133 
134     def get_outdated_docs(self) -> Union[str, List[str]]:
135         return 'all documents'  # for now
136 
137     def get_target_uri(self, docname: str, typ: str = None) -> str:
138         if docname not in self.docnames:
139             raise NoUri(docname, typ)
140         else:
141             return '%' + docname
142 
143     def get_relative_uri(self, from_: str, to: str, typ: str = None) -> str:
144         # ignore source path
145         return self.get_target_uri(to, typ)
146 
147     def init_document_data(self) -> None:
148         preliminary_document_data = [list(x) for x in self.config.latex_documents]
149         if not preliminary_document_data:
150             logger.warning(__('no "latex_documents" config value found; no documents '
151                               'will be written'))
152             return
153         # assign subdirs to titles
154         self.titles: List[Tuple[str, str]] = []
155         for entry in preliminary_document_data:
156             docname = entry[0]
157             if docname not in self.env.all_docs:
158                 logger.warning(__('"latex_documents" config value references unknown '
159                                   'document %s'), docname)
160                 continue
161             self.document_data.append(entry)  # type: ignore
162             if docname.endswith(SEP + 'index'):
163                 docname = docname[:-5]
164             self.titles.append((docname, entry[2]))
165 
166     def init_context(self) -> None:
167         self.context = DEFAULT_SETTINGS.copy()
168 
169         # Add special settings for latex_engine
170         self.context.update(ADDITIONAL_SETTINGS.get(self.config.latex_engine, {}))
171 
172         # Add special settings for (latex_engine, language_code)
173         if self.config.language:
174             key = (self.config.latex_engine, self.config.language[:2])
175             self.context.update(ADDITIONAL_SETTINGS.get(key, {}))
176 
177         # Apply user settings to context
178         self.context.update(self.config.latex_elements)
179         self.context['release'] = self.config.release
180         self.context['use_xindy'] = self.config.latex_use_xindy
181 
182         if self.config.today:
183             self.context['date'] = self.config.today
184         else:
185             self.context['date'] = format_date(self.config.today_fmt or _('%b %d, %Y'),
186                                                language=self.config.language)
187 
188         if self.config.latex_logo:
189             self.context['logofilename'] = path.basename(self.config.latex_logo)
190 
191         # for compatibilities
192         self.context['indexname'] = _('Index')
193         if self.config.release:
194             # Show the release label only if release value exists
195             self.context.setdefault('releasename', _('Release'))
196 
197     def update_context(self) -> None:
198         """Update template variables for .tex file just before writing."""
199         # Apply extension settings to context
200         registry = self.app.registry
201         self.context['packages'] = registry.latex_packages
202         self.context['packages_after_hyperref'] = registry.latex_packages_after_hyperref
203 
204     def init_babel(self) -> None:
205         self.babel = ExtBabel(self.config.language, not self.context['babel'])
206         if self.config.language and not self.babel.is_supported_language():
207             # emit warning if specified language is invalid
208             # (only emitting, nothing changed to processing)
209             logger.warning(__('no Babel option known for language %r'),
210                            self.config.language)
211 
212     def init_multilingual(self) -> None:
213         if self.context['latex_engine'] == 'pdflatex':
214             if not self.babel.uses_cyrillic():
215                 if 'X2' in self.context['fontenc']:
216                     self.context['substitutefont'] = '\\usepackage{substitutefont}'
217                     self.context['textcyrillic'] = ('\\usepackage[Xtwo]'
218                                                     '{sphinxpackagecyrillic}')
219                 elif 'T2A' in self.context['fontenc']:
220                     self.context['substitutefont'] = '\\usepackage{substitutefont}'
221                     self.context['textcyrillic'] = ('\\usepackage[TtwoA]'
222                                                     '{sphinxpackagecyrillic}')
223             if 'LGR' in self.context['fontenc']:
224                 self.context['substitutefont'] = '\\usepackage{substitutefont}'
225             else:
226                 self.context['textgreek'] = ''
227             if self.context['substitutefont'] == '':
228                 self.context['fontsubstitution'] = ''
229 
230         # 'babel' key is public and user setting must be obeyed
231         if self.context['babel']:
232             self.context['classoptions'] += ',' + self.babel.get_language()
233             # this branch is not taken for xelatex/lualatex if default settings
234             self.context['multilingual'] = self.context['babel']
235             if self.config.language:
236                 self.context['shorthandoff'] = SHORTHANDOFF
237 
238                 # Times fonts don't work with Cyrillic languages
239                 if self.babel.uses_cyrillic() and 'fontpkg' not in self.config.latex_elements:
240                     self.context['fontpkg'] = ''
241         elif self.context['polyglossia']:
242             self.context['classoptions'] += ',' + self.babel.get_language()
243             options = self.babel.get_mainlanguage_options()
244             if options:
245                 language = r'\setmainlanguage[%s]{%s}' % (options, self.babel.get_language())
246             else:
247                 language = r'\setmainlanguage{%s}' % self.babel.get_language()
248 
249             self.context['multilingual'] = '%s\n%s' % (self.context['polyglossia'], language)
250 
251     def write_stylesheet(self) -> None:
252         highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style)
253         stylesheet = path.join(self.outdir, 'sphinxhighlight.sty')
254         with open(stylesheet, 'w') as f:
255             f.write('\\NeedsTeXFormat{LaTeX2e}[1995/12/01]\n')
256             f.write('\\ProvidesPackage{sphinxhighlight}'
257                     '[2016/05/29 stylesheet for highlighting with pygments]\n')
258             f.write('% Its contents depend on pygments_style configuration variable.\n\n')
259             f.write(highlighter.get_stylesheet())
260 
261     def write(self, *ignored: Any) -> None:
262         docwriter = LaTeXWriter(self)
263         docsettings: Any = OptionParser(
264             defaults=self.env.settings,
265             components=(docwriter,),
266             read_config_files=True).get_default_values()
267 
268         self.init_document_data()
269         self.write_stylesheet()
270 
271         for entry in self.document_data:
272             docname, targetname, title, author, themename = entry[:5]
273             theme = self.themes.get(themename)
274             toctree_only = False
275             if len(entry) > 5:
276                 toctree_only = entry[5]
277             destination = SphinxFileOutput(destination_path=path.join(self.outdir, targetname),
278                                            encoding='utf-8', overwrite_if_changed=True)
279             with progress_message(__("processing %s") % targetname):
280                 doctree = self.env.get_doctree(docname)
281                 toctree = next(iter(doctree.traverse(addnodes.toctree)), None)
282                 if toctree and toctree.get('maxdepth') > 0:
283                     tocdepth = toctree.get('maxdepth')
284                 else:
285                     tocdepth = None
286 
287                 doctree = self.assemble_doctree(
288                     docname, toctree_only,
289                     appendices=(self.config.latex_appendices if theme.name != 'howto' else []))
290                 doctree['docclass'] = theme.docclass
291                 doctree['contentsname'] = self.get_contentsname(docname)
292                 doctree['tocdepth'] = tocdepth
293                 self.post_process_images(doctree)
294                 self.update_doc_context(title, author, theme)
295                 self.update_context()
296 
297             with progress_message(__("writing")):
298                 docsettings._author = author
299                 docsettings._title = title
300                 docsettings._contentsname = doctree['contentsname']
301                 docsettings._docname = docname
302                 docsettings._docclass = theme.name
303 
304                 doctree.settings = docsettings
305                 docwriter.theme = theme
306                 docwriter.write(doctree, destination)
307 
308     def get_contentsname(self, indexfile: str) -> str:
309         tree = self.env.get_doctree(indexfile)
310         contentsname = None
311         for toctree in tree.traverse(addnodes.toctree):
312             if 'caption' in toctree:
313                 contentsname = toctree['caption']
314                 break
315 
316         return contentsname
317 
318     def update_doc_context(self, title: str, author: str, theme: Theme) -> None:
319         self.context['title'] = title
320         self.context['author'] = author
321         self.context['docclass'] = theme.docclass
322         self.context['papersize'] = theme.papersize
323         self.context['pointsize'] = theme.pointsize
324         self.context['wrapperclass'] = theme.wrapperclass
325 
326     def assemble_doctree(self, indexfile: str, toctree_only: bool, appendices: List[str]) -> nodes.document:  # NOQA
327         self.docnames = set([indexfile] + appendices)
328         logger.info(darkgreen(indexfile) + " ", nonl=True)
329         tree = self.env.get_doctree(indexfile)
330         tree['docname'] = indexfile
331         if toctree_only:
332             # extract toctree nodes from the tree and put them in a
333             # fresh document
334             new_tree = new_document('<latex output>')
335             new_sect = nodes.section()
336             new_sect += nodes.title('<Set title in conf.py>',
337                                     '<Set title in conf.py>')
338             new_tree += new_sect
339             for node in tree.traverse(addnodes.toctree):
340                 new_sect += node
341             tree = new_tree
342         largetree = inline_all_toctrees(self, self.docnames, indexfile, tree,
343                                         darkgreen, [indexfile])
344         largetree['docname'] = indexfile
345         for docname in appendices:
346             appendix = self.env.get_doctree(docname)
347             appendix['docname'] = docname
348             largetree.append(appendix)
349         logger.info('')
350         logger.info(__("resolving references..."))
351         self.env.resolve_references(largetree, indexfile, self)
352         # resolve :ref:s to distant tex files -- we can't add a cross-reference,
353         # but append the document name
354         for pendingnode in largetree.traverse(addnodes.pending_xref):
355             docname = pendingnode['refdocname']
356             sectname = pendingnode['refsectname']
357             newnodes: List[Node] = [nodes.emphasis(sectname, sectname)]
358             for subdir, title in self.titles:
359                 if docname.startswith(subdir):
360                     newnodes.append(nodes.Text(_(' (in '), _(' (in ')))
361                     newnodes.append(nodes.emphasis(title, title))
362                     newnodes.append(nodes.Text(')', ')'))
363                     break
364             else:
365                 pass
366             pendingnode.replace_self(newnodes)
367         return largetree
368 
369     def finish(self) -> None:
370         self.copy_image_files()
371         self.write_message_catalog()
372         self.copy_support_files()
373 
374         if self.config.latex_additional_files:
375             self.copy_latex_additional_files()
376 
377     @progress_message(__('copying TeX support files'))
378     def copy_support_files(self) -> None:
379         """copy TeX support files from texinputs."""
380         # configure usage of xindy (impacts Makefile and latexmkrc)
381         # FIXME: convert this rather to a confval with suitable default
382         #        according to language ? but would require extra documentation
383         if self.config.language:
384             xindy_lang_option = \
385                 XINDY_LANG_OPTIONS.get(self.config.language[:2],
386                                        '-L general -C utf8 ')
387             xindy_cyrillic = self.config.language[:2] in XINDY_CYRILLIC_SCRIPTS
388         else:
389             xindy_lang_option = '-L english -C utf8 '
390             xindy_cyrillic = False
391         context = {
392             'latex_engine':      self.config.latex_engine,
393             'xindy_use':         self.config.latex_use_xindy,
394             'xindy_lang_option': xindy_lang_option,
395             'xindy_cyrillic':    xindy_cyrillic,
396         }
397         logger.info(bold(__('copying TeX support files...')))
398         staticdirname = path.join(package_dir, 'texinputs')
399         for filename in os.listdir(staticdirname):
400             if not filename.startswith('.'):
401                 copy_asset_file(path.join(staticdirname, filename),
402                                 self.outdir, context=context)
403 
404         # use pre-1.6.x Makefile for make latexpdf on Windows
405         if os.name == 'nt':
406             staticdirname = path.join(package_dir, 'texinputs_win')
407             copy_asset_file(path.join(staticdirname, 'Makefile_t'),
408                             self.outdir, context=context)
409 
410     @progress_message(__('copying additional files'))
411     def copy_latex_additional_files(self) -> None:
412         for filename in self.config.latex_additional_files:
413             logger.info(' ' + filename, nonl=True)
414             copy_asset_file(path.join(self.confdir, filename), self.outdir)
415 
416     def copy_image_files(self) -> None:
417         if self.images:
418             stringify_func = ImageAdapter(self.app.env).get_original_image_uri
419             for src in status_iterator(self.images, __('copying images... '), "brown",
420                                        len(self.images), self.app.verbosity,
421                                        stringify_func=stringify_func):
422                 dest = self.images[src]
423                 try:
424                     copy_asset_file(path.join(self.srcdir, src),
425                                     path.join(self.outdir, dest))
426                 except Exception as err:
427                     logger.warning(__('cannot copy image file %r: %s'),
428                                    path.join(self.srcdir, src), err)
429         if self.config.latex_logo:
430             if not path.isfile(path.join(self.confdir, self.config.latex_logo)):
431                 raise SphinxError(__('logo file %r does not exist') % self.config.latex_logo)
432             else:
433                 copy_asset_file(path.join(self.confdir, self.config.latex_logo), self.outdir)
434 
435     def write_message_catalog(self) -> None:
436         formats = self.config.numfig_format
437         context = {
438             'addtocaptions': r'\@iden',
439             'figurename': formats.get('figure', '').split('%s', 1),
440             'tablename': formats.get('table', '').split('%s', 1),
441             'literalblockname': formats.get('code-block', '').split('%s', 1)
442         }
443 
444         if self.context['babel'] or self.context['polyglossia']:
445             context['addtocaptions'] = r'\addto\captions%s' % self.babel.get_language()
446 
447         filename = path.join(package_dir, 'templates', 'latex', 'sphinxmessages.sty_t')
448         copy_asset_file(filename, self.outdir, context=context, renderer=LaTeXRenderer())

</code><intended_behavior>The method(s) responsible for processing `:samp:` should ensure that separate instances are treated as distinct inline elements, preserving any natural whitespace (including new lines) from the rst source when converting to LaTeX. This might involve adjusting the conversion logic to include newline characters or ensuring that the LaTeX commands generated for these elements do not automatically strip or ignore whitespace that is significant in the source document.</intended_behavior>, <file>sphinx/writers/latex.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.writers.latex
3     ~~~~~~~~~~~~~~~~~~~~
4 
5     Custom docutils writer for LaTeX.
6 
7     Much of this code is adapted from Dave Kuhlman's "docpy" writer from his
8     docutils sandbox.
9 
10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
11     :license: BSD, see LICENSE for details.
12 """
13 
14 import re
15 import warnings
16 from collections import defaultdict
17 from os import path
18 from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Set, Tuple, cast
19 
20 from docutils import nodes, writers
21 from docutils.nodes import Element, Node, Text
22 
23 from sphinx import addnodes, highlighting
24 from sphinx.deprecation import RemovedInSphinx70Warning
25 from sphinx.domains import IndexEntry
26 from sphinx.domains.std import StandardDomain
27 from sphinx.errors import SphinxError
28 from sphinx.locale import _, __, admonitionlabels
29 from sphinx.util import logging, split_into, texescape
30 from sphinx.util.docutils import SphinxTranslator
31 from sphinx.util.nodes import clean_astext, get_prev_node
32 from sphinx.util.template import LaTeXRenderer
33 from sphinx.util.texescape import tex_replace_map
34 
35 try:
36     from docutils.utils.roman import toRoman
37 except ImportError:
38     # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman
39     from roman import toRoman  # type: ignore
40 
41 if TYPE_CHECKING:
42     from sphinx.builders.latex import LaTeXBuilder
43     from sphinx.builders.latex.theming import Theme
44 
45 
46 logger = logging.getLogger(__name__)
47 
48 MAX_CITATION_LABEL_LENGTH = 8
49 LATEXSECTIONNAMES = ["part", "chapter", "section", "subsection",
50                      "subsubsection", "paragraph", "subparagraph"]
51 ENUMERATE_LIST_STYLE = defaultdict(lambda: r'\arabic',
52                                    {
53                                        'arabic': r'\arabic',
54                                        'loweralpha': r'\alph',
55                                        'upperalpha': r'\Alph',
56                                        'lowerroman': r'\roman',
57                                        'upperroman': r'\Roman',
58                                    })
59 
60 CR = '\n'
61 BLANKLINE = '\n\n'
62 EXTRA_RE = re.compile(r'^(.*\S)\s+\(([^()]*)\)\s*$')
63 
64 
65 class collected_footnote(nodes.footnote):
66     """Footnotes that are collected are assigned this class."""
67 
68 
69 class UnsupportedError(SphinxError):
70     category = 'Markup is unsupported in LaTeX'
71 
72 
73 class LaTeXWriter(writers.Writer):
74 
75     supported = ('sphinxlatex',)
76 
77     settings_spec = ('LaTeX writer options', '', (
78         ('Document name', ['--docname'], {'default': ''}),
79         ('Document class', ['--docclass'], {'default': 'manual'}),
80         ('Author', ['--author'], {'default': ''}),
81     ))
82     settings_defaults: Dict = {}
83 
84     output = None
85 
86     def __init__(self, builder: "LaTeXBuilder") -> None:
87         super().__init__()
88         self.builder = builder
89         self.theme: Theme = None
90 
91     def translate(self) -> None:
92         visitor = self.builder.create_translator(self.document, self.builder, self.theme)
93         self.document.walkabout(visitor)
94         self.output = cast(LaTeXTranslator, visitor).astext()
95 
96 
97 # Helper classes
98 
99 class Table:
100     """A table data"""
101 
102     def __init__(self, node: Element) -> None:
103         self.header: List[str] = []
104         self.body: List[str] = []
105         self.align = node.get('align', 'default')
106         self.classes: List[str] = node.get('classes', [])
107         self.colcount = 0
108         self.colspec: str = None
109         self.colwidths: List[int] = []
110         self.has_problematic = False
111         self.has_oldproblematic = False
112         self.has_verbatim = False
113         self.caption: List[str] = None
114         self.stubs: List[int] = []
115 
116         # current position
117         self.col = 0
118         self.row = 0
119 
120         # A dict mapping a table location to a cell_id (cell = rectangular area)
121         self.cells: Dict[Tuple[int, int], int] = defaultdict(int)
122         self.cell_id = 0  # last assigned cell_id
123 
124     def is_longtable(self) -> bool:
125         """True if and only if table uses longtable environment."""
126         return self.row > 30 or 'longtable' in self.classes
127 
128     def get_table_type(self) -> str:
129         """Returns the LaTeX environment name for the table.
130 
131         The class currently supports:
132 
133         * longtable
134         * tabular
135         * tabulary
136         """
137         if self.is_longtable():
138             return 'longtable'
139         elif self.has_verbatim:
140             return 'tabular'
141         elif self.colspec:
142             return 'tabulary'
143         elif self.has_problematic or (self.colwidths and 'colwidths-given' in self.classes):
144             return 'tabular'
145         else:
146             return 'tabulary'
147 
148     def get_colspec(self) -> str:
149         """Returns a column spec of table.
150 
151         This is what LaTeX calls the 'preamble argument' of the used table environment.
152 
153         .. note:: the ``\\X`` and ``T`` column type specifiers are defined in ``sphinx.sty``.
154         """
155         if self.colspec:
156             return self.colspec
157         elif self.colwidths and 'colwidths-given' in self.classes:
158             total = sum(self.colwidths)
159             colspecs = [r'\X{%d}{%d}' % (width, total) for width in self.colwidths]
160             return '{|%s|}' % '|'.join(colspecs) + CR
161         elif self.has_problematic:
162             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
163         elif self.get_table_type() == 'tabulary':
164             # sphinx.sty sets T to be J by default.
165             return '{|' + ('T|' * self.colcount) + '}' + CR
166         elif self.has_oldproblematic:
167             return r'{|*{%d}{\X{1}{%d}|}}' % (self.colcount, self.colcount) + CR
168         else:
169             return '{|' + ('l|' * self.colcount) + '}' + CR
170 
171     def add_cell(self, height: int, width: int) -> None:
172         """Adds a new cell to a table.
173 
174         It will be located at current position: (``self.row``, ``self.col``).
175         """
176         self.cell_id += 1
177         for col in range(width):
178             for row in range(height):
179                 assert self.cells[(self.row + row, self.col + col)] == 0
180                 self.cells[(self.row + row, self.col + col)] = self.cell_id
181 
182     def cell(self, row: int = None, col: int = None) -> "TableCell":
183         """Returns a cell object (i.e. rectangular area) containing given position.
184 
185         If no option arguments: ``row`` or ``col`` are given, the current position;
186         ``self.row`` and ``self.col`` are used to get a cell object by default.
187         """
188         try:
189             if row is None:
190                 row = self.row
191             if col is None:
192                 col = self.col
193             return TableCell(self, row, col)
194         except IndexError:
195             return None
196 
197 
198 class TableCell:
199     """Data of a cell in a table."""
200 
201     def __init__(self, table: Table, row: int, col: int) -> None:
202         if table.cells[(row, col)] == 0:
203             raise IndexError
204 
205         self.table = table
206         self.cell_id = table.cells[(row, col)]
207         self.row = row
208         self.col = col
209 
210         # adjust position for multirow/multicol cell
211         while table.cells[(self.row - 1, self.col)] == self.cell_id:
212             self.row -= 1
213         while table.cells[(self.row, self.col - 1)] == self.cell_id:
214             self.col -= 1
215 
216     @property
217     def width(self) -> int:
218         """Returns the cell width."""
219         width = 0
220         while self.table.cells[(self.row, self.col + width)] == self.cell_id:
221             width += 1
222         return width
223 
224     @property
225     def height(self) -> int:
226         """Returns the cell height."""
227         height = 0
228         while self.table.cells[(self.row + height, self.col)] == self.cell_id:
229             height += 1
230         return height
231 
232 
233 def escape_abbr(text: str) -> str:
234     """Adjust spacing after abbreviations."""
235     return re.sub(r'\.(?=\s|$)', r'.\@', text)
236 
237 
238 def rstdim_to_latexdim(width_str: str, scale: int = 100) -> str:
239     """Convert `width_str` with rst length to LaTeX length."""
240     match = re.match(r'^(\d*\.?\d*)\s*(\S*)$', width_str)
241     if not match:
242         raise ValueError
243     res = width_str
244     amount, unit = match.groups()[:2]
245     if scale == 100:
246         float(amount)  # validate amount is float
247         if unit in ('', "px"):
248             res = r"%s\sphinxpxdimen" % amount
249         elif unit == 'pt':
250             res = '%sbp' % amount  # convert to 'bp'
251         elif unit == "%":
252             res = r"%.3f\linewidth" % (float(amount) / 100.0)
253     else:
254         amount_float = float(amount) * scale / 100.0
255         if unit in ('', "px"):
256             res = r"%.5f\sphinxpxdimen" % amount_float
257         elif unit == 'pt':
258             res = '%.5fbp' % amount_float
259         elif unit == "%":
260             res = r"%.5f\linewidth" % (amount_float / 100.0)
261         else:
262             res = "%.5f%s" % (amount_float, unit)
263     return res
264 
265 
266 class LaTeXTranslator(SphinxTranslator):
267     builder: "LaTeXBuilder" = None
268 
269     secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls
270     # default is originally 3. For book/report, 2 is already LaTeX default.
271     ignore_missing_images = False
272 
273     def __init__(self, document: nodes.document, builder: "LaTeXBuilder",
274                  theme: "Theme") -> None:
275         super().__init__(document, builder)
276         self.body: List[str] = []
277         self.theme = theme
278 
279         # flags
280         self.in_title = 0
281         self.in_production_list = 0
282         self.in_footnote = 0
283         self.in_caption = 0
284         self.in_term = 0
285         self.needs_linetrimming = 0
286         self.in_minipage = 0
287         self.no_latex_floats = 0
288         self.first_document = 1
289         self.this_is_the_title = 1
290         self.literal_whitespace = 0
291         self.in_parsed_literal = 0
292         self.compact_list = 0
293         self.first_param = 0
294 
295         sphinxpkgoptions = []
296 
297         # sort out some elements
298         self.elements = self.builder.context.copy()
299 
300         # initial section names
301         self.sectionnames = LATEXSECTIONNAMES[:]
302         if self.theme.toplevel_sectioning == 'section':
303             self.sectionnames.remove('chapter')
304 
305         # determine top section level
306         self.top_sectionlevel = 1
307         if self.config.latex_toplevel_sectioning:
308             try:
309                 self.top_sectionlevel = \
310                     self.sectionnames.index(self.config.latex_toplevel_sectioning)
311             except ValueError:
312                 logger.warning(__('unknown %r toplevel_sectioning for class %r') %
313                                (self.config.latex_toplevel_sectioning, self.theme.docclass))
314 
315         if self.config.numfig:
316             self.numfig_secnum_depth = self.config.numfig_secnum_depth
317             if self.numfig_secnum_depth > 0:  # default is 1
318                 # numfig_secnum_depth as passed to sphinx.sty indices same names as in
319                 # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...
320                 if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
321                    self.top_sectionlevel > 0:
322                     self.numfig_secnum_depth += self.top_sectionlevel
323                 else:
324                     self.numfig_secnum_depth += self.top_sectionlevel - 1
325                 # this (minus one) will serve as minimum to LaTeX's secnumdepth
326                 self.numfig_secnum_depth = min(self.numfig_secnum_depth,
327                                                len(LATEXSECTIONNAMES) - 1)
328                 # if passed key value is < 1 LaTeX will act as if 0; see sphinx.sty
329                 sphinxpkgoptions.append('numfigreset=%s' % self.numfig_secnum_depth)
330             else:
331                 sphinxpkgoptions.append('nonumfigreset')
332 
333         if self.config.numfig and self.config.math_numfig:
334             sphinxpkgoptions.append('mathnumfig')
335 
336         if (self.config.language not in {None, 'en', 'ja'} and
337                 'fncychap' not in self.config.latex_elements):
338             # use Sonny style if any language specified (except English)
339             self.elements['fncychap'] = (r'\usepackage[Sonny]{fncychap}' + CR +
340                                          r'\ChNameVar{\Large\normalfont\sffamily}' + CR +
341                                          r'\ChTitleVar{\Large\normalfont\sffamily}')
342 
343         self.babel = self.builder.babel
344         if self.config.language and not self.babel.is_supported_language():
345             # emit warning if specified language is invalid
346             # (only emitting, nothing changed to processing)
347             logger.warning(__('no Babel option known for language %r'),
348                            self.config.language)
349 
350         minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto
351         if self.document.get('tocdepth'):
352             # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel
353             #   tocdepth = -1: show only parts
354             #   tocdepth =  0: show parts and chapters
355             #   tocdepth =  1: show parts, chapters and sections
356             #   tocdepth =  2: show parts, chapters, sections and subsections
357             #   ...
358             tocdepth = self.document.get('tocdepth', 999) + self.top_sectionlevel - 2
359             if len(self.sectionnames) < len(LATEXSECTIONNAMES) and \
360                self.top_sectionlevel > 0:
361                 tocdepth += 1  # because top_sectionlevel is shifted by -1
362             if tocdepth > len(LATEXSECTIONNAMES) - 2:  # default is 5 <-> subparagraph
363                 logger.warning(__('too large :maxdepth:, ignored.'))
364                 tocdepth = len(LATEXSECTIONNAMES) - 2
365 
366             self.elements['tocdepth'] = r'\setcounter{tocdepth}{%d}' % tocdepth
367             minsecnumdepth = max(minsecnumdepth, tocdepth)
368 
369         if self.config.numfig and (self.config.numfig_secnum_depth > 0):
370             minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
371 
372         if minsecnumdepth > self.secnumdepth:
373             self.elements['secnumdepth'] = r'\setcounter{secnumdepth}{%d}' %\
374                                            minsecnumdepth
375 
376         contentsname = document.get('contentsname')
377         if contentsname:
378             self.elements['contentsname'] = self.babel_renewcommand(r'\contentsname',
379                                                                     contentsname)
380 
381         if self.elements['maxlistdepth']:
382             sphinxpkgoptions.append('maxlistdepth=%s' % self.elements['maxlistdepth'])
383         if sphinxpkgoptions:
384             self.elements['sphinxpkgoptions'] = '[,%s]' % ','.join(sphinxpkgoptions)
385         if self.elements['sphinxsetup']:
386             self.elements['sphinxsetup'] = (r'\sphinxsetup{%s}' % self.elements['sphinxsetup'])
387         if self.elements['extraclassoptions']:
388             self.elements['classoptions'] += ',' + \
389                                              self.elements['extraclassoptions']
390 
391         self.highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style,
392                                                        latex_engine=self.config.latex_engine)
393         self.context: List[Any] = []
394         self.descstack: List[str] = []
395         self.tables: List[Table] = []
396         self.next_table_colspec: str = None
397         self.bodystack: List[List[str]] = []
398         self.footnote_restricted: Element = None
399         self.pending_footnotes: List[nodes.footnote_reference] = []
400         self.curfilestack: List[str] = []
401         self.handled_abbrs: Set[str] = set()
402 
403     def pushbody(self, newbody: List[str]) -> None:
404         self.bodystack.append(self.body)
405         self.body = newbody
406 
407     def popbody(self) -> List[str]:
408         body = self.body
409         self.body = self.bodystack.pop()
410         return body
411 
412     def astext(self) -> str:
413         self.elements.update({
414             'body': ''.join(self.body),
415             'indices': self.generate_indices()
416         })
417         return self.render('latex.tex_t', self.elements)
418 
419     def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -> str:
420         if withdoc:
421             id = self.curfilestack[-1] + ':' + id
422         return (r'\phantomsection' if anchor else '') + r'\label{%s}' % self.idescape(id)
423 
424     def hypertarget_to(self, node: Element, anchor: bool = False) -> str:
425         labels = ''.join(self.hypertarget(node_id, anchor=False) for node_id in node['ids'])
426         if anchor:
427             return r'\phantomsection' + labels
428         else:
429             return labels
430 
431     def hyperlink(self, id: str) -> str:
432         return r'{\hyperref[%s]{' % self.idescape(id)
433 
434     def hyperpageref(self, id: str) -> str:
435         return r'\autopageref*{%s}' % self.idescape(id)
436 
437     def escape(self, s: str) -> str:
438         return texescape.escape(s, self.config.latex_engine)
439 
440     def idescape(self, id: str) -> str:
441         return r'\detokenize{%s}' % str(id).translate(tex_replace_map).\
442             encode('ascii', 'backslashreplace').decode('ascii').\
443             replace('\\', '_')
444 
445     def babel_renewcommand(self, command: str, definition: str) -> str:
446         if self.elements['multilingual']:
447             prefix = r'\addto\captions%s{' % self.babel.get_language()
448             suffix = '}'
449         else:  # babel is disabled (mainly for Japanese environment)
450             prefix = ''
451             suffix = ''
452 
453         return r'%s\renewcommand{%s}{%s}%s' % (prefix, command, definition, suffix) + CR
454 
455     def generate_indices(self) -> str:
456         def generate(content: List[Tuple[str, List[IndexEntry]]], collapsed: bool) -> None:
457             ret.append(r'\begin{sphinxtheindex}' + CR)
458             ret.append(r'\let\bigletter\sphinxstyleindexlettergroup' + CR)
459             for i, (letter, entries) in enumerate(content):
460                 if i > 0:
461                     ret.append(r'\indexspace' + CR)
462                 ret.append(r'\bigletter{%s}' % self.escape(letter) + CR)
463                 for entry in entries:
464                     if not entry[3]:
465                         continue
466                     ret.append(r'\item\relax\sphinxstyleindexentry{%s}' %
467                                self.encode(entry[0]))
468                     if entry[4]:
469                         # add "extra" info
470                         ret.append(r'\sphinxstyleindexextra{%s}' % self.encode(entry[4]))
471                     ret.append(r'\sphinxstyleindexpageref{%s:%s}' %
472                                (entry[2], self.idescape(entry[3])) + CR)
473             ret.append(r'\end{sphinxtheindex}' + CR)
474 
475         ret = []
476         # latex_domain_indices can be False/True or a list of index names
477         indices_config = self.config.latex_domain_indices
478         if indices_config:
479             for domain in self.builder.env.domains.values():
480                 for indexcls in domain.indices:
481                     indexname = '%s-%s' % (domain.name, indexcls.name)
482                     if isinstance(indices_config, list):
483                         if indexname not in indices_config:
484                             continue
485                     content, collapsed = indexcls(domain).generate(
486                         self.builder.docnames)
487                     if not content:
488                         continue
489                     ret.append(r'\renewcommand{\indexname}{%s}' % indexcls.localname + CR)
490                     generate(content, collapsed)
491 
492         return ''.join(ret)
493 
494     def render(self, template_name: str, variables: Dict) -> str:
495         renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)
496         for template_dir in self.config.templates_path:
497             template = path.join(self.builder.confdir, template_dir,
498                                  template_name)
499             if path.exists(template):
500                 return renderer.render(template, variables)
501 
502         return renderer.render(template_name, variables)
503 
504     @property
505     def table(self) -> Table:
506         """Get current table."""
507         if self.tables:
508             return self.tables[-1]
509         else:
510             return None
511 
512     def visit_document(self, node: Element) -> None:
513         self.curfilestack.append(node.get('docname', ''))
514         if self.first_document == 1:
515             # the first document is all the regular content ...
516             self.first_document = 0
517         elif self.first_document == 0:
518             # ... and all others are the appendices
519             self.body.append(CR + r'\appendix' + CR)
520             self.first_document = -1
521         if 'docname' in node:
522             self.body.append(self.hypertarget(':doc'))
523         # "- 1" because the level is increased before the title is visited
524         self.sectionlevel = self.top_sectionlevel - 1
525 
526     def depart_document(self, node: Element) -> None:
527         pass
528 
529     def visit_start_of_file(self, node: Element) -> None:
530         self.curfilestack.append(node['docname'])
531 
532     def depart_start_of_file(self, node: Element) -> None:
533         self.curfilestack.pop()
534 
535     def visit_section(self, node: Element) -> None:
536         if not self.this_is_the_title:
537             self.sectionlevel += 1
538         self.body.append(BLANKLINE)
539 
540     def depart_section(self, node: Element) -> None:
541         self.sectionlevel = max(self.sectionlevel - 1,
542                                 self.top_sectionlevel - 1)
543 
544     def visit_problematic(self, node: Element) -> None:
545         self.body.append(r'{\color{red}\bfseries{}')
546 
547     def depart_problematic(self, node: Element) -> None:
548         self.body.append('}')
549 
550     def visit_topic(self, node: Element) -> None:
551         self.in_minipage = 1
552         self.body.append(CR + r'\begin{sphinxShadowBox}' + CR)
553 
554     def depart_topic(self, node: Element) -> None:
555         self.in_minipage = 0
556         self.body.append(r'\end{sphinxShadowBox}' + CR)
557     visit_sidebar = visit_topic
558     depart_sidebar = depart_topic
559 
560     def visit_glossary(self, node: Element) -> None:
561         pass
562 
563     def depart_glossary(self, node: Element) -> None:
564         pass
565 
566     def visit_productionlist(self, node: Element) -> None:
567         self.body.append(BLANKLINE)
568         self.body.append(r'\begin{productionlist}' + CR)
569         self.in_production_list = 1
570 
571     def depart_productionlist(self, node: Element) -> None:
572         self.body.append(r'\end{productionlist}' + BLANKLINE)
573         self.in_production_list = 0
574 
575     def visit_production(self, node: Element) -> None:
576         if node['tokenname']:
577             tn = node['tokenname']
578             self.body.append(self.hypertarget('grammar-token-' + tn))
579             self.body.append(r'\production{%s}{' % self.encode(tn))
580         else:
581             self.body.append(r'\productioncont{')
582 
583     def depart_production(self, node: Element) -> None:
584         self.body.append('}' + CR)
585 
586     def visit_transition(self, node: Element) -> None:
587         self.body.append(self.elements['transition'])
588 
589     def depart_transition(self, node: Element) -> None:
590         pass
591 
592     def visit_title(self, node: Element) -> None:
593         parent = node.parent
594         if isinstance(parent, addnodes.seealso):
595             # the environment already handles this
596             raise nodes.SkipNode
597         elif isinstance(parent, nodes.section):
598             if self.this_is_the_title:
599                 if len(node.children) != 1 and not isinstance(node.children[0],
600                                                               nodes.Text):
601                     logger.warning(__('document title is not a single Text node'),
602                                    location=node)
603                 if not self.elements['title']:
604                     # text needs to be escaped since it is inserted into
605                     # the output literally
606                     self.elements['title'] = self.escape(node.astext())
607                 self.this_is_the_title = 0
608                 raise nodes.SkipNode
609             else:
610                 short = ''
611                 if list(node.traverse(nodes.image)):
612                     short = ('[%s]' % self.escape(' '.join(clean_astext(node).split())))
613 
614                 try:
615                     self.body.append(r'\%s%s{' % (self.sectionnames[self.sectionlevel], short))
616                 except IndexError:
617                     # just use "subparagraph", it's not numbered anyway
618                     self.body.append(r'\%s%s{' % (self.sectionnames[-1], short))
619                 self.context.append('}' + CR + self.hypertarget_to(node.parent))
620         elif isinstance(parent, nodes.topic):
621             self.body.append(r'\sphinxstyletopictitle{')
622             self.context.append('}' + CR)
623         elif isinstance(parent, nodes.sidebar):
624             self.body.append(r'\sphinxstylesidebartitle{')
625             self.context.append('}' + CR)
626         elif isinstance(parent, nodes.Admonition):
627             self.body.append('{')
628             self.context.append('}' + CR)
629         elif isinstance(parent, nodes.table):
630             # Redirect body output until title is finished.
631             self.pushbody([])
632         else:
633             logger.warning(__('encountered title node not in section, topic, table, '
634                               'admonition or sidebar'),
635                            location=node)
636             self.body.append(r'\sphinxstyleothertitle{')
637             self.context.append('}' + CR)
638         self.in_title = 1
639 
640     def depart_title(self, node: Element) -> None:
641         self.in_title = 0
642         if isinstance(node.parent, nodes.table):
643             self.table.caption = self.popbody()
644         else:
645             self.body.append(self.context.pop())
646 
647     def visit_subtitle(self, node: Element) -> None:
648         if isinstance(node.parent, nodes.sidebar):
649             self.body.append(r'\sphinxstylesidebarsubtitle{')
650             self.context.append('}' + CR)
651         else:
652             self.context.append('')
653 
654     def depart_subtitle(self, node: Element) -> None:
655         self.body.append(self.context.pop())
656 
657     #############################################################
658     # Domain-specific object descriptions
659     #############################################################
660 
661     # Top-level nodes for descriptions
662     ##################################
663 
664     def visit_desc(self, node: Element) -> None:
665         if self.config.latex_show_urls == 'footnote':
666             self.body.append(BLANKLINE)
667             self.body.append(r'\begin{savenotes}\begin{fulllineitems}' + CR)
668         else:
669             self.body.append(BLANKLINE)
670             self.body.append(r'\begin{fulllineitems}' + CR)
671         if self.table:
672             self.table.has_problematic = True
673 
674     def depart_desc(self, node: Element) -> None:
675         if self.config.latex_show_urls == 'footnote':
676             self.body.append(CR + r'\end{fulllineitems}\end{savenotes}' + BLANKLINE)
677         else:
678             self.body.append(CR + r'\end{fulllineitems}' + BLANKLINE)
679 
680     def _visit_signature_line(self, node: Element) -> None:
681         for child in node:
682             if isinstance(child, addnodes.desc_parameterlist):
683                 self.body.append(r'\pysiglinewithargsret{')
684                 break
685         else:
686             self.body.append(r'\pysigline{')
687 
688     def _depart_signature_line(self, node: Element) -> None:
689         self.body.append('}')
690 
691     def visit_desc_signature(self, node: Element) -> None:
692         if node.parent['objtype'] != 'describe' and node['ids']:
693             hyper = self.hypertarget(node['ids'][0])
694         else:
695             hyper = ''
696         self.body.append(hyper)
697         if not node.get('is_multiline'):
698             self._visit_signature_line(node)
699         else:
700             self.body.append('%' + CR)
701             self.body.append(r'\pysigstartmultiline' + CR)
702 
703     def depart_desc_signature(self, node: Element) -> None:
704         if not node.get('is_multiline'):
705             self._depart_signature_line(node)
706         else:
707             self.body.append('%' + CR)
708             self.body.append(r'\pysigstopmultiline')
709 
710     def visit_desc_signature_line(self, node: Element) -> None:
711         self._visit_signature_line(node)
712 
713     def depart_desc_signature_line(self, node: Element) -> None:
714         self._depart_signature_line(node)
715 
716     def visit_desc_content(self, node: Element) -> None:
717         pass
718 
719     def depart_desc_content(self, node: Element) -> None:
720         pass
721 
722     def visit_desc_inline(self, node: Element) -> None:
723         self.body.append(r'\sphinxcode{\sphinxupquote{')
724 
725     def depart_desc_inline(self, node: Element) -> None:
726         self.body.append('}}')
727 
728     # Nodes for high-level structure in signatures
729     ##############################################
730 
731     def visit_desc_name(self, node: Element) -> None:
732         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
733         self.literal_whitespace += 1
734 
735     def depart_desc_name(self, node: Element) -> None:
736         self.body.append('}}')
737         self.literal_whitespace -= 1
738 
739     def visit_desc_addname(self, node: Element) -> None:
740         self.body.append(r'\sphinxcode{\sphinxupquote{')
741         self.literal_whitespace += 1
742 
743     def depart_desc_addname(self, node: Element) -> None:
744         self.body.append('}}')
745         self.literal_whitespace -= 1
746 
747     def visit_desc_type(self, node: Element) -> None:
748         pass
749 
750     def depart_desc_type(self, node: Element) -> None:
751         pass
752 
753     def visit_desc_returns(self, node: Element) -> None:
754         self.body.append(r'{ $\rightarrow$ ')
755 
756     def depart_desc_returns(self, node: Element) -> None:
757         self.body.append(r'}')
758 
759     def visit_desc_parameterlist(self, node: Element) -> None:
760         # close name, open parameterlist
761         self.body.append('}{')
762         self.first_param = 1
763 
764     def depart_desc_parameterlist(self, node: Element) -> None:
765         # close parameterlist, open return annotation
766         self.body.append('}{')
767 
768     def visit_desc_parameter(self, node: Element) -> None:
769         if not self.first_param:
770             self.body.append(', ')
771         else:
772             self.first_param = 0
773         if not node.hasattr('noemph'):
774             self.body.append(r'\emph{')
775 
776     def depart_desc_parameter(self, node: Element) -> None:
777         if not node.hasattr('noemph'):
778             self.body.append('}')
779 
780     def visit_desc_optional(self, node: Element) -> None:
781         self.body.append(r'\sphinxoptional{')
782 
783     def depart_desc_optional(self, node: Element) -> None:
784         self.body.append('}')
785 
786     def visit_desc_annotation(self, node: Element) -> None:
787         self.body.append(r'\sphinxbfcode{\sphinxupquote{')
788 
789     def depart_desc_annotation(self, node: Element) -> None:
790         self.body.append('}}')
791 
792     ##############################################
793 
794     def visit_seealso(self, node: Element) -> None:
795         self.body.append(BLANKLINE)
796         self.body.append(r'\sphinxstrong{%s:}' % admonitionlabels['seealso'] + CR)
797         self.body.append(r'\nopagebreak' + BLANKLINE)
798 
799     def depart_seealso(self, node: Element) -> None:
800         self.body.append(BLANKLINE)
801 
802     def visit_rubric(self, node: Element) -> None:
803         if len(node) == 1 and node.astext() in ('Footnotes', _('Footnotes')):
804             raise nodes.SkipNode
805         self.body.append(r'\subsubsection*{')
806         self.context.append('}' + CR)
807         self.in_title = 1
808 
809     def depart_rubric(self, node: Element) -> None:
810         self.in_title = 0
811         self.body.append(self.context.pop())
812 
813     def visit_footnote(self, node: Element) -> None:
814         self.in_footnote += 1
815         label = cast(nodes.label, node[0])
816         if 'auto' not in node:
817             self.body.append(r'\sphinxstepexplicit ')
818         if self.in_parsed_literal:
819             self.body.append(r'\begin{footnote}[%s]' % label.astext())
820         else:
821             self.body.append('%' + CR)
822             self.body.append(r'\begin{footnote}[%s]' % label.astext())
823         if 'auto' not in node:
824             self.body.append(r'\phantomsection'
825                              r'\label{\thesphinxscope.%s}%%' % label.astext() + CR)
826         self.body.append(r'\sphinxAtStartFootnote' + CR)
827 
828     def depart_footnote(self, node: Element) -> None:
829         if self.in_parsed_literal:
830             self.body.append(r'\end{footnote}')
831         else:
832             self.body.append('%' + CR)
833             self.body.append(r'\end{footnote}')
834         self.in_footnote -= 1
835 
836     def visit_label(self, node: Element) -> None:
837         raise nodes.SkipNode
838 
839     def visit_tabular_col_spec(self, node: Element) -> None:
840         self.next_table_colspec = node['spec']
841         raise nodes.SkipNode
842 
843     def visit_table(self, node: Element) -> None:
844         if len(self.tables) == 1:
845             if self.table.get_table_type() == 'longtable':
846                 raise UnsupportedError(
847                     '%s:%s: longtable does not support nesting a table.' %
848                     (self.curfilestack[-1], node.line or ''))
849             else:
850                 # change type of parent table to tabular
851                 # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ
852                 self.table.has_problematic = True
853         elif len(self.tables) > 2:
854             raise UnsupportedError(
855                 '%s:%s: deeply nested tables are not implemented.' %
856                 (self.curfilestack[-1], node.line or ''))
857 
858         self.tables.append(Table(node))
859         if self.next_table_colspec:
860             self.table.colspec = '{%s}' % self.next_table_colspec + CR
861             if 'colwidths-given' in node.get('classes', []):
862                 logger.info(__('both tabularcolumns and :widths: option are given. '
863                                ':widths: is ignored.'), location=node)
864         self.next_table_colspec = None
865 
866     def depart_table(self, node: Element) -> None:
867         labels = self.hypertarget_to(node)
868         table_type = self.table.get_table_type()
869         table = self.render(table_type + '.tex_t',
870                             dict(table=self.table, labels=labels))
871         self.body.append(BLANKLINE)
872         self.body.append(table)
873         self.body.append(CR)
874 
875         self.tables.pop()
876 
877     def visit_colspec(self, node: Element) -> None:
878         self.table.colcount += 1
879         if 'colwidth' in node:
880             self.table.colwidths.append(node['colwidth'])
881         if 'stub' in node:
882             self.table.stubs.append(self.table.colcount - 1)
883 
884     def depart_colspec(self, node: Element) -> None:
885         pass
886 
887     def visit_tgroup(self, node: Element) -> None:
888         pass
889 
890     def depart_tgroup(self, node: Element) -> None:
891         pass
892 
893     def visit_thead(self, node: Element) -> None:
894         # Redirect head output until header is finished.
895         self.pushbody(self.table.header)
896 
897     def depart_thead(self, node: Element) -> None:
898         self.popbody()
899 
900     def visit_tbody(self, node: Element) -> None:
901         # Redirect body output until table is finished.
902         self.pushbody(self.table.body)
903 
904     def depart_tbody(self, node: Element) -> None:
905         self.popbody()
906 
907     def visit_row(self, node: Element) -> None:
908         self.table.col = 0
909 
910         # fill columns if the row starts with the bottom of multirow cell
911         while True:
912             cell = self.table.cell(self.table.row, self.table.col)
913             if cell is None:  # not a bottom of multirow cell
914                 break
915             else:  # a bottom of multirow cell
916                 self.table.col += cell.width
917                 if cell.col:
918                     self.body.append('&')
919                 if cell.width == 1:
920                     # insert suitable strut for equalizing row heights in given multirow
921                     self.body.append(r'\sphinxtablestrut{%d}' % cell.cell_id)
922                 else:  # use \multicolumn for wide multirow cell
923                     self.body.append(r'\multicolumn{%d}{|l|}{\sphinxtablestrut{%d}}' %
924                                      (cell.width, cell.cell_id))
925 
926     def depart_row(self, node: Element) -> None:
927         self.body.append(r'\\' + CR)
928         cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]
929         underlined = [cell.row + cell.height == self.table.row + 1 for cell in cells]
930         if all(underlined):
931             self.body.append(r'\hline')
932         else:
933             i = 0
934             underlined.extend([False])  # sentinel
935             while i < len(underlined):
936                 if underlined[i] is True:
937                     j = underlined[i:].index(False)
938                     self.body.append(r'\cline{%d-%d}' % (i + 1, i + j))
939                     i += j
940                 i += 1
941         self.table.row += 1
942 
943     def visit_entry(self, node: Element) -> None:
944         if self.table.col > 0:
945             self.body.append('&')
946         self.table.add_cell(node.get('morerows', 0) + 1, node.get('morecols', 0) + 1)
947         cell = self.table.cell()
948         context = ''
949         if cell.width > 1:
950             if self.config.latex_use_latex_multicolumn:
951                 if self.table.col == 0:
952                     self.body.append(r'\multicolumn{%d}{|l|}{%%' % cell.width + CR)
953                 else:
954                     self.body.append(r'\multicolumn{%d}{l|}{%%' % cell.width + CR)
955                 context = '}%' + CR
956             else:
957                 self.body.append(r'\sphinxstartmulticolumn{%d}%%' % cell.width + CR)
958                 context = r'\sphinxstopmulticolumn' + CR
959         if cell.height > 1:
960             # \sphinxmultirow 2nd arg "cell_id" will serve as id for LaTeX macros as well
961             self.body.append(r'\sphinxmultirow{%d}{%d}{%%' % (cell.height, cell.cell_id) + CR)
962             context = '}%' + CR + context
963         if cell.width > 1 or cell.height > 1:
964             self.body.append(r'\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}'
965                              % (cell.width, self.table.colcount) + CR)
966             context = (r'\par' + CR + r'\vskip-\baselineskip'
967                        r'\vbox{\hbox{\strut}}\end{varwidth}%' + CR + context)
968             self.needs_linetrimming = 1
969         if len(list(node.traverse(nodes.paragraph))) >= 2:
970             self.table.has_oldproblematic = True
971         if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):
972             if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == '':
973                 pass
974             else:
975                 self.body.append(r'\sphinxstyletheadfamily ')
976         if self.needs_linetrimming:
977             self.pushbody([])
978         self.context.append(context)
979 
980     def depart_entry(self, node: Element) -> None:
981         if self.needs_linetrimming:
982             self.needs_linetrimming = 0
983             body = self.popbody()
984 
985             # Remove empty lines from top of merged cell
986             while body and body[0] == CR:
987                 body.pop(0)
988             self.body.extend(body)
989 
990         self.body.append(self.context.pop())
991 
992         cell = self.table.cell()
993         self.table.col += cell.width
994 
995         # fill columns if next ones are a bottom of wide-multirow cell
996         while True:
997             nextcell = self.table.cell()
998             if nextcell is None:  # not a bottom of multirow cell
999                 break
1000             else:  # a bottom part of multirow cell
1001                 self.table.col += nextcell.width
1002                 self.body.append('&')
1003                 if nextcell.width == 1:
1004                     # insert suitable strut for equalizing row heights in multirow
1005                     # they also serve to clear colour panels which would hide the text
1006                     self.body.append(r'\sphinxtablestrut{%d}' % nextcell.cell_id)
1007                 else:
1008                     # use \multicolumn for wide multirow cell
1009                     self.body.append(r'\multicolumn{%d}{l|}{\sphinxtablestrut{%d}}' %
1010                                      (nextcell.width, nextcell.cell_id))
1011 
1012     def visit_acks(self, node: Element) -> None:
1013         # this is a list in the source, but should be rendered as a
1014         # comma-separated list here
1015         bullet_list = cast(nodes.bullet_list, node[0])
1016         list_items = cast(Iterable[nodes.list_item], bullet_list)
1017         self.body.append(BLANKLINE)
1018         self.body.append(', '.join(n.astext() for n in list_items) + '.')
1019         self.body.append(BLANKLINE)
1020         raise nodes.SkipNode
1021 
1022     def visit_bullet_list(self, node: Element) -> None:
1023         if not self.compact_list:
1024             self.body.append(r'\begin{itemize}' + CR)
1025         if self.table:
1026             self.table.has_problematic = True
1027 
1028     def depart_bullet_list(self, node: Element) -> None:
1029         if not self.compact_list:
1030             self.body.append(r'\end{itemize}' + CR)
1031 
1032     def visit_enumerated_list(self, node: Element) -> None:
1033         def get_enumtype(node: Element) -> str:
1034             enumtype = node.get('enumtype', 'arabic')
1035             if 'alpha' in enumtype and 26 < node.get('start', 0) + len(node):
1036                 # fallback to arabic if alphabet counter overflows
1037                 enumtype = 'arabic'
1038 
1039             return enumtype
1040 
1041         def get_nested_level(node: Element) -> int:
1042             if node is None:
1043                 return 0
1044             elif isinstance(node, nodes.enumerated_list):
1045                 return get_nested_level(node.parent) + 1
1046             else:
1047                 return get_nested_level(node.parent)
1048 
1049         enum = "enum%s" % toRoman(get_nested_level(node)).lower()
1050         enumnext = "enum%s" % toRoman(get_nested_level(node) + 1).lower()
1051         style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))
1052         prefix = node.get('prefix', '')
1053         suffix = node.get('suffix', '.')
1054 
1055         self.body.append(r'\begin{enumerate}' + CR)
1056         self.body.append(r'\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%' %
1057                          (style, enum, enumnext, prefix, suffix) + CR)
1058         if 'start' in node:
1059             self.body.append(r'\setcounter{%s}{%d}' % (enum, node['start'] - 1) + CR)
1060         if self.table:
1061             self.table.has_problematic = True
1062 
1063     def depart_enumerated_list(self, node: Element) -> None:
1064         self.body.append(r'\end{enumerate}' + CR)
1065 
1066     def visit_list_item(self, node: Element) -> None:
1067         # Append "{}" in case the next character is "[", which would break
1068         # LaTeX's list environment (no numbering and the "[" is not printed).
1069         self.body.append(r'\item {} ')
1070 
1071     def depart_list_item(self, node: Element) -> None:
1072         self.body.append(CR)
1073 
1074     def visit_definition_list(self, node: Element) -> None:
1075         self.body.append(r'\begin{description}' + CR)
1076         if self.table:
1077             self.table.has_problematic = True
1078 
1079     def depart_definition_list(self, node: Element) -> None:
1080         self.body.append(r'\end{description}' + CR)
1081 
1082     def visit_definition_list_item(self, node: Element) -> None:
1083         pass
1084 
1085     def depart_definition_list_item(self, node: Element) -> None:
1086         pass
1087 
1088     def visit_term(self, node: Element) -> None:
1089         self.in_term += 1
1090         ctx = ''
1091         if node.get('ids'):
1092             ctx = r'\phantomsection'
1093             for node_id in node['ids']:
1094                 ctx += self.hypertarget(node_id, anchor=False)
1095         ctx += r'}] \leavevmode'
1096         self.body.append(r'\item[{')
1097         self.context.append(ctx)
1098 
1099     def depart_term(self, node: Element) -> None:
1100         self.body.append(self.context.pop())
1101         self.in_term -= 1
1102 
1103     def visit_classifier(self, node: Element) -> None:
1104         self.body.append('{[}')
1105 
1106     def depart_classifier(self, node: Element) -> None:
1107         self.body.append('{]}')
1108 
1109     def visit_definition(self, node: Element) -> None:
1110         pass
1111 
1112     def depart_definition(self, node: Element) -> None:
1113         self.body.append(CR)
1114 
1115     def visit_field_list(self, node: Element) -> None:
1116         self.body.append(r'\begin{quote}\begin{description}' + CR)
1117         if self.table:
1118             self.table.has_problematic = True
1119 
1120     def depart_field_list(self, node: Element) -> None:
1121         self.body.append(r'\end{description}\end{quote}' + CR)
1122 
1123     def visit_field(self, node: Element) -> None:
1124         pass
1125 
1126     def depart_field(self, node: Element) -> None:
1127         pass
1128 
1129     visit_field_name = visit_term
1130     depart_field_name = depart_term
1131 
1132     visit_field_body = visit_definition
1133     depart_field_body = depart_definition
1134 
1135     def visit_paragraph(self, node: Element) -> None:
1136         index = node.parent.index(node)
1137         if (index > 0 and isinstance(node.parent, nodes.compound) and
1138                 not isinstance(node.parent[index - 1], nodes.paragraph) and
1139                 not isinstance(node.parent[index - 1], nodes.compound)):
1140             # insert blank line, if the paragraph follows a non-paragraph node in a compound
1141             self.body.append(r'\noindent' + CR)
1142         elif index == 1 and isinstance(node.parent, (nodes.footnote, footnotetext)):
1143             # don't insert blank line, if the paragraph is second child of a footnote
1144             # (first one is label node)
1145             pass
1146         else:
1147             # the \sphinxAtStartPar is to allow hyphenation of first word of
1148             # a paragraph in narrow contexts such as in a table cell
1149             # added as two items (cf. line trimming in depart_entry())
1150             self.body.extend([CR, r'\sphinxAtStartPar' + CR])
1151 
1152     def depart_paragraph(self, node: Element) -> None:
1153         self.body.append(CR)
1154 
1155     def visit_centered(self, node: Element) -> None:
1156         self.body.append(CR + r'\begin{center}')
1157         if self.table:
1158             self.table.has_problematic = True
1159 
1160     def depart_centered(self, node: Element) -> None:
1161         self.body.append(CR + r'\end{center}')
1162 
1163     def visit_hlist(self, node: Element) -> None:
1164         self.compact_list += 1
1165         ncolumns = node['ncolumns']
1166         if self.compact_list > 1:
1167             self.body.append(r'\setlength{\multicolsep}{0pt}' + CR)
1168         self.body.append(r'\begin{multicols}{' + ncolumns + r'}\raggedright' + CR)
1169         self.body.append(r'\begin{itemize}\setlength{\itemsep}{0pt}'
1170                          r'\setlength{\parskip}{0pt}' + CR)
1171         if self.table:
1172             self.table.has_problematic = True
1173 
1174     def depart_hlist(self, node: Element) -> None:
1175         self.compact_list -= 1
1176         self.body.append(r'\end{itemize}\raggedcolumns\end{multicols}' + CR)
1177 
1178     def visit_hlistcol(self, node: Element) -> None:
1179         pass
1180 
1181     def depart_hlistcol(self, node: Element) -> None:
1182         # \columnbreak would guarantee same columns as in html output.  But
1183         # some testing with long items showed that columns may be too uneven.
1184         # And in case only of short items, the automatic column breaks should
1185         # match the ones pre-computed by the hlist() directive.
1186         # self.body.append(r'\columnbreak\n')
1187         pass
1188 
1189     def latex_image_length(self, width_str: str, scale: int = 100) -> str:
1190         try:
1191             return rstdim_to_latexdim(width_str, scale)
1192         except ValueError:
1193             logger.warning(__('dimension unit %s is invalid. Ignored.'), width_str)
1194             return None
1195 
1196     def is_inline(self, node: Element) -> bool:
1197         """Check whether a node represents an inline element."""
1198         return isinstance(node.parent, nodes.TextElement)
1199 
1200     def visit_image(self, node: Element) -> None:
1201         pre: List[str] = []  # in reverse order
1202         post: List[str] = []
1203         include_graphics_options = []
1204         has_hyperlink = isinstance(node.parent, nodes.reference)
1205         if has_hyperlink:
1206             is_inline = self.is_inline(node.parent)
1207         else:
1208             is_inline = self.is_inline(node)
1209         if 'width' in node:
1210             if 'scale' in node:
1211                 w = self.latex_image_length(node['width'], node['scale'])
1212             else:
1213                 w = self.latex_image_length(node['width'])
1214             if w:
1215                 include_graphics_options.append('width=%s' % w)
1216         if 'height' in node:
1217             if 'scale' in node:
1218                 h = self.latex_image_length(node['height'], node['scale'])
1219             else:
1220                 h = self.latex_image_length(node['height'])
1221             if h:
1222                 include_graphics_options.append('height=%s' % h)
1223         if 'scale' in node:
1224             if not include_graphics_options:
1225                 # if no "width" nor "height", \sphinxincludegraphics will fit
1226                 # to the available text width if oversized after rescaling.
1227                 include_graphics_options.append('scale=%s'
1228                                                 % (float(node['scale']) / 100.0))
1229         if 'align' in node:
1230             align_prepost = {
1231                 # By default latex aligns the top of an image.
1232                 (1, 'top'): ('', ''),
1233                 (1, 'middle'): (r'\raisebox{-0.5\height}{', '}'),
1234                 (1, 'bottom'): (r'\raisebox{-\height}{', '}'),
1235                 (0, 'center'): (r'{\hspace*{\fill}', r'\hspace*{\fill}}'),
1236                 # These 2 don't exactly do the right thing.  The image should
1237                 # be floated alongside the paragraph.  See
1238                 # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG
1239                 (0, 'left'): ('{', r'\hspace*{\fill}}'),
1240                 (0, 'right'): (r'{\hspace*{\fill}', '}'),
1241             }
1242             try:
1243                 pre.append(align_prepost[is_inline, node['align']][0])
1244                 post.append(align_prepost[is_inline, node['align']][1])
1245             except KeyError:
1246                 pass
1247         if self.in_parsed_literal:
1248             pre.append(r'{\sphinxunactivateextrasandspace ')
1249             post.append('}')
1250         if not is_inline and not has_hyperlink:
1251             pre.append(CR + r'\noindent')
1252             post.append(CR)
1253         pre.reverse()
1254         if node['uri'] in self.builder.images:
1255             uri = self.builder.images[node['uri']]
1256         else:
1257             # missing image!
1258             if self.ignore_missing_images:
1259                 return
1260             uri = node['uri']
1261         if uri.find('://') != -1:
1262             # ignore remote images
1263             return
1264         self.body.extend(pre)
1265         options = ''
1266         if include_graphics_options:
1267             options = '[%s]' % ','.join(include_graphics_options)
1268         base, ext = path.splitext(uri)
1269         if self.in_title and base:
1270             # Lowercase tokens forcely because some fncychap themes capitalize
1271             # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).
1272             self.body.append(r'\lowercase{\sphinxincludegraphics%s}{{%s}%s}' %
1273                              (options, base, ext))
1274         else:
1275             self.body.append(r'\sphinxincludegraphics%s{{%s}%s}' %
1276                              (options, base, ext))
1277         self.body.extend(post)
1278 
1279     def depart_image(self, node: Element) -> None:
1280         pass
1281 
1282     def visit_figure(self, node: Element) -> None:
1283         align = self.elements['figure_align']
1284         if self.no_latex_floats:
1285             align = "H"
1286         if self.table:
1287             # TODO: support align option
1288             if 'width' in node:
1289                 length = self.latex_image_length(node['width'])
1290                 if length:
1291                     self.body.append(r'\begin{sphinxfigure-in-table}[%s]' % length + CR)
1292                     self.body.append(r'\centering' + CR)
1293             else:
1294                 self.body.append(r'\begin{sphinxfigure-in-table}' + CR)
1295                 self.body.append(r'\centering' + CR)
1296             if any(isinstance(child, nodes.caption) for child in node):
1297                 self.body.append(r'\capstart')
1298             self.context.append(r'\end{sphinxfigure-in-table}\relax' + CR)
1299         elif node.get('align', '') in ('left', 'right'):
1300             length = None
1301             if 'width' in node:
1302                 length = self.latex_image_length(node['width'])
1303             elif isinstance(node[0], nodes.image) and 'width' in node[0]:
1304                 length = self.latex_image_length(node[0]['width'])
1305             self.body.append(BLANKLINE)     # Insert a blank line to prevent infinite loop
1306                                             # https://github.com/sphinx-doc/sphinx/issues/7059
1307             self.body.append(r'\begin{wrapfigure}{%s}{%s}' %
1308                              ('r' if node['align'] == 'right' else 'l', length or '0pt') + CR)
1309             self.body.append(r'\centering')
1310             self.context.append(r'\end{wrapfigure}' + CR)
1311         elif self.in_minipage:
1312             self.body.append(CR + r'\begin{center}')
1313             self.context.append(r'\end{center}' + CR)
1314         else:
1315             self.body.append(CR + r'\begin{figure}[%s]' % align + CR)
1316             self.body.append(r'\centering' + CR)
1317             if any(isinstance(child, nodes.caption) for child in node):
1318                 self.body.append(r'\capstart' + CR)
1319             self.context.append(r'\end{figure}' + CR)
1320 
1321     def depart_figure(self, node: Element) -> None:
1322         self.body.append(self.context.pop())
1323 
1324     def visit_caption(self, node: Element) -> None:
1325         self.in_caption += 1
1326         if isinstance(node.parent, captioned_literal_block):
1327             self.body.append(r'\sphinxSetupCaptionForVerbatim{')
1328         elif self.in_minipage and isinstance(node.parent, nodes.figure):
1329             self.body.append(r'\captionof{figure}{')
1330         elif self.table and node.parent.tagname == 'figure':
1331             self.body.append(r'\sphinxfigcaption{')
1332         else:
1333             self.body.append(r'\caption{')
1334 
1335     def depart_caption(self, node: Element) -> None:
1336         self.body.append('}')
1337         if isinstance(node.parent, nodes.figure):
1338             labels = self.hypertarget_to(node.parent)
1339             self.body.append(labels)
1340         self.in_caption -= 1
1341 
1342     def visit_legend(self, node: Element) -> None:
1343         self.body.append(CR + r'\begin{sphinxlegend}')
1344 
1345     def depart_legend(self, node: Element) -> None:
1346         self.body.append(r'\end{sphinxlegend}' + CR)
1347 
1348     def visit_admonition(self, node: Element) -> None:
1349         self.body.append(CR + r'\begin{sphinxadmonition}{note}')
1350         self.no_latex_floats += 1
1351 
1352     def depart_admonition(self, node: Element) -> None:
1353         self.body.append(r'\end{sphinxadmonition}' + CR)
1354         self.no_latex_floats -= 1
1355 
1356     def _visit_named_admonition(self, node: Element) -> None:
1357         label = admonitionlabels[node.tagname]
1358         self.body.append(CR + r'\begin{sphinxadmonition}{%s}{%s:}' %
1359                          (node.tagname, label))
1360         self.no_latex_floats += 1
1361 
1362     def _depart_named_admonition(self, node: Element) -> None:
1363         self.body.append(r'\end{sphinxadmonition}' + CR)
1364         self.no_latex_floats -= 1
1365 
1366     visit_attention = _visit_named_admonition
1367     depart_attention = _depart_named_admonition
1368     visit_caution = _visit_named_admonition
1369     depart_caution = _depart_named_admonition
1370     visit_danger = _visit_named_admonition
1371     depart_danger = _depart_named_admonition
1372     visit_error = _visit_named_admonition
1373     depart_error = _depart_named_admonition
1374     visit_hint = _visit_named_admonition
1375     depart_hint = _depart_named_admonition
1376     visit_important = _visit_named_admonition
1377     depart_important = _depart_named_admonition
1378     visit_note = _visit_named_admonition
1379     depart_note = _depart_named_admonition
1380     visit_tip = _visit_named_admonition
1381     depart_tip = _depart_named_admonition
1382     visit_warning = _visit_named_admonition
1383     depart_warning = _depart_named_admonition
1384 
1385     def visit_versionmodified(self, node: Element) -> None:
1386         pass
1387 
1388     def depart_versionmodified(self, node: Element) -> None:
1389         pass
1390 
1391     def visit_target(self, node: Element) -> None:
1392         def add_target(id: str) -> None:
1393             # indexing uses standard LaTeX index markup, so the targets
1394             # will be generated differently
1395             if id.startswith('index-'):
1396                 return
1397 
1398             # equations also need no extra blank line nor hypertarget
1399             # TODO: fix this dependency on mathbase extension internals
1400             if id.startswith('equation-'):
1401                 return
1402 
1403             # insert blank line, if the target follows a paragraph node
1404             index = node.parent.index(node)
1405             if index > 0 and isinstance(node.parent[index - 1], nodes.paragraph):
1406                 self.body.append(CR)
1407 
1408             # do not generate \phantomsection in \section{}
1409             anchor = not self.in_title
1410             self.body.append(self.hypertarget(id, anchor=anchor))
1411 
1412         # skip if visitor for next node supports hyperlink
1413         next_node: Node = node
1414         while isinstance(next_node, nodes.target):
1415             next_node = next_node.next_node(ascend=True)
1416 
1417         domain = cast(StandardDomain, self.builder.env.get_domain('std'))
1418         if isinstance(next_node, HYPERLINK_SUPPORT_NODES):
1419             return
1420         elif domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):
1421             return
1422 
1423         if 'refuri' in node:
1424             return
1425         if 'anonymous' in node:
1426             return
1427         if node.get('refid'):
1428             prev_node = get_prev_node(node)
1429             if isinstance(prev_node, nodes.reference) and node['refid'] == prev_node['refid']:
1430                 # a target for a hyperlink reference having alias
1431                 pass
1432             else:
1433                 add_target(node['refid'])
1434         for id in node['ids']:
1435             add_target(id)
1436 
1437     def depart_target(self, node: Element) -> None:
1438         pass
1439 
1440     def visit_attribution(self, node: Element) -> None:
1441         self.body.append(CR + r'\begin{flushright}' + CR)
1442         self.body.append('---')
1443 
1444     def depart_attribution(self, node: Element) -> None:
1445         self.body.append(CR + r'\end{flushright}' + CR)
1446 
1447     def visit_index(self, node: Element) -> None:
1448         def escape(value: str) -> str:
1449             value = self.encode(value)
1450             value = value.replace(r'\{', r'\sphinxleftcurlybrace{}')
1451             value = value.replace(r'\}', r'\sphinxrightcurlybrace{}')
1452             value = value.replace('"', '""')
1453             value = value.replace('@', '"@')
1454             value = value.replace('!', '"!')
1455             value = value.replace('|', r'\textbar{}')
1456             return value
1457 
1458         def style(string: str) -> str:
1459             match = EXTRA_RE.match(string)
1460             if match:
1461                 return match.expand(r'\\spxentry{\1}\\spxextra{\2}')
1462             else:
1463                 return r'\spxentry{%s}' % string
1464 
1465         if not node.get('inline', True):
1466             self.body.append(CR)
1467         entries = node['entries']
1468         for type, string, tid, ismain, key_ in entries:
1469             m = ''
1470             if ismain:
1471                 m = '|spxpagem'
1472             try:
1473                 if type == 'single':
1474                     try:
1475                         p1, p2 = [escape(x) for x in split_into(2, 'single', string)]
1476                         P1, P2 = style(p1), style(p2)
1477                         self.body.append(r'\index{%s@%s!%s@%s%s}' % (p1, P1, p2, P2, m))
1478                     except ValueError:
1479                         p = escape(split_into(1, 'single', string)[0])
1480                         P = style(p)
1481                         self.body.append(r'\index{%s@%s%s}' % (p, P, m))
1482                 elif type == 'pair':
1483                     p1, p2 = [escape(x) for x in split_into(2, 'pair', string)]
1484                     P1, P2 = style(p1), style(p2)
1485                     self.body.append(r'\index{%s@%s!%s@%s%s}\index{%s@%s!%s@%s%s}' %
1486                                      (p1, P1, p2, P2, m, p2, P2, p1, P1, m))
1487                 elif type == 'triple':
1488                     p1, p2, p3 = [escape(x) for x in split_into(3, 'triple', string)]
1489                     P1, P2, P3 = style(p1), style(p2), style(p3)
1490                     self.body.append(
1491                         r'\index{%s@%s!%s %s@%s %s%s}'
1492                         r'\index{%s@%s!%s, %s@%s, %s%s}'
1493                         r'\index{%s@%s!%s %s@%s %s%s}' %
1494                         (p1, P1, p2, p3, P2, P3, m,
1495                          p2, P2, p3, p1, P3, P1, m,
1496                          p3, P3, p1, p2, P1, P2, m))
1497                 elif type == 'see':
1498                     p1, p2 = [escape(x) for x in split_into(2, 'see', string)]
1499                     P1 = style(p1)
1500                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1501                 elif type == 'seealso':
1502                     p1, p2 = [escape(x) for x in split_into(2, 'seealso', string)]
1503                     P1 = style(p1)
1504                     self.body.append(r'\index{%s@%s|see{%s}}' % (p1, P1, p2))
1505                 else:
1506                     logger.warning(__('unknown index entry type %s found'), type)
1507             except ValueError as err:
1508                 logger.warning(str(err))
1509         if not node.get('inline', True):
1510             self.body.append(r'\ignorespaces ')
1511         raise nodes.SkipNode
1512 
1513     def visit_raw(self, node: Element) -> None:
1514         if not self.is_inline(node):
1515             self.body.append(CR)
1516         if 'latex' in node.get('format', '').split():
1517             self.body.append(node.astext())
1518         if not self.is_inline(node):
1519             self.body.append(CR)
1520         raise nodes.SkipNode
1521 
1522     def visit_reference(self, node: Element) -> None:
1523         if not self.in_title:
1524             for id in node.get('ids'):
1525                 anchor = not self.in_caption
1526                 self.body += self.hypertarget(id, anchor=anchor)
1527         if not self.is_inline(node):
1528             self.body.append(CR)
1529         uri = node.get('refuri', '')
1530         if not uri and node.get('refid'):
1531             uri = '%' + self.curfilestack[-1] + '#' + node['refid']
1532         if self.in_title or not uri:
1533             self.context.append('')
1534         elif uri.startswith('#'):
1535             # references to labels in the same document
1536             id = self.curfilestack[-1] + ':' + uri[1:]
1537             self.body.append(self.hyperlink(id))
1538             self.body.append(r'\emph{')
1539             if self.config.latex_show_pagerefs and not \
1540                     self.in_production_list:
1541                 self.context.append('}}} (%s)' % self.hyperpageref(id))
1542             else:
1543                 self.context.append('}}}')
1544         elif uri.startswith('%'):
1545             # references to documents or labels inside documents
1546             hashindex = uri.find('#')
1547             if hashindex == -1:
1548                 # reference to the document
1549                 id = uri[1:] + '::doc'
1550             else:
1551                 # reference to a label
1552                 id = uri[1:].replace('#', ':')
1553             self.body.append(self.hyperlink(id))
1554             if (len(node) and
1555                     isinstance(node[0], nodes.Element) and
1556                     'std-term' in node[0].get('classes', [])):
1557                 # don't add a pageref for glossary terms
1558                 self.context.append('}}}')
1559                 # mark up as termreference
1560                 self.body.append(r'\sphinxtermref{')
1561             else:
1562                 self.body.append(r'\sphinxcrossref{')
1563                 if self.config.latex_show_pagerefs and not self.in_production_list:
1564                     self.context.append('}}} (%s)' % self.hyperpageref(id))
1565                 else:
1566                     self.context.append('}}}')
1567         else:
1568             if len(node) == 1 and uri == node[0]:
1569                 if node.get('nolinkurl'):
1570                     self.body.append(r'\sphinxnolinkurl{%s}' % self.encode_uri(uri))
1571                 else:
1572                     self.body.append(r'\sphinxurl{%s}' % self.encode_uri(uri))
1573                 raise nodes.SkipNode
1574             else:
1575                 self.body.append(r'\sphinxhref{%s}{' % self.encode_uri(uri))
1576                 self.context.append('}')
1577 
1578     def depart_reference(self, node: Element) -> None:
1579         self.body.append(self.context.pop())
1580         if not self.is_inline(node):
1581             self.body.append(CR)
1582 
1583     def visit_number_reference(self, node: Element) -> None:
1584         if node.get('refid'):
1585             id = self.curfilestack[-1] + ':' + node['refid']
1586         else:
1587             id = node.get('refuri', '')[1:].replace('#', ':')
1588 
1589         title = self.escape(node.get('title', '%s')).replace(r'\%s', '%s')
1590         if r'\{name\}' in title or r'\{number\}' in title:
1591             # new style format (cf. "Fig.%{number}")
1592             title = title.replace(r'\{name\}', '{name}').replace(r'\{number\}', '{number}')
1593             text = escape_abbr(title).format(name=r'\nameref{%s}' % self.idescape(id),
1594                                              number=r'\ref{%s}' % self.idescape(id))
1595         else:
1596             # old style format (cf. "Fig.%{number}")
1597             text = escape_abbr(title) % (r'\ref{%s}' % self.idescape(id))
1598         hyperref = r'\hyperref[%s]{%s}' % (self.idescape(id), text)
1599         self.body.append(hyperref)
1600 
1601         raise nodes.SkipNode
1602 
1603     def visit_download_reference(self, node: Element) -> None:
1604         pass
1605 
1606     def depart_download_reference(self, node: Element) -> None:
1607         pass
1608 
1609     def visit_pending_xref(self, node: Element) -> None:
1610         pass
1611 
1612     def depart_pending_xref(self, node: Element) -> None:
1613         pass
1614 
1615     def visit_emphasis(self, node: Element) -> None:
1616         self.body.append(r'\sphinxstyleemphasis{')
1617 
1618     def depart_emphasis(self, node: Element) -> None:
1619         self.body.append('}')
1620 
1621     def visit_literal_emphasis(self, node: Element) -> None:
1622         self.body.append(r'\sphinxstyleliteralemphasis{\sphinxupquote{')
1623 
1624     def depart_literal_emphasis(self, node: Element) -> None:
1625         self.body.append('}}')
1626 
1627     def visit_strong(self, node: Element) -> None:
1628         self.body.append(r'\sphinxstylestrong{')
1629 
1630     def depart_strong(self, node: Element) -> None:
1631         self.body.append('}')
1632 
1633     def visit_literal_strong(self, node: Element) -> None:
1634         self.body.append(r'\sphinxstyleliteralstrong{\sphinxupquote{')
1635 
1636     def depart_literal_strong(self, node: Element) -> None:
1637         self.body.append('}}')
1638 
1639     def visit_abbreviation(self, node: Element) -> None:
1640         abbr = node.astext()
1641         self.body.append(r'\sphinxstyleabbreviation{')
1642         # spell out the explanation once
1643         if node.hasattr('explanation') and abbr not in self.handled_abbrs:
1644             self.context.append('} (%s)' % self.encode(node['explanation']))
1645             self.handled_abbrs.add(abbr)
1646         else:
1647             self.context.append('}')
1648 
1649     def depart_abbreviation(self, node: Element) -> None:
1650         self.body.append(self.context.pop())
1651 
1652     def visit_manpage(self, node: Element) -> None:
1653         return self.visit_literal_emphasis(node)
1654 
1655     def depart_manpage(self, node: Element) -> None:
1656         return self.depart_literal_emphasis(node)
1657 
1658     def visit_title_reference(self, node: Element) -> None:
1659         self.body.append(r'\sphinxtitleref{')
1660 
1661     def depart_title_reference(self, node: Element) -> None:
1662         self.body.append('}')
1663 
1664     def visit_thebibliography(self, node: Element) -> None:
1665         citations = cast(Iterable[nodes.citation], node)
1666         labels = (cast(nodes.label, citation[0]) for citation in citations)
1667         longest_label = max((label.astext() for label in labels), key=len)
1668         if len(longest_label) > MAX_CITATION_LABEL_LENGTH:
1669             # adjust max width of citation labels not to break the layout
1670             longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]
1671 
1672         self.body.append(CR + r'\begin{sphinxthebibliography}{%s}' %
1673                          self.encode(longest_label) + CR)
1674 
1675     def depart_thebibliography(self, node: Element) -> None:
1676         self.body.append(r'\end{sphinxthebibliography}' + CR)
1677 
1678     def visit_citation(self, node: Element) -> None:
1679         label = cast(nodes.label, node[0])
1680         self.body.append(r'\bibitem[%s]{%s:%s}' % (self.encode(label.astext()),
1681                                                    node['docname'], node['ids'][0]))
1682 
1683     def depart_citation(self, node: Element) -> None:
1684         pass
1685 
1686     def visit_citation_reference(self, node: Element) -> None:
1687         if self.in_title:
1688             pass
1689         else:
1690             self.body.append(r'\sphinxcite{%s:%s}' % (node['docname'], node['refname']))
1691             raise nodes.SkipNode
1692 
1693     def depart_citation_reference(self, node: Element) -> None:
1694         pass
1695 
1696     def visit_literal(self, node: Element) -> None:
1697         if self.in_title:
1698             self.body.append(r'\sphinxstyleliteralintitle{\sphinxupquote{')
1699         elif 'kbd' in node['classes']:
1700             self.body.append(r'\sphinxkeyboard{\sphinxupquote{')
1701         else:
1702             self.body.append(r'\sphinxcode{\sphinxupquote{')
1703 
1704     def depart_literal(self, node: Element) -> None:
1705         self.body.append('}}')
1706 
1707     def visit_footnote_reference(self, node: Element) -> None:
1708         raise nodes.SkipNode
1709 
1710     def visit_footnotemark(self, node: Element) -> None:
1711         self.body.append(r'\sphinxfootnotemark[')
1712 
1713     def depart_footnotemark(self, node: Element) -> None:
1714         self.body.append(']')
1715 
1716     def visit_footnotetext(self, node: Element) -> None:
1717         label = cast(nodes.label, node[0])
1718         self.body.append('%' + CR)
1719         self.body.append(r'\begin{footnotetext}[%s]'
1720                          r'\phantomsection\label{\thesphinxscope.%s}%%'
1721                          % (label.astext(), label.astext()) + CR)
1722         self.body.append(r'\sphinxAtStartFootnote' + CR)
1723 
1724     def depart_footnotetext(self, node: Element) -> None:
1725         # the \ignorespaces in particular for after table header use
1726         self.body.append('%' + CR)
1727         self.body.append(r'\end{footnotetext}\ignorespaces ')
1728 
1729     def visit_captioned_literal_block(self, node: Element) -> None:
1730         pass
1731 
1732     def depart_captioned_literal_block(self, node: Element) -> None:
1733         pass
1734 
1735     def visit_literal_block(self, node: Element) -> None:
1736         if node.rawsource != node.astext():
1737             # most probably a parsed-literal block -- don't highlight
1738             self.in_parsed_literal += 1
1739             self.body.append(r'\begin{sphinxalltt}' + CR)
1740         else:
1741             labels = self.hypertarget_to(node)
1742             if isinstance(node.parent, captioned_literal_block):
1743                 labels += self.hypertarget_to(node.parent)
1744             if labels and not self.in_footnote:
1745                 self.body.append(CR + r'\def\sphinxLiteralBlockLabel{' + labels + '}')
1746 
1747             lang = node.get('language', 'default')
1748             linenos = node.get('linenos', False)
1749             highlight_args = node.get('highlight_args', {})
1750             highlight_args['force'] = node.get('force', False)
1751             opts = self.config.highlight_options.get(lang, {})
1752 
1753             hlcode = self.highlighter.highlight_block(
1754                 node.rawsource, lang, opts=opts, linenos=linenos,
1755                 location=node, **highlight_args
1756             )
1757             if self.in_footnote:
1758                 self.body.append(CR + r'\sphinxSetupCodeBlockInFootnote')
1759                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1760                                         r'\begin{sphinxVerbatim}')
1761             # if in table raise verbatim flag to avoid "tabulary" environment
1762             # and opt for sphinxVerbatimintable to handle caption & long lines
1763             elif self.table:
1764                 self.table.has_problematic = True
1765                 self.table.has_verbatim = True
1766                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1767                                         r'\begin{sphinxVerbatimintable}')
1768             else:
1769                 hlcode = hlcode.replace(r'\begin{Verbatim}',
1770                                         r'\begin{sphinxVerbatim}')
1771             # get consistent trailer
1772             hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}
1773             if self.table and not self.in_footnote:
1774                 hlcode += r'\end{sphinxVerbatimintable}'
1775             else:
1776                 hlcode += r'\end{sphinxVerbatim}'
1777 
1778             hllines = str(highlight_args.get('hl_lines', []))[1:-1]
1779             if hllines:
1780                 self.body.append(CR + r'\fvset{hllines={, %s,}}%%' % hllines)
1781             self.body.append(CR + hlcode + CR)
1782             if hllines:
1783                 self.body.append(r'\sphinxresetverbatimhllines' + CR)
1784             raise nodes.SkipNode
1785 
1786     def depart_literal_block(self, node: Element) -> None:
1787         self.body.append(CR + r'\end{sphinxalltt}' + CR)
1788         self.in_parsed_literal -= 1
1789     visit_doctest_block = visit_literal_block
1790     depart_doctest_block = depart_literal_block
1791 
1792     def visit_line(self, node: Element) -> None:
1793         self.body.append(r'\item[] ')
1794 
1795     def depart_line(self, node: Element) -> None:
1796         self.body.append(CR)
1797 
1798     def visit_line_block(self, node: Element) -> None:
1799         if isinstance(node.parent, nodes.line_block):
1800             self.body.append(r'\item[]' + CR)
1801             self.body.append(r'\begin{DUlineblock}{\DUlineblockindent}' + CR)
1802         else:
1803             self.body.append(CR + r'\begin{DUlineblock}{0em}' + CR)
1804         if self.table:
1805             self.table.has_problematic = True
1806 
1807     def depart_line_block(self, node: Element) -> None:
1808         self.body.append(r'\end{DUlineblock}' + CR)
1809 
1810     def visit_block_quote(self, node: Element) -> None:
1811         # If the block quote contains a single object and that object
1812         # is a list, then generate a list not a block quote.
1813         # This lets us indent lists.
1814         done = 0
1815         if len(node.children) == 1:
1816             child = node.children[0]
1817             if isinstance(child, nodes.bullet_list) or \
1818                     isinstance(child, nodes.enumerated_list):
1819                 done = 1
1820         if not done:
1821             self.body.append(r'\begin{quote}' + CR)
1822             if self.table:
1823                 self.table.has_problematic = True
1824 
1825     def depart_block_quote(self, node: Element) -> None:
1826         done = 0
1827         if len(node.children) == 1:
1828             child = node.children[0]
1829             if isinstance(child, nodes.bullet_list) or \
1830                     isinstance(child, nodes.enumerated_list):
1831                 done = 1
1832         if not done:
1833             self.body.append(r'\end{quote}' + CR)
1834 
1835     # option node handling copied from docutils' latex writer
1836 
1837     def visit_option(self, node: Element) -> None:
1838         if self.context[-1]:
1839             # this is not the first option
1840             self.body.append(', ')
1841 
1842     def depart_option(self, node: Element) -> None:
1843         # flag that the first option is done.
1844         self.context[-1] += 1
1845 
1846     def visit_option_argument(self, node: Element) -> None:
1847         """The delimiter between an option and its argument."""
1848         self.body.append(node.get('delimiter', ' '))
1849 
1850     def depart_option_argument(self, node: Element) -> None:
1851         pass
1852 
1853     def visit_option_group(self, node: Element) -> None:
1854         self.body.append(r'\item [')
1855         # flag for first option
1856         self.context.append(0)
1857 
1858     def depart_option_group(self, node: Element) -> None:
1859         self.context.pop()  # the flag
1860         self.body.append('] ')
1861 
1862     def visit_option_list(self, node: Element) -> None:
1863         self.body.append(r'\begin{optionlist}{3cm}' + CR)
1864         if self.table:
1865             self.table.has_problematic = True
1866 
1867     def depart_option_list(self, node: Element) -> None:
1868         self.body.append(r'\end{optionlist}' + CR)
1869 
1870     def visit_option_list_item(self, node: Element) -> None:
1871         pass
1872 
1873     def depart_option_list_item(self, node: Element) -> None:
1874         pass
1875 
1876     def visit_option_string(self, node: Element) -> None:
1877         ostring = node.astext()
1878         self.body.append(self.encode(ostring))
1879         raise nodes.SkipNode
1880 
1881     def visit_description(self, node: Element) -> None:
1882         self.body.append(' ')
1883 
1884     def depart_description(self, node: Element) -> None:
1885         pass
1886 
1887     def visit_superscript(self, node: Element) -> None:
1888         self.body.append(r'$^{\text{')
1889 
1890     def depart_superscript(self, node: Element) -> None:
1891         self.body.append('}}$')
1892 
1893     def visit_subscript(self, node: Element) -> None:
1894         self.body.append(r'$_{\text{')
1895 
1896     def depart_subscript(self, node: Element) -> None:
1897         self.body.append('}}$')
1898 
1899     def visit_inline(self, node: Element) -> None:
1900         classes = node.get('classes', [])
1901         if classes in [['menuselection']]:
1902             self.body.append(r'\sphinxmenuselection{')
1903             self.context.append('}')
1904         elif classes in [['guilabel']]:
1905             self.body.append(r'\sphinxguilabel{')
1906             self.context.append('}')
1907         elif classes in [['accelerator']]:
1908             self.body.append(r'\sphinxaccelerator{')
1909             self.context.append('}')
1910         elif classes and not self.in_title:
1911             self.body.append(r'\DUrole{%s}{' % ','.join(classes))
1912             self.context.append('}')
1913         else:
1914             self.context.append('')
1915 
1916     def depart_inline(self, node: Element) -> None:
1917         self.body.append(self.context.pop())
1918 
1919     def visit_generated(self, node: Element) -> None:
1920         pass
1921 
1922     def depart_generated(self, node: Element) -> None:
1923         pass
1924 
1925     def visit_compound(self, node: Element) -> None:
1926         pass
1927 
1928     def depart_compound(self, node: Element) -> None:
1929         pass
1930 
1931     def visit_container(self, node: Element) -> None:
1932         classes = node.get('classes', [])
1933         for c in classes:
1934             self.body.append('\n\\begin{sphinxuseclass}{%s}' % c)
1935 
1936     def depart_container(self, node: Element) -> None:
1937         classes = node.get('classes', [])
1938         for c in classes:
1939             self.body.append('\n\\end{sphinxuseclass}')
1940 
1941     def visit_decoration(self, node: Element) -> None:
1942         pass
1943 
1944     def depart_decoration(self, node: Element) -> None:
1945         pass
1946 
1947     # docutils-generated elements that we don't support
1948 
1949     def visit_header(self, node: Element) -> None:
1950         raise nodes.SkipNode
1951 
1952     def visit_footer(self, node: Element) -> None:
1953         raise nodes.SkipNode
1954 
1955     def visit_docinfo(self, node: Element) -> None:
1956         raise nodes.SkipNode
1957 
1958     # text handling
1959 
1960     def encode(self, text: str) -> str:
1961         text = self.escape(text)
1962         if self.literal_whitespace:
1963             # Insert a blank before the newline, to avoid
1964             # ! LaTeX Error: There's no line here to end.
1965             text = text.replace(CR, r'~\\' + CR).replace(' ', '~')
1966         return text
1967 
1968     def encode_uri(self, text: str) -> str:
1969         # TODO: it is probably wrong that this uses texescape.escape()
1970         #       this must be checked against hyperref package exact dealings
1971         #       mainly, %, #, {, } and \ need escaping via a \ escape
1972         # in \href, the tilde is allowed and must be represented literally
1973         return self.encode(text).replace(r'\textasciitilde{}', '~').\
1974             replace(r'\sphinxhyphen{}', '-').\
1975             replace(r'\textquotesingle{}', "'")
1976 
1977     def visit_Text(self, node: Text) -> None:
1978         text = self.encode(node.astext())
1979         self.body.append(text)
1980 
1981     def depart_Text(self, node: Text) -> None:
1982         pass
1983 
1984     def visit_comment(self, node: Element) -> None:
1985         raise nodes.SkipNode
1986 
1987     def visit_meta(self, node: Element) -> None:
1988         # only valid for HTML
1989         raise nodes.SkipNode
1990 
1991     def visit_system_message(self, node: Element) -> None:
1992         pass
1993 
1994     def depart_system_message(self, node: Element) -> None:
1995         self.body.append(CR)
1996 
1997     def visit_math(self, node: Element) -> None:
1998         if self.in_title:
1999             self.body.append(r'\protect\(%s\protect\)' % node.astext())
2000         else:
2001             self.body.append(r'\(%s\)' % node.astext())
2002         raise nodes.SkipNode
2003 
2004     def visit_math_block(self, node: Element) -> None:
2005         if node.get('label'):
2006             label = "equation:%s:%s" % (node['docname'], node['label'])
2007         else:
2008             label = None
2009 
2010         if node.get('nowrap'):
2011             if label:
2012                 self.body.append(r'\label{%s}' % label)
2013             self.body.append(node.astext())
2014         else:
2015             from sphinx.util.math import wrap_displaymath
2016             self.body.append(wrap_displaymath(node.astext(), label,
2017                                               self.config.math_number_all))
2018         raise nodes.SkipNode
2019 
2020     def visit_math_reference(self, node: Element) -> None:
2021         label = "equation:%s:%s" % (node['docname'], node['target'])
2022         eqref_format = self.config.math_eqref_format
2023         if eqref_format:
2024             try:
2025                 ref = r'\ref{%s}' % label
2026                 self.body.append(eqref_format.format(number=ref))
2027             except KeyError as exc:
2028                 logger.warning(__('Invalid math_eqref_format: %r'), exc,
2029                                location=node)
2030                 self.body.append(r'\eqref{%s}' % label)
2031         else:
2032             self.body.append(r'\eqref{%s}' % label)
2033 
2034     def depart_math_reference(self, node: Element) -> None:
2035         pass
2036 
2037     def unknown_visit(self, node: Node) -> None:
2038         raise NotImplementedError('Unknown node: ' + node.__class__.__name__)
2039 
2040     @property
2041     def docclasses(self) -> Tuple[str, str]:
2042         """Prepends prefix to sphinx document classes"""
2043         warnings.warn('LaTeXWriter.docclasses() is deprecated.',
2044                       RemovedInSphinx70Warning, stacklevel=2)
2045         return ('howto', 'manual')
2046 
2047 
2048 # FIXME: Workaround to avoid circular import
2049 # refs: https://github.com/sphinx-doc/sphinx/issues/5433
2050 from sphinx.builders.latex.nodes import ( # NOQA isort:skip
2051     HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,
2052 )

</code><intended_behavior>The glossary processing method should maintain compact formatting between terms that share a common description, avoiding excessive vertical whitespace in the LaTeX output. This might involve introducing or modifying spacing controls in the LaTeX commands generated for glossary entries or improving the handling of grouped glossary terms to ensure that the LaTeX output closely mirrors the intended layout specified in the rst document.</intended_behavior>]
2025-10-16 00:18:44.210 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 00:18:44.210 | INFO     | Search-only: skipping patch selection
2025-10-16 00:18:44.351 | INFO     | Task sphinx-doc__sphinx-9999 completed successfully.
2025-10-16 00:18:44.352 | INFO     | No patch generated. You can try running ACR again.
