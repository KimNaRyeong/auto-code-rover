[
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/core/expr.py",
        "start": 1920,
        "end": 2026,
        "class_name": "Expr",
        "method_name": "extract_multiplicatively",
        "code": "1920     def extract_multiplicatively(self, c):\n1921         \"\"\"Return None if it's not possible to make self in the form\n1922            c * something in a nice way, i.e. preserving the properties\n1923            of arguments of self.\n1924 \n1925            >>> from sympy import symbols, Rational\n1926 \n1927            >>> x, y = symbols('x,y', real=True)\n1928 \n1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n1930            x*y**2\n1931 \n1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n1933 \n1934            >>> (2*x).extract_multiplicatively(2)\n1935            x\n1936 \n1937            >>> (2*x).extract_multiplicatively(3)\n1938 \n1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n1940            x/6\n1941 \n1942         \"\"\"\n1943         c = sympify(c)\n1944         if self is S.NaN:\n1945             return None\n1946         if c is S.One:\n1947             return self\n1948         elif c == self:\n1949             return S.One\n1950         if c.is_Add:\n1951             cc, pc = c.primitive()\n1952             if cc is not S.One:\n1953                 c = Mul(cc, pc, evaluate=False)\n1954         if c.is_Mul:\n1955             a, b = c.as_two_terms()\n1956             x = self.extract_multiplicatively(a)\n1957             if x is not None:\n1958                 return x.extract_multiplicatively(b)\n1959         quotient = self / c\n1960         if self.is_Number:\n1961             if self is S.Infinity:\n1962                 if c.is_positive:\n1963                     return S.Infinity\n1964             elif self is S.NegativeInfinity:\n1965                 if c.is_negative:\n1966                     return S.Infinity\n1967                 elif c.is_positive:\n1968                     return S.NegativeInfinity\n1969             elif self is S.ComplexInfinity:\n1970                 if not c.is_zero:\n1971                     return S.ComplexInfinity\n1972             elif self.is_Integer:\n1973                 if not quotient.is_Integer:\n1974                     return None\n1975                 elif self.is_positive and quotient.is_negative:\n1976                     return None\n1977                 else:\n1978                     return quotient\n1979             elif self.is_Rational:\n1980                 if not quotient.is_Rational:\n1981                     return None\n1982                 elif self.is_positive and quotient.is_negative:\n1983                     return None\n1984                 else:\n1985                     return quotient\n1986             elif self.is_Float:\n1987                 if not quotient.is_Float:\n1988                     return None\n1989                 elif self.is_positive and quotient.is_negative:\n1990                     return None\n1991                 else:\n1992                     return quotient\n1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n1994             if quotient.is_Mul and len(quotient.args) == 2:\n1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n1996                     return quotient\n1997             elif quotient.is_Integer and c.is_Number:\n1998                 return quotient\n1999         elif self.is_Add:\n2000             cs, ps = self.primitive()\n2001             if cs is not S.One:\n2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)\n2003             newargs = []\n2004             for arg in self.args:\n2005                 newarg = arg.extract_multiplicatively(c)\n2006                 if newarg is not None:\n2007                     newargs.append(newarg)\n2008                 else:\n2009                     return None\n2010             return Add(*newargs)\n2011         elif self.is_Mul:\n2012             args = list(self.args)\n2013             for i, arg in enumerate(args):\n2014                 newarg = arg.extract_multiplicatively(c)\n2015                 if newarg is not None:\n2016                     args[i] = newarg\n2017                     return Mul(*args)\n2018         elif self.is_Pow:\n2019             if c.is_Pow and c.base == self.base:\n2020                 new_exp = self.exp.extract_additively(c.exp)\n2021                 if new_exp is not None:\n2022                     return self.base ** (new_exp)\n2023             elif c == self.base:\n2024                 new_exp = self.exp.extract_additively(1)\n2025                 if new_exp is not None:\n2026                     return self.base ** (new_exp)\n",
        "intended_behavior": "This method should be able to correctly handle the case when attempting to extract a negative factor from an expression, particularly when that expression is constructed with Mul(..., evaluate=False). It appears that when a negative factor that matches the negative content of an expression is to be extracted, the method fails to return the correct factored expression. The intended behavior would involve checking if the expression can be divided by the given factor c in a way that maintains the integrity and properties of the original expression, even when evaluate=False has led to a non-standard representation of the expression. This can include better handling or normalization of expressions involving negative factors or ensuring that the Mul objects with evaluate=False are correctly interpreted and simplified if possible before attempting to extract multiplicatively."
    },
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/core/expr.py",
        "start": 15,
        "end": 3227,
        "class_name": "Expr",
        "method_name": null,
        "code": "15 class Expr(Basic, EvalfMixin):\n16     \"\"\"\n17     Base class for algebraic expressions.\n18 \n19     Everything that requires arithmetic operations to be defined\n20     should subclass this class, instead of Basic (which should be\n21     used only for argument storage and expression manipulation, i.e.\n22     pattern matching, substitutions, etc).\n23 \n24     See Also\n25     ========\n26 \n27     sympy.core.basic.Basic\n28     \"\"\"\n29 \n30     __slots__ = []\n31 \n32     @property\n33     def _diff_wrt(self):\n34         \"\"\"Is it allowed to take derivative wrt to this instance.\n35 \n36         This determines if it is allowed to take derivatives wrt this object.\n37         Subclasses such as Symbol, Function and Derivative should return True\n38         to enable derivatives wrt them. The implementation in Derivative\n39         separates the Symbol and non-Symbol _diff_wrt=True variables and\n40         temporarily converts the non-Symbol vars in Symbols when performing\n41         the differentiation.\n42 \n43         Note, see the docstring of Derivative for how this should work\n44         mathematically. In particular, note that expr.subs(yourclass, Symbol)\n45         should be well-defined on a structural level, or this will lead to\n46         inconsistent results.\n47 \n48         Examples\n49         ========\n50 \n51         >>> from sympy import Expr\n52         >>> e = Expr()\n53         >>> e._diff_wrt\n54         False\n55         >>> class MyClass(Expr):\n56         ...     _diff_wrt = True\n57         ...\n58         >>> (2*MyClass()).diff(MyClass())\n59         2\n60         \"\"\"\n61         return False\n62 \n63     @cacheit\n64     def sort_key(self, order=None):\n65 \n66         coeff, expr = self.as_coeff_Mul()\n67 \n68         if expr.is_Pow:\n69             expr, exp = expr.args\n70         else:\n71             expr, exp = expr, S.One\n72 \n73         if expr.is_Dummy:\n74             args = (expr.sort_key(),)\n75         elif expr.is_Atom:\n76             args = (str(expr),)\n77         else:\n78             if expr.is_Add:\n79                 args = expr.as_ordered_terms(order=order)\n80             elif expr.is_Mul:\n81                 args = expr.as_ordered_factors(order=order)\n82             else:\n83                 args = expr.args\n84 \n85             args = tuple(\n86                 [ default_sort_key(arg, order=order) for arg in args ])\n87 \n88         args = (len(args), tuple(args))\n89         exp = exp.sort_key(order=order)\n90 \n91         return expr.class_key(), args, exp, coeff\n92 \n93     # ***************\n94     # * Arithmetics *\n95     # ***************\n96     # Expr and its sublcasses use _op_priority to determine which object\n97     # passed to a binary special method (__mul__, etc.) will handle the\n98     # operation. In general, the 'call_highest_priority' decorator will choose\n99     # the object with the highest _op_priority to handle the call.\n100     # Custom subclasses that want to define their own binary special methods\n101     # should set an _op_priority value that is higher than the default.\n102     #\n103     # **NOTE**:\n104     # This is a temporary fix, and will eventually be replaced with\n105     # something better and more powerful.  See issue 5510.\n106     _op_priority = 10.0\n107 \n108     def __pos__(self):\n109         return self\n110 \n111     def __neg__(self):\n112         return Mul(S.NegativeOne, self)\n113 \n114     def __abs__(self):\n115         from sympy import Abs\n116         return Abs(self)\n117 \n118     @_sympifyit('other', NotImplemented)\n119     @call_highest_priority('__radd__')\n120     def __add__(self, other):\n121         return Add(self, other)\n122 \n123     @_sympifyit('other', NotImplemented)\n124     @call_highest_priority('__add__')\n125     def __radd__(self, other):\n126         return Add(other, self)\n127 \n128     @_sympifyit('other', NotImplemented)\n129     @call_highest_priority('__rsub__')\n130     def __sub__(self, other):\n131         return Add(self, -other)\n132 \n133     @_sympifyit('other', NotImplemented)\n134     @call_highest_priority('__sub__')\n135     def __rsub__(self, other):\n136         return Add(other, -self)\n137 \n138     @_sympifyit('other', NotImplemented)\n139     @call_highest_priority('__rmul__')\n140     def __mul__(self, other):\n141         return Mul(self, other)\n142 \n143     @_sympifyit('other', NotImplemented)\n144     @call_highest_priority('__mul__')\n145     def __rmul__(self, other):\n146         return Mul(other, self)\n147 \n148     @_sympifyit('other', NotImplemented)\n149     @call_highest_priority('__rpow__')\n150     def __pow__(self, other):\n151         return Pow(self, other)\n152 \n153     @_sympifyit('other', NotImplemented)\n154     @call_highest_priority('__pow__')\n155     def __rpow__(self, other):\n156         return Pow(other, self)\n157 \n158     @_sympifyit('other', NotImplemented)\n159     @call_highest_priority('__rdiv__')\n160     def __div__(self, other):\n161         return Mul(self, Pow(other, S.NegativeOne))\n162 \n163     @_sympifyit('other', NotImplemented)\n164     @call_highest_priority('__div__')\n165     def __rdiv__(self, other):\n166         return Mul(other, Pow(self, S.NegativeOne))\n167 \n168     __truediv__ = __div__\n169     __rtruediv__ = __rdiv__\n170 \n171     @_sympifyit('other', NotImplemented)\n172     @call_highest_priority('__rmod__')\n173     def __mod__(self, other):\n174         return Mod(self, other)\n175 \n176     @_sympifyit('other', NotImplemented)\n177     @call_highest_priority('__mod__')\n178     def __rmod__(self, other):\n179         return Mod(other, self)\n180 \n181     @_sympifyit('other', NotImplemented)\n182     @call_highest_priority('__rfloordiv__')\n183     def __floordiv__(self, other):\n184         from sympy.functions.elementary.integers import floor\n185         return floor(self / other)\n186 \n187     @_sympifyit('other', NotImplemented)\n188     @call_highest_priority('__floordiv__')\n189     def __rfloordiv__(self, other):\n190         from sympy.functions.elementary.integers import floor\n191         return floor(self / other)\n192 \n193     def __int__(self):\n194         # Although we only need to round to the units position, we'll\n195         # get one more digit so the extra testing below can be avoided\n196         # unless the rounded value rounded to an integer, e.g. if an\n197         # expression were equal to 1.9 and we rounded to the unit position\n198         # we would get a 2 and would not know if this rounded up or not\n199         # without doing a test (as done below). But if we keep an extra\n200         # digit we know that 1.9 is not the same as 1 and there is no\n201         # need for further testing: our int value is correct. If the value\n202         # were 1.99, however, this would round to 2.0 and our int value is\n203         # off by one. So...if our round value is the same as the int value\n204         # (regardless of how much extra work we do to calculate extra decimal\n205         # places) we need to test whether we are off by one.\n206         from sympy import Dummy\n207         if not self.is_number:\n208             raise TypeError(\"can't convert symbols to int\")\n209         r = self.round(2)\n210         if not r.is_Number:\n211             raise TypeError(\"can't convert complex to int\")\n212         if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n213             raise TypeError(\"can't convert %s to int\" % r)\n214         i = int(r)\n215         if not i:\n216             return 0\n217         # off-by-one check\n218         if i == r and not (self - i).equals(0):\n219             isign = 1 if i > 0 else -1\n220             x = Dummy()\n221             # in the following (self - i).evalf(2) will not always work while\n222             # (self - r).evalf(2) and the use of subs does; if the test that\n223             # was added when this comment was added passes, it might be safe\n224             # to simply use sign to compute this rather than doing this by hand:\n225             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1\n226             if diff_sign != isign:\n227                 i -= isign\n228         return i\n229     __long__ = __int__\n230 \n231     def __float__(self):\n232         # Don't bother testing if it's a number; if it's not this is going\n233         # to fail, and if it is we still need to check that it evalf'ed to\n234         # a number.\n235         result = self.evalf()\n236         if result.is_Number:\n237             return float(result)\n238         if result.is_number and result.as_real_imag()[1]:\n239             raise TypeError(\"can't convert complex to float\")\n240         raise TypeError(\"can't convert expression to float\")\n241 \n242     def __complex__(self):\n243         result = self.evalf()\n244         re, im = result.as_real_imag()\n245         return complex(float(re), float(im))\n246 \n247     def __ge__(self, other):\n248         from sympy import GreaterThan\n249         try:\n250             other = _sympify(other)\n251         except SympifyError:\n252             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n253         for me in (self, other):\n254             if (me.is_complex and me.is_real is False) or \\\n255                     me.has(S.ComplexInfinity):\n256                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n257             if me is S.NaN:\n258                 raise TypeError(\"Invalid NaN comparison\")\n259         if self.is_real or other.is_real:\n260             dif = self - other\n261             if dif.is_nonnegative is not None and \\\n262                     dif.is_nonnegative is not dif.is_negative:\n263                 return sympify(dif.is_nonnegative)\n264         return GreaterThan(self, other, evaluate=False)\n265 \n266     def __le__(self, other):\n267         from sympy import LessThan\n268         try:\n269             other = _sympify(other)\n270         except SympifyError:\n271             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n272         for me in (self, other):\n273             if (me.is_complex and me.is_real is False) or \\\n274                     me.has(S.ComplexInfinity):\n275                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n276             if me is S.NaN:\n277                 raise TypeError(\"Invalid NaN comparison\")\n278         if self.is_real or other.is_real:\n279             dif = self - other\n280             if dif.is_nonpositive is not None and \\\n281                     dif.is_nonpositive is not dif.is_positive:\n282                 return sympify(dif.is_nonpositive)\n283         return LessThan(self, other, evaluate=False)\n284 \n285     def __gt__(self, other):\n286         from sympy import StrictGreaterThan\n287         try:\n288             other = _sympify(other)\n289         except SympifyError:\n290             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n291         for me in (self, other):\n292             if (me.is_complex and me.is_real is False) or \\\n293                     me.has(S.ComplexInfinity):\n294                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n295             if me is S.NaN:\n296                 raise TypeError(\"Invalid NaN comparison\")\n297         if self.is_real or other.is_real:\n298             dif = self - other\n299             if dif.is_positive is not None and \\\n300                     dif.is_positive is not dif.is_nonpositive:\n301                 return sympify(dif.is_positive)\n302         return StrictGreaterThan(self, other, evaluate=False)\n303 \n304     def __lt__(self, other):\n305         from sympy import StrictLessThan\n306         try:\n307             other = _sympify(other)\n308         except SympifyError:\n309             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n310         for me in (self, other):\n311             if (me.is_complex and me.is_real is False) or \\\n312                     me.has(S.ComplexInfinity):\n313                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n314             if me is S.NaN:\n315                 raise TypeError(\"Invalid NaN comparison\")\n316         if self.is_real or other.is_real:\n317             dif = self - other\n318             if dif.is_negative is not None and \\\n319                     dif.is_negative is not dif.is_nonnegative:\n320                 return sympify(dif.is_negative)\n321         return StrictLessThan(self, other, evaluate=False)\n322 \n323     @staticmethod\n324     def _from_mpmath(x, prec):\n325         from sympy import Float\n326         if hasattr(x, \"_mpf_\"):\n327             return Float._new(x._mpf_, prec)\n328         elif hasattr(x, \"_mpc_\"):\n329             re, im = x._mpc_\n330             re = Float._new(re, prec)\n331             im = Float._new(im, prec)*S.ImaginaryUnit\n332             return re + im\n333         else:\n334             raise TypeError(\"expected mpmath number (mpf or mpc)\")\n335 \n336     @property\n337     def is_number(self):\n338         \"\"\"Returns True if 'self' has no free symbols.\n339         It will be faster than `if not self.free_symbols`, however, since\n340         `is_number` will fail as soon as it hits a free symbol.\n341 \n342         Examples\n343         ========\n344 \n345         >>> from sympy import log, Integral\n346         >>> from sympy.abc import x\n347 \n348         >>> x.is_number\n349         False\n350         >>> (2*x).is_number\n351         False\n352         >>> (2 + log(2)).is_number\n353         True\n354         >>> (2 + Integral(2, x)).is_number\n355         False\n356         >>> (2 + Integral(2, (x, 1, 2))).is_number\n357         True\n358 \n359         \"\"\"\n360         return all(obj.is_number for obj in self.args)\n361 \n362     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n363         \"\"\"Return self evaluated, if possible, replacing free symbols with\n364         random complex values, if necessary.\n365 \n366         The random complex value for each free symbol is generated\n367         by the random_complex_number routine giving real and imaginary\n368         parts in the range given by the re_min, re_max, im_min, and im_max\n369         values. The returned value is evaluated to a precision of n\n370         (if given) else the maximum of 15 and the precision needed\n371         to get more than 1 digit of precision. If the expression\n372         could not be evaluated to a number, or could not be evaluated\n373         to more than 1 digit of precision, then None is returned.\n374 \n375         Examples\n376         ========\n377 \n378         >>> from sympy import sqrt\n379         >>> from sympy.abc import x, y\n380         >>> x._random()                         # doctest: +SKIP\n381         0.0392918155679172 + 0.916050214307199*I\n382         >>> x._random(2)                        # doctest: +SKIP\n383         -0.77 - 0.87*I\n384         >>> (x + y/2)._random(2)                # doctest: +SKIP\n385         -0.57 + 0.16*I\n386         >>> sqrt(2)._random(2)\n387         1.4\n388 \n389         See Also\n390         ========\n391 \n392         sympy.utilities.randtest.random_complex_number\n393         \"\"\"\n394 \n395         free = self.free_symbols\n396         prec = 1\n397         if free:\n398             from sympy.utilities.randtest import random_complex_number\n399             a, c, b, d = re_min, re_max, im_min, im_max\n400             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n401                            for zi in free])))\n402             try:\n403                 nmag = abs(self.evalf(2, subs=reps))\n404             except (ValueError, TypeError):\n405                 # if an out of range value resulted in evalf problems\n406                 # then return None -- XXX is there a way to know how to\n407                 # select a good random number for a given expression?\n408                 # e.g. when calculating n! negative values for n should not\n409                 # be used\n410                 return None\n411         else:\n412             reps = {}\n413             nmag = abs(self.evalf(2))\n414 \n415         if not hasattr(nmag, '_prec'):\n416             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n417             return None\n418 \n419         if nmag._prec == 1:\n420             # increase the precision up to the default maximum\n421             # precision to see if we can get any significance\n422 \n423             from mpmath.libmp.libintmath import giant_steps\n424             from sympy.core.evalf import DEFAULT_MAXPREC as target\n425 \n426             # evaluate\n427             for prec in giant_steps(2, target):\n428                 nmag = abs(self.evalf(prec, subs=reps))\n429                 if nmag._prec != 1:\n430                     break\n431 \n432         if nmag._prec != 1:\n433             if n is None:\n434                 n = max(prec, 15)\n435             return self.evalf(n, subs=reps)\n436 \n437         # never got any significance\n438         return None\n439 \n440     def is_constant(self, *wrt, **flags):\n441         \"\"\"Return True if self is constant, False if not, or None if\n442         the constancy could not be determined conclusively.\n443 \n444         If an expression has no free symbols then it is a constant. If\n445         there are free symbols it is possible that the expression is a\n446         constant, perhaps (but not necessarily) zero. To test such\n447         expressions, two strategies are tried:\n448 \n449         1) numerical evaluation at two random points. If two such evaluations\n450         give two different values and the values have a precision greater than\n451         1 then self is not constant. If the evaluations agree or could not be\n452         obtained with any precision, no decision is made. The numerical testing\n453         is done only if ``wrt`` is different than the free symbols.\n454 \n455         2) differentiation with respect to variables in 'wrt' (or all free\n456         symbols if omitted) to see if the expression is constant or not. This\n457         will not always lead to an expression that is zero even though an\n458         expression is constant (see added test in test_expr.py). If\n459         all derivatives are zero then self is constant with respect to the\n460         given symbols.\n461 \n462         If neither evaluation nor differentiation can prove the expression is\n463         constant, None is returned unless two numerical values happened to be\n464         the same and the flag ``failing_number`` is True -- in that case the\n465         numerical value will be returned.\n466 \n467         If flag simplify=False is passed, self will not be simplified;\n468         the default is True since self should be simplified before testing.\n469 \n470         Examples\n471         ========\n472 \n473         >>> from sympy import cos, sin, Sum, S, pi\n474         >>> from sympy.abc import a, n, x, y\n475         >>> x.is_constant()\n476         False\n477         >>> S(2).is_constant()\n478         True\n479         >>> Sum(x, (x, 1, 10)).is_constant()\n480         True\n481         >>> Sum(x, (x, 1, n)).is_constant()\n482         False\n483         >>> Sum(x, (x, 1, n)).is_constant(y)\n484         True\n485         >>> Sum(x, (x, 1, n)).is_constant(n)\n486         False\n487         >>> Sum(x, (x, 1, n)).is_constant(x)\n488         True\n489         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n490         >>> eq.is_constant()\n491         True\n492         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n493         True\n494 \n495         >>> (0**x).is_constant()\n496         False\n497         >>> x.is_constant()\n498         False\n499         >>> (x**x).is_constant()\n500         False\n501         >>> one = cos(x)**2 + sin(x)**2\n502         >>> one.is_constant()\n503         True\n504         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n505         True\n506         \"\"\"\n507 \n508         simplify = flags.get('simplify', True)\n509 \n510         # Except for expressions that contain units, only one of these should\n511         # be necessary since if something is\n512         # known to be a number it should also know that there are no\n513         # free symbols. But is_number quits as soon as it hits a non-number\n514         # whereas free_symbols goes until all free symbols have been collected,\n515         # thus is_number should be faster. But a double check on free symbols\n516         # is made just in case there is a discrepancy between the two.\n517         free = self.free_symbols\n518         if self.is_number or not free:\n519             # if the following assertion fails then that object's free_symbols\n520             # method needs attention: if an expression is a number it cannot\n521             # have free symbols\n522             assert not free\n523             return True\n524 \n525         # if we are only interested in some symbols and they are not in the\n526         # free symbols then this expression is constant wrt those symbols\n527         wrt = set(wrt)\n528         if wrt and not wrt & free:\n529             return True\n530         wrt = wrt or free\n531 \n532         # simplify unless this has already been done\n533         expr = self\n534         if simplify:\n535             expr = expr.simplify()\n536 \n537         # is_zero should be a quick assumptions check; it can be wrong for\n538         # numbers (see test_is_not_constant test), giving False when it\n539         # shouldn't, but hopefully it will never give True unless it is sure.\n540         if expr.is_zero:\n541             return True\n542 \n543         # try numerical evaluation to see if we get two different values\n544         failing_number = None\n545         if wrt == free:\n546             # try 0 (for a) and 1 (for b)\n547             try:\n548                 a = expr.subs(list(zip(free, [0]*len(free))),\n549                     simultaneous=True)\n550                 if a is S.NaN:\n551                     # evaluation may succeed when substitution fails\n552                     a = expr._random(None, 0, 0, 0, 0)\n553             except ZeroDivisionError:\n554                 a = None\n555             if a is not None and a is not S.NaN:\n556                 try:\n557                     b = expr.subs(list(zip(free, [1]*len(free))),\n558                         simultaneous=True)\n559                     if b is S.NaN:\n560                         # evaluation may succeed when substitution fails\n561                         b = expr._random(None, 1, 0, 1, 0)\n562                 except ZeroDivisionError:\n563                     b = None\n564                 if b is not None and b is not S.NaN and b.equals(a) is False:\n565                     return False\n566                 # try random real\n567                 b = expr._random(None, -1, 0, 1, 0)\n568                 if b is not None and b is not S.NaN and b.equals(a) is False:\n569                     return False\n570                 # try random complex\n571                 b = expr._random()\n572                 if b is not None and b is not S.NaN:\n573                     if b.equals(a) is False:\n574                         return False\n575                     failing_number = a if a.is_number else b\n576 \n577         # now we will test each wrt symbol (or all free symbols) to see if the\n578         # expression depends on them or not using differentiation. This is\n579         # not sufficient for all expressions, however, so we don't return\n580         # False if we get a derivative other than 0 with free symbols.\n581         for w in wrt:\n582             deriv = expr.diff(w)\n583             if simplify:\n584                 deriv = deriv.simplify()\n585             if deriv != 0:\n586                 if not (pure_complex(deriv, or_real=True)):\n587                     if flags.get('failing_number', False):\n588                         return failing_number\n589                     elif deriv.free_symbols:\n590                         # dead line provided _random returns None in such cases\n591                         return None\n592                 return False\n593         return True\n594 \n595     def equals(self, other, failing_expression=False):\n596         \"\"\"Return True if self == other, False if it doesn't, or None. If\n597         failing_expression is True then the expression which did not simplify\n598         to a 0 will be returned instead of None.\n599 \n600         If ``self`` is a Number (or complex number) that is not zero, then\n601         the result is False.\n602 \n603         If ``self`` is a number and has not evaluated to zero, evalf will be\n604         used to test whether the expression evaluates to zero. If it does so\n605         and the result has significance (i.e. the precision is either -1, for\n606         a Rational result, or is greater than 1) then the evalf value will be\n607         used to return True or False.\n608 \n609         \"\"\"\n610         from sympy.simplify.simplify import nsimplify, simplify\n611         from sympy.solvers.solveset import solveset\n612         from sympy.polys.polyerrors import NotAlgebraic\n613         from sympy.polys.numberfields import minimal_polynomial\n614 \n615         other = sympify(other)\n616         if self == other:\n617             return True\n618 \n619         # they aren't the same so see if we can make the difference 0;\n620         # don't worry about doing simplification steps one at a time\n621         # because if the expression ever goes to 0 then the subsequent\n622         # simplification steps that are done will be very fast.\n623         diff = factor_terms(simplify(self - other), radical=True)\n624 \n625         if not diff:\n626             return True\n627 \n628         if not diff.has(Add, Mod):\n629             # if there is no expanding to be done after simplifying\n630             # then this can't be a zero\n631             return False\n632 \n633         constant = diff.is_constant(simplify=False, failing_number=True)\n634 \n635         if constant is False:\n636             return False\n637 \n638         if constant is None and (diff.free_symbols or not diff.is_number):\n639             # e.g. unless the right simplification is done, a symbolic\n640             # zero is possible (see expression of issue 6829: without\n641             # simplification constant will be None).\n642             return\n643 \n644         if constant is True:\n645             ndiff = diff._random()\n646             if ndiff:\n647                 return False\n648 \n649         # sometimes we can use a simplified result to give a clue as to\n650         # what the expression should be; if the expression is *not* zero\n651         # then we should have been able to compute that and so now\n652         # we can just consider the cases where the approximation appears\n653         # to be zero -- we try to prove it via minimal_polynomial.\n654         if diff.is_number:\n655             approx = diff.nsimplify()\n656             if not approx:\n657                 # try to prove via self-consistency\n658                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n659                 # it seems to work better to try big ones first\n660                 surds.sort(key=lambda x: -x.args[0])\n661                 for s in surds:\n662                     try:\n663                         # simplify is False here -- this expression has already\n664                         # been identified as being hard to identify as zero;\n665                         # we will handle the checking ourselves using nsimplify\n666                         # to see if we are in the right ballpark or not and if so\n667                         # *then* the simplification will be attempted.\n668                         if s.is_Symbol:\n669                             sol = list(solveset(diff, s))\n670                         else:\n671                             sol = [s]\n672                         if sol:\n673                             if s in sol:\n674                                 return True\n675                             if s.is_real:\n676                                 if any(nsimplify(si, [s]) == s and simplify(si) == s\n677                                         for si in sol):\n678                                     return True\n679                     except NotImplementedError:\n680                         pass\n681 \n682                 # try to prove with minimal_polynomial but know when\n683                 # *not* to use this or else it can take a long time. e.g. issue 8354\n684                 if True:  # change True to condition that assures non-hang\n685                     try:\n686                         mp = minimal_polynomial(diff)\n687                         if mp.is_Symbol:\n688                             return True\n689                         return False\n690                     except (NotAlgebraic, NotImplementedError):\n691                         pass\n692 \n693         # diff has not simplified to zero; constant is either None, True\n694         # or the number with significance (prec != 1) that was randomly\n695         # calculated twice as the same value.\n696         if constant not in (True, None) and constant != 0:\n697             return False\n698 \n699         if failing_expression:\n700             return diff\n701         return None\n702 \n703     def _eval_is_positive(self):\n704         from sympy.polys.numberfields import minimal_polynomial\n705         from sympy.polys.polyerrors import NotAlgebraic\n706         if self.is_number:\n707             if self.is_real is False:\n708                 return False\n709             try:\n710                 # check to see that we can get a value\n711                 n2 = self._eval_evalf(2)\n712                 if n2 is None:\n713                     raise AttributeError\n714                 if n2._prec == 1:  # no significance\n715                     raise AttributeError\n716                 if n2 == S.NaN:\n717                     raise AttributeError\n718             except (AttributeError, ValueError):\n719                 return None\n720             n, i = self.evalf(2).as_real_imag()\n721             if not i.is_Number or not n.is_Number:\n722                 return False\n723             if n._prec != 1 and i._prec != 1:\n724                 return bool(not i and n > 0)\n725             elif n._prec == 1 and (not i or i._prec == 1) and \\\n726                     self.is_algebraic and not self.has(Function):\n727                 try:\n728                     if minimal_polynomial(self).is_Symbol:\n729                         return False\n730                 except (NotAlgebraic, NotImplementedError):\n731                     pass\n732 \n733     def _eval_is_negative(self):\n734         from sympy.polys.numberfields import minimal_polynomial\n735         from sympy.polys.polyerrors import NotAlgebraic\n736         if self.is_number:\n737             if self.is_real is False:\n738                 return False\n739             try:\n740                 # check to see that we can get a value\n741                 n2 = self._eval_evalf(2)\n742                 if n2 is None:\n743                     raise AttributeError\n744                 if n2._prec == 1:  # no significance\n745                     raise AttributeError\n746                 if n2 == S.NaN:\n747                     raise AttributeError\n748             except (AttributeError, ValueError):\n749                 return None\n750             n, i = self.evalf(2).as_real_imag()\n751             if not i.is_Number or not n.is_Number:\n752                 return False\n753             if n._prec != 1 and i._prec != 1:\n754                 return bool(not i and n < 0)\n755             elif n._prec == 1 and (not i or i._prec == 1) and \\\n756                     self.is_algebraic and not self.has(Function):\n757                 try:\n758                     if minimal_polynomial(self).is_Symbol:\n759                         return False\n760                 except (NotAlgebraic, NotImplementedError):\n761                     pass\n762 \n763     def _eval_interval(self, x, a, b):\n764         \"\"\"\n765         Returns evaluation over an interval.  For most functions this is:\n766 \n767         self.subs(x, b) - self.subs(x, a),\n768 \n769         possibly using limit() if NaN is returned from subs.\n770 \n771         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),\n772         respectively.\n773 \n774         \"\"\"\n775         from sympy.series import limit, Limit\n776         from sympy.solvers.solveset import solveset\n777 \n778         if (a is None and b is None):\n779             raise ValueError('Both interval ends cannot be None.')\n780 \n781         if a == b:\n782             return 0;\n783 \n784         if a is None:\n785             A = 0\n786         else:\n787             A = self.subs(x, a)\n788             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n789                 if (a < b) != False:\n790                     A = limit(self, x, a,\"+\")\n791                 else:\n792                     A = limit(self, x, a,\"-\")\n793 \n794                 if A is S.NaN:\n795                     return A\n796                 if isinstance(A, Limit):\n797                     raise NotImplementedError(\"Could not compute limit\")\n798 \n799         if b is None:\n800             B = 0\n801         else:\n802             B = self.subs(x, b)\n803             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n804                 if (a < b) != False:\n805                     B = limit(self, x, b,\"-\")\n806                 else:\n807                     B = limit(self, x, b,\"+\")\n808 \n809                 if isinstance(B, Limit):\n810                     raise NotImplementedError(\"Could not compute limit\")\n811 \n812         if (a and b) is None:\n813             return B - A\n814 \n815         value = B - A\n816 \n817         if a.is_comparable and b.is_comparable:\n818             singularities = list(solveset(self.cancel().as_numer_denom()[1], x))\n819             for s in singularities:\n820                 if a < s < b:\n821                     value += -limit(self, x, s, \"+\") + limit(self, x, s, \"-\")\n822                 elif b < s < a:\n823                     value += limit(self, x, s, \"+\") - limit(self, x, s, \"-\")\n824 \n825         return value\n826 \n827     def _eval_power(self, other):\n828         # subclass to compute self**other for cases when\n829         # other is not NaN, 0, or 1\n830         return None\n831 \n832     def _eval_conjugate(self):\n833         if self.is_real:\n834             return self\n835         elif self.is_imaginary:\n836             return -self\n837 \n838     def conjugate(self):\n839         from sympy.functions.elementary.complexes import conjugate as c\n840         return c(self)\n841 \n842     def _eval_transpose(self):\n843         from sympy.functions.elementary.complexes import conjugate\n844         if self.is_complex:\n845             return self\n846         elif self.is_hermitian:\n847             return conjugate(self)\n848         elif self.is_antihermitian:\n849             return -conjugate(self)\n850 \n851     def transpose(self):\n852         from sympy.functions.elementary.complexes import transpose\n853         return transpose(self)\n854 \n855     def _eval_adjoint(self):\n856         from sympy.functions.elementary.complexes import conjugate, transpose\n857         if self.is_hermitian:\n858             return self\n859         elif self.is_antihermitian:\n860             return -self\n861         obj = self._eval_conjugate()\n862         if obj is not None:\n863             return transpose(obj)\n864         obj = self._eval_transpose()\n865         if obj is not None:\n866             return conjugate(obj)\n867 \n868     def adjoint(self):\n869         from sympy.functions.elementary.complexes import adjoint\n870         return adjoint(self)\n871 \n872     @classmethod\n873     def _parse_order(cls, order):\n874         \"\"\"Parse and configure the ordering of terms. \"\"\"\n875         from sympy.polys.orderings import monomial_key\n876 \n877         try:\n878             reverse = order.startswith('rev-')\n879         except AttributeError:\n880             reverse = False\n881         else:\n882             if reverse:\n883                 order = order[4:]\n884 \n885         monom_key = monomial_key(order)\n886 \n887         def neg(monom):\n888             result = []\n889 \n890             for m in monom:\n891                 if isinstance(m, tuple):\n892                     result.append(neg(m))\n893                 else:\n894                     result.append(-m)\n895 \n896             return tuple(result)\n897 \n898         def key(term):\n899             _, ((re, im), monom, ncpart) = term\n900 \n901             monom = neg(monom_key(monom))\n902             ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n903             coeff = ((bool(im), im), (re, im))\n904 \n905             return monom, ncpart, coeff\n906 \n907         return key, reverse\n908 \n909     def as_ordered_factors(self, order=None):\n910         \"\"\"Return list of ordered factors (if Mul) else [self].\"\"\"\n911         return [self]\n912 \n913     def as_ordered_terms(self, order=None, data=False):\n914         \"\"\"\n915         Transform an expression to an ordered list of terms.\n916 \n917         Examples\n918         ========\n919 \n920         >>> from sympy import sin, cos\n921         >>> from sympy.abc import x\n922 \n923         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n924         [sin(x)**2*cos(x), sin(x)**2, 1]\n925 \n926         \"\"\"\n927         key, reverse = self._parse_order(order)\n928         terms, gens = self.as_terms()\n929 \n930         if not any(term.is_Order for term, _ in terms):\n931             ordered = sorted(terms, key=key, reverse=reverse)\n932         else:\n933             _terms, _order = [], []\n934 \n935             for term, repr in terms:\n936                 if not term.is_Order:\n937                     _terms.append((term, repr))\n938                 else:\n939                     _order.append((term, repr))\n940 \n941             ordered = sorted(_terms, key=key, reverse=True) \\\n942                 + sorted(_order, key=key, reverse=True)\n943 \n944         if data:\n945             return ordered, gens\n946         else:\n947             return [term for term, _ in ordered]\n948 \n949     def as_terms(self):\n950         \"\"\"Transform an expression to a list of terms. \"\"\"\n951         from .add import Add\n952         from .mul import Mul\n953         from .exprtools import decompose_power\n954 \n955         gens, terms = set([]), []\n956 \n957         for term in Add.make_args(self):\n958             coeff, _term = term.as_coeff_Mul()\n959 \n960             coeff = complex(coeff)\n961             cpart, ncpart = {}, []\n962 \n963             if _term is not S.One:\n964                 for factor in Mul.make_args(_term):\n965                     if factor.is_number:\n966                         try:\n967                             coeff *= complex(factor)\n968                         except TypeError:\n969                             pass\n970                         else:\n971                             continue\n972 \n973                     if factor.is_commutative:\n974                         base, exp = decompose_power(factor)\n975 \n976                         cpart[base] = exp\n977                         gens.add(base)\n978                     else:\n979                         ncpart.append(factor)\n980 \n981             coeff = coeff.real, coeff.imag\n982             ncpart = tuple(ncpart)\n983 \n984             terms.append((term, (coeff, cpart, ncpart)))\n985 \n986         gens = sorted(gens, key=default_sort_key)\n987 \n988         k, indices = len(gens), {}\n989 \n990         for i, g in enumerate(gens):\n991             indices[g] = i\n992 \n993         result = []\n994 \n995         for term, (coeff, cpart, ncpart) in terms:\n996             monom = [0]*k\n997 \n998             for base, exp in cpart.items():\n999                 monom[indices[base]] = exp\n1000 \n1001             result.append((term, (coeff, tuple(monom), ncpart)))\n1002 \n1003         return result, gens\n1004 \n1005     def removeO(self):\n1006         \"\"\"Removes the additive O(..) symbol if there is one\"\"\"\n1007         return self\n1008 \n1009     def getO(self):\n1010         \"\"\"Returns the additive O(..) symbol if there is one, else None.\"\"\"\n1011         return None\n1012 \n1013     def getn(self):\n1014         \"\"\"\n1015         Returns the order of the expression.\n1016 \n1017         The order is determined either from the O(...) term. If there\n1018         is no O(...) term, it returns None.\n1019 \n1020         Examples\n1021         ========\n1022 \n1023         >>> from sympy import O\n1024         >>> from sympy.abc import x\n1025         >>> (1 + x + O(x**2)).getn()\n1026         2\n1027         >>> (1 + x).getn()\n1028 \n1029         \"\"\"\n1030         from sympy import Dummy, Symbol\n1031         o = self.getO()\n1032         if o is None:\n1033             return None\n1034         elif o.is_Order:\n1035             o = o.expr\n1036             if o is S.One:\n1037                 return S.Zero\n1038             if o.is_Symbol:\n1039                 return S.One\n1040             if o.is_Pow:\n1041                 return o.args[1]\n1042             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n\n1043                 for oi in o.args:\n1044                     if oi.is_Symbol:\n1045                         return S.One\n1046                     if oi.is_Pow:\n1047                         syms = oi.atoms(Symbol)\n1048                         if len(syms) == 1:\n1049                             x = syms.pop()\n1050                             oi = oi.subs(x, Dummy('x', positive=True))\n1051                             if oi.base.is_Symbol and oi.exp.is_Rational:\n1052                                 return abs(oi.exp)\n1053 \n1054         raise NotImplementedError('not sure of order of %s' % o)\n1055 \n1056     def count_ops(self, visual=None):\n1057         \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n1058         from .function import count_ops\n1059         return count_ops(self, visual)\n1060 \n1061     def args_cnc(self, cset=False, warn=True, split_1=True):\n1062         \"\"\"Return [commutative factors, non-commutative factors] of self.\n1063 \n1064         self is treated as a Mul and the ordering of the factors is maintained.\n1065         If ``cset`` is True the commutative factors will be returned in a set.\n1066         If there were repeated factors (as may happen with an unevaluated Mul)\n1067         then an error will be raised unless it is explicitly supressed by\n1068         setting ``warn`` to False.\n1069 \n1070         Note: -1 is always separated from a Number unless split_1 is False.\n1071 \n1072         >>> from sympy import symbols, oo\n1073         >>> A, B = symbols('A B', commutative=False)\n1074         >>> x, y = symbols('x y')\n1075         >>> (-2*x*y).args_cnc()\n1076         [[-1, 2, x, y], []]\n1077         >>> (-2.5*x).args_cnc()\n1078         [[-1, 2.5, x], []]\n1079         >>> (-2*x*A*B*y).args_cnc()\n1080         [[-1, 2, x, y], [A, B]]\n1081         >>> (-2*x*A*B*y).args_cnc(split_1=False)\n1082         [[-2, x, y], [A, B]]\n1083         >>> (-2*x*y).args_cnc(cset=True)\n1084         [{-1, 2, x, y}, []]\n1085 \n1086         The arg is always treated as a Mul:\n1087 \n1088         >>> (-2 + x + A).args_cnc()\n1089         [[], [x - 2 + A]]\n1090         >>> (-oo).args_cnc() # -oo is a singleton\n1091         [[-1, oo], []]\n1092         \"\"\"\n1093 \n1094         if self.is_Mul:\n1095             args = list(self.args)\n1096         else:\n1097             args = [self]\n1098         for i, mi in enumerate(args):\n1099             if not mi.is_commutative:\n1100                 c = args[:i]\n1101                 nc = args[i:]\n1102                 break\n1103         else:\n1104             c = args\n1105             nc = []\n1106 \n1107         if c and split_1 and (\n1108             c[0].is_Number and\n1109             c[0].is_negative and\n1110                 c[0] is not S.NegativeOne):\n1111             c[:1] = [S.NegativeOne, -c[0]]\n1112 \n1113         if cset:\n1114             clen = len(c)\n1115             c = set(c)\n1116             if clen and warn and len(c) != clen:\n1117                 raise ValueError('repeated commutative arguments: %s' %\n1118                                  [ci for ci in c if list(self.args).count(ci) > 1])\n1119         return [c, nc]\n1120 \n1121     def coeff(self, x, n=1, right=False):\n1122         \"\"\"\n1123         Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n1124         is zero then all terms independent of ``x`` will be returned.\n1125 \n1126         When ``x`` is noncommutative, the coefficient to the left (default) or\n1127         right of ``x`` can be returned. The keyword 'right' is ignored when\n1128         ``x`` is commutative.\n1129 \n1130         See Also\n1131         ========\n1132 \n1133         as_coefficient: separate the expression into a coefficient and factor\n1134         as_coeff_Add: separate the additive constant from an expression\n1135         as_coeff_Mul: separate the multiplicative constant from an expression\n1136         as_independent: separate x-dependent terms/factors from others\n1137         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1138         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1139 \n1140         Examples\n1141         ========\n1142 \n1143         >>> from sympy import symbols\n1144         >>> from sympy.abc import x, y, z\n1145 \n1146         You can select terms that have an explicit negative in front of them:\n1147 \n1148         >>> (-x + 2*y).coeff(-1)\n1149         x\n1150         >>> (x - 2*y).coeff(-1)\n1151         2*y\n1152 \n1153         You can select terms with no Rational coefficient:\n1154 \n1155         >>> (x + 2*y).coeff(1)\n1156         x\n1157         >>> (3 + 2*x + 4*x**2).coeff(1)\n1158         0\n1159 \n1160         You can select terms independent of x by making n=0; in this case\n1161         expr.as_independent(x)[0] is returned (and 0 will be returned instead\n1162         of None):\n1163 \n1164         >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n1165         3\n1166         >>> eq = ((x + 1)**3).expand() + 1\n1167         >>> eq\n1168         x**3 + 3*x**2 + 3*x + 2\n1169         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1170         [1, 3, 3, 2]\n1171         >>> eq -= 2\n1172         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1173         [1, 3, 3, 0]\n1174 \n1175         You can select terms that have a numerical term in front of them:\n1176 \n1177         >>> (-x - 2*y).coeff(2)\n1178         -y\n1179         >>> from sympy import sqrt\n1180         >>> (x + sqrt(2)*x).coeff(sqrt(2))\n1181         x\n1182 \n1183         The matching is exact:\n1184 \n1185         >>> (3 + 2*x + 4*x**2).coeff(x)\n1186         2\n1187         >>> (3 + 2*x + 4*x**2).coeff(x**2)\n1188         4\n1189         >>> (3 + 2*x + 4*x**2).coeff(x**3)\n1190         0\n1191         >>> (z*(x + y)**2).coeff((x + y)**2)\n1192         z\n1193         >>> (z*(x + y)**2).coeff(x + y)\n1194         0\n1195 \n1196         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n1197         from the following:\n1198 \n1199         >>> (x + z*(x + x*y)).coeff(x)\n1200         1\n1201 \n1202         If such factoring is desired, factor_terms can be used first:\n1203 \n1204         >>> from sympy import factor_terms\n1205         >>> factor_terms(x + z*(x + x*y)).coeff(x)\n1206         z*(y + 1) + 1\n1207 \n1208         >>> n, m, o = symbols('n m o', commutative=False)\n1209         >>> n.coeff(n)\n1210         1\n1211         >>> (3*n).coeff(n)\n1212         3\n1213         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n1214         1 + m\n1215         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n1216         m\n1217 \n1218         If there is more than one possible coefficient 0 is returned:\n1219 \n1220         >>> (n*m + m*n).coeff(n)\n1221         0\n1222 \n1223         If there is only one possible coefficient, it is returned:\n1224 \n1225         >>> (n*m + x*m*n).coeff(m*n)\n1226         x\n1227         >>> (n*m + x*m*n).coeff(m*n, right=1)\n1228         1\n1229 \n1230         \"\"\"\n1231         x = sympify(x)\n1232         if not isinstance(x, Basic):\n1233             return S.Zero\n1234 \n1235         n = as_int(n)\n1236 \n1237         if not x:\n1238             return S.Zero\n1239 \n1240         if x == self:\n1241             if n == 1:\n1242                 return S.One\n1243             return S.Zero\n1244 \n1245         if x is S.One:\n1246             co = [a for a in Add.make_args(self)\n1247                   if a.as_coeff_Mul()[0] is S.One]\n1248             if not co:\n1249                 return S.Zero\n1250             return Add(*co)\n1251 \n1252         if n == 0:\n1253             if x.is_Add and self.is_Add:\n1254                 c = self.coeff(x, right=right)\n1255                 if not c:\n1256                     return S.Zero\n1257                 if not right:\n1258                     return self - Add(*[a*x for a in Add.make_args(c)])\n1259                 return self - Add(*[x*a for a in Add.make_args(c)])\n1260             return self.as_independent(x, as_Add=True)[0]\n1261 \n1262         # continue with the full method, looking for this power of x:\n1263         x = x**n\n1264 \n1265         def incommon(l1, l2):\n1266             if not l1 or not l2:\n1267                 return []\n1268             n = min(len(l1), len(l2))\n1269             for i in range(n):\n1270                 if l1[i] != l2[i]:\n1271                     return l1[:i]\n1272             return l1[:]\n1273 \n1274         def find(l, sub, first=True):\n1275             \"\"\" Find where list sub appears in list l. When ``first`` is True\n1276             the first occurance from the left is returned, else the last\n1277             occurance is returned. Return None if sub is not in l.\n1278 \n1279             >> l = range(5)*2\n1280             >> find(l, [2, 3])\n1281             2\n1282             >> find(l, [2, 3], first=0)\n1283             7\n1284             >> find(l, [2, 4])\n1285             None\n1286 \n1287             \"\"\"\n1288             if not sub or not l or len(sub) > len(l):\n1289                 return None\n1290             n = len(sub)\n1291             if not first:\n1292                 l.reverse()\n1293                 sub.reverse()\n1294             for i in range(0, len(l) - n + 1):\n1295                 if all(l[i + j] == sub[j] for j in range(n)):\n1296                     break\n1297             else:\n1298                 i = None\n1299             if not first:\n1300                 l.reverse()\n1301                 sub.reverse()\n1302             if i is not None and not first:\n1303                 i = len(l) - (i + n)\n1304             return i\n1305 \n1306         co = []\n1307         args = Add.make_args(self)\n1308         self_c = self.is_commutative\n1309         x_c = x.is_commutative\n1310         if self_c and not x_c:\n1311             return S.Zero\n1312 \n1313         if self_c:\n1314             xargs = x.args_cnc(cset=True, warn=False)[0]\n1315             for a in args:\n1316                 margs = a.args_cnc(cset=True, warn=False)[0]\n1317                 if len(xargs) > len(margs):\n1318                     continue\n1319                 resid = margs.difference(xargs)\n1320                 if len(resid) + len(xargs) == len(margs):\n1321                     co.append(Mul(*resid))\n1322             if co == []:\n1323                 return S.Zero\n1324             elif co:\n1325                 return Add(*co)\n1326         elif x_c:\n1327             xargs = x.args_cnc(cset=True, warn=False)[0]\n1328             for a in args:\n1329                 margs, nc = a.args_cnc(cset=True)\n1330                 if len(xargs) > len(margs):\n1331                     continue\n1332                 resid = margs.difference(xargs)\n1333                 if len(resid) + len(xargs) == len(margs):\n1334                     co.append(Mul(*(list(resid) + nc)))\n1335             if co == []:\n1336                 return S.Zero\n1337             elif co:\n1338                 return Add(*co)\n1339         else:  # both nc\n1340             xargs, nx = x.args_cnc(cset=True)\n1341             # find the parts that pass the commutative terms\n1342             for a in args:\n1343                 margs, nc = a.args_cnc(cset=True)\n1344                 if len(xargs) > len(margs):\n1345                     continue\n1346                 resid = margs.difference(xargs)\n1347                 if len(resid) + len(xargs) == len(margs):\n1348                     co.append((resid, nc))\n1349             # now check the non-comm parts\n1350             if not co:\n1351                 return S.Zero\n1352             if all(n == co[0][1] for r, n in co):\n1353                 ii = find(co[0][1], nx, right)\n1354                 if ii is not None:\n1355                     if not right:\n1356                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n1357                     else:\n1358                         return Mul(*co[0][1][ii + len(nx):])\n1359             beg = reduce(incommon, (n[1] for n in co))\n1360             if beg:\n1361                 ii = find(beg, nx, right)\n1362                 if ii is not None:\n1363                     if not right:\n1364                         gcdc = co[0][0]\n1365                         for i in range(1, len(co)):\n1366                             gcdc = gcdc.intersection(co[i][0])\n1367                             if not gcdc:\n1368                                 break\n1369                         return Mul(*(list(gcdc) + beg[:ii]))\n1370                     else:\n1371                         m = ii + len(nx)\n1372                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n1373             end = list(reversed(\n1374                 reduce(incommon, (list(reversed(n[1])) for n in co))))\n1375             if end:\n1376                 ii = find(end, nx, right)\n1377                 if ii is not None:\n1378                     if not right:\n1379                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n1380                     else:\n1381                         return Mul(*end[ii + len(nx):])\n1382             # look for single match\n1383             hit = None\n1384             for i, (r, n) in enumerate(co):\n1385                 ii = find(n, nx, right)\n1386                 if ii is not None:\n1387                     if not hit:\n1388                         hit = ii, r, n\n1389                     else:\n1390                         break\n1391             else:\n1392                 if hit:\n1393                     ii, r, n = hit\n1394                     if not right:\n1395                         return Mul(*(list(r) + n[:ii]))\n1396                     else:\n1397                         return Mul(*n[ii + len(nx):])\n1398 \n1399             return S.Zero\n1400 \n1401     def as_expr(self, *gens):\n1402         \"\"\"\n1403         Convert a polynomial to a SymPy expression.\n1404 \n1405         Examples\n1406         ========\n1407 \n1408         >>> from sympy import sin\n1409         >>> from sympy.abc import x, y\n1410 \n1411         >>> f = (x**2 + x*y).as_poly(x, y)\n1412         >>> f.as_expr()\n1413         x**2 + x*y\n1414 \n1415         >>> sin(x).as_expr()\n1416         sin(x)\n1417 \n1418         \"\"\"\n1419         return self\n1420 \n1421     def as_coefficient(self, expr):\n1422         \"\"\"\n1423         Extracts symbolic coefficient at the given expression. In\n1424         other words, this functions separates 'self' into the product\n1425         of 'expr' and 'expr'-free coefficient. If such separation\n1426         is not possible it will return None.\n1427 \n1428         Examples\n1429         ========\n1430 \n1431         >>> from sympy import E, pi, sin, I, Poly\n1432         >>> from sympy.abc import x\n1433 \n1434         >>> E.as_coefficient(E)\n1435         1\n1436         >>> (2*E).as_coefficient(E)\n1437         2\n1438         >>> (2*sin(E)*E).as_coefficient(E)\n1439 \n1440         Two terms have E in them so a sum is returned. (If one were\n1441         desiring the coefficient of the term exactly matching E then\n1442         the constant from the returned expression could be selected.\n1443         Or, for greater precision, a method of Poly can be used to\n1444         indicate the desired term from which the coefficient is\n1445         desired.)\n1446 \n1447         >>> (2*E + x*E).as_coefficient(E)\n1448         x + 2\n1449         >>> _.args[0]  # just want the exact match\n1450         2\n1451         >>> p = Poly(2*E + x*E); p\n1452         Poly(x*E + 2*E, x, E, domain='ZZ')\n1453         >>> p.coeff_monomial(E)\n1454         2\n1455         >>> p.nth(0, 1)\n1456         2\n1457 \n1458         Since the following cannot be written as a product containing\n1459         E as a factor, None is returned. (If the coefficient ``2*x`` is\n1460         desired then the ``coeff`` method should be used.)\n1461 \n1462         >>> (2*E*x + x).as_coefficient(E)\n1463         >>> (2*E*x + x).coeff(E)\n1464         2*x\n1465 \n1466         >>> (E*(x + 1) + x).as_coefficient(E)\n1467 \n1468         >>> (2*pi*I).as_coefficient(pi*I)\n1469         2\n1470         >>> (2*I).as_coefficient(pi*I)\n1471 \n1472         See Also\n1473         ========\n1474 \n1475         coeff: return sum of terms have a given factor\n1476         as_coeff_Add: separate the additive constant from an expression\n1477         as_coeff_Mul: separate the multiplicative constant from an expression\n1478         as_independent: separate x-dependent terms/factors from others\n1479         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1480         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1481 \n1482 \n1483         \"\"\"\n1484 \n1485         r = self.extract_multiplicatively(expr)\n1486         if r and not r.has(expr):\n1487             return r\n1488 \n1489     def as_independent(self, *deps, **hint):\n1490         \"\"\"\n1491         A mostly naive separation of a Mul or Add into arguments that are not\n1492         are dependent on deps. To obtain as complete a separation of variables\n1493         as possible, use a separation method first, e.g.:\n1494 \n1495         * separatevars() to change Mul, Add and Pow (including exp) into Mul\n1496         * .expand(mul=True) to change Add or Mul into Add\n1497         * .expand(log=True) to change log expr into an Add\n1498 \n1499         The only non-naive thing that is done here is to respect noncommutative\n1500         ordering of variables and to always return (0, 0) for `self` of zero\n1501         regardless of hints.\n1502 \n1503         For nonzero `self`, the returned tuple (i, d) has the\n1504         following interpretation:\n1505 \n1506         * i will has no variable that appears in deps\n1507         * d will be 1 or else have terms that contain variables that are in deps\n1508         * if self is an Add then self = i + d\n1509         * if self is a Mul then self = i*d\n1510         * otherwise (self, S.One) or (S.One, self) is returned.\n1511 \n1512         To force the expression to be treated as an Add, use the hint as_Add=True\n1513 \n1514         Examples\n1515         ========\n1516 \n1517         -- self is an Add\n1518 \n1519         >>> from sympy import sin, cos, exp\n1520         >>> from sympy.abc import x, y, z\n1521 \n1522         >>> (x + x*y).as_independent(x)\n1523         (0, x*y + x)\n1524         >>> (x + x*y).as_independent(y)\n1525         (x, x*y)\n1526         >>> (2*x*sin(x) + y + x + z).as_independent(x)\n1527         (y + z, 2*x*sin(x) + x)\n1528         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n1529         (z, 2*x*sin(x) + x + y)\n1530 \n1531         -- self is a Mul\n1532 \n1533         >>> (x*sin(x)*cos(y)).as_independent(x)\n1534         (cos(y), x*sin(x))\n1535 \n1536         non-commutative terms cannot always be separated out when self is a Mul\n1537 \n1538         >>> from sympy import symbols\n1539         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n1540         >>> (n1 + n1*n2).as_independent(n2)\n1541         (n1, n1*n2)\n1542         >>> (n2*n1 + n1*n2).as_independent(n2)\n1543         (0, n1*n2 + n2*n1)\n1544         >>> (n1*n2*n3).as_independent(n1)\n1545         (1, n1*n2*n3)\n1546         >>> (n1*n2*n3).as_independent(n2)\n1547         (n1, n2*n3)\n1548         >>> ((x-n1)*(x-y)).as_independent(x)\n1549         (1, (x - y)*(x - n1))\n1550 \n1551         -- self is anything else:\n1552 \n1553         >>> (sin(x)).as_independent(x)\n1554         (1, sin(x))\n1555         >>> (sin(x)).as_independent(y)\n1556         (sin(x), 1)\n1557         >>> exp(x+y).as_independent(x)\n1558         (1, exp(x + y))\n1559 \n1560         -- force self to be treated as an Add:\n1561 \n1562         >>> (3*x).as_independent(x, as_Add=True)\n1563         (0, 3*x)\n1564 \n1565         -- force self to be treated as a Mul:\n1566 \n1567         >>> (3+x).as_independent(x, as_Add=False)\n1568         (1, x + 3)\n1569         >>> (-3+x).as_independent(x, as_Add=False)\n1570         (1, x - 3)\n1571 \n1572         Note how the below differs from the above in making the\n1573         constant on the dep term positive.\n1574 \n1575         >>> (y*(-3+x)).as_independent(x)\n1576         (y, x - 3)\n1577 \n1578         -- use .as_independent() for true independence testing instead\n1579            of .has(). The former considers only symbols in the free\n1580            symbols while the latter considers all symbols\n1581 \n1582         >>> from sympy import Integral\n1583         >>> I = Integral(x, (x, 1, 2))\n1584         >>> I.has(x)\n1585         True\n1586         >>> x in I.free_symbols\n1587         False\n1588         >>> I.as_independent(x) == (I, 1)\n1589         True\n1590         >>> (I + x).as_independent(x) == (I, x)\n1591         True\n1592 \n1593         Note: when trying to get independent terms, a separation method\n1594         might need to be used first. In this case, it is important to keep\n1595         track of what you send to this routine so you know how to interpret\n1596         the returned values\n1597 \n1598         >>> from sympy import separatevars, log\n1599         >>> separatevars(exp(x+y)).as_independent(x)\n1600         (exp(y), exp(x))\n1601         >>> (x + x*y).as_independent(y)\n1602         (x, x*y)\n1603         >>> separatevars(x + x*y).as_independent(y)\n1604         (x, y + 1)\n1605         >>> (x*(1 + y)).as_independent(y)\n1606         (x, y + 1)\n1607         >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n1608         (x, x*y)\n1609         >>> a, b=symbols('a b', positive=True)\n1610         >>> (log(a*b).expand(log=True)).as_independent(b)\n1611         (log(a), log(b))\n1612 \n1613         See Also\n1614         ========\n1615         .separatevars(), .expand(log=True), Add.as_two_terms(),\n1616         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()\n1617         \"\"\"\n1618         from .symbol import Symbol\n1619         from .add import _unevaluated_Add\n1620         from .mul import _unevaluated_Mul\n1621         from sympy.utilities.iterables import sift\n1622 \n1623         if self.is_zero:\n1624             return S.Zero, S.Zero\n1625 \n1626         func = self.func\n1627         if hint.get('as_Add', func is Add):\n1628             want = Add\n1629         else:\n1630             want = Mul\n1631 \n1632         # sift out deps into symbolic and other and ignore\n1633         # all symbols but those that are in the free symbols\n1634         sym = set()\n1635         other = []\n1636         for d in deps:\n1637             if isinstance(d, Symbol):  # Symbol.is_Symbol is True\n1638                 sym.add(d)\n1639             else:\n1640                 other.append(d)\n1641 \n1642         def has(e):\n1643             \"\"\"return the standard has() if there are no literal symbols, else\n1644             check to see that symbol-deps are in the free symbols.\"\"\"\n1645             has_other = e.has(*other)\n1646             if not sym:\n1647                 return has_other\n1648             return has_other or e.has(*(e.free_symbols & sym))\n1649 \n1650         if (want is not func or\n1651                 func is not Add and func is not Mul):\n1652             if has(self):\n1653                 return (want.identity, self)\n1654             else:\n1655                 return (self, want.identity)\n1656         else:\n1657             if func is Add:\n1658                 args = list(self.args)\n1659             else:\n1660                 args, nc = self.args_cnc()\n1661 \n1662         d = sift(args, lambda x: has(x))\n1663         depend = d[True]\n1664         indep = d[False]\n1665         if func is Add:  # all terms were treated as commutative\n1666             return (Add(*indep), _unevaluated_Add(*depend))\n1667         else:  # handle noncommutative by stopping at first dependent term\n1668             for i, n in enumerate(nc):\n1669                 if has(n):\n1670                     depend.extend(nc[i:])\n1671                     break\n1672                 indep.append(n)\n1673             return Mul(*indep), (\n1674                 Mul(*depend, evaluate=False) if nc else\n1675                 _unevaluated_Mul(*depend))\n1676 \n1677     def as_real_imag(self, deep=True, **hints):\n1678         \"\"\"Performs complex expansion on 'self' and returns a tuple\n1679            containing collected both real and imaginary parts. This\n1680            method can't be confused with re() and im() functions,\n1681            which does not perform complex expansion at evaluation.\n1682 \n1683            However it is possible to expand both re() and im()\n1684            functions and get exactly the same results as with\n1685            a single call to this function.\n1686 \n1687            >>> from sympy import symbols, I\n1688 \n1689            >>> x, y = symbols('x,y', real=True)\n1690 \n1691            >>> (x + y*I).as_real_imag()\n1692            (x, y)\n1693 \n1694            >>> from sympy.abc import z, w\n1695 \n1696            >>> (z + w*I).as_real_imag()\n1697            (re(z) - im(w), re(w) + im(z))\n1698 \n1699         \"\"\"\n1700         from sympy import im, re\n1701         if hints.get('ignore') == self:\n1702             return None\n1703         else:\n1704             return (re(self), im(self))\n1705 \n1706     def as_powers_dict(self):\n1707         \"\"\"Return self as a dictionary of factors with each factor being\n1708         treated as a power. The keys are the bases of the factors and the\n1709         values, the corresponding exponents. The resulting dictionary should\n1710         be used with caution if the expression is a Mul and contains non-\n1711         commutative factors since the order that they appeared will be lost in\n1712         the dictionary.\"\"\"\n1713         d = defaultdict(int)\n1714         d.update(dict([self.as_base_exp()]))\n1715         return d\n1716 \n1717     def as_coefficients_dict(self):\n1718         \"\"\"Return a dictionary mapping terms to their Rational coefficient.\n1719         Since the dictionary is a defaultdict, inquiries about terms which\n1720         were not present will return a coefficient of 0. If an expression is\n1721         not an Add it is considered to have a single term.\n1722 \n1723         Examples\n1724         ========\n1725 \n1726         >>> from sympy.abc import a, x\n1727         >>> (3*x + a*x + 4).as_coefficients_dict()\n1728         {1: 4, x: 3, a*x: 1}\n1729         >>> _[a]\n1730         0\n1731         >>> (3*a*x).as_coefficients_dict()\n1732         {a*x: 3}\n1733 \n1734         \"\"\"\n1735         c, m = self.as_coeff_Mul()\n1736         if not c.is_Rational:\n1737             c = S.One\n1738             m = self\n1739         d = defaultdict(int)\n1740         d.update({m: c})\n1741         return d\n1742 \n1743     def as_base_exp(self):\n1744         # a -> b ** e\n1745         return self, S.One\n1746 \n1747     def as_coeff_mul(self, *deps, **kwargs):\n1748         \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n1749 \n1750         c should be a Rational multiplied by any terms of the Mul that are\n1751         independent of deps.\n1752 \n1753         args should be a tuple of all other terms of m; args is empty\n1754         if self is a Number or if self is independent of deps (when given).\n1755 \n1756         This should be used when you don't know if self is a Mul or not but\n1757         you want to treat self as a Mul or if you want to process the\n1758         individual arguments of the tail of self as a Mul.\n1759 \n1760         - if you know self is a Mul and want only the head, use self.args[0];\n1761         - if you don't want to process the arguments of the tail but need the\n1762           tail then use self.as_two_terms() which gives the head and tail;\n1763         - if you want to split self into an independent and dependent parts\n1764           use ``self.as_independent(*deps)``\n1765 \n1766         >>> from sympy import S\n1767         >>> from sympy.abc import x, y\n1768         >>> (S(3)).as_coeff_mul()\n1769         (3, ())\n1770         >>> (3*x*y).as_coeff_mul()\n1771         (3, (x, y))\n1772         >>> (3*x*y).as_coeff_mul(x)\n1773         (3*y, (x,))\n1774         >>> (3*y).as_coeff_mul(x)\n1775         (3*y, ())\n1776         \"\"\"\n1777         if deps:\n1778             if not self.has(*deps):\n1779                 return self, tuple()\n1780         return S.One, (self,)\n1781 \n1782     def as_coeff_add(self, *deps):\n1783         \"\"\"Return the tuple (c, args) where self is written as an Add, ``a``.\n1784 \n1785         c should be a Rational added to any terms of the Add that are\n1786         independent of deps.\n1787 \n1788         args should be a tuple of all other terms of ``a``; args is empty\n1789         if self is a Number or if self is independent of deps (when given).\n1790 \n1791         This should be used when you don't know if self is an Add or not but\n1792         you want to treat self as an Add or if you want to process the\n1793         individual arguments of the tail of self as an Add.\n1794 \n1795         - if you know self is an Add and want only the head, use self.args[0];\n1796         - if you don't want to process the arguments of the tail but need the\n1797           tail then use self.as_two_terms() which gives the head and tail.\n1798         - if you want to split self into an independent and dependent parts\n1799           use ``self.as_independent(*deps)``\n1800 \n1801         >>> from sympy import S\n1802         >>> from sympy.abc import x, y\n1803         >>> (S(3)).as_coeff_add()\n1804         (3, ())\n1805         >>> (3 + x).as_coeff_add()\n1806         (3, (x,))\n1807         >>> (3 + x + y).as_coeff_add(x)\n1808         (y + 3, (x,))\n1809         >>> (3 + y).as_coeff_add(x)\n1810         (y + 3, ())\n1811 \n1812         \"\"\"\n1813         if deps:\n1814             if not self.has(*deps):\n1815                 return self, tuple()\n1816         return S.Zero, (self,)\n1817 \n1818     def primitive(self):\n1819         \"\"\"Return the positive Rational that can be extracted non-recursively\n1820         from every term of self (i.e., self is treated like an Add). This is\n1821         like the as_coeff_Mul() method but primitive always extracts a positive\n1822         Rational (never a negative or a Float).\n1823 \n1824         Examples\n1825         ========\n1826 \n1827         >>> from sympy.abc import x\n1828         >>> (3*(x + 1)**2).primitive()\n1829         (3, (x + 1)**2)\n1830         >>> a = (6*x + 2); a.primitive()\n1831         (2, 3*x + 1)\n1832         >>> b = (x/2 + 3); b.primitive()\n1833         (1/2, x + 6)\n1834         >>> (a*b).primitive() == (1, a*b)\n1835         True\n1836         \"\"\"\n1837         if not self:\n1838             return S.One, S.Zero\n1839         c, r = self.as_coeff_Mul(rational=True)\n1840         if c.is_negative:\n1841             c, r = -c, -r\n1842         return c, r\n1843 \n1844     def as_content_primitive(self, radical=False, clear=True):\n1845         \"\"\"This method should recursively remove a Rational from all arguments\n1846         and return that (content) and the new self (primitive). The content\n1847         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n1848         The primitive need no be in canonical form and should try to preserve\n1849         the underlying structure if possible (i.e. expand_mul should not be\n1850         applied to self).\n1851 \n1852         Examples\n1853         ========\n1854 \n1855         >>> from sympy import sqrt\n1856         >>> from sympy.abc import x, y, z\n1857 \n1858         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n1859 \n1860         The as_content_primitive function is recursive and retains structure:\n1861 \n1862         >>> eq.as_content_primitive()\n1863         (2, x + 3*y*(y + 1) + 1)\n1864 \n1865         Integer powers will have Rationals extracted from the base:\n1866 \n1867         >>> ((2 + 6*x)**2).as_content_primitive()\n1868         (4, (3*x + 1)**2)\n1869         >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n1870         (1, (2*(3*x + 1))**(2*y))\n1871 \n1872         Terms may end up joining once their as_content_primitives are added:\n1873 \n1874         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1875         (11, x*(y + 1))\n1876         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1877         (9, x*(y + 1))\n1878         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n1879         (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n1880         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n1881         (121, x**2*(y + 1)**2)\n1882         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()\n1883         (1, 121.0*x**2*(y + 1)**2)\n1884 \n1885         Radical content can also be factored out of the primitive:\n1886 \n1887         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n1888         (2, sqrt(2)*(1 + 2*sqrt(5)))\n1889 \n1890         If clear=False (default is True) then content will not be removed\n1891         from an Add if it can be distributed to leave one or more\n1892         terms with integer coefficients.\n1893 \n1894         >>> (x/2 + y).as_content_primitive()\n1895         (1/2, x + 2*y)\n1896         >>> (x/2 + y).as_content_primitive(clear=False)\n1897         (1, x/2 + y)\n1898         \"\"\"\n1899         return S.One, self\n1900 \n1901     def as_numer_denom(self):\n1902         \"\"\" expression -> a/b -> a, b\n1903 \n1904         This is just a stub that should be defined by\n1905         an object's class methods to get anything else.\n1906 \n1907         See Also\n1908         ========\n1909         normal: return a/b instead of a, b\n1910         \"\"\"\n1911 \n1912         return self, S.One\n1913 \n1914     def normal(self):\n1915         n, d = self.as_numer_denom()\n1916         if d is S.One:\n1917             return n\n1918         return n/d\n1919 \n1920     def extract_multiplicatively(self, c):\n1921         \"\"\"Return None if it's not possible to make self in the form\n1922            c * something in a nice way, i.e. preserving the properties\n1923            of arguments of self.\n1924 \n1925            >>> from sympy import symbols, Rational\n1926 \n1927            >>> x, y = symbols('x,y', real=True)\n1928 \n1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n1930            x*y**2\n1931 \n1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n1933 \n1934            >>> (2*x).extract_multiplicatively(2)\n1935            x\n1936 \n1937            >>> (2*x).extract_multiplicatively(3)\n1938 \n1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n1940            x/6\n1941 \n1942         \"\"\"\n1943         c = sympify(c)\n1944         if self is S.NaN:\n1945             return None\n1946         if c is S.One:\n1947             return self\n1948         elif c == self:\n1949             return S.One\n1950         if c.is_Add:\n1951             cc, pc = c.primitive()\n1952             if cc is not S.One:\n1953                 c = Mul(cc, pc, evaluate=False)\n1954         if c.is_Mul:\n1955             a, b = c.as_two_terms()\n1956             x = self.extract_multiplicatively(a)\n1957             if x is not None:\n1958                 return x.extract_multiplicatively(b)\n1959         quotient = self / c\n1960         if self.is_Number:\n1961             if self is S.Infinity:\n1962                 if c.is_positive:\n1963                     return S.Infinity\n1964             elif self is S.NegativeInfinity:\n1965                 if c.is_negative:\n1966                     return S.Infinity\n1967                 elif c.is_positive:\n1968                     return S.NegativeInfinity\n1969             elif self is S.ComplexInfinity:\n1970                 if not c.is_zero:\n1971                     return S.ComplexInfinity\n1972             elif self.is_Integer:\n1973                 if not quotient.is_Integer:\n1974                     return None\n1975                 elif self.is_positive and quotient.is_negative:\n1976                     return None\n1977                 else:\n1978                     return quotient\n1979             elif self.is_Rational:\n1980                 if not quotient.is_Rational:\n1981                     return None\n1982                 elif self.is_positive and quotient.is_negative:\n1983                     return None\n1984                 else:\n1985                     return quotient\n1986             elif self.is_Float:\n1987                 if not quotient.is_Float:\n1988                     return None\n1989                 elif self.is_positive and quotient.is_negative:\n1990                     return None\n1991                 else:\n1992                     return quotient\n1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n1994             if quotient.is_Mul and len(quotient.args) == 2:\n1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n1996                     return quotient\n1997             elif quotient.is_Integer and c.is_Number:\n1998                 return quotient\n1999         elif self.is_Add:\n2000             cs, ps = self.primitive()\n2001             if cs is not S.One:\n2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)\n2003             newargs = []\n2004             for arg in self.args:\n2005                 newarg = arg.extract_multiplicatively(c)\n2006                 if newarg is not None:\n2007                     newargs.append(newarg)\n2008                 else:\n2009                     return None\n2010             return Add(*newargs)\n2011         elif self.is_Mul:\n2012             args = list(self.args)\n2013             for i, arg in enumerate(args):\n2014                 newarg = arg.extract_multiplicatively(c)\n2015                 if newarg is not None:\n2016                     args[i] = newarg\n2017                     return Mul(*args)\n2018         elif self.is_Pow:\n2019             if c.is_Pow and c.base == self.base:\n2020                 new_exp = self.exp.extract_additively(c.exp)\n2021                 if new_exp is not None:\n2022                     return self.base ** (new_exp)\n2023             elif c == self.base:\n2024                 new_exp = self.exp.extract_additively(1)\n2025                 if new_exp is not None:\n2026                     return self.base ** (new_exp)\n2027 \n2028     def extract_additively(self, c):\n2029         \"\"\"Return self - c if it's possible to subtract c from self and\n2030         make all matching coefficients move towards zero, else return None.\n2031 \n2032         Examples\n2033         ========\n2034 \n2035         >>> from sympy.abc import x, y\n2036         >>> e = 2*x + 3\n2037         >>> e.extract_additively(x + 1)\n2038         x + 2\n2039         >>> e.extract_additively(3*x)\n2040         >>> e.extract_additively(4)\n2041         >>> (y*(x + 1)).extract_additively(x + 1)\n2042         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n2043         (x + 1)*(x + 2*y) + 3\n2044 \n2045         Sometimes auto-expansion will return a less simplified result\n2046         than desired; gcd_terms might be used in such cases:\n2047 \n2048         >>> from sympy import gcd_terms\n2049         >>> (4*x*(y + 1) + y).extract_additively(x)\n2050         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y\n2051         >>> gcd_terms(_)\n2052         x*(4*y + 3) + y\n2053 \n2054         See Also\n2055         ========\n2056         extract_multiplicatively\n2057         coeff\n2058         as_coefficient\n2059 \n2060         \"\"\"\n2061 \n2062         c = sympify(c)\n2063         if self is S.NaN:\n2064             return None\n2065         if c is S.Zero:\n2066             return self\n2067         elif c == self:\n2068             return S.Zero\n2069         elif self is S.Zero:\n2070             return None\n2071 \n2072         if self.is_Number:\n2073             if not c.is_Number:\n2074                 return None\n2075             co = self\n2076             diff = co - c\n2077             # XXX should we match types? i.e should 3 - .1 succeed?\n2078             if (co > 0 and diff > 0 and diff < co or\n2079                     co < 0 and diff < 0 and diff > co):\n2080                 return diff\n2081             return None\n2082 \n2083         if c.is_Number:\n2084             co, t = self.as_coeff_Add()\n2085             xa = co.extract_additively(c)\n2086             if xa is None:\n2087                 return None\n2088             return xa + t\n2089 \n2090         # handle the args[0].is_Number case separately\n2091         # since we will have trouble looking for the coeff of\n2092         # a number.\n2093         if c.is_Add and c.args[0].is_Number:\n2094             # whole term as a term factor\n2095             co = self.coeff(c)\n2096             xa0 = (co.extract_additively(1) or 0)*c\n2097             if xa0:\n2098                 diff = self - co*c\n2099                 return (xa0 + (diff.extract_additively(c) or diff)) or None\n2100             # term-wise\n2101             h, t = c.as_coeff_Add()\n2102             sh, st = self.as_coeff_Add()\n2103             xa = sh.extract_additively(h)\n2104             if xa is None:\n2105                 return None\n2106             xa2 = st.extract_additively(t)\n2107             if xa2 is None:\n2108                 return None\n2109             return xa + xa2\n2110 \n2111         # whole term as a term factor\n2112         co = self.coeff(c)\n2113         xa0 = (co.extract_additively(1) or 0)*c\n2114         if xa0:\n2115             diff = self - co*c\n2116             return (xa0 + (diff.extract_additively(c) or diff)) or None\n2117         # term-wise\n2118         coeffs = []\n2119         for a in Add.make_args(c):\n2120             ac, at = a.as_coeff_Mul()\n2121             co = self.coeff(at)\n2122             if not co:\n2123                 return None\n2124             coc, cot = co.as_coeff_Add()\n2125             xa = coc.extract_additively(ac)\n2126             if xa is None:\n2127                 return None\n2128             self -= co*at\n2129             coeffs.append((cot + xa)*at)\n2130         coeffs.append(self)\n2131         return Add(*coeffs)\n2132 \n2133     def could_extract_minus_sign(self):\n2134         \"\"\"Canonical way to choose an element in the set {e, -e} where\n2135            e is any expression. If the canonical element is e, we have\n2136            e.could_extract_minus_sign() == True, else\n2137            e.could_extract_minus_sign() == False.\n2138 \n2139            For any expression, the set ``{e.could_extract_minus_sign(),\n2140            (-e).could_extract_minus_sign()}`` must be ``{True, False}``.\n2141 \n2142            >>> from sympy.abc import x, y\n2143            >>> (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()\n2144            True\n2145 \n2146         \"\"\"\n2147         negative_self = -self\n2148         self_has_minus = (self.extract_multiplicatively(-1) is not None)\n2149         negative_self_has_minus = (\n2150             (negative_self).extract_multiplicatively(-1) is not None)\n2151         if self_has_minus != negative_self_has_minus:\n2152             return self_has_minus\n2153         else:\n2154             if self.is_Add:\n2155                 # We choose the one with less arguments with minus signs\n2156                 all_args = len(self.args)\n2157                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])\n2158                 positive_args = all_args - negative_args\n2159                 if positive_args > negative_args:\n2160                     return False\n2161                 elif positive_args < negative_args:\n2162                     return True\n2163             elif self.is_Mul:\n2164                 # We choose the one with an odd number of minus signs\n2165                 num, den = self.as_numer_denom()\n2166                 args = Mul.make_args(num) + Mul.make_args(den)\n2167                 arg_signs = [arg.could_extract_minus_sign() for arg in args]\n2168                 negative_args = list(filter(None, arg_signs))\n2169                 return len(negative_args) % 2 == 1\n2170 \n2171             # As a last resort, we choose the one with greater value of .sort_key()\n2172             return bool(self.sort_key() < negative_self.sort_key())\n2173 \n2174     def extract_branch_factor(self, allow_half=False):\n2175         \"\"\"\n2176         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.\n2177         Return (z, n).\n2178 \n2179         >>> from sympy import exp_polar, I, pi\n2180         >>> from sympy.abc import x, y\n2181         >>> exp_polar(I*pi).extract_branch_factor()\n2182         (exp_polar(I*pi), 0)\n2183         >>> exp_polar(2*I*pi).extract_branch_factor()\n2184         (1, 1)\n2185         >>> exp_polar(-pi*I).extract_branch_factor()\n2186         (exp_polar(I*pi), -1)\n2187         >>> exp_polar(3*pi*I + x).extract_branch_factor()\n2188         (exp_polar(x + I*pi), 1)\n2189         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n2190         (y*exp_polar(2*pi*x), -1)\n2191         >>> exp_polar(-I*pi/2).extract_branch_factor()\n2192         (exp_polar(-I*pi/2), 0)\n2193 \n2194         If allow_half is True, also extract exp_polar(I*pi):\n2195 \n2196         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n2197         (1, 1/2)\n2198         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n2199         (1, 1)\n2200         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n2201         (1, 3/2)\n2202         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n2203         (1, -1/2)\n2204         \"\"\"\n2205         from sympy import exp_polar, pi, I, ceiling, Add\n2206         n = S(0)\n2207         res = S(1)\n2208         args = Mul.make_args(self)\n2209         exps = []\n2210         for arg in args:\n2211             if arg.func is exp_polar:\n2212                 exps += [arg.exp]\n2213             else:\n2214                 res *= arg\n2215         piimult = S(0)\n2216         extras = []\n2217         while exps:\n2218             exp = exps.pop()\n2219             if exp.is_Add:\n2220                 exps += exp.args\n2221                 continue\n2222             if exp.is_Mul:\n2223                 coeff = exp.as_coefficient(pi*I)\n2224                 if coeff is not None:\n2225                     piimult += coeff\n2226                     continue\n2227             extras += [exp]\n2228         if not piimult.free_symbols:\n2229             coeff = piimult\n2230             tail = ()\n2231         else:\n2232             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)\n2233         # round down to nearest multiple of 2\n2234         branchfact = ceiling(coeff/2 - S(1)/2)*2\n2235         n += branchfact/2\n2236         c = coeff - branchfact\n2237         if allow_half:\n2238             nc = c.extract_additively(1)\n2239             if nc is not None:\n2240                 n += S(1)/2\n2241                 c = nc\n2242         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)\n2243         if newexp != 0:\n2244             res *= exp_polar(newexp)\n2245         return res, n\n2246 \n2247     def _eval_is_polynomial(self, syms):\n2248         if self.free_symbols.intersection(syms) == set([]):\n2249             return True\n2250         return False\n2251 \n2252     def is_polynomial(self, *syms):\n2253         \"\"\"\n2254         Return True if self is a polynomial in syms and False otherwise.\n2255 \n2256         This checks if self is an exact polynomial in syms.  This function\n2257         returns False for expressions that are \"polynomials\" with symbolic\n2258         exponents.  Thus, you should be able to apply polynomial algorithms to\n2259         expressions for which this returns True, and Poly(expr, \\*syms) should\n2260         work if and only if expr.is_polynomial(\\*syms) returns True. The\n2261         polynomial does not have to be in expanded form.  If no symbols are\n2262         given, all free symbols in the expression will be used.\n2263 \n2264         This is not part of the assumptions system.  You cannot do\n2265         Symbol('z', polynomial=True).\n2266 \n2267         Examples\n2268         ========\n2269 \n2270         >>> from sympy import Symbol\n2271         >>> x = Symbol('x')\n2272         >>> ((x**2 + 1)**4).is_polynomial(x)\n2273         True\n2274         >>> ((x**2 + 1)**4).is_polynomial()\n2275         True\n2276         >>> (2**x + 1).is_polynomial(x)\n2277         False\n2278 \n2279 \n2280         >>> n = Symbol('n', nonnegative=True, integer=True)\n2281         >>> (x**n + 1).is_polynomial(x)\n2282         False\n2283 \n2284         This function does not attempt any nontrivial simplifications that may\n2285         result in an expression that does not appear to be a polynomial to\n2286         become one.\n2287 \n2288         >>> from sympy import sqrt, factor, cancel\n2289         >>> y = Symbol('y', positive=True)\n2290         >>> a = sqrt(y**2 + 2*y + 1)\n2291         >>> a.is_polynomial(y)\n2292         False\n2293         >>> factor(a)\n2294         y + 1\n2295         >>> factor(a).is_polynomial(y)\n2296         True\n2297 \n2298         >>> b = (y**2 + 2*y + 1)/(y + 1)\n2299         >>> b.is_polynomial(y)\n2300         False\n2301         >>> cancel(b)\n2302         y + 1\n2303         >>> cancel(b).is_polynomial(y)\n2304         True\n2305 \n2306         See also .is_rational_function()\n2307 \n2308         \"\"\"\n2309         if syms:\n2310             syms = set(map(sympify, syms))\n2311         else:\n2312             syms = self.free_symbols\n2313 \n2314         if syms.intersection(self.free_symbols) == set([]):\n2315             # constant polynomial\n2316             return True\n2317         else:\n2318             return self._eval_is_polynomial(syms)\n2319 \n2320     def _eval_is_rational_function(self, syms):\n2321         if self.free_symbols.intersection(syms) == set([]):\n2322             return True\n2323         return False\n2324 \n2325     def is_rational_function(self, *syms):\n2326         \"\"\"\n2327         Test whether function is a ratio of two polynomials in the given\n2328         symbols, syms. When syms is not given, all free symbols will be used.\n2329         The rational function does not have to be in expanded or in any kind of\n2330         canonical form.\n2331 \n2332         This function returns False for expressions that are \"rational\n2333         functions\" with symbolic exponents.  Thus, you should be able to call\n2334         .as_numer_denom() and apply polynomial algorithms to the result for\n2335         expressions for which this returns True.\n2336 \n2337         This is not part of the assumptions system.  You cannot do\n2338         Symbol('z', rational_function=True).\n2339 \n2340         Examples\n2341         ========\n2342 \n2343         >>> from sympy import Symbol, sin\n2344         >>> from sympy.abc import x, y\n2345 \n2346         >>> (x/y).is_rational_function()\n2347         True\n2348 \n2349         >>> (x**2).is_rational_function()\n2350         True\n2351 \n2352         >>> (x/sin(y)).is_rational_function(y)\n2353         False\n2354 \n2355         >>> n = Symbol('n', integer=True)\n2356         >>> (x**n + 1).is_rational_function(x)\n2357         False\n2358 \n2359         This function does not attempt any nontrivial simplifications that may\n2360         result in an expression that does not appear to be a rational function\n2361         to become one.\n2362 \n2363         >>> from sympy import sqrt, factor\n2364         >>> y = Symbol('y', positive=True)\n2365         >>> a = sqrt(y**2 + 2*y + 1)/y\n2366         >>> a.is_rational_function(y)\n2367         False\n2368         >>> factor(a)\n2369         (y + 1)/y\n2370         >>> factor(a).is_rational_function(y)\n2371         True\n2372 \n2373         See also is_algebraic_expr().\n2374 \n2375         \"\"\"\n2376         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:\n2377             return False\n2378 \n2379         if syms:\n2380             syms = set(map(sympify, syms))\n2381         else:\n2382             syms = self.free_symbols\n2383 \n2384         if syms.intersection(self.free_symbols) == set([]):\n2385             # constant rational function\n2386             return True\n2387         else:\n2388             return self._eval_is_rational_function(syms)\n2389 \n2390     def _eval_is_algebraic_expr(self, syms):\n2391         if self.free_symbols.intersection(syms) == set([]):\n2392             return True\n2393         return False\n2394 \n2395     def is_algebraic_expr(self, *syms):\n2396         \"\"\"\n2397         This tests whether a given expression is algebraic or not, in the\n2398         given symbols, syms. When syms is not given, all free symbols\n2399         will be used. The rational function does not have to be in expanded\n2400         or in any kind of canonical form.\n2401 \n2402         This function returns False for expressions that are \"algebraic\n2403         expressions\" with symbolic exponents. This is a simple extension to the\n2404         is_rational_function, including rational exponentiation.\n2405 \n2406         Examples\n2407         ========\n2408 \n2409         >>> from sympy import Symbol, sqrt\n2410         >>> x = Symbol('x', real=True)\n2411         >>> sqrt(1 + x).is_rational_function()\n2412         False\n2413         >>> sqrt(1 + x).is_algebraic_expr()\n2414         True\n2415 \n2416         This function does not attempt any nontrivial simplifications that may\n2417         result in an expression that does not appear to be an algebraic\n2418         expression to become one.\n2419 \n2420         >>> from sympy import exp, factor\n2421         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n2422         >>> a.is_algebraic_expr(x)\n2423         False\n2424         >>> factor(a).is_algebraic_expr()\n2425         True\n2426 \n2427         See Also\n2428         ========\n2429         is_rational_function()\n2430 \n2431         References\n2432         ==========\n2433 \n2434         - http://en.wikipedia.org/wiki/Algebraic_expression\n2435 \n2436         \"\"\"\n2437         if syms:\n2438             syms = set(map(sympify, syms))\n2439         else:\n2440             syms = self.free_symbols\n2441 \n2442         if syms.intersection(self.free_symbols) == set([]):\n2443             # constant algebraic expression\n2444             return True\n2445         else:\n2446             return self._eval_is_algebraic_expr(syms)\n2447 \n2448     ###################################################################################\n2449     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################\n2450     ###################################################################################\n2451 \n2452     def series(self, x=None, x0=0, n=6, dir=\"+\", logx=None):\n2453         \"\"\"\n2454         Series expansion of \"self\" around ``x = x0`` yielding either terms of\n2455         the series one by one (the lazy series given when n=None), else\n2456         all the terms at once when n != None.\n2457 \n2458         Returns the series expansion of \"self\" around the point ``x = x0``\n2459         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).\n2460 \n2461         If ``x=None`` and ``self`` is univariate, the univariate symbol will\n2462         be supplied, otherwise an error will be raised.\n2463 \n2464         >>> from sympy import cos, exp\n2465         >>> from sympy.abc import x, y\n2466         >>> cos(x).series()\n2467         1 - x**2/2 + x**4/24 + O(x**6)\n2468         >>> cos(x).series(n=4)\n2469         1 - x**2/2 + O(x**4)\n2470         >>> cos(x).series(x, x0=1, n=2)\n2471         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n2472         >>> e = cos(x + exp(y))\n2473         >>> e.series(y, n=2)\n2474         cos(x + 1) - y*sin(x + 1) + O(y**2)\n2475         >>> e.series(x, n=2)\n2476         cos(exp(y)) - x*sin(exp(y)) + O(x**2)\n2477 \n2478         If ``n=None`` then a generator of the series terms will be returned.\n2479 \n2480         >>> term=cos(x).series(n=None)\n2481         >>> [next(term) for i in range(2)]\n2482         [1, -x**2/2]\n2483 \n2484         For ``dir=+`` (default) the series is calculated from the right and\n2485         for ``dir=-`` the series from the left. For smooth functions this\n2486         flag will not alter the results.\n2487 \n2488         >>> abs(x).series(dir=\"+\")\n2489         x\n2490         >>> abs(x).series(dir=\"-\")\n2491         -x\n2492 \n2493         \"\"\"\n2494         from sympy import collect, Dummy, Order, Rational, Symbol\n2495         if x is None:\n2496             syms = self.atoms(Symbol)\n2497             if not syms:\n2498                 return self\n2499             elif len(syms) > 1:\n2500                 raise ValueError('x must be given for multivariate functions.')\n2501             x = syms.pop()\n2502 \n2503         if not self.has(x):\n2504             if n is None:\n2505                 return (s for s in [self])\n2506             else:\n2507                 return self\n2508 \n2509         if len(dir) != 1 or dir not in '+-':\n2510             raise ValueError(\"Dir must be '+' or '-'\")\n2511 \n2512         if x0 in [S.Infinity, S.NegativeInfinity]:\n2513             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]\n2514             s = self.subs(x, 1/x).series(x, n=n, dir=dir)\n2515             if n is None:\n2516                 return (si.subs(x, 1/x) for si in s)\n2517             return s.subs(x, 1/x)\n2518 \n2519         # use rep to shift origin to x0 and change sign (if dir is negative)\n2520         # and undo the process with rep2\n2521         if x0 or dir == '-':\n2522             if dir == '-':\n2523                 rep = -x + x0\n2524                 rep2 = -x\n2525                 rep2b = x0\n2526             else:\n2527                 rep = x + x0\n2528                 rep2 = x\n2529                 rep2b = -x0\n2530             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)\n2531             if n is None:  # lseries...\n2532                 return (si.subs(x, rep2 + rep2b) for si in s)\n2533             return s.subs(x, rep2 + rep2b)\n2534 \n2535         # from here on it's x0=0 and dir='+' handling\n2536 \n2537         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:\n2538             # replace x with an x that has a positive assumption\n2539             xpos = Dummy('x', positive=True, finite=True)\n2540             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)\n2541             if n is None:\n2542                 return (s.subs(xpos, x) for s in rv)\n2543             else:\n2544                 return rv.subs(xpos, x)\n2545 \n2546         if n is not None:  # nseries handling\n2547             s1 = self._eval_nseries(x, n=n, logx=logx)\n2548             o = s1.getO() or S.Zero\n2549             if o:\n2550                 # make sure the requested order is returned\n2551                 ngot = o.getn()\n2552                 if ngot > n:\n2553                     # leave o in its current form (e.g. with x*log(x)) so\n2554                     # it eats terms properly, then replace it below\n2555                     if n != 0:\n2556                         s1 += o.subs(x, x**Rational(n, ngot))\n2557                     else:\n2558                         s1 += Order(1, x)\n2559                 elif ngot < n:\n2560                     # increase the requested number of terms to get the desired\n2561                     # number keep increasing (up to 9) until the received order\n2562                     # is different than the original order and then predict how\n2563                     # many additional terms are needed\n2564                     for more in range(1, 9):\n2565                         s1 = self._eval_nseries(x, n=n + more, logx=logx)\n2566                         newn = s1.getn()\n2567                         if newn != ngot:\n2568                             ndo = n + (n - ngot)*more/(newn - ngot)\n2569                             s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2570                             while s1.getn() < n:\n2571                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2572                                 ndo += 1\n2573                             break\n2574                     else:\n2575                         raise ValueError('Could not calculate %s terms for %s'\n2576                                          % (str(n), self))\n2577                     s1 += Order(x**n, x)\n2578                 o = s1.getO()\n2579                 s1 = s1.removeO()\n2580             else:\n2581                 o = Order(x**n, x)\n2582                 s1done = s1.doit()\n2583                 if (s1done + o).removeO() == s1done:\n2584                     o = S.Zero\n2585 \n2586             try:\n2587                 return collect(s1, x) + o\n2588             except NotImplementedError:\n2589                 return s1 + o\n2590 \n2591         else:  # lseries handling\n2592             def yield_lseries(s):\n2593                 \"\"\"Return terms of lseries one at a time.\"\"\"\n2594                 for si in s:\n2595                     if not si.is_Add:\n2596                         yield si\n2597                         continue\n2598                     # yield terms 1 at a time if possible\n2599                     # by increasing order until all the\n2600                     # terms have been returned\n2601                     yielded = 0\n2602                     o = Order(si, x)*x\n2603                     ndid = 0\n2604                     ndo = len(si.args)\n2605                     while 1:\n2606                         do = (si - yielded + o).removeO()\n2607                         o *= x\n2608                         if not do or do.is_Order:\n2609                             continue\n2610                         if do.is_Add:\n2611                             ndid += len(do.args)\n2612                         else:\n2613                             ndid += 1\n2614                         yield do\n2615                         if ndid == ndo:\n2616                             break\n2617                         yielded += do\n2618 \n2619             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))\n2620 \n2621     def taylor_term(self, n, x, *previous_terms):\n2622         \"\"\"General method for the taylor term.\n2623 \n2624         This method is slow, because it differentiates n-times. Subclasses can\n2625         redefine it to make it faster by using the \"previous_terms\".\n2626         \"\"\"\n2627         from sympy import Dummy, factorial\n2628         x = sympify(x)\n2629         _x = Dummy('x')\n2630         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)\n2631 \n2632     def lseries(self, x=None, x0=0, dir='+', logx=None):\n2633         \"\"\"\n2634         Wrapper for series yielding an iterator of the terms of the series.\n2635 \n2636         Note: an infinite series will yield an infinite iterator. The following,\n2637         for exaxmple, will never terminate. It will just keep printing terms\n2638         of the sin(x) series::\n2639 \n2640           for term in sin(x).lseries(x):\n2641               print term\n2642 \n2643         The advantage of lseries() over nseries() is that many times you are\n2644         just interested in the next term in the series (i.e. the first term for\n2645         example), but you don't know how many you should ask for in nseries()\n2646         using the \"n\" parameter.\n2647 \n2648         See also nseries().\n2649         \"\"\"\n2650         return self.series(x, x0, n=None, dir=dir, logx=logx)\n2651 \n2652     def _eval_lseries(self, x, logx=None):\n2653         # default implementation of lseries is using nseries(), and adaptively\n2654         # increasing the \"n\". As you can see, it is not very efficient, because\n2655         # we are calculating the series over and over again. Subclasses should\n2656         # override this method and implement much more efficient yielding of\n2657         # terms.\n2658         n = 0\n2659         series = self._eval_nseries(x, n=n, logx=logx)\n2660         if not series.is_Order:\n2661             if series.is_Add:\n2662                 yield series.removeO()\n2663             else:\n2664                 yield series\n2665             return\n2666 \n2667         while series.is_Order:\n2668             n += 1\n2669             series = self._eval_nseries(x, n=n, logx=logx)\n2670         e = series.removeO()\n2671         yield e\n2672         while 1:\n2673             while 1:\n2674                 n += 1\n2675                 series = self._eval_nseries(x, n=n, logx=logx).removeO()\n2676                 if e != series:\n2677                     break\n2678             yield series - e\n2679             e = series\n2680 \n2681     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):\n2682         \"\"\"\n2683         Wrapper to _eval_nseries if assumptions allow, else to series.\n2684 \n2685         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\n2686         called. This calculates \"n\" terms in the innermost expressions and\n2687         then builds up the final series just by \"cross-multiplying\" everything\n2688         out.\n2689 \n2690         The optional ``logx`` parameter can be used to replace any log(x) in the\n2691         returned series with a symbolic value to avoid evaluating log(x) at 0. A\n2692         symbol to use in place of log(x) should be provided.\n2693 \n2694         Advantage -- it's fast, because we don't have to determine how many\n2695         terms we need to calculate in advance.\n2696 \n2697         Disadvantage -- you may end up with less terms than you may have\n2698         expected, but the O(x**n) term appended will always be correct and\n2699         so the result, though perhaps shorter, will also be correct.\n2700 \n2701         If any of those assumptions is not met, this is treated like a\n2702         wrapper to series which will try harder to return the correct\n2703         number of terms.\n2704 \n2705         See also lseries().\n2706 \n2707         Examples\n2708         ========\n2709 \n2710         >>> from sympy import sin, log, Symbol\n2711         >>> from sympy.abc import x, y\n2712         >>> sin(x).nseries(x, 0, 6)\n2713         x - x**3/6 + x**5/120 + O(x**6)\n2714         >>> log(x+1).nseries(x, 0, 5)\n2715         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\n2716 \n2717         Handling of the ``logx`` parameter --- in the following example the\n2718         expansion fails since ``sin`` does not have an asymptotic expansion\n2719         at -oo (the limit of log(x) as x approaches 0):\n2720 \n2721         >>> e = sin(log(x))\n2722         >>> e.nseries(x, 0, 6)\n2723         Traceback (most recent call last):\n2724         ...\n2725         PoleError: ...\n2726         ...\n2727         >>> logx = Symbol('logx')\n2728         >>> e.nseries(x, 0, 6, logx=logx)\n2729         sin(logx)\n2730 \n2731         In the following example, the expansion works but gives only an Order term\n2732         unless the ``logx`` parameter is used:\n2733 \n2734         >>> e = x**y\n2735         >>> e.nseries(x, 0, 2)\n2736         O(log(x)**2)\n2737         >>> e.nseries(x, 0, 2, logx=logx)\n2738         exp(logx*y)\n2739 \n2740         \"\"\"\n2741         if x and not x in self.free_symbols:\n2742             return self\n2743         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):\n2744             return self.series(x, x0, n, dir)\n2745         else:\n2746             return self._eval_nseries(x, n=n, logx=logx)\n2747 \n2748     def _eval_nseries(self, x, n, logx):\n2749         \"\"\"\n2750         Return terms of series for self up to O(x**n) at x=0\n2751         from the positive direction.\n2752 \n2753         This is a method that should be overridden in subclasses. Users should\n2754         never call this method directly (use .nseries() instead), so you don't\n2755         have to write docstrings for _eval_nseries().\n2756         \"\"\"\n2757         from sympy.utilities.misc import filldedent\n2758         raise NotImplementedError(filldedent(\"\"\"\n2759                      The _eval_nseries method should be added to\n2760                      %s to give terms up to O(x**n) at x=0\n2761                      from the positive direction so it is available when\n2762                      nseries calls it.\"\"\" % self.func)\n2763                      )\n2764 \n2765     def limit(self, x, xlim, dir='+'):\n2766         \"\"\" Compute limit x->xlim.\n2767         \"\"\"\n2768         from sympy.series.limits import limit\n2769         return limit(self, x, xlim, dir)\n2770 \n2771     def compute_leading_term(self, x, logx=None):\n2772         \"\"\"\n2773         as_leading_term is only allowed for results of .series()\n2774         This is a wrapper to compute a series first.\n2775         \"\"\"\n2776         from sympy import Dummy, log\n2777         from sympy.series.gruntz import calculate_series\n2778 \n2779         if self.removeO() == 0:\n2780             return self\n2781 \n2782         if logx is None:\n2783             d = Dummy('logx')\n2784             s = calculate_series(self, x, d).subs(d, log(x))\n2785         else:\n2786             s = calculate_series(self, x, logx)\n2787 \n2788         return s.as_leading_term(x)\n2789 \n2790     @cacheit\n2791     def as_leading_term(self, *symbols):\n2792         \"\"\"\n2793         Returns the leading (nonzero) term of the series expansion of self.\n2794 \n2795         The _eval_as_leading_term routines are used to do this, and they must\n2796         always return a non-zero value.\n2797 \n2798         Examples\n2799         ========\n2800 \n2801         >>> from sympy.abc import x\n2802         >>> (1 + x + x**2).as_leading_term(x)\n2803         1\n2804         >>> (1/x**2 + x + x**2).as_leading_term(x)\n2805         x**(-2)\n2806 \n2807         \"\"\"\n2808         from sympy import powsimp\n2809         if len(symbols) > 1:\n2810             c = self\n2811             for x in symbols:\n2812                 c = c.as_leading_term(x)\n2813             return c\n2814         elif not symbols:\n2815             return self\n2816         x = sympify(symbols[0])\n2817         if not x.is_Symbol:\n2818             raise ValueError('expecting a Symbol but got %s' % x)\n2819         if x not in self.free_symbols:\n2820             return self\n2821         obj = self._eval_as_leading_term(x)\n2822         if obj is not None:\n2823             return powsimp(obj, deep=True, combine='exp')\n2824         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))\n2825 \n2826     def _eval_as_leading_term(self, x):\n2827         return self\n2828 \n2829     def as_coeff_exponent(self, x):\n2830         \"\"\" ``c*x**e -> c,e`` where x can be any symbolic expression.\n2831         \"\"\"\n2832         from sympy import collect\n2833         s = collect(self, x)\n2834         c, p = s.as_coeff_mul(x)\n2835         if len(p) == 1:\n2836             b, e = p[0].as_base_exp()\n2837             if b == x:\n2838                 return c, e\n2839         return s, S.Zero\n2840 \n2841     def leadterm(self, x):\n2842         \"\"\"\n2843         Returns the leading term a*x**b as a tuple (a, b).\n2844 \n2845         Examples\n2846         ========\n2847 \n2848         >>> from sympy.abc import x\n2849         >>> (1+x+x**2).leadterm(x)\n2850         (1, 0)\n2851         >>> (1/x**2+x+x**2).leadterm(x)\n2852         (1, -2)\n2853 \n2854         \"\"\"\n2855         from sympy import Dummy, log\n2856         l = self.as_leading_term(x)\n2857         d = Dummy('logx')\n2858         if l.has(log(x)):\n2859             l = l.subs(log(x), d)\n2860         c, e = l.as_coeff_exponent(x)\n2861         if x in c.free_symbols:\n2862             from sympy.utilities.misc import filldedent\n2863             raise ValueError(filldedent(\"\"\"\n2864                 cannot compute leadterm(%s, %s). The coefficient\n2865                 should have been free of x but got %s\"\"\" % (self, x, c)))\n2866         c = c.subs(d, log(x))\n2867         return c, e\n2868 \n2869     def as_coeff_Mul(self, rational=False):\n2870         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n2871         return S.One, self\n2872 \n2873     def as_coeff_Add(self, rational=False):\n2874         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2875         return S.Zero, self\n2876 \n2877     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,\n2878             full=False):\n2879         \"\"\"\n2880         Compute formal power power series of self.\n2881 \n2882         See the docstring of the :func:`fps` function in sympy.series.formal for\n2883         more information.\n2884         \"\"\"\n2885         from sympy.series.formal import fps\n2886 \n2887         return fps(self, x, x0, dir, hyper, order, rational, full)\n2888 \n2889     def fourier_series(self, limits=None):\n2890         \"\"\"Compute fourier sine/cosine series of self.\n2891 \n2892         See the docstring of the :func:`fourier_series` in sympy.series.fourier\n2893         for more information.\n2894         \"\"\"\n2895         from sympy.series.fourier import fourier_series\n2896 \n2897         return fourier_series(self, limits)\n2898 \n2899     ###################################################################################\n2900     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################\n2901     ###################################################################################\n2902 \n2903     def diff(self, *symbols, **assumptions):\n2904         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z\n2905         assumptions.setdefault(\"evaluate\", True)\n2906         return Derivative(self, *new_symbols, **assumptions)\n2907 \n2908     ###########################################################################\n2909     ###################### EXPRESSION EXPANSION METHODS #######################\n2910     ###########################################################################\n2911 \n2912     # Relevant subclasses should override _eval_expand_hint() methods.  See\n2913     # the docstring of expand() for more info.\n2914 \n2915     def _eval_expand_complex(self, **hints):\n2916         real, imag = self.as_real_imag(**hints)\n2917         return real + S.ImaginaryUnit*imag\n2918 \n2919     @staticmethod\n2920     def _expand_hint(expr, hint, deep=True, **hints):\n2921         \"\"\"\n2922         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.\n2923 \n2924         Returns ``(expr, hit)``, where expr is the (possibly) expanded\n2925         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and\n2926         ``False`` otherwise.\n2927         \"\"\"\n2928         hit = False\n2929         # XXX: Hack to support non-Basic args\n2930         #              |\n2931         #              V\n2932         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:\n2933             sargs = []\n2934             for arg in expr.args:\n2935                 arg, arghit = Expr._expand_hint(arg, hint, **hints)\n2936                 hit |= arghit\n2937                 sargs.append(arg)\n2938 \n2939             if hit:\n2940                 expr = expr.func(*sargs)\n2941 \n2942         if hasattr(expr, hint):\n2943             newexpr = getattr(expr, hint)(**hints)\n2944             if newexpr != expr:\n2945                 return (newexpr, True)\n2946 \n2947         return (expr, hit)\n2948 \n2949     @cacheit\n2950     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,\n2951             mul=True, log=True, multinomial=True, basic=True, **hints):\n2952         \"\"\"\n2953         Expand an expression using hints.\n2954 \n2955         See the docstring of the expand() function in sympy.core.function for\n2956         more information.\n2957 \n2958         \"\"\"\n2959         from sympy.simplify.radsimp import fraction\n2960 \n2961         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,\n2962            log=log, multinomial=multinomial, basic=basic)\n2963 \n2964         expr = self\n2965         if hints.pop('frac', False):\n2966             n, d = [a.expand(deep=deep, modulus=modulus, **hints)\n2967                     for a in fraction(self)]\n2968             return n/d\n2969         elif hints.pop('denom', False):\n2970             n, d = fraction(self)\n2971             return n/d.expand(deep=deep, modulus=modulus, **hints)\n2972         elif hints.pop('numer', False):\n2973             n, d = fraction(self)\n2974             return n.expand(deep=deep, modulus=modulus, **hints)/d\n2975 \n2976         # Although the hints are sorted here, an earlier hint may get applied\n2977         # at a given node in the expression tree before another because of how\n2978         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +\n2979         # x*z) because while applying log at the top level, log and mul are\n2980         # applied at the deeper level in the tree so that when the log at the\n2981         # upper level gets applied, the mul has already been applied at the\n2982         # lower level.\n2983 \n2984         # Additionally, because hints are only applied once, the expression\n2985         # may not be expanded all the way.   For example, if mul is applied\n2986         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For\n2987         # now, we just use a special case to make multinomial run before mul,\n2988         # so that at least polynomials will be expanded all the way.  In the\n2989         # future, smarter heuristics should be applied.\n2990         # TODO: Smarter heuristics\n2991 \n2992         def _expand_hint_key(hint):\n2993             \"\"\"Make multinomial come before mul\"\"\"\n2994             if hint == 'mul':\n2995                 return 'mulz'\n2996             return hint\n2997 \n2998         for hint in sorted(hints.keys(), key=_expand_hint_key):\n2999             use_hint = hints[hint]\n3000             if use_hint:\n3001                 hint = '_eval_expand_' + hint\n3002                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n3003 \n3004         while True:\n3005             was = expr\n3006             if hints.get('multinomial', False):\n3007                 expr, _ = Expr._expand_hint(\n3008                     expr, '_eval_expand_multinomial', deep=deep, **hints)\n3009             if hints.get('mul', False):\n3010                 expr, _ = Expr._expand_hint(\n3011                     expr, '_eval_expand_mul', deep=deep, **hints)\n3012             if hints.get('log', False):\n3013                 expr, _ = Expr._expand_hint(\n3014                     expr, '_eval_expand_log', deep=deep, **hints)\n3015             if expr == was:\n3016                 break\n3017 \n3018         if modulus is not None:\n3019             modulus = sympify(modulus)\n3020 \n3021             if not modulus.is_Integer or modulus <= 0:\n3022                 raise ValueError(\n3023                     \"modulus must be a positive integer, got %s\" % modulus)\n3024 \n3025             terms = []\n3026 \n3027             for term in Add.make_args(expr):\n3028                 coeff, tail = term.as_coeff_Mul(rational=True)\n3029 \n3030                 coeff %= modulus\n3031 \n3032                 if coeff:\n3033                     terms.append(coeff*tail)\n3034 \n3035             expr = Add(*terms)\n3036 \n3037         return expr\n3038 \n3039     ###########################################################################\n3040     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################\n3041     ###########################################################################\n3042 \n3043     def integrate(self, *args, **kwargs):\n3044         \"\"\"See the integrate function in sympy.integrals\"\"\"\n3045         from sympy.integrals import integrate\n3046         return integrate(self, *args, **kwargs)\n3047 \n3048     def simplify(self, ratio=1.7, measure=None):\n3049         \"\"\"See the simplify function in sympy.simplify\"\"\"\n3050         from sympy.simplify import simplify\n3051         from sympy.core.function import count_ops\n3052         measure = measure or count_ops\n3053         return simplify(self, ratio, measure)\n3054 \n3055     def nsimplify(self, constants=[], tolerance=None, full=False):\n3056         \"\"\"See the nsimplify function in sympy.simplify\"\"\"\n3057         from sympy.simplify import nsimplify\n3058         return nsimplify(self, constants, tolerance, full)\n3059 \n3060     def separate(self, deep=False, force=False):\n3061         \"\"\"See the separate function in sympy.simplify\"\"\"\n3062         from sympy.core.function import expand_power_base\n3063         return expand_power_base(self, deep=deep, force=force)\n3064 \n3065     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):\n3066         \"\"\"See the collect function in sympy.simplify\"\"\"\n3067         from sympy.simplify import collect\n3068         return collect(self, syms, func, evaluate, exact, distribute_order_term)\n3069 \n3070     def together(self, *args, **kwargs):\n3071         \"\"\"See the together function in sympy.polys\"\"\"\n3072         from sympy.polys import together\n3073         return together(self, *args, **kwargs)\n3074 \n3075     def apart(self, x=None, **args):\n3076         \"\"\"See the apart function in sympy.polys\"\"\"\n3077         from sympy.polys import apart\n3078         return apart(self, x, **args)\n3079 \n3080     def ratsimp(self):\n3081         \"\"\"See the ratsimp function in sympy.simplify\"\"\"\n3082         from sympy.simplify import ratsimp\n3083         return ratsimp(self)\n3084 \n3085     def trigsimp(self, **args):\n3086         \"\"\"See the trigsimp function in sympy.simplify\"\"\"\n3087         from sympy.simplify import trigsimp\n3088         return trigsimp(self, **args)\n3089 \n3090     def radsimp(self, **kwargs):\n3091         \"\"\"See the radsimp function in sympy.simplify\"\"\"\n3092         from sympy.simplify import radsimp\n3093         return radsimp(self, **kwargs)\n3094 \n3095     def powsimp(self, *args, **kwargs):\n3096         \"\"\"See the powsimp function in sympy.simplify\"\"\"\n3097         from sympy.simplify import powsimp\n3098         return powsimp(self, *args, **kwargs)\n3099 \n3100     def combsimp(self):\n3101         \"\"\"See the combsimp function in sympy.simplify\"\"\"\n3102         from sympy.simplify import combsimp\n3103         return combsimp(self)\n3104 \n3105     def factor(self, *gens, **args):\n3106         \"\"\"See the factor() function in sympy.polys.polytools\"\"\"\n3107         from sympy.polys import factor\n3108         return factor(self, *gens, **args)\n3109 \n3110     def refine(self, assumption=True):\n3111         \"\"\"See the refine function in sympy.assumptions\"\"\"\n3112         from sympy.assumptions import refine\n3113         return refine(self, assumption)\n3114 \n3115     def cancel(self, *gens, **args):\n3116         \"\"\"See the cancel function in sympy.polys\"\"\"\n3117         from sympy.polys import cancel\n3118         return cancel(self, *gens, **args)\n3119 \n3120     def invert(self, g, *gens, **args):\n3121         \"\"\"Return the multiplicative inverse of ``self`` mod ``g``\n3122         where ``self`` (and ``g``) may be symbolic expressions).\n3123 \n3124         See Also\n3125         ========\n3126         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert\n3127         \"\"\"\n3128         from sympy.polys.polytools import invert\n3129         from sympy.core.numbers import mod_inverse\n3130         if self.is_number and getattr(g, 'is_number', True):\n3131             return mod_inverse(self, g)\n3132         return invert(self, g, *gens, **args)\n3133 \n3134     def round(self, p=0):\n3135         \"\"\"Return x rounded to the given decimal place.\n3136 \n3137         If a complex number would results, apply round to the real\n3138         and imaginary components of the number.\n3139 \n3140         Examples\n3141         ========\n3142 \n3143         >>> from sympy import pi, E, I, S, Add, Mul, Number\n3144         >>> S(10.5).round()\n3145         11.\n3146         >>> pi.round()\n3147         3.\n3148         >>> pi.round(2)\n3149         3.14\n3150         >>> (2*pi + E*I).round()\n3151         6. + 3.*I\n3152 \n3153         The round method has a chopping effect:\n3154 \n3155         >>> (2*pi + I/10).round()\n3156         6.\n3157         >>> (pi/10 + 2*I).round()\n3158         2.*I\n3159         >>> (pi/10 + E*I).round(2)\n3160         0.31 + 2.72*I\n3161 \n3162         Notes\n3163         =====\n3164 \n3165         Do not confuse the Python builtin function, round, with the\n3166         SymPy method of the same name. The former always returns a float\n3167         (or raises an error if applied to a complex value) while the\n3168         latter returns either a Number or a complex number:\n3169 \n3170         >>> isinstance(round(S(123), -2), Number)\n3171         False\n3172         >>> isinstance(S(123).round(-2), Number)\n3173         True\n3174         >>> isinstance((3*I).round(), Mul)\n3175         True\n3176         >>> isinstance((1 + 3*I).round(), Add)\n3177         True\n3178 \n3179         \"\"\"\n3180         from sympy import Float\n3181         x = self\n3182         if not x.is_number:\n3183             raise TypeError(\"can't round symbolic expression\")\n3184         if not x.is_Atom:\n3185             xn = x.n(2)\n3186             if not pure_complex(xn, or_real=True):\n3187                 raise TypeError('Expected a number but got %s:' %\n3188                     getattr(getattr(x,'func', x), '__name__', type(x)))\n3189         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n3190             return x\n3191         if not x.is_real:\n3192             i, r = x.as_real_imag()\n3193             return i.round(p) + S.ImaginaryUnit*r.round(p)\n3194         if not x:\n3195             return x\n3196         p = int(p)\n3197 \n3198         precs = [f._prec for f in x.atoms(Float)]\n3199         dps = prec_to_dps(max(precs)) if precs else None\n3200 \n3201         mag_first_dig = _mag(x)\n3202         allow = digits_needed = mag_first_dig + p\n3203         if dps is not None and allow > dps:\n3204             allow = dps\n3205         mag = Pow(10, p)  # magnitude needed to bring digit p to units place\n3206         xwas = x\n3207         x += 1/(2*mag)  # add the half for rounding\n3208         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3209         if i10.is_negative:\n3210             x = xwas - 1/(2*mag)  # should have gone the other way\n3211             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3212             rv = -(Integer(-i10)//10)\n3213         else:\n3214             rv = Integer(i10)//10\n3215         q = 1\n3216         if p > 0:\n3217             q = mag\n3218         elif p < 0:\n3219             rv /= mag\n3220         rv = Rational(rv, q)\n3221         if rv.is_Integer:\n3222             # use str or else it won't be a float\n3223             return Float(str(rv), digits_needed)\n3224         else:\n3225             if not allow and rv > self:\n3226                 allow += 1\n3227             return Float(rv, allow)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "sympy/core/mul.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/core/mul.py",
        "start": 90,
        "end": 1663,
        "class_name": "Mul",
        "method_name": null,
        "code": "90 class Mul(Expr, AssocOp):\n91 \n92     __slots__ = []\n93 \n94     is_Mul = True\n95 \n96     @classmethod\n97     def flatten(cls, seq):\n98         \"\"\"Return commutative, noncommutative and order arguments by\n99         combining related terms.\n100 \n101         Notes\n102         =====\n103             * In an expression like ``a*b*c``, python process this through sympy\n104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.\n105 \n106               -  Sometimes terms are not combined as one would like:\n107                  {c.f. https://github.com/sympy/sympy/issues/4596}\n108 \n109                 >>> from sympy import Mul, sqrt\n110                 >>> from sympy.abc import x, y, z\n111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior\n112                 2*x + 2\n113                 >>> y*(x + 1)*2\n114                 2*y*(x + 1)\n115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first\n116                 y*(2*x + 2)\n117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n118                 2*y*(x + 1)\n119                 >>> 2*((x + 1)*y) # parentheses can control this behavior\n120                 2*y*(x + 1)\n121 \n122                 Powers with compound bases may not find a single base to\n123                 combine with unless all arguments are processed at once.\n124                 Post-processing may be necessary in such cases.\n125                 {c.f. https://github.com/sympy/sympy/issues/5728}\n126 \n127                 >>> a = sqrt(x*sqrt(y))\n128                 >>> a**3\n129                 (x*sqrt(y))**(3/2)\n130                 >>> Mul(a,a,a)\n131                 (x*sqrt(y))**(3/2)\n132                 >>> a*a*a\n133                 x*sqrt(y)*sqrt(x*sqrt(y))\n134                 >>> _.subs(a.base, z).subs(z, a.base)\n135                 (x*sqrt(y))**(3/2)\n136 \n137               -  If more than two terms are being multiplied then all the\n138                  previous terms will be re-processed for each new argument.\n139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`\n140                  expression, then ``a*b*c`` (or building up the product\n141                  with ``*=``) will process all the arguments of ``a`` and\n142                  ``b`` twice: once when ``a*b`` is computed and again when\n143                  ``c`` is multiplied.\n144 \n145                  Using ``Mul(a, b, c)`` will process all arguments once.\n146 \n147             * The results of Mul are cached according to arguments, so flatten\n148               will only be called once for ``Mul(a, b, c)``. If you can\n149               structure a calculation so the arguments are most likely to be\n150               repeats then this can save time in computing the answer. For\n151               example, say you had a Mul, M, that you wished to divide by ``d[i]``\n152               and multiply by ``n[i]`` and you suspect there are many repeats\n153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather\n154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the\n155               product, ``M*n[i]`` will be returned without flattening -- the\n156               cached value will be returned. If you divide by the ``d[i]``\n157               first (and those are more unique than the ``n[i]``) then that will\n158               create a new Mul, ``M/d[i]`` the args of which will be traversed\n159               again when it is multiplied by ``n[i]``.\n160 \n161               {c.f. https://github.com/sympy/sympy/issues/5706}\n162 \n163               This consideration is moot if the cache is turned off.\n164 \n165             NB\n166             --\n167               The validity of the above notes depends on the implementation\n168               details of Mul and flatten which may change at any time. Therefore,\n169               you should only consider them when your code is highly performance\n170               sensitive.\n171 \n172               Removal of 1 from the sequence is already handled by AssocOp.__new__.\n173         \"\"\"\n174 \n175         from sympy.calculus.util import AccumBounds\n176         rv = None\n177         if len(seq) == 2:\n178             a, b = seq\n179             if b.is_Rational:\n180                 a, b = b, a\n181             assert not a is S.One\n182             if not a.is_zero and a.is_Rational:\n183                 r, b = b.as_coeff_Mul()\n184                 if b.is_Add:\n185                     if r is not S.One:  # 2-arg hack\n186                         # leave the Mul as a Mul\n187                         rv = [cls(a*r, b, evaluate=False)], [], None\n188                     elif b.is_commutative:\n189                         if a is S.One:\n190                             rv = [b], [], None\n191                         else:\n192                             r, b = b.as_coeff_Add()\n193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n194                             _addsort(bargs)\n195                             ar = a*r\n196                             if ar:\n197                                 bargs.insert(0, ar)\n198                             bargs = [Add._from_args(bargs)]\n199                             rv = bargs, [], None\n200             if rv:\n201                 return rv\n202 \n203         # apply associativity, separate commutative part of seq\n204         c_part = []         # out: commutative factors\n205         nc_part = []        # out: non-commutative factors\n206 \n207         nc_seq = []\n208 \n209         coeff = S.One       # standalone term\n210                             # e.g. 3 * ...\n211 \n212         c_powers = []       # (base,exp)      n\n213                             # e.g. (x,n) for x\n214 \n215         num_exp = []        # (num-base, exp)           y\n216                             # e.g.  (3, y)  for  ... * 3  * ...\n217 \n218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I\n219 \n220         pnum_rat = {}       # (num-base, Rat-exp)          1/2\n221                             # e.g.  (3, 1/2)  for  ... * 3     * ...\n222 \n223         order_symbols = None\n224 \n225         # --- PART 1 ---\n226         #\n227         # \"collect powers and coeff\":\n228         #\n229         # o coeff\n230         # o c_powers\n231         # o num_exp\n232         # o neg1e\n233         # o pnum_rat\n234         #\n235         # NOTE: this is optimized for all-objects-are-commutative case\n236         for o in seq:\n237             # O(x)\n238             if o.is_Order:\n239                 o, order_symbols = o.as_expr_variables(order_symbols)\n240 \n241             # Mul([...])\n242             if o.is_Mul:\n243                 if o.is_commutative:\n244                     seq.extend(o.args)    # XXX zerocopy?\n245 \n246                 else:\n247                     # NCMul can have commutative parts as well\n248                     for q in o.args:\n249                         if q.is_commutative:\n250                             seq.append(q)\n251                         else:\n252                             nc_seq.append(q)\n253 \n254                     # append non-commutative marker, so we don't forget to\n255                     # process scheduled non-commutative objects\n256                     seq.append(NC_Marker)\n257 \n258                 continue\n259 \n260             # 3\n261             elif o.is_Number:\n262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:\n263                     # we know for sure the result will be nan\n264                     return [S.NaN], [], None\n265                 elif coeff.is_Number:  # it could be zoo\n266                     coeff *= o\n267                     if coeff is S.NaN:\n268                         # we know for sure the result will be nan\n269                         return [S.NaN], [], None\n270                 continue\n271 \n272             elif isinstance(o, AccumBounds):\n273                 coeff = o.__mul__(coeff)\n274                 continue\n275 \n276             elif o is S.ComplexInfinity:\n277                 if not coeff:\n278                     # 0 * zoo = NaN\n279                     return [S.NaN], [], None\n280                 if coeff is S.ComplexInfinity:\n281                     # zoo * zoo = zoo\n282                     return [S.ComplexInfinity], [], None\n283                 coeff = S.ComplexInfinity\n284                 continue\n285 \n286             elif o is S.ImaginaryUnit:\n287                 neg1e += S.Half\n288                 continue\n289 \n290             elif o.is_commutative:\n291                 #      e\n292                 # o = b\n293                 b, e = o.as_base_exp()\n294 \n295                 #  y\n296                 # 3\n297                 if o.is_Pow:\n298                     if b.is_Number:\n299 \n300                         # get all the factors with numeric base so they can be\n301                         # combined below, but don't combine negatives unless\n302                         # the exponent is an integer\n303                         if e.is_Rational:\n304                             if e.is_Integer:\n305                                 coeff *= Pow(b, e)  # it is an unevaluated power\n306                                 continue\n307                             elif e.is_negative:    # also a sign of an unevaluated power\n308                                 seq.append(Pow(b, e))\n309                                 continue\n310                             elif b.is_negative:\n311                                 neg1e += e\n312                                 b = -b\n313                             if b is not S.One:\n314                                 pnum_rat.setdefault(b, []).append(e)\n315                             continue\n316                         elif b.is_positive or e.is_integer:\n317                             num_exp.append((b, e))\n318                             continue\n319 \n320                     elif b is S.ImaginaryUnit and e.is_Rational:\n321                         neg1e += e/2\n322                         continue\n323 \n324                 c_powers.append((b, e))\n325 \n326             # NON-COMMUTATIVE\n327             # TODO: Make non-commutative exponents not combine automatically\n328             else:\n329                 if o is not NC_Marker:\n330                     nc_seq.append(o)\n331 \n332                 # process nc_seq (if any)\n333                 while nc_seq:\n334                     o = nc_seq.pop(0)\n335                     if not nc_part:\n336                         nc_part.append(o)\n337                         continue\n338 \n339                     #                             b    c       b+c\n340                     # try to combine last terms: a  * a   ->  a\n341                     o1 = nc_part.pop()\n342                     b1, e1 = o1.as_base_exp()\n343                     b2, e2 = o.as_base_exp()\n344                     new_exp = e1 + e2\n345                     # Only allow powers to combine if the new exponent is\n346                     # not an Add. This allow things like a**2*b**3 == a**5\n347                     # if a.is_commutative == False, but prohibits\n348                     # a**x*a**y and x**a*x**b from combining (x,y commute).\n349                     if b1 == b2 and (not new_exp.is_Add):\n350                         o12 = b1 ** new_exp\n351 \n352                         # now o12 could be a commutative object\n353                         if o12.is_commutative:\n354                             seq.append(o12)\n355                             continue\n356                         else:\n357                             nc_seq.insert(0, o12)\n358 \n359                     else:\n360                         nc_part.append(o1)\n361                         nc_part.append(o)\n362 \n363         # We do want a combined exponent if it would not be an Add, such as\n364         #  y    2y     3y\n365         # x  * x   -> x\n366         # We determine if two exponents have the same term by using\n367         # as_coeff_Mul.\n368         #\n369         # Unfortunately, this isn't smart enough to consider combining into\n370         # exponents that might already be adds, so things like:\n371         #  z - y    y\n372         # x      * x  will be left alone.  This is because checking every possible\n373         # combination can slow things down.\n374 \n375         # gather exponents of common bases...\n376         def _gather(c_powers):\n377             common_b = {}  # b:e\n378             for b, e in c_powers:\n379                 co = e.as_coeff_Mul()\n380                 common_b.setdefault(b, {}).setdefault(\n381                     co[1], []).append(co[0])\n382             for b, d in common_b.items():\n383                 for di, li in d.items():\n384                     d[di] = Add(*li)\n385             new_c_powers = []\n386             for b, e in common_b.items():\n387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])\n388             return new_c_powers\n389 \n390         # in c_powers\n391         c_powers = _gather(c_powers)\n392 \n393         # and in num_exp\n394         num_exp = _gather(num_exp)\n395 \n396         # --- PART 2 ---\n397         #\n398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)\n399         # o combine collected powers  (2**x * 3**x -> 6**x)\n400         #   with numeric base\n401 \n402         # ................................\n403         # now we have:\n404         # - coeff:\n405         # - c_powers:    (b, e)\n406         # - num_exp:     (2, e)\n407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}\n408 \n409         #  0             1\n410         # x  -> 1       x  -> x\n411 \n412         # this should only need to run twice; if it fails because\n413         # it needs to be run more times, perhaps this should be\n414         # changed to a \"while True\" loop -- the only reason it\n415         # isn't such now is to allow a less-than-perfect result to\n416         # be obtained rather than raising an error or entering an\n417         # infinite loop\n418         for i in range(2):\n419             new_c_powers = []\n420             changed = False\n421             for b, e in c_powers:\n422                 if e.is_zero:\n423                     continue\n424                 if e is S.One:\n425                     if b.is_Number:\n426                         coeff *= b\n427                         continue\n428                     p = b\n429                 if e is not S.One:\n430                     p = Pow(b, e)\n431                     # check to make sure that the base doesn't change\n432                     # after exponentiation; to allow for unevaluated\n433                     # Pow, we only do so if b is not already a Pow\n434                     if p.is_Pow and not b.is_Pow:\n435                         bi = b\n436                         b, e = p.as_base_exp()\n437                         if b != bi:\n438                             changed = True\n439                 c_part.append(p)\n440                 new_c_powers.append((b, e))\n441             # there might have been a change, but unless the base\n442             # matches some other base, there is nothing to do\n443             if changed and len(set(\n444                     b for b, e in new_c_powers)) != len(new_c_powers):\n445                 # start over again\n446                 c_part = []\n447                 c_powers = _gather(new_c_powers)\n448             else:\n449                 break\n450 \n451         #  x    x     x\n452         # 2  * 3  -> 6\n453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x\n454                             # e.g.  x:6  for  ... * 2  * 3  * ...\n455         for b, e in num_exp:\n456             inv_exp_dict.setdefault(e, []).append(b)\n457         for e, b in inv_exp_dict.items():\n458             inv_exp_dict[e] = cls(*b)\n459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n460 \n461         # b, e -> e' = sum(e), b\n462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}\n463         comb_e = {}\n464         for b, e in pnum_rat.items():\n465             comb_e.setdefault(Add(*e), []).append(b)\n466         del pnum_rat\n467         # process them, reducing exponents to values less than 1\n468         # and updating coeff if necessary else adding them to\n469         # num_rat for further processing\n470         num_rat = []\n471         for e, b in comb_e.items():\n472             b = cls(*b)\n473             if e.q == 1:\n474                 coeff *= Pow(b, e)\n475                 continue\n476             if e.p > e.q:\n477                 e_i, ep = divmod(e.p, e.q)\n478                 coeff *= Pow(b, e_i)\n479                 e = Rational(ep, e.q)\n480             num_rat.append((b, e))\n481         del comb_e\n482 \n483         # extract gcd of bases in num_rat\n484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)\n485         pnew = defaultdict(list)\n486         i = 0  # steps through num_rat which may grow\n487         while i < len(num_rat):\n488             bi, ei = num_rat[i]\n489             grow = []\n490             for j in range(i + 1, len(num_rat)):\n491                 bj, ej = num_rat[j]\n492                 g = bi.gcd(bj)\n493                 if g is not S.One:\n494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2\n495                     # this might have a gcd with something else\n496                     e = ei + ej\n497                     if e.q == 1:\n498                         coeff *= Pow(g, e)\n499                     else:\n500                         if e.p > e.q:\n501                             e_i, ep = divmod(e.p, e.q)  # change e in place\n502                             coeff *= Pow(g, e_i)\n503                             e = Rational(ep, e.q)\n504                         grow.append((g, e))\n505                     # update the jth item\n506                     num_rat[j] = (bj/g, ej)\n507                     # update bi that we are checking with\n508                     bi = bi/g\n509                     if bi is S.One:\n510                         break\n511             if bi is not S.One:\n512                 obj = Pow(bi, ei)\n513                 if obj.is_Number:\n514                     coeff *= obj\n515                 else:\n516                     # changes like sqrt(12) -> 2*sqrt(3)\n517                     for obj in Mul.make_args(obj):\n518                         if obj.is_Number:\n519                             coeff *= obj\n520                         else:\n521                             assert obj.is_Pow\n522                             bi, ei = obj.args\n523                             pnew[ei].append(bi)\n524 \n525             num_rat.extend(grow)\n526             i += 1\n527 \n528         # combine bases of the new powers\n529         for e, b in pnew.items():\n530             pnew[e] = cls(*b)\n531 \n532         # handle -1 and I\n533         if neg1e:\n534             # treat I as (-1)**(1/2) and compute -1's total exponent\n535             p, q =  neg1e.as_numer_denom()\n536             # if the integer part is odd, extract -1\n537             n, p = divmod(p, q)\n538             if n % 2:\n539                 coeff = -coeff\n540             # if it's a multiple of 1/2 extract I\n541             if q == 2:\n542                 c_part.append(S.ImaginaryUnit)\n543             elif p:\n544                 # see if there is any positive base this power of\n545                 # -1 can join\n546                 neg1e = Rational(p, q)\n547                 for e, b in pnew.items():\n548                     if e == neg1e and b.is_positive:\n549                         pnew[e] = -b\n550                         break\n551                 else:\n552                     # keep it separate; we've already evaluated it as\n553                     # much as possible so evaluate=False\n554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n555 \n556         # add all the pnew powers\n557         c_part.extend([Pow(b, e) for e, b in pnew.items()])\n558 \n559         # oo, -oo\n560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):\n561             def _handle_for_oo(c_part, coeff_sign):\n562                 new_c_part = []\n563                 for t in c_part:\n564                     if t.is_positive:\n565                         continue\n566                     if t.is_negative:\n567                         coeff_sign *= -1\n568                         continue\n569                     new_c_part.append(t)\n570                 return new_c_part, coeff_sign\n571             c_part, coeff_sign = _handle_for_oo(c_part, 1)\n572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n573             coeff *= coeff_sign\n574 \n575         # zoo\n576         if coeff is S.ComplexInfinity:\n577             # zoo might be\n578             #   infinite_real + bounded_im\n579             #   bounded_real + infinite_im\n580             #   infinite_real + infinite_im\n581             # and non-zero real or imaginary will not change that status.\n582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and\n583                                                 c.is_real is not None)]\n584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and\n585                                                   c.is_real is not None)]\n586 \n587         # 0\n588         elif coeff is S.Zero:\n589             # we know for sure the result will be 0 except the multiplicand\n590             # is infinity\n591             if any(c.is_finite == False for c in c_part):\n592                 return [S.NaN], [], order_symbols\n593             return [coeff], [], order_symbols\n594 \n595         # check for straggling Numbers that were produced\n596         _new = []\n597         for i in c_part:\n598             if i.is_Number:\n599                 coeff *= i\n600             else:\n601                 _new.append(i)\n602         c_part = _new\n603 \n604         # order commutative part canonically\n605         _mulsort(c_part)\n606 \n607         # current code expects coeff to be always in slot-0\n608         if coeff is not S.One:\n609             c_part.insert(0, coeff)\n610 \n611         # we are done\n612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and\n613                 c_part[1].is_Add):\n614             # 2*(1+a) -> 2 + 2 * a\n615             coeff = c_part[0]\n616             c_part = [Add(*[coeff*f for f in c_part[1].args])]\n617 \n618         return c_part, nc_part, order_symbols\n619 \n620     def _eval_power(b, e):\n621 \n622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B\n623         cargs, nc = b.args_cnc(split_1=False)\n624 \n625         if e.is_Integer:\n626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \\\n627                 Pow(Mul._from_args(nc), e, evaluate=False)\n628 \n629         p = Pow(b, e, evaluate=False)\n630 \n631         if e.is_Rational or e.is_Float:\n632             return p._eval_expand_power_base()\n633 \n634         return p\n635 \n636     @classmethod\n637     def class_key(cls):\n638         return 3, 0, cls.__name__\n639 \n640     def _eval_evalf(self, prec):\n641         c, m = self.as_coeff_Mul()\n642         if c is S.NegativeOne:\n643             if m.is_Mul:\n644                 rv = -AssocOp._eval_evalf(m, prec)\n645             else:\n646                 mnew = m._eval_evalf(prec)\n647                 if mnew is not None:\n648                     m = mnew\n649                 rv = -m\n650         else:\n651             rv = AssocOp._eval_evalf(self, prec)\n652         if rv.is_number:\n653             return rv.expand()\n654         return rv\n655 \n656     @property\n657     def _mpc_(self):\n658         \"\"\"\n659         Convert self to an mpmath mpc if possible\n660         \"\"\"\n661         from sympy.core.numbers import I, Float\n662         im_part, imag_unit = self.as_coeff_Mul()\n663         if not imag_unit == I:\n664             # ValueError may seem more reasonable but since it's a @property,\n665             # we need to use AttributeError to keep from confusing things like\n666             # hasattr.\n667             raise AttributeError(\"Cannot convert Mul to mpc. Must be of the form Number*I\")\n668 \n669         return (Float(0)._mpf_, Float(im_part)._mpf_)\n670 \n671     @cacheit\n672     def as_two_terms(self):\n673         \"\"\"Return head and tail of self.\n674 \n675         This is the most efficient way to get the head and tail of an\n676         expression.\n677 \n678         - if you want only the head, use self.args[0];\n679         - if you want to process the arguments of the tail then use\n680           self.as_coef_mul() which gives the head and a tuple containing\n681           the arguments of the tail when treated as a Mul.\n682         - if you want the coefficient when self is treated as an Add\n683           then use self.as_coeff_add()[0]\n684 \n685         >>> from sympy.abc import x, y\n686         >>> (3*x*y).as_two_terms()\n687         (3, x*y)\n688         \"\"\"\n689         args = self.args\n690 \n691         if len(args) == 1:\n692             return S.One, self\n693         elif len(args) == 2:\n694             return args\n695 \n696         else:\n697             return args[0], self._new_rawargs(*args[1:])\n698 \n699     @cacheit\n700     def as_coefficients_dict(self):\n701         \"\"\"Return a dictionary mapping terms to their coefficient.\n702         Since the dictionary is a defaultdict, inquiries about terms which\n703         were not present will return a coefficient of 0. The dictionary\n704         is considered to have a single term.\n705 \n706         Examples\n707         ========\n708 \n709         >>> from sympy.abc import a, x\n710         >>> (3*a*x).as_coefficients_dict()\n711         {a*x: 3}\n712         >>> _[a]\n713         0\n714         \"\"\"\n715 \n716         d = defaultdict(int)\n717         args = self.args\n718 \n719         if len(args) == 1 or not args[0].is_Number:\n720             d[self] = S.One\n721         else:\n722             d[self._new_rawargs(*args[1:])] = args[0]\n723 \n724         return d\n725 \n726     @cacheit\n727     def as_coeff_mul(self, *deps, **kwargs):\n728         rational = kwargs.pop('rational', True)\n729         if deps:\n730             l1 = []\n731             l2 = []\n732             for f in self.args:\n733                 if f.has(*deps):\n734                     l2.append(f)\n735                 else:\n736                     l1.append(f)\n737             return self._new_rawargs(*l1), tuple(l2)\n738         args = self.args\n739         if args[0].is_Number:\n740             if not rational or args[0].is_Rational:\n741                 return args[0], args[1:]\n742             elif args[0].is_negative:\n743                 return S.NegativeOne, (-args[0],) + args[1:]\n744         return S.One, args\n745 \n746     def as_coeff_Mul(self, rational=False):\n747         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n748         coeff, args = self.args[0], self.args[1:]\n749 \n750         if coeff.is_Number:\n751             if not rational or coeff.is_Rational:\n752                 if len(args) == 1:\n753                     return coeff, args[0]\n754                 else:\n755                     return coeff, self._new_rawargs(*args)\n756             elif coeff.is_negative:\n757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n758         return S.One, self\n759 \n760     def as_real_imag(self, deep=True, **hints):\n761         from sympy import Abs, expand_mul, im, re\n762         other = []\n763         coeffr = []\n764         coeffi = []\n765         addterms = S.One\n766         for a in self.args:\n767             if a.is_real:\n768                 coeffr.append(a)\n769             elif a.is_imaginary:\n770                 coeffi.append(a)\n771             elif a.is_commutative:\n772                 # search for complex conjugate pairs:\n773                 for i, x in enumerate(other):\n774                     if x == a.conjugate():\n775                         coeffr.append(Abs(x)**2)\n776                         del other[i]\n777                         break\n778                 else:\n779                     if a.is_Add:\n780                         addterms *= a\n781                     else:\n782                         other.append(a)\n783             else:\n784                 other.append(a)\n785         m = self.func(*other)\n786         if hints.get('ignore') == m:\n787             return\n788         if len(coeffi) % 2:\n789             imco = im(coeffi.pop(0))\n790             # all other pairs make a real factor; they will be\n791             # put into reco below\n792         else:\n793             imco = S.Zero\n794         reco = self.func(*(coeffr + coeffi))\n795         r, i = (reco*re(m), reco*im(m))\n796         if addterms == 1:\n797             if m == 1:\n798                 if imco is S.Zero:\n799                     return (reco, S.Zero)\n800                 else:\n801                     return (S.Zero, reco*imco)\n802             if imco is S.Zero:\n803                 return (r, i)\n804             return (-imco*i, imco*r)\n805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n806         if imco is S.Zero:\n807             return (r*addre - i*addim, i*addre + r*addim)\n808         else:\n809             r, i = -imco*i, imco*r\n810             return (r*addre - i*addim, r*addim + i*addre)\n811 \n812     @staticmethod\n813     def _expandsums(sums):\n814         \"\"\"\n815         Helper function for _eval_expand_mul.\n816 \n817         sums must be a list of instances of Basic.\n818         \"\"\"\n819 \n820         L = len(sums)\n821         if L == 1:\n822             return sums[0].args\n823         terms = []\n824         left = Mul._expandsums(sums[:L//2])\n825         right = Mul._expandsums(sums[L//2:])\n826 \n827         terms = [Mul(a, b) for a in left for b in right]\n828         added = Add(*terms)\n829         return Add.make_args(added)  # it may have collapsed down to one term\n830 \n831     def _eval_expand_mul(self, **hints):\n832         from sympy import fraction\n833 \n834         # Handle things like 1/(x*(x + 1)), which are automatically converted\n835         # to 1/x*1/(x + 1)\n836         expr = self\n837         n, d = fraction(expr)\n838         if d.is_Mul:\n839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i\n840                 for i in (n, d)]\n841             expr = n/d\n842             if not expr.is_Mul:\n843                 return expr\n844 \n845         plain, sums, rewrite = [], [], False\n846         for factor in expr.args:\n847             if factor.is_Add:\n848                 sums.append(factor)\n849                 rewrite = True\n850             else:\n851                 if factor.is_commutative:\n852                     plain.append(factor)\n853                 else:\n854                     sums.append(Basic(factor))  # Wrapper\n855 \n856         if not rewrite:\n857             return expr\n858         else:\n859             plain = self.func(*plain)\n860             if sums:\n861                 terms = self.func._expandsums(sums)\n862                 args = []\n863                 for term in terms:\n864                     t = self.func(plain, term)\n865                     if t.is_Mul and any(a.is_Add for a in t.args):\n866                         t = t._eval_expand_mul()\n867                     args.append(t)\n868                 return Add(*args)\n869             else:\n870                 return plain\n871 \n872     @cacheit\n873     def _eval_derivative(self, s):\n874         args = list(self.args)\n875         terms = []\n876         for i in range(len(args)):\n877             d = args[i].diff(s)\n878             if d:\n879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))\n880         return Add(*terms)\n881 \n882     def _eval_difference_delta(self, n, step):\n883         from sympy.series.limitseq import difference_delta as dd\n884         arg0 = self.args[0]\n885         rest = Mul(*self.args[1:])\n886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *\n887                 rest)\n888 \n889     def _matches_simple(self, expr, repl_dict):\n890         # handle (w*3).matches('x*5') -> {w: x*5/3}\n891         coeff, terms = self.as_coeff_Mul()\n892         terms = Mul.make_args(terms)\n893         if len(terms) == 1:\n894             newexpr = self.__class__._combine_inverse(expr, coeff)\n895             return terms[0].matches(newexpr, repl_dict)\n896         return\n897 \n898     def matches(self, expr, repl_dict={}, old=False):\n899         expr = sympify(expr)\n900         if self.is_commutative and expr.is_commutative:\n901             return AssocOp._matches_commutative(self, expr, repl_dict, old)\n902         elif self.is_commutative is not expr.is_commutative:\n903             return None\n904         c1, nc1 = self.args_cnc()\n905         c2, nc2 = expr.args_cnc()\n906         repl_dict = repl_dict.copy()\n907         if c1:\n908             if not c2:\n909                 c2 = [1]\n910             a = self.func(*c1)\n911             if isinstance(a, AssocOp):\n912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)\n913             else:\n914                 repl_dict = a.matches(self.func(*c2), repl_dict)\n915         if repl_dict:\n916             a = self.func(*nc1)\n917             if isinstance(a, self.func):\n918                 repl_dict = a._matches(self.func(*nc2), repl_dict)\n919             else:\n920                 repl_dict = a.matches(self.func(*nc2), repl_dict)\n921         return repl_dict or None\n922 \n923     def _matches(self, expr, repl_dict={}):\n924         # weed out negative one prefixes#\n925         from sympy import Wild\n926         sign = 1\n927         a, b = self.as_two_terms()\n928         if a is S.NegativeOne:\n929             if b.is_Mul:\n930                 sign = -sign\n931             else:\n932                 # the remainder, b, is not a Mul anymore\n933                 return b.matches(-expr, repl_dict)\n934         expr = sympify(expr)\n935         if expr.is_Mul and expr.args[0] is S.NegativeOne:\n936             expr = -expr\n937             sign = -sign\n938 \n939         if not expr.is_Mul:\n940             # expr can only match if it matches b and a matches +/- 1\n941             if len(self.args) == 2:\n942                 # quickly test for equality\n943                 if b == expr:\n944                     return a.matches(Rational(sign), repl_dict)\n945                 # do more expensive match\n946                 dd = b.matches(expr, repl_dict)\n947                 if dd is None:\n948                     return None\n949                 dd = a.matches(Rational(sign), dd)\n950                 return dd\n951             return None\n952 \n953         d = repl_dict.copy()\n954 \n955         # weed out identical terms\n956         pp = list(self.args)\n957         ee = list(expr.args)\n958         for p in self.args:\n959             if p in expr.args:\n960                 ee.remove(p)\n961                 pp.remove(p)\n962 \n963         # only one symbol left in pattern -> match the remaining expression\n964         if len(pp) == 1 and isinstance(pp[0], Wild):\n965             if len(ee) == 1:\n966                 d[pp[0]] = sign * ee[0]\n967             else:\n968                 d[pp[0]] = sign * expr.func(*ee)\n969             return d\n970 \n971         if len(ee) != len(pp):\n972             return None\n973 \n974         for p, e in zip(pp, ee):\n975             d = p.xreplace(d).matches(e, d)\n976             if d is None:\n977                 return None\n978         return d\n979 \n980     @staticmethod\n981     def _combine_inverse(lhs, rhs):\n982         \"\"\"\n983         Returns lhs/rhs, but treats arguments like symbols, so things like\n984         oo/oo return 1, instead of a nan.\n985         \"\"\"\n986         if lhs == rhs:\n987             return S.One\n988 \n989         def check(l, r):\n990             if l.is_Float and r.is_comparable:\n991                 # if both objects are added to 0 they will share the same \"normalization\"\n992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow\n993                 # the 0 to pass, we use __add__ directly.\n994                 return l.__add__(0) == r.evalf().__add__(0)\n995             return False\n996         if check(lhs, rhs) or check(rhs, lhs):\n997             return S.One\n998         if lhs.is_Mul and rhs.is_Mul:\n999             a = list(lhs.args)\n1000             b = [1]\n1001             for x in rhs.args:\n1002                 if x in a:\n1003                     a.remove(x)\n1004                 elif -x in a:\n1005                     a.remove(-x)\n1006                     b.append(-1)\n1007                 else:\n1008                     b.append(x)\n1009             return lhs.func(*a)/rhs.func(*b)\n1010         return lhs/rhs\n1011 \n1012     def as_powers_dict(self):\n1013         d = defaultdict(int)\n1014         for term in self.args:\n1015             b, e = term.as_base_exp()\n1016             d[b] += e\n1017         return d\n1018 \n1019     def as_numer_denom(self):\n1020         # don't use _from_args to rebuild the numerators and denominators\n1021         # as the order is not guaranteed to be the same once they have\n1022         # been separated from each other\n1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n1024         return self.func(*numers), self.func(*denoms)\n1025 \n1026     def as_base_exp(self):\n1027         e1 = None\n1028         bases = []\n1029         nc = 0\n1030         for m in self.args:\n1031             b, e = m.as_base_exp()\n1032             if not b.is_commutative:\n1033                 nc += 1\n1034             if e1 is None:\n1035                 e1 = e\n1036             elif e != e1 or nc > 1:\n1037                 return self, S.One\n1038             bases.append(b)\n1039         return self.func(*bases), e1\n1040 \n1041     def _eval_is_polynomial(self, syms):\n1042         return all(term._eval_is_polynomial(syms) for term in self.args)\n1043 \n1044     def _eval_is_rational_function(self, syms):\n1045         return all(term._eval_is_rational_function(syms) for term in self.args)\n1046 \n1047     def _eval_is_algebraic_expr(self, syms):\n1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)\n1049 \n1050     _eval_is_finite = lambda self: _fuzzy_group(\n1051         a.is_finite for a in self.args)\n1052     _eval_is_commutative = lambda self: _fuzzy_group(\n1053         a.is_commutative for a in self.args)\n1054     _eval_is_complex = lambda self: _fuzzy_group(\n1055         (a.is_complex for a in self.args), quick_exit=True)\n1056 \n1057     def _eval_is_infinite(self):\n1058         if any(a.is_infinite for a in self.args):\n1059             if any(a.is_zero for a in self.args):\n1060                 return S.NaN.is_infinite\n1061             if any(a.is_zero is None for a in self.args):\n1062                 return None\n1063             return True\n1064 \n1065     def _eval_is_rational(self):\n1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n1067         if r:\n1068             return r\n1069         elif r is False:\n1070             return self.is_zero\n1071 \n1072     def _eval_is_algebraic(self):\n1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n1074         if r:\n1075             return r\n1076         elif r is False:\n1077             return self.is_zero\n1078 \n1079     def _eval_is_zero(self):\n1080         zero = infinite = False\n1081         for a in self.args:\n1082             z = a.is_zero\n1083             if z:\n1084                 if infinite:\n1085                     return  # 0*oo is nan and nan.is_zero is None\n1086                 zero = True\n1087             else:\n1088                 if not a.is_finite:\n1089                     if zero:\n1090                         return  # 0*oo is nan and nan.is_zero is None\n1091                     infinite = True\n1092                 if zero is False and z is None:  # trap None\n1093                     zero = None\n1094         return zero\n1095 \n1096     def _eval_is_integer(self):\n1097         is_rational = self.is_rational\n1098 \n1099         if is_rational:\n1100             n, d = self.as_numer_denom()\n1101             if d is S.One:\n1102                 return True\n1103             elif d is S(2):\n1104                 return n.is_even\n1105         elif is_rational is False:\n1106             return False\n1107 \n1108     def _eval_is_polar(self):\n1109         has_polar = any(arg.is_polar for arg in self.args)\n1110         return has_polar and \\\n1111             all(arg.is_polar or arg.is_positive for arg in self.args)\n1112 \n1113     def _eval_is_real(self):\n1114         return self._eval_real_imag(True)\n1115 \n1116     def _eval_real_imag(self, real):\n1117         zero = one_neither = False\n1118 \n1119         for t in self.args:\n1120             if not t.is_complex:\n1121                 return t.is_complex\n1122             elif t.is_imaginary:\n1123                 real = not real\n1124             elif t.is_real:\n1125                 if not zero:\n1126                     z = t.is_zero\n1127                     if not z and zero is False:\n1128                         zero = z\n1129                     elif z:\n1130                         if all(a.is_finite for a in self.args):\n1131                             return True\n1132                         return\n1133             elif t.is_real is False:\n1134                 if one_neither:\n1135                     return  # complex terms might cancel\n1136                 one_neither = True\n1137             else:\n1138                 return\n1139 \n1140         if one_neither:  # self is a+I*b or I*b\n1141             if real:\n1142                 return zero  # real*self is like self: neither is real\n1143         elif zero is False:\n1144             return real  # can't be trumped by 0\n1145         elif real:\n1146             return real  # doesn't matter what zero is\n1147 \n1148     def _eval_is_imaginary(self):\n1149         z = self.is_zero\n1150         if z:\n1151             return False\n1152         elif z is False:\n1153             return self._eval_real_imag(False)\n1154 \n1155     def _eval_is_hermitian(self):\n1156         return self._eval_herm_antiherm(True)\n1157 \n1158     def _eval_herm_antiherm(self, real):\n1159         one_nc = zero = one_neither = False\n1160 \n1161         for t in self.args:\n1162             if not t.is_commutative:\n1163                 if one_nc:\n1164                     return\n1165                 one_nc = True\n1166 \n1167             if t.is_antihermitian:\n1168                 real = not real\n1169             elif t.is_hermitian:\n1170                 if not zero:\n1171                     z = t.is_zero\n1172                     if not z and zero is False:\n1173                         zero = z\n1174                     elif z:\n1175                         if all(a.is_finite for a in self.args):\n1176                             return True\n1177                         return\n1178             elif t.is_hermitian is False:\n1179                 if one_neither:\n1180                     return\n1181                 one_neither = True\n1182             else:\n1183                 return\n1184 \n1185         if one_neither:\n1186             if real:\n1187                 return zero\n1188         elif zero is False or real:\n1189             return real\n1190 \n1191     def _eval_is_antihermitian(self):\n1192         z = self.is_zero\n1193         if z:\n1194             return False\n1195         elif z is False:\n1196             return self._eval_herm_antiherm(False)\n1197 \n1198     def _eval_is_irrational(self):\n1199         for t in self.args:\n1200             a = t.is_irrational\n1201             if a:\n1202                 others = list(self.args)\n1203                 others.remove(t)\n1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):\n1205                     return True\n1206                 return\n1207             if a is None:\n1208                 return\n1209         return False\n1210 \n1211     def _eval_is_positive(self):\n1212         \"\"\"Return True if self is positive, False if not, and None if it\n1213         cannot be determined.\n1214 \n1215         This algorithm is non-recursive and works by keeping track of the\n1216         sign which changes when a negative or nonpositive is encountered.\n1217         Whether a nonpositive or nonnegative is seen is also tracked since\n1218         the presence of these makes it impossible to return True, but\n1219         possible to return False if the end result is nonpositive. e.g.\n1220 \n1221             pos * neg * nonpositive -> pos or zero -> None is returned\n1222             pos * neg * nonnegative -> neg or zero -> False is returned\n1223         \"\"\"\n1224         return self._eval_pos_neg(1)\n1225 \n1226     def _eval_pos_neg(self, sign):\n1227         saw_NON = saw_NOT = False\n1228         for t in self.args:\n1229             if t.is_positive:\n1230                 continue\n1231             elif t.is_negative:\n1232                 sign = -sign\n1233             elif t.is_zero:\n1234                 if all(a.is_finite for a in self.args):\n1235                     return False\n1236                 return\n1237             elif t.is_nonpositive:\n1238                 sign = -sign\n1239                 saw_NON = True\n1240             elif t.is_nonnegative:\n1241                 saw_NON = True\n1242             elif t.is_positive is False:\n1243                 sign = -sign\n1244                 if saw_NOT:\n1245                     return\n1246                 saw_NOT = True\n1247             elif t.is_negative is False:\n1248                 if saw_NOT:\n1249                     return\n1250                 saw_NOT = True\n1251             else:\n1252                 return\n1253         if sign == 1 and saw_NON is False and saw_NOT is False:\n1254             return True\n1255         if sign < 0:\n1256             return False\n1257 \n1258     def _eval_is_negative(self):\n1259         if self.args[0] == -1:\n1260             return (-self).is_positive  # remove -1\n1261         return self._eval_pos_neg(-1)\n1262 \n1263     def _eval_is_odd(self):\n1264         is_integer = self.is_integer\n1265 \n1266         if is_integer:\n1267             r, acc = True, 1\n1268             for t in self.args:\n1269                 if not t.is_integer:\n1270                     return None\n1271                 elif t.is_even:\n1272                     r = False\n1273                 elif t.is_integer:\n1274                     if r is False:\n1275                         pass\n1276                     elif acc != 1 and (acc + t).is_odd:\n1277                         r = False\n1278                     elif t.is_odd is None:\n1279                         r = None\n1280                 acc = t\n1281             return r\n1282 \n1283         # !integer -> !odd\n1284         elif is_integer is False:\n1285             return False\n1286 \n1287     def _eval_is_even(self):\n1288         is_integer = self.is_integer\n1289 \n1290         if is_integer:\n1291             return fuzzy_not(self.is_odd)\n1292 \n1293         elif is_integer is False:\n1294             return False\n1295 \n1296     def _eval_is_prime(self):\n1297         \"\"\"\n1298         If product is a positive integer, multiplication\n1299         will never result in a prime number.\n1300         \"\"\"\n1301         if self.is_number:\n1302             \"\"\"\n1303             If input is a number that is not completely simplified.\n1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)\n1305             So we manually evaluate it and return whether that is prime or not.\n1306             \"\"\"\n1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)\n1308             r = S.One\n1309             for arg in self.args:\n1310                 r *= arg\n1311             return r.is_prime\n1312 \n1313         if self.is_integer and self.is_positive:\n1314             \"\"\"\n1315             Here we count the number of arguments that have a minimum value\n1316             greater than two.\n1317             If there are more than one of such a symbol then the result is not prime.\n1318             Else, the result cannot be determined.\n1319             \"\"\"\n1320             number_of_args = 0 # count of symbols with minimum value greater than one\n1321             for arg in self.args:\n1322                 if (arg-1).is_positive:\n1323                     number_of_args += 1\n1324 \n1325             if number_of_args > 1:\n1326                 return False\n1327 \n1328     def _eval_subs(self, old, new):\n1329         from sympy.functions.elementary.complexes import sign\n1330         from sympy.ntheory.factor_ import multiplicity\n1331         from sympy.simplify.powsimp import powdenest\n1332         from sympy.simplify.radsimp import fraction\n1333 \n1334         if not old.is_Mul:\n1335             return None\n1336 \n1337         # try keep replacement literal so -2*x doesn't replace 4*x\n1338         if old.args[0].is_Number and old.args[0] < 0:\n1339             if self.args[0].is_Number:\n1340                 if self.args[0] < 0:\n1341                     return self._subs(-old, -new)\n1342                 return None\n1343 \n1344         def base_exp(a):\n1345             # if I and -1 are in a Mul, they get both end up with\n1346             # a -1 base (see issue 6421); all we want here are the\n1347             # true Pow or exp separated into base and exponent\n1348             from sympy import exp\n1349             if a.is_Pow or a.func is exp:\n1350                 return a.as_base_exp()\n1351             return a, S.One\n1352 \n1353         def breakup(eq):\n1354             \"\"\"break up powers of eq when treated as a Mul:\n1355                    b**(Rational*e) -> b**e, Rational\n1356                 commutatives come back as a dictionary {b**e: Rational}\n1357                 noncommutatives come back as a list [(b**e, Rational)]\n1358             \"\"\"\n1359 \n1360             (c, nc) = (defaultdict(int), list())\n1361             for a in Mul.make_args(eq):\n1362                 a = powdenest(a)\n1363                 (b, e) = base_exp(a)\n1364                 if e is not S.One:\n1365                     (co, _) = e.as_coeff_mul()\n1366                     b = Pow(b, e/co)\n1367                     e = co\n1368                 if a.is_commutative:\n1369                     c[b] += e\n1370                 else:\n1371                     nc.append([b, e])\n1372             return (c, nc)\n1373 \n1374         def rejoin(b, co):\n1375             \"\"\"\n1376             Put rational back with exponent; in general this is not ok, but\n1377             since we took it from the exponent for analysis, it's ok to put\n1378             it back.\n1379             \"\"\"\n1380 \n1381             (b, e) = base_exp(b)\n1382             return Pow(b, e*co)\n1383 \n1384         def ndiv(a, b):\n1385             \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n1386             but not vice versa, and 2/5 does not divide 1/3) then return\n1387             the integer number of times it divides, else return 0.\n1388             \"\"\"\n1389             if not b.q % a.q or not a.q % b.q:\n1390                 return int(a/b)\n1391             return 0\n1392 \n1393         # give Muls in the denominator a chance to be changed (see issue 5651)\n1394         # rv will be the default return value\n1395         rv = None\n1396         n, d = fraction(self)\n1397         self2 = self\n1398         if d is not S.One:\n1399             self2 = n._subs(old, new)/d._subs(old, new)\n1400             if not self2.is_Mul:\n1401                 return self2._subs(old, new)\n1402             if self2 != self:\n1403                 rv = self2\n1404 \n1405         # Now continue with regular substitution.\n1406 \n1407         # handle the leading coefficient and use it to decide if anything\n1408         # should even be started; we always know where to find the Rational\n1409         # so it's a quick test\n1410 \n1411         co_self = self2.args[0]\n1412         co_old = old.args[0]\n1413         co_xmul = None\n1414         if co_old.is_Rational and co_self.is_Rational:\n1415             # if coeffs are the same there will be no updating to do\n1416             # below after breakup() step; so skip (and keep co_xmul=None)\n1417             if co_old != co_self:\n1418                 co_xmul = co_self.extract_multiplicatively(co_old)\n1419         elif co_old.is_Rational:\n1420             return rv\n1421 \n1422         # break self and old into factors\n1423 \n1424         (c, nc) = breakup(self2)\n1425         (old_c, old_nc) = breakup(old)\n1426 \n1427         # update the coefficients if we had an extraction\n1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5\n1429         # then co_self in c is replaced by (3/5)**2 and co_residual\n1430         # is 2*(1/7)**2\n1431 \n1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:\n1433             mult = S(multiplicity(abs(co_old), co_self))\n1434             c.pop(co_self)\n1435             if co_old in c:\n1436                 c[co_old] += mult\n1437             else:\n1438                 c[co_old] = mult\n1439             co_residual = co_self/co_old**mult\n1440         else:\n1441             co_residual = 1\n1442 \n1443         # do quick tests to see if we can't succeed\n1444 \n1445         ok = True\n1446         if len(old_nc) > len(nc):\n1447             # more non-commutative terms\n1448             ok = False\n1449         elif len(old_c) > len(c):\n1450             # more commutative terms\n1451             ok = False\n1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):\n1453             # unmatched non-commutative bases\n1454             ok = False\n1455         elif set(old_c).difference(set(c)):\n1456             # unmatched commutative terms\n1457             ok = False\n1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n1459             # differences in sign\n1460             ok = False\n1461         if not ok:\n1462             return rv\n1463 \n1464         if not old_c:\n1465             cdid = None\n1466         else:\n1467             rat = []\n1468             for (b, old_e) in old_c.items():\n1469                 c_e = c[b]\n1470                 rat.append(ndiv(c_e, old_e))\n1471                 if not rat[-1]:\n1472                     return rv\n1473             cdid = min(rat)\n1474 \n1475         if not old_nc:\n1476             ncdid = None\n1477             for i in range(len(nc)):\n1478                 nc[i] = rejoin(*nc[i])\n1479         else:\n1480             ncdid = 0  # number of nc replacements we did\n1481             take = len(old_nc)  # how much to look at each time\n1482             limit = cdid or S.Infinity  # max number that we can take\n1483             failed = []  # failed terms will need subs if other terms pass\n1484             i = 0\n1485             while limit and i + take <= len(nc):\n1486                 hit = False\n1487 \n1488                 # the bases must be equivalent in succession, and\n1489                 # the powers must be extractively compatible on the\n1490                 # first and last factor but equal inbetween.\n1491 \n1492                 rat = []\n1493                 for j in range(take):\n1494                     if nc[i + j][0] != old_nc[j][0]:\n1495                         break\n1496                     elif j == 0:\n1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n1498                     elif j == take - 1:\n1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n1500                     elif nc[i + j][1] != old_nc[j][1]:\n1501                         break\n1502                     else:\n1503                         rat.append(1)\n1504                     j += 1\n1505                 else:\n1506                     ndo = min(rat)\n1507                     if ndo:\n1508                         if take == 1:\n1509                             if cdid:\n1510                                 ndo = min(cdid, ndo)\n1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],\n1512                                     nc[i][1] - ndo*old_nc[0][1])\n1513                         else:\n1514                             ndo = 1\n1515 \n1516                             # the left residual\n1517 \n1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*\n1519                                     old_nc[0][1])\n1520 \n1521                             # eliminate all middle terms\n1522 \n1523                             mid = new\n1524 \n1525                             # the right residual (which may be the same as the middle if take == 2)\n1526 \n1527                             ir = i + take - 1\n1528                             r = (nc[ir][0], nc[ir][1] - ndo*\n1529                                  old_nc[-1][1])\n1530                             if r[1]:\n1531                                 if i + take < len(nc):\n1532                                     nc[i:i + take] = [l*mid, r]\n1533                                 else:\n1534                                     r = rejoin(*r)\n1535                                     nc[i:i + take] = [l*mid*r]\n1536                             else:\n1537 \n1538                                 # there was nothing left on the right\n1539 \n1540                                 nc[i:i + take] = [l*mid]\n1541 \n1542                         limit -= ndo\n1543                         ncdid += ndo\n1544                         hit = True\n1545                 if not hit:\n1546 \n1547                     # do the subs on this failing factor\n1548 \n1549                     failed.append(i)\n1550                 i += 1\n1551             else:\n1552 \n1553                 if not ncdid:\n1554                     return rv\n1555 \n1556                 # although we didn't fail, certain nc terms may have\n1557                 # failed so we rebuild them after attempting a partial\n1558                 # subs on them\n1559 \n1560                 failed.extend(range(i, len(nc)))\n1561                 for i in failed:\n1562                     nc[i] = rejoin(*nc[i]).subs(old, new)\n1563 \n1564         # rebuild the expression\n1565 \n1566         if cdid is None:\n1567             do = ncdid\n1568         elif ncdid is None:\n1569             do = cdid\n1570         else:\n1571             do = min(ncdid, cdid)\n1572 \n1573         margs = []\n1574         for b in c:\n1575             if b in old_c:\n1576 \n1577                 # calculate the new exponent\n1578 \n1579                 e = c[b] - old_c[b]*do\n1580                 margs.append(rejoin(b, e))\n1581             else:\n1582                 margs.append(rejoin(b.subs(old, new), c[b]))\n1583         if cdid and not ncdid:\n1584 \n1585             # in case we are replacing commutative with non-commutative,\n1586             # we want the new term to come at the front just like the\n1587             # rest of this routine\n1588 \n1589             margs = [Pow(new, cdid)] + margs\n1590         return co_residual*self2.func(*margs)*self2.func(*nc)\n1591 \n1592     def _eval_nseries(self, x, n, logx):\n1593         from sympy import Order, powsimp\n1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]\n1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)\n1596         if res.has(Order):\n1597             res += Order(x**n, x)\n1598         return res\n1599 \n1600     def _eval_as_leading_term(self, x):\n1601         return self.func(*[t.as_leading_term(x) for t in self.args])\n1602 \n1603     def _eval_conjugate(self):\n1604         return self.func(*[t.conjugate() for t in self.args])\n1605 \n1606     def _eval_transpose(self):\n1607         return self.func(*[t.transpose() for t in self.args[::-1]])\n1608 \n1609     def _eval_adjoint(self):\n1610         return self.func(*[t.adjoint() for t in self.args[::-1]])\n1611 \n1612     def _sage_(self):\n1613         s = 1\n1614         for x in self.args:\n1615             s *= x._sage_()\n1616         return s\n1617 \n1618     def as_content_primitive(self, radical=False, clear=True):\n1619         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n1620         extracted from self.\n1621 \n1622         Examples\n1623         ========\n1624 \n1625         >>> from sympy import sqrt\n1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n1627         (6, -sqrt(2)*(-sqrt(2) + 1))\n1628 \n1629         See docstring of Expr.as_content_primitive for more examples.\n1630         \"\"\"\n1631 \n1632         coef = S.One\n1633         args = []\n1634         for i, a in enumerate(self.args):\n1635             c, p = a.as_content_primitive(radical=radical, clear=clear)\n1636             coef *= c\n1637             if p is not S.One:\n1638                 args.append(p)\n1639         # don't use self._from_args here to reconstruct args\n1640         # since there may be identical args now that should be combined\n1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n1642         return coef, self.func(*args)\n1643 \n1644     def as_ordered_factors(self, order=None):\n1645         \"\"\"Transform an expression into an ordered list of factors.\n1646 \n1647         Examples\n1648         ========\n1649 \n1650         >>> from sympy import sin, cos\n1651         >>> from sympy.abc import x, y\n1652 \n1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n1654         [2, x, y, sin(x), cos(x)]\n1655 \n1656         \"\"\"\n1657         cpart, ncpart = self.args_cnc()\n1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))\n1659         return cpart + ncpart\n1660 \n1661     @property\n1662     def _sorted_args(self):\n1663         return tuple(self.as_ordered_factors())\n",
        "intended_behavior": "Though not directly implicated by a specific method in the bug report, the way Mul objects are created with evaluate=False and their interaction with methods like extract_multiplicatively suggests that there might be an underlying issue in either how Mul objects represent their arguments or in a helper method that extract_multiplicatively relies on (such as primitive or another method called within extract_multiplicatively). An analysis should be conducted on methods within Mul that are involved in the creation and simplification of these expressions to ensure they correctly handle negative values and expressions in non-evaluated form. This might involve ensuring that the primitive method (when called on results of Mul with evaluate=False) returns a form that is correctly interpreted by extract_multiplicatively, or adjusting how these Mul objects represent their arguments in a way that simplifies correctly when division is attempted."
    }
]