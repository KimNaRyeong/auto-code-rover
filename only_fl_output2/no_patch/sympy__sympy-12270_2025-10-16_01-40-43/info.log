2025-10-16 01:40:43.145 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-16 01:40:48.253 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=494, output_tokens=12, cost=0.005300
2025-10-16 01:41:03.349 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=674, output_tokens=598, cost=0.024680
2025-10-16 01:41:04.561 | INFO     | registered non reproducing test 0
2025-10-16 01:41:21.485 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1863, output_tokens=689, cost=0.039300
2025-10-16 01:41:22.680 | INFO     | registered non reproducing test 1
2025-10-16 01:41:38.824 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1962, output_tokens=709, cost=0.040890
2025-10-16 01:41:40.018 | INFO     | registered non reproducing test 2
2025-10-16 01:41:40.018 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-16 01:41:40.021 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:41:54.193 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=795, output_tokens=558, cost=0.024690
2025-10-16 01:41:54.204 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:41:56.426 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=912, output_tokens=75, cost=0.011370
2025-10-16 01:41:56.428 | DEBUG    | Extracted a valid json.
2025-10-16 01:41:56.428 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Mul\")",
        "search_method(\"extract_multiplicatively\")",
        "search_method(\"primitive\")",
        "search_code_in_file(\"Mul(2, -x, evaluate=False).extract_multiplicatively(-2)\", \"core/expr.py\")"
    ],
    "bug_locations": []
}
2025-10-16 01:41:56.500 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-16 01:41:56.501 | DEBUG    | <Agent search> Analyzing search results.
2025-10-16 01:42:14.459 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4535, output_tokens=693, cost=0.066140
2025-10-16 01:42:14.473 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-16 01:42:27.317 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5444, output_tokens=557, cost=0.071150
2025-10-16 01:42:27.326 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-16 01:42:37.435 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=403, cost=0.021200
2025-10-16 01:42:37.436 | DEBUG    | Extracted a valid json.
2025-10-16 01:42:37.436 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/expr.py",
            "class": "Expr",
            "method": "extract_multiplicatively",
            "intended_behavior": "This method should be able to correctly handle the case when attempting to extract a negative factor from an expression, particularly when that expression is constructed with Mul(..., evaluate=False). It appears that when a negative factor that matches the negative content of an expression is to be extracted, the method fails to return the correct factored expression. The intended behavior would involve checking if the expression can be divided by the given factor c in a way that maintains the integrity and properties of the original expression, even when evaluate=False has led to a non-standard representation of the expression. This can include better handling or normalization of expressions involving negative factors or ensuring that the Mul objects with evaluate=False are correctly interpreted and simplified if possible before attempting to extract multiplicatively."
        },
        {
            "file": "sympy/core/mul.py",
            "class": "Mul",
            "method": "",
            "intended_behavior": "Though not directly implicated by a specific method in the bug report, the way Mul objects are created with evaluate=False and their interaction with methods like extract_multiplicatively suggests that there might be an underlying issue in either how Mul objects represent their arguments or in a helper method that extract_multiplicatively relies on (such as primitive or another method called within extract_multiplicatively). An analysis should be conducted on methods within Mul that are involved in the creation and simplification of these expressions to ensure they correctly handle negative values and expressions in non-evaluated form. This might involve ensuring that the primitive method (when called on results of Mul with evaluate=False) returns a form that is correctly interpreted by extract_multiplicatively, or adjusting how these Mul objects represent their arguments in a way that simplifies correctly when division is attempted."
        }
    ]
}
2025-10-16 01:42:37.454 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>extract_multiplicatively</method>
<code>
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)

</code><intended_behavior>This method should be able to correctly handle the case when attempting to extract a negative factor from an expression, particularly when that expression is constructed with Mul(..., evaluate=False). It appears that when a negative factor that matches the negative content of an expression is to be extracted, the method fails to return the correct factored expression. The intended behavior would involve checking if the expression can be divided by the given factor c in a way that maintains the integrity and properties of the original expression, even when evaluate=False has led to a non-standard representation of the expression. This can include better handling or normalization of expressions involving negative factors or ensuring that the Mul objects with evaluate=False are correctly interpreted and simplified if possible before attempting to extract multiplicatively.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     @property
33     def _diff_wrt(self):
34         """Is it allowed to take derivative wrt to this instance.
35 
36         This determines if it is allowed to take derivatives wrt this object.
37         Subclasses such as Symbol, Function and Derivative should return True
38         to enable derivatives wrt them. The implementation in Derivative
39         separates the Symbol and non-Symbol _diff_wrt=True variables and
40         temporarily converts the non-Symbol vars in Symbols when performing
41         the differentiation.
42 
43         Note, see the docstring of Derivative for how this should work
44         mathematically. In particular, note that expr.subs(yourclass, Symbol)
45         should be well-defined on a structural level, or this will lead to
46         inconsistent results.
47 
48         Examples
49         ========
50 
51         >>> from sympy import Expr
52         >>> e = Expr()
53         >>> e._diff_wrt
54         False
55         >>> class MyClass(Expr):
56         ...     _diff_wrt = True
57         ...
58         >>> (2*MyClass()).diff(MyClass())
59         2
60         """
61         return False
62 
63     @cacheit
64     def sort_key(self, order=None):
65 
66         coeff, expr = self.as_coeff_Mul()
67 
68         if expr.is_Pow:
69             expr, exp = expr.args
70         else:
71             expr, exp = expr, S.One
72 
73         if expr.is_Dummy:
74             args = (expr.sort_key(),)
75         elif expr.is_Atom:
76             args = (str(expr),)
77         else:
78             if expr.is_Add:
79                 args = expr.as_ordered_terms(order=order)
80             elif expr.is_Mul:
81                 args = expr.as_ordered_factors(order=order)
82             else:
83                 args = expr.args
84 
85             args = tuple(
86                 [ default_sort_key(arg, order=order) for arg in args ])
87 
88         args = (len(args), tuple(args))
89         exp = exp.sort_key(order=order)
90 
91         return expr.class_key(), args, exp, coeff
92 
93     # ***************
94     # * Arithmetics *
95     # ***************
96     # Expr and its sublcasses use _op_priority to determine which object
97     # passed to a binary special method (__mul__, etc.) will handle the
98     # operation. In general, the 'call_highest_priority' decorator will choose
99     # the object with the highest _op_priority to handle the call.
100     # Custom subclasses that want to define their own binary special methods
101     # should set an _op_priority value that is higher than the default.
102     #
103     # **NOTE**:
104     # This is a temporary fix, and will eventually be replaced with
105     # something better and more powerful.  See issue 5510.
106     _op_priority = 10.0
107 
108     def __pos__(self):
109         return self
110 
111     def __neg__(self):
112         return Mul(S.NegativeOne, self)
113 
114     def __abs__(self):
115         from sympy import Abs
116         return Abs(self)
117 
118     @_sympifyit('other', NotImplemented)
119     @call_highest_priority('__radd__')
120     def __add__(self, other):
121         return Add(self, other)
122 
123     @_sympifyit('other', NotImplemented)
124     @call_highest_priority('__add__')
125     def __radd__(self, other):
126         return Add(other, self)
127 
128     @_sympifyit('other', NotImplemented)
129     @call_highest_priority('__rsub__')
130     def __sub__(self, other):
131         return Add(self, -other)
132 
133     @_sympifyit('other', NotImplemented)
134     @call_highest_priority('__sub__')
135     def __rsub__(self, other):
136         return Add(other, -self)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__rmul__')
140     def __mul__(self, other):
141         return Mul(self, other)
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__mul__')
145     def __rmul__(self, other):
146         return Mul(other, self)
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__rpow__')
150     def __pow__(self, other):
151         return Pow(self, other)
152 
153     @_sympifyit('other', NotImplemented)
154     @call_highest_priority('__pow__')
155     def __rpow__(self, other):
156         return Pow(other, self)
157 
158     @_sympifyit('other', NotImplemented)
159     @call_highest_priority('__rdiv__')
160     def __div__(self, other):
161         return Mul(self, Pow(other, S.NegativeOne))
162 
163     @_sympifyit('other', NotImplemented)
164     @call_highest_priority('__div__')
165     def __rdiv__(self, other):
166         return Mul(other, Pow(self, S.NegativeOne))
167 
168     __truediv__ = __div__
169     __rtruediv__ = __rdiv__
170 
171     @_sympifyit('other', NotImplemented)
172     @call_highest_priority('__rmod__')
173     def __mod__(self, other):
174         return Mod(self, other)
175 
176     @_sympifyit('other', NotImplemented)
177     @call_highest_priority('__mod__')
178     def __rmod__(self, other):
179         return Mod(other, self)
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__rfloordiv__')
183     def __floordiv__(self, other):
184         from sympy.functions.elementary.integers import floor
185         return floor(self / other)
186 
187     @_sympifyit('other', NotImplemented)
188     @call_highest_priority('__floordiv__')
189     def __rfloordiv__(self, other):
190         from sympy.functions.elementary.integers import floor
191         return floor(self / other)
192 
193     def __int__(self):
194         # Although we only need to round to the units position, we'll
195         # get one more digit so the extra testing below can be avoided
196         # unless the rounded value rounded to an integer, e.g. if an
197         # expression were equal to 1.9 and we rounded to the unit position
198         # we would get a 2 and would not know if this rounded up or not
199         # without doing a test (as done below). But if we keep an extra
200         # digit we know that 1.9 is not the same as 1 and there is no
201         # need for further testing: our int value is correct. If the value
202         # were 1.99, however, this would round to 2.0 and our int value is
203         # off by one. So...if our round value is the same as the int value
204         # (regardless of how much extra work we do to calculate extra decimal
205         # places) we need to test whether we are off by one.
206         from sympy import Dummy
207         if not self.is_number:
208             raise TypeError("can't convert symbols to int")
209         r = self.round(2)
210         if not r.is_Number:
211             raise TypeError("can't convert complex to int")
212         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
213             raise TypeError("can't convert %s to int" % r)
214         i = int(r)
215         if not i:
216             return 0
217         # off-by-one check
218         if i == r and not (self - i).equals(0):
219             isign = 1 if i > 0 else -1
220             x = Dummy()
221             # in the following (self - i).evalf(2) will not always work while
222             # (self - r).evalf(2) and the use of subs does; if the test that
223             # was added when this comment was added passes, it might be safe
224             # to simply use sign to compute this rather than doing this by hand:
225             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
226             if diff_sign != isign:
227                 i -= isign
228         return i
229     __long__ = __int__
230 
231     def __float__(self):
232         # Don't bother testing if it's a number; if it's not this is going
233         # to fail, and if it is we still need to check that it evalf'ed to
234         # a number.
235         result = self.evalf()
236         if result.is_Number:
237             return float(result)
238         if result.is_number and result.as_real_imag()[1]:
239             raise TypeError("can't convert complex to float")
240         raise TypeError("can't convert expression to float")
241 
242     def __complex__(self):
243         result = self.evalf()
244         re, im = result.as_real_imag()
245         return complex(float(re), float(im))
246 
247     def __ge__(self, other):
248         from sympy import GreaterThan
249         try:
250             other = _sympify(other)
251         except SympifyError:
252             raise TypeError("Invalid comparison %s >= %s" % (self, other))
253         for me in (self, other):
254             if (me.is_complex and me.is_real is False) or \
255                     me.has(S.ComplexInfinity):
256                 raise TypeError("Invalid comparison of complex %s" % me)
257             if me is S.NaN:
258                 raise TypeError("Invalid NaN comparison")
259         if self.is_real or other.is_real:
260             dif = self - other
261             if dif.is_nonnegative is not None and \
262                     dif.is_nonnegative is not dif.is_negative:
263                 return sympify(dif.is_nonnegative)
264         return GreaterThan(self, other, evaluate=False)
265 
266     def __le__(self, other):
267         from sympy import LessThan
268         try:
269             other = _sympify(other)
270         except SympifyError:
271             raise TypeError("Invalid comparison %s <= %s" % (self, other))
272         for me in (self, other):
273             if (me.is_complex and me.is_real is False) or \
274                     me.has(S.ComplexInfinity):
275                 raise TypeError("Invalid comparison of complex %s" % me)
276             if me is S.NaN:
277                 raise TypeError("Invalid NaN comparison")
278         if self.is_real or other.is_real:
279             dif = self - other
280             if dif.is_nonpositive is not None and \
281                     dif.is_nonpositive is not dif.is_positive:
282                 return sympify(dif.is_nonpositive)
283         return LessThan(self, other, evaluate=False)
284 
285     def __gt__(self, other):
286         from sympy import StrictGreaterThan
287         try:
288             other = _sympify(other)
289         except SympifyError:
290             raise TypeError("Invalid comparison %s > %s" % (self, other))
291         for me in (self, other):
292             if (me.is_complex and me.is_real is False) or \
293                     me.has(S.ComplexInfinity):
294                 raise TypeError("Invalid comparison of complex %s" % me)
295             if me is S.NaN:
296                 raise TypeError("Invalid NaN comparison")
297         if self.is_real or other.is_real:
298             dif = self - other
299             if dif.is_positive is not None and \
300                     dif.is_positive is not dif.is_nonpositive:
301                 return sympify(dif.is_positive)
302         return StrictGreaterThan(self, other, evaluate=False)
303 
304     def __lt__(self, other):
305         from sympy import StrictLessThan
306         try:
307             other = _sympify(other)
308         except SympifyError:
309             raise TypeError("Invalid comparison %s < %s" % (self, other))
310         for me in (self, other):
311             if (me.is_complex and me.is_real is False) or \
312                     me.has(S.ComplexInfinity):
313                 raise TypeError("Invalid comparison of complex %s" % me)
314             if me is S.NaN:
315                 raise TypeError("Invalid NaN comparison")
316         if self.is_real or other.is_real:
317             dif = self - other
318             if dif.is_negative is not None and \
319                     dif.is_negative is not dif.is_nonnegative:
320                 return sympify(dif.is_negative)
321         return StrictLessThan(self, other, evaluate=False)
322 
323     @staticmethod
324     def _from_mpmath(x, prec):
325         from sympy import Float
326         if hasattr(x, "_mpf_"):
327             return Float._new(x._mpf_, prec)
328         elif hasattr(x, "_mpc_"):
329             re, im = x._mpc_
330             re = Float._new(re, prec)
331             im = Float._new(im, prec)*S.ImaginaryUnit
332             return re + im
333         else:
334             raise TypeError("expected mpmath number (mpf or mpc)")
335 
336     @property
337     def is_number(self):
338         """Returns True if 'self' has no free symbols.
339         It will be faster than `if not self.free_symbols`, however, since
340         `is_number` will fail as soon as it hits a free symbol.
341 
342         Examples
343         ========
344 
345         >>> from sympy import log, Integral
346         >>> from sympy.abc import x
347 
348         >>> x.is_number
349         False
350         >>> (2*x).is_number
351         False
352         >>> (2 + log(2)).is_number
353         True
354         >>> (2 + Integral(2, x)).is_number
355         False
356         >>> (2 + Integral(2, (x, 1, 2))).is_number
357         True
358 
359         """
360         return all(obj.is_number for obj in self.args)
361 
362     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
363         """Return self evaluated, if possible, replacing free symbols with
364         random complex values, if necessary.
365 
366         The random complex value for each free symbol is generated
367         by the random_complex_number routine giving real and imaginary
368         parts in the range given by the re_min, re_max, im_min, and im_max
369         values. The returned value is evaluated to a precision of n
370         (if given) else the maximum of 15 and the precision needed
371         to get more than 1 digit of precision. If the expression
372         could not be evaluated to a number, or could not be evaluated
373         to more than 1 digit of precision, then None is returned.
374 
375         Examples
376         ========
377 
378         >>> from sympy import sqrt
379         >>> from sympy.abc import x, y
380         >>> x._random()                         # doctest: +SKIP
381         0.0392918155679172 + 0.916050214307199*I
382         >>> x._random(2)                        # doctest: +SKIP
383         -0.77 - 0.87*I
384         >>> (x + y/2)._random(2)                # doctest: +SKIP
385         -0.57 + 0.16*I
386         >>> sqrt(2)._random(2)
387         1.4
388 
389         See Also
390         ========
391 
392         sympy.utilities.randtest.random_complex_number
393         """
394 
395         free = self.free_symbols
396         prec = 1
397         if free:
398             from sympy.utilities.randtest import random_complex_number
399             a, c, b, d = re_min, re_max, im_min, im_max
400             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
401                            for zi in free])))
402             try:
403                 nmag = abs(self.evalf(2, subs=reps))
404             except (ValueError, TypeError):
405                 # if an out of range value resulted in evalf problems
406                 # then return None -- XXX is there a way to know how to
407                 # select a good random number for a given expression?
408                 # e.g. when calculating n! negative values for n should not
409                 # be used
410                 return None
411         else:
412             reps = {}
413             nmag = abs(self.evalf(2))
414 
415         if not hasattr(nmag, '_prec'):
416             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
417             return None
418 
419         if nmag._prec == 1:
420             # increase the precision up to the default maximum
421             # precision to see if we can get any significance
422 
423             from mpmath.libmp.libintmath import giant_steps
424             from sympy.core.evalf import DEFAULT_MAXPREC as target
425 
426             # evaluate
427             for prec in giant_steps(2, target):
428                 nmag = abs(self.evalf(prec, subs=reps))
429                 if nmag._prec != 1:
430                     break
431 
432         if nmag._prec != 1:
433             if n is None:
434                 n = max(prec, 15)
435             return self.evalf(n, subs=reps)
436 
437         # never got any significance
438         return None
439 
440     def is_constant(self, *wrt, **flags):
441         """Return True if self is constant, False if not, or None if
442         the constancy could not be determined conclusively.
443 
444         If an expression has no free symbols then it is a constant. If
445         there are free symbols it is possible that the expression is a
446         constant, perhaps (but not necessarily) zero. To test such
447         expressions, two strategies are tried:
448 
449         1) numerical evaluation at two random points. If two such evaluations
450         give two different values and the values have a precision greater than
451         1 then self is not constant. If the evaluations agree or could not be
452         obtained with any precision, no decision is made. The numerical testing
453         is done only if ``wrt`` is different than the free symbols.
454 
455         2) differentiation with respect to variables in 'wrt' (or all free
456         symbols if omitted) to see if the expression is constant or not. This
457         will not always lead to an expression that is zero even though an
458         expression is constant (see added test in test_expr.py). If
459         all derivatives are zero then self is constant with respect to the
460         given symbols.
461 
462         If neither evaluation nor differentiation can prove the expression is
463         constant, None is returned unless two numerical values happened to be
464         the same and the flag ``failing_number`` is True -- in that case the
465         numerical value will be returned.
466 
467         If flag simplify=False is passed, self will not be simplified;
468         the default is True since self should be simplified before testing.
469 
470         Examples
471         ========
472 
473         >>> from sympy import cos, sin, Sum, S, pi
474         >>> from sympy.abc import a, n, x, y
475         >>> x.is_constant()
476         False
477         >>> S(2).is_constant()
478         True
479         >>> Sum(x, (x, 1, 10)).is_constant()
480         True
481         >>> Sum(x, (x, 1, n)).is_constant()
482         False
483         >>> Sum(x, (x, 1, n)).is_constant(y)
484         True
485         >>> Sum(x, (x, 1, n)).is_constant(n)
486         False
487         >>> Sum(x, (x, 1, n)).is_constant(x)
488         True
489         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
490         >>> eq.is_constant()
491         True
492         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
493         True
494 
495         >>> (0**x).is_constant()
496         False
497         >>> x.is_constant()
498         False
499         >>> (x**x).is_constant()
500         False
501         >>> one = cos(x)**2 + sin(x)**2
502         >>> one.is_constant()
503         True
504         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
505         True
506         """
507 
508         simplify = flags.get('simplify', True)
509 
510         # Except for expressions that contain units, only one of these should
511         # be necessary since if something is
512         # known to be a number it should also know that there are no
513         # free symbols. But is_number quits as soon as it hits a non-number
514         # whereas free_symbols goes until all free symbols have been collected,
515         # thus is_number should be faster. But a double check on free symbols
516         # is made just in case there is a discrepancy between the two.
517         free = self.free_symbols
518         if self.is_number or not free:
519             # if the following assertion fails then that object's free_symbols
520             # method needs attention: if an expression is a number it cannot
521             # have free symbols
522             assert not free
523             return True
524 
525         # if we are only interested in some symbols and they are not in the
526         # free symbols then this expression is constant wrt those symbols
527         wrt = set(wrt)
528         if wrt and not wrt & free:
529             return True
530         wrt = wrt or free
531 
532         # simplify unless this has already been done
533         expr = self
534         if simplify:
535             expr = expr.simplify()
536 
537         # is_zero should be a quick assumptions check; it can be wrong for
538         # numbers (see test_is_not_constant test), giving False when it
539         # shouldn't, but hopefully it will never give True unless it is sure.
540         if expr.is_zero:
541             return True
542 
543         # try numerical evaluation to see if we get two different values
544         failing_number = None
545         if wrt == free:
546             # try 0 (for a) and 1 (for b)
547             try:
548                 a = expr.subs(list(zip(free, [0]*len(free))),
549                     simultaneous=True)
550                 if a is S.NaN:
551                     # evaluation may succeed when substitution fails
552                     a = expr._random(None, 0, 0, 0, 0)
553             except ZeroDivisionError:
554                 a = None
555             if a is not None and a is not S.NaN:
556                 try:
557                     b = expr.subs(list(zip(free, [1]*len(free))),
558                         simultaneous=True)
559                     if b is S.NaN:
560                         # evaluation may succeed when substitution fails
561                         b = expr._random(None, 1, 0, 1, 0)
562                 except ZeroDivisionError:
563                     b = None
564                 if b is not None and b is not S.NaN and b.equals(a) is False:
565                     return False
566                 # try random real
567                 b = expr._random(None, -1, 0, 1, 0)
568                 if b is not None and b is not S.NaN and b.equals(a) is False:
569                     return False
570                 # try random complex
571                 b = expr._random()
572                 if b is not None and b is not S.NaN:
573                     if b.equals(a) is False:
574                         return False
575                     failing_number = a if a.is_number else b
576 
577         # now we will test each wrt symbol (or all free symbols) to see if the
578         # expression depends on them or not using differentiation. This is
579         # not sufficient for all expressions, however, so we don't return
580         # False if we get a derivative other than 0 with free symbols.
581         for w in wrt:
582             deriv = expr.diff(w)
583             if simplify:
584                 deriv = deriv.simplify()
585             if deriv != 0:
586                 if not (pure_complex(deriv, or_real=True)):
587                     if flags.get('failing_number', False):
588                         return failing_number
589                     elif deriv.free_symbols:
590                         # dead line provided _random returns None in such cases
591                         return None
592                 return False
593         return True
594 
595     def equals(self, other, failing_expression=False):
596         """Return True if self == other, False if it doesn't, or None. If
597         failing_expression is True then the expression which did not simplify
598         to a 0 will be returned instead of None.
599 
600         If ``self`` is a Number (or complex number) that is not zero, then
601         the result is False.
602 
603         If ``self`` is a number and has not evaluated to zero, evalf will be
604         used to test whether the expression evaluates to zero. If it does so
605         and the result has significance (i.e. the precision is either -1, for
606         a Rational result, or is greater than 1) then the evalf value will be
607         used to return True or False.
608 
609         """
610         from sympy.simplify.simplify import nsimplify, simplify
611         from sympy.solvers.solveset import solveset
612         from sympy.polys.polyerrors import NotAlgebraic
613         from sympy.polys.numberfields import minimal_polynomial
614 
615         other = sympify(other)
616         if self == other:
617             return True
618 
619         # they aren't the same so see if we can make the difference 0;
620         # don't worry about doing simplification steps one at a time
621         # because if the expression ever goes to 0 then the subsequent
622         # simplification steps that are done will be very fast.
623         diff = factor_terms(simplify(self - other), radical=True)
624 
625         if not diff:
626             return True
627 
628         if not diff.has(Add, Mod):
629             # if there is no expanding to be done after simplifying
630             # then this can't be a zero
631             return False
632 
633         constant = diff.is_constant(simplify=False, failing_number=True)
634 
635         if constant is False:
636             return False
637 
638         if constant is None and (diff.free_symbols or not diff.is_number):
639             # e.g. unless the right simplification is done, a symbolic
640             # zero is possible (see expression of issue 6829: without
641             # simplification constant will be None).
642             return
643 
644         if constant is True:
645             ndiff = diff._random()
646             if ndiff:
647                 return False
648 
649         # sometimes we can use a simplified result to give a clue as to
650         # what the expression should be; if the expression is *not* zero
651         # then we should have been able to compute that and so now
652         # we can just consider the cases where the approximation appears
653         # to be zero -- we try to prove it via minimal_polynomial.
654         if diff.is_number:
655             approx = diff.nsimplify()
656             if not approx:
657                 # try to prove via self-consistency
658                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
659                 # it seems to work better to try big ones first
660                 surds.sort(key=lambda x: -x.args[0])
661                 for s in surds:
662                     try:
663                         # simplify is False here -- this expression has already
664                         # been identified as being hard to identify as zero;
665                         # we will handle the checking ourselves using nsimplify
666                         # to see if we are in the right ballpark or not and if so
667                         # *then* the simplification will be attempted.
668                         if s.is_Symbol:
669                             sol = list(solveset(diff, s))
670                         else:
671                             sol = [s]
672                         if sol:
673                             if s in sol:
674                                 return True
675                             if s.is_real:
676                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
677                                         for si in sol):
678                                     return True
679                     except NotImplementedError:
680                         pass
681 
682                 # try to prove with minimal_polynomial but know when
683                 # *not* to use this or else it can take a long time. e.g. issue 8354
684                 if True:  # change True to condition that assures non-hang
685                     try:
686                         mp = minimal_polynomial(diff)
687                         if mp.is_Symbol:
688                             return True
689                         return False
690                     except (NotAlgebraic, NotImplementedError):
691                         pass
692 
693         # diff has not simplified to zero; constant is either None, True
694         # or the number with significance (prec != 1) that was randomly
695         # calculated twice as the same value.
696         if constant not in (True, None) and constant != 0:
697             return False
698 
699         if failing_expression:
700             return diff
701         return None
702 
703     def _eval_is_positive(self):
704         from sympy.polys.numberfields import minimal_polynomial
705         from sympy.polys.polyerrors import NotAlgebraic
706         if self.is_number:
707             if self.is_real is False:
708                 return False
709             try:
710                 # check to see that we can get a value
711                 n2 = self._eval_evalf(2)
712                 if n2 is None:
713                     raise AttributeError
714                 if n2._prec == 1:  # no significance
715                     raise AttributeError
716                 if n2 == S.NaN:
717                     raise AttributeError
718             except (AttributeError, ValueError):
719                 return None
720             n, i = self.evalf(2).as_real_imag()
721             if not i.is_Number or not n.is_Number:
722                 return False
723             if n._prec != 1 and i._prec != 1:
724                 return bool(not i and n > 0)
725             elif n._prec == 1 and (not i or i._prec == 1) and \
726                     self.is_algebraic and not self.has(Function):
727                 try:
728                     if minimal_polynomial(self).is_Symbol:
729                         return False
730                 except (NotAlgebraic, NotImplementedError):
731                     pass
732 
733     def _eval_is_negative(self):
734         from sympy.polys.numberfields import minimal_polynomial
735         from sympy.polys.polyerrors import NotAlgebraic
736         if self.is_number:
737             if self.is_real is False:
738                 return False
739             try:
740                 # check to see that we can get a value
741                 n2 = self._eval_evalf(2)
742                 if n2 is None:
743                     raise AttributeError
744                 if n2._prec == 1:  # no significance
745                     raise AttributeError
746                 if n2 == S.NaN:
747                     raise AttributeError
748             except (AttributeError, ValueError):
749                 return None
750             n, i = self.evalf(2).as_real_imag()
751             if not i.is_Number or not n.is_Number:
752                 return False
753             if n._prec != 1 and i._prec != 1:
754                 return bool(not i and n < 0)
755             elif n._prec == 1 and (not i or i._prec == 1) and \
756                     self.is_algebraic and not self.has(Function):
757                 try:
758                     if minimal_polynomial(self).is_Symbol:
759                         return False
760                 except (NotAlgebraic, NotImplementedError):
761                     pass
762 
763     def _eval_interval(self, x, a, b):
764         """
765         Returns evaluation over an interval.  For most functions this is:
766 
767         self.subs(x, b) - self.subs(x, a),
768 
769         possibly using limit() if NaN is returned from subs.
770 
771         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
772         respectively.
773 
774         """
775         from sympy.series import limit, Limit
776         from sympy.solvers.solveset import solveset
777 
778         if (a is None and b is None):
779             raise ValueError('Both interval ends cannot be None.')
780 
781         if a == b:
782             return 0;
783 
784         if a is None:
785             A = 0
786         else:
787             A = self.subs(x, a)
788             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
789                 if (a < b) != False:
790                     A = limit(self, x, a,"+")
791                 else:
792                     A = limit(self, x, a,"-")
793 
794                 if A is S.NaN:
795                     return A
796                 if isinstance(A, Limit):
797                     raise NotImplementedError("Could not compute limit")
798 
799         if b is None:
800             B = 0
801         else:
802             B = self.subs(x, b)
803             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
804                 if (a < b) != False:
805                     B = limit(self, x, b,"-")
806                 else:
807                     B = limit(self, x, b,"+")
808 
809                 if isinstance(B, Limit):
810                     raise NotImplementedError("Could not compute limit")
811 
812         if (a and b) is None:
813             return B - A
814 
815         value = B - A
816 
817         if a.is_comparable and b.is_comparable:
818             singularities = list(solveset(self.cancel().as_numer_denom()[1], x))
819             for s in singularities:
820                 if a < s < b:
821                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
822                 elif b < s < a:
823                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
824 
825         return value
826 
827     def _eval_power(self, other):
828         # subclass to compute self**other for cases when
829         # other is not NaN, 0, or 1
830         return None
831 
832     def _eval_conjugate(self):
833         if self.is_real:
834             return self
835         elif self.is_imaginary:
836             return -self
837 
838     def conjugate(self):
839         from sympy.functions.elementary.complexes import conjugate as c
840         return c(self)
841 
842     def _eval_transpose(self):
843         from sympy.functions.elementary.complexes import conjugate
844         if self.is_complex:
845             return self
846         elif self.is_hermitian:
847             return conjugate(self)
848         elif self.is_antihermitian:
849             return -conjugate(self)
850 
851     def transpose(self):
852         from sympy.functions.elementary.complexes import transpose
853         return transpose(self)
854 
855     def _eval_adjoint(self):
856         from sympy.functions.elementary.complexes import conjugate, transpose
857         if self.is_hermitian:
858             return self
859         elif self.is_antihermitian:
860             return -self
861         obj = self._eval_conjugate()
862         if obj is not None:
863             return transpose(obj)
864         obj = self._eval_transpose()
865         if obj is not None:
866             return conjugate(obj)
867 
868     def adjoint(self):
869         from sympy.functions.elementary.complexes import adjoint
870         return adjoint(self)
871 
872     @classmethod
873     def _parse_order(cls, order):
874         """Parse and configure the ordering of terms. """
875         from sympy.polys.orderings import monomial_key
876 
877         try:
878             reverse = order.startswith('rev-')
879         except AttributeError:
880             reverse = False
881         else:
882             if reverse:
883                 order = order[4:]
884 
885         monom_key = monomial_key(order)
886 
887         def neg(monom):
888             result = []
889 
890             for m in monom:
891                 if isinstance(m, tuple):
892                     result.append(neg(m))
893                 else:
894                     result.append(-m)
895 
896             return tuple(result)
897 
898         def key(term):
899             _, ((re, im), monom, ncpart) = term
900 
901             monom = neg(monom_key(monom))
902             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
903             coeff = ((bool(im), im), (re, im))
904 
905             return monom, ncpart, coeff
906 
907         return key, reverse
908 
909     def as_ordered_factors(self, order=None):
910         """Return list of ordered factors (if Mul) else [self]."""
911         return [self]
912 
913     def as_ordered_terms(self, order=None, data=False):
914         """
915         Transform an expression to an ordered list of terms.
916 
917         Examples
918         ========
919 
920         >>> from sympy import sin, cos
921         >>> from sympy.abc import x
922 
923         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
924         [sin(x)**2*cos(x), sin(x)**2, 1]
925 
926         """
927         key, reverse = self._parse_order(order)
928         terms, gens = self.as_terms()
929 
930         if not any(term.is_Order for term, _ in terms):
931             ordered = sorted(terms, key=key, reverse=reverse)
932         else:
933             _terms, _order = [], []
934 
935             for term, repr in terms:
936                 if not term.is_Order:
937                     _terms.append((term, repr))
938                 else:
939                     _order.append((term, repr))
940 
941             ordered = sorted(_terms, key=key, reverse=True) \
942                 + sorted(_order, key=key, reverse=True)
943 
944         if data:
945             return ordered, gens
946         else:
947             return [term for term, _ in ordered]
948 
949     def as_terms(self):
950         """Transform an expression to a list of terms. """
951         from .add import Add
952         from .mul import Mul
953         from .exprtools import decompose_power
954 
955         gens, terms = set([]), []
956 
957         for term in Add.make_args(self):
958             coeff, _term = term.as_coeff_Mul()
959 
960             coeff = complex(coeff)
961             cpart, ncpart = {}, []
962 
963             if _term is not S.One:
964                 for factor in Mul.make_args(_term):
965                     if factor.is_number:
966                         try:
967                             coeff *= complex(factor)
968                         except TypeError:
969                             pass
970                         else:
971                             continue
972 
973                     if factor.is_commutative:
974                         base, exp = decompose_power(factor)
975 
976                         cpart[base] = exp
977                         gens.add(base)
978                     else:
979                         ncpart.append(factor)
980 
981             coeff = coeff.real, coeff.imag
982             ncpart = tuple(ncpart)
983 
984             terms.append((term, (coeff, cpart, ncpart)))
985 
986         gens = sorted(gens, key=default_sort_key)
987 
988         k, indices = len(gens), {}
989 
990         for i, g in enumerate(gens):
991             indices[g] = i
992 
993         result = []
994 
995         for term, (coeff, cpart, ncpart) in terms:
996             monom = [0]*k
997 
998             for base, exp in cpart.items():
999                 monom[indices[base]] = exp
1000 
1001             result.append((term, (coeff, tuple(monom), ncpart)))
1002 
1003         return result, gens
1004 
1005     def removeO(self):
1006         """Removes the additive O(..) symbol if there is one"""
1007         return self
1008 
1009     def getO(self):
1010         """Returns the additive O(..) symbol if there is one, else None."""
1011         return None
1012 
1013     def getn(self):
1014         """
1015         Returns the order of the expression.
1016 
1017         The order is determined either from the O(...) term. If there
1018         is no O(...) term, it returns None.
1019 
1020         Examples
1021         ========
1022 
1023         >>> from sympy import O
1024         >>> from sympy.abc import x
1025         >>> (1 + x + O(x**2)).getn()
1026         2
1027         >>> (1 + x).getn()
1028 
1029         """
1030         from sympy import Dummy, Symbol
1031         o = self.getO()
1032         if o is None:
1033             return None
1034         elif o.is_Order:
1035             o = o.expr
1036             if o is S.One:
1037                 return S.Zero
1038             if o.is_Symbol:
1039                 return S.One
1040             if o.is_Pow:
1041                 return o.args[1]
1042             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1043                 for oi in o.args:
1044                     if oi.is_Symbol:
1045                         return S.One
1046                     if oi.is_Pow:
1047                         syms = oi.atoms(Symbol)
1048                         if len(syms) == 1:
1049                             x = syms.pop()
1050                             oi = oi.subs(x, Dummy('x', positive=True))
1051                             if oi.base.is_Symbol and oi.exp.is_Rational:
1052                                 return abs(oi.exp)
1053 
1054         raise NotImplementedError('not sure of order of %s' % o)
1055 
1056     def count_ops(self, visual=None):
1057         """wrapper for count_ops that returns the operation count."""
1058         from .function import count_ops
1059         return count_ops(self, visual)
1060 
1061     def args_cnc(self, cset=False, warn=True, split_1=True):
1062         """Return [commutative factors, non-commutative factors] of self.
1063 
1064         self is treated as a Mul and the ordering of the factors is maintained.
1065         If ``cset`` is True the commutative factors will be returned in a set.
1066         If there were repeated factors (as may happen with an unevaluated Mul)
1067         then an error will be raised unless it is explicitly supressed by
1068         setting ``warn`` to False.
1069 
1070         Note: -1 is always separated from a Number unless split_1 is False.
1071 
1072         >>> from sympy import symbols, oo
1073         >>> A, B = symbols('A B', commutative=False)
1074         >>> x, y = symbols('x y')
1075         >>> (-2*x*y).args_cnc()
1076         [[-1, 2, x, y], []]
1077         >>> (-2.5*x).args_cnc()
1078         [[-1, 2.5, x], []]
1079         >>> (-2*x*A*B*y).args_cnc()
1080         [[-1, 2, x, y], [A, B]]
1081         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1082         [[-2, x, y], [A, B]]
1083         >>> (-2*x*y).args_cnc(cset=True)
1084         [{-1, 2, x, y}, []]
1085 
1086         The arg is always treated as a Mul:
1087 
1088         >>> (-2 + x + A).args_cnc()
1089         [[], [x - 2 + A]]
1090         >>> (-oo).args_cnc() # -oo is a singleton
1091         [[-1, oo], []]
1092         """
1093 
1094         if self.is_Mul:
1095             args = list(self.args)
1096         else:
1097             args = [self]
1098         for i, mi in enumerate(args):
1099             if not mi.is_commutative:
1100                 c = args[:i]
1101                 nc = args[i:]
1102                 break
1103         else:
1104             c = args
1105             nc = []
1106 
1107         if c and split_1 and (
1108             c[0].is_Number and
1109             c[0].is_negative and
1110                 c[0] is not S.NegativeOne):
1111             c[:1] = [S.NegativeOne, -c[0]]
1112 
1113         if cset:
1114             clen = len(c)
1115             c = set(c)
1116             if clen and warn and len(c) != clen:
1117                 raise ValueError('repeated commutative arguments: %s' %
1118                                  [ci for ci in c if list(self.args).count(ci) > 1])
1119         return [c, nc]
1120 
1121     def coeff(self, x, n=1, right=False):
1122         """
1123         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1124         is zero then all terms independent of ``x`` will be returned.
1125 
1126         When ``x`` is noncommutative, the coefficient to the left (default) or
1127         right of ``x`` can be returned. The keyword 'right' is ignored when
1128         ``x`` is commutative.
1129 
1130         See Also
1131         ========
1132 
1133         as_coefficient: separate the expression into a coefficient and factor
1134         as_coeff_Add: separate the additive constant from an expression
1135         as_coeff_Mul: separate the multiplicative constant from an expression
1136         as_independent: separate x-dependent terms/factors from others
1137         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1138         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1139 
1140         Examples
1141         ========
1142 
1143         >>> from sympy import symbols
1144         >>> from sympy.abc import x, y, z
1145 
1146         You can select terms that have an explicit negative in front of them:
1147 
1148         >>> (-x + 2*y).coeff(-1)
1149         x
1150         >>> (x - 2*y).coeff(-1)
1151         2*y
1152 
1153         You can select terms with no Rational coefficient:
1154 
1155         >>> (x + 2*y).coeff(1)
1156         x
1157         >>> (3 + 2*x + 4*x**2).coeff(1)
1158         0
1159 
1160         You can select terms independent of x by making n=0; in this case
1161         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1162         of None):
1163 
1164         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1165         3
1166         >>> eq = ((x + 1)**3).expand() + 1
1167         >>> eq
1168         x**3 + 3*x**2 + 3*x + 2
1169         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1170         [1, 3, 3, 2]
1171         >>> eq -= 2
1172         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1173         [1, 3, 3, 0]
1174 
1175         You can select terms that have a numerical term in front of them:
1176 
1177         >>> (-x - 2*y).coeff(2)
1178         -y
1179         >>> from sympy import sqrt
1180         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1181         x
1182 
1183         The matching is exact:
1184 
1185         >>> (3 + 2*x + 4*x**2).coeff(x)
1186         2
1187         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1188         4
1189         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1190         0
1191         >>> (z*(x + y)**2).coeff((x + y)**2)
1192         z
1193         >>> (z*(x + y)**2).coeff(x + y)
1194         0
1195 
1196         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1197         from the following:
1198 
1199         >>> (x + z*(x + x*y)).coeff(x)
1200         1
1201 
1202         If such factoring is desired, factor_terms can be used first:
1203 
1204         >>> from sympy import factor_terms
1205         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1206         z*(y + 1) + 1
1207 
1208         >>> n, m, o = symbols('n m o', commutative=False)
1209         >>> n.coeff(n)
1210         1
1211         >>> (3*n).coeff(n)
1212         3
1213         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1214         1 + m
1215         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1216         m
1217 
1218         If there is more than one possible coefficient 0 is returned:
1219 
1220         >>> (n*m + m*n).coeff(n)
1221         0
1222 
1223         If there is only one possible coefficient, it is returned:
1224 
1225         >>> (n*m + x*m*n).coeff(m*n)
1226         x
1227         >>> (n*m + x*m*n).coeff(m*n, right=1)
1228         1
1229 
1230         """
1231         x = sympify(x)
1232         if not isinstance(x, Basic):
1233             return S.Zero
1234 
1235         n = as_int(n)
1236 
1237         if not x:
1238             return S.Zero
1239 
1240         if x == self:
1241             if n == 1:
1242                 return S.One
1243             return S.Zero
1244 
1245         if x is S.One:
1246             co = [a for a in Add.make_args(self)
1247                   if a.as_coeff_Mul()[0] is S.One]
1248             if not co:
1249                 return S.Zero
1250             return Add(*co)
1251 
1252         if n == 0:
1253             if x.is_Add and self.is_Add:
1254                 c = self.coeff(x, right=right)
1255                 if not c:
1256                     return S.Zero
1257                 if not right:
1258                     return self - Add(*[a*x for a in Add.make_args(c)])
1259                 return self - Add(*[x*a for a in Add.make_args(c)])
1260             return self.as_independent(x, as_Add=True)[0]
1261 
1262         # continue with the full method, looking for this power of x:
1263         x = x**n
1264 
1265         def incommon(l1, l2):
1266             if not l1 or not l2:
1267                 return []
1268             n = min(len(l1), len(l2))
1269             for i in range(n):
1270                 if l1[i] != l2[i]:
1271                     return l1[:i]
1272             return l1[:]
1273 
1274         def find(l, sub, first=True):
1275             """ Find where list sub appears in list l. When ``first`` is True
1276             the first occurance from the left is returned, else the last
1277             occurance is returned. Return None if sub is not in l.
1278 
1279             >> l = range(5)*2
1280             >> find(l, [2, 3])
1281             2
1282             >> find(l, [2, 3], first=0)
1283             7
1284             >> find(l, [2, 4])
1285             None
1286 
1287             """
1288             if not sub or not l or len(sub) > len(l):
1289                 return None
1290             n = len(sub)
1291             if not first:
1292                 l.reverse()
1293                 sub.reverse()
1294             for i in range(0, len(l) - n + 1):
1295                 if all(l[i + j] == sub[j] for j in range(n)):
1296                     break
1297             else:
1298                 i = None
1299             if not first:
1300                 l.reverse()
1301                 sub.reverse()
1302             if i is not None and not first:
1303                 i = len(l) - (i + n)
1304             return i
1305 
1306         co = []
1307         args = Add.make_args(self)
1308         self_c = self.is_commutative
1309         x_c = x.is_commutative
1310         if self_c and not x_c:
1311             return S.Zero
1312 
1313         if self_c:
1314             xargs = x.args_cnc(cset=True, warn=False)[0]
1315             for a in args:
1316                 margs = a.args_cnc(cset=True, warn=False)[0]
1317                 if len(xargs) > len(margs):
1318                     continue
1319                 resid = margs.difference(xargs)
1320                 if len(resid) + len(xargs) == len(margs):
1321                     co.append(Mul(*resid))
1322             if co == []:
1323                 return S.Zero
1324             elif co:
1325                 return Add(*co)
1326         elif x_c:
1327             xargs = x.args_cnc(cset=True, warn=False)[0]
1328             for a in args:
1329                 margs, nc = a.args_cnc(cset=True)
1330                 if len(xargs) > len(margs):
1331                     continue
1332                 resid = margs.difference(xargs)
1333                 if len(resid) + len(xargs) == len(margs):
1334                     co.append(Mul(*(list(resid) + nc)))
1335             if co == []:
1336                 return S.Zero
1337             elif co:
1338                 return Add(*co)
1339         else:  # both nc
1340             xargs, nx = x.args_cnc(cset=True)
1341             # find the parts that pass the commutative terms
1342             for a in args:
1343                 margs, nc = a.args_cnc(cset=True)
1344                 if len(xargs) > len(margs):
1345                     continue
1346                 resid = margs.difference(xargs)
1347                 if len(resid) + len(xargs) == len(margs):
1348                     co.append((resid, nc))
1349             # now check the non-comm parts
1350             if not co:
1351                 return S.Zero
1352             if all(n == co[0][1] for r, n in co):
1353                 ii = find(co[0][1], nx, right)
1354                 if ii is not None:
1355                     if not right:
1356                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1357                     else:
1358                         return Mul(*co[0][1][ii + len(nx):])
1359             beg = reduce(incommon, (n[1] for n in co))
1360             if beg:
1361                 ii = find(beg, nx, right)
1362                 if ii is not None:
1363                     if not right:
1364                         gcdc = co[0][0]
1365                         for i in range(1, len(co)):
1366                             gcdc = gcdc.intersection(co[i][0])
1367                             if not gcdc:
1368                                 break
1369                         return Mul(*(list(gcdc) + beg[:ii]))
1370                     else:
1371                         m = ii + len(nx)
1372                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1373             end = list(reversed(
1374                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1375             if end:
1376                 ii = find(end, nx, right)
1377                 if ii is not None:
1378                     if not right:
1379                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1380                     else:
1381                         return Mul(*end[ii + len(nx):])
1382             # look for single match
1383             hit = None
1384             for i, (r, n) in enumerate(co):
1385                 ii = find(n, nx, right)
1386                 if ii is not None:
1387                     if not hit:
1388                         hit = ii, r, n
1389                     else:
1390                         break
1391             else:
1392                 if hit:
1393                     ii, r, n = hit
1394                     if not right:
1395                         return Mul(*(list(r) + n[:ii]))
1396                     else:
1397                         return Mul(*n[ii + len(nx):])
1398 
1399             return S.Zero
1400 
1401     def as_expr(self, *gens):
1402         """
1403         Convert a polynomial to a SymPy expression.
1404 
1405         Examples
1406         ========
1407 
1408         >>> from sympy import sin
1409         >>> from sympy.abc import x, y
1410 
1411         >>> f = (x**2 + x*y).as_poly(x, y)
1412         >>> f.as_expr()
1413         x**2 + x*y
1414 
1415         >>> sin(x).as_expr()
1416         sin(x)
1417 
1418         """
1419         return self
1420 
1421     def as_coefficient(self, expr):
1422         """
1423         Extracts symbolic coefficient at the given expression. In
1424         other words, this functions separates 'self' into the product
1425         of 'expr' and 'expr'-free coefficient. If such separation
1426         is not possible it will return None.
1427 
1428         Examples
1429         ========
1430 
1431         >>> from sympy import E, pi, sin, I, Poly
1432         >>> from sympy.abc import x
1433 
1434         >>> E.as_coefficient(E)
1435         1
1436         >>> (2*E).as_coefficient(E)
1437         2
1438         >>> (2*sin(E)*E).as_coefficient(E)
1439 
1440         Two terms have E in them so a sum is returned. (If one were
1441         desiring the coefficient of the term exactly matching E then
1442         the constant from the returned expression could be selected.
1443         Or, for greater precision, a method of Poly can be used to
1444         indicate the desired term from which the coefficient is
1445         desired.)
1446 
1447         >>> (2*E + x*E).as_coefficient(E)
1448         x + 2
1449         >>> _.args[0]  # just want the exact match
1450         2
1451         >>> p = Poly(2*E + x*E); p
1452         Poly(x*E + 2*E, x, E, domain='ZZ')
1453         >>> p.coeff_monomial(E)
1454         2
1455         >>> p.nth(0, 1)
1456         2
1457 
1458         Since the following cannot be written as a product containing
1459         E as a factor, None is returned. (If the coefficient ``2*x`` is
1460         desired then the ``coeff`` method should be used.)
1461 
1462         >>> (2*E*x + x).as_coefficient(E)
1463         >>> (2*E*x + x).coeff(E)
1464         2*x
1465 
1466         >>> (E*(x + 1) + x).as_coefficient(E)
1467 
1468         >>> (2*pi*I).as_coefficient(pi*I)
1469         2
1470         >>> (2*I).as_coefficient(pi*I)
1471 
1472         See Also
1473         ========
1474 
1475         coeff: return sum of terms have a given factor
1476         as_coeff_Add: separate the additive constant from an expression
1477         as_coeff_Mul: separate the multiplicative constant from an expression
1478         as_independent: separate x-dependent terms/factors from others
1479         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1480         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1481 
1482 
1483         """
1484 
1485         r = self.extract_multiplicatively(expr)
1486         if r and not r.has(expr):
1487             return r
1488 
1489     def as_independent(self, *deps, **hint):
1490         """
1491         A mostly naive separation of a Mul or Add into arguments that are not
1492         are dependent on deps. To obtain as complete a separation of variables
1493         as possible, use a separation method first, e.g.:
1494 
1495         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1496         * .expand(mul=True) to change Add or Mul into Add
1497         * .expand(log=True) to change log expr into an Add
1498 
1499         The only non-naive thing that is done here is to respect noncommutative
1500         ordering of variables and to always return (0, 0) for `self` of zero
1501         regardless of hints.
1502 
1503         For nonzero `self`, the returned tuple (i, d) has the
1504         following interpretation:
1505 
1506         * i will has no variable that appears in deps
1507         * d will be 1 or else have terms that contain variables that are in deps
1508         * if self is an Add then self = i + d
1509         * if self is a Mul then self = i*d
1510         * otherwise (self, S.One) or (S.One, self) is returned.
1511 
1512         To force the expression to be treated as an Add, use the hint as_Add=True
1513 
1514         Examples
1515         ========
1516 
1517         -- self is an Add
1518 
1519         >>> from sympy import sin, cos, exp
1520         >>> from sympy.abc import x, y, z
1521 
1522         >>> (x + x*y).as_independent(x)
1523         (0, x*y + x)
1524         >>> (x + x*y).as_independent(y)
1525         (x, x*y)
1526         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1527         (y + z, 2*x*sin(x) + x)
1528         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1529         (z, 2*x*sin(x) + x + y)
1530 
1531         -- self is a Mul
1532 
1533         >>> (x*sin(x)*cos(y)).as_independent(x)
1534         (cos(y), x*sin(x))
1535 
1536         non-commutative terms cannot always be separated out when self is a Mul
1537 
1538         >>> from sympy import symbols
1539         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1540         >>> (n1 + n1*n2).as_independent(n2)
1541         (n1, n1*n2)
1542         >>> (n2*n1 + n1*n2).as_independent(n2)
1543         (0, n1*n2 + n2*n1)
1544         >>> (n1*n2*n3).as_independent(n1)
1545         (1, n1*n2*n3)
1546         >>> (n1*n2*n3).as_independent(n2)
1547         (n1, n2*n3)
1548         >>> ((x-n1)*(x-y)).as_independent(x)
1549         (1, (x - y)*(x - n1))
1550 
1551         -- self is anything else:
1552 
1553         >>> (sin(x)).as_independent(x)
1554         (1, sin(x))
1555         >>> (sin(x)).as_independent(y)
1556         (sin(x), 1)
1557         >>> exp(x+y).as_independent(x)
1558         (1, exp(x + y))
1559 
1560         -- force self to be treated as an Add:
1561 
1562         >>> (3*x).as_independent(x, as_Add=True)
1563         (0, 3*x)
1564 
1565         -- force self to be treated as a Mul:
1566 
1567         >>> (3+x).as_independent(x, as_Add=False)
1568         (1, x + 3)
1569         >>> (-3+x).as_independent(x, as_Add=False)
1570         (1, x - 3)
1571 
1572         Note how the below differs from the above in making the
1573         constant on the dep term positive.
1574 
1575         >>> (y*(-3+x)).as_independent(x)
1576         (y, x - 3)
1577 
1578         -- use .as_independent() for true independence testing instead
1579            of .has(). The former considers only symbols in the free
1580            symbols while the latter considers all symbols
1581 
1582         >>> from sympy import Integral
1583         >>> I = Integral(x, (x, 1, 2))
1584         >>> I.has(x)
1585         True
1586         >>> x in I.free_symbols
1587         False
1588         >>> I.as_independent(x) == (I, 1)
1589         True
1590         >>> (I + x).as_independent(x) == (I, x)
1591         True
1592 
1593         Note: when trying to get independent terms, a separation method
1594         might need to be used first. In this case, it is important to keep
1595         track of what you send to this routine so you know how to interpret
1596         the returned values
1597 
1598         >>> from sympy import separatevars, log
1599         >>> separatevars(exp(x+y)).as_independent(x)
1600         (exp(y), exp(x))
1601         >>> (x + x*y).as_independent(y)
1602         (x, x*y)
1603         >>> separatevars(x + x*y).as_independent(y)
1604         (x, y + 1)
1605         >>> (x*(1 + y)).as_independent(y)
1606         (x, y + 1)
1607         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1608         (x, x*y)
1609         >>> a, b=symbols('a b', positive=True)
1610         >>> (log(a*b).expand(log=True)).as_independent(b)
1611         (log(a), log(b))
1612 
1613         See Also
1614         ========
1615         .separatevars(), .expand(log=True), Add.as_two_terms(),
1616         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1617         """
1618         from .symbol import Symbol
1619         from .add import _unevaluated_Add
1620         from .mul import _unevaluated_Mul
1621         from sympy.utilities.iterables import sift
1622 
1623         if self.is_zero:
1624             return S.Zero, S.Zero
1625 
1626         func = self.func
1627         if hint.get('as_Add', func is Add):
1628             want = Add
1629         else:
1630             want = Mul
1631 
1632         # sift out deps into symbolic and other and ignore
1633         # all symbols but those that are in the free symbols
1634         sym = set()
1635         other = []
1636         for d in deps:
1637             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1638                 sym.add(d)
1639             else:
1640                 other.append(d)
1641 
1642         def has(e):
1643             """return the standard has() if there are no literal symbols, else
1644             check to see that symbol-deps are in the free symbols."""
1645             has_other = e.has(*other)
1646             if not sym:
1647                 return has_other
1648             return has_other or e.has(*(e.free_symbols & sym))
1649 
1650         if (want is not func or
1651                 func is not Add and func is not Mul):
1652             if has(self):
1653                 return (want.identity, self)
1654             else:
1655                 return (self, want.identity)
1656         else:
1657             if func is Add:
1658                 args = list(self.args)
1659             else:
1660                 args, nc = self.args_cnc()
1661 
1662         d = sift(args, lambda x: has(x))
1663         depend = d[True]
1664         indep = d[False]
1665         if func is Add:  # all terms were treated as commutative
1666             return (Add(*indep), _unevaluated_Add(*depend))
1667         else:  # handle noncommutative by stopping at first dependent term
1668             for i, n in enumerate(nc):
1669                 if has(n):
1670                     depend.extend(nc[i:])
1671                     break
1672                 indep.append(n)
1673             return Mul(*indep), (
1674                 Mul(*depend, evaluate=False) if nc else
1675                 _unevaluated_Mul(*depend))
1676 
1677     def as_real_imag(self, deep=True, **hints):
1678         """Performs complex expansion on 'self' and returns a tuple
1679            containing collected both real and imaginary parts. This
1680            method can't be confused with re() and im() functions,
1681            which does not perform complex expansion at evaluation.
1682 
1683            However it is possible to expand both re() and im()
1684            functions and get exactly the same results as with
1685            a single call to this function.
1686 
1687            >>> from sympy import symbols, I
1688 
1689            >>> x, y = symbols('x,y', real=True)
1690 
1691            >>> (x + y*I).as_real_imag()
1692            (x, y)
1693 
1694            >>> from sympy.abc import z, w
1695 
1696            >>> (z + w*I).as_real_imag()
1697            (re(z) - im(w), re(w) + im(z))
1698 
1699         """
1700         from sympy import im, re
1701         if hints.get('ignore') == self:
1702             return None
1703         else:
1704             return (re(self), im(self))
1705 
1706     def as_powers_dict(self):
1707         """Return self as a dictionary of factors with each factor being
1708         treated as a power. The keys are the bases of the factors and the
1709         values, the corresponding exponents. The resulting dictionary should
1710         be used with caution if the expression is a Mul and contains non-
1711         commutative factors since the order that they appeared will be lost in
1712         the dictionary."""
1713         d = defaultdict(int)
1714         d.update(dict([self.as_base_exp()]))
1715         return d
1716 
1717     def as_coefficients_dict(self):
1718         """Return a dictionary mapping terms to their Rational coefficient.
1719         Since the dictionary is a defaultdict, inquiries about terms which
1720         were not present will return a coefficient of 0. If an expression is
1721         not an Add it is considered to have a single term.
1722 
1723         Examples
1724         ========
1725 
1726         >>> from sympy.abc import a, x
1727         >>> (3*x + a*x + 4).as_coefficients_dict()
1728         {1: 4, x: 3, a*x: 1}
1729         >>> _[a]
1730         0
1731         >>> (3*a*x).as_coefficients_dict()
1732         {a*x: 3}
1733 
1734         """
1735         c, m = self.as_coeff_Mul()
1736         if not c.is_Rational:
1737             c = S.One
1738             m = self
1739         d = defaultdict(int)
1740         d.update({m: c})
1741         return d
1742 
1743     def as_base_exp(self):
1744         # a -> b ** e
1745         return self, S.One
1746 
1747     def as_coeff_mul(self, *deps, **kwargs):
1748         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1749 
1750         c should be a Rational multiplied by any terms of the Mul that are
1751         independent of deps.
1752 
1753         args should be a tuple of all other terms of m; args is empty
1754         if self is a Number or if self is independent of deps (when given).
1755 
1756         This should be used when you don't know if self is a Mul or not but
1757         you want to treat self as a Mul or if you want to process the
1758         individual arguments of the tail of self as a Mul.
1759 
1760         - if you know self is a Mul and want only the head, use self.args[0];
1761         - if you don't want to process the arguments of the tail but need the
1762           tail then use self.as_two_terms() which gives the head and tail;
1763         - if you want to split self into an independent and dependent parts
1764           use ``self.as_independent(*deps)``
1765 
1766         >>> from sympy import S
1767         >>> from sympy.abc import x, y
1768         >>> (S(3)).as_coeff_mul()
1769         (3, ())
1770         >>> (3*x*y).as_coeff_mul()
1771         (3, (x, y))
1772         >>> (3*x*y).as_coeff_mul(x)
1773         (3*y, (x,))
1774         >>> (3*y).as_coeff_mul(x)
1775         (3*y, ())
1776         """
1777         if deps:
1778             if not self.has(*deps):
1779                 return self, tuple()
1780         return S.One, (self,)
1781 
1782     def as_coeff_add(self, *deps):
1783         """Return the tuple (c, args) where self is written as an Add, ``a``.
1784 
1785         c should be a Rational added to any terms of the Add that are
1786         independent of deps.
1787 
1788         args should be a tuple of all other terms of ``a``; args is empty
1789         if self is a Number or if self is independent of deps (when given).
1790 
1791         This should be used when you don't know if self is an Add or not but
1792         you want to treat self as an Add or if you want to process the
1793         individual arguments of the tail of self as an Add.
1794 
1795         - if you know self is an Add and want only the head, use self.args[0];
1796         - if you don't want to process the arguments of the tail but need the
1797           tail then use self.as_two_terms() which gives the head and tail.
1798         - if you want to split self into an independent and dependent parts
1799           use ``self.as_independent(*deps)``
1800 
1801         >>> from sympy import S
1802         >>> from sympy.abc import x, y
1803         >>> (S(3)).as_coeff_add()
1804         (3, ())
1805         >>> (3 + x).as_coeff_add()
1806         (3, (x,))
1807         >>> (3 + x + y).as_coeff_add(x)
1808         (y + 3, (x,))
1809         >>> (3 + y).as_coeff_add(x)
1810         (y + 3, ())
1811 
1812         """
1813         if deps:
1814             if not self.has(*deps):
1815                 return self, tuple()
1816         return S.Zero, (self,)
1817 
1818     def primitive(self):
1819         """Return the positive Rational that can be extracted non-recursively
1820         from every term of self (i.e., self is treated like an Add). This is
1821         like the as_coeff_Mul() method but primitive always extracts a positive
1822         Rational (never a negative or a Float).
1823 
1824         Examples
1825         ========
1826 
1827         >>> from sympy.abc import x
1828         >>> (3*(x + 1)**2).primitive()
1829         (3, (x + 1)**2)
1830         >>> a = (6*x + 2); a.primitive()
1831         (2, 3*x + 1)
1832         >>> b = (x/2 + 3); b.primitive()
1833         (1/2, x + 6)
1834         >>> (a*b).primitive() == (1, a*b)
1835         True
1836         """
1837         if not self:
1838             return S.One, S.Zero
1839         c, r = self.as_coeff_Mul(rational=True)
1840         if c.is_negative:
1841             c, r = -c, -r
1842         return c, r
1843 
1844     def as_content_primitive(self, radical=False, clear=True):
1845         """This method should recursively remove a Rational from all arguments
1846         and return that (content) and the new self (primitive). The content
1847         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1848         The primitive need no be in canonical form and should try to preserve
1849         the underlying structure if possible (i.e. expand_mul should not be
1850         applied to self).
1851 
1852         Examples
1853         ========
1854 
1855         >>> from sympy import sqrt
1856         >>> from sympy.abc import x, y, z
1857 
1858         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1859 
1860         The as_content_primitive function is recursive and retains structure:
1861 
1862         >>> eq.as_content_primitive()
1863         (2, x + 3*y*(y + 1) + 1)
1864 
1865         Integer powers will have Rationals extracted from the base:
1866 
1867         >>> ((2 + 6*x)**2).as_content_primitive()
1868         (4, (3*x + 1)**2)
1869         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1870         (1, (2*(3*x + 1))**(2*y))
1871 
1872         Terms may end up joining once their as_content_primitives are added:
1873 
1874         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1875         (11, x*(y + 1))
1876         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1877         (9, x*(y + 1))
1878         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1879         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1880         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1881         (121, x**2*(y + 1)**2)
1882         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1883         (1, 121.0*x**2*(y + 1)**2)
1884 
1885         Radical content can also be factored out of the primitive:
1886 
1887         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1888         (2, sqrt(2)*(1 + 2*sqrt(5)))
1889 
1890         If clear=False (default is True) then content will not be removed
1891         from an Add if it can be distributed to leave one or more
1892         terms with integer coefficients.
1893 
1894         >>> (x/2 + y).as_content_primitive()
1895         (1/2, x + 2*y)
1896         >>> (x/2 + y).as_content_primitive(clear=False)
1897         (1, x/2 + y)
1898         """
1899         return S.One, self
1900 
1901     def as_numer_denom(self):
1902         """ expression -> a/b -> a, b
1903 
1904         This is just a stub that should be defined by
1905         an object's class methods to get anything else.
1906 
1907         See Also
1908         ========
1909         normal: return a/b instead of a, b
1910         """
1911 
1912         return self, S.One
1913 
1914     def normal(self):
1915         n, d = self.as_numer_denom()
1916         if d is S.One:
1917             return n
1918         return n/d
1919 
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)
2027 
2028     def extract_additively(self, c):
2029         """Return self - c if it's possible to subtract c from self and
2030         make all matching coefficients move towards zero, else return None.
2031 
2032         Examples
2033         ========
2034 
2035         >>> from sympy.abc import x, y
2036         >>> e = 2*x + 3
2037         >>> e.extract_additively(x + 1)
2038         x + 2
2039         >>> e.extract_additively(3*x)
2040         >>> e.extract_additively(4)
2041         >>> (y*(x + 1)).extract_additively(x + 1)
2042         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2043         (x + 1)*(x + 2*y) + 3
2044 
2045         Sometimes auto-expansion will return a less simplified result
2046         than desired; gcd_terms might be used in such cases:
2047 
2048         >>> from sympy import gcd_terms
2049         >>> (4*x*(y + 1) + y).extract_additively(x)
2050         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2051         >>> gcd_terms(_)
2052         x*(4*y + 3) + y
2053 
2054         See Also
2055         ========
2056         extract_multiplicatively
2057         coeff
2058         as_coefficient
2059 
2060         """
2061 
2062         c = sympify(c)
2063         if self is S.NaN:
2064             return None
2065         if c is S.Zero:
2066             return self
2067         elif c == self:
2068             return S.Zero
2069         elif self is S.Zero:
2070             return None
2071 
2072         if self.is_Number:
2073             if not c.is_Number:
2074                 return None
2075             co = self
2076             diff = co - c
2077             # XXX should we match types? i.e should 3 - .1 succeed?
2078             if (co > 0 and diff > 0 and diff < co or
2079                     co < 0 and diff < 0 and diff > co):
2080                 return diff
2081             return None
2082 
2083         if c.is_Number:
2084             co, t = self.as_coeff_Add()
2085             xa = co.extract_additively(c)
2086             if xa is None:
2087                 return None
2088             return xa + t
2089 
2090         # handle the args[0].is_Number case separately
2091         # since we will have trouble looking for the coeff of
2092         # a number.
2093         if c.is_Add and c.args[0].is_Number:
2094             # whole term as a term factor
2095             co = self.coeff(c)
2096             xa0 = (co.extract_additively(1) or 0)*c
2097             if xa0:
2098                 diff = self - co*c
2099                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2100             # term-wise
2101             h, t = c.as_coeff_Add()
2102             sh, st = self.as_coeff_Add()
2103             xa = sh.extract_additively(h)
2104             if xa is None:
2105                 return None
2106             xa2 = st.extract_additively(t)
2107             if xa2 is None:
2108                 return None
2109             return xa + xa2
2110 
2111         # whole term as a term factor
2112         co = self.coeff(c)
2113         xa0 = (co.extract_additively(1) or 0)*c
2114         if xa0:
2115             diff = self - co*c
2116             return (xa0 + (diff.extract_additively(c) or diff)) or None
2117         # term-wise
2118         coeffs = []
2119         for a in Add.make_args(c):
2120             ac, at = a.as_coeff_Mul()
2121             co = self.coeff(at)
2122             if not co:
2123                 return None
2124             coc, cot = co.as_coeff_Add()
2125             xa = coc.extract_additively(ac)
2126             if xa is None:
2127                 return None
2128             self -= co*at
2129             coeffs.append((cot + xa)*at)
2130         coeffs.append(self)
2131         return Add(*coeffs)
2132 
2133     def could_extract_minus_sign(self):
2134         """Canonical way to choose an element in the set {e, -e} where
2135            e is any expression. If the canonical element is e, we have
2136            e.could_extract_minus_sign() == True, else
2137            e.could_extract_minus_sign() == False.
2138 
2139            For any expression, the set ``{e.could_extract_minus_sign(),
2140            (-e).could_extract_minus_sign()}`` must be ``{True, False}``.
2141 
2142            >>> from sympy.abc import x, y
2143            >>> (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()
2144            True
2145 
2146         """
2147         negative_self = -self
2148         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2149         negative_self_has_minus = (
2150             (negative_self).extract_multiplicatively(-1) is not None)
2151         if self_has_minus != negative_self_has_minus:
2152             return self_has_minus
2153         else:
2154             if self.is_Add:
2155                 # We choose the one with less arguments with minus signs
2156                 all_args = len(self.args)
2157                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2158                 positive_args = all_args - negative_args
2159                 if positive_args > negative_args:
2160                     return False
2161                 elif positive_args < negative_args:
2162                     return True
2163             elif self.is_Mul:
2164                 # We choose the one with an odd number of minus signs
2165                 num, den = self.as_numer_denom()
2166                 args = Mul.make_args(num) + Mul.make_args(den)
2167                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2168                 negative_args = list(filter(None, arg_signs))
2169                 return len(negative_args) % 2 == 1
2170 
2171             # As a last resort, we choose the one with greater value of .sort_key()
2172             return bool(self.sort_key() < negative_self.sort_key())
2173 
2174     def extract_branch_factor(self, allow_half=False):
2175         """
2176         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2177         Return (z, n).
2178 
2179         >>> from sympy import exp_polar, I, pi
2180         >>> from sympy.abc import x, y
2181         >>> exp_polar(I*pi).extract_branch_factor()
2182         (exp_polar(I*pi), 0)
2183         >>> exp_polar(2*I*pi).extract_branch_factor()
2184         (1, 1)
2185         >>> exp_polar(-pi*I).extract_branch_factor()
2186         (exp_polar(I*pi), -1)
2187         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2188         (exp_polar(x + I*pi), 1)
2189         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2190         (y*exp_polar(2*pi*x), -1)
2191         >>> exp_polar(-I*pi/2).extract_branch_factor()
2192         (exp_polar(-I*pi/2), 0)
2193 
2194         If allow_half is True, also extract exp_polar(I*pi):
2195 
2196         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2197         (1, 1/2)
2198         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2199         (1, 1)
2200         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2201         (1, 3/2)
2202         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2203         (1, -1/2)
2204         """
2205         from sympy import exp_polar, pi, I, ceiling, Add
2206         n = S(0)
2207         res = S(1)
2208         args = Mul.make_args(self)
2209         exps = []
2210         for arg in args:
2211             if arg.func is exp_polar:
2212                 exps += [arg.exp]
2213             else:
2214                 res *= arg
2215         piimult = S(0)
2216         extras = []
2217         while exps:
2218             exp = exps.pop()
2219             if exp.is_Add:
2220                 exps += exp.args
2221                 continue
2222             if exp.is_Mul:
2223                 coeff = exp.as_coefficient(pi*I)
2224                 if coeff is not None:
2225                     piimult += coeff
2226                     continue
2227             extras += [exp]
2228         if not piimult.free_symbols:
2229             coeff = piimult
2230             tail = ()
2231         else:
2232             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2233         # round down to nearest multiple of 2
2234         branchfact = ceiling(coeff/2 - S(1)/2)*2
2235         n += branchfact/2
2236         c = coeff - branchfact
2237         if allow_half:
2238             nc = c.extract_additively(1)
2239             if nc is not None:
2240                 n += S(1)/2
2241                 c = nc
2242         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2243         if newexp != 0:
2244             res *= exp_polar(newexp)
2245         return res, n
2246 
2247     def _eval_is_polynomial(self, syms):
2248         if self.free_symbols.intersection(syms) == set([]):
2249             return True
2250         return False
2251 
2252     def is_polynomial(self, *syms):
2253         """
2254         Return True if self is a polynomial in syms and False otherwise.
2255 
2256         This checks if self is an exact polynomial in syms.  This function
2257         returns False for expressions that are "polynomials" with symbolic
2258         exponents.  Thus, you should be able to apply polynomial algorithms to
2259         expressions for which this returns True, and Poly(expr, \*syms) should
2260         work if and only if expr.is_polynomial(\*syms) returns True. The
2261         polynomial does not have to be in expanded form.  If no symbols are
2262         given, all free symbols in the expression will be used.
2263 
2264         This is not part of the assumptions system.  You cannot do
2265         Symbol('z', polynomial=True).
2266 
2267         Examples
2268         ========
2269 
2270         >>> from sympy import Symbol
2271         >>> x = Symbol('x')
2272         >>> ((x**2 + 1)**4).is_polynomial(x)
2273         True
2274         >>> ((x**2 + 1)**4).is_polynomial()
2275         True
2276         >>> (2**x + 1).is_polynomial(x)
2277         False
2278 
2279 
2280         >>> n = Symbol('n', nonnegative=True, integer=True)
2281         >>> (x**n + 1).is_polynomial(x)
2282         False
2283 
2284         This function does not attempt any nontrivial simplifications that may
2285         result in an expression that does not appear to be a polynomial to
2286         become one.
2287 
2288         >>> from sympy import sqrt, factor, cancel
2289         >>> y = Symbol('y', positive=True)
2290         >>> a = sqrt(y**2 + 2*y + 1)
2291         >>> a.is_polynomial(y)
2292         False
2293         >>> factor(a)
2294         y + 1
2295         >>> factor(a).is_polynomial(y)
2296         True
2297 
2298         >>> b = (y**2 + 2*y + 1)/(y + 1)
2299         >>> b.is_polynomial(y)
2300         False
2301         >>> cancel(b)
2302         y + 1
2303         >>> cancel(b).is_polynomial(y)
2304         True
2305 
2306         See also .is_rational_function()
2307 
2308         """
2309         if syms:
2310             syms = set(map(sympify, syms))
2311         else:
2312             syms = self.free_symbols
2313 
2314         if syms.intersection(self.free_symbols) == set([]):
2315             # constant polynomial
2316             return True
2317         else:
2318             return self._eval_is_polynomial(syms)
2319 
2320     def _eval_is_rational_function(self, syms):
2321         if self.free_symbols.intersection(syms) == set([]):
2322             return True
2323         return False
2324 
2325     def is_rational_function(self, *syms):
2326         """
2327         Test whether function is a ratio of two polynomials in the given
2328         symbols, syms. When syms is not given, all free symbols will be used.
2329         The rational function does not have to be in expanded or in any kind of
2330         canonical form.
2331 
2332         This function returns False for expressions that are "rational
2333         functions" with symbolic exponents.  Thus, you should be able to call
2334         .as_numer_denom() and apply polynomial algorithms to the result for
2335         expressions for which this returns True.
2336 
2337         This is not part of the assumptions system.  You cannot do
2338         Symbol('z', rational_function=True).
2339 
2340         Examples
2341         ========
2342 
2343         >>> from sympy import Symbol, sin
2344         >>> from sympy.abc import x, y
2345 
2346         >>> (x/y).is_rational_function()
2347         True
2348 
2349         >>> (x**2).is_rational_function()
2350         True
2351 
2352         >>> (x/sin(y)).is_rational_function(y)
2353         False
2354 
2355         >>> n = Symbol('n', integer=True)
2356         >>> (x**n + 1).is_rational_function(x)
2357         False
2358 
2359         This function does not attempt any nontrivial simplifications that may
2360         result in an expression that does not appear to be a rational function
2361         to become one.
2362 
2363         >>> from sympy import sqrt, factor
2364         >>> y = Symbol('y', positive=True)
2365         >>> a = sqrt(y**2 + 2*y + 1)/y
2366         >>> a.is_rational_function(y)
2367         False
2368         >>> factor(a)
2369         (y + 1)/y
2370         >>> factor(a).is_rational_function(y)
2371         True
2372 
2373         See also is_algebraic_expr().
2374 
2375         """
2376         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2377             return False
2378 
2379         if syms:
2380             syms = set(map(sympify, syms))
2381         else:
2382             syms = self.free_symbols
2383 
2384         if syms.intersection(self.free_symbols) == set([]):
2385             # constant rational function
2386             return True
2387         else:
2388             return self._eval_is_rational_function(syms)
2389 
2390     def _eval_is_algebraic_expr(self, syms):
2391         if self.free_symbols.intersection(syms) == set([]):
2392             return True
2393         return False
2394 
2395     def is_algebraic_expr(self, *syms):
2396         """
2397         This tests whether a given expression is algebraic or not, in the
2398         given symbols, syms. When syms is not given, all free symbols
2399         will be used. The rational function does not have to be in expanded
2400         or in any kind of canonical form.
2401 
2402         This function returns False for expressions that are "algebraic
2403         expressions" with symbolic exponents. This is a simple extension to the
2404         is_rational_function, including rational exponentiation.
2405 
2406         Examples
2407         ========
2408 
2409         >>> from sympy import Symbol, sqrt
2410         >>> x = Symbol('x', real=True)
2411         >>> sqrt(1 + x).is_rational_function()
2412         False
2413         >>> sqrt(1 + x).is_algebraic_expr()
2414         True
2415 
2416         This function does not attempt any nontrivial simplifications that may
2417         result in an expression that does not appear to be an algebraic
2418         expression to become one.
2419 
2420         >>> from sympy import exp, factor
2421         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2422         >>> a.is_algebraic_expr(x)
2423         False
2424         >>> factor(a).is_algebraic_expr()
2425         True
2426 
2427         See Also
2428         ========
2429         is_rational_function()
2430 
2431         References
2432         ==========
2433 
2434         - http://en.wikipedia.org/wiki/Algebraic_expression
2435 
2436         """
2437         if syms:
2438             syms = set(map(sympify, syms))
2439         else:
2440             syms = self.free_symbols
2441 
2442         if syms.intersection(self.free_symbols) == set([]):
2443             # constant algebraic expression
2444             return True
2445         else:
2446             return self._eval_is_algebraic_expr(syms)
2447 
2448     ###################################################################################
2449     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2450     ###################################################################################
2451 
2452     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2453         """
2454         Series expansion of "self" around ``x = x0`` yielding either terms of
2455         the series one by one (the lazy series given when n=None), else
2456         all the terms at once when n != None.
2457 
2458         Returns the series expansion of "self" around the point ``x = x0``
2459         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2460 
2461         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2462         be supplied, otherwise an error will be raised.
2463 
2464         >>> from sympy import cos, exp
2465         >>> from sympy.abc import x, y
2466         >>> cos(x).series()
2467         1 - x**2/2 + x**4/24 + O(x**6)
2468         >>> cos(x).series(n=4)
2469         1 - x**2/2 + O(x**4)
2470         >>> cos(x).series(x, x0=1, n=2)
2471         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2472         >>> e = cos(x + exp(y))
2473         >>> e.series(y, n=2)
2474         cos(x + 1) - y*sin(x + 1) + O(y**2)
2475         >>> e.series(x, n=2)
2476         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2477 
2478         If ``n=None`` then a generator of the series terms will be returned.
2479 
2480         >>> term=cos(x).series(n=None)
2481         >>> [next(term) for i in range(2)]
2482         [1, -x**2/2]
2483 
2484         For ``dir=+`` (default) the series is calculated from the right and
2485         for ``dir=-`` the series from the left. For smooth functions this
2486         flag will not alter the results.
2487 
2488         >>> abs(x).series(dir="+")
2489         x
2490         >>> abs(x).series(dir="-")
2491         -x
2492 
2493         """
2494         from sympy import collect, Dummy, Order, Rational, Symbol
2495         if x is None:
2496             syms = self.atoms(Symbol)
2497             if not syms:
2498                 return self
2499             elif len(syms) > 1:
2500                 raise ValueError('x must be given for multivariate functions.')
2501             x = syms.pop()
2502 
2503         if not self.has(x):
2504             if n is None:
2505                 return (s for s in [self])
2506             else:
2507                 return self
2508 
2509         if len(dir) != 1 or dir not in '+-':
2510             raise ValueError("Dir must be '+' or '-'")
2511 
2512         if x0 in [S.Infinity, S.NegativeInfinity]:
2513             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2514             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2515             if n is None:
2516                 return (si.subs(x, 1/x) for si in s)
2517             return s.subs(x, 1/x)
2518 
2519         # use rep to shift origin to x0 and change sign (if dir is negative)
2520         # and undo the process with rep2
2521         if x0 or dir == '-':
2522             if dir == '-':
2523                 rep = -x + x0
2524                 rep2 = -x
2525                 rep2b = x0
2526             else:
2527                 rep = x + x0
2528                 rep2 = x
2529                 rep2b = -x0
2530             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2531             if n is None:  # lseries...
2532                 return (si.subs(x, rep2 + rep2b) for si in s)
2533             return s.subs(x, rep2 + rep2b)
2534 
2535         # from here on it's x0=0 and dir='+' handling
2536 
2537         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2538             # replace x with an x that has a positive assumption
2539             xpos = Dummy('x', positive=True, finite=True)
2540             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2541             if n is None:
2542                 return (s.subs(xpos, x) for s in rv)
2543             else:
2544                 return rv.subs(xpos, x)
2545 
2546         if n is not None:  # nseries handling
2547             s1 = self._eval_nseries(x, n=n, logx=logx)
2548             o = s1.getO() or S.Zero
2549             if o:
2550                 # make sure the requested order is returned
2551                 ngot = o.getn()
2552                 if ngot > n:
2553                     # leave o in its current form (e.g. with x*log(x)) so
2554                     # it eats terms properly, then replace it below
2555                     if n != 0:
2556                         s1 += o.subs(x, x**Rational(n, ngot))
2557                     else:
2558                         s1 += Order(1, x)
2559                 elif ngot < n:
2560                     # increase the requested number of terms to get the desired
2561                     # number keep increasing (up to 9) until the received order
2562                     # is different than the original order and then predict how
2563                     # many additional terms are needed
2564                     for more in range(1, 9):
2565                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2566                         newn = s1.getn()
2567                         if newn != ngot:
2568                             ndo = n + (n - ngot)*more/(newn - ngot)
2569                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2570                             while s1.getn() < n:
2571                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2572                                 ndo += 1
2573                             break
2574                     else:
2575                         raise ValueError('Could not calculate %s terms for %s'
2576                                          % (str(n), self))
2577                     s1 += Order(x**n, x)
2578                 o = s1.getO()
2579                 s1 = s1.removeO()
2580             else:
2581                 o = Order(x**n, x)
2582                 s1done = s1.doit()
2583                 if (s1done + o).removeO() == s1done:
2584                     o = S.Zero
2585 
2586             try:
2587                 return collect(s1, x) + o
2588             except NotImplementedError:
2589                 return s1 + o
2590 
2591         else:  # lseries handling
2592             def yield_lseries(s):
2593                 """Return terms of lseries one at a time."""
2594                 for si in s:
2595                     if not si.is_Add:
2596                         yield si
2597                         continue
2598                     # yield terms 1 at a time if possible
2599                     # by increasing order until all the
2600                     # terms have been returned
2601                     yielded = 0
2602                     o = Order(si, x)*x
2603                     ndid = 0
2604                     ndo = len(si.args)
2605                     while 1:
2606                         do = (si - yielded + o).removeO()
2607                         o *= x
2608                         if not do or do.is_Order:
2609                             continue
2610                         if do.is_Add:
2611                             ndid += len(do.args)
2612                         else:
2613                             ndid += 1
2614                         yield do
2615                         if ndid == ndo:
2616                             break
2617                         yielded += do
2618 
2619             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2620 
2621     def taylor_term(self, n, x, *previous_terms):
2622         """General method for the taylor term.
2623 
2624         This method is slow, because it differentiates n-times. Subclasses can
2625         redefine it to make it faster by using the "previous_terms".
2626         """
2627         from sympy import Dummy, factorial
2628         x = sympify(x)
2629         _x = Dummy('x')
2630         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2631 
2632     def lseries(self, x=None, x0=0, dir='+', logx=None):
2633         """
2634         Wrapper for series yielding an iterator of the terms of the series.
2635 
2636         Note: an infinite series will yield an infinite iterator. The following,
2637         for exaxmple, will never terminate. It will just keep printing terms
2638         of the sin(x) series::
2639 
2640           for term in sin(x).lseries(x):
2641               print term
2642 
2643         The advantage of lseries() over nseries() is that many times you are
2644         just interested in the next term in the series (i.e. the first term for
2645         example), but you don't know how many you should ask for in nseries()
2646         using the "n" parameter.
2647 
2648         See also nseries().
2649         """
2650         return self.series(x, x0, n=None, dir=dir, logx=logx)
2651 
2652     def _eval_lseries(self, x, logx=None):
2653         # default implementation of lseries is using nseries(), and adaptively
2654         # increasing the "n". As you can see, it is not very efficient, because
2655         # we are calculating the series over and over again. Subclasses should
2656         # override this method and implement much more efficient yielding of
2657         # terms.
2658         n = 0
2659         series = self._eval_nseries(x, n=n, logx=logx)
2660         if not series.is_Order:
2661             if series.is_Add:
2662                 yield series.removeO()
2663             else:
2664                 yield series
2665             return
2666 
2667         while series.is_Order:
2668             n += 1
2669             series = self._eval_nseries(x, n=n, logx=logx)
2670         e = series.removeO()
2671         yield e
2672         while 1:
2673             while 1:
2674                 n += 1
2675                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2676                 if e != series:
2677                     break
2678             yield series - e
2679             e = series
2680 
2681     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2682         """
2683         Wrapper to _eval_nseries if assumptions allow, else to series.
2684 
2685         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2686         called. This calculates "n" terms in the innermost expressions and
2687         then builds up the final series just by "cross-multiplying" everything
2688         out.
2689 
2690         The optional ``logx`` parameter can be used to replace any log(x) in the
2691         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2692         symbol to use in place of log(x) should be provided.
2693 
2694         Advantage -- it's fast, because we don't have to determine how many
2695         terms we need to calculate in advance.
2696 
2697         Disadvantage -- you may end up with less terms than you may have
2698         expected, but the O(x**n) term appended will always be correct and
2699         so the result, though perhaps shorter, will also be correct.
2700 
2701         If any of those assumptions is not met, this is treated like a
2702         wrapper to series which will try harder to return the correct
2703         number of terms.
2704 
2705         See also lseries().
2706 
2707         Examples
2708         ========
2709 
2710         >>> from sympy import sin, log, Symbol
2711         >>> from sympy.abc import x, y
2712         >>> sin(x).nseries(x, 0, 6)
2713         x - x**3/6 + x**5/120 + O(x**6)
2714         >>> log(x+1).nseries(x, 0, 5)
2715         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2716 
2717         Handling of the ``logx`` parameter --- in the following example the
2718         expansion fails since ``sin`` does not have an asymptotic expansion
2719         at -oo (the limit of log(x) as x approaches 0):
2720 
2721         >>> e = sin(log(x))
2722         >>> e.nseries(x, 0, 6)
2723         Traceback (most recent call last):
2724         ...
2725         PoleError: ...
2726         ...
2727         >>> logx = Symbol('logx')
2728         >>> e.nseries(x, 0, 6, logx=logx)
2729         sin(logx)
2730 
2731         In the following example, the expansion works but gives only an Order term
2732         unless the ``logx`` parameter is used:
2733 
2734         >>> e = x**y
2735         >>> e.nseries(x, 0, 2)
2736         O(log(x)**2)
2737         >>> e.nseries(x, 0, 2, logx=logx)
2738         exp(logx*y)
2739 
2740         """
2741         if x and not x in self.free_symbols:
2742             return self
2743         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2744             return self.series(x, x0, n, dir)
2745         else:
2746             return self._eval_nseries(x, n=n, logx=logx)
2747 
2748     def _eval_nseries(self, x, n, logx):
2749         """
2750         Return terms of series for self up to O(x**n) at x=0
2751         from the positive direction.
2752 
2753         This is a method that should be overridden in subclasses. Users should
2754         never call this method directly (use .nseries() instead), so you don't
2755         have to write docstrings for _eval_nseries().
2756         """
2757         from sympy.utilities.misc import filldedent
2758         raise NotImplementedError(filldedent("""
2759                      The _eval_nseries method should be added to
2760                      %s to give terms up to O(x**n) at x=0
2761                      from the positive direction so it is available when
2762                      nseries calls it.""" % self.func)
2763                      )
2764 
2765     def limit(self, x, xlim, dir='+'):
2766         """ Compute limit x->xlim.
2767         """
2768         from sympy.series.limits import limit
2769         return limit(self, x, xlim, dir)
2770 
2771     def compute_leading_term(self, x, logx=None):
2772         """
2773         as_leading_term is only allowed for results of .series()
2774         This is a wrapper to compute a series first.
2775         """
2776         from sympy import Dummy, log
2777         from sympy.series.gruntz import calculate_series
2778 
2779         if self.removeO() == 0:
2780             return self
2781 
2782         if logx is None:
2783             d = Dummy('logx')
2784             s = calculate_series(self, x, d).subs(d, log(x))
2785         else:
2786             s = calculate_series(self, x, logx)
2787 
2788         return s.as_leading_term(x)
2789 
2790     @cacheit
2791     def as_leading_term(self, *symbols):
2792         """
2793         Returns the leading (nonzero) term of the series expansion of self.
2794 
2795         The _eval_as_leading_term routines are used to do this, and they must
2796         always return a non-zero value.
2797 
2798         Examples
2799         ========
2800 
2801         >>> from sympy.abc import x
2802         >>> (1 + x + x**2).as_leading_term(x)
2803         1
2804         >>> (1/x**2 + x + x**2).as_leading_term(x)
2805         x**(-2)
2806 
2807         """
2808         from sympy import powsimp
2809         if len(symbols) > 1:
2810             c = self
2811             for x in symbols:
2812                 c = c.as_leading_term(x)
2813             return c
2814         elif not symbols:
2815             return self
2816         x = sympify(symbols[0])
2817         if not x.is_Symbol:
2818             raise ValueError('expecting a Symbol but got %s' % x)
2819         if x not in self.free_symbols:
2820             return self
2821         obj = self._eval_as_leading_term(x)
2822         if obj is not None:
2823             return powsimp(obj, deep=True, combine='exp')
2824         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2825 
2826     def _eval_as_leading_term(self, x):
2827         return self
2828 
2829     def as_coeff_exponent(self, x):
2830         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2831         """
2832         from sympy import collect
2833         s = collect(self, x)
2834         c, p = s.as_coeff_mul(x)
2835         if len(p) == 1:
2836             b, e = p[0].as_base_exp()
2837             if b == x:
2838                 return c, e
2839         return s, S.Zero
2840 
2841     def leadterm(self, x):
2842         """
2843         Returns the leading term a*x**b as a tuple (a, b).
2844 
2845         Examples
2846         ========
2847 
2848         >>> from sympy.abc import x
2849         >>> (1+x+x**2).leadterm(x)
2850         (1, 0)
2851         >>> (1/x**2+x+x**2).leadterm(x)
2852         (1, -2)
2853 
2854         """
2855         from sympy import Dummy, log
2856         l = self.as_leading_term(x)
2857         d = Dummy('logx')
2858         if l.has(log(x)):
2859             l = l.subs(log(x), d)
2860         c, e = l.as_coeff_exponent(x)
2861         if x in c.free_symbols:
2862             from sympy.utilities.misc import filldedent
2863             raise ValueError(filldedent("""
2864                 cannot compute leadterm(%s, %s). The coefficient
2865                 should have been free of x but got %s""" % (self, x, c)))
2866         c = c.subs(d, log(x))
2867         return c, e
2868 
2869     def as_coeff_Mul(self, rational=False):
2870         """Efficiently extract the coefficient of a product. """
2871         return S.One, self
2872 
2873     def as_coeff_Add(self, rational=False):
2874         """Efficiently extract the coefficient of a summation. """
2875         return S.Zero, self
2876 
2877     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2878             full=False):
2879         """
2880         Compute formal power power series of self.
2881 
2882         See the docstring of the :func:`fps` function in sympy.series.formal for
2883         more information.
2884         """
2885         from sympy.series.formal import fps
2886 
2887         return fps(self, x, x0, dir, hyper, order, rational, full)
2888 
2889     def fourier_series(self, limits=None):
2890         """Compute fourier sine/cosine series of self.
2891 
2892         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2893         for more information.
2894         """
2895         from sympy.series.fourier import fourier_series
2896 
2897         return fourier_series(self, limits)
2898 
2899     ###################################################################################
2900     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2901     ###################################################################################
2902 
2903     def diff(self, *symbols, **assumptions):
2904         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2905         assumptions.setdefault("evaluate", True)
2906         return Derivative(self, *new_symbols, **assumptions)
2907 
2908     ###########################################################################
2909     ###################### EXPRESSION EXPANSION METHODS #######################
2910     ###########################################################################
2911 
2912     # Relevant subclasses should override _eval_expand_hint() methods.  See
2913     # the docstring of expand() for more info.
2914 
2915     def _eval_expand_complex(self, **hints):
2916         real, imag = self.as_real_imag(**hints)
2917         return real + S.ImaginaryUnit*imag
2918 
2919     @staticmethod
2920     def _expand_hint(expr, hint, deep=True, **hints):
2921         """
2922         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2923 
2924         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2925         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2926         ``False`` otherwise.
2927         """
2928         hit = False
2929         # XXX: Hack to support non-Basic args
2930         #              |
2931         #              V
2932         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2933             sargs = []
2934             for arg in expr.args:
2935                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2936                 hit |= arghit
2937                 sargs.append(arg)
2938 
2939             if hit:
2940                 expr = expr.func(*sargs)
2941 
2942         if hasattr(expr, hint):
2943             newexpr = getattr(expr, hint)(**hints)
2944             if newexpr != expr:
2945                 return (newexpr, True)
2946 
2947         return (expr, hit)
2948 
2949     @cacheit
2950     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2951             mul=True, log=True, multinomial=True, basic=True, **hints):
2952         """
2953         Expand an expression using hints.
2954 
2955         See the docstring of the expand() function in sympy.core.function for
2956         more information.
2957 
2958         """
2959         from sympy.simplify.radsimp import fraction
2960 
2961         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
2962            log=log, multinomial=multinomial, basic=basic)
2963 
2964         expr = self
2965         if hints.pop('frac', False):
2966             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
2967                     for a in fraction(self)]
2968             return n/d
2969         elif hints.pop('denom', False):
2970             n, d = fraction(self)
2971             return n/d.expand(deep=deep, modulus=modulus, **hints)
2972         elif hints.pop('numer', False):
2973             n, d = fraction(self)
2974             return n.expand(deep=deep, modulus=modulus, **hints)/d
2975 
2976         # Although the hints are sorted here, an earlier hint may get applied
2977         # at a given node in the expression tree before another because of how
2978         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
2979         # x*z) because while applying log at the top level, log and mul are
2980         # applied at the deeper level in the tree so that when the log at the
2981         # upper level gets applied, the mul has already been applied at the
2982         # lower level.
2983 
2984         # Additionally, because hints are only applied once, the expression
2985         # may not be expanded all the way.   For example, if mul is applied
2986         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
2987         # now, we just use a special case to make multinomial run before mul,
2988         # so that at least polynomials will be expanded all the way.  In the
2989         # future, smarter heuristics should be applied.
2990         # TODO: Smarter heuristics
2991 
2992         def _expand_hint_key(hint):
2993             """Make multinomial come before mul"""
2994             if hint == 'mul':
2995                 return 'mulz'
2996             return hint
2997 
2998         for hint in sorted(hints.keys(), key=_expand_hint_key):
2999             use_hint = hints[hint]
3000             if use_hint:
3001                 hint = '_eval_expand_' + hint
3002                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3003 
3004         while True:
3005             was = expr
3006             if hints.get('multinomial', False):
3007                 expr, _ = Expr._expand_hint(
3008                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3009             if hints.get('mul', False):
3010                 expr, _ = Expr._expand_hint(
3011                     expr, '_eval_expand_mul', deep=deep, **hints)
3012             if hints.get('log', False):
3013                 expr, _ = Expr._expand_hint(
3014                     expr, '_eval_expand_log', deep=deep, **hints)
3015             if expr == was:
3016                 break
3017 
3018         if modulus is not None:
3019             modulus = sympify(modulus)
3020 
3021             if not modulus.is_Integer or modulus <= 0:
3022                 raise ValueError(
3023                     "modulus must be a positive integer, got %s" % modulus)
3024 
3025             terms = []
3026 
3027             for term in Add.make_args(expr):
3028                 coeff, tail = term.as_coeff_Mul(rational=True)
3029 
3030                 coeff %= modulus
3031 
3032                 if coeff:
3033                     terms.append(coeff*tail)
3034 
3035             expr = Add(*terms)
3036 
3037         return expr
3038 
3039     ###########################################################################
3040     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3041     ###########################################################################
3042 
3043     def integrate(self, *args, **kwargs):
3044         """See the integrate function in sympy.integrals"""
3045         from sympy.integrals import integrate
3046         return integrate(self, *args, **kwargs)
3047 
3048     def simplify(self, ratio=1.7, measure=None):
3049         """See the simplify function in sympy.simplify"""
3050         from sympy.simplify import simplify
3051         from sympy.core.function import count_ops
3052         measure = measure or count_ops
3053         return simplify(self, ratio, measure)
3054 
3055     def nsimplify(self, constants=[], tolerance=None, full=False):
3056         """See the nsimplify function in sympy.simplify"""
3057         from sympy.simplify import nsimplify
3058         return nsimplify(self, constants, tolerance, full)
3059 
3060     def separate(self, deep=False, force=False):
3061         """See the separate function in sympy.simplify"""
3062         from sympy.core.function import expand_power_base
3063         return expand_power_base(self, deep=deep, force=force)
3064 
3065     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3066         """See the collect function in sympy.simplify"""
3067         from sympy.simplify import collect
3068         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3069 
3070     def together(self, *args, **kwargs):
3071         """See the together function in sympy.polys"""
3072         from sympy.polys import together
3073         return together(self, *args, **kwargs)
3074 
3075     def apart(self, x=None, **args):
3076         """See the apart function in sympy.polys"""
3077         from sympy.polys import apart
3078         return apart(self, x, **args)
3079 
3080     def ratsimp(self):
3081         """See the ratsimp function in sympy.simplify"""
3082         from sympy.simplify import ratsimp
3083         return ratsimp(self)
3084 
3085     def trigsimp(self, **args):
3086         """See the trigsimp function in sympy.simplify"""
3087         from sympy.simplify import trigsimp
3088         return trigsimp(self, **args)
3089 
3090     def radsimp(self, **kwargs):
3091         """See the radsimp function in sympy.simplify"""
3092         from sympy.simplify import radsimp
3093         return radsimp(self, **kwargs)
3094 
3095     def powsimp(self, *args, **kwargs):
3096         """See the powsimp function in sympy.simplify"""
3097         from sympy.simplify import powsimp
3098         return powsimp(self, *args, **kwargs)
3099 
3100     def combsimp(self):
3101         """See the combsimp function in sympy.simplify"""
3102         from sympy.simplify import combsimp
3103         return combsimp(self)
3104 
3105     def factor(self, *gens, **args):
3106         """See the factor() function in sympy.polys.polytools"""
3107         from sympy.polys import factor
3108         return factor(self, *gens, **args)
3109 
3110     def refine(self, assumption=True):
3111         """See the refine function in sympy.assumptions"""
3112         from sympy.assumptions import refine
3113         return refine(self, assumption)
3114 
3115     def cancel(self, *gens, **args):
3116         """See the cancel function in sympy.polys"""
3117         from sympy.polys import cancel
3118         return cancel(self, *gens, **args)
3119 
3120     def invert(self, g, *gens, **args):
3121         """Return the multiplicative inverse of ``self`` mod ``g``
3122         where ``self`` (and ``g``) may be symbolic expressions).
3123 
3124         See Also
3125         ========
3126         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3127         """
3128         from sympy.polys.polytools import invert
3129         from sympy.core.numbers import mod_inverse
3130         if self.is_number and getattr(g, 'is_number', True):
3131             return mod_inverse(self, g)
3132         return invert(self, g, *gens, **args)
3133 
3134     def round(self, p=0):
3135         """Return x rounded to the given decimal place.
3136 
3137         If a complex number would results, apply round to the real
3138         and imaginary components of the number.
3139 
3140         Examples
3141         ========
3142 
3143         >>> from sympy import pi, E, I, S, Add, Mul, Number
3144         >>> S(10.5).round()
3145         11.
3146         >>> pi.round()
3147         3.
3148         >>> pi.round(2)
3149         3.14
3150         >>> (2*pi + E*I).round()
3151         6. + 3.*I
3152 
3153         The round method has a chopping effect:
3154 
3155         >>> (2*pi + I/10).round()
3156         6.
3157         >>> (pi/10 + 2*I).round()
3158         2.*I
3159         >>> (pi/10 + E*I).round(2)
3160         0.31 + 2.72*I
3161 
3162         Notes
3163         =====
3164 
3165         Do not confuse the Python builtin function, round, with the
3166         SymPy method of the same name. The former always returns a float
3167         (or raises an error if applied to a complex value) while the
3168         latter returns either a Number or a complex number:
3169 
3170         >>> isinstance(round(S(123), -2), Number)
3171         False
3172         >>> isinstance(S(123).round(-2), Number)
3173         True
3174         >>> isinstance((3*I).round(), Mul)
3175         True
3176         >>> isinstance((1 + 3*I).round(), Add)
3177         True
3178 
3179         """
3180         from sympy import Float
3181         x = self
3182         if not x.is_number:
3183             raise TypeError("can't round symbolic expression")
3184         if not x.is_Atom:
3185             xn = x.n(2)
3186             if not pure_complex(xn, or_real=True):
3187                 raise TypeError('Expected a number but got %s:' %
3188                     getattr(getattr(x,'func', x), '__name__', type(x)))
3189         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3190             return x
3191         if not x.is_real:
3192             i, r = x.as_real_imag()
3193             return i.round(p) + S.ImaginaryUnit*r.round(p)
3194         if not x:
3195             return x
3196         p = int(p)
3197 
3198         precs = [f._prec for f in x.atoms(Float)]
3199         dps = prec_to_dps(max(precs)) if precs else None
3200 
3201         mag_first_dig = _mag(x)
3202         allow = digits_needed = mag_first_dig + p
3203         if dps is not None and allow > dps:
3204             allow = dps
3205         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3206         xwas = x
3207         x += 1/(2*mag)  # add the half for rounding
3208         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3209         if i10.is_negative:
3210             x = xwas - 1/(2*mag)  # should have gone the other way
3211             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3212             rv = -(Integer(-i10)//10)
3213         else:
3214             rv = Integer(i10)//10
3215         q = 1
3216         if p > 0:
3217             q = mag
3218         elif p < 0:
3219             rv /= mag
3220         rv = Rational(rv, q)
3221         if rv.is_Integer:
3222             # use str or else it won't be a float
3223             return Float(str(rv), digits_needed)
3224         else:
3225             if not allow and rv > self:
3226                 allow += 1
3227             return Float(rv, allow)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())

</code><intended_behavior>Though not directly implicated by a specific method in the bug report, the way Mul objects are created with evaluate=False and their interaction with methods like extract_multiplicatively suggests that there might be an underlying issue in either how Mul objects represent their arguments or in a helper method that extract_multiplicatively relies on (such as primitive or another method called within extract_multiplicatively). An analysis should be conducted on methods within Mul that are involved in the creation and simplification of these expressions to ensure they correctly handle negative values and expressions in non-evaluated form. This might involve ensuring that the primitive method (when called on results of Mul with evaluate=False) returns a form that is correctly interpreted by extract_multiplicatively, or adjusting how these Mul objects represent their arguments in a way that simplifies correctly when division is attempted.</intended_behavior>]
2025-10-16 01:42:37.455 | INFO     | Search completed. Bug locations: [<file>sympy/core/expr.py</file>
<class>Expr</class>
<method>extract_multiplicatively</method>
<code>
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)

</code><intended_behavior>This method should be able to correctly handle the case when attempting to extract a negative factor from an expression, particularly when that expression is constructed with Mul(..., evaluate=False). It appears that when a negative factor that matches the negative content of an expression is to be extracted, the method fails to return the correct factored expression. The intended behavior would involve checking if the expression can be divided by the given factor c in a way that maintains the integrity and properties of the original expression, even when evaluate=False has led to a non-standard representation of the expression. This can include better handling or normalization of expressions involving negative factors or ensuring that the Mul objects with evaluate=False are correctly interpreted and simplified if possible before attempting to extract multiplicatively.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     @property
33     def _diff_wrt(self):
34         """Is it allowed to take derivative wrt to this instance.
35 
36         This determines if it is allowed to take derivatives wrt this object.
37         Subclasses such as Symbol, Function and Derivative should return True
38         to enable derivatives wrt them. The implementation in Derivative
39         separates the Symbol and non-Symbol _diff_wrt=True variables and
40         temporarily converts the non-Symbol vars in Symbols when performing
41         the differentiation.
42 
43         Note, see the docstring of Derivative for how this should work
44         mathematically. In particular, note that expr.subs(yourclass, Symbol)
45         should be well-defined on a structural level, or this will lead to
46         inconsistent results.
47 
48         Examples
49         ========
50 
51         >>> from sympy import Expr
52         >>> e = Expr()
53         >>> e._diff_wrt
54         False
55         >>> class MyClass(Expr):
56         ...     _diff_wrt = True
57         ...
58         >>> (2*MyClass()).diff(MyClass())
59         2
60         """
61         return False
62 
63     @cacheit
64     def sort_key(self, order=None):
65 
66         coeff, expr = self.as_coeff_Mul()
67 
68         if expr.is_Pow:
69             expr, exp = expr.args
70         else:
71             expr, exp = expr, S.One
72 
73         if expr.is_Dummy:
74             args = (expr.sort_key(),)
75         elif expr.is_Atom:
76             args = (str(expr),)
77         else:
78             if expr.is_Add:
79                 args = expr.as_ordered_terms(order=order)
80             elif expr.is_Mul:
81                 args = expr.as_ordered_factors(order=order)
82             else:
83                 args = expr.args
84 
85             args = tuple(
86                 [ default_sort_key(arg, order=order) for arg in args ])
87 
88         args = (len(args), tuple(args))
89         exp = exp.sort_key(order=order)
90 
91         return expr.class_key(), args, exp, coeff
92 
93     # ***************
94     # * Arithmetics *
95     # ***************
96     # Expr and its sublcasses use _op_priority to determine which object
97     # passed to a binary special method (__mul__, etc.) will handle the
98     # operation. In general, the 'call_highest_priority' decorator will choose
99     # the object with the highest _op_priority to handle the call.
100     # Custom subclasses that want to define their own binary special methods
101     # should set an _op_priority value that is higher than the default.
102     #
103     # **NOTE**:
104     # This is a temporary fix, and will eventually be replaced with
105     # something better and more powerful.  See issue 5510.
106     _op_priority = 10.0
107 
108     def __pos__(self):
109         return self
110 
111     def __neg__(self):
112         return Mul(S.NegativeOne, self)
113 
114     def __abs__(self):
115         from sympy import Abs
116         return Abs(self)
117 
118     @_sympifyit('other', NotImplemented)
119     @call_highest_priority('__radd__')
120     def __add__(self, other):
121         return Add(self, other)
122 
123     @_sympifyit('other', NotImplemented)
124     @call_highest_priority('__add__')
125     def __radd__(self, other):
126         return Add(other, self)
127 
128     @_sympifyit('other', NotImplemented)
129     @call_highest_priority('__rsub__')
130     def __sub__(self, other):
131         return Add(self, -other)
132 
133     @_sympifyit('other', NotImplemented)
134     @call_highest_priority('__sub__')
135     def __rsub__(self, other):
136         return Add(other, -self)
137 
138     @_sympifyit('other', NotImplemented)
139     @call_highest_priority('__rmul__')
140     def __mul__(self, other):
141         return Mul(self, other)
142 
143     @_sympifyit('other', NotImplemented)
144     @call_highest_priority('__mul__')
145     def __rmul__(self, other):
146         return Mul(other, self)
147 
148     @_sympifyit('other', NotImplemented)
149     @call_highest_priority('__rpow__')
150     def __pow__(self, other):
151         return Pow(self, other)
152 
153     @_sympifyit('other', NotImplemented)
154     @call_highest_priority('__pow__')
155     def __rpow__(self, other):
156         return Pow(other, self)
157 
158     @_sympifyit('other', NotImplemented)
159     @call_highest_priority('__rdiv__')
160     def __div__(self, other):
161         return Mul(self, Pow(other, S.NegativeOne))
162 
163     @_sympifyit('other', NotImplemented)
164     @call_highest_priority('__div__')
165     def __rdiv__(self, other):
166         return Mul(other, Pow(self, S.NegativeOne))
167 
168     __truediv__ = __div__
169     __rtruediv__ = __rdiv__
170 
171     @_sympifyit('other', NotImplemented)
172     @call_highest_priority('__rmod__')
173     def __mod__(self, other):
174         return Mod(self, other)
175 
176     @_sympifyit('other', NotImplemented)
177     @call_highest_priority('__mod__')
178     def __rmod__(self, other):
179         return Mod(other, self)
180 
181     @_sympifyit('other', NotImplemented)
182     @call_highest_priority('__rfloordiv__')
183     def __floordiv__(self, other):
184         from sympy.functions.elementary.integers import floor
185         return floor(self / other)
186 
187     @_sympifyit('other', NotImplemented)
188     @call_highest_priority('__floordiv__')
189     def __rfloordiv__(self, other):
190         from sympy.functions.elementary.integers import floor
191         return floor(self / other)
192 
193     def __int__(self):
194         # Although we only need to round to the units position, we'll
195         # get one more digit so the extra testing below can be avoided
196         # unless the rounded value rounded to an integer, e.g. if an
197         # expression were equal to 1.9 and we rounded to the unit position
198         # we would get a 2 and would not know if this rounded up or not
199         # without doing a test (as done below). But if we keep an extra
200         # digit we know that 1.9 is not the same as 1 and there is no
201         # need for further testing: our int value is correct. If the value
202         # were 1.99, however, this would round to 2.0 and our int value is
203         # off by one. So...if our round value is the same as the int value
204         # (regardless of how much extra work we do to calculate extra decimal
205         # places) we need to test whether we are off by one.
206         from sympy import Dummy
207         if not self.is_number:
208             raise TypeError("can't convert symbols to int")
209         r = self.round(2)
210         if not r.is_Number:
211             raise TypeError("can't convert complex to int")
212         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
213             raise TypeError("can't convert %s to int" % r)
214         i = int(r)
215         if not i:
216             return 0
217         # off-by-one check
218         if i == r and not (self - i).equals(0):
219             isign = 1 if i > 0 else -1
220             x = Dummy()
221             # in the following (self - i).evalf(2) will not always work while
222             # (self - r).evalf(2) and the use of subs does; if the test that
223             # was added when this comment was added passes, it might be safe
224             # to simply use sign to compute this rather than doing this by hand:
225             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
226             if diff_sign != isign:
227                 i -= isign
228         return i
229     __long__ = __int__
230 
231     def __float__(self):
232         # Don't bother testing if it's a number; if it's not this is going
233         # to fail, and if it is we still need to check that it evalf'ed to
234         # a number.
235         result = self.evalf()
236         if result.is_Number:
237             return float(result)
238         if result.is_number and result.as_real_imag()[1]:
239             raise TypeError("can't convert complex to float")
240         raise TypeError("can't convert expression to float")
241 
242     def __complex__(self):
243         result = self.evalf()
244         re, im = result.as_real_imag()
245         return complex(float(re), float(im))
246 
247     def __ge__(self, other):
248         from sympy import GreaterThan
249         try:
250             other = _sympify(other)
251         except SympifyError:
252             raise TypeError("Invalid comparison %s >= %s" % (self, other))
253         for me in (self, other):
254             if (me.is_complex and me.is_real is False) or \
255                     me.has(S.ComplexInfinity):
256                 raise TypeError("Invalid comparison of complex %s" % me)
257             if me is S.NaN:
258                 raise TypeError("Invalid NaN comparison")
259         if self.is_real or other.is_real:
260             dif = self - other
261             if dif.is_nonnegative is not None and \
262                     dif.is_nonnegative is not dif.is_negative:
263                 return sympify(dif.is_nonnegative)
264         return GreaterThan(self, other, evaluate=False)
265 
266     def __le__(self, other):
267         from sympy import LessThan
268         try:
269             other = _sympify(other)
270         except SympifyError:
271             raise TypeError("Invalid comparison %s <= %s" % (self, other))
272         for me in (self, other):
273             if (me.is_complex and me.is_real is False) or \
274                     me.has(S.ComplexInfinity):
275                 raise TypeError("Invalid comparison of complex %s" % me)
276             if me is S.NaN:
277                 raise TypeError("Invalid NaN comparison")
278         if self.is_real or other.is_real:
279             dif = self - other
280             if dif.is_nonpositive is not None and \
281                     dif.is_nonpositive is not dif.is_positive:
282                 return sympify(dif.is_nonpositive)
283         return LessThan(self, other, evaluate=False)
284 
285     def __gt__(self, other):
286         from sympy import StrictGreaterThan
287         try:
288             other = _sympify(other)
289         except SympifyError:
290             raise TypeError("Invalid comparison %s > %s" % (self, other))
291         for me in (self, other):
292             if (me.is_complex and me.is_real is False) or \
293                     me.has(S.ComplexInfinity):
294                 raise TypeError("Invalid comparison of complex %s" % me)
295             if me is S.NaN:
296                 raise TypeError("Invalid NaN comparison")
297         if self.is_real or other.is_real:
298             dif = self - other
299             if dif.is_positive is not None and \
300                     dif.is_positive is not dif.is_nonpositive:
301                 return sympify(dif.is_positive)
302         return StrictGreaterThan(self, other, evaluate=False)
303 
304     def __lt__(self, other):
305         from sympy import StrictLessThan
306         try:
307             other = _sympify(other)
308         except SympifyError:
309             raise TypeError("Invalid comparison %s < %s" % (self, other))
310         for me in (self, other):
311             if (me.is_complex and me.is_real is False) or \
312                     me.has(S.ComplexInfinity):
313                 raise TypeError("Invalid comparison of complex %s" % me)
314             if me is S.NaN:
315                 raise TypeError("Invalid NaN comparison")
316         if self.is_real or other.is_real:
317             dif = self - other
318             if dif.is_negative is not None and \
319                     dif.is_negative is not dif.is_nonnegative:
320                 return sympify(dif.is_negative)
321         return StrictLessThan(self, other, evaluate=False)
322 
323     @staticmethod
324     def _from_mpmath(x, prec):
325         from sympy import Float
326         if hasattr(x, "_mpf_"):
327             return Float._new(x._mpf_, prec)
328         elif hasattr(x, "_mpc_"):
329             re, im = x._mpc_
330             re = Float._new(re, prec)
331             im = Float._new(im, prec)*S.ImaginaryUnit
332             return re + im
333         else:
334             raise TypeError("expected mpmath number (mpf or mpc)")
335 
336     @property
337     def is_number(self):
338         """Returns True if 'self' has no free symbols.
339         It will be faster than `if not self.free_symbols`, however, since
340         `is_number` will fail as soon as it hits a free symbol.
341 
342         Examples
343         ========
344 
345         >>> from sympy import log, Integral
346         >>> from sympy.abc import x
347 
348         >>> x.is_number
349         False
350         >>> (2*x).is_number
351         False
352         >>> (2 + log(2)).is_number
353         True
354         >>> (2 + Integral(2, x)).is_number
355         False
356         >>> (2 + Integral(2, (x, 1, 2))).is_number
357         True
358 
359         """
360         return all(obj.is_number for obj in self.args)
361 
362     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
363         """Return self evaluated, if possible, replacing free symbols with
364         random complex values, if necessary.
365 
366         The random complex value for each free symbol is generated
367         by the random_complex_number routine giving real and imaginary
368         parts in the range given by the re_min, re_max, im_min, and im_max
369         values. The returned value is evaluated to a precision of n
370         (if given) else the maximum of 15 and the precision needed
371         to get more than 1 digit of precision. If the expression
372         could not be evaluated to a number, or could not be evaluated
373         to more than 1 digit of precision, then None is returned.
374 
375         Examples
376         ========
377 
378         >>> from sympy import sqrt
379         >>> from sympy.abc import x, y
380         >>> x._random()                         # doctest: +SKIP
381         0.0392918155679172 + 0.916050214307199*I
382         >>> x._random(2)                        # doctest: +SKIP
383         -0.77 - 0.87*I
384         >>> (x + y/2)._random(2)                # doctest: +SKIP
385         -0.57 + 0.16*I
386         >>> sqrt(2)._random(2)
387         1.4
388 
389         See Also
390         ========
391 
392         sympy.utilities.randtest.random_complex_number
393         """
394 
395         free = self.free_symbols
396         prec = 1
397         if free:
398             from sympy.utilities.randtest import random_complex_number
399             a, c, b, d = re_min, re_max, im_min, im_max
400             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
401                            for zi in free])))
402             try:
403                 nmag = abs(self.evalf(2, subs=reps))
404             except (ValueError, TypeError):
405                 # if an out of range value resulted in evalf problems
406                 # then return None -- XXX is there a way to know how to
407                 # select a good random number for a given expression?
408                 # e.g. when calculating n! negative values for n should not
409                 # be used
410                 return None
411         else:
412             reps = {}
413             nmag = abs(self.evalf(2))
414 
415         if not hasattr(nmag, '_prec'):
416             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
417             return None
418 
419         if nmag._prec == 1:
420             # increase the precision up to the default maximum
421             # precision to see if we can get any significance
422 
423             from mpmath.libmp.libintmath import giant_steps
424             from sympy.core.evalf import DEFAULT_MAXPREC as target
425 
426             # evaluate
427             for prec in giant_steps(2, target):
428                 nmag = abs(self.evalf(prec, subs=reps))
429                 if nmag._prec != 1:
430                     break
431 
432         if nmag._prec != 1:
433             if n is None:
434                 n = max(prec, 15)
435             return self.evalf(n, subs=reps)
436 
437         # never got any significance
438         return None
439 
440     def is_constant(self, *wrt, **flags):
441         """Return True if self is constant, False if not, or None if
442         the constancy could not be determined conclusively.
443 
444         If an expression has no free symbols then it is a constant. If
445         there are free symbols it is possible that the expression is a
446         constant, perhaps (but not necessarily) zero. To test such
447         expressions, two strategies are tried:
448 
449         1) numerical evaluation at two random points. If two such evaluations
450         give two different values and the values have a precision greater than
451         1 then self is not constant. If the evaluations agree or could not be
452         obtained with any precision, no decision is made. The numerical testing
453         is done only if ``wrt`` is different than the free symbols.
454 
455         2) differentiation with respect to variables in 'wrt' (or all free
456         symbols if omitted) to see if the expression is constant or not. This
457         will not always lead to an expression that is zero even though an
458         expression is constant (see added test in test_expr.py). If
459         all derivatives are zero then self is constant with respect to the
460         given symbols.
461 
462         If neither evaluation nor differentiation can prove the expression is
463         constant, None is returned unless two numerical values happened to be
464         the same and the flag ``failing_number`` is True -- in that case the
465         numerical value will be returned.
466 
467         If flag simplify=False is passed, self will not be simplified;
468         the default is True since self should be simplified before testing.
469 
470         Examples
471         ========
472 
473         >>> from sympy import cos, sin, Sum, S, pi
474         >>> from sympy.abc import a, n, x, y
475         >>> x.is_constant()
476         False
477         >>> S(2).is_constant()
478         True
479         >>> Sum(x, (x, 1, 10)).is_constant()
480         True
481         >>> Sum(x, (x, 1, n)).is_constant()
482         False
483         >>> Sum(x, (x, 1, n)).is_constant(y)
484         True
485         >>> Sum(x, (x, 1, n)).is_constant(n)
486         False
487         >>> Sum(x, (x, 1, n)).is_constant(x)
488         True
489         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
490         >>> eq.is_constant()
491         True
492         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
493         True
494 
495         >>> (0**x).is_constant()
496         False
497         >>> x.is_constant()
498         False
499         >>> (x**x).is_constant()
500         False
501         >>> one = cos(x)**2 + sin(x)**2
502         >>> one.is_constant()
503         True
504         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
505         True
506         """
507 
508         simplify = flags.get('simplify', True)
509 
510         # Except for expressions that contain units, only one of these should
511         # be necessary since if something is
512         # known to be a number it should also know that there are no
513         # free symbols. But is_number quits as soon as it hits a non-number
514         # whereas free_symbols goes until all free symbols have been collected,
515         # thus is_number should be faster. But a double check on free symbols
516         # is made just in case there is a discrepancy between the two.
517         free = self.free_symbols
518         if self.is_number or not free:
519             # if the following assertion fails then that object's free_symbols
520             # method needs attention: if an expression is a number it cannot
521             # have free symbols
522             assert not free
523             return True
524 
525         # if we are only interested in some symbols and they are not in the
526         # free symbols then this expression is constant wrt those symbols
527         wrt = set(wrt)
528         if wrt and not wrt & free:
529             return True
530         wrt = wrt or free
531 
532         # simplify unless this has already been done
533         expr = self
534         if simplify:
535             expr = expr.simplify()
536 
537         # is_zero should be a quick assumptions check; it can be wrong for
538         # numbers (see test_is_not_constant test), giving False when it
539         # shouldn't, but hopefully it will never give True unless it is sure.
540         if expr.is_zero:
541             return True
542 
543         # try numerical evaluation to see if we get two different values
544         failing_number = None
545         if wrt == free:
546             # try 0 (for a) and 1 (for b)
547             try:
548                 a = expr.subs(list(zip(free, [0]*len(free))),
549                     simultaneous=True)
550                 if a is S.NaN:
551                     # evaluation may succeed when substitution fails
552                     a = expr._random(None, 0, 0, 0, 0)
553             except ZeroDivisionError:
554                 a = None
555             if a is not None and a is not S.NaN:
556                 try:
557                     b = expr.subs(list(zip(free, [1]*len(free))),
558                         simultaneous=True)
559                     if b is S.NaN:
560                         # evaluation may succeed when substitution fails
561                         b = expr._random(None, 1, 0, 1, 0)
562                 except ZeroDivisionError:
563                     b = None
564                 if b is not None and b is not S.NaN and b.equals(a) is False:
565                     return False
566                 # try random real
567                 b = expr._random(None, -1, 0, 1, 0)
568                 if b is not None and b is not S.NaN and b.equals(a) is False:
569                     return False
570                 # try random complex
571                 b = expr._random()
572                 if b is not None and b is not S.NaN:
573                     if b.equals(a) is False:
574                         return False
575                     failing_number = a if a.is_number else b
576 
577         # now we will test each wrt symbol (or all free symbols) to see if the
578         # expression depends on them or not using differentiation. This is
579         # not sufficient for all expressions, however, so we don't return
580         # False if we get a derivative other than 0 with free symbols.
581         for w in wrt:
582             deriv = expr.diff(w)
583             if simplify:
584                 deriv = deriv.simplify()
585             if deriv != 0:
586                 if not (pure_complex(deriv, or_real=True)):
587                     if flags.get('failing_number', False):
588                         return failing_number
589                     elif deriv.free_symbols:
590                         # dead line provided _random returns None in such cases
591                         return None
592                 return False
593         return True
594 
595     def equals(self, other, failing_expression=False):
596         """Return True if self == other, False if it doesn't, or None. If
597         failing_expression is True then the expression which did not simplify
598         to a 0 will be returned instead of None.
599 
600         If ``self`` is a Number (or complex number) that is not zero, then
601         the result is False.
602 
603         If ``self`` is a number and has not evaluated to zero, evalf will be
604         used to test whether the expression evaluates to zero. If it does so
605         and the result has significance (i.e. the precision is either -1, for
606         a Rational result, or is greater than 1) then the evalf value will be
607         used to return True or False.
608 
609         """
610         from sympy.simplify.simplify import nsimplify, simplify
611         from sympy.solvers.solveset import solveset
612         from sympy.polys.polyerrors import NotAlgebraic
613         from sympy.polys.numberfields import minimal_polynomial
614 
615         other = sympify(other)
616         if self == other:
617             return True
618 
619         # they aren't the same so see if we can make the difference 0;
620         # don't worry about doing simplification steps one at a time
621         # because if the expression ever goes to 0 then the subsequent
622         # simplification steps that are done will be very fast.
623         diff = factor_terms(simplify(self - other), radical=True)
624 
625         if not diff:
626             return True
627 
628         if not diff.has(Add, Mod):
629             # if there is no expanding to be done after simplifying
630             # then this can't be a zero
631             return False
632 
633         constant = diff.is_constant(simplify=False, failing_number=True)
634 
635         if constant is False:
636             return False
637 
638         if constant is None and (diff.free_symbols or not diff.is_number):
639             # e.g. unless the right simplification is done, a symbolic
640             # zero is possible (see expression of issue 6829: without
641             # simplification constant will be None).
642             return
643 
644         if constant is True:
645             ndiff = diff._random()
646             if ndiff:
647                 return False
648 
649         # sometimes we can use a simplified result to give a clue as to
650         # what the expression should be; if the expression is *not* zero
651         # then we should have been able to compute that and so now
652         # we can just consider the cases where the approximation appears
653         # to be zero -- we try to prove it via minimal_polynomial.
654         if diff.is_number:
655             approx = diff.nsimplify()
656             if not approx:
657                 # try to prove via self-consistency
658                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
659                 # it seems to work better to try big ones first
660                 surds.sort(key=lambda x: -x.args[0])
661                 for s in surds:
662                     try:
663                         # simplify is False here -- this expression has already
664                         # been identified as being hard to identify as zero;
665                         # we will handle the checking ourselves using nsimplify
666                         # to see if we are in the right ballpark or not and if so
667                         # *then* the simplification will be attempted.
668                         if s.is_Symbol:
669                             sol = list(solveset(diff, s))
670                         else:
671                             sol = [s]
672                         if sol:
673                             if s in sol:
674                                 return True
675                             if s.is_real:
676                                 if any(nsimplify(si, [s]) == s and simplify(si) == s
677                                         for si in sol):
678                                     return True
679                     except NotImplementedError:
680                         pass
681 
682                 # try to prove with minimal_polynomial but know when
683                 # *not* to use this or else it can take a long time. e.g. issue 8354
684                 if True:  # change True to condition that assures non-hang
685                     try:
686                         mp = minimal_polynomial(diff)
687                         if mp.is_Symbol:
688                             return True
689                         return False
690                     except (NotAlgebraic, NotImplementedError):
691                         pass
692 
693         # diff has not simplified to zero; constant is either None, True
694         # or the number with significance (prec != 1) that was randomly
695         # calculated twice as the same value.
696         if constant not in (True, None) and constant != 0:
697             return False
698 
699         if failing_expression:
700             return diff
701         return None
702 
703     def _eval_is_positive(self):
704         from sympy.polys.numberfields import minimal_polynomial
705         from sympy.polys.polyerrors import NotAlgebraic
706         if self.is_number:
707             if self.is_real is False:
708                 return False
709             try:
710                 # check to see that we can get a value
711                 n2 = self._eval_evalf(2)
712                 if n2 is None:
713                     raise AttributeError
714                 if n2._prec == 1:  # no significance
715                     raise AttributeError
716                 if n2 == S.NaN:
717                     raise AttributeError
718             except (AttributeError, ValueError):
719                 return None
720             n, i = self.evalf(2).as_real_imag()
721             if not i.is_Number or not n.is_Number:
722                 return False
723             if n._prec != 1 and i._prec != 1:
724                 return bool(not i and n > 0)
725             elif n._prec == 1 and (not i or i._prec == 1) and \
726                     self.is_algebraic and not self.has(Function):
727                 try:
728                     if minimal_polynomial(self).is_Symbol:
729                         return False
730                 except (NotAlgebraic, NotImplementedError):
731                     pass
732 
733     def _eval_is_negative(self):
734         from sympy.polys.numberfields import minimal_polynomial
735         from sympy.polys.polyerrors import NotAlgebraic
736         if self.is_number:
737             if self.is_real is False:
738                 return False
739             try:
740                 # check to see that we can get a value
741                 n2 = self._eval_evalf(2)
742                 if n2 is None:
743                     raise AttributeError
744                 if n2._prec == 1:  # no significance
745                     raise AttributeError
746                 if n2 == S.NaN:
747                     raise AttributeError
748             except (AttributeError, ValueError):
749                 return None
750             n, i = self.evalf(2).as_real_imag()
751             if not i.is_Number or not n.is_Number:
752                 return False
753             if n._prec != 1 and i._prec != 1:
754                 return bool(not i and n < 0)
755             elif n._prec == 1 and (not i or i._prec == 1) and \
756                     self.is_algebraic and not self.has(Function):
757                 try:
758                     if minimal_polynomial(self).is_Symbol:
759                         return False
760                 except (NotAlgebraic, NotImplementedError):
761                     pass
762 
763     def _eval_interval(self, x, a, b):
764         """
765         Returns evaluation over an interval.  For most functions this is:
766 
767         self.subs(x, b) - self.subs(x, a),
768 
769         possibly using limit() if NaN is returned from subs.
770 
771         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
772         respectively.
773 
774         """
775         from sympy.series import limit, Limit
776         from sympy.solvers.solveset import solveset
777 
778         if (a is None and b is None):
779             raise ValueError('Both interval ends cannot be None.')
780 
781         if a == b:
782             return 0;
783 
784         if a is None:
785             A = 0
786         else:
787             A = self.subs(x, a)
788             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
789                 if (a < b) != False:
790                     A = limit(self, x, a,"+")
791                 else:
792                     A = limit(self, x, a,"-")
793 
794                 if A is S.NaN:
795                     return A
796                 if isinstance(A, Limit):
797                     raise NotImplementedError("Could not compute limit")
798 
799         if b is None:
800             B = 0
801         else:
802             B = self.subs(x, b)
803             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
804                 if (a < b) != False:
805                     B = limit(self, x, b,"-")
806                 else:
807                     B = limit(self, x, b,"+")
808 
809                 if isinstance(B, Limit):
810                     raise NotImplementedError("Could not compute limit")
811 
812         if (a and b) is None:
813             return B - A
814 
815         value = B - A
816 
817         if a.is_comparable and b.is_comparable:
818             singularities = list(solveset(self.cancel().as_numer_denom()[1], x))
819             for s in singularities:
820                 if a < s < b:
821                     value += -limit(self, x, s, "+") + limit(self, x, s, "-")
822                 elif b < s < a:
823                     value += limit(self, x, s, "+") - limit(self, x, s, "-")
824 
825         return value
826 
827     def _eval_power(self, other):
828         # subclass to compute self**other for cases when
829         # other is not NaN, 0, or 1
830         return None
831 
832     def _eval_conjugate(self):
833         if self.is_real:
834             return self
835         elif self.is_imaginary:
836             return -self
837 
838     def conjugate(self):
839         from sympy.functions.elementary.complexes import conjugate as c
840         return c(self)
841 
842     def _eval_transpose(self):
843         from sympy.functions.elementary.complexes import conjugate
844         if self.is_complex:
845             return self
846         elif self.is_hermitian:
847             return conjugate(self)
848         elif self.is_antihermitian:
849             return -conjugate(self)
850 
851     def transpose(self):
852         from sympy.functions.elementary.complexes import transpose
853         return transpose(self)
854 
855     def _eval_adjoint(self):
856         from sympy.functions.elementary.complexes import conjugate, transpose
857         if self.is_hermitian:
858             return self
859         elif self.is_antihermitian:
860             return -self
861         obj = self._eval_conjugate()
862         if obj is not None:
863             return transpose(obj)
864         obj = self._eval_transpose()
865         if obj is not None:
866             return conjugate(obj)
867 
868     def adjoint(self):
869         from sympy.functions.elementary.complexes import adjoint
870         return adjoint(self)
871 
872     @classmethod
873     def _parse_order(cls, order):
874         """Parse and configure the ordering of terms. """
875         from sympy.polys.orderings import monomial_key
876 
877         try:
878             reverse = order.startswith('rev-')
879         except AttributeError:
880             reverse = False
881         else:
882             if reverse:
883                 order = order[4:]
884 
885         monom_key = monomial_key(order)
886 
887         def neg(monom):
888             result = []
889 
890             for m in monom:
891                 if isinstance(m, tuple):
892                     result.append(neg(m))
893                 else:
894                     result.append(-m)
895 
896             return tuple(result)
897 
898         def key(term):
899             _, ((re, im), monom, ncpart) = term
900 
901             monom = neg(monom_key(monom))
902             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
903             coeff = ((bool(im), im), (re, im))
904 
905             return monom, ncpart, coeff
906 
907         return key, reverse
908 
909     def as_ordered_factors(self, order=None):
910         """Return list of ordered factors (if Mul) else [self]."""
911         return [self]
912 
913     def as_ordered_terms(self, order=None, data=False):
914         """
915         Transform an expression to an ordered list of terms.
916 
917         Examples
918         ========
919 
920         >>> from sympy import sin, cos
921         >>> from sympy.abc import x
922 
923         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
924         [sin(x)**2*cos(x), sin(x)**2, 1]
925 
926         """
927         key, reverse = self._parse_order(order)
928         terms, gens = self.as_terms()
929 
930         if not any(term.is_Order for term, _ in terms):
931             ordered = sorted(terms, key=key, reverse=reverse)
932         else:
933             _terms, _order = [], []
934 
935             for term, repr in terms:
936                 if not term.is_Order:
937                     _terms.append((term, repr))
938                 else:
939                     _order.append((term, repr))
940 
941             ordered = sorted(_terms, key=key, reverse=True) \
942                 + sorted(_order, key=key, reverse=True)
943 
944         if data:
945             return ordered, gens
946         else:
947             return [term for term, _ in ordered]
948 
949     def as_terms(self):
950         """Transform an expression to a list of terms. """
951         from .add import Add
952         from .mul import Mul
953         from .exprtools import decompose_power
954 
955         gens, terms = set([]), []
956 
957         for term in Add.make_args(self):
958             coeff, _term = term.as_coeff_Mul()
959 
960             coeff = complex(coeff)
961             cpart, ncpart = {}, []
962 
963             if _term is not S.One:
964                 for factor in Mul.make_args(_term):
965                     if factor.is_number:
966                         try:
967                             coeff *= complex(factor)
968                         except TypeError:
969                             pass
970                         else:
971                             continue
972 
973                     if factor.is_commutative:
974                         base, exp = decompose_power(factor)
975 
976                         cpart[base] = exp
977                         gens.add(base)
978                     else:
979                         ncpart.append(factor)
980 
981             coeff = coeff.real, coeff.imag
982             ncpart = tuple(ncpart)
983 
984             terms.append((term, (coeff, cpart, ncpart)))
985 
986         gens = sorted(gens, key=default_sort_key)
987 
988         k, indices = len(gens), {}
989 
990         for i, g in enumerate(gens):
991             indices[g] = i
992 
993         result = []
994 
995         for term, (coeff, cpart, ncpart) in terms:
996             monom = [0]*k
997 
998             for base, exp in cpart.items():
999                 monom[indices[base]] = exp
1000 
1001             result.append((term, (coeff, tuple(monom), ncpart)))
1002 
1003         return result, gens
1004 
1005     def removeO(self):
1006         """Removes the additive O(..) symbol if there is one"""
1007         return self
1008 
1009     def getO(self):
1010         """Returns the additive O(..) symbol if there is one, else None."""
1011         return None
1012 
1013     def getn(self):
1014         """
1015         Returns the order of the expression.
1016 
1017         The order is determined either from the O(...) term. If there
1018         is no O(...) term, it returns None.
1019 
1020         Examples
1021         ========
1022 
1023         >>> from sympy import O
1024         >>> from sympy.abc import x
1025         >>> (1 + x + O(x**2)).getn()
1026         2
1027         >>> (1 + x).getn()
1028 
1029         """
1030         from sympy import Dummy, Symbol
1031         o = self.getO()
1032         if o is None:
1033             return None
1034         elif o.is_Order:
1035             o = o.expr
1036             if o is S.One:
1037                 return S.Zero
1038             if o.is_Symbol:
1039                 return S.One
1040             if o.is_Pow:
1041                 return o.args[1]
1042             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1043                 for oi in o.args:
1044                     if oi.is_Symbol:
1045                         return S.One
1046                     if oi.is_Pow:
1047                         syms = oi.atoms(Symbol)
1048                         if len(syms) == 1:
1049                             x = syms.pop()
1050                             oi = oi.subs(x, Dummy('x', positive=True))
1051                             if oi.base.is_Symbol and oi.exp.is_Rational:
1052                                 return abs(oi.exp)
1053 
1054         raise NotImplementedError('not sure of order of %s' % o)
1055 
1056     def count_ops(self, visual=None):
1057         """wrapper for count_ops that returns the operation count."""
1058         from .function import count_ops
1059         return count_ops(self, visual)
1060 
1061     def args_cnc(self, cset=False, warn=True, split_1=True):
1062         """Return [commutative factors, non-commutative factors] of self.
1063 
1064         self is treated as a Mul and the ordering of the factors is maintained.
1065         If ``cset`` is True the commutative factors will be returned in a set.
1066         If there were repeated factors (as may happen with an unevaluated Mul)
1067         then an error will be raised unless it is explicitly supressed by
1068         setting ``warn`` to False.
1069 
1070         Note: -1 is always separated from a Number unless split_1 is False.
1071 
1072         >>> from sympy import symbols, oo
1073         >>> A, B = symbols('A B', commutative=False)
1074         >>> x, y = symbols('x y')
1075         >>> (-2*x*y).args_cnc()
1076         [[-1, 2, x, y], []]
1077         >>> (-2.5*x).args_cnc()
1078         [[-1, 2.5, x], []]
1079         >>> (-2*x*A*B*y).args_cnc()
1080         [[-1, 2, x, y], [A, B]]
1081         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1082         [[-2, x, y], [A, B]]
1083         >>> (-2*x*y).args_cnc(cset=True)
1084         [{-1, 2, x, y}, []]
1085 
1086         The arg is always treated as a Mul:
1087 
1088         >>> (-2 + x + A).args_cnc()
1089         [[], [x - 2 + A]]
1090         >>> (-oo).args_cnc() # -oo is a singleton
1091         [[-1, oo], []]
1092         """
1093 
1094         if self.is_Mul:
1095             args = list(self.args)
1096         else:
1097             args = [self]
1098         for i, mi in enumerate(args):
1099             if not mi.is_commutative:
1100                 c = args[:i]
1101                 nc = args[i:]
1102                 break
1103         else:
1104             c = args
1105             nc = []
1106 
1107         if c and split_1 and (
1108             c[0].is_Number and
1109             c[0].is_negative and
1110                 c[0] is not S.NegativeOne):
1111             c[:1] = [S.NegativeOne, -c[0]]
1112 
1113         if cset:
1114             clen = len(c)
1115             c = set(c)
1116             if clen and warn and len(c) != clen:
1117                 raise ValueError('repeated commutative arguments: %s' %
1118                                  [ci for ci in c if list(self.args).count(ci) > 1])
1119         return [c, nc]
1120 
1121     def coeff(self, x, n=1, right=False):
1122         """
1123         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1124         is zero then all terms independent of ``x`` will be returned.
1125 
1126         When ``x`` is noncommutative, the coefficient to the left (default) or
1127         right of ``x`` can be returned. The keyword 'right' is ignored when
1128         ``x`` is commutative.
1129 
1130         See Also
1131         ========
1132 
1133         as_coefficient: separate the expression into a coefficient and factor
1134         as_coeff_Add: separate the additive constant from an expression
1135         as_coeff_Mul: separate the multiplicative constant from an expression
1136         as_independent: separate x-dependent terms/factors from others
1137         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1138         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1139 
1140         Examples
1141         ========
1142 
1143         >>> from sympy import symbols
1144         >>> from sympy.abc import x, y, z
1145 
1146         You can select terms that have an explicit negative in front of them:
1147 
1148         >>> (-x + 2*y).coeff(-1)
1149         x
1150         >>> (x - 2*y).coeff(-1)
1151         2*y
1152 
1153         You can select terms with no Rational coefficient:
1154 
1155         >>> (x + 2*y).coeff(1)
1156         x
1157         >>> (3 + 2*x + 4*x**2).coeff(1)
1158         0
1159 
1160         You can select terms independent of x by making n=0; in this case
1161         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1162         of None):
1163 
1164         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1165         3
1166         >>> eq = ((x + 1)**3).expand() + 1
1167         >>> eq
1168         x**3 + 3*x**2 + 3*x + 2
1169         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1170         [1, 3, 3, 2]
1171         >>> eq -= 2
1172         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1173         [1, 3, 3, 0]
1174 
1175         You can select terms that have a numerical term in front of them:
1176 
1177         >>> (-x - 2*y).coeff(2)
1178         -y
1179         >>> from sympy import sqrt
1180         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1181         x
1182 
1183         The matching is exact:
1184 
1185         >>> (3 + 2*x + 4*x**2).coeff(x)
1186         2
1187         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1188         4
1189         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1190         0
1191         >>> (z*(x + y)**2).coeff((x + y)**2)
1192         z
1193         >>> (z*(x + y)**2).coeff(x + y)
1194         0
1195 
1196         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1197         from the following:
1198 
1199         >>> (x + z*(x + x*y)).coeff(x)
1200         1
1201 
1202         If such factoring is desired, factor_terms can be used first:
1203 
1204         >>> from sympy import factor_terms
1205         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1206         z*(y + 1) + 1
1207 
1208         >>> n, m, o = symbols('n m o', commutative=False)
1209         >>> n.coeff(n)
1210         1
1211         >>> (3*n).coeff(n)
1212         3
1213         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1214         1 + m
1215         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1216         m
1217 
1218         If there is more than one possible coefficient 0 is returned:
1219 
1220         >>> (n*m + m*n).coeff(n)
1221         0
1222 
1223         If there is only one possible coefficient, it is returned:
1224 
1225         >>> (n*m + x*m*n).coeff(m*n)
1226         x
1227         >>> (n*m + x*m*n).coeff(m*n, right=1)
1228         1
1229 
1230         """
1231         x = sympify(x)
1232         if not isinstance(x, Basic):
1233             return S.Zero
1234 
1235         n = as_int(n)
1236 
1237         if not x:
1238             return S.Zero
1239 
1240         if x == self:
1241             if n == 1:
1242                 return S.One
1243             return S.Zero
1244 
1245         if x is S.One:
1246             co = [a for a in Add.make_args(self)
1247                   if a.as_coeff_Mul()[0] is S.One]
1248             if not co:
1249                 return S.Zero
1250             return Add(*co)
1251 
1252         if n == 0:
1253             if x.is_Add and self.is_Add:
1254                 c = self.coeff(x, right=right)
1255                 if not c:
1256                     return S.Zero
1257                 if not right:
1258                     return self - Add(*[a*x for a in Add.make_args(c)])
1259                 return self - Add(*[x*a for a in Add.make_args(c)])
1260             return self.as_independent(x, as_Add=True)[0]
1261 
1262         # continue with the full method, looking for this power of x:
1263         x = x**n
1264 
1265         def incommon(l1, l2):
1266             if not l1 or not l2:
1267                 return []
1268             n = min(len(l1), len(l2))
1269             for i in range(n):
1270                 if l1[i] != l2[i]:
1271                     return l1[:i]
1272             return l1[:]
1273 
1274         def find(l, sub, first=True):
1275             """ Find where list sub appears in list l. When ``first`` is True
1276             the first occurance from the left is returned, else the last
1277             occurance is returned. Return None if sub is not in l.
1278 
1279             >> l = range(5)*2
1280             >> find(l, [2, 3])
1281             2
1282             >> find(l, [2, 3], first=0)
1283             7
1284             >> find(l, [2, 4])
1285             None
1286 
1287             """
1288             if not sub or not l or len(sub) > len(l):
1289                 return None
1290             n = len(sub)
1291             if not first:
1292                 l.reverse()
1293                 sub.reverse()
1294             for i in range(0, len(l) - n + 1):
1295                 if all(l[i + j] == sub[j] for j in range(n)):
1296                     break
1297             else:
1298                 i = None
1299             if not first:
1300                 l.reverse()
1301                 sub.reverse()
1302             if i is not None and not first:
1303                 i = len(l) - (i + n)
1304             return i
1305 
1306         co = []
1307         args = Add.make_args(self)
1308         self_c = self.is_commutative
1309         x_c = x.is_commutative
1310         if self_c and not x_c:
1311             return S.Zero
1312 
1313         if self_c:
1314             xargs = x.args_cnc(cset=True, warn=False)[0]
1315             for a in args:
1316                 margs = a.args_cnc(cset=True, warn=False)[0]
1317                 if len(xargs) > len(margs):
1318                     continue
1319                 resid = margs.difference(xargs)
1320                 if len(resid) + len(xargs) == len(margs):
1321                     co.append(Mul(*resid))
1322             if co == []:
1323                 return S.Zero
1324             elif co:
1325                 return Add(*co)
1326         elif x_c:
1327             xargs = x.args_cnc(cset=True, warn=False)[0]
1328             for a in args:
1329                 margs, nc = a.args_cnc(cset=True)
1330                 if len(xargs) > len(margs):
1331                     continue
1332                 resid = margs.difference(xargs)
1333                 if len(resid) + len(xargs) == len(margs):
1334                     co.append(Mul(*(list(resid) + nc)))
1335             if co == []:
1336                 return S.Zero
1337             elif co:
1338                 return Add(*co)
1339         else:  # both nc
1340             xargs, nx = x.args_cnc(cset=True)
1341             # find the parts that pass the commutative terms
1342             for a in args:
1343                 margs, nc = a.args_cnc(cset=True)
1344                 if len(xargs) > len(margs):
1345                     continue
1346                 resid = margs.difference(xargs)
1347                 if len(resid) + len(xargs) == len(margs):
1348                     co.append((resid, nc))
1349             # now check the non-comm parts
1350             if not co:
1351                 return S.Zero
1352             if all(n == co[0][1] for r, n in co):
1353                 ii = find(co[0][1], nx, right)
1354                 if ii is not None:
1355                     if not right:
1356                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1357                     else:
1358                         return Mul(*co[0][1][ii + len(nx):])
1359             beg = reduce(incommon, (n[1] for n in co))
1360             if beg:
1361                 ii = find(beg, nx, right)
1362                 if ii is not None:
1363                     if not right:
1364                         gcdc = co[0][0]
1365                         for i in range(1, len(co)):
1366                             gcdc = gcdc.intersection(co[i][0])
1367                             if not gcdc:
1368                                 break
1369                         return Mul(*(list(gcdc) + beg[:ii]))
1370                     else:
1371                         m = ii + len(nx)
1372                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1373             end = list(reversed(
1374                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1375             if end:
1376                 ii = find(end, nx, right)
1377                 if ii is not None:
1378                     if not right:
1379                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1380                     else:
1381                         return Mul(*end[ii + len(nx):])
1382             # look for single match
1383             hit = None
1384             for i, (r, n) in enumerate(co):
1385                 ii = find(n, nx, right)
1386                 if ii is not None:
1387                     if not hit:
1388                         hit = ii, r, n
1389                     else:
1390                         break
1391             else:
1392                 if hit:
1393                     ii, r, n = hit
1394                     if not right:
1395                         return Mul(*(list(r) + n[:ii]))
1396                     else:
1397                         return Mul(*n[ii + len(nx):])
1398 
1399             return S.Zero
1400 
1401     def as_expr(self, *gens):
1402         """
1403         Convert a polynomial to a SymPy expression.
1404 
1405         Examples
1406         ========
1407 
1408         >>> from sympy import sin
1409         >>> from sympy.abc import x, y
1410 
1411         >>> f = (x**2 + x*y).as_poly(x, y)
1412         >>> f.as_expr()
1413         x**2 + x*y
1414 
1415         >>> sin(x).as_expr()
1416         sin(x)
1417 
1418         """
1419         return self
1420 
1421     def as_coefficient(self, expr):
1422         """
1423         Extracts symbolic coefficient at the given expression. In
1424         other words, this functions separates 'self' into the product
1425         of 'expr' and 'expr'-free coefficient. If such separation
1426         is not possible it will return None.
1427 
1428         Examples
1429         ========
1430 
1431         >>> from sympy import E, pi, sin, I, Poly
1432         >>> from sympy.abc import x
1433 
1434         >>> E.as_coefficient(E)
1435         1
1436         >>> (2*E).as_coefficient(E)
1437         2
1438         >>> (2*sin(E)*E).as_coefficient(E)
1439 
1440         Two terms have E in them so a sum is returned. (If one were
1441         desiring the coefficient of the term exactly matching E then
1442         the constant from the returned expression could be selected.
1443         Or, for greater precision, a method of Poly can be used to
1444         indicate the desired term from which the coefficient is
1445         desired.)
1446 
1447         >>> (2*E + x*E).as_coefficient(E)
1448         x + 2
1449         >>> _.args[0]  # just want the exact match
1450         2
1451         >>> p = Poly(2*E + x*E); p
1452         Poly(x*E + 2*E, x, E, domain='ZZ')
1453         >>> p.coeff_monomial(E)
1454         2
1455         >>> p.nth(0, 1)
1456         2
1457 
1458         Since the following cannot be written as a product containing
1459         E as a factor, None is returned. (If the coefficient ``2*x`` is
1460         desired then the ``coeff`` method should be used.)
1461 
1462         >>> (2*E*x + x).as_coefficient(E)
1463         >>> (2*E*x + x).coeff(E)
1464         2*x
1465 
1466         >>> (E*(x + 1) + x).as_coefficient(E)
1467 
1468         >>> (2*pi*I).as_coefficient(pi*I)
1469         2
1470         >>> (2*I).as_coefficient(pi*I)
1471 
1472         See Also
1473         ========
1474 
1475         coeff: return sum of terms have a given factor
1476         as_coeff_Add: separate the additive constant from an expression
1477         as_coeff_Mul: separate the multiplicative constant from an expression
1478         as_independent: separate x-dependent terms/factors from others
1479         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1480         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1481 
1482 
1483         """
1484 
1485         r = self.extract_multiplicatively(expr)
1486         if r and not r.has(expr):
1487             return r
1488 
1489     def as_independent(self, *deps, **hint):
1490         """
1491         A mostly naive separation of a Mul or Add into arguments that are not
1492         are dependent on deps. To obtain as complete a separation of variables
1493         as possible, use a separation method first, e.g.:
1494 
1495         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1496         * .expand(mul=True) to change Add or Mul into Add
1497         * .expand(log=True) to change log expr into an Add
1498 
1499         The only non-naive thing that is done here is to respect noncommutative
1500         ordering of variables and to always return (0, 0) for `self` of zero
1501         regardless of hints.
1502 
1503         For nonzero `self`, the returned tuple (i, d) has the
1504         following interpretation:
1505 
1506         * i will has no variable that appears in deps
1507         * d will be 1 or else have terms that contain variables that are in deps
1508         * if self is an Add then self = i + d
1509         * if self is a Mul then self = i*d
1510         * otherwise (self, S.One) or (S.One, self) is returned.
1511 
1512         To force the expression to be treated as an Add, use the hint as_Add=True
1513 
1514         Examples
1515         ========
1516 
1517         -- self is an Add
1518 
1519         >>> from sympy import sin, cos, exp
1520         >>> from sympy.abc import x, y, z
1521 
1522         >>> (x + x*y).as_independent(x)
1523         (0, x*y + x)
1524         >>> (x + x*y).as_independent(y)
1525         (x, x*y)
1526         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1527         (y + z, 2*x*sin(x) + x)
1528         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1529         (z, 2*x*sin(x) + x + y)
1530 
1531         -- self is a Mul
1532 
1533         >>> (x*sin(x)*cos(y)).as_independent(x)
1534         (cos(y), x*sin(x))
1535 
1536         non-commutative terms cannot always be separated out when self is a Mul
1537 
1538         >>> from sympy import symbols
1539         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1540         >>> (n1 + n1*n2).as_independent(n2)
1541         (n1, n1*n2)
1542         >>> (n2*n1 + n1*n2).as_independent(n2)
1543         (0, n1*n2 + n2*n1)
1544         >>> (n1*n2*n3).as_independent(n1)
1545         (1, n1*n2*n3)
1546         >>> (n1*n2*n3).as_independent(n2)
1547         (n1, n2*n3)
1548         >>> ((x-n1)*(x-y)).as_independent(x)
1549         (1, (x - y)*(x - n1))
1550 
1551         -- self is anything else:
1552 
1553         >>> (sin(x)).as_independent(x)
1554         (1, sin(x))
1555         >>> (sin(x)).as_independent(y)
1556         (sin(x), 1)
1557         >>> exp(x+y).as_independent(x)
1558         (1, exp(x + y))
1559 
1560         -- force self to be treated as an Add:
1561 
1562         >>> (3*x).as_independent(x, as_Add=True)
1563         (0, 3*x)
1564 
1565         -- force self to be treated as a Mul:
1566 
1567         >>> (3+x).as_independent(x, as_Add=False)
1568         (1, x + 3)
1569         >>> (-3+x).as_independent(x, as_Add=False)
1570         (1, x - 3)
1571 
1572         Note how the below differs from the above in making the
1573         constant on the dep term positive.
1574 
1575         >>> (y*(-3+x)).as_independent(x)
1576         (y, x - 3)
1577 
1578         -- use .as_independent() for true independence testing instead
1579            of .has(). The former considers only symbols in the free
1580            symbols while the latter considers all symbols
1581 
1582         >>> from sympy import Integral
1583         >>> I = Integral(x, (x, 1, 2))
1584         >>> I.has(x)
1585         True
1586         >>> x in I.free_symbols
1587         False
1588         >>> I.as_independent(x) == (I, 1)
1589         True
1590         >>> (I + x).as_independent(x) == (I, x)
1591         True
1592 
1593         Note: when trying to get independent terms, a separation method
1594         might need to be used first. In this case, it is important to keep
1595         track of what you send to this routine so you know how to interpret
1596         the returned values
1597 
1598         >>> from sympy import separatevars, log
1599         >>> separatevars(exp(x+y)).as_independent(x)
1600         (exp(y), exp(x))
1601         >>> (x + x*y).as_independent(y)
1602         (x, x*y)
1603         >>> separatevars(x + x*y).as_independent(y)
1604         (x, y + 1)
1605         >>> (x*(1 + y)).as_independent(y)
1606         (x, y + 1)
1607         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1608         (x, x*y)
1609         >>> a, b=symbols('a b', positive=True)
1610         >>> (log(a*b).expand(log=True)).as_independent(b)
1611         (log(a), log(b))
1612 
1613         See Also
1614         ========
1615         .separatevars(), .expand(log=True), Add.as_two_terms(),
1616         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1617         """
1618         from .symbol import Symbol
1619         from .add import _unevaluated_Add
1620         from .mul import _unevaluated_Mul
1621         from sympy.utilities.iterables import sift
1622 
1623         if self.is_zero:
1624             return S.Zero, S.Zero
1625 
1626         func = self.func
1627         if hint.get('as_Add', func is Add):
1628             want = Add
1629         else:
1630             want = Mul
1631 
1632         # sift out deps into symbolic and other and ignore
1633         # all symbols but those that are in the free symbols
1634         sym = set()
1635         other = []
1636         for d in deps:
1637             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1638                 sym.add(d)
1639             else:
1640                 other.append(d)
1641 
1642         def has(e):
1643             """return the standard has() if there are no literal symbols, else
1644             check to see that symbol-deps are in the free symbols."""
1645             has_other = e.has(*other)
1646             if not sym:
1647                 return has_other
1648             return has_other or e.has(*(e.free_symbols & sym))
1649 
1650         if (want is not func or
1651                 func is not Add and func is not Mul):
1652             if has(self):
1653                 return (want.identity, self)
1654             else:
1655                 return (self, want.identity)
1656         else:
1657             if func is Add:
1658                 args = list(self.args)
1659             else:
1660                 args, nc = self.args_cnc()
1661 
1662         d = sift(args, lambda x: has(x))
1663         depend = d[True]
1664         indep = d[False]
1665         if func is Add:  # all terms were treated as commutative
1666             return (Add(*indep), _unevaluated_Add(*depend))
1667         else:  # handle noncommutative by stopping at first dependent term
1668             for i, n in enumerate(nc):
1669                 if has(n):
1670                     depend.extend(nc[i:])
1671                     break
1672                 indep.append(n)
1673             return Mul(*indep), (
1674                 Mul(*depend, evaluate=False) if nc else
1675                 _unevaluated_Mul(*depend))
1676 
1677     def as_real_imag(self, deep=True, **hints):
1678         """Performs complex expansion on 'self' and returns a tuple
1679            containing collected both real and imaginary parts. This
1680            method can't be confused with re() and im() functions,
1681            which does not perform complex expansion at evaluation.
1682 
1683            However it is possible to expand both re() and im()
1684            functions and get exactly the same results as with
1685            a single call to this function.
1686 
1687            >>> from sympy import symbols, I
1688 
1689            >>> x, y = symbols('x,y', real=True)
1690 
1691            >>> (x + y*I).as_real_imag()
1692            (x, y)
1693 
1694            >>> from sympy.abc import z, w
1695 
1696            >>> (z + w*I).as_real_imag()
1697            (re(z) - im(w), re(w) + im(z))
1698 
1699         """
1700         from sympy import im, re
1701         if hints.get('ignore') == self:
1702             return None
1703         else:
1704             return (re(self), im(self))
1705 
1706     def as_powers_dict(self):
1707         """Return self as a dictionary of factors with each factor being
1708         treated as a power. The keys are the bases of the factors and the
1709         values, the corresponding exponents. The resulting dictionary should
1710         be used with caution if the expression is a Mul and contains non-
1711         commutative factors since the order that they appeared will be lost in
1712         the dictionary."""
1713         d = defaultdict(int)
1714         d.update(dict([self.as_base_exp()]))
1715         return d
1716 
1717     def as_coefficients_dict(self):
1718         """Return a dictionary mapping terms to their Rational coefficient.
1719         Since the dictionary is a defaultdict, inquiries about terms which
1720         were not present will return a coefficient of 0. If an expression is
1721         not an Add it is considered to have a single term.
1722 
1723         Examples
1724         ========
1725 
1726         >>> from sympy.abc import a, x
1727         >>> (3*x + a*x + 4).as_coefficients_dict()
1728         {1: 4, x: 3, a*x: 1}
1729         >>> _[a]
1730         0
1731         >>> (3*a*x).as_coefficients_dict()
1732         {a*x: 3}
1733 
1734         """
1735         c, m = self.as_coeff_Mul()
1736         if not c.is_Rational:
1737             c = S.One
1738             m = self
1739         d = defaultdict(int)
1740         d.update({m: c})
1741         return d
1742 
1743     def as_base_exp(self):
1744         # a -> b ** e
1745         return self, S.One
1746 
1747     def as_coeff_mul(self, *deps, **kwargs):
1748         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1749 
1750         c should be a Rational multiplied by any terms of the Mul that are
1751         independent of deps.
1752 
1753         args should be a tuple of all other terms of m; args is empty
1754         if self is a Number or if self is independent of deps (when given).
1755 
1756         This should be used when you don't know if self is a Mul or not but
1757         you want to treat self as a Mul or if you want to process the
1758         individual arguments of the tail of self as a Mul.
1759 
1760         - if you know self is a Mul and want only the head, use self.args[0];
1761         - if you don't want to process the arguments of the tail but need the
1762           tail then use self.as_two_terms() which gives the head and tail;
1763         - if you want to split self into an independent and dependent parts
1764           use ``self.as_independent(*deps)``
1765 
1766         >>> from sympy import S
1767         >>> from sympy.abc import x, y
1768         >>> (S(3)).as_coeff_mul()
1769         (3, ())
1770         >>> (3*x*y).as_coeff_mul()
1771         (3, (x, y))
1772         >>> (3*x*y).as_coeff_mul(x)
1773         (3*y, (x,))
1774         >>> (3*y).as_coeff_mul(x)
1775         (3*y, ())
1776         """
1777         if deps:
1778             if not self.has(*deps):
1779                 return self, tuple()
1780         return S.One, (self,)
1781 
1782     def as_coeff_add(self, *deps):
1783         """Return the tuple (c, args) where self is written as an Add, ``a``.
1784 
1785         c should be a Rational added to any terms of the Add that are
1786         independent of deps.
1787 
1788         args should be a tuple of all other terms of ``a``; args is empty
1789         if self is a Number or if self is independent of deps (when given).
1790 
1791         This should be used when you don't know if self is an Add or not but
1792         you want to treat self as an Add or if you want to process the
1793         individual arguments of the tail of self as an Add.
1794 
1795         - if you know self is an Add and want only the head, use self.args[0];
1796         - if you don't want to process the arguments of the tail but need the
1797           tail then use self.as_two_terms() which gives the head and tail.
1798         - if you want to split self into an independent and dependent parts
1799           use ``self.as_independent(*deps)``
1800 
1801         >>> from sympy import S
1802         >>> from sympy.abc import x, y
1803         >>> (S(3)).as_coeff_add()
1804         (3, ())
1805         >>> (3 + x).as_coeff_add()
1806         (3, (x,))
1807         >>> (3 + x + y).as_coeff_add(x)
1808         (y + 3, (x,))
1809         >>> (3 + y).as_coeff_add(x)
1810         (y + 3, ())
1811 
1812         """
1813         if deps:
1814             if not self.has(*deps):
1815                 return self, tuple()
1816         return S.Zero, (self,)
1817 
1818     def primitive(self):
1819         """Return the positive Rational that can be extracted non-recursively
1820         from every term of self (i.e., self is treated like an Add). This is
1821         like the as_coeff_Mul() method but primitive always extracts a positive
1822         Rational (never a negative or a Float).
1823 
1824         Examples
1825         ========
1826 
1827         >>> from sympy.abc import x
1828         >>> (3*(x + 1)**2).primitive()
1829         (3, (x + 1)**2)
1830         >>> a = (6*x + 2); a.primitive()
1831         (2, 3*x + 1)
1832         >>> b = (x/2 + 3); b.primitive()
1833         (1/2, x + 6)
1834         >>> (a*b).primitive() == (1, a*b)
1835         True
1836         """
1837         if not self:
1838             return S.One, S.Zero
1839         c, r = self.as_coeff_Mul(rational=True)
1840         if c.is_negative:
1841             c, r = -c, -r
1842         return c, r
1843 
1844     def as_content_primitive(self, radical=False, clear=True):
1845         """This method should recursively remove a Rational from all arguments
1846         and return that (content) and the new self (primitive). The content
1847         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
1848         The primitive need no be in canonical form and should try to preserve
1849         the underlying structure if possible (i.e. expand_mul should not be
1850         applied to self).
1851 
1852         Examples
1853         ========
1854 
1855         >>> from sympy import sqrt
1856         >>> from sympy.abc import x, y, z
1857 
1858         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
1859 
1860         The as_content_primitive function is recursive and retains structure:
1861 
1862         >>> eq.as_content_primitive()
1863         (2, x + 3*y*(y + 1) + 1)
1864 
1865         Integer powers will have Rationals extracted from the base:
1866 
1867         >>> ((2 + 6*x)**2).as_content_primitive()
1868         (4, (3*x + 1)**2)
1869         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
1870         (1, (2*(3*x + 1))**(2*y))
1871 
1872         Terms may end up joining once their as_content_primitives are added:
1873 
1874         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1875         (11, x*(y + 1))
1876         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
1877         (9, x*(y + 1))
1878         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
1879         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
1880         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
1881         (121, x**2*(y + 1)**2)
1882         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
1883         (1, 121.0*x**2*(y + 1)**2)
1884 
1885         Radical content can also be factored out of the primitive:
1886 
1887         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
1888         (2, sqrt(2)*(1 + 2*sqrt(5)))
1889 
1890         If clear=False (default is True) then content will not be removed
1891         from an Add if it can be distributed to leave one or more
1892         terms with integer coefficients.
1893 
1894         >>> (x/2 + y).as_content_primitive()
1895         (1/2, x + 2*y)
1896         >>> (x/2 + y).as_content_primitive(clear=False)
1897         (1, x/2 + y)
1898         """
1899         return S.One, self
1900 
1901     def as_numer_denom(self):
1902         """ expression -> a/b -> a, b
1903 
1904         This is just a stub that should be defined by
1905         an object's class methods to get anything else.
1906 
1907         See Also
1908         ========
1909         normal: return a/b instead of a, b
1910         """
1911 
1912         return self, S.One
1913 
1914     def normal(self):
1915         n, d = self.as_numer_denom()
1916         if d is S.One:
1917             return n
1918         return n/d
1919 
1920     def extract_multiplicatively(self, c):
1921         """Return None if it's not possible to make self in the form
1922            c * something in a nice way, i.e. preserving the properties
1923            of arguments of self.
1924 
1925            >>> from sympy import symbols, Rational
1926 
1927            >>> x, y = symbols('x,y', real=True)
1928 
1929            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
1930            x*y**2
1931 
1932            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
1933 
1934            >>> (2*x).extract_multiplicatively(2)
1935            x
1936 
1937            >>> (2*x).extract_multiplicatively(3)
1938 
1939            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
1940            x/6
1941 
1942         """
1943         c = sympify(c)
1944         if self is S.NaN:
1945             return None
1946         if c is S.One:
1947             return self
1948         elif c == self:
1949             return S.One
1950         if c.is_Add:
1951             cc, pc = c.primitive()
1952             if cc is not S.One:
1953                 c = Mul(cc, pc, evaluate=False)
1954         if c.is_Mul:
1955             a, b = c.as_two_terms()
1956             x = self.extract_multiplicatively(a)
1957             if x is not None:
1958                 return x.extract_multiplicatively(b)
1959         quotient = self / c
1960         if self.is_Number:
1961             if self is S.Infinity:
1962                 if c.is_positive:
1963                     return S.Infinity
1964             elif self is S.NegativeInfinity:
1965                 if c.is_negative:
1966                     return S.Infinity
1967                 elif c.is_positive:
1968                     return S.NegativeInfinity
1969             elif self is S.ComplexInfinity:
1970                 if not c.is_zero:
1971                     return S.ComplexInfinity
1972             elif self.is_Integer:
1973                 if not quotient.is_Integer:
1974                     return None
1975                 elif self.is_positive and quotient.is_negative:
1976                     return None
1977                 else:
1978                     return quotient
1979             elif self.is_Rational:
1980                 if not quotient.is_Rational:
1981                     return None
1982                 elif self.is_positive and quotient.is_negative:
1983                     return None
1984                 else:
1985                     return quotient
1986             elif self.is_Float:
1987                 if not quotient.is_Float:
1988                     return None
1989                 elif self.is_positive and quotient.is_negative:
1990                     return None
1991                 else:
1992                     return quotient
1993         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
1994             if quotient.is_Mul and len(quotient.args) == 2:
1995                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
1996                     return quotient
1997             elif quotient.is_Integer and c.is_Number:
1998                 return quotient
1999         elif self.is_Add:
2000             cs, ps = self.primitive()
2001             if cs is not S.One:
2002                 return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)
2003             newargs = []
2004             for arg in self.args:
2005                 newarg = arg.extract_multiplicatively(c)
2006                 if newarg is not None:
2007                     newargs.append(newarg)
2008                 else:
2009                     return None
2010             return Add(*newargs)
2011         elif self.is_Mul:
2012             args = list(self.args)
2013             for i, arg in enumerate(args):
2014                 newarg = arg.extract_multiplicatively(c)
2015                 if newarg is not None:
2016                     args[i] = newarg
2017                     return Mul(*args)
2018         elif self.is_Pow:
2019             if c.is_Pow and c.base == self.base:
2020                 new_exp = self.exp.extract_additively(c.exp)
2021                 if new_exp is not None:
2022                     return self.base ** (new_exp)
2023             elif c == self.base:
2024                 new_exp = self.exp.extract_additively(1)
2025                 if new_exp is not None:
2026                     return self.base ** (new_exp)
2027 
2028     def extract_additively(self, c):
2029         """Return self - c if it's possible to subtract c from self and
2030         make all matching coefficients move towards zero, else return None.
2031 
2032         Examples
2033         ========
2034 
2035         >>> from sympy.abc import x, y
2036         >>> e = 2*x + 3
2037         >>> e.extract_additively(x + 1)
2038         x + 2
2039         >>> e.extract_additively(3*x)
2040         >>> e.extract_additively(4)
2041         >>> (y*(x + 1)).extract_additively(x + 1)
2042         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2043         (x + 1)*(x + 2*y) + 3
2044 
2045         Sometimes auto-expansion will return a less simplified result
2046         than desired; gcd_terms might be used in such cases:
2047 
2048         >>> from sympy import gcd_terms
2049         >>> (4*x*(y + 1) + y).extract_additively(x)
2050         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2051         >>> gcd_terms(_)
2052         x*(4*y + 3) + y
2053 
2054         See Also
2055         ========
2056         extract_multiplicatively
2057         coeff
2058         as_coefficient
2059 
2060         """
2061 
2062         c = sympify(c)
2063         if self is S.NaN:
2064             return None
2065         if c is S.Zero:
2066             return self
2067         elif c == self:
2068             return S.Zero
2069         elif self is S.Zero:
2070             return None
2071 
2072         if self.is_Number:
2073             if not c.is_Number:
2074                 return None
2075             co = self
2076             diff = co - c
2077             # XXX should we match types? i.e should 3 - .1 succeed?
2078             if (co > 0 and diff > 0 and diff < co or
2079                     co < 0 and diff < 0 and diff > co):
2080                 return diff
2081             return None
2082 
2083         if c.is_Number:
2084             co, t = self.as_coeff_Add()
2085             xa = co.extract_additively(c)
2086             if xa is None:
2087                 return None
2088             return xa + t
2089 
2090         # handle the args[0].is_Number case separately
2091         # since we will have trouble looking for the coeff of
2092         # a number.
2093         if c.is_Add and c.args[0].is_Number:
2094             # whole term as a term factor
2095             co = self.coeff(c)
2096             xa0 = (co.extract_additively(1) or 0)*c
2097             if xa0:
2098                 diff = self - co*c
2099                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2100             # term-wise
2101             h, t = c.as_coeff_Add()
2102             sh, st = self.as_coeff_Add()
2103             xa = sh.extract_additively(h)
2104             if xa is None:
2105                 return None
2106             xa2 = st.extract_additively(t)
2107             if xa2 is None:
2108                 return None
2109             return xa + xa2
2110 
2111         # whole term as a term factor
2112         co = self.coeff(c)
2113         xa0 = (co.extract_additively(1) or 0)*c
2114         if xa0:
2115             diff = self - co*c
2116             return (xa0 + (diff.extract_additively(c) or diff)) or None
2117         # term-wise
2118         coeffs = []
2119         for a in Add.make_args(c):
2120             ac, at = a.as_coeff_Mul()
2121             co = self.coeff(at)
2122             if not co:
2123                 return None
2124             coc, cot = co.as_coeff_Add()
2125             xa = coc.extract_additively(ac)
2126             if xa is None:
2127                 return None
2128             self -= co*at
2129             coeffs.append((cot + xa)*at)
2130         coeffs.append(self)
2131         return Add(*coeffs)
2132 
2133     def could_extract_minus_sign(self):
2134         """Canonical way to choose an element in the set {e, -e} where
2135            e is any expression. If the canonical element is e, we have
2136            e.could_extract_minus_sign() == True, else
2137            e.could_extract_minus_sign() == False.
2138 
2139            For any expression, the set ``{e.could_extract_minus_sign(),
2140            (-e).could_extract_minus_sign()}`` must be ``{True, False}``.
2141 
2142            >>> from sympy.abc import x, y
2143            >>> (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()
2144            True
2145 
2146         """
2147         negative_self = -self
2148         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2149         negative_self_has_minus = (
2150             (negative_self).extract_multiplicatively(-1) is not None)
2151         if self_has_minus != negative_self_has_minus:
2152             return self_has_minus
2153         else:
2154             if self.is_Add:
2155                 # We choose the one with less arguments with minus signs
2156                 all_args = len(self.args)
2157                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2158                 positive_args = all_args - negative_args
2159                 if positive_args > negative_args:
2160                     return False
2161                 elif positive_args < negative_args:
2162                     return True
2163             elif self.is_Mul:
2164                 # We choose the one with an odd number of minus signs
2165                 num, den = self.as_numer_denom()
2166                 args = Mul.make_args(num) + Mul.make_args(den)
2167                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2168                 negative_args = list(filter(None, arg_signs))
2169                 return len(negative_args) % 2 == 1
2170 
2171             # As a last resort, we choose the one with greater value of .sort_key()
2172             return bool(self.sort_key() < negative_self.sort_key())
2173 
2174     def extract_branch_factor(self, allow_half=False):
2175         """
2176         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2177         Return (z, n).
2178 
2179         >>> from sympy import exp_polar, I, pi
2180         >>> from sympy.abc import x, y
2181         >>> exp_polar(I*pi).extract_branch_factor()
2182         (exp_polar(I*pi), 0)
2183         >>> exp_polar(2*I*pi).extract_branch_factor()
2184         (1, 1)
2185         >>> exp_polar(-pi*I).extract_branch_factor()
2186         (exp_polar(I*pi), -1)
2187         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2188         (exp_polar(x + I*pi), 1)
2189         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2190         (y*exp_polar(2*pi*x), -1)
2191         >>> exp_polar(-I*pi/2).extract_branch_factor()
2192         (exp_polar(-I*pi/2), 0)
2193 
2194         If allow_half is True, also extract exp_polar(I*pi):
2195 
2196         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2197         (1, 1/2)
2198         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2199         (1, 1)
2200         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2201         (1, 3/2)
2202         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2203         (1, -1/2)
2204         """
2205         from sympy import exp_polar, pi, I, ceiling, Add
2206         n = S(0)
2207         res = S(1)
2208         args = Mul.make_args(self)
2209         exps = []
2210         for arg in args:
2211             if arg.func is exp_polar:
2212                 exps += [arg.exp]
2213             else:
2214                 res *= arg
2215         piimult = S(0)
2216         extras = []
2217         while exps:
2218             exp = exps.pop()
2219             if exp.is_Add:
2220                 exps += exp.args
2221                 continue
2222             if exp.is_Mul:
2223                 coeff = exp.as_coefficient(pi*I)
2224                 if coeff is not None:
2225                     piimult += coeff
2226                     continue
2227             extras += [exp]
2228         if not piimult.free_symbols:
2229             coeff = piimult
2230             tail = ()
2231         else:
2232             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2233         # round down to nearest multiple of 2
2234         branchfact = ceiling(coeff/2 - S(1)/2)*2
2235         n += branchfact/2
2236         c = coeff - branchfact
2237         if allow_half:
2238             nc = c.extract_additively(1)
2239             if nc is not None:
2240                 n += S(1)/2
2241                 c = nc
2242         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2243         if newexp != 0:
2244             res *= exp_polar(newexp)
2245         return res, n
2246 
2247     def _eval_is_polynomial(self, syms):
2248         if self.free_symbols.intersection(syms) == set([]):
2249             return True
2250         return False
2251 
2252     def is_polynomial(self, *syms):
2253         """
2254         Return True if self is a polynomial in syms and False otherwise.
2255 
2256         This checks if self is an exact polynomial in syms.  This function
2257         returns False for expressions that are "polynomials" with symbolic
2258         exponents.  Thus, you should be able to apply polynomial algorithms to
2259         expressions for which this returns True, and Poly(expr, \*syms) should
2260         work if and only if expr.is_polynomial(\*syms) returns True. The
2261         polynomial does not have to be in expanded form.  If no symbols are
2262         given, all free symbols in the expression will be used.
2263 
2264         This is not part of the assumptions system.  You cannot do
2265         Symbol('z', polynomial=True).
2266 
2267         Examples
2268         ========
2269 
2270         >>> from sympy import Symbol
2271         >>> x = Symbol('x')
2272         >>> ((x**2 + 1)**4).is_polynomial(x)
2273         True
2274         >>> ((x**2 + 1)**4).is_polynomial()
2275         True
2276         >>> (2**x + 1).is_polynomial(x)
2277         False
2278 
2279 
2280         >>> n = Symbol('n', nonnegative=True, integer=True)
2281         >>> (x**n + 1).is_polynomial(x)
2282         False
2283 
2284         This function does not attempt any nontrivial simplifications that may
2285         result in an expression that does not appear to be a polynomial to
2286         become one.
2287 
2288         >>> from sympy import sqrt, factor, cancel
2289         >>> y = Symbol('y', positive=True)
2290         >>> a = sqrt(y**2 + 2*y + 1)
2291         >>> a.is_polynomial(y)
2292         False
2293         >>> factor(a)
2294         y + 1
2295         >>> factor(a).is_polynomial(y)
2296         True
2297 
2298         >>> b = (y**2 + 2*y + 1)/(y + 1)
2299         >>> b.is_polynomial(y)
2300         False
2301         >>> cancel(b)
2302         y + 1
2303         >>> cancel(b).is_polynomial(y)
2304         True
2305 
2306         See also .is_rational_function()
2307 
2308         """
2309         if syms:
2310             syms = set(map(sympify, syms))
2311         else:
2312             syms = self.free_symbols
2313 
2314         if syms.intersection(self.free_symbols) == set([]):
2315             # constant polynomial
2316             return True
2317         else:
2318             return self._eval_is_polynomial(syms)
2319 
2320     def _eval_is_rational_function(self, syms):
2321         if self.free_symbols.intersection(syms) == set([]):
2322             return True
2323         return False
2324 
2325     def is_rational_function(self, *syms):
2326         """
2327         Test whether function is a ratio of two polynomials in the given
2328         symbols, syms. When syms is not given, all free symbols will be used.
2329         The rational function does not have to be in expanded or in any kind of
2330         canonical form.
2331 
2332         This function returns False for expressions that are "rational
2333         functions" with symbolic exponents.  Thus, you should be able to call
2334         .as_numer_denom() and apply polynomial algorithms to the result for
2335         expressions for which this returns True.
2336 
2337         This is not part of the assumptions system.  You cannot do
2338         Symbol('z', rational_function=True).
2339 
2340         Examples
2341         ========
2342 
2343         >>> from sympy import Symbol, sin
2344         >>> from sympy.abc import x, y
2345 
2346         >>> (x/y).is_rational_function()
2347         True
2348 
2349         >>> (x**2).is_rational_function()
2350         True
2351 
2352         >>> (x/sin(y)).is_rational_function(y)
2353         False
2354 
2355         >>> n = Symbol('n', integer=True)
2356         >>> (x**n + 1).is_rational_function(x)
2357         False
2358 
2359         This function does not attempt any nontrivial simplifications that may
2360         result in an expression that does not appear to be a rational function
2361         to become one.
2362 
2363         >>> from sympy import sqrt, factor
2364         >>> y = Symbol('y', positive=True)
2365         >>> a = sqrt(y**2 + 2*y + 1)/y
2366         >>> a.is_rational_function(y)
2367         False
2368         >>> factor(a)
2369         (y + 1)/y
2370         >>> factor(a).is_rational_function(y)
2371         True
2372 
2373         See also is_algebraic_expr().
2374 
2375         """
2376         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2377             return False
2378 
2379         if syms:
2380             syms = set(map(sympify, syms))
2381         else:
2382             syms = self.free_symbols
2383 
2384         if syms.intersection(self.free_symbols) == set([]):
2385             # constant rational function
2386             return True
2387         else:
2388             return self._eval_is_rational_function(syms)
2389 
2390     def _eval_is_algebraic_expr(self, syms):
2391         if self.free_symbols.intersection(syms) == set([]):
2392             return True
2393         return False
2394 
2395     def is_algebraic_expr(self, *syms):
2396         """
2397         This tests whether a given expression is algebraic or not, in the
2398         given symbols, syms. When syms is not given, all free symbols
2399         will be used. The rational function does not have to be in expanded
2400         or in any kind of canonical form.
2401 
2402         This function returns False for expressions that are "algebraic
2403         expressions" with symbolic exponents. This is a simple extension to the
2404         is_rational_function, including rational exponentiation.
2405 
2406         Examples
2407         ========
2408 
2409         >>> from sympy import Symbol, sqrt
2410         >>> x = Symbol('x', real=True)
2411         >>> sqrt(1 + x).is_rational_function()
2412         False
2413         >>> sqrt(1 + x).is_algebraic_expr()
2414         True
2415 
2416         This function does not attempt any nontrivial simplifications that may
2417         result in an expression that does not appear to be an algebraic
2418         expression to become one.
2419 
2420         >>> from sympy import exp, factor
2421         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2422         >>> a.is_algebraic_expr(x)
2423         False
2424         >>> factor(a).is_algebraic_expr()
2425         True
2426 
2427         See Also
2428         ========
2429         is_rational_function()
2430 
2431         References
2432         ==========
2433 
2434         - http://en.wikipedia.org/wiki/Algebraic_expression
2435 
2436         """
2437         if syms:
2438             syms = set(map(sympify, syms))
2439         else:
2440             syms = self.free_symbols
2441 
2442         if syms.intersection(self.free_symbols) == set([]):
2443             # constant algebraic expression
2444             return True
2445         else:
2446             return self._eval_is_algebraic_expr(syms)
2447 
2448     ###################################################################################
2449     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2450     ###################################################################################
2451 
2452     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2453         """
2454         Series expansion of "self" around ``x = x0`` yielding either terms of
2455         the series one by one (the lazy series given when n=None), else
2456         all the terms at once when n != None.
2457 
2458         Returns the series expansion of "self" around the point ``x = x0``
2459         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2460 
2461         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2462         be supplied, otherwise an error will be raised.
2463 
2464         >>> from sympy import cos, exp
2465         >>> from sympy.abc import x, y
2466         >>> cos(x).series()
2467         1 - x**2/2 + x**4/24 + O(x**6)
2468         >>> cos(x).series(n=4)
2469         1 - x**2/2 + O(x**4)
2470         >>> cos(x).series(x, x0=1, n=2)
2471         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2472         >>> e = cos(x + exp(y))
2473         >>> e.series(y, n=2)
2474         cos(x + 1) - y*sin(x + 1) + O(y**2)
2475         >>> e.series(x, n=2)
2476         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2477 
2478         If ``n=None`` then a generator of the series terms will be returned.
2479 
2480         >>> term=cos(x).series(n=None)
2481         >>> [next(term) for i in range(2)]
2482         [1, -x**2/2]
2483 
2484         For ``dir=+`` (default) the series is calculated from the right and
2485         for ``dir=-`` the series from the left. For smooth functions this
2486         flag will not alter the results.
2487 
2488         >>> abs(x).series(dir="+")
2489         x
2490         >>> abs(x).series(dir="-")
2491         -x
2492 
2493         """
2494         from sympy import collect, Dummy, Order, Rational, Symbol
2495         if x is None:
2496             syms = self.atoms(Symbol)
2497             if not syms:
2498                 return self
2499             elif len(syms) > 1:
2500                 raise ValueError('x must be given for multivariate functions.')
2501             x = syms.pop()
2502 
2503         if not self.has(x):
2504             if n is None:
2505                 return (s for s in [self])
2506             else:
2507                 return self
2508 
2509         if len(dir) != 1 or dir not in '+-':
2510             raise ValueError("Dir must be '+' or '-'")
2511 
2512         if x0 in [S.Infinity, S.NegativeInfinity]:
2513             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]
2514             s = self.subs(x, 1/x).series(x, n=n, dir=dir)
2515             if n is None:
2516                 return (si.subs(x, 1/x) for si in s)
2517             return s.subs(x, 1/x)
2518 
2519         # use rep to shift origin to x0 and change sign (if dir is negative)
2520         # and undo the process with rep2
2521         if x0 or dir == '-':
2522             if dir == '-':
2523                 rep = -x + x0
2524                 rep2 = -x
2525                 rep2b = x0
2526             else:
2527                 rep = x + x0
2528                 rep2 = x
2529                 rep2b = -x0
2530             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2531             if n is None:  # lseries...
2532                 return (si.subs(x, rep2 + rep2b) for si in s)
2533             return s.subs(x, rep2 + rep2b)
2534 
2535         # from here on it's x0=0 and dir='+' handling
2536 
2537         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2538             # replace x with an x that has a positive assumption
2539             xpos = Dummy('x', positive=True, finite=True)
2540             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2541             if n is None:
2542                 return (s.subs(xpos, x) for s in rv)
2543             else:
2544                 return rv.subs(xpos, x)
2545 
2546         if n is not None:  # nseries handling
2547             s1 = self._eval_nseries(x, n=n, logx=logx)
2548             o = s1.getO() or S.Zero
2549             if o:
2550                 # make sure the requested order is returned
2551                 ngot = o.getn()
2552                 if ngot > n:
2553                     # leave o in its current form (e.g. with x*log(x)) so
2554                     # it eats terms properly, then replace it below
2555                     if n != 0:
2556                         s1 += o.subs(x, x**Rational(n, ngot))
2557                     else:
2558                         s1 += Order(1, x)
2559                 elif ngot < n:
2560                     # increase the requested number of terms to get the desired
2561                     # number keep increasing (up to 9) until the received order
2562                     # is different than the original order and then predict how
2563                     # many additional terms are needed
2564                     for more in range(1, 9):
2565                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2566                         newn = s1.getn()
2567                         if newn != ngot:
2568                             ndo = n + (n - ngot)*more/(newn - ngot)
2569                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2570                             while s1.getn() < n:
2571                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2572                                 ndo += 1
2573                             break
2574                     else:
2575                         raise ValueError('Could not calculate %s terms for %s'
2576                                          % (str(n), self))
2577                     s1 += Order(x**n, x)
2578                 o = s1.getO()
2579                 s1 = s1.removeO()
2580             else:
2581                 o = Order(x**n, x)
2582                 s1done = s1.doit()
2583                 if (s1done + o).removeO() == s1done:
2584                     o = S.Zero
2585 
2586             try:
2587                 return collect(s1, x) + o
2588             except NotImplementedError:
2589                 return s1 + o
2590 
2591         else:  # lseries handling
2592             def yield_lseries(s):
2593                 """Return terms of lseries one at a time."""
2594                 for si in s:
2595                     if not si.is_Add:
2596                         yield si
2597                         continue
2598                     # yield terms 1 at a time if possible
2599                     # by increasing order until all the
2600                     # terms have been returned
2601                     yielded = 0
2602                     o = Order(si, x)*x
2603                     ndid = 0
2604                     ndo = len(si.args)
2605                     while 1:
2606                         do = (si - yielded + o).removeO()
2607                         o *= x
2608                         if not do or do.is_Order:
2609                             continue
2610                         if do.is_Add:
2611                             ndid += len(do.args)
2612                         else:
2613                             ndid += 1
2614                         yield do
2615                         if ndid == ndo:
2616                             break
2617                         yielded += do
2618 
2619             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2620 
2621     def taylor_term(self, n, x, *previous_terms):
2622         """General method for the taylor term.
2623 
2624         This method is slow, because it differentiates n-times. Subclasses can
2625         redefine it to make it faster by using the "previous_terms".
2626         """
2627         from sympy import Dummy, factorial
2628         x = sympify(x)
2629         _x = Dummy('x')
2630         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2631 
2632     def lseries(self, x=None, x0=0, dir='+', logx=None):
2633         """
2634         Wrapper for series yielding an iterator of the terms of the series.
2635 
2636         Note: an infinite series will yield an infinite iterator. The following,
2637         for exaxmple, will never terminate. It will just keep printing terms
2638         of the sin(x) series::
2639 
2640           for term in sin(x).lseries(x):
2641               print term
2642 
2643         The advantage of lseries() over nseries() is that many times you are
2644         just interested in the next term in the series (i.e. the first term for
2645         example), but you don't know how many you should ask for in nseries()
2646         using the "n" parameter.
2647 
2648         See also nseries().
2649         """
2650         return self.series(x, x0, n=None, dir=dir, logx=logx)
2651 
2652     def _eval_lseries(self, x, logx=None):
2653         # default implementation of lseries is using nseries(), and adaptively
2654         # increasing the "n". As you can see, it is not very efficient, because
2655         # we are calculating the series over and over again. Subclasses should
2656         # override this method and implement much more efficient yielding of
2657         # terms.
2658         n = 0
2659         series = self._eval_nseries(x, n=n, logx=logx)
2660         if not series.is_Order:
2661             if series.is_Add:
2662                 yield series.removeO()
2663             else:
2664                 yield series
2665             return
2666 
2667         while series.is_Order:
2668             n += 1
2669             series = self._eval_nseries(x, n=n, logx=logx)
2670         e = series.removeO()
2671         yield e
2672         while 1:
2673             while 1:
2674                 n += 1
2675                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
2676                 if e != series:
2677                     break
2678             yield series - e
2679             e = series
2680 
2681     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
2682         """
2683         Wrapper to _eval_nseries if assumptions allow, else to series.
2684 
2685         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
2686         called. This calculates "n" terms in the innermost expressions and
2687         then builds up the final series just by "cross-multiplying" everything
2688         out.
2689 
2690         The optional ``logx`` parameter can be used to replace any log(x) in the
2691         returned series with a symbolic value to avoid evaluating log(x) at 0. A
2692         symbol to use in place of log(x) should be provided.
2693 
2694         Advantage -- it's fast, because we don't have to determine how many
2695         terms we need to calculate in advance.
2696 
2697         Disadvantage -- you may end up with less terms than you may have
2698         expected, but the O(x**n) term appended will always be correct and
2699         so the result, though perhaps shorter, will also be correct.
2700 
2701         If any of those assumptions is not met, this is treated like a
2702         wrapper to series which will try harder to return the correct
2703         number of terms.
2704 
2705         See also lseries().
2706 
2707         Examples
2708         ========
2709 
2710         >>> from sympy import sin, log, Symbol
2711         >>> from sympy.abc import x, y
2712         >>> sin(x).nseries(x, 0, 6)
2713         x - x**3/6 + x**5/120 + O(x**6)
2714         >>> log(x+1).nseries(x, 0, 5)
2715         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
2716 
2717         Handling of the ``logx`` parameter --- in the following example the
2718         expansion fails since ``sin`` does not have an asymptotic expansion
2719         at -oo (the limit of log(x) as x approaches 0):
2720 
2721         >>> e = sin(log(x))
2722         >>> e.nseries(x, 0, 6)
2723         Traceback (most recent call last):
2724         ...
2725         PoleError: ...
2726         ...
2727         >>> logx = Symbol('logx')
2728         >>> e.nseries(x, 0, 6, logx=logx)
2729         sin(logx)
2730 
2731         In the following example, the expansion works but gives only an Order term
2732         unless the ``logx`` parameter is used:
2733 
2734         >>> e = x**y
2735         >>> e.nseries(x, 0, 2)
2736         O(log(x)**2)
2737         >>> e.nseries(x, 0, 2, logx=logx)
2738         exp(logx*y)
2739 
2740         """
2741         if x and not x in self.free_symbols:
2742             return self
2743         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
2744             return self.series(x, x0, n, dir)
2745         else:
2746             return self._eval_nseries(x, n=n, logx=logx)
2747 
2748     def _eval_nseries(self, x, n, logx):
2749         """
2750         Return terms of series for self up to O(x**n) at x=0
2751         from the positive direction.
2752 
2753         This is a method that should be overridden in subclasses. Users should
2754         never call this method directly (use .nseries() instead), so you don't
2755         have to write docstrings for _eval_nseries().
2756         """
2757         from sympy.utilities.misc import filldedent
2758         raise NotImplementedError(filldedent("""
2759                      The _eval_nseries method should be added to
2760                      %s to give terms up to O(x**n) at x=0
2761                      from the positive direction so it is available when
2762                      nseries calls it.""" % self.func)
2763                      )
2764 
2765     def limit(self, x, xlim, dir='+'):
2766         """ Compute limit x->xlim.
2767         """
2768         from sympy.series.limits import limit
2769         return limit(self, x, xlim, dir)
2770 
2771     def compute_leading_term(self, x, logx=None):
2772         """
2773         as_leading_term is only allowed for results of .series()
2774         This is a wrapper to compute a series first.
2775         """
2776         from sympy import Dummy, log
2777         from sympy.series.gruntz import calculate_series
2778 
2779         if self.removeO() == 0:
2780             return self
2781 
2782         if logx is None:
2783             d = Dummy('logx')
2784             s = calculate_series(self, x, d).subs(d, log(x))
2785         else:
2786             s = calculate_series(self, x, logx)
2787 
2788         return s.as_leading_term(x)
2789 
2790     @cacheit
2791     def as_leading_term(self, *symbols):
2792         """
2793         Returns the leading (nonzero) term of the series expansion of self.
2794 
2795         The _eval_as_leading_term routines are used to do this, and they must
2796         always return a non-zero value.
2797 
2798         Examples
2799         ========
2800 
2801         >>> from sympy.abc import x
2802         >>> (1 + x + x**2).as_leading_term(x)
2803         1
2804         >>> (1/x**2 + x + x**2).as_leading_term(x)
2805         x**(-2)
2806 
2807         """
2808         from sympy import powsimp
2809         if len(symbols) > 1:
2810             c = self
2811             for x in symbols:
2812                 c = c.as_leading_term(x)
2813             return c
2814         elif not symbols:
2815             return self
2816         x = sympify(symbols[0])
2817         if not x.is_Symbol:
2818             raise ValueError('expecting a Symbol but got %s' % x)
2819         if x not in self.free_symbols:
2820             return self
2821         obj = self._eval_as_leading_term(x)
2822         if obj is not None:
2823             return powsimp(obj, deep=True, combine='exp')
2824         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
2825 
2826     def _eval_as_leading_term(self, x):
2827         return self
2828 
2829     def as_coeff_exponent(self, x):
2830         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
2831         """
2832         from sympy import collect
2833         s = collect(self, x)
2834         c, p = s.as_coeff_mul(x)
2835         if len(p) == 1:
2836             b, e = p[0].as_base_exp()
2837             if b == x:
2838                 return c, e
2839         return s, S.Zero
2840 
2841     def leadterm(self, x):
2842         """
2843         Returns the leading term a*x**b as a tuple (a, b).
2844 
2845         Examples
2846         ========
2847 
2848         >>> from sympy.abc import x
2849         >>> (1+x+x**2).leadterm(x)
2850         (1, 0)
2851         >>> (1/x**2+x+x**2).leadterm(x)
2852         (1, -2)
2853 
2854         """
2855         from sympy import Dummy, log
2856         l = self.as_leading_term(x)
2857         d = Dummy('logx')
2858         if l.has(log(x)):
2859             l = l.subs(log(x), d)
2860         c, e = l.as_coeff_exponent(x)
2861         if x in c.free_symbols:
2862             from sympy.utilities.misc import filldedent
2863             raise ValueError(filldedent("""
2864                 cannot compute leadterm(%s, %s). The coefficient
2865                 should have been free of x but got %s""" % (self, x, c)))
2866         c = c.subs(d, log(x))
2867         return c, e
2868 
2869     def as_coeff_Mul(self, rational=False):
2870         """Efficiently extract the coefficient of a product. """
2871         return S.One, self
2872 
2873     def as_coeff_Add(self, rational=False):
2874         """Efficiently extract the coefficient of a summation. """
2875         return S.Zero, self
2876 
2877     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
2878             full=False):
2879         """
2880         Compute formal power power series of self.
2881 
2882         See the docstring of the :func:`fps` function in sympy.series.formal for
2883         more information.
2884         """
2885         from sympy.series.formal import fps
2886 
2887         return fps(self, x, x0, dir, hyper, order, rational, full)
2888 
2889     def fourier_series(self, limits=None):
2890         """Compute fourier sine/cosine series of self.
2891 
2892         See the docstring of the :func:`fourier_series` in sympy.series.fourier
2893         for more information.
2894         """
2895         from sympy.series.fourier import fourier_series
2896 
2897         return fourier_series(self, limits)
2898 
2899     ###################################################################################
2900     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
2901     ###################################################################################
2902 
2903     def diff(self, *symbols, **assumptions):
2904         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z
2905         assumptions.setdefault("evaluate", True)
2906         return Derivative(self, *new_symbols, **assumptions)
2907 
2908     ###########################################################################
2909     ###################### EXPRESSION EXPANSION METHODS #######################
2910     ###########################################################################
2911 
2912     # Relevant subclasses should override _eval_expand_hint() methods.  See
2913     # the docstring of expand() for more info.
2914 
2915     def _eval_expand_complex(self, **hints):
2916         real, imag = self.as_real_imag(**hints)
2917         return real + S.ImaginaryUnit*imag
2918 
2919     @staticmethod
2920     def _expand_hint(expr, hint, deep=True, **hints):
2921         """
2922         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
2923 
2924         Returns ``(expr, hit)``, where expr is the (possibly) expanded
2925         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
2926         ``False`` otherwise.
2927         """
2928         hit = False
2929         # XXX: Hack to support non-Basic args
2930         #              |
2931         #              V
2932         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
2933             sargs = []
2934             for arg in expr.args:
2935                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
2936                 hit |= arghit
2937                 sargs.append(arg)
2938 
2939             if hit:
2940                 expr = expr.func(*sargs)
2941 
2942         if hasattr(expr, hint):
2943             newexpr = getattr(expr, hint)(**hints)
2944             if newexpr != expr:
2945                 return (newexpr, True)
2946 
2947         return (expr, hit)
2948 
2949     @cacheit
2950     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
2951             mul=True, log=True, multinomial=True, basic=True, **hints):
2952         """
2953         Expand an expression using hints.
2954 
2955         See the docstring of the expand() function in sympy.core.function for
2956         more information.
2957 
2958         """
2959         from sympy.simplify.radsimp import fraction
2960 
2961         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
2962            log=log, multinomial=multinomial, basic=basic)
2963 
2964         expr = self
2965         if hints.pop('frac', False):
2966             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
2967                     for a in fraction(self)]
2968             return n/d
2969         elif hints.pop('denom', False):
2970             n, d = fraction(self)
2971             return n/d.expand(deep=deep, modulus=modulus, **hints)
2972         elif hints.pop('numer', False):
2973             n, d = fraction(self)
2974             return n.expand(deep=deep, modulus=modulus, **hints)/d
2975 
2976         # Although the hints are sorted here, an earlier hint may get applied
2977         # at a given node in the expression tree before another because of how
2978         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
2979         # x*z) because while applying log at the top level, log and mul are
2980         # applied at the deeper level in the tree so that when the log at the
2981         # upper level gets applied, the mul has already been applied at the
2982         # lower level.
2983 
2984         # Additionally, because hints are only applied once, the expression
2985         # may not be expanded all the way.   For example, if mul is applied
2986         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
2987         # now, we just use a special case to make multinomial run before mul,
2988         # so that at least polynomials will be expanded all the way.  In the
2989         # future, smarter heuristics should be applied.
2990         # TODO: Smarter heuristics
2991 
2992         def _expand_hint_key(hint):
2993             """Make multinomial come before mul"""
2994             if hint == 'mul':
2995                 return 'mulz'
2996             return hint
2997 
2998         for hint in sorted(hints.keys(), key=_expand_hint_key):
2999             use_hint = hints[hint]
3000             if use_hint:
3001                 hint = '_eval_expand_' + hint
3002                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3003 
3004         while True:
3005             was = expr
3006             if hints.get('multinomial', False):
3007                 expr, _ = Expr._expand_hint(
3008                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3009             if hints.get('mul', False):
3010                 expr, _ = Expr._expand_hint(
3011                     expr, '_eval_expand_mul', deep=deep, **hints)
3012             if hints.get('log', False):
3013                 expr, _ = Expr._expand_hint(
3014                     expr, '_eval_expand_log', deep=deep, **hints)
3015             if expr == was:
3016                 break
3017 
3018         if modulus is not None:
3019             modulus = sympify(modulus)
3020 
3021             if not modulus.is_Integer or modulus <= 0:
3022                 raise ValueError(
3023                     "modulus must be a positive integer, got %s" % modulus)
3024 
3025             terms = []
3026 
3027             for term in Add.make_args(expr):
3028                 coeff, tail = term.as_coeff_Mul(rational=True)
3029 
3030                 coeff %= modulus
3031 
3032                 if coeff:
3033                     terms.append(coeff*tail)
3034 
3035             expr = Add(*terms)
3036 
3037         return expr
3038 
3039     ###########################################################################
3040     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3041     ###########################################################################
3042 
3043     def integrate(self, *args, **kwargs):
3044         """See the integrate function in sympy.integrals"""
3045         from sympy.integrals import integrate
3046         return integrate(self, *args, **kwargs)
3047 
3048     def simplify(self, ratio=1.7, measure=None):
3049         """See the simplify function in sympy.simplify"""
3050         from sympy.simplify import simplify
3051         from sympy.core.function import count_ops
3052         measure = measure or count_ops
3053         return simplify(self, ratio, measure)
3054 
3055     def nsimplify(self, constants=[], tolerance=None, full=False):
3056         """See the nsimplify function in sympy.simplify"""
3057         from sympy.simplify import nsimplify
3058         return nsimplify(self, constants, tolerance, full)
3059 
3060     def separate(self, deep=False, force=False):
3061         """See the separate function in sympy.simplify"""
3062         from sympy.core.function import expand_power_base
3063         return expand_power_base(self, deep=deep, force=force)
3064 
3065     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3066         """See the collect function in sympy.simplify"""
3067         from sympy.simplify import collect
3068         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3069 
3070     def together(self, *args, **kwargs):
3071         """See the together function in sympy.polys"""
3072         from sympy.polys import together
3073         return together(self, *args, **kwargs)
3074 
3075     def apart(self, x=None, **args):
3076         """See the apart function in sympy.polys"""
3077         from sympy.polys import apart
3078         return apart(self, x, **args)
3079 
3080     def ratsimp(self):
3081         """See the ratsimp function in sympy.simplify"""
3082         from sympy.simplify import ratsimp
3083         return ratsimp(self)
3084 
3085     def trigsimp(self, **args):
3086         """See the trigsimp function in sympy.simplify"""
3087         from sympy.simplify import trigsimp
3088         return trigsimp(self, **args)
3089 
3090     def radsimp(self, **kwargs):
3091         """See the radsimp function in sympy.simplify"""
3092         from sympy.simplify import radsimp
3093         return radsimp(self, **kwargs)
3094 
3095     def powsimp(self, *args, **kwargs):
3096         """See the powsimp function in sympy.simplify"""
3097         from sympy.simplify import powsimp
3098         return powsimp(self, *args, **kwargs)
3099 
3100     def combsimp(self):
3101         """See the combsimp function in sympy.simplify"""
3102         from sympy.simplify import combsimp
3103         return combsimp(self)
3104 
3105     def factor(self, *gens, **args):
3106         """See the factor() function in sympy.polys.polytools"""
3107         from sympy.polys import factor
3108         return factor(self, *gens, **args)
3109 
3110     def refine(self, assumption=True):
3111         """See the refine function in sympy.assumptions"""
3112         from sympy.assumptions import refine
3113         return refine(self, assumption)
3114 
3115     def cancel(self, *gens, **args):
3116         """See the cancel function in sympy.polys"""
3117         from sympy.polys import cancel
3118         return cancel(self, *gens, **args)
3119 
3120     def invert(self, g, *gens, **args):
3121         """Return the multiplicative inverse of ``self`` mod ``g``
3122         where ``self`` (and ``g``) may be symbolic expressions).
3123 
3124         See Also
3125         ========
3126         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3127         """
3128         from sympy.polys.polytools import invert
3129         from sympy.core.numbers import mod_inverse
3130         if self.is_number and getattr(g, 'is_number', True):
3131             return mod_inverse(self, g)
3132         return invert(self, g, *gens, **args)
3133 
3134     def round(self, p=0):
3135         """Return x rounded to the given decimal place.
3136 
3137         If a complex number would results, apply round to the real
3138         and imaginary components of the number.
3139 
3140         Examples
3141         ========
3142 
3143         >>> from sympy import pi, E, I, S, Add, Mul, Number
3144         >>> S(10.5).round()
3145         11.
3146         >>> pi.round()
3147         3.
3148         >>> pi.round(2)
3149         3.14
3150         >>> (2*pi + E*I).round()
3151         6. + 3.*I
3152 
3153         The round method has a chopping effect:
3154 
3155         >>> (2*pi + I/10).round()
3156         6.
3157         >>> (pi/10 + 2*I).round()
3158         2.*I
3159         >>> (pi/10 + E*I).round(2)
3160         0.31 + 2.72*I
3161 
3162         Notes
3163         =====
3164 
3165         Do not confuse the Python builtin function, round, with the
3166         SymPy method of the same name. The former always returns a float
3167         (or raises an error if applied to a complex value) while the
3168         latter returns either a Number or a complex number:
3169 
3170         >>> isinstance(round(S(123), -2), Number)
3171         False
3172         >>> isinstance(S(123).round(-2), Number)
3173         True
3174         >>> isinstance((3*I).round(), Mul)
3175         True
3176         >>> isinstance((1 + 3*I).round(), Add)
3177         True
3178 
3179         """
3180         from sympy import Float
3181         x = self
3182         if not x.is_number:
3183             raise TypeError("can't round symbolic expression")
3184         if not x.is_Atom:
3185             xn = x.n(2)
3186             if not pure_complex(xn, or_real=True):
3187                 raise TypeError('Expected a number but got %s:' %
3188                     getattr(getattr(x,'func', x), '__name__', type(x)))
3189         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3190             return x
3191         if not x.is_real:
3192             i, r = x.as_real_imag()
3193             return i.round(p) + S.ImaginaryUnit*r.round(p)
3194         if not x:
3195             return x
3196         p = int(p)
3197 
3198         precs = [f._prec for f in x.atoms(Float)]
3199         dps = prec_to_dps(max(precs)) if precs else None
3200 
3201         mag_first_dig = _mag(x)
3202         allow = digits_needed = mag_first_dig + p
3203         if dps is not None and allow > dps:
3204             allow = dps
3205         mag = Pow(10, p)  # magnitude needed to bring digit p to units place
3206         xwas = x
3207         x += 1/(2*mag)  # add the half for rounding
3208         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3209         if i10.is_negative:
3210             x = xwas - 1/(2*mag)  # should have gone the other way
3211             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)
3212             rv = -(Integer(-i10)//10)
3213         else:
3214             rv = Integer(i10)//10
3215         q = 1
3216         if p > 0:
3217             q = mag
3218         elif p < 0:
3219             rv /= mag
3220         rv = Rational(rv, q)
3221         if rv.is_Integer:
3222             # use str or else it won't be a float
3223             return Float(str(rv), digits_needed)
3224         else:
3225             if not allow and rv > self:
3226                 allow += 1
3227             return Float(rv, allow)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/core/mul.py</file>
<class>Mul</class>
<method>None</method>
<code>
90 class Mul(Expr, AssocOp):
91 
92     __slots__ = []
93 
94     is_Mul = True
95 
96     @classmethod
97     def flatten(cls, seq):
98         """Return commutative, noncommutative and order arguments by
99         combining related terms.
100 
101         Notes
102         =====
103             * In an expression like ``a*b*c``, python process this through sympy
104               as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.
105 
106               -  Sometimes terms are not combined as one would like:
107                  {c.f. https://github.com/sympy/sympy/issues/4596}
108 
109                 >>> from sympy import Mul, sqrt
110                 >>> from sympy.abc import x, y, z
111                 >>> 2*(x + 1) # this is the 2-arg Mul behavior
112                 2*x + 2
113                 >>> y*(x + 1)*2
114                 2*y*(x + 1)
115                 >>> 2*(x + 1)*y # 2-arg result will be obtained first
116                 y*(2*x + 2)
117                 >>> Mul(2, x + 1, y) # all 3 args simultaneously processed
118                 2*y*(x + 1)
119                 >>> 2*((x + 1)*y) # parentheses can control this behavior
120                 2*y*(x + 1)
121 
122                 Powers with compound bases may not find a single base to
123                 combine with unless all arguments are processed at once.
124                 Post-processing may be necessary in such cases.
125                 {c.f. https://github.com/sympy/sympy/issues/5728}
126 
127                 >>> a = sqrt(x*sqrt(y))
128                 >>> a**3
129                 (x*sqrt(y))**(3/2)
130                 >>> Mul(a,a,a)
131                 (x*sqrt(y))**(3/2)
132                 >>> a*a*a
133                 x*sqrt(y)*sqrt(x*sqrt(y))
134                 >>> _.subs(a.base, z).subs(z, a.base)
135                 (x*sqrt(y))**(3/2)
136 
137               -  If more than two terms are being multiplied then all the
138                  previous terms will be re-processed for each new argument.
139                  So if each of ``a``, ``b`` and ``c`` were :class:`Mul`
140                  expression, then ``a*b*c`` (or building up the product
141                  with ``*=``) will process all the arguments of ``a`` and
142                  ``b`` twice: once when ``a*b`` is computed and again when
143                  ``c`` is multiplied.
144 
145                  Using ``Mul(a, b, c)`` will process all arguments once.
146 
147             * The results of Mul are cached according to arguments, so flatten
148               will only be called once for ``Mul(a, b, c)``. If you can
149               structure a calculation so the arguments are most likely to be
150               repeats then this can save time in computing the answer. For
151               example, say you had a Mul, M, that you wished to divide by ``d[i]``
152               and multiply by ``n[i]`` and you suspect there are many repeats
153               in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather
154               than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the
155               product, ``M*n[i]`` will be returned without flattening -- the
156               cached value will be returned. If you divide by the ``d[i]``
157               first (and those are more unique than the ``n[i]``) then that will
158               create a new Mul, ``M/d[i]`` the args of which will be traversed
159               again when it is multiplied by ``n[i]``.
160 
161               {c.f. https://github.com/sympy/sympy/issues/5706}
162 
163               This consideration is moot if the cache is turned off.
164 
165             NB
166             --
167               The validity of the above notes depends on the implementation
168               details of Mul and flatten which may change at any time. Therefore,
169               you should only consider them when your code is highly performance
170               sensitive.
171 
172               Removal of 1 from the sequence is already handled by AssocOp.__new__.
173         """
174 
175         from sympy.calculus.util import AccumBounds
176         rv = None
177         if len(seq) == 2:
178             a, b = seq
179             if b.is_Rational:
180                 a, b = b, a
181             assert not a is S.One
182             if not a.is_zero and a.is_Rational:
183                 r, b = b.as_coeff_Mul()
184                 if b.is_Add:
185                     if r is not S.One:  # 2-arg hack
186                         # leave the Mul as a Mul
187                         rv = [cls(a*r, b, evaluate=False)], [], None
188                     elif b.is_commutative:
189                         if a is S.One:
190                             rv = [b], [], None
191                         else:
192                             r, b = b.as_coeff_Add()
193                             bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]
194                             _addsort(bargs)
195                             ar = a*r
196                             if ar:
197                                 bargs.insert(0, ar)
198                             bargs = [Add._from_args(bargs)]
199                             rv = bargs, [], None
200             if rv:
201                 return rv
202 
203         # apply associativity, separate commutative part of seq
204         c_part = []         # out: commutative factors
205         nc_part = []        # out: non-commutative factors
206 
207         nc_seq = []
208 
209         coeff = S.One       # standalone term
210                             # e.g. 3 * ...
211 
212         c_powers = []       # (base,exp)      n
213                             # e.g. (x,n) for x
214 
215         num_exp = []        # (num-base, exp)           y
216                             # e.g.  (3, y)  for  ... * 3  * ...
217 
218         neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I
219 
220         pnum_rat = {}       # (num-base, Rat-exp)          1/2
221                             # e.g.  (3, 1/2)  for  ... * 3     * ...
222 
223         order_symbols = None
224 
225         # --- PART 1 ---
226         #
227         # "collect powers and coeff":
228         #
229         # o coeff
230         # o c_powers
231         # o num_exp
232         # o neg1e
233         # o pnum_rat
234         #
235         # NOTE: this is optimized for all-objects-are-commutative case
236         for o in seq:
237             # O(x)
238             if o.is_Order:
239                 o, order_symbols = o.as_expr_variables(order_symbols)
240 
241             # Mul([...])
242             if o.is_Mul:
243                 if o.is_commutative:
244                     seq.extend(o.args)    # XXX zerocopy?
245 
246                 else:
247                     # NCMul can have commutative parts as well
248                     for q in o.args:
249                         if q.is_commutative:
250                             seq.append(q)
251                         else:
252                             nc_seq.append(q)
253 
254                     # append non-commutative marker, so we don't forget to
255                     # process scheduled non-commutative objects
256                     seq.append(NC_Marker)
257 
258                 continue
259 
260             # 3
261             elif o.is_Number:
262                 if o is S.NaN or coeff is S.ComplexInfinity and o is S.Zero:
263                     # we know for sure the result will be nan
264                     return [S.NaN], [], None
265                 elif coeff.is_Number:  # it could be zoo
266                     coeff *= o
267                     if coeff is S.NaN:
268                         # we know for sure the result will be nan
269                         return [S.NaN], [], None
270                 continue
271 
272             elif isinstance(o, AccumBounds):
273                 coeff = o.__mul__(coeff)
274                 continue
275 
276             elif o is S.ComplexInfinity:
277                 if not coeff:
278                     # 0 * zoo = NaN
279                     return [S.NaN], [], None
280                 if coeff is S.ComplexInfinity:
281                     # zoo * zoo = zoo
282                     return [S.ComplexInfinity], [], None
283                 coeff = S.ComplexInfinity
284                 continue
285 
286             elif o is S.ImaginaryUnit:
287                 neg1e += S.Half
288                 continue
289 
290             elif o.is_commutative:
291                 #      e
292                 # o = b
293                 b, e = o.as_base_exp()
294 
295                 #  y
296                 # 3
297                 if o.is_Pow:
298                     if b.is_Number:
299 
300                         # get all the factors with numeric base so they can be
301                         # combined below, but don't combine negatives unless
302                         # the exponent is an integer
303                         if e.is_Rational:
304                             if e.is_Integer:
305                                 coeff *= Pow(b, e)  # it is an unevaluated power
306                                 continue
307                             elif e.is_negative:    # also a sign of an unevaluated power
308                                 seq.append(Pow(b, e))
309                                 continue
310                             elif b.is_negative:
311                                 neg1e += e
312                                 b = -b
313                             if b is not S.One:
314                                 pnum_rat.setdefault(b, []).append(e)
315                             continue
316                         elif b.is_positive or e.is_integer:
317                             num_exp.append((b, e))
318                             continue
319 
320                     elif b is S.ImaginaryUnit and e.is_Rational:
321                         neg1e += e/2
322                         continue
323 
324                 c_powers.append((b, e))
325 
326             # NON-COMMUTATIVE
327             # TODO: Make non-commutative exponents not combine automatically
328             else:
329                 if o is not NC_Marker:
330                     nc_seq.append(o)
331 
332                 # process nc_seq (if any)
333                 while nc_seq:
334                     o = nc_seq.pop(0)
335                     if not nc_part:
336                         nc_part.append(o)
337                         continue
338 
339                     #                             b    c       b+c
340                     # try to combine last terms: a  * a   ->  a
341                     o1 = nc_part.pop()
342                     b1, e1 = o1.as_base_exp()
343                     b2, e2 = o.as_base_exp()
344                     new_exp = e1 + e2
345                     # Only allow powers to combine if the new exponent is
346                     # not an Add. This allow things like a**2*b**3 == a**5
347                     # if a.is_commutative == False, but prohibits
348                     # a**x*a**y and x**a*x**b from combining (x,y commute).
349                     if b1 == b2 and (not new_exp.is_Add):
350                         o12 = b1 ** new_exp
351 
352                         # now o12 could be a commutative object
353                         if o12.is_commutative:
354                             seq.append(o12)
355                             continue
356                         else:
357                             nc_seq.insert(0, o12)
358 
359                     else:
360                         nc_part.append(o1)
361                         nc_part.append(o)
362 
363         # We do want a combined exponent if it would not be an Add, such as
364         #  y    2y     3y
365         # x  * x   -> x
366         # We determine if two exponents have the same term by using
367         # as_coeff_Mul.
368         #
369         # Unfortunately, this isn't smart enough to consider combining into
370         # exponents that might already be adds, so things like:
371         #  z - y    y
372         # x      * x  will be left alone.  This is because checking every possible
373         # combination can slow things down.
374 
375         # gather exponents of common bases...
376         def _gather(c_powers):
377             common_b = {}  # b:e
378             for b, e in c_powers:
379                 co = e.as_coeff_Mul()
380                 common_b.setdefault(b, {}).setdefault(
381                     co[1], []).append(co[0])
382             for b, d in common_b.items():
383                 for di, li in d.items():
384                     d[di] = Add(*li)
385             new_c_powers = []
386             for b, e in common_b.items():
387                 new_c_powers.extend([(b, c*t) for t, c in e.items()])
388             return new_c_powers
389 
390         # in c_powers
391         c_powers = _gather(c_powers)
392 
393         # and in num_exp
394         num_exp = _gather(num_exp)
395 
396         # --- PART 2 ---
397         #
398         # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)
399         # o combine collected powers  (2**x * 3**x -> 6**x)
400         #   with numeric base
401 
402         # ................................
403         # now we have:
404         # - coeff:
405         # - c_powers:    (b, e)
406         # - num_exp:     (2, e)
407         # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}
408 
409         #  0             1
410         # x  -> 1       x  -> x
411 
412         # this should only need to run twice; if it fails because
413         # it needs to be run more times, perhaps this should be
414         # changed to a "while True" loop -- the only reason it
415         # isn't such now is to allow a less-than-perfect result to
416         # be obtained rather than raising an error or entering an
417         # infinite loop
418         for i in range(2):
419             new_c_powers = []
420             changed = False
421             for b, e in c_powers:
422                 if e.is_zero:
423                     continue
424                 if e is S.One:
425                     if b.is_Number:
426                         coeff *= b
427                         continue
428                     p = b
429                 if e is not S.One:
430                     p = Pow(b, e)
431                     # check to make sure that the base doesn't change
432                     # after exponentiation; to allow for unevaluated
433                     # Pow, we only do so if b is not already a Pow
434                     if p.is_Pow and not b.is_Pow:
435                         bi = b
436                         b, e = p.as_base_exp()
437                         if b != bi:
438                             changed = True
439                 c_part.append(p)
440                 new_c_powers.append((b, e))
441             # there might have been a change, but unless the base
442             # matches some other base, there is nothing to do
443             if changed and len(set(
444                     b for b, e in new_c_powers)) != len(new_c_powers):
445                 # start over again
446                 c_part = []
447                 c_powers = _gather(new_c_powers)
448             else:
449                 break
450 
451         #  x    x     x
452         # 2  * 3  -> 6
453         inv_exp_dict = {}   # exp:Mul(num-bases)     x    x
454                             # e.g.  x:6  for  ... * 2  * 3  * ...
455         for b, e in num_exp:
456             inv_exp_dict.setdefault(e, []).append(b)
457         for e, b in inv_exp_dict.items():
458             inv_exp_dict[e] = cls(*b)
459         c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])
460 
461         # b, e -> e' = sum(e), b
462         # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}
463         comb_e = {}
464         for b, e in pnum_rat.items():
465             comb_e.setdefault(Add(*e), []).append(b)
466         del pnum_rat
467         # process them, reducing exponents to values less than 1
468         # and updating coeff if necessary else adding them to
469         # num_rat for further processing
470         num_rat = []
471         for e, b in comb_e.items():
472             b = cls(*b)
473             if e.q == 1:
474                 coeff *= Pow(b, e)
475                 continue
476             if e.p > e.q:
477                 e_i, ep = divmod(e.p, e.q)
478                 coeff *= Pow(b, e_i)
479                 e = Rational(ep, e.q)
480             num_rat.append((b, e))
481         del comb_e
482 
483         # extract gcd of bases in num_rat
484         # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)
485         pnew = defaultdict(list)
486         i = 0  # steps through num_rat which may grow
487         while i < len(num_rat):
488             bi, ei = num_rat[i]
489             grow = []
490             for j in range(i + 1, len(num_rat)):
491                 bj, ej = num_rat[j]
492                 g = bi.gcd(bj)
493                 if g is not S.One:
494                     # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2
495                     # this might have a gcd with something else
496                     e = ei + ej
497                     if e.q == 1:
498                         coeff *= Pow(g, e)
499                     else:
500                         if e.p > e.q:
501                             e_i, ep = divmod(e.p, e.q)  # change e in place
502                             coeff *= Pow(g, e_i)
503                             e = Rational(ep, e.q)
504                         grow.append((g, e))
505                     # update the jth item
506                     num_rat[j] = (bj/g, ej)
507                     # update bi that we are checking with
508                     bi = bi/g
509                     if bi is S.One:
510                         break
511             if bi is not S.One:
512                 obj = Pow(bi, ei)
513                 if obj.is_Number:
514                     coeff *= obj
515                 else:
516                     # changes like sqrt(12) -> 2*sqrt(3)
517                     for obj in Mul.make_args(obj):
518                         if obj.is_Number:
519                             coeff *= obj
520                         else:
521                             assert obj.is_Pow
522                             bi, ei = obj.args
523                             pnew[ei].append(bi)
524 
525             num_rat.extend(grow)
526             i += 1
527 
528         # combine bases of the new powers
529         for e, b in pnew.items():
530             pnew[e] = cls(*b)
531 
532         # handle -1 and I
533         if neg1e:
534             # treat I as (-1)**(1/2) and compute -1's total exponent
535             p, q =  neg1e.as_numer_denom()
536             # if the integer part is odd, extract -1
537             n, p = divmod(p, q)
538             if n % 2:
539                 coeff = -coeff
540             # if it's a multiple of 1/2 extract I
541             if q == 2:
542                 c_part.append(S.ImaginaryUnit)
543             elif p:
544                 # see if there is any positive base this power of
545                 # -1 can join
546                 neg1e = Rational(p, q)
547                 for e, b in pnew.items():
548                     if e == neg1e and b.is_positive:
549                         pnew[e] = -b
550                         break
551                 else:
552                     # keep it separate; we've already evaluated it as
553                     # much as possible so evaluate=False
554                     c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))
555 
556         # add all the pnew powers
557         c_part.extend([Pow(b, e) for e, b in pnew.items()])
558 
559         # oo, -oo
560         if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):
561             def _handle_for_oo(c_part, coeff_sign):
562                 new_c_part = []
563                 for t in c_part:
564                     if t.is_positive:
565                         continue
566                     if t.is_negative:
567                         coeff_sign *= -1
568                         continue
569                     new_c_part.append(t)
570                 return new_c_part, coeff_sign
571             c_part, coeff_sign = _handle_for_oo(c_part, 1)
572             nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)
573             coeff *= coeff_sign
574 
575         # zoo
576         if coeff is S.ComplexInfinity:
577             # zoo might be
578             #   infinite_real + bounded_im
579             #   bounded_real + infinite_im
580             #   infinite_real + infinite_im
581             # and non-zero real or imaginary will not change that status.
582             c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and
583                                                 c.is_real is not None)]
584             nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and
585                                                   c.is_real is not None)]
586 
587         # 0
588         elif coeff is S.Zero:
589             # we know for sure the result will be 0 except the multiplicand
590             # is infinity
591             if any(c.is_finite == False for c in c_part):
592                 return [S.NaN], [], order_symbols
593             return [coeff], [], order_symbols
594 
595         # check for straggling Numbers that were produced
596         _new = []
597         for i in c_part:
598             if i.is_Number:
599                 coeff *= i
600             else:
601                 _new.append(i)
602         c_part = _new
603 
604         # order commutative part canonically
605         _mulsort(c_part)
606 
607         # current code expects coeff to be always in slot-0
608         if coeff is not S.One:
609             c_part.insert(0, coeff)
610 
611         # we are done
612         if (not nc_part and len(c_part) == 2 and c_part[0].is_Number and
613                 c_part[1].is_Add):
614             # 2*(1+a) -> 2 + 2 * a
615             coeff = c_part[0]
616             c_part = [Add(*[coeff*f for f in c_part[1].args])]
617 
618         return c_part, nc_part, order_symbols
619 
620     def _eval_power(b, e):
621 
622         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
623         cargs, nc = b.args_cnc(split_1=False)
624 
625         if e.is_Integer:
626             return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \
627                 Pow(Mul._from_args(nc), e, evaluate=False)
628 
629         p = Pow(b, e, evaluate=False)
630 
631         if e.is_Rational or e.is_Float:
632             return p._eval_expand_power_base()
633 
634         return p
635 
636     @classmethod
637     def class_key(cls):
638         return 3, 0, cls.__name__
639 
640     def _eval_evalf(self, prec):
641         c, m = self.as_coeff_Mul()
642         if c is S.NegativeOne:
643             if m.is_Mul:
644                 rv = -AssocOp._eval_evalf(m, prec)
645             else:
646                 mnew = m._eval_evalf(prec)
647                 if mnew is not None:
648                     m = mnew
649                 rv = -m
650         else:
651             rv = AssocOp._eval_evalf(self, prec)
652         if rv.is_number:
653             return rv.expand()
654         return rv
655 
656     @property
657     def _mpc_(self):
658         """
659         Convert self to an mpmath mpc if possible
660         """
661         from sympy.core.numbers import I, Float
662         im_part, imag_unit = self.as_coeff_Mul()
663         if not imag_unit == I:
664             # ValueError may seem more reasonable but since it's a @property,
665             # we need to use AttributeError to keep from confusing things like
666             # hasattr.
667             raise AttributeError("Cannot convert Mul to mpc. Must be of the form Number*I")
668 
669         return (Float(0)._mpf_, Float(im_part)._mpf_)
670 
671     @cacheit
672     def as_two_terms(self):
673         """Return head and tail of self.
674 
675         This is the most efficient way to get the head and tail of an
676         expression.
677 
678         - if you want only the head, use self.args[0];
679         - if you want to process the arguments of the tail then use
680           self.as_coef_mul() which gives the head and a tuple containing
681           the arguments of the tail when treated as a Mul.
682         - if you want the coefficient when self is treated as an Add
683           then use self.as_coeff_add()[0]
684 
685         >>> from sympy.abc import x, y
686         >>> (3*x*y).as_two_terms()
687         (3, x*y)
688         """
689         args = self.args
690 
691         if len(args) == 1:
692             return S.One, self
693         elif len(args) == 2:
694             return args
695 
696         else:
697             return args[0], self._new_rawargs(*args[1:])
698 
699     @cacheit
700     def as_coefficients_dict(self):
701         """Return a dictionary mapping terms to their coefficient.
702         Since the dictionary is a defaultdict, inquiries about terms which
703         were not present will return a coefficient of 0. The dictionary
704         is considered to have a single term.
705 
706         Examples
707         ========
708 
709         >>> from sympy.abc import a, x
710         >>> (3*a*x).as_coefficients_dict()
711         {a*x: 3}
712         >>> _[a]
713         0
714         """
715 
716         d = defaultdict(int)
717         args = self.args
718 
719         if len(args) == 1 or not args[0].is_Number:
720             d[self] = S.One
721         else:
722             d[self._new_rawargs(*args[1:])] = args[0]
723 
724         return d
725 
726     @cacheit
727     def as_coeff_mul(self, *deps, **kwargs):
728         rational = kwargs.pop('rational', True)
729         if deps:
730             l1 = []
731             l2 = []
732             for f in self.args:
733                 if f.has(*deps):
734                     l2.append(f)
735                 else:
736                     l1.append(f)
737             return self._new_rawargs(*l1), tuple(l2)
738         args = self.args
739         if args[0].is_Number:
740             if not rational or args[0].is_Rational:
741                 return args[0], args[1:]
742             elif args[0].is_negative:
743                 return S.NegativeOne, (-args[0],) + args[1:]
744         return S.One, args
745 
746     def as_coeff_Mul(self, rational=False):
747         """Efficiently extract the coefficient of a product. """
748         coeff, args = self.args[0], self.args[1:]
749 
750         if coeff.is_Number:
751             if not rational or coeff.is_Rational:
752                 if len(args) == 1:
753                     return coeff, args[0]
754                 else:
755                     return coeff, self._new_rawargs(*args)
756             elif coeff.is_negative:
757                 return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))
758         return S.One, self
759 
760     def as_real_imag(self, deep=True, **hints):
761         from sympy import Abs, expand_mul, im, re
762         other = []
763         coeffr = []
764         coeffi = []
765         addterms = S.One
766         for a in self.args:
767             if a.is_real:
768                 coeffr.append(a)
769             elif a.is_imaginary:
770                 coeffi.append(a)
771             elif a.is_commutative:
772                 # search for complex conjugate pairs:
773                 for i, x in enumerate(other):
774                     if x == a.conjugate():
775                         coeffr.append(Abs(x)**2)
776                         del other[i]
777                         break
778                 else:
779                     if a.is_Add:
780                         addterms *= a
781                     else:
782                         other.append(a)
783             else:
784                 other.append(a)
785         m = self.func(*other)
786         if hints.get('ignore') == m:
787             return
788         if len(coeffi) % 2:
789             imco = im(coeffi.pop(0))
790             # all other pairs make a real factor; they will be
791             # put into reco below
792         else:
793             imco = S.Zero
794         reco = self.func(*(coeffr + coeffi))
795         r, i = (reco*re(m), reco*im(m))
796         if addterms == 1:
797             if m == 1:
798                 if imco is S.Zero:
799                     return (reco, S.Zero)
800                 else:
801                     return (S.Zero, reco*imco)
802             if imco is S.Zero:
803                 return (r, i)
804             return (-imco*i, imco*r)
805         addre, addim = expand_mul(addterms, deep=False).as_real_imag()
806         if imco is S.Zero:
807             return (r*addre - i*addim, i*addre + r*addim)
808         else:
809             r, i = -imco*i, imco*r
810             return (r*addre - i*addim, r*addim + i*addre)
811 
812     @staticmethod
813     def _expandsums(sums):
814         """
815         Helper function for _eval_expand_mul.
816 
817         sums must be a list of instances of Basic.
818         """
819 
820         L = len(sums)
821         if L == 1:
822             return sums[0].args
823         terms = []
824         left = Mul._expandsums(sums[:L//2])
825         right = Mul._expandsums(sums[L//2:])
826 
827         terms = [Mul(a, b) for a in left for b in right]
828         added = Add(*terms)
829         return Add.make_args(added)  # it may have collapsed down to one term
830 
831     def _eval_expand_mul(self, **hints):
832         from sympy import fraction
833 
834         # Handle things like 1/(x*(x + 1)), which are automatically converted
835         # to 1/x*1/(x + 1)
836         expr = self
837         n, d = fraction(expr)
838         if d.is_Mul:
839             n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i
840                 for i in (n, d)]
841             expr = n/d
842             if not expr.is_Mul:
843                 return expr
844 
845         plain, sums, rewrite = [], [], False
846         for factor in expr.args:
847             if factor.is_Add:
848                 sums.append(factor)
849                 rewrite = True
850             else:
851                 if factor.is_commutative:
852                     plain.append(factor)
853                 else:
854                     sums.append(Basic(factor))  # Wrapper
855 
856         if not rewrite:
857             return expr
858         else:
859             plain = self.func(*plain)
860             if sums:
861                 terms = self.func._expandsums(sums)
862                 args = []
863                 for term in terms:
864                     t = self.func(plain, term)
865                     if t.is_Mul and any(a.is_Add for a in t.args):
866                         t = t._eval_expand_mul()
867                     args.append(t)
868                 return Add(*args)
869             else:
870                 return plain
871 
872     @cacheit
873     def _eval_derivative(self, s):
874         args = list(self.args)
875         terms = []
876         for i in range(len(args)):
877             d = args[i].diff(s)
878             if d:
879                 terms.append(self.func(*(args[:i] + [d] + args[i + 1:])))
880         return Add(*terms)
881 
882     def _eval_difference_delta(self, n, step):
883         from sympy.series.limitseq import difference_delta as dd
884         arg0 = self.args[0]
885         rest = Mul(*self.args[1:])
886         return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *
887                 rest)
888 
889     def _matches_simple(self, expr, repl_dict):
890         # handle (w*3).matches('x*5') -> {w: x*5/3}
891         coeff, terms = self.as_coeff_Mul()
892         terms = Mul.make_args(terms)
893         if len(terms) == 1:
894             newexpr = self.__class__._combine_inverse(expr, coeff)
895             return terms[0].matches(newexpr, repl_dict)
896         return
897 
898     def matches(self, expr, repl_dict={}, old=False):
899         expr = sympify(expr)
900         if self.is_commutative and expr.is_commutative:
901             return AssocOp._matches_commutative(self, expr, repl_dict, old)
902         elif self.is_commutative is not expr.is_commutative:
903             return None
904         c1, nc1 = self.args_cnc()
905         c2, nc2 = expr.args_cnc()
906         repl_dict = repl_dict.copy()
907         if c1:
908             if not c2:
909                 c2 = [1]
910             a = self.func(*c1)
911             if isinstance(a, AssocOp):
912                 repl_dict = a._matches_commutative(self.func(*c2), repl_dict, old)
913             else:
914                 repl_dict = a.matches(self.func(*c2), repl_dict)
915         if repl_dict:
916             a = self.func(*nc1)
917             if isinstance(a, self.func):
918                 repl_dict = a._matches(self.func(*nc2), repl_dict)
919             else:
920                 repl_dict = a.matches(self.func(*nc2), repl_dict)
921         return repl_dict or None
922 
923     def _matches(self, expr, repl_dict={}):
924         # weed out negative one prefixes#
925         from sympy import Wild
926         sign = 1
927         a, b = self.as_two_terms()
928         if a is S.NegativeOne:
929             if b.is_Mul:
930                 sign = -sign
931             else:
932                 # the remainder, b, is not a Mul anymore
933                 return b.matches(-expr, repl_dict)
934         expr = sympify(expr)
935         if expr.is_Mul and expr.args[0] is S.NegativeOne:
936             expr = -expr
937             sign = -sign
938 
939         if not expr.is_Mul:
940             # expr can only match if it matches b and a matches +/- 1
941             if len(self.args) == 2:
942                 # quickly test for equality
943                 if b == expr:
944                     return a.matches(Rational(sign), repl_dict)
945                 # do more expensive match
946                 dd = b.matches(expr, repl_dict)
947                 if dd is None:
948                     return None
949                 dd = a.matches(Rational(sign), dd)
950                 return dd
951             return None
952 
953         d = repl_dict.copy()
954 
955         # weed out identical terms
956         pp = list(self.args)
957         ee = list(expr.args)
958         for p in self.args:
959             if p in expr.args:
960                 ee.remove(p)
961                 pp.remove(p)
962 
963         # only one symbol left in pattern -> match the remaining expression
964         if len(pp) == 1 and isinstance(pp[0], Wild):
965             if len(ee) == 1:
966                 d[pp[0]] = sign * ee[0]
967             else:
968                 d[pp[0]] = sign * expr.func(*ee)
969             return d
970 
971         if len(ee) != len(pp):
972             return None
973 
974         for p, e in zip(pp, ee):
975             d = p.xreplace(d).matches(e, d)
976             if d is None:
977                 return None
978         return d
979 
980     @staticmethod
981     def _combine_inverse(lhs, rhs):
982         """
983         Returns lhs/rhs, but treats arguments like symbols, so things like
984         oo/oo return 1, instead of a nan.
985         """
986         if lhs == rhs:
987             return S.One
988 
989         def check(l, r):
990             if l.is_Float and r.is_comparable:
991                 # if both objects are added to 0 they will share the same "normalization"
992                 # and are more likely to compare the same. Since Add(foo, 0) will not allow
993                 # the 0 to pass, we use __add__ directly.
994                 return l.__add__(0) == r.evalf().__add__(0)
995             return False
996         if check(lhs, rhs) or check(rhs, lhs):
997             return S.One
998         if lhs.is_Mul and rhs.is_Mul:
999             a = list(lhs.args)
1000             b = [1]
1001             for x in rhs.args:
1002                 if x in a:
1003                     a.remove(x)
1004                 elif -x in a:
1005                     a.remove(-x)
1006                     b.append(-1)
1007                 else:
1008                     b.append(x)
1009             return lhs.func(*a)/rhs.func(*b)
1010         return lhs/rhs
1011 
1012     def as_powers_dict(self):
1013         d = defaultdict(int)
1014         for term in self.args:
1015             b, e = term.as_base_exp()
1016             d[b] += e
1017         return d
1018 
1019     def as_numer_denom(self):
1020         # don't use _from_args to rebuild the numerators and denominators
1021         # as the order is not guaranteed to be the same once they have
1022         # been separated from each other
1023         numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))
1024         return self.func(*numers), self.func(*denoms)
1025 
1026     def as_base_exp(self):
1027         e1 = None
1028         bases = []
1029         nc = 0
1030         for m in self.args:
1031             b, e = m.as_base_exp()
1032             if not b.is_commutative:
1033                 nc += 1
1034             if e1 is None:
1035                 e1 = e
1036             elif e != e1 or nc > 1:
1037                 return self, S.One
1038             bases.append(b)
1039         return self.func(*bases), e1
1040 
1041     def _eval_is_polynomial(self, syms):
1042         return all(term._eval_is_polynomial(syms) for term in self.args)
1043 
1044     def _eval_is_rational_function(self, syms):
1045         return all(term._eval_is_rational_function(syms) for term in self.args)
1046 
1047     def _eval_is_algebraic_expr(self, syms):
1048         return all(term._eval_is_algebraic_expr(syms) for term in self.args)
1049 
1050     _eval_is_finite = lambda self: _fuzzy_group(
1051         a.is_finite for a in self.args)
1052     _eval_is_commutative = lambda self: _fuzzy_group(
1053         a.is_commutative for a in self.args)
1054     _eval_is_complex = lambda self: _fuzzy_group(
1055         (a.is_complex for a in self.args), quick_exit=True)
1056 
1057     def _eval_is_infinite(self):
1058         if any(a.is_infinite for a in self.args):
1059             if any(a.is_zero for a in self.args):
1060                 return S.NaN.is_infinite
1061             if any(a.is_zero is None for a in self.args):
1062                 return None
1063             return True
1064 
1065     def _eval_is_rational(self):
1066         r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)
1067         if r:
1068             return r
1069         elif r is False:
1070             return self.is_zero
1071 
1072     def _eval_is_algebraic(self):
1073         r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)
1074         if r:
1075             return r
1076         elif r is False:
1077             return self.is_zero
1078 
1079     def _eval_is_zero(self):
1080         zero = infinite = False
1081         for a in self.args:
1082             z = a.is_zero
1083             if z:
1084                 if infinite:
1085                     return  # 0*oo is nan and nan.is_zero is None
1086                 zero = True
1087             else:
1088                 if not a.is_finite:
1089                     if zero:
1090                         return  # 0*oo is nan and nan.is_zero is None
1091                     infinite = True
1092                 if zero is False and z is None:  # trap None
1093                     zero = None
1094         return zero
1095 
1096     def _eval_is_integer(self):
1097         is_rational = self.is_rational
1098 
1099         if is_rational:
1100             n, d = self.as_numer_denom()
1101             if d is S.One:
1102                 return True
1103             elif d is S(2):
1104                 return n.is_even
1105         elif is_rational is False:
1106             return False
1107 
1108     def _eval_is_polar(self):
1109         has_polar = any(arg.is_polar for arg in self.args)
1110         return has_polar and \
1111             all(arg.is_polar or arg.is_positive for arg in self.args)
1112 
1113     def _eval_is_real(self):
1114         return self._eval_real_imag(True)
1115 
1116     def _eval_real_imag(self, real):
1117         zero = one_neither = False
1118 
1119         for t in self.args:
1120             if not t.is_complex:
1121                 return t.is_complex
1122             elif t.is_imaginary:
1123                 real = not real
1124             elif t.is_real:
1125                 if not zero:
1126                     z = t.is_zero
1127                     if not z and zero is False:
1128                         zero = z
1129                     elif z:
1130                         if all(a.is_finite for a in self.args):
1131                             return True
1132                         return
1133             elif t.is_real is False:
1134                 if one_neither:
1135                     return  # complex terms might cancel
1136                 one_neither = True
1137             else:
1138                 return
1139 
1140         if one_neither:  # self is a+I*b or I*b
1141             if real:
1142                 return zero  # real*self is like self: neither is real
1143         elif zero is False:
1144             return real  # can't be trumped by 0
1145         elif real:
1146             return real  # doesn't matter what zero is
1147 
1148     def _eval_is_imaginary(self):
1149         z = self.is_zero
1150         if z:
1151             return False
1152         elif z is False:
1153             return self._eval_real_imag(False)
1154 
1155     def _eval_is_hermitian(self):
1156         return self._eval_herm_antiherm(True)
1157 
1158     def _eval_herm_antiherm(self, real):
1159         one_nc = zero = one_neither = False
1160 
1161         for t in self.args:
1162             if not t.is_commutative:
1163                 if one_nc:
1164                     return
1165                 one_nc = True
1166 
1167             if t.is_antihermitian:
1168                 real = not real
1169             elif t.is_hermitian:
1170                 if not zero:
1171                     z = t.is_zero
1172                     if not z and zero is False:
1173                         zero = z
1174                     elif z:
1175                         if all(a.is_finite for a in self.args):
1176                             return True
1177                         return
1178             elif t.is_hermitian is False:
1179                 if one_neither:
1180                     return
1181                 one_neither = True
1182             else:
1183                 return
1184 
1185         if one_neither:
1186             if real:
1187                 return zero
1188         elif zero is False or real:
1189             return real
1190 
1191     def _eval_is_antihermitian(self):
1192         z = self.is_zero
1193         if z:
1194             return False
1195         elif z is False:
1196             return self._eval_herm_antiherm(False)
1197 
1198     def _eval_is_irrational(self):
1199         for t in self.args:
1200             a = t.is_irrational
1201             if a:
1202                 others = list(self.args)
1203                 others.remove(t)
1204                 if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):
1205                     return True
1206                 return
1207             if a is None:
1208                 return
1209         return False
1210 
1211     def _eval_is_positive(self):
1212         """Return True if self is positive, False if not, and None if it
1213         cannot be determined.
1214 
1215         This algorithm is non-recursive and works by keeping track of the
1216         sign which changes when a negative or nonpositive is encountered.
1217         Whether a nonpositive or nonnegative is seen is also tracked since
1218         the presence of these makes it impossible to return True, but
1219         possible to return False if the end result is nonpositive. e.g.
1220 
1221             pos * neg * nonpositive -> pos or zero -> None is returned
1222             pos * neg * nonnegative -> neg or zero -> False is returned
1223         """
1224         return self._eval_pos_neg(1)
1225 
1226     def _eval_pos_neg(self, sign):
1227         saw_NON = saw_NOT = False
1228         for t in self.args:
1229             if t.is_positive:
1230                 continue
1231             elif t.is_negative:
1232                 sign = -sign
1233             elif t.is_zero:
1234                 if all(a.is_finite for a in self.args):
1235                     return False
1236                 return
1237             elif t.is_nonpositive:
1238                 sign = -sign
1239                 saw_NON = True
1240             elif t.is_nonnegative:
1241                 saw_NON = True
1242             elif t.is_positive is False:
1243                 sign = -sign
1244                 if saw_NOT:
1245                     return
1246                 saw_NOT = True
1247             elif t.is_negative is False:
1248                 if saw_NOT:
1249                     return
1250                 saw_NOT = True
1251             else:
1252                 return
1253         if sign == 1 and saw_NON is False and saw_NOT is False:
1254             return True
1255         if sign < 0:
1256             return False
1257 
1258     def _eval_is_negative(self):
1259         if self.args[0] == -1:
1260             return (-self).is_positive  # remove -1
1261         return self._eval_pos_neg(-1)
1262 
1263     def _eval_is_odd(self):
1264         is_integer = self.is_integer
1265 
1266         if is_integer:
1267             r, acc = True, 1
1268             for t in self.args:
1269                 if not t.is_integer:
1270                     return None
1271                 elif t.is_even:
1272                     r = False
1273                 elif t.is_integer:
1274                     if r is False:
1275                         pass
1276                     elif acc != 1 and (acc + t).is_odd:
1277                         r = False
1278                     elif t.is_odd is None:
1279                         r = None
1280                 acc = t
1281             return r
1282 
1283         # !integer -> !odd
1284         elif is_integer is False:
1285             return False
1286 
1287     def _eval_is_even(self):
1288         is_integer = self.is_integer
1289 
1290         if is_integer:
1291             return fuzzy_not(self.is_odd)
1292 
1293         elif is_integer is False:
1294             return False
1295 
1296     def _eval_is_prime(self):
1297         """
1298         If product is a positive integer, multiplication
1299         will never result in a prime number.
1300         """
1301         if self.is_number:
1302             """
1303             If input is a number that is not completely simplified.
1304             e.g. Mul(sqrt(3), sqrt(3), evaluate=False)
1305             So we manually evaluate it and return whether that is prime or not.
1306             """
1307             # Note: `doit()` was not used due to test failing (Infinite Recursion)
1308             r = S.One
1309             for arg in self.args:
1310                 r *= arg
1311             return r.is_prime
1312 
1313         if self.is_integer and self.is_positive:
1314             """
1315             Here we count the number of arguments that have a minimum value
1316             greater than two.
1317             If there are more than one of such a symbol then the result is not prime.
1318             Else, the result cannot be determined.
1319             """
1320             number_of_args = 0 # count of symbols with minimum value greater than one
1321             for arg in self.args:
1322                 if (arg-1).is_positive:
1323                     number_of_args += 1
1324 
1325             if number_of_args > 1:
1326                 return False
1327 
1328     def _eval_subs(self, old, new):
1329         from sympy.functions.elementary.complexes import sign
1330         from sympy.ntheory.factor_ import multiplicity
1331         from sympy.simplify.powsimp import powdenest
1332         from sympy.simplify.radsimp import fraction
1333 
1334         if not old.is_Mul:
1335             return None
1336 
1337         # try keep replacement literal so -2*x doesn't replace 4*x
1338         if old.args[0].is_Number and old.args[0] < 0:
1339             if self.args[0].is_Number:
1340                 if self.args[0] < 0:
1341                     return self._subs(-old, -new)
1342                 return None
1343 
1344         def base_exp(a):
1345             # if I and -1 are in a Mul, they get both end up with
1346             # a -1 base (see issue 6421); all we want here are the
1347             # true Pow or exp separated into base and exponent
1348             from sympy import exp
1349             if a.is_Pow or a.func is exp:
1350                 return a.as_base_exp()
1351             return a, S.One
1352 
1353         def breakup(eq):
1354             """break up powers of eq when treated as a Mul:
1355                    b**(Rational*e) -> b**e, Rational
1356                 commutatives come back as a dictionary {b**e: Rational}
1357                 noncommutatives come back as a list [(b**e, Rational)]
1358             """
1359 
1360             (c, nc) = (defaultdict(int), list())
1361             for a in Mul.make_args(eq):
1362                 a = powdenest(a)
1363                 (b, e) = base_exp(a)
1364                 if e is not S.One:
1365                     (co, _) = e.as_coeff_mul()
1366                     b = Pow(b, e/co)
1367                     e = co
1368                 if a.is_commutative:
1369                     c[b] += e
1370                 else:
1371                     nc.append([b, e])
1372             return (c, nc)
1373 
1374         def rejoin(b, co):
1375             """
1376             Put rational back with exponent; in general this is not ok, but
1377             since we took it from the exponent for analysis, it's ok to put
1378             it back.
1379             """
1380 
1381             (b, e) = base_exp(b)
1382             return Pow(b, e*co)
1383 
1384         def ndiv(a, b):
1385             """if b divides a in an extractive way (like 1/4 divides 1/2
1386             but not vice versa, and 2/5 does not divide 1/3) then return
1387             the integer number of times it divides, else return 0.
1388             """
1389             if not b.q % a.q or not a.q % b.q:
1390                 return int(a/b)
1391             return 0
1392 
1393         # give Muls in the denominator a chance to be changed (see issue 5651)
1394         # rv will be the default return value
1395         rv = None
1396         n, d = fraction(self)
1397         self2 = self
1398         if d is not S.One:
1399             self2 = n._subs(old, new)/d._subs(old, new)
1400             if not self2.is_Mul:
1401                 return self2._subs(old, new)
1402             if self2 != self:
1403                 rv = self2
1404 
1405         # Now continue with regular substitution.
1406 
1407         # handle the leading coefficient and use it to decide if anything
1408         # should even be started; we always know where to find the Rational
1409         # so it's a quick test
1410 
1411         co_self = self2.args[0]
1412         co_old = old.args[0]
1413         co_xmul = None
1414         if co_old.is_Rational and co_self.is_Rational:
1415             # if coeffs are the same there will be no updating to do
1416             # below after breakup() step; so skip (and keep co_xmul=None)
1417             if co_old != co_self:
1418                 co_xmul = co_self.extract_multiplicatively(co_old)
1419         elif co_old.is_Rational:
1420             return rv
1421 
1422         # break self and old into factors
1423 
1424         (c, nc) = breakup(self2)
1425         (old_c, old_nc) = breakup(old)
1426 
1427         # update the coefficients if we had an extraction
1428         # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5
1429         # then co_self in c is replaced by (3/5)**2 and co_residual
1430         # is 2*(1/7)**2
1431 
1432         if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:
1433             mult = S(multiplicity(abs(co_old), co_self))
1434             c.pop(co_self)
1435             if co_old in c:
1436                 c[co_old] += mult
1437             else:
1438                 c[co_old] = mult
1439             co_residual = co_self/co_old**mult
1440         else:
1441             co_residual = 1
1442 
1443         # do quick tests to see if we can't succeed
1444 
1445         ok = True
1446         if len(old_nc) > len(nc):
1447             # more non-commutative terms
1448             ok = False
1449         elif len(old_c) > len(c):
1450             # more commutative terms
1451             ok = False
1452         elif set(i[0] for i in old_nc).difference(set(i[0] for i in nc)):
1453             # unmatched non-commutative bases
1454             ok = False
1455         elif set(old_c).difference(set(c)):
1456             # unmatched commutative terms
1457             ok = False
1458         elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):
1459             # differences in sign
1460             ok = False
1461         if not ok:
1462             return rv
1463 
1464         if not old_c:
1465             cdid = None
1466         else:
1467             rat = []
1468             for (b, old_e) in old_c.items():
1469                 c_e = c[b]
1470                 rat.append(ndiv(c_e, old_e))
1471                 if not rat[-1]:
1472                     return rv
1473             cdid = min(rat)
1474 
1475         if not old_nc:
1476             ncdid = None
1477             for i in range(len(nc)):
1478                 nc[i] = rejoin(*nc[i])
1479         else:
1480             ncdid = 0  # number of nc replacements we did
1481             take = len(old_nc)  # how much to look at each time
1482             limit = cdid or S.Infinity  # max number that we can take
1483             failed = []  # failed terms will need subs if other terms pass
1484             i = 0
1485             while limit and i + take <= len(nc):
1486                 hit = False
1487 
1488                 # the bases must be equivalent in succession, and
1489                 # the powers must be extractively compatible on the
1490                 # first and last factor but equal inbetween.
1491 
1492                 rat = []
1493                 for j in range(take):
1494                     if nc[i + j][0] != old_nc[j][0]:
1495                         break
1496                     elif j == 0:
1497                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1498                     elif j == take - 1:
1499                         rat.append(ndiv(nc[i + j][1], old_nc[j][1]))
1500                     elif nc[i + j][1] != old_nc[j][1]:
1501                         break
1502                     else:
1503                         rat.append(1)
1504                     j += 1
1505                 else:
1506                     ndo = min(rat)
1507                     if ndo:
1508                         if take == 1:
1509                             if cdid:
1510                                 ndo = min(cdid, ndo)
1511                             nc[i] = Pow(new, ndo)*rejoin(nc[i][0],
1512                                     nc[i][1] - ndo*old_nc[0][1])
1513                         else:
1514                             ndo = 1
1515 
1516                             # the left residual
1517 
1518                             l = rejoin(nc[i][0], nc[i][1] - ndo*
1519                                     old_nc[0][1])
1520 
1521                             # eliminate all middle terms
1522 
1523                             mid = new
1524 
1525                             # the right residual (which may be the same as the middle if take == 2)
1526 
1527                             ir = i + take - 1
1528                             r = (nc[ir][0], nc[ir][1] - ndo*
1529                                  old_nc[-1][1])
1530                             if r[1]:
1531                                 if i + take < len(nc):
1532                                     nc[i:i + take] = [l*mid, r]
1533                                 else:
1534                                     r = rejoin(*r)
1535                                     nc[i:i + take] = [l*mid*r]
1536                             else:
1537 
1538                                 # there was nothing left on the right
1539 
1540                                 nc[i:i + take] = [l*mid]
1541 
1542                         limit -= ndo
1543                         ncdid += ndo
1544                         hit = True
1545                 if not hit:
1546 
1547                     # do the subs on this failing factor
1548 
1549                     failed.append(i)
1550                 i += 1
1551             else:
1552 
1553                 if not ncdid:
1554                     return rv
1555 
1556                 # although we didn't fail, certain nc terms may have
1557                 # failed so we rebuild them after attempting a partial
1558                 # subs on them
1559 
1560                 failed.extend(range(i, len(nc)))
1561                 for i in failed:
1562                     nc[i] = rejoin(*nc[i]).subs(old, new)
1563 
1564         # rebuild the expression
1565 
1566         if cdid is None:
1567             do = ncdid
1568         elif ncdid is None:
1569             do = cdid
1570         else:
1571             do = min(ncdid, cdid)
1572 
1573         margs = []
1574         for b in c:
1575             if b in old_c:
1576 
1577                 # calculate the new exponent
1578 
1579                 e = c[b] - old_c[b]*do
1580                 margs.append(rejoin(b, e))
1581             else:
1582                 margs.append(rejoin(b.subs(old, new), c[b]))
1583         if cdid and not ncdid:
1584 
1585             # in case we are replacing commutative with non-commutative,
1586             # we want the new term to come at the front just like the
1587             # rest of this routine
1588 
1589             margs = [Pow(new, cdid)] + margs
1590         return co_residual*self2.func(*margs)*self2.func(*nc)
1591 
1592     def _eval_nseries(self, x, n, logx):
1593         from sympy import Order, powsimp
1594         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
1595         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
1596         if res.has(Order):
1597             res += Order(x**n, x)
1598         return res
1599 
1600     def _eval_as_leading_term(self, x):
1601         return self.func(*[t.as_leading_term(x) for t in self.args])
1602 
1603     def _eval_conjugate(self):
1604         return self.func(*[t.conjugate() for t in self.args])
1605 
1606     def _eval_transpose(self):
1607         return self.func(*[t.transpose() for t in self.args[::-1]])
1608 
1609     def _eval_adjoint(self):
1610         return self.func(*[t.adjoint() for t in self.args[::-1]])
1611 
1612     def _sage_(self):
1613         s = 1
1614         for x in self.args:
1615             s *= x._sage_()
1616         return s
1617 
1618     def as_content_primitive(self, radical=False, clear=True):
1619         """Return the tuple (R, self/R) where R is the positive Rational
1620         extracted from self.
1621 
1622         Examples
1623         ========
1624 
1625         >>> from sympy import sqrt
1626         >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()
1627         (6, -sqrt(2)*(-sqrt(2) + 1))
1628 
1629         See docstring of Expr.as_content_primitive for more examples.
1630         """
1631 
1632         coef = S.One
1633         args = []
1634         for i, a in enumerate(self.args):
1635             c, p = a.as_content_primitive(radical=radical, clear=clear)
1636             coef *= c
1637             if p is not S.One:
1638                 args.append(p)
1639         # don't use self._from_args here to reconstruct args
1640         # since there may be identical args now that should be combined
1641         # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))
1642         return coef, self.func(*args)
1643 
1644     def as_ordered_factors(self, order=None):
1645         """Transform an expression into an ordered list of factors.
1646 
1647         Examples
1648         ========
1649 
1650         >>> from sympy import sin, cos
1651         >>> from sympy.abc import x, y
1652 
1653         >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()
1654         [2, x, y, sin(x), cos(x)]
1655 
1656         """
1657         cpart, ncpart = self.args_cnc()
1658         cpart.sort(key=lambda expr: expr.sort_key(order=order))
1659         return cpart + ncpart
1660 
1661     @property
1662     def _sorted_args(self):
1663         return tuple(self.as_ordered_factors())

</code><intended_behavior>Though not directly implicated by a specific method in the bug report, the way Mul objects are created with evaluate=False and their interaction with methods like extract_multiplicatively suggests that there might be an underlying issue in either how Mul objects represent their arguments or in a helper method that extract_multiplicatively relies on (such as primitive or another method called within extract_multiplicatively). An analysis should be conducted on methods within Mul that are involved in the creation and simplification of these expressions to ensure they correctly handle negative values and expressions in non-evaluated form. This might involve ensuring that the primitive method (when called on results of Mul with evaluate=False) returns a form that is correctly interpreted by extract_multiplicatively, or adjusting how these Mul objects represent their arguments in a way that simplifies correctly when division is attempted.</intended_behavior>]
2025-10-16 01:42:37.455 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-16 01:42:37.455 | INFO     | Search-only: skipping patch selection
2025-10-16 01:42:37.529 | INFO     | Task sympy__sympy-12270 completed successfully.
2025-10-16 01:42:37.530 | INFO     | No patch generated. You can try running ACR again.
