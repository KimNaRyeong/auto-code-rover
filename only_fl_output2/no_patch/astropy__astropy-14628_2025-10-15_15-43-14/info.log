2025-10-15 15:43:15.176 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 15:43:18.377 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=13, cost=0.005070
2025-10-15 15:43:18.378 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-15 15:43:18.381 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:43:22.525 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=777, output_tokens=144, cost=0.012090
2025-10-15 15:43:22.532 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:43:24.905 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=498, output_tokens=30, cost=0.005880
2025-10-15 15:43:24.906 | DEBUG    | Extracted a valid json.
2025-10-15 15:43:24.907 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"EarthLocation\")", "search_method(\"get_itrs\")"],
    "bug_locations": []
}
2025-10-15 15:43:24.943 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 15:43:24.944 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 15:43:39.609 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2207, output_tokens=568, cost=0.039110
2025-10-15 15:43:39.621 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 15:43:46.651 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2991, output_tokens=211, cost=0.036240
2025-10-15 15:43:46.656 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 15:43:54.686 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=565, output_tokens=233, cost=0.012640
2025-10-15 15:43:54.688 | DEBUG    | Extracted a valid json.
2025-10-15 15:43:54.688 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/coordinates/earth.py",
            "class": "EarthLocation",
            "method": "get_itrs",
            "intended_behavior": "Modify the `get_itrs` method to accept an optional `location` argument that allows for the computation of topocentric ITRS positions relative to the provided `location`. This `location` could be another `EarthLocation` instance. When a `location` is provided, calculate the difference between the coordinates of the `EarthLocation` instance the method is called on and the `location` provided. This difference should be used to return a topocentric ITRS frame. If no `location` is provided, the method should continue to operate as it currently does, returning the geocentric position of the `EarthLocation` instance in the ITRS frame. This enhancement will require adjustments to the method's logic to incorporate the calculation of the differential position when a `location` is provided and to ensure that the existing functionality remains unaffected when no `location` is specified."
        }
    ]
}
2025-10-15 15:43:54.695 | DEBUG    | Bug location extracted successfully: [<file>astropy/coordinates/earth.py</file>
<class>EarthLocation</class>
<method>get_itrs</method>
<code>
658     def get_itrs(self, obstime=None):
659         """
660         Generates an `~astropy.coordinates.ITRS` object with the location of
661         this object at the requested ``obstime``.
662 
663         Parameters
664         ----------
665         obstime : `~astropy.time.Time` or None
666             The ``obstime`` to apply to the new `~astropy.coordinates.ITRS`, or
667             if None, the default ``obstime`` will be used.
668 
669         Returns
670         -------
671         itrs : `~astropy.coordinates.ITRS`
672             The new object in the ITRS frame
673         """
674         # Broadcast for a single position at multiple times, but don't attempt
675         # to be more general here.
676         if obstime and self.size == 1 and obstime.shape:
677             self = np.broadcast_to(self, obstime.shape, subok=True)
678 
679         # do this here to prevent a series of complicated circular imports
680         from .builtin_frames import ITRS
681 
682         return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)

</code><intended_behavior>Modify the `get_itrs` method to accept an optional `location` argument that allows for the computation of topocentric ITRS positions relative to the provided `location`. This `location` could be another `EarthLocation` instance. When a `location` is provided, calculate the difference between the coordinates of the `EarthLocation` instance the method is called on and the `location` provided. This difference should be used to return a topocentric ITRS frame. If no `location` is provided, the method should continue to operate as it currently does, returning the geocentric position of the `EarthLocation` instance in the ITRS frame. This enhancement will require adjustments to the method's logic to incorporate the calculation of the differential position when a `location` is provided and to ensure that the existing functionality remains unaffected when no `location` is specified.</intended_behavior>, <file>astropy/coordinates/earth.py</file>
<class>EarthLocation</class>
<method>None</method>
<code>
177 class EarthLocation(u.Quantity):
178     """
179     Location on the Earth.
180 
181     Initialization is first attempted assuming geocentric (x, y, z) coordinates
182     are given; if that fails, another attempt is made assuming geodetic
183     coordinates (longitude, latitude, height above a reference ellipsoid).
184     When using the geodetic forms, Longitudes are measured increasing to the
185     east, so west longitudes are negative. Internally, the coordinates are
186     stored as geocentric.
187 
188     To ensure a specific type of coordinates is used, use the corresponding
189     class methods (`from_geocentric` and `from_geodetic`) or initialize the
190     arguments with names (``x``, ``y``, ``z`` for geocentric; ``lon``, ``lat``,
191     ``height`` for geodetic).  See the class methods for details.
192 
193 
194     Notes
195     -----
196     This class fits into the coordinates transformation framework in that it
197     encodes a position on the `~astropy.coordinates.ITRS` frame.  To get a
198     proper `~astropy.coordinates.ITRS` object from this object, use the ``itrs``
199     property.
200     """
201 
202     _ellipsoid = "WGS84"
203     _location_dtype = np.dtype({"names": ["x", "y", "z"], "formats": [np.float64] * 3})
204     _array_dtype = np.dtype((np.float64, (3,)))
205     _site_registry = None
206 
207     info = EarthLocationInfo()
208 
209     def __new__(cls, *args, **kwargs):
210         # TODO: needs copy argument and better dealing with inputs.
211         if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], EarthLocation):
212             return args[0].copy()
213         try:
214             self = cls.from_geocentric(*args, **kwargs)
215         except (u.UnitsError, TypeError) as exc_geocentric:
216             try:
217                 self = cls.from_geodetic(*args, **kwargs)
218             except Exception as exc_geodetic:
219                 raise TypeError(
220                     "Coordinates could not be parsed as either "
221                     "geocentric or geodetic, with respective "
222                     f'exceptions "{exc_geocentric}" and "{exc_geodetic}"'
223                 )
224         return self
225 
226     @classmethod
227     def from_geocentric(cls, x, y, z, unit=None):
228         """
229         Location on Earth, initialized from geocentric coordinates.
230 
231         Parameters
232         ----------
233         x, y, z : `~astropy.units.Quantity` or array-like
234             Cartesian coordinates.  If not quantities, ``unit`` should be given.
235         unit : unit-like or None
236             Physical unit of the coordinate values.  If ``x``, ``y``, and/or
237             ``z`` are quantities, they will be converted to this unit.
238 
239         Raises
240         ------
241         astropy.units.UnitsError
242             If the units on ``x``, ``y``, and ``z`` do not match or an invalid
243             unit is given.
244         ValueError
245             If the shapes of ``x``, ``y``, and ``z`` do not match.
246         TypeError
247             If ``x`` is not a `~astropy.units.Quantity` and no unit is given.
248         """
249         if unit is None:
250             try:
251                 unit = x.unit
252             except AttributeError:
253                 raise TypeError(
254                     "Geocentric coordinates should be Quantities "
255                     "unless an explicit unit is given."
256                 ) from None
257         else:
258             unit = u.Unit(unit)
259 
260         if unit.physical_type != "length":
261             raise u.UnitsError("Geocentric coordinates should be in units of length.")
262 
263         try:
264             x = u.Quantity(x, unit, copy=False)
265             y = u.Quantity(y, unit, copy=False)
266             z = u.Quantity(z, unit, copy=False)
267         except u.UnitsError:
268             raise u.UnitsError("Geocentric coordinate units should all be consistent.")
269 
270         x, y, z = np.broadcast_arrays(x, y, z)
271         struc = np.empty(x.shape, cls._location_dtype)
272         struc["x"], struc["y"], struc["z"] = x, y, z
273         return super().__new__(cls, struc, unit, copy=False)
274 
275     @classmethod
276     def from_geodetic(cls, lon, lat, height=0.0, ellipsoid=None):
277         """
278         Location on Earth, initialized from geodetic coordinates.
279 
280         Parameters
281         ----------
282         lon : `~astropy.coordinates.Longitude` or float
283             Earth East longitude.  Can be anything that initialises an
284             `~astropy.coordinates.Angle` object (if float, in degrees).
285         lat : `~astropy.coordinates.Latitude` or float
286             Earth latitude.  Can be anything that initialises an
287             `~astropy.coordinates.Latitude` object (if float, in degrees).
288         height : `~astropy.units.Quantity` ['length'] or float, optional
289             Height above reference ellipsoid (if float, in meters; default: 0).
290         ellipsoid : str, optional
291             Name of the reference ellipsoid to use (default: 'WGS84').
292             Available ellipsoids are:  'WGS84', 'GRS80', 'WGS72'.
293 
294         Raises
295         ------
296         astropy.units.UnitsError
297             If the units on ``lon`` and ``lat`` are inconsistent with angular
298             ones, or that on ``height`` with a length.
299         ValueError
300             If ``lon``, ``lat``, and ``height`` do not have the same shape, or
301             if ``ellipsoid`` is not recognized as among the ones implemented.
302 
303         Notes
304         -----
305         For the conversion to geocentric coordinates, the ERFA routine
306         ``gd2gc`` is used.  See https://github.com/liberfa/erfa
307         """
308         ellipsoid = _check_ellipsoid(ellipsoid, default=cls._ellipsoid)
309         # As wrapping fails on readonly input, we do so manually
310         lon = Angle(lon, u.degree, copy=False).wrap_at(180 * u.degree)
311         lat = Latitude(lat, u.degree, copy=False)
312         # don't convert to m by default, so we can use the height unit below.
313         if not isinstance(height, u.Quantity):
314             height = u.Quantity(height, u.m, copy=False)
315         # get geocentric coordinates.
316         geodetic = ELLIPSOIDS[ellipsoid](lon, lat, height, copy=False)
317         xyz = geodetic.to_cartesian().get_xyz(xyz_axis=-1) << height.unit
318         self = xyz.view(cls._location_dtype, cls).reshape(geodetic.shape)
319         self._ellipsoid = ellipsoid
320         return self
321 
322     @classmethod
323     def of_site(cls, site_name, *, refresh_cache=False):
324         """
325         Return an object of this class for a known observatory/site by name.
326 
327         This is intended as a quick convenience function to get basic site
328         information, not a fully-featured exhaustive registry of observatories
329         and all their properties.
330 
331         Additional information about the site is stored in the ``.info.meta``
332         dictionary of sites obtained using this method (see the examples below).
333 
334         .. note::
335             This function is meant to access the site registry from the astropy
336             data server, which is saved in the user's local cache.  If you would
337             like a site to be added there, issue a pull request to the
338             `astropy-data repository <https://github.com/astropy/astropy-data>`_ .
339             If the cache already exists the function will use it even if the
340             version in the astropy-data repository has been updated unless the
341             ``refresh_cache=True`` option is used.  If there is no cache and the
342             online version cannot be reached, this function falls back on a
343             built-in list, which currently only contains the Greenwich Royal
344             Observatory as an example case.
345 
346         Parameters
347         ----------
348         site_name : str
349             Name of the observatory (case-insensitive).
350         refresh_cache : bool, optional
351             If `True`, force replacement of the cached registry with a
352             newly downloaded version.  (Default: `False`)
353 
354             .. versionadded:: 5.3
355 
356         Returns
357         -------
358         site : `~astropy.coordinates.EarthLocation` (or subclass) instance
359             The location of the observatory. The returned class will be the same
360             as this class.
361 
362         Examples
363         --------
364         >>> from astropy.coordinates import EarthLocation
365         >>> keck = EarthLocation.of_site('Keck Observatory')  # doctest: +REMOTE_DATA
366         >>> keck.geodetic  # doctest: +REMOTE_DATA +FLOAT_CMP
367         GeodeticLocation(lon=<Longitude -155.47833333 deg>, lat=<Latitude 19.82833333 deg>, height=<Quantity 4160. m>)
368         >>> keck.info  # doctest: +REMOTE_DATA
369         name = W. M. Keck Observatory
370         dtype = (float64, float64, float64)
371         unit = m
372         class = EarthLocation
373         n_bad = 0
374         >>> keck.info.meta  # doctest: +REMOTE_DATA
375         {'source': 'IRAF Observatory Database', 'timezone': 'US/Hawaii'}
376 
377         See Also
378         --------
379         get_site_names : the list of sites that this function can access
380         """
381         registry = cls._get_site_registry(force_download=refresh_cache)
382         try:
383             el = registry[site_name]
384         except UnknownSiteException as e:
385             raise UnknownSiteException(
386                 e.site, "EarthLocation.get_site_names", close_names=e.close_names
387             ) from e
388 
389         if cls is el.__class__:
390             return el
391         else:
392             newel = cls.from_geodetic(*el.to_geodetic())
393             newel.info.name = el.info.name
394             return newel
395 
396     @classmethod
397     def of_address(cls, address, get_height=False, google_api_key=None):
398         """
399         Return an object of this class for a given address by querying either
400         the OpenStreetMap Nominatim tool [1]_ (default) or the Google geocoding
401         API [2]_, which requires a specified API key.
402 
403         This is intended as a quick convenience function to get easy access to
404         locations. If you need to specify a precise location, you should use the
405         initializer directly and pass in a longitude, latitude, and elevation.
406 
407         In the background, this just issues a web query to either of
408         the APIs noted above. This is not meant to be abused! Both
409         OpenStreetMap and Google use IP-based query limiting and will ban your
410         IP if you send more than a few thousand queries per hour [2]_.
411 
412         .. warning::
413             If the query returns more than one location (e.g., searching on
414             ``address='springfield'``), this function will use the **first**
415             returned location.
416 
417         Parameters
418         ----------
419         address : str
420             The address to get the location for. As per the Google maps API,
421             this can be a fully specified street address (e.g., 123 Main St.,
422             New York, NY) or a city name (e.g., Danbury, CT), or etc.
423         get_height : bool, optional
424             This only works when using the Google API! See the ``google_api_key``
425             block below. Use the retrieved location to perform a second query to
426             the Google maps elevation API to retrieve the height of the input
427             address [3]_.
428         google_api_key : str, optional
429             A Google API key with the Geocoding API and (optionally) the
430             elevation API enabled. See [4]_ for more information.
431 
432         Returns
433         -------
434         location : `~astropy.coordinates.EarthLocation` (or subclass) instance
435             The location of the input address.
436             Will be type(this class)
437 
438         References
439         ----------
440         .. [1] https://nominatim.openstreetmap.org/
441         .. [2] https://developers.google.com/maps/documentation/geocoding/start
442         .. [3] https://developers.google.com/maps/documentation/elevation/start
443         .. [4] https://developers.google.com/maps/documentation/geocoding/get-api-key
444 
445         """
446         use_google = google_api_key is not None
447 
448         # Fail fast if invalid options are passed:
449         if not use_google and get_height:
450             raise ValueError(
451                 "Currently, `get_height` only works when using the Google geocoding"
452                 " API, which requires passing a Google API key with `google_api_key`."
453                 " See:"
454                 " https://developers.google.com/maps/documentation/geocoding/get-api-key"
455                 " for information on obtaining an API key."
456             )
457 
458         if use_google:  # Google
459             pars = urllib.parse.urlencode({"address": address, "key": google_api_key})
460             geo_url = f"https://maps.googleapis.com/maps/api/geocode/json?{pars}"
461 
462         else:  # OpenStreetMap
463             pars = urllib.parse.urlencode({"q": address, "format": "json"})
464             geo_url = f"https://nominatim.openstreetmap.org/search?{pars}"
465 
466         # get longitude and latitude location
467         err_str = f"Unable to retrieve coordinates for address '{address}'; {{msg}}"
468         geo_result = _get_json_result(geo_url, err_str=err_str, use_google=use_google)
469 
470         if use_google:
471             loc = geo_result[0]["geometry"]["location"]
472             lat = loc["lat"]
473             lon = loc["lng"]
474 
475         else:
476             loc = geo_result[0]
477             lat = float(loc["lat"])  # strings are returned by OpenStreetMap
478             lon = float(loc["lon"])
479 
480         if get_height:
481             pars = {"locations": f"{lat:.8f},{lon:.8f}", "key": google_api_key}
482             pars = urllib.parse.urlencode(pars)
483             ele_url = f"https://maps.googleapis.com/maps/api/elevation/json?{pars}"
484 
485             err_str = f"Unable to retrieve elevation for address '{address}'; {{msg}}"
486             ele_result = _get_json_result(
487                 ele_url, err_str=err_str, use_google=use_google
488             )
489             height = ele_result[0]["elevation"] * u.meter
490 
491         else:
492             height = 0.0
493 
494         return cls.from_geodetic(lon=lon * u.deg, lat=lat * u.deg, height=height)
495 
496     @classmethod
497     def get_site_names(cls, *, refresh_cache=False):
498         """
499         Get list of names of observatories for use with
500         `~astropy.coordinates.EarthLocation.of_site`.
501 
502         .. note::
503             This function is meant to access the site registry from the astropy
504             data server, which is saved in the user's local cache.  If you would
505             like a site to be added there, issue a pull request to the
506             `astropy-data repository <https://github.com/astropy/astropy-data>`_ .
507             If the cache already exists the function will use it even if the
508             version in the astropy-data repository has been updated unless the
509             ``refresh_cache=True`` option is used.  If there is no cache and the
510             online version cannot be reached, this function falls back on a
511             built-in list, which currently only contains the Greenwich Royal
512             Observatory as an example case.
513 
514         Parameters
515         ----------
516         refresh_cache : bool, optional
517             If `True`, force replacement of the cached registry with a
518             newly downloaded version.  (Default: `False`)
519 
520             .. versionadded:: 5.3
521 
522         Returns
523         -------
524         names : list of str
525             List of valid observatory names
526 
527         See Also
528         --------
529         of_site : Gets the actual location object for one of the sites names
530             this returns.
531         """
532         return cls._get_site_registry(force_download=refresh_cache).names
533 
534     @classmethod
535     def _get_site_registry(cls, force_download=False, force_builtin=False):
536         """
537         Gets the site registry.  The first time this either downloads or loads
538         from the data file packaged with astropy.  Subsequent calls will use the
539         cached version unless explicitly overridden.
540 
541         Parameters
542         ----------
543         force_download : bool or str
544             If not False, force replacement of the cached registry with a
545             downloaded version. If a str, that will be used as the URL to
546             download from (if just True, the default URL will be used).
547         force_builtin : bool
548             If True, load from the data file bundled with astropy and set the
549             cache to that.
550 
551         Returns
552         -------
553         reg : astropy.coordinates.sites.SiteRegistry
554         """
555         # need to do this here at the bottom to avoid circular dependencies
556         from .sites import get_builtin_sites, get_downloaded_sites
557 
558         if force_builtin and force_download:
559             raise ValueError("Cannot have both force_builtin and force_download True")
560 
561         if force_builtin:
562             cls._site_registry = get_builtin_sites()
563         else:
564             if force_download or not cls._site_registry:
565                 try:
566                     if isinstance(force_download, str):
567                         cls._site_registry = get_downloaded_sites(force_download)
568                     else:
569                         cls._site_registry = get_downloaded_sites()
570                 except OSError:
571                     if force_download:
572                         raise
573                     msg = (
574                         "Could not access the main site list. Falling back on the "
575                         "built-in version, which is rather limited. If you want to "
576                         "retry the download, use the option 'refresh_cache=True'."
577                     )
578                     warn(msg, AstropyUserWarning)
579                     cls._site_registry = get_builtin_sites()
580         return cls._site_registry
581 
582     @property
583     def ellipsoid(self):
584         """The default ellipsoid used to convert to geodetic coordinates."""
585         return self._ellipsoid
586 
587     @ellipsoid.setter
588     def ellipsoid(self, ellipsoid):
589         self._ellipsoid = _check_ellipsoid(ellipsoid)
590 
591     @property
592     def geodetic(self):
593         """Convert to geodetic coordinates for the default ellipsoid."""
594         return self.to_geodetic()
595 
596     def to_geodetic(self, ellipsoid=None):
597         """Convert to geodetic coordinates.
598 
599         Parameters
600         ----------
601         ellipsoid : str, optional
602             Reference ellipsoid to use.  Default is the one the coordinates
603             were initialized with.  Available are: 'WGS84', 'GRS80', 'WGS72'
604 
605         Returns
606         -------
607         lon, lat, height : `~astropy.units.Quantity`
608             The tuple is a ``GeodeticLocation`` namedtuple and is comprised of
609             instances of `~astropy.coordinates.Longitude`,
610             `~astropy.coordinates.Latitude`, and `~astropy.units.Quantity`.
611 
612         Raises
613         ------
614         ValueError
615             if ``ellipsoid`` is not recognized as among the ones implemented.
616 
617         Notes
618         -----
619         For the conversion to geodetic coordinates, the ERFA routine
620         ``gc2gd`` is used.  See https://github.com/liberfa/erfa
621         """
622         ellipsoid = _check_ellipsoid(ellipsoid, default=self.ellipsoid)
623         xyz = self.view(self._array_dtype, u.Quantity)
624         llh = CartesianRepresentation(xyz, xyz_axis=-1, copy=False).represent_as(
625             ELLIPSOIDS[ellipsoid]
626         )
627         return GeodeticLocation(
628             Longitude(llh.lon, u.deg, wrap_angle=180 * u.deg, copy=False),
629             llh.lat << u.deg,
630             llh.height << self.unit,
631         )
632 
633     @property
634     def lon(self):
635         """Longitude of the location, for the default ellipsoid."""
636         return self.geodetic[0]
637 
638     @property
639     def lat(self):
640         """Latitude of the location, for the default ellipsoid."""
641         return self.geodetic[1]
642 
643     @property
644     def height(self):
645         """Height of the location, for the default ellipsoid."""
646         return self.geodetic[2]
647 
648     # mostly for symmetry with geodetic and to_geodetic.
649     @property
650     def geocentric(self):
651         """Convert to a tuple with X, Y, and Z as quantities."""
652         return self.to_geocentric()
653 
654     def to_geocentric(self):
655         """Convert to a tuple with X, Y, and Z as quantities."""
656         return (self.x, self.y, self.z)
657 
658     def get_itrs(self, obstime=None):
659         """
660         Generates an `~astropy.coordinates.ITRS` object with the location of
661         this object at the requested ``obstime``.
662 
663         Parameters
664         ----------
665         obstime : `~astropy.time.Time` or None
666             The ``obstime`` to apply to the new `~astropy.coordinates.ITRS`, or
667             if None, the default ``obstime`` will be used.
668 
669         Returns
670         -------
671         itrs : `~astropy.coordinates.ITRS`
672             The new object in the ITRS frame
673         """
674         # Broadcast for a single position at multiple times, but don't attempt
675         # to be more general here.
676         if obstime and self.size == 1 and obstime.shape:
677             self = np.broadcast_to(self, obstime.shape, subok=True)
678 
679         # do this here to prevent a series of complicated circular imports
680         from .builtin_frames import ITRS
681 
682         return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)
683 
684     itrs = property(
685         get_itrs,
686         doc="""An `~astropy.coordinates.ITRS` object
687                for the location of this object at the
688                default ``obstime``.""",
689     )
690 
691     def get_gcrs(self, obstime):
692         """GCRS position with velocity at ``obstime`` as a GCRS coordinate.
693 
694         Parameters
695         ----------
696         obstime : `~astropy.time.Time`
697             The ``obstime`` to calculate the GCRS position/velocity at.
698 
699         Returns
700         -------
701         gcrs : `~astropy.coordinates.GCRS` instance
702             With velocity included.
703         """
704         # do this here to prevent a series of complicated circular imports
705         from .builtin_frames import GCRS
706 
707         loc, vel = self.get_gcrs_posvel(obstime)
708         loc.differentials["s"] = CartesianDifferential.from_cartesian(vel)
709         return GCRS(loc, obstime=obstime)
710 
711     def _get_gcrs_posvel(self, obstime, ref_to_itrs, gcrs_to_ref):
712         """Calculate GCRS position and velocity given transformation matrices.
713 
714         The reference frame z axis must point to the Celestial Intermediate Pole
715         (as is the case for CIRS and TETE).
716 
717         This private method is used in intermediate_rotation_transforms,
718         where some of the matrices are already available for the coordinate
719         transformation.
720 
721         The method is faster by an order of magnitude than just adding a zero
722         velocity to ITRS and transforming to GCRS, because it avoids calculating
723         the velocity via finite differencing of the results of the transformation
724         at three separate times.
725         """
726         # The simplest route is to transform to the reference frame where the
727         # z axis is properly aligned with the Earth's rotation axis (CIRS or
728         # TETE), then calculate the velocity, and then transform this
729         # reference position and velocity to GCRS.  For speed, though, we
730         # transform the coordinates to GCRS in one step, and calculate the
731         # velocities by rotating around the earth's axis transformed to GCRS.
732         ref_to_gcrs = matrix_transpose(gcrs_to_ref)
733         itrs_to_gcrs = ref_to_gcrs @ matrix_transpose(ref_to_itrs)
734         # Earth's rotation vector in the ref frame is rot_vec_ref = (0,0,OMEGA_EARTH),
735         # so in GCRS it is rot_vec_gcrs[..., 2] @ OMEGA_EARTH.
736         rot_vec_gcrs = CartesianRepresentation(
737             ref_to_gcrs[..., 2] * OMEGA_EARTH, xyz_axis=-1, copy=False
738         )
739         # Get the position in the GCRS frame.
740         # Since we just need the cartesian representation of ITRS, avoid get_itrs().
741         itrs_cart = CartesianRepresentation(self.x, self.y, self.z, copy=False)
742         pos = itrs_cart.transform(itrs_to_gcrs)
743         vel = rot_vec_gcrs.cross(pos)
744         return pos, vel
745 
746     def get_gcrs_posvel(self, obstime):
747         """
748         Calculate the GCRS position and velocity of this object at the
749         requested ``obstime``.
750 
751         Parameters
752         ----------
753         obstime : `~astropy.time.Time`
754             The ``obstime`` to calculate the GCRS position/velocity at.
755 
756         Returns
757         -------
758         obsgeoloc : `~astropy.coordinates.CartesianRepresentation`
759             The GCRS position of the object
760         obsgeovel : `~astropy.coordinates.CartesianRepresentation`
761             The GCRS velocity of the object
762         """
763         # Local import to prevent circular imports.
764         from .builtin_frames.intermediate_rotation_transforms import (
765             cirs_to_itrs_mat,
766             gcrs_to_cirs_mat,
767         )
768 
769         # Get gcrs_posvel by transforming via CIRS (slightly faster than TETE).
770         return self._get_gcrs_posvel(
771             obstime, cirs_to_itrs_mat(obstime), gcrs_to_cirs_mat(obstime)
772         )
773 
774     def gravitational_redshift(
775         self, obstime, bodies=["sun", "jupiter", "moon"], masses={}
776     ):
777         """Return the gravitational redshift at this EarthLocation.
778 
779         Calculates the gravitational redshift, of order 3 m/s, due to the
780         requested solar system bodies.
781 
782         Parameters
783         ----------
784         obstime : `~astropy.time.Time`
785             The ``obstime`` to calculate the redshift at.
786 
787         bodies : iterable, optional
788             The bodies (other than the Earth) to include in the redshift
789             calculation.  List elements should be any body name
790             `get_body_barycentric` accepts.  Defaults to Jupiter, the Sun, and
791             the Moon.  Earth is always included (because the class represents
792             an *Earth* location).
793 
794         masses : dict[str, `~astropy.units.Quantity`], optional
795             The mass or gravitational parameters (G * mass) to assume for the
796             bodies requested in ``bodies``. Can be used to override the
797             defaults for the Sun, Jupiter, the Moon, and the Earth, or to
798             pass in masses for other bodies.
799 
800         Returns
801         -------
802         redshift : `~astropy.units.Quantity`
803             Gravitational redshift in velocity units at given obstime.
804         """
805         # needs to be here to avoid circular imports
806         from .solar_system import get_body_barycentric
807 
808         bodies = list(bodies)
809         # Ensure earth is included and last in the list.
810         if "earth" in bodies:
811             bodies.remove("earth")
812         bodies.append("earth")
813         _masses = {
814             "sun": consts.GM_sun,
815             "jupiter": consts.GM_jup,
816             "moon": consts.G * 7.34767309e22 * u.kg,
817             "earth": consts.GM_earth,
818         }
819         _masses.update(masses)
820         GMs = []
821         M_GM_equivalency = (u.kg, u.Unit(consts.G * u.kg))
822         for body in bodies:
823             try:
824                 GMs.append(_masses[body].to(u.m**3 / u.s**2, [M_GM_equivalency]))
825             except KeyError as err:
826                 raise KeyError(f'body "{body}" does not have a mass.') from err
827             except u.UnitsError as exc:
828                 exc.args += (
829                     (
830                         '"masses" argument values must be masses or '
831                         "gravitational parameters."
832                     ),
833                 )
834                 raise
835 
836         positions = [get_body_barycentric(name, obstime) for name in bodies]
837         # Calculate distances to objects other than earth.
838         distances = [(pos - positions[-1]).norm() for pos in positions[:-1]]
839         # Append distance from Earth's center for Earth's contribution.
840         distances.append(CartesianRepresentation(self.geocentric).norm())
841         # Get redshifts due to all objects.
842         redshifts = [
843             -GM / consts.c / distance for (GM, distance) in zip(GMs, distances)
844         ]
845         # Reverse order of summing, to go from small to big, and to get
846         # "earth" first, which gives m/s as unit.
847         return sum(redshifts[::-1])
848 
849     @property
850     def x(self):
851         """The X component of the geocentric coordinates."""
852         return self["x"]
853 
854     @property
855     def y(self):
856         """The Y component of the geocentric coordinates."""
857         return self["y"]
858 
859     @property
860     def z(self):
861         """The Z component of the geocentric coordinates."""
862         return self["z"]
863 
864     def __getitem__(self, item):
865         result = super().__getitem__(item)
866         if result.dtype is self.dtype:
867             return result.view(self.__class__)
868         else:
869             return result.view(u.Quantity)
870 
871     def __array_finalize__(self, obj):
872         super().__array_finalize__(obj)
873         if hasattr(obj, "_ellipsoid"):
874             self._ellipsoid = obj._ellipsoid
875 
876     def __len__(self):
877         if self.shape == ():
878             raise IndexError("0-d EarthLocation arrays cannot be indexed")
879         else:
880             return super().__len__()
881 
882     def _to_value(self, unit, equivalencies=[]):
883         """Helper method for to and to_value."""
884         # Conversion to another unit in both ``to`` and ``to_value`` goes
885         # via this routine. To make the regular quantity routines work, we
886         # temporarily turn the structured array into a regular one.
887         array_view = self.view(self._array_dtype, np.ndarray)
888         if equivalencies == []:
889             equivalencies = self._equivalencies
890         new_array = self.unit.to(unit, array_view, equivalencies=equivalencies)
891         return new_array.view(self.dtype).reshape(self.shape)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 15:43:54.695 | INFO     | Search completed. Bug locations: [<file>astropy/coordinates/earth.py</file>
<class>EarthLocation</class>
<method>get_itrs</method>
<code>
658     def get_itrs(self, obstime=None):
659         """
660         Generates an `~astropy.coordinates.ITRS` object with the location of
661         this object at the requested ``obstime``.
662 
663         Parameters
664         ----------
665         obstime : `~astropy.time.Time` or None
666             The ``obstime`` to apply to the new `~astropy.coordinates.ITRS`, or
667             if None, the default ``obstime`` will be used.
668 
669         Returns
670         -------
671         itrs : `~astropy.coordinates.ITRS`
672             The new object in the ITRS frame
673         """
674         # Broadcast for a single position at multiple times, but don't attempt
675         # to be more general here.
676         if obstime and self.size == 1 and obstime.shape:
677             self = np.broadcast_to(self, obstime.shape, subok=True)
678 
679         # do this here to prevent a series of complicated circular imports
680         from .builtin_frames import ITRS
681 
682         return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)

</code><intended_behavior>Modify the `get_itrs` method to accept an optional `location` argument that allows for the computation of topocentric ITRS positions relative to the provided `location`. This `location` could be another `EarthLocation` instance. When a `location` is provided, calculate the difference between the coordinates of the `EarthLocation` instance the method is called on and the `location` provided. This difference should be used to return a topocentric ITRS frame. If no `location` is provided, the method should continue to operate as it currently does, returning the geocentric position of the `EarthLocation` instance in the ITRS frame. This enhancement will require adjustments to the method's logic to incorporate the calculation of the differential position when a `location` is provided and to ensure that the existing functionality remains unaffected when no `location` is specified.</intended_behavior>, <file>astropy/coordinates/earth.py</file>
<class>EarthLocation</class>
<method>None</method>
<code>
177 class EarthLocation(u.Quantity):
178     """
179     Location on the Earth.
180 
181     Initialization is first attempted assuming geocentric (x, y, z) coordinates
182     are given; if that fails, another attempt is made assuming geodetic
183     coordinates (longitude, latitude, height above a reference ellipsoid).
184     When using the geodetic forms, Longitudes are measured increasing to the
185     east, so west longitudes are negative. Internally, the coordinates are
186     stored as geocentric.
187 
188     To ensure a specific type of coordinates is used, use the corresponding
189     class methods (`from_geocentric` and `from_geodetic`) or initialize the
190     arguments with names (``x``, ``y``, ``z`` for geocentric; ``lon``, ``lat``,
191     ``height`` for geodetic).  See the class methods for details.
192 
193 
194     Notes
195     -----
196     This class fits into the coordinates transformation framework in that it
197     encodes a position on the `~astropy.coordinates.ITRS` frame.  To get a
198     proper `~astropy.coordinates.ITRS` object from this object, use the ``itrs``
199     property.
200     """
201 
202     _ellipsoid = "WGS84"
203     _location_dtype = np.dtype({"names": ["x", "y", "z"], "formats": [np.float64] * 3})
204     _array_dtype = np.dtype((np.float64, (3,)))
205     _site_registry = None
206 
207     info = EarthLocationInfo()
208 
209     def __new__(cls, *args, **kwargs):
210         # TODO: needs copy argument and better dealing with inputs.
211         if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], EarthLocation):
212             return args[0].copy()
213         try:
214             self = cls.from_geocentric(*args, **kwargs)
215         except (u.UnitsError, TypeError) as exc_geocentric:
216             try:
217                 self = cls.from_geodetic(*args, **kwargs)
218             except Exception as exc_geodetic:
219                 raise TypeError(
220                     "Coordinates could not be parsed as either "
221                     "geocentric or geodetic, with respective "
222                     f'exceptions "{exc_geocentric}" and "{exc_geodetic}"'
223                 )
224         return self
225 
226     @classmethod
227     def from_geocentric(cls, x, y, z, unit=None):
228         """
229         Location on Earth, initialized from geocentric coordinates.
230 
231         Parameters
232         ----------
233         x, y, z : `~astropy.units.Quantity` or array-like
234             Cartesian coordinates.  If not quantities, ``unit`` should be given.
235         unit : unit-like or None
236             Physical unit of the coordinate values.  If ``x``, ``y``, and/or
237             ``z`` are quantities, they will be converted to this unit.
238 
239         Raises
240         ------
241         astropy.units.UnitsError
242             If the units on ``x``, ``y``, and ``z`` do not match or an invalid
243             unit is given.
244         ValueError
245             If the shapes of ``x``, ``y``, and ``z`` do not match.
246         TypeError
247             If ``x`` is not a `~astropy.units.Quantity` and no unit is given.
248         """
249         if unit is None:
250             try:
251                 unit = x.unit
252             except AttributeError:
253                 raise TypeError(
254                     "Geocentric coordinates should be Quantities "
255                     "unless an explicit unit is given."
256                 ) from None
257         else:
258             unit = u.Unit(unit)
259 
260         if unit.physical_type != "length":
261             raise u.UnitsError("Geocentric coordinates should be in units of length.")
262 
263         try:
264             x = u.Quantity(x, unit, copy=False)
265             y = u.Quantity(y, unit, copy=False)
266             z = u.Quantity(z, unit, copy=False)
267         except u.UnitsError:
268             raise u.UnitsError("Geocentric coordinate units should all be consistent.")
269 
270         x, y, z = np.broadcast_arrays(x, y, z)
271         struc = np.empty(x.shape, cls._location_dtype)
272         struc["x"], struc["y"], struc["z"] = x, y, z
273         return super().__new__(cls, struc, unit, copy=False)
274 
275     @classmethod
276     def from_geodetic(cls, lon, lat, height=0.0, ellipsoid=None):
277         """
278         Location on Earth, initialized from geodetic coordinates.
279 
280         Parameters
281         ----------
282         lon : `~astropy.coordinates.Longitude` or float
283             Earth East longitude.  Can be anything that initialises an
284             `~astropy.coordinates.Angle` object (if float, in degrees).
285         lat : `~astropy.coordinates.Latitude` or float
286             Earth latitude.  Can be anything that initialises an
287             `~astropy.coordinates.Latitude` object (if float, in degrees).
288         height : `~astropy.units.Quantity` ['length'] or float, optional
289             Height above reference ellipsoid (if float, in meters; default: 0).
290         ellipsoid : str, optional
291             Name of the reference ellipsoid to use (default: 'WGS84').
292             Available ellipsoids are:  'WGS84', 'GRS80', 'WGS72'.
293 
294         Raises
295         ------
296         astropy.units.UnitsError
297             If the units on ``lon`` and ``lat`` are inconsistent with angular
298             ones, or that on ``height`` with a length.
299         ValueError
300             If ``lon``, ``lat``, and ``height`` do not have the same shape, or
301             if ``ellipsoid`` is not recognized as among the ones implemented.
302 
303         Notes
304         -----
305         For the conversion to geocentric coordinates, the ERFA routine
306         ``gd2gc`` is used.  See https://github.com/liberfa/erfa
307         """
308         ellipsoid = _check_ellipsoid(ellipsoid, default=cls._ellipsoid)
309         # As wrapping fails on readonly input, we do so manually
310         lon = Angle(lon, u.degree, copy=False).wrap_at(180 * u.degree)
311         lat = Latitude(lat, u.degree, copy=False)
312         # don't convert to m by default, so we can use the height unit below.
313         if not isinstance(height, u.Quantity):
314             height = u.Quantity(height, u.m, copy=False)
315         # get geocentric coordinates.
316         geodetic = ELLIPSOIDS[ellipsoid](lon, lat, height, copy=False)
317         xyz = geodetic.to_cartesian().get_xyz(xyz_axis=-1) << height.unit
318         self = xyz.view(cls._location_dtype, cls).reshape(geodetic.shape)
319         self._ellipsoid = ellipsoid
320         return self
321 
322     @classmethod
323     def of_site(cls, site_name, *, refresh_cache=False):
324         """
325         Return an object of this class for a known observatory/site by name.
326 
327         This is intended as a quick convenience function to get basic site
328         information, not a fully-featured exhaustive registry of observatories
329         and all their properties.
330 
331         Additional information about the site is stored in the ``.info.meta``
332         dictionary of sites obtained using this method (see the examples below).
333 
334         .. note::
335             This function is meant to access the site registry from the astropy
336             data server, which is saved in the user's local cache.  If you would
337             like a site to be added there, issue a pull request to the
338             `astropy-data repository <https://github.com/astropy/astropy-data>`_ .
339             If the cache already exists the function will use it even if the
340             version in the astropy-data repository has been updated unless the
341             ``refresh_cache=True`` option is used.  If there is no cache and the
342             online version cannot be reached, this function falls back on a
343             built-in list, which currently only contains the Greenwich Royal
344             Observatory as an example case.
345 
346         Parameters
347         ----------
348         site_name : str
349             Name of the observatory (case-insensitive).
350         refresh_cache : bool, optional
351             If `True`, force replacement of the cached registry with a
352             newly downloaded version.  (Default: `False`)
353 
354             .. versionadded:: 5.3
355 
356         Returns
357         -------
358         site : `~astropy.coordinates.EarthLocation` (or subclass) instance
359             The location of the observatory. The returned class will be the same
360             as this class.
361 
362         Examples
363         --------
364         >>> from astropy.coordinates import EarthLocation
365         >>> keck = EarthLocation.of_site('Keck Observatory')  # doctest: +REMOTE_DATA
366         >>> keck.geodetic  # doctest: +REMOTE_DATA +FLOAT_CMP
367         GeodeticLocation(lon=<Longitude -155.47833333 deg>, lat=<Latitude 19.82833333 deg>, height=<Quantity 4160. m>)
368         >>> keck.info  # doctest: +REMOTE_DATA
369         name = W. M. Keck Observatory
370         dtype = (float64, float64, float64)
371         unit = m
372         class = EarthLocation
373         n_bad = 0
374         >>> keck.info.meta  # doctest: +REMOTE_DATA
375         {'source': 'IRAF Observatory Database', 'timezone': 'US/Hawaii'}
376 
377         See Also
378         --------
379         get_site_names : the list of sites that this function can access
380         """
381         registry = cls._get_site_registry(force_download=refresh_cache)
382         try:
383             el = registry[site_name]
384         except UnknownSiteException as e:
385             raise UnknownSiteException(
386                 e.site, "EarthLocation.get_site_names", close_names=e.close_names
387             ) from e
388 
389         if cls is el.__class__:
390             return el
391         else:
392             newel = cls.from_geodetic(*el.to_geodetic())
393             newel.info.name = el.info.name
394             return newel
395 
396     @classmethod
397     def of_address(cls, address, get_height=False, google_api_key=None):
398         """
399         Return an object of this class for a given address by querying either
400         the OpenStreetMap Nominatim tool [1]_ (default) or the Google geocoding
401         API [2]_, which requires a specified API key.
402 
403         This is intended as a quick convenience function to get easy access to
404         locations. If you need to specify a precise location, you should use the
405         initializer directly and pass in a longitude, latitude, and elevation.
406 
407         In the background, this just issues a web query to either of
408         the APIs noted above. This is not meant to be abused! Both
409         OpenStreetMap and Google use IP-based query limiting and will ban your
410         IP if you send more than a few thousand queries per hour [2]_.
411 
412         .. warning::
413             If the query returns more than one location (e.g., searching on
414             ``address='springfield'``), this function will use the **first**
415             returned location.
416 
417         Parameters
418         ----------
419         address : str
420             The address to get the location for. As per the Google maps API,
421             this can be a fully specified street address (e.g., 123 Main St.,
422             New York, NY) or a city name (e.g., Danbury, CT), or etc.
423         get_height : bool, optional
424             This only works when using the Google API! See the ``google_api_key``
425             block below. Use the retrieved location to perform a second query to
426             the Google maps elevation API to retrieve the height of the input
427             address [3]_.
428         google_api_key : str, optional
429             A Google API key with the Geocoding API and (optionally) the
430             elevation API enabled. See [4]_ for more information.
431 
432         Returns
433         -------
434         location : `~astropy.coordinates.EarthLocation` (or subclass) instance
435             The location of the input address.
436             Will be type(this class)
437 
438         References
439         ----------
440         .. [1] https://nominatim.openstreetmap.org/
441         .. [2] https://developers.google.com/maps/documentation/geocoding/start
442         .. [3] https://developers.google.com/maps/documentation/elevation/start
443         .. [4] https://developers.google.com/maps/documentation/geocoding/get-api-key
444 
445         """
446         use_google = google_api_key is not None
447 
448         # Fail fast if invalid options are passed:
449         if not use_google and get_height:
450             raise ValueError(
451                 "Currently, `get_height` only works when using the Google geocoding"
452                 " API, which requires passing a Google API key with `google_api_key`."
453                 " See:"
454                 " https://developers.google.com/maps/documentation/geocoding/get-api-key"
455                 " for information on obtaining an API key."
456             )
457 
458         if use_google:  # Google
459             pars = urllib.parse.urlencode({"address": address, "key": google_api_key})
460             geo_url = f"https://maps.googleapis.com/maps/api/geocode/json?{pars}"
461 
462         else:  # OpenStreetMap
463             pars = urllib.parse.urlencode({"q": address, "format": "json"})
464             geo_url = f"https://nominatim.openstreetmap.org/search?{pars}"
465 
466         # get longitude and latitude location
467         err_str = f"Unable to retrieve coordinates for address '{address}'; {{msg}}"
468         geo_result = _get_json_result(geo_url, err_str=err_str, use_google=use_google)
469 
470         if use_google:
471             loc = geo_result[0]["geometry"]["location"]
472             lat = loc["lat"]
473             lon = loc["lng"]
474 
475         else:
476             loc = geo_result[0]
477             lat = float(loc["lat"])  # strings are returned by OpenStreetMap
478             lon = float(loc["lon"])
479 
480         if get_height:
481             pars = {"locations": f"{lat:.8f},{lon:.8f}", "key": google_api_key}
482             pars = urllib.parse.urlencode(pars)
483             ele_url = f"https://maps.googleapis.com/maps/api/elevation/json?{pars}"
484 
485             err_str = f"Unable to retrieve elevation for address '{address}'; {{msg}}"
486             ele_result = _get_json_result(
487                 ele_url, err_str=err_str, use_google=use_google
488             )
489             height = ele_result[0]["elevation"] * u.meter
490 
491         else:
492             height = 0.0
493 
494         return cls.from_geodetic(lon=lon * u.deg, lat=lat * u.deg, height=height)
495 
496     @classmethod
497     def get_site_names(cls, *, refresh_cache=False):
498         """
499         Get list of names of observatories for use with
500         `~astropy.coordinates.EarthLocation.of_site`.
501 
502         .. note::
503             This function is meant to access the site registry from the astropy
504             data server, which is saved in the user's local cache.  If you would
505             like a site to be added there, issue a pull request to the
506             `astropy-data repository <https://github.com/astropy/astropy-data>`_ .
507             If the cache already exists the function will use it even if the
508             version in the astropy-data repository has been updated unless the
509             ``refresh_cache=True`` option is used.  If there is no cache and the
510             online version cannot be reached, this function falls back on a
511             built-in list, which currently only contains the Greenwich Royal
512             Observatory as an example case.
513 
514         Parameters
515         ----------
516         refresh_cache : bool, optional
517             If `True`, force replacement of the cached registry with a
518             newly downloaded version.  (Default: `False`)
519 
520             .. versionadded:: 5.3
521 
522         Returns
523         -------
524         names : list of str
525             List of valid observatory names
526 
527         See Also
528         --------
529         of_site : Gets the actual location object for one of the sites names
530             this returns.
531         """
532         return cls._get_site_registry(force_download=refresh_cache).names
533 
534     @classmethod
535     def _get_site_registry(cls, force_download=False, force_builtin=False):
536         """
537         Gets the site registry.  The first time this either downloads or loads
538         from the data file packaged with astropy.  Subsequent calls will use the
539         cached version unless explicitly overridden.
540 
541         Parameters
542         ----------
543         force_download : bool or str
544             If not False, force replacement of the cached registry with a
545             downloaded version. If a str, that will be used as the URL to
546             download from (if just True, the default URL will be used).
547         force_builtin : bool
548             If True, load from the data file bundled with astropy and set the
549             cache to that.
550 
551         Returns
552         -------
553         reg : astropy.coordinates.sites.SiteRegistry
554         """
555         # need to do this here at the bottom to avoid circular dependencies
556         from .sites import get_builtin_sites, get_downloaded_sites
557 
558         if force_builtin and force_download:
559             raise ValueError("Cannot have both force_builtin and force_download True")
560 
561         if force_builtin:
562             cls._site_registry = get_builtin_sites()
563         else:
564             if force_download or not cls._site_registry:
565                 try:
566                     if isinstance(force_download, str):
567                         cls._site_registry = get_downloaded_sites(force_download)
568                     else:
569                         cls._site_registry = get_downloaded_sites()
570                 except OSError:
571                     if force_download:
572                         raise
573                     msg = (
574                         "Could not access the main site list. Falling back on the "
575                         "built-in version, which is rather limited. If you want to "
576                         "retry the download, use the option 'refresh_cache=True'."
577                     )
578                     warn(msg, AstropyUserWarning)
579                     cls._site_registry = get_builtin_sites()
580         return cls._site_registry
581 
582     @property
583     def ellipsoid(self):
584         """The default ellipsoid used to convert to geodetic coordinates."""
585         return self._ellipsoid
586 
587     @ellipsoid.setter
588     def ellipsoid(self, ellipsoid):
589         self._ellipsoid = _check_ellipsoid(ellipsoid)
590 
591     @property
592     def geodetic(self):
593         """Convert to geodetic coordinates for the default ellipsoid."""
594         return self.to_geodetic()
595 
596     def to_geodetic(self, ellipsoid=None):
597         """Convert to geodetic coordinates.
598 
599         Parameters
600         ----------
601         ellipsoid : str, optional
602             Reference ellipsoid to use.  Default is the one the coordinates
603             were initialized with.  Available are: 'WGS84', 'GRS80', 'WGS72'
604 
605         Returns
606         -------
607         lon, lat, height : `~astropy.units.Quantity`
608             The tuple is a ``GeodeticLocation`` namedtuple and is comprised of
609             instances of `~astropy.coordinates.Longitude`,
610             `~astropy.coordinates.Latitude`, and `~astropy.units.Quantity`.
611 
612         Raises
613         ------
614         ValueError
615             if ``ellipsoid`` is not recognized as among the ones implemented.
616 
617         Notes
618         -----
619         For the conversion to geodetic coordinates, the ERFA routine
620         ``gc2gd`` is used.  See https://github.com/liberfa/erfa
621         """
622         ellipsoid = _check_ellipsoid(ellipsoid, default=self.ellipsoid)
623         xyz = self.view(self._array_dtype, u.Quantity)
624         llh = CartesianRepresentation(xyz, xyz_axis=-1, copy=False).represent_as(
625             ELLIPSOIDS[ellipsoid]
626         )
627         return GeodeticLocation(
628             Longitude(llh.lon, u.deg, wrap_angle=180 * u.deg, copy=False),
629             llh.lat << u.deg,
630             llh.height << self.unit,
631         )
632 
633     @property
634     def lon(self):
635         """Longitude of the location, for the default ellipsoid."""
636         return self.geodetic[0]
637 
638     @property
639     def lat(self):
640         """Latitude of the location, for the default ellipsoid."""
641         return self.geodetic[1]
642 
643     @property
644     def height(self):
645         """Height of the location, for the default ellipsoid."""
646         return self.geodetic[2]
647 
648     # mostly for symmetry with geodetic and to_geodetic.
649     @property
650     def geocentric(self):
651         """Convert to a tuple with X, Y, and Z as quantities."""
652         return self.to_geocentric()
653 
654     def to_geocentric(self):
655         """Convert to a tuple with X, Y, and Z as quantities."""
656         return (self.x, self.y, self.z)
657 
658     def get_itrs(self, obstime=None):
659         """
660         Generates an `~astropy.coordinates.ITRS` object with the location of
661         this object at the requested ``obstime``.
662 
663         Parameters
664         ----------
665         obstime : `~astropy.time.Time` or None
666             The ``obstime`` to apply to the new `~astropy.coordinates.ITRS`, or
667             if None, the default ``obstime`` will be used.
668 
669         Returns
670         -------
671         itrs : `~astropy.coordinates.ITRS`
672             The new object in the ITRS frame
673         """
674         # Broadcast for a single position at multiple times, but don't attempt
675         # to be more general here.
676         if obstime and self.size == 1 and obstime.shape:
677             self = np.broadcast_to(self, obstime.shape, subok=True)
678 
679         # do this here to prevent a series of complicated circular imports
680         from .builtin_frames import ITRS
681 
682         return ITRS(x=self.x, y=self.y, z=self.z, obstime=obstime)
683 
684     itrs = property(
685         get_itrs,
686         doc="""An `~astropy.coordinates.ITRS` object
687                for the location of this object at the
688                default ``obstime``.""",
689     )
690 
691     def get_gcrs(self, obstime):
692         """GCRS position with velocity at ``obstime`` as a GCRS coordinate.
693 
694         Parameters
695         ----------
696         obstime : `~astropy.time.Time`
697             The ``obstime`` to calculate the GCRS position/velocity at.
698 
699         Returns
700         -------
701         gcrs : `~astropy.coordinates.GCRS` instance
702             With velocity included.
703         """
704         # do this here to prevent a series of complicated circular imports
705         from .builtin_frames import GCRS
706 
707         loc, vel = self.get_gcrs_posvel(obstime)
708         loc.differentials["s"] = CartesianDifferential.from_cartesian(vel)
709         return GCRS(loc, obstime=obstime)
710 
711     def _get_gcrs_posvel(self, obstime, ref_to_itrs, gcrs_to_ref):
712         """Calculate GCRS position and velocity given transformation matrices.
713 
714         The reference frame z axis must point to the Celestial Intermediate Pole
715         (as is the case for CIRS and TETE).
716 
717         This private method is used in intermediate_rotation_transforms,
718         where some of the matrices are already available for the coordinate
719         transformation.
720 
721         The method is faster by an order of magnitude than just adding a zero
722         velocity to ITRS and transforming to GCRS, because it avoids calculating
723         the velocity via finite differencing of the results of the transformation
724         at three separate times.
725         """
726         # The simplest route is to transform to the reference frame where the
727         # z axis is properly aligned with the Earth's rotation axis (CIRS or
728         # TETE), then calculate the velocity, and then transform this
729         # reference position and velocity to GCRS.  For speed, though, we
730         # transform the coordinates to GCRS in one step, and calculate the
731         # velocities by rotating around the earth's axis transformed to GCRS.
732         ref_to_gcrs = matrix_transpose(gcrs_to_ref)
733         itrs_to_gcrs = ref_to_gcrs @ matrix_transpose(ref_to_itrs)
734         # Earth's rotation vector in the ref frame is rot_vec_ref = (0,0,OMEGA_EARTH),
735         # so in GCRS it is rot_vec_gcrs[..., 2] @ OMEGA_EARTH.
736         rot_vec_gcrs = CartesianRepresentation(
737             ref_to_gcrs[..., 2] * OMEGA_EARTH, xyz_axis=-1, copy=False
738         )
739         # Get the position in the GCRS frame.
740         # Since we just need the cartesian representation of ITRS, avoid get_itrs().
741         itrs_cart = CartesianRepresentation(self.x, self.y, self.z, copy=False)
742         pos = itrs_cart.transform(itrs_to_gcrs)
743         vel = rot_vec_gcrs.cross(pos)
744         return pos, vel
745 
746     def get_gcrs_posvel(self, obstime):
747         """
748         Calculate the GCRS position and velocity of this object at the
749         requested ``obstime``.
750 
751         Parameters
752         ----------
753         obstime : `~astropy.time.Time`
754             The ``obstime`` to calculate the GCRS position/velocity at.
755 
756         Returns
757         -------
758         obsgeoloc : `~astropy.coordinates.CartesianRepresentation`
759             The GCRS position of the object
760         obsgeovel : `~astropy.coordinates.CartesianRepresentation`
761             The GCRS velocity of the object
762         """
763         # Local import to prevent circular imports.
764         from .builtin_frames.intermediate_rotation_transforms import (
765             cirs_to_itrs_mat,
766             gcrs_to_cirs_mat,
767         )
768 
769         # Get gcrs_posvel by transforming via CIRS (slightly faster than TETE).
770         return self._get_gcrs_posvel(
771             obstime, cirs_to_itrs_mat(obstime), gcrs_to_cirs_mat(obstime)
772         )
773 
774     def gravitational_redshift(
775         self, obstime, bodies=["sun", "jupiter", "moon"], masses={}
776     ):
777         """Return the gravitational redshift at this EarthLocation.
778 
779         Calculates the gravitational redshift, of order 3 m/s, due to the
780         requested solar system bodies.
781 
782         Parameters
783         ----------
784         obstime : `~astropy.time.Time`
785             The ``obstime`` to calculate the redshift at.
786 
787         bodies : iterable, optional
788             The bodies (other than the Earth) to include in the redshift
789             calculation.  List elements should be any body name
790             `get_body_barycentric` accepts.  Defaults to Jupiter, the Sun, and
791             the Moon.  Earth is always included (because the class represents
792             an *Earth* location).
793 
794         masses : dict[str, `~astropy.units.Quantity`], optional
795             The mass or gravitational parameters (G * mass) to assume for the
796             bodies requested in ``bodies``. Can be used to override the
797             defaults for the Sun, Jupiter, the Moon, and the Earth, or to
798             pass in masses for other bodies.
799 
800         Returns
801         -------
802         redshift : `~astropy.units.Quantity`
803             Gravitational redshift in velocity units at given obstime.
804         """
805         # needs to be here to avoid circular imports
806         from .solar_system import get_body_barycentric
807 
808         bodies = list(bodies)
809         # Ensure earth is included and last in the list.
810         if "earth" in bodies:
811             bodies.remove("earth")
812         bodies.append("earth")
813         _masses = {
814             "sun": consts.GM_sun,
815             "jupiter": consts.GM_jup,
816             "moon": consts.G * 7.34767309e22 * u.kg,
817             "earth": consts.GM_earth,
818         }
819         _masses.update(masses)
820         GMs = []
821         M_GM_equivalency = (u.kg, u.Unit(consts.G * u.kg))
822         for body in bodies:
823             try:
824                 GMs.append(_masses[body].to(u.m**3 / u.s**2, [M_GM_equivalency]))
825             except KeyError as err:
826                 raise KeyError(f'body "{body}" does not have a mass.') from err
827             except u.UnitsError as exc:
828                 exc.args += (
829                     (
830                         '"masses" argument values must be masses or '
831                         "gravitational parameters."
832                     ),
833                 )
834                 raise
835 
836         positions = [get_body_barycentric(name, obstime) for name in bodies]
837         # Calculate distances to objects other than earth.
838         distances = [(pos - positions[-1]).norm() for pos in positions[:-1]]
839         # Append distance from Earth's center for Earth's contribution.
840         distances.append(CartesianRepresentation(self.geocentric).norm())
841         # Get redshifts due to all objects.
842         redshifts = [
843             -GM / consts.c / distance for (GM, distance) in zip(GMs, distances)
844         ]
845         # Reverse order of summing, to go from small to big, and to get
846         # "earth" first, which gives m/s as unit.
847         return sum(redshifts[::-1])
848 
849     @property
850     def x(self):
851         """The X component of the geocentric coordinates."""
852         return self["x"]
853 
854     @property
855     def y(self):
856         """The Y component of the geocentric coordinates."""
857         return self["y"]
858 
859     @property
860     def z(self):
861         """The Z component of the geocentric coordinates."""
862         return self["z"]
863 
864     def __getitem__(self, item):
865         result = super().__getitem__(item)
866         if result.dtype is self.dtype:
867             return result.view(self.__class__)
868         else:
869             return result.view(u.Quantity)
870 
871     def __array_finalize__(self, obj):
872         super().__array_finalize__(obj)
873         if hasattr(obj, "_ellipsoid"):
874             self._ellipsoid = obj._ellipsoid
875 
876     def __len__(self):
877         if self.shape == ():
878             raise IndexError("0-d EarthLocation arrays cannot be indexed")
879         else:
880             return super().__len__()
881 
882     def _to_value(self, unit, equivalencies=[]):
883         """Helper method for to and to_value."""
884         # Conversion to another unit in both ``to`` and ``to_value`` goes
885         # via this routine. To make the regular quantity routines work, we
886         # temporarily turn the structured array into a regular one.
887         array_view = self.view(self._array_dtype, np.ndarray)
888         if equivalencies == []:
889             equivalencies = self._equivalencies
890         new_array = self.unit.to(unit, array_view, equivalencies=equivalencies)
891         return new_array.view(self.dtype).reshape(self.shape)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 15:43:54.695 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 15:43:54.696 | INFO     | Search-only: skipping patch selection
2025-10-15 15:43:54.808 | INFO     | Task astropy__astropy-14628 completed successfully.
2025-10-15 15:43:54.809 | INFO     | No patch generated. You can try running ACR again.
