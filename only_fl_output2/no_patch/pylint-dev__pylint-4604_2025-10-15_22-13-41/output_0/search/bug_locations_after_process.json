[
    {
        "rel_file_path": "pylint/checkers/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/checkers/utils.py",
        "start": 1,
        "end": 1513,
        "class_name": null,
        "method_name": null,
        "code": "1 # Copyright (c) 2006-2007, 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>\n2 # Copyright (c) 2009 Mads Kiilerich <mads@kiilerich.com>\n3 # Copyright (c) 2010 Daniel Harding <dharding@gmail.com>\n4 # Copyright (c) 2012-2014 Google, Inc.\n5 # Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>\n6 # Copyright (c) 2013-2020 Claudiu Popa <pcmanticore@gmail.com>\n7 # Copyright (c) 2014 Brett Cannon <brett@python.org>\n8 # Copyright (c) 2014 Ricardo Gemignani <ricardo.gemignani@gmail.com>\n9 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>\n10 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>\n11 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>\n12 # Copyright (c) 2015 Radu Ciorba <radu@devrandom.ro>\n13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>\n14 # Copyright (c) 2016, 2018-2019 Ashley Whetter <ashley@awhetter.co.uk>\n15 # Copyright (c) 2016-2017 \u0141ukasz Rogalski <rogalski.91@gmail.com>\n16 # Copyright (c) 2016-2017 Moises Lopez <moylop260@vauxoo.com>\n17 # Copyright (c) 2016 Brian C. Lane <bcl@redhat.com>\n18 # Copyright (c) 2017-2018, 2020 hippo91 <guillaume.peillex@gmail.com>\n19 # Copyright (c) 2017 ttenhoeve-aa <ttenhoeve@appannie.com>\n20 # Copyright (c) 2018 Alan Chan <achan961117@gmail.com>\n21 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>\n22 # Copyright (c) 2018 Yury Gribov <tetra2005@gmail.com>\n23 # Copyright (c) 2018 Caio Carrara <ccarrara@redhat.com>\n24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>\n25 # Copyright (c) 2018 Bryce Guinta <bryce.guinta@protonmail.com>\n26 # Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>\n27 # Copyright (c) 2018 Ville Skytt\u00e4 <ville.skytta@iki.fi>\n28 # Copyright (c) 2018 Brian Shaginaw <brian.shaginaw@warbyparker.com>\n29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>\n30 # Copyright (c) 2019 Matthijs Blom <19817960+MatthijsBlom@users.noreply.github.com>\n31 # Copyright (c) 2019 Djailla <bastien.vallet@gmail.com>\n32 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>\n33 # Copyright (c) 2019 Nathan Marrow <nmarrow@google.com>\n34 # Copyright (c) 2019 Svet <svet@hyperscience.com>\n35 # Copyright (c) 2019 Pascal Corpet <pcorpet@users.noreply.github.com>\n36 # Copyright (c) 2020 Batuhan Taskaya <batuhanosmantaskaya@gmail.com>\n37 # Copyright (c) 2020 Luigi <luigi.cristofolini@q-ctrl.com>\n38 # Copyright (c) 2020 ethan-leba <ethanleba5@gmail.com>\n39 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>\n40 # Copyright (c) 2020 Andrew Simmons <anjsimmo@gmail.com>\n41 # Copyright (c) 2020 Ram Rachum <ram@rachum.com>\n42 # Copyright (c) 2020 Slavfox <slavfoxman@gmail.com>\n43 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>\n44 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>\n45 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>\n46 \n47 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n48 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n49 \n50 \"\"\"some functions that may be useful for various checkers\n51 \"\"\"\n52 import builtins\n53 import itertools\n54 import numbers\n55 import re\n56 import string\n57 from functools import lru_cache, partial\n58 from typing import (\n59     Any,\n60     Callable,\n61     Dict,\n62     Iterable,\n63     List,\n64     Match,\n65     Optional,\n66     Set,\n67     Tuple,\n68     Union,\n69 )\n70 \n71 import _string\n72 import astroid\n73 \n74 BUILTINS_NAME = builtins.__name__\n75 COMP_NODE_TYPES = (\n76     astroid.ListComp,\n77     astroid.SetComp,\n78     astroid.DictComp,\n79     astroid.GeneratorExp,\n80 )\n81 EXCEPTIONS_MODULE = \"builtins\"\n82 ABC_MODULES = {\"abc\", \"_py_abc\"}\n83 ABC_METHODS = {\n84     \"abc.abstractproperty\",\n85     \"abc.abstractmethod\",\n86     \"abc.abstractclassmethod\",\n87     \"abc.abstractstaticmethod\",\n88 }\n89 TYPING_PROTOCOLS = frozenset(\n90     {\"typing.Protocol\", \"typing_extensions.Protocol\", \".Protocol\"}\n91 )\n92 ITER_METHOD = \"__iter__\"\n93 AITER_METHOD = \"__aiter__\"\n94 NEXT_METHOD = \"__next__\"\n95 GETITEM_METHOD = \"__getitem__\"\n96 CLASS_GETITEM_METHOD = \"__class_getitem__\"\n97 SETITEM_METHOD = \"__setitem__\"\n98 DELITEM_METHOD = \"__delitem__\"\n99 CONTAINS_METHOD = \"__contains__\"\n100 KEYS_METHOD = \"keys\"\n101 \n102 # Dictionary which maps the number of expected parameters a\n103 # special method can have to a set of special methods.\n104 # The following keys are used to denote the parameters restrictions:\n105 #\n106 # * None: variable number of parameters\n107 # * number: exactly that number of parameters\n108 # * tuple: this are the odd ones. Basically it means that the function\n109 #          can work with any number of arguments from that tuple,\n110 #          although it's best to implement it in order to accept\n111 #          all of them.\n112 _SPECIAL_METHODS_PARAMS = {\n113     None: (\"__new__\", \"__init__\", \"__call__\"),\n114     0: (\n115         \"__del__\",\n116         \"__repr__\",\n117         \"__str__\",\n118         \"__bytes__\",\n119         \"__hash__\",\n120         \"__bool__\",\n121         \"__dir__\",\n122         \"__len__\",\n123         \"__length_hint__\",\n124         \"__iter__\",\n125         \"__reversed__\",\n126         \"__neg__\",\n127         \"__pos__\",\n128         \"__abs__\",\n129         \"__invert__\",\n130         \"__complex__\",\n131         \"__int__\",\n132         \"__float__\",\n133         \"__index__\",\n134         \"__trunc__\",\n135         \"__floor__\",\n136         \"__ceil__\",\n137         \"__enter__\",\n138         \"__aenter__\",\n139         \"__getnewargs_ex__\",\n140         \"__getnewargs__\",\n141         \"__getstate__\",\n142         \"__reduce__\",\n143         \"__copy__\",\n144         \"__unicode__\",\n145         \"__nonzero__\",\n146         \"__await__\",\n147         \"__aiter__\",\n148         \"__anext__\",\n149         \"__fspath__\",\n150     ),\n151     1: (\n152         \"__format__\",\n153         \"__lt__\",\n154         \"__le__\",\n155         \"__eq__\",\n156         \"__ne__\",\n157         \"__gt__\",\n158         \"__ge__\",\n159         \"__getattr__\",\n160         \"__getattribute__\",\n161         \"__delattr__\",\n162         \"__delete__\",\n163         \"__instancecheck__\",\n164         \"__subclasscheck__\",\n165         \"__getitem__\",\n166         \"__missing__\",\n167         \"__delitem__\",\n168         \"__contains__\",\n169         \"__add__\",\n170         \"__sub__\",\n171         \"__mul__\",\n172         \"__truediv__\",\n173         \"__floordiv__\",\n174         \"__rfloordiv__\",\n175         \"__mod__\",\n176         \"__divmod__\",\n177         \"__lshift__\",\n178         \"__rshift__\",\n179         \"__and__\",\n180         \"__xor__\",\n181         \"__or__\",\n182         \"__radd__\",\n183         \"__rsub__\",\n184         \"__rmul__\",\n185         \"__rtruediv__\",\n186         \"__rmod__\",\n187         \"__rdivmod__\",\n188         \"__rpow__\",\n189         \"__rlshift__\",\n190         \"__rrshift__\",\n191         \"__rand__\",\n192         \"__rxor__\",\n193         \"__ror__\",\n194         \"__iadd__\",\n195         \"__isub__\",\n196         \"__imul__\",\n197         \"__itruediv__\",\n198         \"__ifloordiv__\",\n199         \"__imod__\",\n200         \"__ilshift__\",\n201         \"__irshift__\",\n202         \"__iand__\",\n203         \"__ixor__\",\n204         \"__ior__\",\n205         \"__ipow__\",\n206         \"__setstate__\",\n207         \"__reduce_ex__\",\n208         \"__deepcopy__\",\n209         \"__cmp__\",\n210         \"__matmul__\",\n211         \"__rmatmul__\",\n212         \"__imatmul__\",\n213         \"__div__\",\n214     ),\n215     2: (\"__setattr__\", \"__get__\", \"__set__\", \"__setitem__\", \"__set_name__\"),\n216     3: (\"__exit__\", \"__aexit__\"),\n217     (0, 1): (\"__round__\",),\n218     (1, 2): (\"__pow__\",),\n219 }\n220 \n221 SPECIAL_METHODS_PARAMS = {\n222     name: params\n223     for params, methods in _SPECIAL_METHODS_PARAMS.items()\n224     for name in methods  # type: ignore\n225 }\n226 PYMETHODS = set(SPECIAL_METHODS_PARAMS)\n227 \n228 SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(\n229     (\n230         \"builtins.tuple\",\n231         \"builtins.list\",\n232         \"builtins.dict\",\n233         \"builtins.set\",\n234         \"builtins.frozenset\",\n235         \"builtins.type\",\n236         \"collections.deque\",\n237         \"collections.defaultdict\",\n238         \"collections.OrderedDict\",\n239         \"collections.Counter\",\n240         \"collections.ChainMap\",\n241         \"_collections_abc.Awaitable\",\n242         \"_collections_abc.Coroutine\",\n243         \"_collections_abc.AsyncIterable\",\n244         \"_collections_abc.AsyncIterator\",\n245         \"_collections_abc.AsyncGenerator\",\n246         \"_collections_abc.Iterable\",\n247         \"_collections_abc.Iterator\",\n248         \"_collections_abc.Generator\",\n249         \"_collections_abc.Reversible\",\n250         \"_collections_abc.Container\",\n251         \"_collections_abc.Collection\",\n252         \"_collections_abc.Callable\",\n253         \"_collections_abc.Set\",\n254         \"_collections_abc.MutableSet\",\n255         \"_collections_abc.Mapping\",\n256         \"_collections_abc.MutableMapping\",\n257         \"_collections_abc.Sequence\",\n258         \"_collections_abc.MutableSequence\",\n259         \"_collections_abc.ByteString\",\n260         \"_collections_abc.MappingView\",\n261         \"_collections_abc.KeysView\",\n262         \"_collections_abc.ItemsView\",\n263         \"_collections_abc.ValuesView\",\n264         \"contextlib.AbstractContextManager\",\n265         \"contextlib.AbstractAsyncContextManager\",\n266         \"re.Pattern\",\n267         \"re.Match\",\n268     )\n269 )\n270 \n271 \n272 class NoSuchArgumentError(Exception):\n273     pass\n274 \n275 \n276 class InferredTypeError(Exception):\n277     pass\n278 \n279 \n280 def is_inside_lambda(node: astroid.node_classes.NodeNG) -> bool:\n281     \"\"\"Return true if given node is inside lambda\"\"\"\n282     parent = node.parent\n283     while parent is not None:\n284         if isinstance(parent, astroid.Lambda):\n285             return True\n286         parent = parent.parent\n287     return False\n288 \n289 \n290 def get_all_elements(\n291     node: astroid.node_classes.NodeNG,\n292 ) -> Iterable[astroid.node_classes.NodeNG]:\n293     \"\"\"Recursively returns all atoms in nested lists and tuples.\"\"\"\n294     if isinstance(node, (astroid.Tuple, astroid.List)):\n295         for child in node.elts:\n296             yield from get_all_elements(child)\n297     else:\n298         yield node\n299 \n300 \n301 def is_super(node: astroid.node_classes.NodeNG) -> bool:\n302     \"\"\"return True if the node is referencing the \"super\" builtin function\"\"\"\n303     if getattr(node, \"name\", None) == \"super\" and node.root().name == BUILTINS_NAME:\n304         return True\n305     return False\n306 \n307 \n308 def is_error(node: astroid.scoped_nodes.FunctionDef) -> bool:\n309     \"\"\"Return true if the given function node only raises an exception\"\"\"\n310     return len(node.body) == 1 and isinstance(node.body[0], astroid.Raise)\n311 \n312 \n313 builtins = builtins.__dict__.copy()  # type: ignore\n314 SPECIAL_BUILTINS = (\"__builtins__\",)  # '__path__', '__file__')\n315 \n316 \n317 def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool:\n318     \"\"\"Returns True if the given node is an object from the __builtin__ module.\"\"\"\n319     return node and node.root().name == BUILTINS_NAME\n320 \n321 \n322 def is_builtin(name: str) -> bool:\n323     \"\"\"return true if <name> could be considered as a builtin defined by python\"\"\"\n324     return name in builtins or name in SPECIAL_BUILTINS  # type: ignore\n325 \n326 \n327 def is_defined_in_scope(\n328     var_node: astroid.node_classes.NodeNG,\n329     varname: str,\n330     scope: astroid.node_classes.NodeNG,\n331 ) -> bool:\n332     if isinstance(scope, astroid.If):\n333         for node in scope.body:\n334             if (\n335                 isinstance(node, astroid.Assign)\n336                 and any(\n337                     isinstance(target, astroid.AssignName) and target.name == varname\n338                     for target in node.targets\n339                 )\n340             ) or (isinstance(node, astroid.Nonlocal) and varname in node.names):\n341                 return True\n342     elif isinstance(scope, (COMP_NODE_TYPES, astroid.For)):\n343         for ass_node in scope.nodes_of_class(astroid.AssignName):\n344             if ass_node.name == varname:\n345                 return True\n346     elif isinstance(scope, astroid.With):\n347         for expr, ids in scope.items:\n348             if expr.parent_of(var_node):\n349                 break\n350             if ids and isinstance(ids, astroid.AssignName) and ids.name == varname:\n351                 return True\n352     elif isinstance(scope, (astroid.Lambda, astroid.FunctionDef)):\n353         if scope.args.is_argument(varname):\n354             # If the name is found inside a default value\n355             # of a function, then let the search continue\n356             # in the parent's tree.\n357             if scope.args.parent_of(var_node):\n358                 try:\n359                     scope.args.default_value(varname)\n360                     scope = scope.parent\n361                     is_defined_in_scope(var_node, varname, scope)\n362                 except astroid.NoDefault:\n363                     pass\n364             return True\n365         if getattr(scope, \"name\", None) == varname:\n366             return True\n367     elif isinstance(scope, astroid.ExceptHandler):\n368         if isinstance(scope.name, astroid.AssignName):\n369             ass_node = scope.name\n370             if ass_node.name == varname:\n371                 return True\n372     return False\n373 \n374 \n375 def is_defined_before(var_node: astroid.Name) -> bool:\n376     \"\"\"Check if the given variable node is defined before\n377 \n378     Verify that the variable node is defined by a parent node\n379     (list, set, dict, or generator comprehension, lambda)\n380     or in a previous sibling node on the same line\n381     (statement_defining ; statement_using).\n382     \"\"\"\n383     varname = var_node.name\n384     _node = var_node.parent\n385     while _node:\n386         if is_defined_in_scope(var_node, varname, _node):\n387             return True\n388         _node = _node.parent\n389     # possibly multiple statements on the same line using semi colon separator\n390     stmt = var_node.statement()\n391     _node = stmt.previous_sibling()\n392     lineno = stmt.fromlineno\n393     while _node and _node.fromlineno == lineno:\n394         for assign_node in _node.nodes_of_class(astroid.AssignName):\n395             if assign_node.name == varname:\n396                 return True\n397         for imp_node in _node.nodes_of_class((astroid.ImportFrom, astroid.Import)):\n398             if varname in [name[1] or name[0] for name in imp_node.names]:\n399                 return True\n400         _node = _node.previous_sibling()\n401     return False\n402 \n403 \n404 def is_default_argument(\n405     node: astroid.node_classes.NodeNG,\n406     scope: Optional[astroid.node_classes.NodeNG] = None,\n407 ) -> bool:\n408     \"\"\"return true if the given Name node is used in function or lambda\n409     default argument's value\n410     \"\"\"\n411     if not scope:\n412         scope = node.scope()\n413     if isinstance(scope, (astroid.FunctionDef, astroid.Lambda)):\n414         for default_node in scope.args.defaults:\n415             for default_name_node in default_node.nodes_of_class(astroid.Name):\n416                 if default_name_node is node:\n417                     return True\n418     return False\n419 \n420 \n421 def is_func_decorator(node: astroid.node_classes.NodeNG) -> bool:\n422     \"\"\"return true if the name is used in function decorator\"\"\"\n423     parent = node.parent\n424     while parent is not None:\n425         if isinstance(parent, astroid.Decorators):\n426             return True\n427         if parent.is_statement or isinstance(\n428             parent,\n429             (\n430                 astroid.Lambda,\n431                 astroid.scoped_nodes.ComprehensionScope,\n432                 astroid.scoped_nodes.ListComp,\n433             ),\n434         ):\n435             break\n436         parent = parent.parent\n437     return False\n438 \n439 \n440 def is_ancestor_name(\n441     frame: astroid.ClassDef, node: astroid.node_classes.NodeNG\n442 ) -> bool:\n443     \"\"\"return True if `frame` is an astroid.Class node with `node` in the\n444     subtree of its bases attribute\n445     \"\"\"\n446     if not isinstance(frame, astroid.ClassDef):\n447         return False\n448     for base in frame.bases:\n449         if node in base.nodes_of_class(astroid.Name):\n450             return True\n451     return False\n452 \n453 \n454 def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:\n455     \"\"\"return the higher parent which is not an AssignName, Tuple or List node\"\"\"\n456     while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):\n457         node = node.parent\n458     return node\n459 \n460 \n461 def overrides_a_method(class_node: astroid.ClassDef, name: str) -> bool:\n462     \"\"\"return True if <name> is a method overridden from an ancestor\"\"\"\n463     for ancestor in class_node.ancestors():\n464         if name in ancestor and isinstance(ancestor[name], astroid.FunctionDef):\n465             return True\n466     return False\n467 \n468 \n469 def check_messages(*messages: str) -> Callable:\n470     \"\"\"decorator to store messages that are handled by a checker method\"\"\"\n471 \n472     def store_messages(func):\n473         func.checks_msgs = messages\n474         return func\n475 \n476     return store_messages\n477 \n478 \n479 class IncompleteFormatString(Exception):\n480     \"\"\"A format string ended in the middle of a format specifier.\"\"\"\n481 \n482 \n483 class UnsupportedFormatCharacter(Exception):\n484     \"\"\"A format character in a format string is not one of the supported\n485     format characters.\"\"\"\n486 \n487     def __init__(self, index):\n488         Exception.__init__(self, index)\n489         self.index = index\n490 \n491 \n492 def parse_format_string(\n493     format_string: str,\n494 ) -> Tuple[Set[str], int, Dict[str, str], List[str]]:\n495     \"\"\"Parses a format string, returning a tuple of (keys, num_args), where keys\n496     is the set of mapping keys in the format string, and num_args is the number\n497     of arguments required by the format string.  Raises\n498     IncompleteFormatString or UnsupportedFormatCharacter if a\n499     parse error occurs.\"\"\"\n500     keys = set()\n501     key_types = dict()\n502     pos_types = []\n503     num_args = 0\n504 \n505     def next_char(i):\n506         i += 1\n507         if i == len(format_string):\n508             raise IncompleteFormatString\n509         return (i, format_string[i])\n510 \n511     i = 0\n512     while i < len(format_string):\n513         char = format_string[i]\n514         if char == \"%\":\n515             i, char = next_char(i)\n516             # Parse the mapping key (optional).\n517             key = None\n518             if char == \"(\":\n519                 depth = 1\n520                 i, char = next_char(i)\n521                 key_start = i\n522                 while depth != 0:\n523                     if char == \"(\":\n524                         depth += 1\n525                     elif char == \")\":\n526                         depth -= 1\n527                     i, char = next_char(i)\n528                 key_end = i - 1\n529                 key = format_string[key_start:key_end]\n530 \n531             # Parse the conversion flags (optional).\n532             while char in \"#0- +\":\n533                 i, char = next_char(i)\n534             # Parse the minimum field width (optional).\n535             if char == \"*\":\n536                 num_args += 1\n537                 i, char = next_char(i)\n538             else:\n539                 while char in string.digits:\n540                     i, char = next_char(i)\n541             # Parse the precision (optional).\n542             if char == \".\":\n543                 i, char = next_char(i)\n544                 if char == \"*\":\n545                     num_args += 1\n546                     i, char = next_char(i)\n547                 else:\n548                     while char in string.digits:\n549                         i, char = next_char(i)\n550             # Parse the length modifier (optional).\n551             if char in \"hlL\":\n552                 i, char = next_char(i)\n553             # Parse the conversion type (mandatory).\n554             flags = \"diouxXeEfFgGcrs%a\"\n555             if char not in flags:\n556                 raise UnsupportedFormatCharacter(i)\n557             if key:\n558                 keys.add(key)\n559                 key_types[key] = char\n560             elif char != \"%\":\n561                 num_args += 1\n562                 pos_types.append(char)\n563         i += 1\n564     return keys, num_args, key_types, pos_types\n565 \n566 \n567 def split_format_field_names(format_string) -> Tuple[str, Iterable[Tuple[bool, str]]]:\n568     try:\n569         return _string.formatter_field_name_split(format_string)\n570     except ValueError as e:\n571         raise IncompleteFormatString() from e\n572 \n573 \n574 def collect_string_fields(format_string) -> Iterable[Optional[str]]:\n575     \"\"\"Given a format string, return an iterator\n576     of all the valid format fields. It handles nested fields\n577     as well.\n578     \"\"\"\n579     formatter = string.Formatter()\n580     try:\n581         parseiterator = formatter.parse(format_string)\n582         for result in parseiterator:\n583             if all(item is None for item in result[1:]):\n584                 # not a replacement format\n585                 continue\n586             name = result[1]\n587             nested = result[2]\n588             yield name\n589             if nested:\n590                 yield from collect_string_fields(nested)\n591     except ValueError as exc:\n592         # Probably the format string is invalid.\n593         if exc.args[0].startswith(\"cannot switch from manual\"):\n594             # On Jython, parsing a string with both manual\n595             # and automatic positions will fail with a ValueError,\n596             # while on CPython it will simply return the fields,\n597             # the validation being done in the interpreter (?).\n598             # We're just returning two mixed fields in order\n599             # to trigger the format-combined-specification check.\n600             yield \"\"\n601             yield \"1\"\n602             return\n603         raise IncompleteFormatString(format_string) from exc\n604 \n605 \n606 def parse_format_method_string(\n607     format_string: str,\n608 ) -> Tuple[List[Tuple[str, List[Tuple[bool, str]]]], int, int]:\n609     \"\"\"\n610     Parses a PEP 3101 format string, returning a tuple of\n611     (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args),\n612     where keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt\n613     is the number of arguments required by the format string and\n614     explicit_pos_args is the number of arguments passed with the position.\n615     \"\"\"\n616     keyword_arguments = []\n617     implicit_pos_args_cnt = 0\n618     explicit_pos_args = set()\n619     for name in collect_string_fields(format_string):\n620         if name and str(name).isdigit():\n621             explicit_pos_args.add(str(name))\n622         elif name:\n623             keyname, fielditerator = split_format_field_names(name)\n624             if isinstance(keyname, numbers.Number):\n625                 explicit_pos_args.add(str(keyname))\n626             try:\n627                 keyword_arguments.append((keyname, list(fielditerator)))\n628             except ValueError as e:\n629                 raise IncompleteFormatString() from e\n630         else:\n631             implicit_pos_args_cnt += 1\n632     return keyword_arguments, implicit_pos_args_cnt, len(explicit_pos_args)\n633 \n634 \n635 def is_attr_protected(attrname: str) -> bool:\n636     \"\"\"return True if attribute name is protected (start with _ and some other\n637     details), False otherwise.\n638     \"\"\"\n639     return (\n640         attrname[0] == \"_\"\n641         and attrname != \"_\"\n642         and not (attrname.startswith(\"__\") and attrname.endswith(\"__\"))\n643     )\n644 \n645 \n646 def node_frame_class(node: astroid.node_classes.NodeNG) -> Optional[astroid.ClassDef]:\n647     \"\"\"Return the class that is wrapping the given node\n648 \n649     The function returns a class for a method node (or a staticmethod or a\n650     classmethod), otherwise it returns `None`.\n651     \"\"\"\n652     klass = node.frame()\n653     nodes_to_check = (\n654         astroid.node_classes.NodeNG,\n655         astroid.UnboundMethod,\n656         astroid.BaseInstance,\n657     )\n658     while (\n659         klass\n660         and isinstance(klass, nodes_to_check)\n661         and not isinstance(klass, astroid.ClassDef)\n662     ):\n663         if klass.parent is None:\n664             klass = None\n665         else:\n666             klass = klass.parent.frame()\n667 \n668     return klass\n669 \n670 \n671 def is_attr_private(attrname: str) -> Optional[Match[str]]:\n672     \"\"\"Check that attribute name is private (at least two leading underscores,\n673     at most one trailing underscore)\n674     \"\"\"\n675     regex = re.compile(\"^_{2,}.*[^_]+_?$\")\n676     return regex.match(attrname)\n677 \n678 \n679 def get_argument_from_call(\n680     call_node: astroid.Call, position: int = None, keyword: str = None\n681 ) -> astroid.Name:\n682     \"\"\"Returns the specified argument from a function call.\n683 \n684     :param astroid.Call call_node: Node representing a function call to check.\n685     :param int position: position of the argument.\n686     :param str keyword: the keyword of the argument.\n687 \n688     :returns: The node representing the argument, None if the argument is not found.\n689     :rtype: astroid.Name\n690     :raises ValueError: if both position and keyword are None.\n691     :raises NoSuchArgumentError: if no argument at the provided position or with\n692     the provided keyword.\n693     \"\"\"\n694     if position is None and keyword is None:\n695         raise ValueError(\"Must specify at least one of: position or keyword.\")\n696     if position is not None:\n697         try:\n698             return call_node.args[position]\n699         except IndexError:\n700             pass\n701     if keyword and call_node.keywords:\n702         for arg in call_node.keywords:\n703             if arg.arg == keyword:\n704                 return arg.value\n705 \n706     raise NoSuchArgumentError\n707 \n708 \n709 def inherit_from_std_ex(node: astroid.node_classes.NodeNG) -> bool:\n710     \"\"\"\n711     Return true if the given class node is subclass of\n712     exceptions.Exception.\n713     \"\"\"\n714     ancestors = node.ancestors() if hasattr(node, \"ancestors\") else []\n715     for ancestor in itertools.chain([node], ancestors):\n716         if (\n717             ancestor.name in (\"Exception\", \"BaseException\")\n718             and ancestor.root().name == EXCEPTIONS_MODULE\n719         ):\n720             return True\n721     return False\n722 \n723 \n724 def error_of_type(handler: astroid.ExceptHandler, error_type) -> bool:\n725     \"\"\"\n726     Check if the given exception handler catches\n727     the given error_type.\n728 \n729     The *handler* parameter is a node, representing an ExceptHandler node.\n730     The *error_type* can be an exception, such as AttributeError,\n731     the name of an exception, or it can be a tuple of errors.\n732     The function will return True if the handler catches any of the\n733     given errors.\n734     \"\"\"\n735 \n736     def stringify_error(error):\n737         if not isinstance(error, str):\n738             return error.__name__\n739         return error\n740 \n741     if not isinstance(error_type, tuple):\n742         error_type = (error_type,)  # type: ignore\n743     expected_errors = {stringify_error(error) for error in error_type}  # type: ignore\n744     if not handler.type:\n745         return False\n746     return handler.catch(expected_errors)\n747 \n748 \n749 def decorated_with_property(node: astroid.FunctionDef) -> bool:\n750     \"\"\"Detect if the given function node is decorated with a property.\"\"\"\n751     if not node.decorators:\n752         return False\n753     for decorator in node.decorators.nodes:\n754         try:\n755             if _is_property_decorator(decorator):\n756                 return True\n757         except astroid.InferenceError:\n758             pass\n759     return False\n760 \n761 \n762 def _is_property_kind(node, *kinds):\n763     if not isinstance(node, (astroid.UnboundMethod, astroid.FunctionDef)):\n764         return False\n765     if node.decorators:\n766         for decorator in node.decorators.nodes:\n767             if isinstance(decorator, astroid.Attribute) and decorator.attrname in kinds:\n768                 return True\n769     return False\n770 \n771 \n772 def is_property_setter(node: astroid.FunctionDef) -> bool:\n773     \"\"\"Check if the given node is a property setter\"\"\"\n774     return _is_property_kind(node, \"setter\")\n775 \n776 \n777 def is_property_deleter(node: astroid.FunctionDef) -> bool:\n778     \"\"\"Check if the given node is a property deleter\"\"\"\n779     return _is_property_kind(node, \"deleter\")\n780 \n781 \n782 def is_property_setter_or_deleter(node: astroid.FunctionDef) -> bool:\n783     \"\"\"Check if the given node is either a property setter or a deleter\"\"\"\n784     return _is_property_kind(node, \"setter\", \"deleter\")\n785 \n786 \n787 def _is_property_decorator(decorator: astroid.Name) -> bool:\n788     for inferred in decorator.infer():\n789         if isinstance(inferred, astroid.ClassDef):\n790             if inferred.qname() in (\"builtins.property\", \"functools.cached_property\"):\n791                 return True\n792             for ancestor in inferred.ancestors():\n793                 if (\n794                     ancestor.name == \"property\"\n795                     and ancestor.root().name == BUILTINS_NAME\n796                 ):\n797                     return True\n798     return False\n799 \n800 \n801 def decorated_with(\n802     func: Union[astroid.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod],\n803     qnames: Iterable[str],\n804 ) -> bool:\n805     \"\"\"Determine if the `func` node has a decorator with the qualified name `qname`.\"\"\"\n806     decorators = func.decorators.nodes if func.decorators else []\n807     for decorator_node in decorators:\n808         if isinstance(decorator_node, astroid.Call):\n809             # We only want to infer the function name\n810             decorator_node = decorator_node.func\n811         try:\n812             if any(\n813                 i.name in qnames or i.qname() in qnames\n814                 for i in decorator_node.infer()\n815                 if i is not None and i != astroid.Uninferable\n816             ):\n817                 return True\n818         except astroid.InferenceError:\n819             continue\n820     return False\n821 \n822 \n823 @lru_cache(maxsize=1024)\n824 def unimplemented_abstract_methods(\n825     node: astroid.ClassDef, is_abstract_cb: astroid.FunctionDef = None\n826 ) -> Dict[str, astroid.node_classes.NodeNG]:\n827     \"\"\"\n828     Get the unimplemented abstract methods for the given *node*.\n829 \n830     A method can be considered abstract if the callback *is_abstract_cb*\n831     returns a ``True`` value. The check defaults to verifying that\n832     a method is decorated with abstract methods.\n833     The function will work only for new-style classes. For old-style\n834     classes, it will simply return an empty dictionary.\n835     For the rest of them, it will return a dictionary of abstract method\n836     names and their inferred objects.\n837     \"\"\"\n838     if is_abstract_cb is None:\n839         is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)\n840     visited: Dict[str, astroid.node_classes.NodeNG] = {}\n841     try:\n842         mro = reversed(node.mro())\n843     except NotImplementedError:\n844         # Old style class, it will not have a mro.\n845         return {}\n846     except astroid.ResolveError:\n847         # Probably inconsistent hierarchy, don'try\n848         # to figure this out here.\n849         return {}\n850     for ancestor in mro:\n851         for obj in ancestor.values():\n852             inferred = obj\n853             if isinstance(obj, astroid.AssignName):\n854                 inferred = safe_infer(obj)\n855                 if not inferred:\n856                     # Might be an abstract function,\n857                     # but since we don't have enough information\n858                     # in order to take this decision, we're taking\n859                     # the *safe* decision instead.\n860                     if obj.name in visited:\n861                         del visited[obj.name]\n862                     continue\n863                 if not isinstance(inferred, astroid.FunctionDef):\n864                     if obj.name in visited:\n865                         del visited[obj.name]\n866             if isinstance(inferred, astroid.FunctionDef):\n867                 # It's critical to use the original name,\n868                 # since after inferring, an object can be something\n869                 # else than expected, as in the case of the\n870                 # following assignment.\n871                 #\n872                 # class A:\n873                 #     def keys(self): pass\n874                 #     __iter__ = keys\n875                 abstract = is_abstract_cb(inferred)\n876                 if abstract:\n877                     visited[obj.name] = inferred\n878                 elif not abstract and obj.name in visited:\n879                     del visited[obj.name]\n880     return visited\n881 \n882 \n883 def find_try_except_wrapper_node(\n884     node: astroid.node_classes.NodeNG,\n885 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:\n886     \"\"\"Return the ExceptHandler or the TryExcept node in which the node is.\"\"\"\n887     current = node\n888     ignores = (astroid.ExceptHandler, astroid.TryExcept)\n889     while current and not isinstance(current.parent, ignores):\n890         current = current.parent\n891 \n892     if current and isinstance(current.parent, ignores):\n893         return current.parent\n894     return None\n895 \n896 \n897 def find_except_wrapper_node_in_scope(\n898     node: astroid.node_classes.NodeNG,\n899 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:\n900     \"\"\"Return the ExceptHandler in which the node is, without going out of scope.\"\"\"\n901     current = node\n902     while current.parent is not None:\n903         current = current.parent\n904         if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):\n905             # If we're inside a function/class definition, we don't want to keep checking\n906             # higher ancestors for `except` clauses, because if these exist, it means our\n907             # function/class was defined in an `except` clause, rather than the current code\n908             # actually running in an `except` clause.\n909             return None\n910         if isinstance(current, astroid.ExceptHandler):\n911             return current\n912     return None\n913 \n914 \n915 def is_from_fallback_block(node: astroid.node_classes.NodeNG) -> bool:\n916     \"\"\"Check if the given node is from a fallback import block.\"\"\"\n917     context = find_try_except_wrapper_node(node)\n918     if not context:\n919         return False\n920 \n921     if isinstance(context, astroid.ExceptHandler):\n922         other_body = context.parent.body\n923         handlers = context.parent.handlers\n924     else:\n925         other_body = itertools.chain.from_iterable(\n926             handler.body for handler in context.handlers\n927         )\n928         handlers = context.handlers\n929 \n930     has_fallback_imports = any(\n931         isinstance(import_node, (astroid.ImportFrom, astroid.Import))\n932         for import_node in other_body\n933     )\n934     ignores_import_error = _except_handlers_ignores_exception(handlers, ImportError)\n935     return ignores_import_error or has_fallback_imports\n936 \n937 \n938 def _except_handlers_ignores_exception(\n939     handlers: astroid.ExceptHandler, exception\n940 ) -> bool:\n941     func = partial(error_of_type, error_type=(exception,))\n942     return any(func(handler) for handler in handlers)\n943 \n944 \n945 def get_exception_handlers(\n946     node: astroid.node_classes.NodeNG, exception=Exception\n947 ) -> Optional[List[astroid.ExceptHandler]]:\n948     \"\"\"Return the collections of handlers handling the exception in arguments.\n949 \n950     Args:\n951         node (astroid.NodeNG): A node that is potentially wrapped in a try except.\n952         exception (builtin.Exception or str): exception or name of the exception.\n953 \n954     Returns:\n955         list: the collection of handlers that are handling the exception or None.\n956 \n957     \"\"\"\n958     context = find_try_except_wrapper_node(node)\n959     if isinstance(context, astroid.TryExcept):\n960         return [\n961             handler for handler in context.handlers if error_of_type(handler, exception)\n962         ]\n963     return []\n964 \n965 \n966 def is_node_inside_try_except(node: astroid.Raise) -> bool:\n967     \"\"\"Check if the node is directly under a Try/Except statement.\n968     (but not under an ExceptHandler!)\n969 \n970     Args:\n971         node (astroid.Raise): the node raising the exception.\n972 \n973     Returns:\n974         bool: True if the node is inside a try/except statement, False otherwise.\n975     \"\"\"\n976     context = find_try_except_wrapper_node(node)\n977     return isinstance(context, astroid.TryExcept)\n978 \n979 \n980 def node_ignores_exception(\n981     node: astroid.node_classes.NodeNG, exception=Exception\n982 ) -> bool:\n983     \"\"\"Check if the node is in a TryExcept which handles the given exception.\n984 \n985     If the exception is not given, the function is going to look for bare\n986     excepts.\n987     \"\"\"\n988     managing_handlers = get_exception_handlers(node, exception)\n989     if not managing_handlers:\n990         return False\n991     return any(managing_handlers)\n992 \n993 \n994 def class_is_abstract(node: astroid.ClassDef) -> bool:\n995     \"\"\"return true if the given class node should be considered as an abstract\n996     class\n997     \"\"\"\n998     # Only check for explicit metaclass=ABCMeta on this specific class\n999     meta = node.declared_metaclass()\n1000     if meta is not None:\n1001         if meta.name == \"ABCMeta\" and meta.root().name in ABC_MODULES:\n1002             return True\n1003 \n1004     for ancestor in node.ancestors():\n1005         if ancestor.name == \"ABC\" and ancestor.root().name in ABC_MODULES:\n1006             # abc.ABC inheritance\n1007             return True\n1008 \n1009     for method in node.methods():\n1010         if method.parent.frame() is node:\n1011             if method.is_abstract(pass_is_abstract=False):\n1012                 return True\n1013     return False\n1014 \n1015 \n1016 def _supports_protocol_method(value: astroid.node_classes.NodeNG, attr: str) -> bool:\n1017     try:\n1018         attributes = value.getattr(attr)\n1019     except astroid.NotFoundError:\n1020         return False\n1021 \n1022     first = attributes[0]\n1023     if isinstance(first, astroid.AssignName):\n1024         if isinstance(first.parent.value, astroid.Const):\n1025             return False\n1026     return True\n1027 \n1028 \n1029 def is_comprehension(node: astroid.node_classes.NodeNG) -> bool:\n1030     comprehensions = (\n1031         astroid.ListComp,\n1032         astroid.SetComp,\n1033         astroid.DictComp,\n1034         astroid.GeneratorExp,\n1035     )\n1036     return isinstance(node, comprehensions)\n1037 \n1038 \n1039 def _supports_mapping_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1040     return _supports_protocol_method(\n1041         value, GETITEM_METHOD\n1042     ) and _supports_protocol_method(value, KEYS_METHOD)\n1043 \n1044 \n1045 def _supports_membership_test_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1046     return _supports_protocol_method(value, CONTAINS_METHOD)\n1047 \n1048 \n1049 def _supports_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1050     return _supports_protocol_method(value, ITER_METHOD) or _supports_protocol_method(\n1051         value, GETITEM_METHOD\n1052     )\n1053 \n1054 \n1055 def _supports_async_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1056     return _supports_protocol_method(value, AITER_METHOD)\n1057 \n1058 \n1059 def _supports_getitem_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1060     return _supports_protocol_method(value, GETITEM_METHOD)\n1061 \n1062 \n1063 def _supports_setitem_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1064     return _supports_protocol_method(value, SETITEM_METHOD)\n1065 \n1066 \n1067 def _supports_delitem_protocol(value: astroid.node_classes.NodeNG) -> bool:\n1068     return _supports_protocol_method(value, DELITEM_METHOD)\n1069 \n1070 \n1071 def _is_abstract_class_name(name: str) -> bool:\n1072     lname = name.lower()\n1073     is_mixin = lname.endswith(\"mixin\")\n1074     is_abstract = lname.startswith(\"abstract\")\n1075     is_base = lname.startswith(\"base\") or lname.endswith(\"base\")\n1076     return is_mixin or is_abstract or is_base\n1077 \n1078 \n1079 def is_inside_abstract_class(node: astroid.node_classes.NodeNG) -> bool:\n1080     while node is not None:\n1081         if isinstance(node, astroid.ClassDef):\n1082             if class_is_abstract(node):\n1083                 return True\n1084             name = getattr(node, \"name\", None)\n1085             if name is not None and _is_abstract_class_name(name):\n1086                 return True\n1087         node = node.parent\n1088     return False\n1089 \n1090 \n1091 def _supports_protocol(\n1092     value: astroid.node_classes.NodeNG, protocol_callback: astroid.FunctionDef\n1093 ) -> bool:\n1094     if isinstance(value, astroid.ClassDef):\n1095         if not has_known_bases(value):\n1096             return True\n1097         # classobj can only be iterable if it has an iterable metaclass\n1098         meta = value.metaclass()\n1099         if meta is not None:\n1100             if protocol_callback(meta):\n1101                 return True\n1102     if isinstance(value, astroid.BaseInstance):\n1103         if not has_known_bases(value):\n1104             return True\n1105         if value.has_dynamic_getattr():\n1106             return True\n1107         if protocol_callback(value):\n1108             return True\n1109 \n1110     if (\n1111         isinstance(value, astroid.bases.Proxy)\n1112         and isinstance(value._proxied, astroid.BaseInstance)\n1113         and has_known_bases(value._proxied)\n1114     ):\n1115         value = value._proxied\n1116         return protocol_callback(value)\n1117 \n1118     return False\n1119 \n1120 \n1121 def is_iterable(value: astroid.node_classes.NodeNG, check_async: bool = False) -> bool:\n1122     if check_async:\n1123         protocol_check = _supports_async_iteration_protocol\n1124     else:\n1125         protocol_check = _supports_iteration_protocol\n1126     return _supports_protocol(value, protocol_check)\n1127 \n1128 \n1129 def is_mapping(value: astroid.node_classes.NodeNG) -> bool:\n1130     return _supports_protocol(value, _supports_mapping_protocol)\n1131 \n1132 \n1133 def supports_membership_test(value: astroid.node_classes.NodeNG) -> bool:\n1134     supported = _supports_protocol(value, _supports_membership_test_protocol)\n1135     return supported or is_iterable(value)\n1136 \n1137 \n1138 def supports_getitem(\n1139     value: astroid.node_classes.NodeNG, node: astroid.node_classes.NodeNG\n1140 ) -> bool:\n1141     if isinstance(value, astroid.ClassDef):\n1142         if _supports_protocol_method(value, CLASS_GETITEM_METHOD):\n1143             return True\n1144         if is_class_subscriptable_pep585_with_postponed_evaluation_enabled(value, node):\n1145             return True\n1146     return _supports_protocol(value, _supports_getitem_protocol)\n1147 \n1148 \n1149 def supports_setitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:\n1150     return _supports_protocol(value, _supports_setitem_protocol)\n1151 \n1152 \n1153 def supports_delitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:\n1154     return _supports_protocol(value, _supports_delitem_protocol)\n1155 \n1156 \n1157 def _get_python_type_of_node(node):\n1158     pytype = getattr(node, \"pytype\", None)\n1159     if callable(pytype):\n1160         return pytype()\n1161     return None\n1162 \n1163 \n1164 @lru_cache(maxsize=1024)\n1165 def safe_infer(\n1166     node: astroid.node_classes.NodeNG, context=None\n1167 ) -> Optional[astroid.node_classes.NodeNG]:\n1168     \"\"\"Return the inferred value for the given node.\n1169 \n1170     Return None if inference failed or if there is some ambiguity (more than\n1171     one node has been inferred of different types).\n1172     \"\"\"\n1173     inferred_types = set()\n1174     try:\n1175         infer_gen = node.infer(context=context)\n1176         value = next(infer_gen)\n1177     except astroid.InferenceError:\n1178         return None\n1179 \n1180     if value is not astroid.Uninferable:\n1181         inferred_types.add(_get_python_type_of_node(value))\n1182 \n1183     try:\n1184         for inferred in infer_gen:\n1185             inferred_type = _get_python_type_of_node(inferred)\n1186             if inferred_type not in inferred_types:\n1187                 return None  # If there is ambiguity on the inferred node.\n1188     except astroid.InferenceError:\n1189         return None  # There is some kind of ambiguity\n1190     except StopIteration:\n1191         return value\n1192     return value if len(inferred_types) <= 1 else None\n1193 \n1194 \n1195 def has_known_bases(klass: astroid.ClassDef, context=None) -> bool:\n1196     \"\"\"Return true if all base classes of a class could be inferred.\"\"\"\n1197     try:\n1198         return klass._all_bases_known\n1199     except AttributeError:\n1200         pass\n1201     for base in klass.bases:\n1202         result = safe_infer(base, context=context)\n1203         if (\n1204             not isinstance(result, astroid.ClassDef)\n1205             or result is klass\n1206             or not has_known_bases(result, context=context)\n1207         ):\n1208             klass._all_bases_known = False\n1209             return False\n1210     klass._all_bases_known = True\n1211     return True\n1212 \n1213 \n1214 def is_none(node: astroid.node_classes.NodeNG) -> bool:\n1215     return (\n1216         node is None\n1217         or (isinstance(node, astroid.Const) and node.value is None)\n1218         or (isinstance(node, astroid.Name) and node.name == \"None\")\n1219     )\n1220 \n1221 \n1222 def node_type(node: astroid.node_classes.NodeNG) -> Optional[type]:\n1223     \"\"\"Return the inferred type for `node`\n1224 \n1225     If there is more than one possible type, or if inferred type is Uninferable or None,\n1226     return None\n1227     \"\"\"\n1228     # check there is only one possible type for the assign node. Else we\n1229     # don't handle it for now\n1230     types = set()\n1231     try:\n1232         for var_type in node.infer():\n1233             if var_type == astroid.Uninferable or is_none(var_type):\n1234                 continue\n1235             types.add(var_type)\n1236             if len(types) > 1:\n1237                 return None\n1238     except astroid.InferenceError:\n1239         return None\n1240     return types.pop() if types else None\n1241 \n1242 \n1243 def is_registered_in_singledispatch_function(node: astroid.FunctionDef) -> bool:\n1244     \"\"\"Check if the given function node is a singledispatch function.\"\"\"\n1245 \n1246     singledispatch_qnames = (\n1247         \"functools.singledispatch\",\n1248         \"singledispatch.singledispatch\",\n1249     )\n1250 \n1251     if not isinstance(node, astroid.FunctionDef):\n1252         return False\n1253 \n1254     decorators = node.decorators.nodes if node.decorators else []\n1255     for decorator in decorators:\n1256         # func.register are function calls\n1257         if not isinstance(decorator, astroid.Call):\n1258             continue\n1259 \n1260         func = decorator.func\n1261         if not isinstance(func, astroid.Attribute) or func.attrname != \"register\":\n1262             continue\n1263 \n1264         try:\n1265             func_def = next(func.expr.infer())\n1266         except astroid.InferenceError:\n1267             continue\n1268 \n1269         if isinstance(func_def, astroid.FunctionDef):\n1270             # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here\n1271             return decorated_with(func_def, singledispatch_qnames)\n1272 \n1273     return False\n1274 \n1275 \n1276 def get_node_last_lineno(node: astroid.node_classes.NodeNG) -> int:\n1277     \"\"\"\n1278     Get the last lineno of the given node. For a simple statement this will just be node.lineno,\n1279     but for a node that has child statements (e.g. a method) this will be the lineno of the last\n1280     child statement recursively.\n1281     \"\"\"\n1282     # 'finalbody' is always the last clause in a try statement, if present\n1283     if getattr(node, \"finalbody\", False):\n1284         return get_node_last_lineno(node.finalbody[-1])\n1285     # For if, while, and for statements 'orelse' is always the last clause.\n1286     # For try statements 'orelse' is the last in the absence of a 'finalbody'\n1287     if getattr(node, \"orelse\", False):\n1288         return get_node_last_lineno(node.orelse[-1])\n1289     # try statements have the 'handlers' last if there is no 'orelse' or 'finalbody'\n1290     if getattr(node, \"handlers\", False):\n1291         return get_node_last_lineno(node.handlers[-1])\n1292     # All compound statements have a 'body'\n1293     if getattr(node, \"body\", False):\n1294         return get_node_last_lineno(node.body[-1])\n1295     # Not a compound statement\n1296     return node.lineno\n1297 \n1298 \n1299 def is_postponed_evaluation_enabled(node: astroid.node_classes.NodeNG) -> bool:\n1300     \"\"\"Check if the postponed evaluation of annotations is enabled\"\"\"\n1301     module = node.root()\n1302     return \"annotations\" in module.future_imports\n1303 \n1304 \n1305 def is_class_subscriptable_pep585_with_postponed_evaluation_enabled(\n1306     value: astroid.ClassDef, node: astroid.node_classes.NodeNG\n1307 ) -> bool:\n1308     \"\"\"Check if class is subscriptable with PEP 585 and\n1309     postponed evaluation enabled.\n1310     \"\"\"\n1311     return (\n1312         is_postponed_evaluation_enabled(node)\n1313         and value.qname() in SUBSCRIPTABLE_CLASSES_PEP585\n1314         and is_node_in_type_annotation_context(node)\n1315     )\n1316 \n1317 \n1318 def is_node_in_type_annotation_context(node: astroid.node_classes.NodeNG) -> bool:\n1319     \"\"\"Check if node is in type annotation context.\n1320 \n1321     Check for 'AnnAssign', function 'Arguments',\n1322     or part of function return type anntation.\n1323     \"\"\"\n1324     # pylint: disable=too-many-boolean-expressions\n1325     current_node, parent_node = node, node.parent\n1326     while True:\n1327         if (\n1328             isinstance(parent_node, astroid.AnnAssign)\n1329             and parent_node.annotation == current_node\n1330             or isinstance(parent_node, astroid.Arguments)\n1331             and current_node\n1332             in (\n1333                 *parent_node.annotations,\n1334                 *parent_node.posonlyargs_annotations,\n1335                 *parent_node.kwonlyargs_annotations,\n1336                 parent_node.varargannotation,\n1337                 parent_node.kwargannotation,\n1338             )\n1339             or isinstance(parent_node, astroid.FunctionDef)\n1340             and parent_node.returns == current_node\n1341         ):\n1342             return True\n1343         current_node, parent_node = parent_node, parent_node.parent\n1344         if isinstance(parent_node, astroid.Module):\n1345             return False\n1346 \n1347 \n1348 def is_subclass_of(child: astroid.ClassDef, parent: astroid.ClassDef) -> bool:\n1349     \"\"\"\n1350     Check if first node is a subclass of second node.\n1351     :param child: Node to check for subclass.\n1352     :param parent: Node to check for superclass.\n1353     :returns: True if child is derived from parent. False otherwise.\n1354     \"\"\"\n1355     if not all(isinstance(node, astroid.ClassDef) for node in (child, parent)):\n1356         return False\n1357 \n1358     for ancestor in child.ancestors():\n1359         try:\n1360             if astroid.helpers.is_subtype(ancestor, parent):\n1361                 return True\n1362         except astroid.exceptions._NonDeducibleTypeHierarchy:\n1363             continue\n1364     return False\n1365 \n1366 \n1367 @lru_cache(maxsize=1024)\n1368 def is_overload_stub(node: astroid.node_classes.NodeNG) -> bool:\n1369     \"\"\"Check if a node if is a function stub decorated with typing.overload.\n1370 \n1371     :param node: Node to check.\n1372     :returns: True if node is an overload function stub. False otherwise.\n1373     \"\"\"\n1374     decorators = getattr(node, \"decorators\", None)\n1375     return bool(decorators and decorated_with(node, [\"typing.overload\", \"overload\"]))\n1376 \n1377 \n1378 def is_protocol_class(cls: astroid.node_classes.NodeNG) -> bool:\n1379     \"\"\"Check if the given node represents a protocol class\n1380 \n1381     :param cls: The node to check\n1382     :returns: True if the node is a typing protocol class, false otherwise.\n1383     \"\"\"\n1384     if not isinstance(cls, astroid.ClassDef):\n1385         return False\n1386 \n1387     # Use .ancestors() since not all protocol classes can have\n1388     # their mro deduced.\n1389     return any(parent.qname() in TYPING_PROTOCOLS for parent in cls.ancestors())\n1390 \n1391 \n1392 def is_call_of_name(node: astroid.node_classes.NodeNG, name: str) -> bool:\n1393     \"\"\"Checks if node is a function call with the given name\"\"\"\n1394     return (\n1395         isinstance(node, astroid.Call)\n1396         and isinstance(node.func, astroid.Name)\n1397         and node.func.name == name\n1398     )\n1399 \n1400 \n1401 def is_test_condition(\n1402     node: astroid.node_classes.NodeNG,\n1403     parent: Optional[astroid.node_classes.NodeNG] = None,\n1404 ) -> bool:\n1405     \"\"\"Returns true if the given node is being tested for truthiness\"\"\"\n1406     parent = parent or node.parent\n1407     if isinstance(parent, (astroid.While, astroid.If, astroid.IfExp, astroid.Assert)):\n1408         return node is parent.test or parent.test.parent_of(node)\n1409     if isinstance(parent, astroid.Comprehension):\n1410         return node in parent.ifs\n1411     return is_call_of_name(parent, \"bool\") and parent.parent_of(node)\n1412 \n1413 \n1414 def is_classdef_type(node: astroid.ClassDef) -> bool:\n1415     \"\"\"Test if ClassDef node is Type.\"\"\"\n1416     if node.name == \"type\":\n1417         return True\n1418     for base in node.bases:\n1419         if isinstance(base, astroid.Name) and base.name == \"type\":\n1420             return True\n1421     return False\n1422 \n1423 \n1424 def is_attribute_typed_annotation(\n1425     node: Union[astroid.ClassDef, astroid.Instance], attr_name: str\n1426 ) -> bool:\n1427     \"\"\"Test if attribute is typed annotation in current node\n1428     or any base nodes.\n1429     \"\"\"\n1430     attribute = node.locals.get(attr_name, [None])[0]\n1431     if (\n1432         attribute\n1433         and isinstance(attribute, astroid.AssignName)\n1434         and isinstance(attribute.parent, astroid.AnnAssign)\n1435     ):\n1436         return True\n1437     for base in node.bases:\n1438         inferred = safe_infer(base)\n1439         if (\n1440             inferred\n1441             and isinstance(inferred, astroid.ClassDef)\n1442             and is_attribute_typed_annotation(inferred, attr_name)\n1443         ):\n1444             return True\n1445     return False\n1446 \n1447 \n1448 def is_assign_name_annotated_with(node: astroid.AssignName, typing_name: str) -> bool:\n1449     \"\"\"Test if AssignName node has `typing_name` annotation.\n1450 \n1451     Especially useful to check for `typing._SpecialForm` instances\n1452     like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.\n1453     \"\"\"\n1454     if not isinstance(node.parent, astroid.AnnAssign):\n1455         return False\n1456     annotation = node.parent.annotation\n1457     if isinstance(annotation, astroid.Subscript):\n1458         annotation = annotation.value\n1459     if (\n1460         isinstance(annotation, astroid.Name)\n1461         and annotation.name == typing_name\n1462         or isinstance(annotation, astroid.Attribute)\n1463         and annotation.attrname == typing_name\n1464     ):\n1465         return True\n1466     return False\n1467 \n1468 \n1469 def get_iterating_dictionary_name(\n1470     node: Union[astroid.For, astroid.Comprehension]\n1471 ) -> Optional[str]:\n1472     \"\"\"Get the name of the dictionary which keys are being iterated over on\n1473     a `astroid.For` or `astroid.Comprehension` node.\n1474 \n1475     If the iterating object is not either the keys method of a dictionary\n1476     or a dictionary itself, this returns None.\n1477     \"\"\"\n1478     # Is it a proper keys call?\n1479     if (\n1480         isinstance(node.iter, astroid.Call)\n1481         and isinstance(node.iter.func, astroid.Attribute)\n1482         and node.iter.func.attrname == \"keys\"\n1483     ):\n1484         inferred = safe_infer(node.iter.func)\n1485         if not isinstance(inferred, astroid.BoundMethod):\n1486             return None\n1487         return node.iter.as_string().rpartition(\".keys\")[0]\n1488 \n1489     # Is it a dictionary?\n1490     if isinstance(node.iter, (astroid.Name, astroid.Attribute)):\n1491         inferred = safe_infer(node.iter)\n1492         if not isinstance(inferred, astroid.Dict):\n1493             return None\n1494         return node.iter.as_string()\n1495 \n1496     return None\n1497 \n1498 \n1499 def get_subscript_const_value(node: astroid.Subscript) -> astroid.Const:\n1500     \"\"\"\n1501     Returns the value 'subscript.slice' of a Subscript node.\n1502 \n1503     :param node: Subscript Node to extract value from\n1504     :returns: Const Node containing subscript value\n1505     :raises InferredTypeError: if the subscript node cannot be inferred as a Const\n1506     \"\"\"\n1507     inferred = safe_infer(node.slice)\n1508     if not isinstance(inferred, astroid.Const):\n1509         raise InferredTypeError(\n1510             \"Subscript.slice cannot be inferred as an astroid.Const\"\n1511         )\n1512 \n1513     return inferred\n",
        "intended_behavior": "Modify or enhance the utility function to parse type comments for imports and mark those imports as utilized if found within '# type:' comments. This should preserve the existing functionality of identifying unused imports while also recognizing imports used in type comments as valid usage."
    },
    {
        "rel_file_path": "pylint/lint/run.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.9/pylint/lint/run.py",
        "start": 1,
        "end": 478,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE\n3 \n4 import os\n5 import sys\n6 import warnings\n7 \n8 from pylint import __pkginfo__, config, extensions, interfaces\n9 from pylint.constants import full_version\n10 from pylint.lint.pylinter import PyLinter\n11 from pylint.lint.utils import ArgumentPreprocessingError, preprocess_options\n12 from pylint.utils import utils\n13 \n14 try:\n15     import multiprocessing\n16 except ImportError:\n17     multiprocessing = None  # type: ignore\n18 \n19 \n20 def _cpu_count() -> int:\n21     \"\"\"Use sched_affinity if available for virtualized or containerized environments.\"\"\"\n22     sched_getaffinity = getattr(os, \"sched_getaffinity\", None)\n23     # pylint: disable=not-callable,using-constant-test\n24     if sched_getaffinity:\n25         return len(sched_getaffinity(0))\n26     if multiprocessing:\n27         return multiprocessing.cpu_count()\n28     return 1\n29 \n30 \n31 def cb_list_extensions(option, optname, value, parser):\n32     \"\"\"List all the extensions under pylint.extensions\"\"\"\n33 \n34     for filename in os.listdir(os.path.dirname(extensions.__file__)):\n35         if filename.endswith(\".py\") and not filename.startswith(\"_\"):\n36             extension_name, _, _ = filename.partition(\".\")\n37             print(f\"pylint.extensions.{extension_name}\")\n38     sys.exit(0)\n39 \n40 \n41 def cb_list_confidence_levels(option, optname, value, parser):\n42     for level in interfaces.CONFIDENCE_LEVELS:\n43         print(\"%-18s: %s\" % level)\n44     sys.exit(0)\n45 \n46 \n47 def cb_init_hook(optname, value):\n48     \"\"\"exec arbitrary code to set sys.path for instance\"\"\"\n49     exec(value)  # pylint: disable=exec-used\n50 \n51 \n52 UNUSED_PARAM_SENTINEL = object()\n53 \n54 \n55 class Run:\n56     \"\"\"helper class to use as main for pylint :\n57 \n58     run(*sys.argv[1:])\n59     \"\"\"\n60 \n61     LinterClass = PyLinter\n62     option_groups = (\n63         (\n64             \"Commands\",\n65             \"Options which are actually commands. Options in this \\\n66 group are mutually exclusive.\",\n67         ),\n68     )\n69 \n70     @staticmethod\n71     def _return_one(*args):  # pylint: disable=unused-argument\n72         return 1\n73 \n74     def __init__(\n75         self,\n76         args,\n77         reporter=None,\n78         exit=True,\n79         do_exit=UNUSED_PARAM_SENTINEL,\n80     ):  # pylint: disable=redefined-builtin\n81         self._rcfile = None\n82         self._output = None\n83         self._version_asked = False\n84         self._plugins = []\n85         self.verbose = None\n86         try:\n87             preprocess_options(\n88                 args,\n89                 {\n90                     # option: (callback, takearg)\n91                     \"version\": (self.version_asked, False),\n92                     \"init-hook\": (cb_init_hook, True),\n93                     \"rcfile\": (self.cb_set_rcfile, True),\n94                     \"load-plugins\": (self.cb_add_plugins, True),\n95                     \"verbose\": (self.cb_verbose_mode, False),\n96                     \"output\": (self.cb_set_output, True),\n97                 },\n98             )\n99         except ArgumentPreprocessingError as ex:\n100             print(ex, file=sys.stderr)\n101             sys.exit(32)\n102 \n103         self.linter = linter = self.LinterClass(\n104             (\n105                 (\n106                     \"rcfile\",\n107                     {\n108                         \"action\": \"callback\",\n109                         \"callback\": Run._return_one,\n110                         \"group\": \"Commands\",\n111                         \"type\": \"string\",\n112                         \"metavar\": \"<file>\",\n113                         \"help\": \"Specify a configuration file to load.\",\n114                     },\n115                 ),\n116                 (\n117                     \"output\",\n118                     {\n119                         \"action\": \"callback\",\n120                         \"callback\": Run._return_one,\n121                         \"group\": \"Commands\",\n122                         \"type\": \"string\",\n123                         \"metavar\": \"<file>\",\n124                         \"help\": \"Specify an output file.\",\n125                     },\n126                 ),\n127                 (\n128                     \"init-hook\",\n129                     {\n130                         \"action\": \"callback\",\n131                         \"callback\": Run._return_one,\n132                         \"type\": \"string\",\n133                         \"metavar\": \"<code>\",\n134                         \"level\": 1,\n135                         \"help\": \"Python code to execute, usually for sys.path \"\n136                         \"manipulation such as pygtk.require().\",\n137                     },\n138                 ),\n139                 (\n140                     \"help-msg\",\n141                     {\n142                         \"action\": \"callback\",\n143                         \"type\": \"string\",\n144                         \"metavar\": \"<msg-id>\",\n145                         \"callback\": self.cb_help_message,\n146                         \"group\": \"Commands\",\n147                         \"help\": \"Display a help message for the given message id and \"\n148                         \"exit. The value may be a comma separated list of message ids.\",\n149                     },\n150                 ),\n151                 (\n152                     \"list-msgs\",\n153                     {\n154                         \"action\": \"callback\",\n155                         \"metavar\": \"<msg-id>\",\n156                         \"callback\": self.cb_list_messages,\n157                         \"group\": \"Commands\",\n158                         \"level\": 1,\n159                         \"help\": \"Generate pylint's messages.\",\n160                     },\n161                 ),\n162                 (\n163                     \"list-msgs-enabled\",\n164                     {\n165                         \"action\": \"callback\",\n166                         \"metavar\": \"<msg-id>\",\n167                         \"callback\": self.cb_list_messages_enabled,\n168                         \"group\": \"Commands\",\n169                         \"level\": 1,\n170                         \"help\": \"Display a list of what messages are enabled \"\n171                         \"and disabled with the given configuration.\",\n172                     },\n173                 ),\n174                 (\n175                     \"list-groups\",\n176                     {\n177                         \"action\": \"callback\",\n178                         \"metavar\": \"<msg-id>\",\n179                         \"callback\": self.cb_list_groups,\n180                         \"group\": \"Commands\",\n181                         \"level\": 1,\n182                         \"help\": \"List pylint's message groups.\",\n183                     },\n184                 ),\n185                 (\n186                     \"list-conf-levels\",\n187                     {\n188                         \"action\": \"callback\",\n189                         \"callback\": cb_list_confidence_levels,\n190                         \"group\": \"Commands\",\n191                         \"level\": 1,\n192                         \"help\": \"Generate pylint's confidence levels.\",\n193                     },\n194                 ),\n195                 (\n196                     \"list-extensions\",\n197                     {\n198                         \"action\": \"callback\",\n199                         \"callback\": cb_list_extensions,\n200                         \"group\": \"Commands\",\n201                         \"level\": 1,\n202                         \"help\": \"List available extensions.\",\n203                     },\n204                 ),\n205                 (\n206                     \"full-documentation\",\n207                     {\n208                         \"action\": \"callback\",\n209                         \"metavar\": \"<msg-id>\",\n210                         \"callback\": self.cb_full_documentation,\n211                         \"group\": \"Commands\",\n212                         \"level\": 1,\n213                         \"help\": \"Generate pylint's full documentation.\",\n214                     },\n215                 ),\n216                 (\n217                     \"generate-rcfile\",\n218                     {\n219                         \"action\": \"callback\",\n220                         \"callback\": self.cb_generate_config,\n221                         \"group\": \"Commands\",\n222                         \"help\": \"Generate a sample configuration file according to \"\n223                         \"the current configuration. You can put other options \"\n224                         \"before this one to get them in the generated \"\n225                         \"configuration.\",\n226                     },\n227                 ),\n228                 (\n229                     \"generate-man\",\n230                     {\n231                         \"action\": \"callback\",\n232                         \"callback\": self.cb_generate_manpage,\n233                         \"group\": \"Commands\",\n234                         \"help\": \"Generate pylint's man page.\",\n235                         \"hide\": True,\n236                     },\n237                 ),\n238                 (\n239                     \"errors-only\",\n240                     {\n241                         \"action\": \"callback\",\n242                         \"callback\": self.cb_error_mode,\n243                         \"short\": \"E\",\n244                         \"help\": \"In error mode, checkers without error messages are \"\n245                         \"disabled and for others, only the ERROR messages are \"\n246                         \"displayed, and no reports are done by default.\",\n247                     },\n248                 ),\n249                 (\n250                     \"py3k\",\n251                     {\n252                         \"action\": \"callback\",\n253                         \"callback\": self.cb_python3_porting_mode,\n254                         \"help\": \"In Python 3 porting mode, all checkers will be \"\n255                         \"disabled and only messages emitted by the porting \"\n256                         \"checker will be displayed.\",\n257                     },\n258                 ),\n259                 (\n260                     \"verbose\",\n261                     {\n262                         \"action\": \"callback\",\n263                         \"callback\": self.cb_verbose_mode,\n264                         \"short\": \"v\",\n265                         \"help\": \"In verbose mode, extra non-checker-related info \"\n266                         \"will be displayed.\",\n267                     },\n268                 ),\n269             ),\n270             option_groups=self.option_groups,\n271             pylintrc=self._rcfile,\n272         )\n273         # register standard checkers\n274         if self._version_asked:\n275             print(full_version)\n276             sys.exit(0)\n277         linter.load_default_plugins()\n278         # load command line plugins\n279         linter.load_plugin_modules(self._plugins)\n280         # add some help section\n281         linter.add_help_section(\"Environment variables\", config.ENV_HELP, level=1)\n282         linter.add_help_section(\n283             \"Output\",\n284             \"Using the default text output, the message format is :                          \\n\"\n285             \"                                                                                \\n\"\n286             \"        MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE                                \\n\"\n287             \"                                                                                \\n\"\n288             \"There are 5 kind of message types :                                             \\n\"\n289             \"    * (C) convention, for programming standard violation                        \\n\"\n290             \"    * (R) refactor, for bad code smell                                          \\n\"\n291             \"    * (W) warning, for python specific problems                                 \\n\"\n292             \"    * (E) error, for probable bugs in the code                                  \\n\"\n293             \"    * (F) fatal, if an error occurred which prevented pylint from doing further\\n\"\n294             \"processing.\\n\",\n295             level=1,\n296         )\n297         linter.add_help_section(\n298             \"Output status code\",\n299             \"Pylint should leave with following status code:                                 \\n\"\n300             \"    * 0 if everything went fine                                                 \\n\"\n301             \"    * 1 if a fatal message was issued                                           \\n\"\n302             \"    * 2 if an error message was issued                                          \\n\"\n303             \"    * 4 if a warning message was issued                                         \\n\"\n304             \"    * 8 if a refactor message was issued                                        \\n\"\n305             \"    * 16 if a convention message was issued                                     \\n\"\n306             \"    * 32 on usage error                                                         \\n\"\n307             \"                                                                                \\n\"\n308             \"status 1 to 16 will be bit-ORed so you can know which different categories has\\n\"\n309             \"been issued by analysing pylint output status code\\n\",\n310             level=1,\n311         )\n312         # read configuration\n313         linter.disable(\"I\")\n314         linter.enable(\"c-extension-no-member\")\n315         try:\n316             linter.read_config_file(verbose=self.verbose)\n317         except OSError as ex:\n318             print(ex, file=sys.stderr)\n319             sys.exit(32)\n320 \n321         config_parser = linter.cfgfile_parser\n322         # run init hook, if present, before loading plugins\n323         if config_parser.has_option(\"MASTER\", \"init-hook\"):\n324             cb_init_hook(\n325                 \"init-hook\", utils._unquote(config_parser.get(\"MASTER\", \"init-hook\"))\n326             )\n327         # is there some additional plugins in the file configuration, in\n328         if config_parser.has_option(\"MASTER\", \"load-plugins\"):\n329             plugins = utils._splitstrip(config_parser.get(\"MASTER\", \"load-plugins\"))\n330             linter.load_plugin_modules(plugins)\n331         # now we can load file config and command line, plugins (which can\n332         # provide options) have been registered\n333         linter.load_config_file()\n334 \n335         if reporter:\n336             # if a custom reporter is provided as argument, it may be overridden\n337             # by file parameters, so re-set it here, but before command line\n338             # parsing so it's still overrideable by command line option\n339             linter.set_reporter(reporter)\n340         try:\n341             args = linter.load_command_line_configuration(args)\n342         except SystemExit as exc:\n343             if exc.code == 2:  # bad options\n344                 exc.code = 32\n345             raise\n346         if not args:\n347             print(linter.help())\n348             sys.exit(32)\n349 \n350         if linter.config.jobs < 0:\n351             print(\n352                 \"Jobs number (%d) should be greater than or equal to 0\"\n353                 % linter.config.jobs,\n354                 file=sys.stderr,\n355             )\n356             sys.exit(32)\n357         if linter.config.jobs > 1 or linter.config.jobs == 0:\n358             if multiprocessing is None:\n359                 print(\n360                     \"Multiprocessing library is missing, fallback to single process\",\n361                     file=sys.stderr,\n362                 )\n363                 linter.set_option(\"jobs\", 1)\n364             elif linter.config.jobs == 0:\n365                 linter.config.jobs = _cpu_count()\n366 \n367         # We have loaded configuration from config file and command line. Now, we can\n368         # load plugin specific configuration.\n369         linter.load_plugin_configuration()\n370 \n371         # Now that plugins are loaded, get list of all fail_on messages, and enable them\n372         linter.enable_fail_on_messages()\n373 \n374         if self._output:\n375             try:\n376                 with open(self._output, \"w\") as output:\n377                     linter.reporter.set_output(output)\n378                     linter.check(args)\n379                     score_value = linter.generate_reports()\n380             except OSError as ex:\n381                 print(ex, file=sys.stderr)\n382                 sys.exit(32)\n383         else:\n384             linter.check(args)\n385             score_value = linter.generate_reports()\n386 \n387         if do_exit is not UNUSED_PARAM_SENTINEL:\n388             warnings.warn(\n389                 \"do_exit is deprecated and it is going to be removed in a future version.\",\n390                 DeprecationWarning,\n391             )\n392             exit = do_exit\n393 \n394         if exit:\n395             if linter.config.exit_zero:\n396                 sys.exit(0)\n397             else:\n398                 if (\n399                     score_value\n400                     and score_value >= linter.config.fail_under\n401                     # detected messages flagged by --fail-on prevent non-zero exit code\n402                     and not linter.any_fail_on_issues()\n403                 ):\n404                     sys.exit(0)\n405                 sys.exit(self.linter.msg_status)\n406 \n407     def version_asked(self, _, __):\n408         \"\"\"callback for version (i.e. before option parsing)\"\"\"\n409         self._version_asked = True\n410 \n411     def cb_set_rcfile(self, name, value):\n412         \"\"\"callback for option preprocessing (i.e. before option parsing)\"\"\"\n413         self._rcfile = value\n414 \n415     def cb_set_output(self, name, value):\n416         \"\"\"callback for option preprocessing (i.e. before option parsing)\"\"\"\n417         self._output = value\n418 \n419     def cb_add_plugins(self, name, value):\n420         \"\"\"callback for option preprocessing (i.e. before option parsing)\"\"\"\n421         self._plugins.extend(utils._splitstrip(value))\n422 \n423     def cb_error_mode(self, *args, **kwargs):\n424         \"\"\"error mode:\n425         * disable all but error messages\n426         * disable the 'miscellaneous' checker which can be safely deactivated in\n427           debug\n428         * disable reports\n429         * do not save execution information\n430         \"\"\"\n431         self.linter.error_mode()\n432 \n433     def cb_generate_config(self, *args, **kwargs):\n434         \"\"\"optik callback for sample config file generation\"\"\"\n435         self.linter.generate_config(skipsections=(\"COMMANDS\",))\n436         sys.exit(0)\n437 \n438     def cb_generate_manpage(self, *args, **kwargs):\n439         \"\"\"optik callback for sample config file generation\"\"\"\n440         self.linter.generate_manpage(__pkginfo__)\n441         sys.exit(0)\n442 \n443     def cb_help_message(self, option, optname, value, parser):\n444         \"\"\"optik callback for printing some help about a particular message\"\"\"\n445         self.linter.msgs_store.help_message(utils._splitstrip(value))\n446         sys.exit(0)\n447 \n448     def cb_full_documentation(self, option, optname, value, parser):\n449         \"\"\"optik callback for printing full documentation\"\"\"\n450         self.linter.print_full_documentation()\n451         sys.exit(0)\n452 \n453     def cb_list_messages(self, option, optname, value, parser):\n454         \"\"\"optik callback for printing available messages\"\"\"\n455         self.linter.msgs_store.list_messages()\n456         sys.exit(0)\n457 \n458     def cb_list_messages_enabled(self, option, optname, value, parser):\n459         \"\"\"optik callback for printing available messages\"\"\"\n460         self.linter.list_messages_enabled()\n461         sys.exit(0)\n462 \n463     def cb_list_groups(self, *args, **kwargs):\n464         \"\"\"List all the check groups that pylint knows about\n465 \n466         These should be useful to know what check groups someone can disable\n467         or enable.\n468         \"\"\"\n469         for check in self.linter.get_checker_names():\n470             print(check)\n471         sys.exit(0)\n472 \n473     def cb_python3_porting_mode(self, *args, **kwargs):\n474         \"\"\"Activate only the python3 porting checker.\"\"\"\n475         self.linter.python3_porting_mode()\n476 \n477     def cb_verbose_mode(self, *args, **kwargs):\n478         self.verbose = True\n",
        "intended_behavior": "Ensure that during the linting process, the improved logic from 'utils.py' (or wherever else appropriate) is effectively employed to recognize imports used in type comments. This may involve ensuring that the data about used imports includes those found within type comments before finalizing the unused imports report."
    }
]