2025-10-15 22:13:41.665 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 22:13:43.162 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=288, output_tokens=12, cost=0.003240
2025-10-15 22:13:51.529 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=468, output_tokens=348, cost=0.015120
2025-10-15 22:13:52.513 | INFO     | registered non reproducing test 0
2025-10-15 22:14:07.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1386, output_tokens=715, cost=0.035310
2025-10-15 22:14:08.093 | INFO     | registered non reproducing test 1
2025-10-15 22:14:26.302 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1500, output_tokens=751, cost=0.037530
2025-10-15 22:14:27.272 | INFO     | registered non reproducing test 2
2025-10-15 22:14:27.272 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 22:14:27.275 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:14:36.996 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=595, output_tokens=379, cost=0.017320
2025-10-15 22:14:37.000 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:14:39.633 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=733, output_tokens=44, cost=0.008650
2025-10-15 22:14:39.634 | DEBUG    | Extracted a valid json.
2025-10-15 22:14:39.634 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"unused-import\")",
        "search_code(\"type comments\")",
        "search_code(\"# type:\")"
    ],
    "bug_locations": []
}
2025-10-15 22:14:39.651 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 22:14:39.652 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 22:14:55.696 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1364, output_tokens=629, cost=0.032510
2025-10-15 22:14:55.703 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 22:15:04.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2209, output_tokens=394, cost=0.033910
2025-10-15 22:15:04.580 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 22:15:10.718 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=187, cost=0.013090
2025-10-15 22:15:10.719 | DEBUG    | Extracted a valid json.
2025-10-15 22:15:10.719 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/checkers/utils.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify or enhance the utility function to parse type comments for imports and mark those imports as utilized if found within '# type:' comments. This should preserve the existing functionality of identifying unused imports while also recognizing imports used in type comments as valid usage."
        },
        {
            "file": "pylint/lint/run.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that during the linting process, the improved logic from 'utils.py' (or wherever else appropriate) is effectively employed to recognize imports used in type comments. This may involve ensuring that the data about used imports includes those found within type comments before finalizing the unused imports report."
        }
    ]
}
2025-10-15 22:15:10.727 | DEBUG    | Bug location extracted successfully: [<file>pylint/checkers/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006-2007, 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2009 Mads Kiilerich <mads@kiilerich.com>
3 # Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
4 # Copyright (c) 2012-2014 Google, Inc.
5 # Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
6 # Copyright (c) 2013-2020 Claudiu Popa <pcmanticore@gmail.com>
7 # Copyright (c) 2014 Brett Cannon <brett@python.org>
8 # Copyright (c) 2014 Ricardo Gemignani <ricardo.gemignani@gmail.com>
9 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
10 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
11 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
12 # Copyright (c) 2015 Radu Ciorba <radu@devrandom.ro>
13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
14 # Copyright (c) 2016, 2018-2019 Ashley Whetter <ashley@awhetter.co.uk>
15 # Copyright (c) 2016-2017 Łukasz Rogalski <rogalski.91@gmail.com>
16 # Copyright (c) 2016-2017 Moises Lopez <moylop260@vauxoo.com>
17 # Copyright (c) 2016 Brian C. Lane <bcl@redhat.com>
18 # Copyright (c) 2017-2018, 2020 hippo91 <guillaume.peillex@gmail.com>
19 # Copyright (c) 2017 ttenhoeve-aa <ttenhoeve@appannie.com>
20 # Copyright (c) 2018 Alan Chan <achan961117@gmail.com>
21 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
22 # Copyright (c) 2018 Yury Gribov <tetra2005@gmail.com>
23 # Copyright (c) 2018 Caio Carrara <ccarrara@redhat.com>
24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
25 # Copyright (c) 2018 Bryce Guinta <bryce.guinta@protonmail.com>
26 # Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
27 # Copyright (c) 2018 Ville Skyttä <ville.skytta@iki.fi>
28 # Copyright (c) 2018 Brian Shaginaw <brian.shaginaw@warbyparker.com>
29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
30 # Copyright (c) 2019 Matthijs Blom <19817960+MatthijsBlom@users.noreply.github.com>
31 # Copyright (c) 2019 Djailla <bastien.vallet@gmail.com>
32 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>
33 # Copyright (c) 2019 Nathan Marrow <nmarrow@google.com>
34 # Copyright (c) 2019 Svet <svet@hyperscience.com>
35 # Copyright (c) 2019 Pascal Corpet <pcorpet@users.noreply.github.com>
36 # Copyright (c) 2020 Batuhan Taskaya <batuhanosmantaskaya@gmail.com>
37 # Copyright (c) 2020 Luigi <luigi.cristofolini@q-ctrl.com>
38 # Copyright (c) 2020 ethan-leba <ethanleba5@gmail.com>
39 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>
40 # Copyright (c) 2020 Andrew Simmons <anjsimmo@gmail.com>
41 # Copyright (c) 2020 Ram Rachum <ram@rachum.com>
42 # Copyright (c) 2020 Slavfox <slavfoxman@gmail.com>
43 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
44 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>
45 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>
46 
47 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
48 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
49 
50 """some functions that may be useful for various checkers
51 """
52 import builtins
53 import itertools
54 import numbers
55 import re
56 import string
57 from functools import lru_cache, partial
58 from typing import (
59     Any,
60     Callable,
61     Dict,
62     Iterable,
63     List,
64     Match,
65     Optional,
66     Set,
67     Tuple,
68     Union,
69 )
70 
71 import _string
72 import astroid
73 
74 BUILTINS_NAME = builtins.__name__
75 COMP_NODE_TYPES = (
76     astroid.ListComp,
77     astroid.SetComp,
78     astroid.DictComp,
79     astroid.GeneratorExp,
80 )
81 EXCEPTIONS_MODULE = "builtins"
82 ABC_MODULES = {"abc", "_py_abc"}
83 ABC_METHODS = {
84     "abc.abstractproperty",
85     "abc.abstractmethod",
86     "abc.abstractclassmethod",
87     "abc.abstractstaticmethod",
88 }
89 TYPING_PROTOCOLS = frozenset(
90     {"typing.Protocol", "typing_extensions.Protocol", ".Protocol"}
91 )
92 ITER_METHOD = "__iter__"
93 AITER_METHOD = "__aiter__"
94 NEXT_METHOD = "__next__"
95 GETITEM_METHOD = "__getitem__"
96 CLASS_GETITEM_METHOD = "__class_getitem__"
97 SETITEM_METHOD = "__setitem__"
98 DELITEM_METHOD = "__delitem__"
99 CONTAINS_METHOD = "__contains__"
100 KEYS_METHOD = "keys"
101 
102 # Dictionary which maps the number of expected parameters a
103 # special method can have to a set of special methods.
104 # The following keys are used to denote the parameters restrictions:
105 #
106 # * None: variable number of parameters
107 # * number: exactly that number of parameters
108 # * tuple: this are the odd ones. Basically it means that the function
109 #          can work with any number of arguments from that tuple,
110 #          although it's best to implement it in order to accept
111 #          all of them.
112 _SPECIAL_METHODS_PARAMS = {
113     None: ("__new__", "__init__", "__call__"),
114     0: (
115         "__del__",
116         "__repr__",
117         "__str__",
118         "__bytes__",
119         "__hash__",
120         "__bool__",
121         "__dir__",
122         "__len__",
123         "__length_hint__",
124         "__iter__",
125         "__reversed__",
126         "__neg__",
127         "__pos__",
128         "__abs__",
129         "__invert__",
130         "__complex__",
131         "__int__",
132         "__float__",
133         "__index__",
134         "__trunc__",
135         "__floor__",
136         "__ceil__",
137         "__enter__",
138         "__aenter__",
139         "__getnewargs_ex__",
140         "__getnewargs__",
141         "__getstate__",
142         "__reduce__",
143         "__copy__",
144         "__unicode__",
145         "__nonzero__",
146         "__await__",
147         "__aiter__",
148         "__anext__",
149         "__fspath__",
150     ),
151     1: (
152         "__format__",
153         "__lt__",
154         "__le__",
155         "__eq__",
156         "__ne__",
157         "__gt__",
158         "__ge__",
159         "__getattr__",
160         "__getattribute__",
161         "__delattr__",
162         "__delete__",
163         "__instancecheck__",
164         "__subclasscheck__",
165         "__getitem__",
166         "__missing__",
167         "__delitem__",
168         "__contains__",
169         "__add__",
170         "__sub__",
171         "__mul__",
172         "__truediv__",
173         "__floordiv__",
174         "__rfloordiv__",
175         "__mod__",
176         "__divmod__",
177         "__lshift__",
178         "__rshift__",
179         "__and__",
180         "__xor__",
181         "__or__",
182         "__radd__",
183         "__rsub__",
184         "__rmul__",
185         "__rtruediv__",
186         "__rmod__",
187         "__rdivmod__",
188         "__rpow__",
189         "__rlshift__",
190         "__rrshift__",
191         "__rand__",
192         "__rxor__",
193         "__ror__",
194         "__iadd__",
195         "__isub__",
196         "__imul__",
197         "__itruediv__",
198         "__ifloordiv__",
199         "__imod__",
200         "__ilshift__",
201         "__irshift__",
202         "__iand__",
203         "__ixor__",
204         "__ior__",
205         "__ipow__",
206         "__setstate__",
207         "__reduce_ex__",
208         "__deepcopy__",
209         "__cmp__",
210         "__matmul__",
211         "__rmatmul__",
212         "__imatmul__",
213         "__div__",
214     ),
215     2: ("__setattr__", "__get__", "__set__", "__setitem__", "__set_name__"),
216     3: ("__exit__", "__aexit__"),
217     (0, 1): ("__round__",),
218     (1, 2): ("__pow__",),
219 }
220 
221 SPECIAL_METHODS_PARAMS = {
222     name: params
223     for params, methods in _SPECIAL_METHODS_PARAMS.items()
224     for name in methods  # type: ignore
225 }
226 PYMETHODS = set(SPECIAL_METHODS_PARAMS)
227 
228 SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(
229     (
230         "builtins.tuple",
231         "builtins.list",
232         "builtins.dict",
233         "builtins.set",
234         "builtins.frozenset",
235         "builtins.type",
236         "collections.deque",
237         "collections.defaultdict",
238         "collections.OrderedDict",
239         "collections.Counter",
240         "collections.ChainMap",
241         "_collections_abc.Awaitable",
242         "_collections_abc.Coroutine",
243         "_collections_abc.AsyncIterable",
244         "_collections_abc.AsyncIterator",
245         "_collections_abc.AsyncGenerator",
246         "_collections_abc.Iterable",
247         "_collections_abc.Iterator",
248         "_collections_abc.Generator",
249         "_collections_abc.Reversible",
250         "_collections_abc.Container",
251         "_collections_abc.Collection",
252         "_collections_abc.Callable",
253         "_collections_abc.Set",
254         "_collections_abc.MutableSet",
255         "_collections_abc.Mapping",
256         "_collections_abc.MutableMapping",
257         "_collections_abc.Sequence",
258         "_collections_abc.MutableSequence",
259         "_collections_abc.ByteString",
260         "_collections_abc.MappingView",
261         "_collections_abc.KeysView",
262         "_collections_abc.ItemsView",
263         "_collections_abc.ValuesView",
264         "contextlib.AbstractContextManager",
265         "contextlib.AbstractAsyncContextManager",
266         "re.Pattern",
267         "re.Match",
268     )
269 )
270 
271 
272 class NoSuchArgumentError(Exception):
273     pass
274 
275 
276 class InferredTypeError(Exception):
277     pass
278 
279 
280 def is_inside_lambda(node: astroid.node_classes.NodeNG) -> bool:
281     """Return true if given node is inside lambda"""
282     parent = node.parent
283     while parent is not None:
284         if isinstance(parent, astroid.Lambda):
285             return True
286         parent = parent.parent
287     return False
288 
289 
290 def get_all_elements(
291     node: astroid.node_classes.NodeNG,
292 ) -> Iterable[astroid.node_classes.NodeNG]:
293     """Recursively returns all atoms in nested lists and tuples."""
294     if isinstance(node, (astroid.Tuple, astroid.List)):
295         for child in node.elts:
296             yield from get_all_elements(child)
297     else:
298         yield node
299 
300 
301 def is_super(node: astroid.node_classes.NodeNG) -> bool:
302     """return True if the node is referencing the "super" builtin function"""
303     if getattr(node, "name", None) == "super" and node.root().name == BUILTINS_NAME:
304         return True
305     return False
306 
307 
308 def is_error(node: astroid.scoped_nodes.FunctionDef) -> bool:
309     """Return true if the given function node only raises an exception"""
310     return len(node.body) == 1 and isinstance(node.body[0], astroid.Raise)
311 
312 
313 builtins = builtins.__dict__.copy()  # type: ignore
314 SPECIAL_BUILTINS = ("__builtins__",)  # '__path__', '__file__')
315 
316 
317 def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool:
318     """Returns True if the given node is an object from the __builtin__ module."""
319     return node and node.root().name == BUILTINS_NAME
320 
321 
322 def is_builtin(name: str) -> bool:
323     """return true if <name> could be considered as a builtin defined by python"""
324     return name in builtins or name in SPECIAL_BUILTINS  # type: ignore
325 
326 
327 def is_defined_in_scope(
328     var_node: astroid.node_classes.NodeNG,
329     varname: str,
330     scope: astroid.node_classes.NodeNG,
331 ) -> bool:
332     if isinstance(scope, astroid.If):
333         for node in scope.body:
334             if (
335                 isinstance(node, astroid.Assign)
336                 and any(
337                     isinstance(target, astroid.AssignName) and target.name == varname
338                     for target in node.targets
339                 )
340             ) or (isinstance(node, astroid.Nonlocal) and varname in node.names):
341                 return True
342     elif isinstance(scope, (COMP_NODE_TYPES, astroid.For)):
343         for ass_node in scope.nodes_of_class(astroid.AssignName):
344             if ass_node.name == varname:
345                 return True
346     elif isinstance(scope, astroid.With):
347         for expr, ids in scope.items:
348             if expr.parent_of(var_node):
349                 break
350             if ids and isinstance(ids, astroid.AssignName) and ids.name == varname:
351                 return True
352     elif isinstance(scope, (astroid.Lambda, astroid.FunctionDef)):
353         if scope.args.is_argument(varname):
354             # If the name is found inside a default value
355             # of a function, then let the search continue
356             # in the parent's tree.
357             if scope.args.parent_of(var_node):
358                 try:
359                     scope.args.default_value(varname)
360                     scope = scope.parent
361                     is_defined_in_scope(var_node, varname, scope)
362                 except astroid.NoDefault:
363                     pass
364             return True
365         if getattr(scope, "name", None) == varname:
366             return True
367     elif isinstance(scope, astroid.ExceptHandler):
368         if isinstance(scope.name, astroid.AssignName):
369             ass_node = scope.name
370             if ass_node.name == varname:
371                 return True
372     return False
373 
374 
375 def is_defined_before(var_node: astroid.Name) -> bool:
376     """Check if the given variable node is defined before
377 
378     Verify that the variable node is defined by a parent node
379     (list, set, dict, or generator comprehension, lambda)
380     or in a previous sibling node on the same line
381     (statement_defining ; statement_using).
382     """
383     varname = var_node.name
384     _node = var_node.parent
385     while _node:
386         if is_defined_in_scope(var_node, varname, _node):
387             return True
388         _node = _node.parent
389     # possibly multiple statements on the same line using semi colon separator
390     stmt = var_node.statement()
391     _node = stmt.previous_sibling()
392     lineno = stmt.fromlineno
393     while _node and _node.fromlineno == lineno:
394         for assign_node in _node.nodes_of_class(astroid.AssignName):
395             if assign_node.name == varname:
396                 return True
397         for imp_node in _node.nodes_of_class((astroid.ImportFrom, astroid.Import)):
398             if varname in [name[1] or name[0] for name in imp_node.names]:
399                 return True
400         _node = _node.previous_sibling()
401     return False
402 
403 
404 def is_default_argument(
405     node: astroid.node_classes.NodeNG,
406     scope: Optional[astroid.node_classes.NodeNG] = None,
407 ) -> bool:
408     """return true if the given Name node is used in function or lambda
409     default argument's value
410     """
411     if not scope:
412         scope = node.scope()
413     if isinstance(scope, (astroid.FunctionDef, astroid.Lambda)):
414         for default_node in scope.args.defaults:
415             for default_name_node in default_node.nodes_of_class(astroid.Name):
416                 if default_name_node is node:
417                     return True
418     return False
419 
420 
421 def is_func_decorator(node: astroid.node_classes.NodeNG) -> bool:
422     """return true if the name is used in function decorator"""
423     parent = node.parent
424     while parent is not None:
425         if isinstance(parent, astroid.Decorators):
426             return True
427         if parent.is_statement or isinstance(
428             parent,
429             (
430                 astroid.Lambda,
431                 astroid.scoped_nodes.ComprehensionScope,
432                 astroid.scoped_nodes.ListComp,
433             ),
434         ):
435             break
436         parent = parent.parent
437     return False
438 
439 
440 def is_ancestor_name(
441     frame: astroid.ClassDef, node: astroid.node_classes.NodeNG
442 ) -> bool:
443     """return True if `frame` is an astroid.Class node with `node` in the
444     subtree of its bases attribute
445     """
446     if not isinstance(frame, astroid.ClassDef):
447         return False
448     for base in frame.bases:
449         if node in base.nodes_of_class(astroid.Name):
450             return True
451     return False
452 
453 
454 def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:
455     """return the higher parent which is not an AssignName, Tuple or List node"""
456     while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):
457         node = node.parent
458     return node
459 
460 
461 def overrides_a_method(class_node: astroid.ClassDef, name: str) -> bool:
462     """return True if <name> is a method overridden from an ancestor"""
463     for ancestor in class_node.ancestors():
464         if name in ancestor and isinstance(ancestor[name], astroid.FunctionDef):
465             return True
466     return False
467 
468 
469 def check_messages(*messages: str) -> Callable:
470     """decorator to store messages that are handled by a checker method"""
471 
472     def store_messages(func):
473         func.checks_msgs = messages
474         return func
475 
476     return store_messages
477 
478 
479 class IncompleteFormatString(Exception):
480     """A format string ended in the middle of a format specifier."""
481 
482 
483 class UnsupportedFormatCharacter(Exception):
484     """A format character in a format string is not one of the supported
485     format characters."""
486 
487     def __init__(self, index):
488         Exception.__init__(self, index)
489         self.index = index
490 
491 
492 def parse_format_string(
493     format_string: str,
494 ) -> Tuple[Set[str], int, Dict[str, str], List[str]]:
495     """Parses a format string, returning a tuple of (keys, num_args), where keys
496     is the set of mapping keys in the format string, and num_args is the number
497     of arguments required by the format string.  Raises
498     IncompleteFormatString or UnsupportedFormatCharacter if a
499     parse error occurs."""
500     keys = set()
501     key_types = dict()
502     pos_types = []
503     num_args = 0
504 
505     def next_char(i):
506         i += 1
507         if i == len(format_string):
508             raise IncompleteFormatString
509         return (i, format_string[i])
510 
511     i = 0
512     while i < len(format_string):
513         char = format_string[i]
514         if char == "%":
515             i, char = next_char(i)
516             # Parse the mapping key (optional).
517             key = None
518             if char == "(":
519                 depth = 1
520                 i, char = next_char(i)
521                 key_start = i
522                 while depth != 0:
523                     if char == "(":
524                         depth += 1
525                     elif char == ")":
526                         depth -= 1
527                     i, char = next_char(i)
528                 key_end = i - 1
529                 key = format_string[key_start:key_end]
530 
531             # Parse the conversion flags (optional).
532             while char in "#0- +":
533                 i, char = next_char(i)
534             # Parse the minimum field width (optional).
535             if char == "*":
536                 num_args += 1
537                 i, char = next_char(i)
538             else:
539                 while char in string.digits:
540                     i, char = next_char(i)
541             # Parse the precision (optional).
542             if char == ".":
543                 i, char = next_char(i)
544                 if char == "*":
545                     num_args += 1
546                     i, char = next_char(i)
547                 else:
548                     while char in string.digits:
549                         i, char = next_char(i)
550             # Parse the length modifier (optional).
551             if char in "hlL":
552                 i, char = next_char(i)
553             # Parse the conversion type (mandatory).
554             flags = "diouxXeEfFgGcrs%a"
555             if char not in flags:
556                 raise UnsupportedFormatCharacter(i)
557             if key:
558                 keys.add(key)
559                 key_types[key] = char
560             elif char != "%":
561                 num_args += 1
562                 pos_types.append(char)
563         i += 1
564     return keys, num_args, key_types, pos_types
565 
566 
567 def split_format_field_names(format_string) -> Tuple[str, Iterable[Tuple[bool, str]]]:
568     try:
569         return _string.formatter_field_name_split(format_string)
570     except ValueError as e:
571         raise IncompleteFormatString() from e
572 
573 
574 def collect_string_fields(format_string) -> Iterable[Optional[str]]:
575     """Given a format string, return an iterator
576     of all the valid format fields. It handles nested fields
577     as well.
578     """
579     formatter = string.Formatter()
580     try:
581         parseiterator = formatter.parse(format_string)
582         for result in parseiterator:
583             if all(item is None for item in result[1:]):
584                 # not a replacement format
585                 continue
586             name = result[1]
587             nested = result[2]
588             yield name
589             if nested:
590                 yield from collect_string_fields(nested)
591     except ValueError as exc:
592         # Probably the format string is invalid.
593         if exc.args[0].startswith("cannot switch from manual"):
594             # On Jython, parsing a string with both manual
595             # and automatic positions will fail with a ValueError,
596             # while on CPython it will simply return the fields,
597             # the validation being done in the interpreter (?).
598             # We're just returning two mixed fields in order
599             # to trigger the format-combined-specification check.
600             yield ""
601             yield "1"
602             return
603         raise IncompleteFormatString(format_string) from exc
604 
605 
606 def parse_format_method_string(
607     format_string: str,
608 ) -> Tuple[List[Tuple[str, List[Tuple[bool, str]]]], int, int]:
609     """
610     Parses a PEP 3101 format string, returning a tuple of
611     (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args),
612     where keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt
613     is the number of arguments required by the format string and
614     explicit_pos_args is the number of arguments passed with the position.
615     """
616     keyword_arguments = []
617     implicit_pos_args_cnt = 0
618     explicit_pos_args = set()
619     for name in collect_string_fields(format_string):
620         if name and str(name).isdigit():
621             explicit_pos_args.add(str(name))
622         elif name:
623             keyname, fielditerator = split_format_field_names(name)
624             if isinstance(keyname, numbers.Number):
625                 explicit_pos_args.add(str(keyname))
626             try:
627                 keyword_arguments.append((keyname, list(fielditerator)))
628             except ValueError as e:
629                 raise IncompleteFormatString() from e
630         else:
631             implicit_pos_args_cnt += 1
632     return keyword_arguments, implicit_pos_args_cnt, len(explicit_pos_args)
633 
634 
635 def is_attr_protected(attrname: str) -> bool:
636     """return True if attribute name is protected (start with _ and some other
637     details), False otherwise.
638     """
639     return (
640         attrname[0] == "_"
641         and attrname != "_"
642         and not (attrname.startswith("__") and attrname.endswith("__"))
643     )
644 
645 
646 def node_frame_class(node: astroid.node_classes.NodeNG) -> Optional[astroid.ClassDef]:
647     """Return the class that is wrapping the given node
648 
649     The function returns a class for a method node (or a staticmethod or a
650     classmethod), otherwise it returns `None`.
651     """
652     klass = node.frame()
653     nodes_to_check = (
654         astroid.node_classes.NodeNG,
655         astroid.UnboundMethod,
656         astroid.BaseInstance,
657     )
658     while (
659         klass
660         and isinstance(klass, nodes_to_check)
661         and not isinstance(klass, astroid.ClassDef)
662     ):
663         if klass.parent is None:
664             klass = None
665         else:
666             klass = klass.parent.frame()
667 
668     return klass
669 
670 
671 def is_attr_private(attrname: str) -> Optional[Match[str]]:
672     """Check that attribute name is private (at least two leading underscores,
673     at most one trailing underscore)
674     """
675     regex = re.compile("^_{2,}.*[^_]+_?$")
676     return regex.match(attrname)
677 
678 
679 def get_argument_from_call(
680     call_node: astroid.Call, position: int = None, keyword: str = None
681 ) -> astroid.Name:
682     """Returns the specified argument from a function call.
683 
684     :param astroid.Call call_node: Node representing a function call to check.
685     :param int position: position of the argument.
686     :param str keyword: the keyword of the argument.
687 
688     :returns: The node representing the argument, None if the argument is not found.
689     :rtype: astroid.Name
690     :raises ValueError: if both position and keyword are None.
691     :raises NoSuchArgumentError: if no argument at the provided position or with
692     the provided keyword.
693     """
694     if position is None and keyword is None:
695         raise ValueError("Must specify at least one of: position or keyword.")
696     if position is not None:
697         try:
698             return call_node.args[position]
699         except IndexError:
700             pass
701     if keyword and call_node.keywords:
702         for arg in call_node.keywords:
703             if arg.arg == keyword:
704                 return arg.value
705 
706     raise NoSuchArgumentError
707 
708 
709 def inherit_from_std_ex(node: astroid.node_classes.NodeNG) -> bool:
710     """
711     Return true if the given class node is subclass of
712     exceptions.Exception.
713     """
714     ancestors = node.ancestors() if hasattr(node, "ancestors") else []
715     for ancestor in itertools.chain([node], ancestors):
716         if (
717             ancestor.name in ("Exception", "BaseException")
718             and ancestor.root().name == EXCEPTIONS_MODULE
719         ):
720             return True
721     return False
722 
723 
724 def error_of_type(handler: astroid.ExceptHandler, error_type) -> bool:
725     """
726     Check if the given exception handler catches
727     the given error_type.
728 
729     The *handler* parameter is a node, representing an ExceptHandler node.
730     The *error_type* can be an exception, such as AttributeError,
731     the name of an exception, or it can be a tuple of errors.
732     The function will return True if the handler catches any of the
733     given errors.
734     """
735 
736     def stringify_error(error):
737         if not isinstance(error, str):
738             return error.__name__
739         return error
740 
741     if not isinstance(error_type, tuple):
742         error_type = (error_type,)  # type: ignore
743     expected_errors = {stringify_error(error) for error in error_type}  # type: ignore
744     if not handler.type:
745         return False
746     return handler.catch(expected_errors)
747 
748 
749 def decorated_with_property(node: astroid.FunctionDef) -> bool:
750     """Detect if the given function node is decorated with a property."""
751     if not node.decorators:
752         return False
753     for decorator in node.decorators.nodes:
754         try:
755             if _is_property_decorator(decorator):
756                 return True
757         except astroid.InferenceError:
758             pass
759     return False
760 
761 
762 def _is_property_kind(node, *kinds):
763     if not isinstance(node, (astroid.UnboundMethod, astroid.FunctionDef)):
764         return False
765     if node.decorators:
766         for decorator in node.decorators.nodes:
767             if isinstance(decorator, astroid.Attribute) and decorator.attrname in kinds:
768                 return True
769     return False
770 
771 
772 def is_property_setter(node: astroid.FunctionDef) -> bool:
773     """Check if the given node is a property setter"""
774     return _is_property_kind(node, "setter")
775 
776 
777 def is_property_deleter(node: astroid.FunctionDef) -> bool:
778     """Check if the given node is a property deleter"""
779     return _is_property_kind(node, "deleter")
780 
781 
782 def is_property_setter_or_deleter(node: astroid.FunctionDef) -> bool:
783     """Check if the given node is either a property setter or a deleter"""
784     return _is_property_kind(node, "setter", "deleter")
785 
786 
787 def _is_property_decorator(decorator: astroid.Name) -> bool:
788     for inferred in decorator.infer():
789         if isinstance(inferred, astroid.ClassDef):
790             if inferred.qname() in ("builtins.property", "functools.cached_property"):
791                 return True
792             for ancestor in inferred.ancestors():
793                 if (
794                     ancestor.name == "property"
795                     and ancestor.root().name == BUILTINS_NAME
796                 ):
797                     return True
798     return False
799 
800 
801 def decorated_with(
802     func: Union[astroid.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod],
803     qnames: Iterable[str],
804 ) -> bool:
805     """Determine if the `func` node has a decorator with the qualified name `qname`."""
806     decorators = func.decorators.nodes if func.decorators else []
807     for decorator_node in decorators:
808         if isinstance(decorator_node, astroid.Call):
809             # We only want to infer the function name
810             decorator_node = decorator_node.func
811         try:
812             if any(
813                 i.name in qnames or i.qname() in qnames
814                 for i in decorator_node.infer()
815                 if i is not None and i != astroid.Uninferable
816             ):
817                 return True
818         except astroid.InferenceError:
819             continue
820     return False
821 
822 
823 @lru_cache(maxsize=1024)
824 def unimplemented_abstract_methods(
825     node: astroid.ClassDef, is_abstract_cb: astroid.FunctionDef = None
826 ) -> Dict[str, astroid.node_classes.NodeNG]:
827     """
828     Get the unimplemented abstract methods for the given *node*.
829 
830     A method can be considered abstract if the callback *is_abstract_cb*
831     returns a ``True`` value. The check defaults to verifying that
832     a method is decorated with abstract methods.
833     The function will work only for new-style classes. For old-style
834     classes, it will simply return an empty dictionary.
835     For the rest of them, it will return a dictionary of abstract method
836     names and their inferred objects.
837     """
838     if is_abstract_cb is None:
839         is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)
840     visited: Dict[str, astroid.node_classes.NodeNG] = {}
841     try:
842         mro = reversed(node.mro())
843     except NotImplementedError:
844         # Old style class, it will not have a mro.
845         return {}
846     except astroid.ResolveError:
847         # Probably inconsistent hierarchy, don'try
848         # to figure this out here.
849         return {}
850     for ancestor in mro:
851         for obj in ancestor.values():
852             inferred = obj
853             if isinstance(obj, astroid.AssignName):
854                 inferred = safe_infer(obj)
855                 if not inferred:
856                     # Might be an abstract function,
857                     # but since we don't have enough information
858                     # in order to take this decision, we're taking
859                     # the *safe* decision instead.
860                     if obj.name in visited:
861                         del visited[obj.name]
862                     continue
863                 if not isinstance(inferred, astroid.FunctionDef):
864                     if obj.name in visited:
865                         del visited[obj.name]
866             if isinstance(inferred, astroid.FunctionDef):
867                 # It's critical to use the original name,
868                 # since after inferring, an object can be something
869                 # else than expected, as in the case of the
870                 # following assignment.
871                 #
872                 # class A:
873                 #     def keys(self): pass
874                 #     __iter__ = keys
875                 abstract = is_abstract_cb(inferred)
876                 if abstract:
877                     visited[obj.name] = inferred
878                 elif not abstract and obj.name in visited:
879                     del visited[obj.name]
880     return visited
881 
882 
883 def find_try_except_wrapper_node(
884     node: astroid.node_classes.NodeNG,
885 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:
886     """Return the ExceptHandler or the TryExcept node in which the node is."""
887     current = node
888     ignores = (astroid.ExceptHandler, astroid.TryExcept)
889     while current and not isinstance(current.parent, ignores):
890         current = current.parent
891 
892     if current and isinstance(current.parent, ignores):
893         return current.parent
894     return None
895 
896 
897 def find_except_wrapper_node_in_scope(
898     node: astroid.node_classes.NodeNG,
899 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:
900     """Return the ExceptHandler in which the node is, without going out of scope."""
901     current = node
902     while current.parent is not None:
903         current = current.parent
904         if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):
905             # If we're inside a function/class definition, we don't want to keep checking
906             # higher ancestors for `except` clauses, because if these exist, it means our
907             # function/class was defined in an `except` clause, rather than the current code
908             # actually running in an `except` clause.
909             return None
910         if isinstance(current, astroid.ExceptHandler):
911             return current
912     return None
913 
914 
915 def is_from_fallback_block(node: astroid.node_classes.NodeNG) -> bool:
916     """Check if the given node is from a fallback import block."""
917     context = find_try_except_wrapper_node(node)
918     if not context:
919         return False
920 
921     if isinstance(context, astroid.ExceptHandler):
922         other_body = context.parent.body
923         handlers = context.parent.handlers
924     else:
925         other_body = itertools.chain.from_iterable(
926             handler.body for handler in context.handlers
927         )
928         handlers = context.handlers
929 
930     has_fallback_imports = any(
931         isinstance(import_node, (astroid.ImportFrom, astroid.Import))
932         for import_node in other_body
933     )
934     ignores_import_error = _except_handlers_ignores_exception(handlers, ImportError)
935     return ignores_import_error or has_fallback_imports
936 
937 
938 def _except_handlers_ignores_exception(
939     handlers: astroid.ExceptHandler, exception
940 ) -> bool:
941     func = partial(error_of_type, error_type=(exception,))
942     return any(func(handler) for handler in handlers)
943 
944 
945 def get_exception_handlers(
946     node: astroid.node_classes.NodeNG, exception=Exception
947 ) -> Optional[List[astroid.ExceptHandler]]:
948     """Return the collections of handlers handling the exception in arguments.
949 
950     Args:
951         node (astroid.NodeNG): A node that is potentially wrapped in a try except.
952         exception (builtin.Exception or str): exception or name of the exception.
953 
954     Returns:
955         list: the collection of handlers that are handling the exception or None.
956 
957     """
958     context = find_try_except_wrapper_node(node)
959     if isinstance(context, astroid.TryExcept):
960         return [
961             handler for handler in context.handlers if error_of_type(handler, exception)
962         ]
963     return []
964 
965 
966 def is_node_inside_try_except(node: astroid.Raise) -> bool:
967     """Check if the node is directly under a Try/Except statement.
968     (but not under an ExceptHandler!)
969 
970     Args:
971         node (astroid.Raise): the node raising the exception.
972 
973     Returns:
974         bool: True if the node is inside a try/except statement, False otherwise.
975     """
976     context = find_try_except_wrapper_node(node)
977     return isinstance(context, astroid.TryExcept)
978 
979 
980 def node_ignores_exception(
981     node: astroid.node_classes.NodeNG, exception=Exception
982 ) -> bool:
983     """Check if the node is in a TryExcept which handles the given exception.
984 
985     If the exception is not given, the function is going to look for bare
986     excepts.
987     """
988     managing_handlers = get_exception_handlers(node, exception)
989     if not managing_handlers:
990         return False
991     return any(managing_handlers)
992 
993 
994 def class_is_abstract(node: astroid.ClassDef) -> bool:
995     """return true if the given class node should be considered as an abstract
996     class
997     """
998     # Only check for explicit metaclass=ABCMeta on this specific class
999     meta = node.declared_metaclass()
1000     if meta is not None:
1001         if meta.name == "ABCMeta" and meta.root().name in ABC_MODULES:
1002             return True
1003 
1004     for ancestor in node.ancestors():
1005         if ancestor.name == "ABC" and ancestor.root().name in ABC_MODULES:
1006             # abc.ABC inheritance
1007             return True
1008 
1009     for method in node.methods():
1010         if method.parent.frame() is node:
1011             if method.is_abstract(pass_is_abstract=False):
1012                 return True
1013     return False
1014 
1015 
1016 def _supports_protocol_method(value: astroid.node_classes.NodeNG, attr: str) -> bool:
1017     try:
1018         attributes = value.getattr(attr)
1019     except astroid.NotFoundError:
1020         return False
1021 
1022     first = attributes[0]
1023     if isinstance(first, astroid.AssignName):
1024         if isinstance(first.parent.value, astroid.Const):
1025             return False
1026     return True
1027 
1028 
1029 def is_comprehension(node: astroid.node_classes.NodeNG) -> bool:
1030     comprehensions = (
1031         astroid.ListComp,
1032         astroid.SetComp,
1033         astroid.DictComp,
1034         astroid.GeneratorExp,
1035     )
1036     return isinstance(node, comprehensions)
1037 
1038 
1039 def _supports_mapping_protocol(value: astroid.node_classes.NodeNG) -> bool:
1040     return _supports_protocol_method(
1041         value, GETITEM_METHOD
1042     ) and _supports_protocol_method(value, KEYS_METHOD)
1043 
1044 
1045 def _supports_membership_test_protocol(value: astroid.node_classes.NodeNG) -> bool:
1046     return _supports_protocol_method(value, CONTAINS_METHOD)
1047 
1048 
1049 def _supports_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:
1050     return _supports_protocol_method(value, ITER_METHOD) or _supports_protocol_method(
1051         value, GETITEM_METHOD
1052     )
1053 
1054 
1055 def _supports_async_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:
1056     return _supports_protocol_method(value, AITER_METHOD)
1057 
1058 
1059 def _supports_getitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1060     return _supports_protocol_method(value, GETITEM_METHOD)
1061 
1062 
1063 def _supports_setitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1064     return _supports_protocol_method(value, SETITEM_METHOD)
1065 
1066 
1067 def _supports_delitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1068     return _supports_protocol_method(value, DELITEM_METHOD)
1069 
1070 
1071 def _is_abstract_class_name(name: str) -> bool:
1072     lname = name.lower()
1073     is_mixin = lname.endswith("mixin")
1074     is_abstract = lname.startswith("abstract")
1075     is_base = lname.startswith("base") or lname.endswith("base")
1076     return is_mixin or is_abstract or is_base
1077 
1078 
1079 def is_inside_abstract_class(node: astroid.node_classes.NodeNG) -> bool:
1080     while node is not None:
1081         if isinstance(node, astroid.ClassDef):
1082             if class_is_abstract(node):
1083                 return True
1084             name = getattr(node, "name", None)
1085             if name is not None and _is_abstract_class_name(name):
1086                 return True
1087         node = node.parent
1088     return False
1089 
1090 
1091 def _supports_protocol(
1092     value: astroid.node_classes.NodeNG, protocol_callback: astroid.FunctionDef
1093 ) -> bool:
1094     if isinstance(value, astroid.ClassDef):
1095         if not has_known_bases(value):
1096             return True
1097         # classobj can only be iterable if it has an iterable metaclass
1098         meta = value.metaclass()
1099         if meta is not None:
1100             if protocol_callback(meta):
1101                 return True
1102     if isinstance(value, astroid.BaseInstance):
1103         if not has_known_bases(value):
1104             return True
1105         if value.has_dynamic_getattr():
1106             return True
1107         if protocol_callback(value):
1108             return True
1109 
1110     if (
1111         isinstance(value, astroid.bases.Proxy)
1112         and isinstance(value._proxied, astroid.BaseInstance)
1113         and has_known_bases(value._proxied)
1114     ):
1115         value = value._proxied
1116         return protocol_callback(value)
1117 
1118     return False
1119 
1120 
1121 def is_iterable(value: astroid.node_classes.NodeNG, check_async: bool = False) -> bool:
1122     if check_async:
1123         protocol_check = _supports_async_iteration_protocol
1124     else:
1125         protocol_check = _supports_iteration_protocol
1126     return _supports_protocol(value, protocol_check)
1127 
1128 
1129 def is_mapping(value: astroid.node_classes.NodeNG) -> bool:
1130     return _supports_protocol(value, _supports_mapping_protocol)
1131 
1132 
1133 def supports_membership_test(value: astroid.node_classes.NodeNG) -> bool:
1134     supported = _supports_protocol(value, _supports_membership_test_protocol)
1135     return supported or is_iterable(value)
1136 
1137 
1138 def supports_getitem(
1139     value: astroid.node_classes.NodeNG, node: astroid.node_classes.NodeNG
1140 ) -> bool:
1141     if isinstance(value, astroid.ClassDef):
1142         if _supports_protocol_method(value, CLASS_GETITEM_METHOD):
1143             return True
1144         if is_class_subscriptable_pep585_with_postponed_evaluation_enabled(value, node):
1145             return True
1146     return _supports_protocol(value, _supports_getitem_protocol)
1147 
1148 
1149 def supports_setitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:
1150     return _supports_protocol(value, _supports_setitem_protocol)
1151 
1152 
1153 def supports_delitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:
1154     return _supports_protocol(value, _supports_delitem_protocol)
1155 
1156 
1157 def _get_python_type_of_node(node):
1158     pytype = getattr(node, "pytype", None)
1159     if callable(pytype):
1160         return pytype()
1161     return None
1162 
1163 
1164 @lru_cache(maxsize=1024)
1165 def safe_infer(
1166     node: astroid.node_classes.NodeNG, context=None
1167 ) -> Optional[astroid.node_classes.NodeNG]:
1168     """Return the inferred value for the given node.
1169 
1170     Return None if inference failed or if there is some ambiguity (more than
1171     one node has been inferred of different types).
1172     """
1173     inferred_types = set()
1174     try:
1175         infer_gen = node.infer(context=context)
1176         value = next(infer_gen)
1177     except astroid.InferenceError:
1178         return None
1179 
1180     if value is not astroid.Uninferable:
1181         inferred_types.add(_get_python_type_of_node(value))
1182 
1183     try:
1184         for inferred in infer_gen:
1185             inferred_type = _get_python_type_of_node(inferred)
1186             if inferred_type not in inferred_types:
1187                 return None  # If there is ambiguity on the inferred node.
1188     except astroid.InferenceError:
1189         return None  # There is some kind of ambiguity
1190     except StopIteration:
1191         return value
1192     return value if len(inferred_types) <= 1 else None
1193 
1194 
1195 def has_known_bases(klass: astroid.ClassDef, context=None) -> bool:
1196     """Return true if all base classes of a class could be inferred."""
1197     try:
1198         return klass._all_bases_known
1199     except AttributeError:
1200         pass
1201     for base in klass.bases:
1202         result = safe_infer(base, context=context)
1203         if (
1204             not isinstance(result, astroid.ClassDef)
1205             or result is klass
1206             or not has_known_bases(result, context=context)
1207         ):
1208             klass._all_bases_known = False
1209             return False
1210     klass._all_bases_known = True
1211     return True
1212 
1213 
1214 def is_none(node: astroid.node_classes.NodeNG) -> bool:
1215     return (
1216         node is None
1217         or (isinstance(node, astroid.Const) and node.value is None)
1218         or (isinstance(node, astroid.Name) and node.name == "None")
1219     )
1220 
1221 
1222 def node_type(node: astroid.node_classes.NodeNG) -> Optional[type]:
1223     """Return the inferred type for `node`
1224 
1225     If there is more than one possible type, or if inferred type is Uninferable or None,
1226     return None
1227     """
1228     # check there is only one possible type for the assign node. Else we
1229     # don't handle it for now
1230     types = set()
1231     try:
1232         for var_type in node.infer():
1233             if var_type == astroid.Uninferable or is_none(var_type):
1234                 continue
1235             types.add(var_type)
1236             if len(types) > 1:
1237                 return None
1238     except astroid.InferenceError:
1239         return None
1240     return types.pop() if types else None
1241 
1242 
1243 def is_registered_in_singledispatch_function(node: astroid.FunctionDef) -> bool:
1244     """Check if the given function node is a singledispatch function."""
1245 
1246     singledispatch_qnames = (
1247         "functools.singledispatch",
1248         "singledispatch.singledispatch",
1249     )
1250 
1251     if not isinstance(node, astroid.FunctionDef):
1252         return False
1253 
1254     decorators = node.decorators.nodes if node.decorators else []
1255     for decorator in decorators:
1256         # func.register are function calls
1257         if not isinstance(decorator, astroid.Call):
1258             continue
1259 
1260         func = decorator.func
1261         if not isinstance(func, astroid.Attribute) or func.attrname != "register":
1262             continue
1263 
1264         try:
1265             func_def = next(func.expr.infer())
1266         except astroid.InferenceError:
1267             continue
1268 
1269         if isinstance(func_def, astroid.FunctionDef):
1270             # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here
1271             return decorated_with(func_def, singledispatch_qnames)
1272 
1273     return False
1274 
1275 
1276 def get_node_last_lineno(node: astroid.node_classes.NodeNG) -> int:
1277     """
1278     Get the last lineno of the given node. For a simple statement this will just be node.lineno,
1279     but for a node that has child statements (e.g. a method) this will be the lineno of the last
1280     child statement recursively.
1281     """
1282     # 'finalbody' is always the last clause in a try statement, if present
1283     if getattr(node, "finalbody", False):
1284         return get_node_last_lineno(node.finalbody[-1])
1285     # For if, while, and for statements 'orelse' is always the last clause.
1286     # For try statements 'orelse' is the last in the absence of a 'finalbody'
1287     if getattr(node, "orelse", False):
1288         return get_node_last_lineno(node.orelse[-1])
1289     # try statements have the 'handlers' last if there is no 'orelse' or 'finalbody'
1290     if getattr(node, "handlers", False):
1291         return get_node_last_lineno(node.handlers[-1])
1292     # All compound statements have a 'body'
1293     if getattr(node, "body", False):
1294         return get_node_last_lineno(node.body[-1])
1295     # Not a compound statement
1296     return node.lineno
1297 
1298 
1299 def is_postponed_evaluation_enabled(node: astroid.node_classes.NodeNG) -> bool:
1300     """Check if the postponed evaluation of annotations is enabled"""
1301     module = node.root()
1302     return "annotations" in module.future_imports
1303 
1304 
1305 def is_class_subscriptable_pep585_with_postponed_evaluation_enabled(
1306     value: astroid.ClassDef, node: astroid.node_classes.NodeNG
1307 ) -> bool:
1308     """Check if class is subscriptable with PEP 585 and
1309     postponed evaluation enabled.
1310     """
1311     return (
1312         is_postponed_evaluation_enabled(node)
1313         and value.qname() in SUBSCRIPTABLE_CLASSES_PEP585
1314         and is_node_in_type_annotation_context(node)
1315     )
1316 
1317 
1318 def is_node_in_type_annotation_context(node: astroid.node_classes.NodeNG) -> bool:
1319     """Check if node is in type annotation context.
1320 
1321     Check for 'AnnAssign', function 'Arguments',
1322     or part of function return type anntation.
1323     """
1324     # pylint: disable=too-many-boolean-expressions
1325     current_node, parent_node = node, node.parent
1326     while True:
1327         if (
1328             isinstance(parent_node, astroid.AnnAssign)
1329             and parent_node.annotation == current_node
1330             or isinstance(parent_node, astroid.Arguments)
1331             and current_node
1332             in (
1333                 *parent_node.annotations,
1334                 *parent_node.posonlyargs_annotations,
1335                 *parent_node.kwonlyargs_annotations,
1336                 parent_node.varargannotation,
1337                 parent_node.kwargannotation,
1338             )
1339             or isinstance(parent_node, astroid.FunctionDef)
1340             and parent_node.returns == current_node
1341         ):
1342             return True
1343         current_node, parent_node = parent_node, parent_node.parent
1344         if isinstance(parent_node, astroid.Module):
1345             return False
1346 
1347 
1348 def is_subclass_of(child: astroid.ClassDef, parent: astroid.ClassDef) -> bool:
1349     """
1350     Check if first node is a subclass of second node.
1351     :param child: Node to check for subclass.
1352     :param parent: Node to check for superclass.
1353     :returns: True if child is derived from parent. False otherwise.
1354     """
1355     if not all(isinstance(node, astroid.ClassDef) for node in (child, parent)):
1356         return False
1357 
1358     for ancestor in child.ancestors():
1359         try:
1360             if astroid.helpers.is_subtype(ancestor, parent):
1361                 return True
1362         except astroid.exceptions._NonDeducibleTypeHierarchy:
1363             continue
1364     return False
1365 
1366 
1367 @lru_cache(maxsize=1024)
1368 def is_overload_stub(node: astroid.node_classes.NodeNG) -> bool:
1369     """Check if a node if is a function stub decorated with typing.overload.
1370 
1371     :param node: Node to check.
1372     :returns: True if node is an overload function stub. False otherwise.
1373     """
1374     decorators = getattr(node, "decorators", None)
1375     return bool(decorators and decorated_with(node, ["typing.overload", "overload"]))
1376 
1377 
1378 def is_protocol_class(cls: astroid.node_classes.NodeNG) -> bool:
1379     """Check if the given node represents a protocol class
1380 
1381     :param cls: The node to check
1382     :returns: True if the node is a typing protocol class, false otherwise.
1383     """
1384     if not isinstance(cls, astroid.ClassDef):
1385         return False
1386 
1387     # Use .ancestors() since not all protocol classes can have
1388     # their mro deduced.
1389     return any(parent.qname() in TYPING_PROTOCOLS for parent in cls.ancestors())
1390 
1391 
1392 def is_call_of_name(node: astroid.node_classes.NodeNG, name: str) -> bool:
1393     """Checks if node is a function call with the given name"""
1394     return (
1395         isinstance(node, astroid.Call)
1396         and isinstance(node.func, astroid.Name)
1397         and node.func.name == name
1398     )
1399 
1400 
1401 def is_test_condition(
1402     node: astroid.node_classes.NodeNG,
1403     parent: Optional[astroid.node_classes.NodeNG] = None,
1404 ) -> bool:
1405     """Returns true if the given node is being tested for truthiness"""
1406     parent = parent or node.parent
1407     if isinstance(parent, (astroid.While, astroid.If, astroid.IfExp, astroid.Assert)):
1408         return node is parent.test or parent.test.parent_of(node)
1409     if isinstance(parent, astroid.Comprehension):
1410         return node in parent.ifs
1411     return is_call_of_name(parent, "bool") and parent.parent_of(node)
1412 
1413 
1414 def is_classdef_type(node: astroid.ClassDef) -> bool:
1415     """Test if ClassDef node is Type."""
1416     if node.name == "type":
1417         return True
1418     for base in node.bases:
1419         if isinstance(base, astroid.Name) and base.name == "type":
1420             return True
1421     return False
1422 
1423 
1424 def is_attribute_typed_annotation(
1425     node: Union[astroid.ClassDef, astroid.Instance], attr_name: str
1426 ) -> bool:
1427     """Test if attribute is typed annotation in current node
1428     or any base nodes.
1429     """
1430     attribute = node.locals.get(attr_name, [None])[0]
1431     if (
1432         attribute
1433         and isinstance(attribute, astroid.AssignName)
1434         and isinstance(attribute.parent, astroid.AnnAssign)
1435     ):
1436         return True
1437     for base in node.bases:
1438         inferred = safe_infer(base)
1439         if (
1440             inferred
1441             and isinstance(inferred, astroid.ClassDef)
1442             and is_attribute_typed_annotation(inferred, attr_name)
1443         ):
1444             return True
1445     return False
1446 
1447 
1448 def is_assign_name_annotated_with(node: astroid.AssignName, typing_name: str) -> bool:
1449     """Test if AssignName node has `typing_name` annotation.
1450 
1451     Especially useful to check for `typing._SpecialForm` instances
1452     like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.
1453     """
1454     if not isinstance(node.parent, astroid.AnnAssign):
1455         return False
1456     annotation = node.parent.annotation
1457     if isinstance(annotation, astroid.Subscript):
1458         annotation = annotation.value
1459     if (
1460         isinstance(annotation, astroid.Name)
1461         and annotation.name == typing_name
1462         or isinstance(annotation, astroid.Attribute)
1463         and annotation.attrname == typing_name
1464     ):
1465         return True
1466     return False
1467 
1468 
1469 def get_iterating_dictionary_name(
1470     node: Union[astroid.For, astroid.Comprehension]
1471 ) -> Optional[str]:
1472     """Get the name of the dictionary which keys are being iterated over on
1473     a `astroid.For` or `astroid.Comprehension` node.
1474 
1475     If the iterating object is not either the keys method of a dictionary
1476     or a dictionary itself, this returns None.
1477     """
1478     # Is it a proper keys call?
1479     if (
1480         isinstance(node.iter, astroid.Call)
1481         and isinstance(node.iter.func, astroid.Attribute)
1482         and node.iter.func.attrname == "keys"
1483     ):
1484         inferred = safe_infer(node.iter.func)
1485         if not isinstance(inferred, astroid.BoundMethod):
1486             return None
1487         return node.iter.as_string().rpartition(".keys")[0]
1488 
1489     # Is it a dictionary?
1490     if isinstance(node.iter, (astroid.Name, astroid.Attribute)):
1491         inferred = safe_infer(node.iter)
1492         if not isinstance(inferred, astroid.Dict):
1493             return None
1494         return node.iter.as_string()
1495 
1496     return None
1497 
1498 
1499 def get_subscript_const_value(node: astroid.Subscript) -> astroid.Const:
1500     """
1501     Returns the value 'subscript.slice' of a Subscript node.
1502 
1503     :param node: Subscript Node to extract value from
1504     :returns: Const Node containing subscript value
1505     :raises InferredTypeError: if the subscript node cannot be inferred as a Const
1506     """
1507     inferred = safe_infer(node.slice)
1508     if not isinstance(inferred, astroid.Const):
1509         raise InferredTypeError(
1510             "Subscript.slice cannot be inferred as an astroid.Const"
1511         )
1512 
1513     return inferred

</code><intended_behavior>Modify or enhance the utility function to parse type comments for imports and mark those imports as utilized if found within '# type:' comments. This should preserve the existing functionality of identifying unused imports while also recognizing imports used in type comments as valid usage.</intended_behavior>, <file>pylint/lint/run.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import os
5 import sys
6 import warnings
7 
8 from pylint import __pkginfo__, config, extensions, interfaces
9 from pylint.constants import full_version
10 from pylint.lint.pylinter import PyLinter
11 from pylint.lint.utils import ArgumentPreprocessingError, preprocess_options
12 from pylint.utils import utils
13 
14 try:
15     import multiprocessing
16 except ImportError:
17     multiprocessing = None  # type: ignore
18 
19 
20 def _cpu_count() -> int:
21     """Use sched_affinity if available for virtualized or containerized environments."""
22     sched_getaffinity = getattr(os, "sched_getaffinity", None)
23     # pylint: disable=not-callable,using-constant-test
24     if sched_getaffinity:
25         return len(sched_getaffinity(0))
26     if multiprocessing:
27         return multiprocessing.cpu_count()
28     return 1
29 
30 
31 def cb_list_extensions(option, optname, value, parser):
32     """List all the extensions under pylint.extensions"""
33 
34     for filename in os.listdir(os.path.dirname(extensions.__file__)):
35         if filename.endswith(".py") and not filename.startswith("_"):
36             extension_name, _, _ = filename.partition(".")
37             print(f"pylint.extensions.{extension_name}")
38     sys.exit(0)
39 
40 
41 def cb_list_confidence_levels(option, optname, value, parser):
42     for level in interfaces.CONFIDENCE_LEVELS:
43         print("%-18s: %s" % level)
44     sys.exit(0)
45 
46 
47 def cb_init_hook(optname, value):
48     """exec arbitrary code to set sys.path for instance"""
49     exec(value)  # pylint: disable=exec-used
50 
51 
52 UNUSED_PARAM_SENTINEL = object()
53 
54 
55 class Run:
56     """helper class to use as main for pylint :
57 
58     run(*sys.argv[1:])
59     """
60 
61     LinterClass = PyLinter
62     option_groups = (
63         (
64             "Commands",
65             "Options which are actually commands. Options in this \
66 group are mutually exclusive.",
67         ),
68     )
69 
70     @staticmethod
71     def _return_one(*args):  # pylint: disable=unused-argument
72         return 1
73 
74     def __init__(
75         self,
76         args,
77         reporter=None,
78         exit=True,
79         do_exit=UNUSED_PARAM_SENTINEL,
80     ):  # pylint: disable=redefined-builtin
81         self._rcfile = None
82         self._output = None
83         self._version_asked = False
84         self._plugins = []
85         self.verbose = None
86         try:
87             preprocess_options(
88                 args,
89                 {
90                     # option: (callback, takearg)
91                     "version": (self.version_asked, False),
92                     "init-hook": (cb_init_hook, True),
93                     "rcfile": (self.cb_set_rcfile, True),
94                     "load-plugins": (self.cb_add_plugins, True),
95                     "verbose": (self.cb_verbose_mode, False),
96                     "output": (self.cb_set_output, True),
97                 },
98             )
99         except ArgumentPreprocessingError as ex:
100             print(ex, file=sys.stderr)
101             sys.exit(32)
102 
103         self.linter = linter = self.LinterClass(
104             (
105                 (
106                     "rcfile",
107                     {
108                         "action": "callback",
109                         "callback": Run._return_one,
110                         "group": "Commands",
111                         "type": "string",
112                         "metavar": "<file>",
113                         "help": "Specify a configuration file to load.",
114                     },
115                 ),
116                 (
117                     "output",
118                     {
119                         "action": "callback",
120                         "callback": Run._return_one,
121                         "group": "Commands",
122                         "type": "string",
123                         "metavar": "<file>",
124                         "help": "Specify an output file.",
125                     },
126                 ),
127                 (
128                     "init-hook",
129                     {
130                         "action": "callback",
131                         "callback": Run._return_one,
132                         "type": "string",
133                         "metavar": "<code>",
134                         "level": 1,
135                         "help": "Python code to execute, usually for sys.path "
136                         "manipulation such as pygtk.require().",
137                     },
138                 ),
139                 (
140                     "help-msg",
141                     {
142                         "action": "callback",
143                         "type": "string",
144                         "metavar": "<msg-id>",
145                         "callback": self.cb_help_message,
146                         "group": "Commands",
147                         "help": "Display a help message for the given message id and "
148                         "exit. The value may be a comma separated list of message ids.",
149                     },
150                 ),
151                 (
152                     "list-msgs",
153                     {
154                         "action": "callback",
155                         "metavar": "<msg-id>",
156                         "callback": self.cb_list_messages,
157                         "group": "Commands",
158                         "level": 1,
159                         "help": "Generate pylint's messages.",
160                     },
161                 ),
162                 (
163                     "list-msgs-enabled",
164                     {
165                         "action": "callback",
166                         "metavar": "<msg-id>",
167                         "callback": self.cb_list_messages_enabled,
168                         "group": "Commands",
169                         "level": 1,
170                         "help": "Display a list of what messages are enabled "
171                         "and disabled with the given configuration.",
172                     },
173                 ),
174                 (
175                     "list-groups",
176                     {
177                         "action": "callback",
178                         "metavar": "<msg-id>",
179                         "callback": self.cb_list_groups,
180                         "group": "Commands",
181                         "level": 1,
182                         "help": "List pylint's message groups.",
183                     },
184                 ),
185                 (
186                     "list-conf-levels",
187                     {
188                         "action": "callback",
189                         "callback": cb_list_confidence_levels,
190                         "group": "Commands",
191                         "level": 1,
192                         "help": "Generate pylint's confidence levels.",
193                     },
194                 ),
195                 (
196                     "list-extensions",
197                     {
198                         "action": "callback",
199                         "callback": cb_list_extensions,
200                         "group": "Commands",
201                         "level": 1,
202                         "help": "List available extensions.",
203                     },
204                 ),
205                 (
206                     "full-documentation",
207                     {
208                         "action": "callback",
209                         "metavar": "<msg-id>",
210                         "callback": self.cb_full_documentation,
211                         "group": "Commands",
212                         "level": 1,
213                         "help": "Generate pylint's full documentation.",
214                     },
215                 ),
216                 (
217                     "generate-rcfile",
218                     {
219                         "action": "callback",
220                         "callback": self.cb_generate_config,
221                         "group": "Commands",
222                         "help": "Generate a sample configuration file according to "
223                         "the current configuration. You can put other options "
224                         "before this one to get them in the generated "
225                         "configuration.",
226                     },
227                 ),
228                 (
229                     "generate-man",
230                     {
231                         "action": "callback",
232                         "callback": self.cb_generate_manpage,
233                         "group": "Commands",
234                         "help": "Generate pylint's man page.",
235                         "hide": True,
236                     },
237                 ),
238                 (
239                     "errors-only",
240                     {
241                         "action": "callback",
242                         "callback": self.cb_error_mode,
243                         "short": "E",
244                         "help": "In error mode, checkers without error messages are "
245                         "disabled and for others, only the ERROR messages are "
246                         "displayed, and no reports are done by default.",
247                     },
248                 ),
249                 (
250                     "py3k",
251                     {
252                         "action": "callback",
253                         "callback": self.cb_python3_porting_mode,
254                         "help": "In Python 3 porting mode, all checkers will be "
255                         "disabled and only messages emitted by the porting "
256                         "checker will be displayed.",
257                     },
258                 ),
259                 (
260                     "verbose",
261                     {
262                         "action": "callback",
263                         "callback": self.cb_verbose_mode,
264                         "short": "v",
265                         "help": "In verbose mode, extra non-checker-related info "
266                         "will be displayed.",
267                     },
268                 ),
269             ),
270             option_groups=self.option_groups,
271             pylintrc=self._rcfile,
272         )
273         # register standard checkers
274         if self._version_asked:
275             print(full_version)
276             sys.exit(0)
277         linter.load_default_plugins()
278         # load command line plugins
279         linter.load_plugin_modules(self._plugins)
280         # add some help section
281         linter.add_help_section("Environment variables", config.ENV_HELP, level=1)
282         linter.add_help_section(
283             "Output",
284             "Using the default text output, the message format is :                          \n"
285             "                                                                                \n"
286             "        MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE                                \n"
287             "                                                                                \n"
288             "There are 5 kind of message types :                                             \n"
289             "    * (C) convention, for programming standard violation                        \n"
290             "    * (R) refactor, for bad code smell                                          \n"
291             "    * (W) warning, for python specific problems                                 \n"
292             "    * (E) error, for probable bugs in the code                                  \n"
293             "    * (F) fatal, if an error occurred which prevented pylint from doing further\n"
294             "processing.\n",
295             level=1,
296         )
297         linter.add_help_section(
298             "Output status code",
299             "Pylint should leave with following status code:                                 \n"
300             "    * 0 if everything went fine                                                 \n"
301             "    * 1 if a fatal message was issued                                           \n"
302             "    * 2 if an error message was issued                                          \n"
303             "    * 4 if a warning message was issued                                         \n"
304             "    * 8 if a refactor message was issued                                        \n"
305             "    * 16 if a convention message was issued                                     \n"
306             "    * 32 on usage error                                                         \n"
307             "                                                                                \n"
308             "status 1 to 16 will be bit-ORed so you can know which different categories has\n"
309             "been issued by analysing pylint output status code\n",
310             level=1,
311         )
312         # read configuration
313         linter.disable("I")
314         linter.enable("c-extension-no-member")
315         try:
316             linter.read_config_file(verbose=self.verbose)
317         except OSError as ex:
318             print(ex, file=sys.stderr)
319             sys.exit(32)
320 
321         config_parser = linter.cfgfile_parser
322         # run init hook, if present, before loading plugins
323         if config_parser.has_option("MASTER", "init-hook"):
324             cb_init_hook(
325                 "init-hook", utils._unquote(config_parser.get("MASTER", "init-hook"))
326             )
327         # is there some additional plugins in the file configuration, in
328         if config_parser.has_option("MASTER", "load-plugins"):
329             plugins = utils._splitstrip(config_parser.get("MASTER", "load-plugins"))
330             linter.load_plugin_modules(plugins)
331         # now we can load file config and command line, plugins (which can
332         # provide options) have been registered
333         linter.load_config_file()
334 
335         if reporter:
336             # if a custom reporter is provided as argument, it may be overridden
337             # by file parameters, so re-set it here, but before command line
338             # parsing so it's still overrideable by command line option
339             linter.set_reporter(reporter)
340         try:
341             args = linter.load_command_line_configuration(args)
342         except SystemExit as exc:
343             if exc.code == 2:  # bad options
344                 exc.code = 32
345             raise
346         if not args:
347             print(linter.help())
348             sys.exit(32)
349 
350         if linter.config.jobs < 0:
351             print(
352                 "Jobs number (%d) should be greater than or equal to 0"
353                 % linter.config.jobs,
354                 file=sys.stderr,
355             )
356             sys.exit(32)
357         if linter.config.jobs > 1 or linter.config.jobs == 0:
358             if multiprocessing is None:
359                 print(
360                     "Multiprocessing library is missing, fallback to single process",
361                     file=sys.stderr,
362                 )
363                 linter.set_option("jobs", 1)
364             elif linter.config.jobs == 0:
365                 linter.config.jobs = _cpu_count()
366 
367         # We have loaded configuration from config file and command line. Now, we can
368         # load plugin specific configuration.
369         linter.load_plugin_configuration()
370 
371         # Now that plugins are loaded, get list of all fail_on messages, and enable them
372         linter.enable_fail_on_messages()
373 
374         if self._output:
375             try:
376                 with open(self._output, "w") as output:
377                     linter.reporter.set_output(output)
378                     linter.check(args)
379                     score_value = linter.generate_reports()
380             except OSError as ex:
381                 print(ex, file=sys.stderr)
382                 sys.exit(32)
383         else:
384             linter.check(args)
385             score_value = linter.generate_reports()
386 
387         if do_exit is not UNUSED_PARAM_SENTINEL:
388             warnings.warn(
389                 "do_exit is deprecated and it is going to be removed in a future version.",
390                 DeprecationWarning,
391             )
392             exit = do_exit
393 
394         if exit:
395             if linter.config.exit_zero:
396                 sys.exit(0)
397             else:
398                 if (
399                     score_value
400                     and score_value >= linter.config.fail_under
401                     # detected messages flagged by --fail-on prevent non-zero exit code
402                     and not linter.any_fail_on_issues()
403                 ):
404                     sys.exit(0)
405                 sys.exit(self.linter.msg_status)
406 
407     def version_asked(self, _, __):
408         """callback for version (i.e. before option parsing)"""
409         self._version_asked = True
410 
411     def cb_set_rcfile(self, name, value):
412         """callback for option preprocessing (i.e. before option parsing)"""
413         self._rcfile = value
414 
415     def cb_set_output(self, name, value):
416         """callback for option preprocessing (i.e. before option parsing)"""
417         self._output = value
418 
419     def cb_add_plugins(self, name, value):
420         """callback for option preprocessing (i.e. before option parsing)"""
421         self._plugins.extend(utils._splitstrip(value))
422 
423     def cb_error_mode(self, *args, **kwargs):
424         """error mode:
425         * disable all but error messages
426         * disable the 'miscellaneous' checker which can be safely deactivated in
427           debug
428         * disable reports
429         * do not save execution information
430         """
431         self.linter.error_mode()
432 
433     def cb_generate_config(self, *args, **kwargs):
434         """optik callback for sample config file generation"""
435         self.linter.generate_config(skipsections=("COMMANDS",))
436         sys.exit(0)
437 
438     def cb_generate_manpage(self, *args, **kwargs):
439         """optik callback for sample config file generation"""
440         self.linter.generate_manpage(__pkginfo__)
441         sys.exit(0)
442 
443     def cb_help_message(self, option, optname, value, parser):
444         """optik callback for printing some help about a particular message"""
445         self.linter.msgs_store.help_message(utils._splitstrip(value))
446         sys.exit(0)
447 
448     def cb_full_documentation(self, option, optname, value, parser):
449         """optik callback for printing full documentation"""
450         self.linter.print_full_documentation()
451         sys.exit(0)
452 
453     def cb_list_messages(self, option, optname, value, parser):
454         """optik callback for printing available messages"""
455         self.linter.msgs_store.list_messages()
456         sys.exit(0)
457 
458     def cb_list_messages_enabled(self, option, optname, value, parser):
459         """optik callback for printing available messages"""
460         self.linter.list_messages_enabled()
461         sys.exit(0)
462 
463     def cb_list_groups(self, *args, **kwargs):
464         """List all the check groups that pylint knows about
465 
466         These should be useful to know what check groups someone can disable
467         or enable.
468         """
469         for check in self.linter.get_checker_names():
470             print(check)
471         sys.exit(0)
472 
473     def cb_python3_porting_mode(self, *args, **kwargs):
474         """Activate only the python3 porting checker."""
475         self.linter.python3_porting_mode()
476 
477     def cb_verbose_mode(self, *args, **kwargs):
478         self.verbose = True

</code><intended_behavior>Ensure that during the linting process, the improved logic from 'utils.py' (or wherever else appropriate) is effectively employed to recognize imports used in type comments. This may involve ensuring that the data about used imports includes those found within type comments before finalizing the unused imports report.</intended_behavior>]
2025-10-15 22:15:10.727 | INFO     | Search completed. Bug locations: [<file>pylint/checkers/utils.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Copyright (c) 2006-2007, 2009-2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
2 # Copyright (c) 2009 Mads Kiilerich <mads@kiilerich.com>
3 # Copyright (c) 2010 Daniel Harding <dharding@gmail.com>
4 # Copyright (c) 2012-2014 Google, Inc.
5 # Copyright (c) 2012 FELD Boris <lothiraldan@gmail.com>
6 # Copyright (c) 2013-2020 Claudiu Popa <pcmanticore@gmail.com>
7 # Copyright (c) 2014 Brett Cannon <brett@python.org>
8 # Copyright (c) 2014 Ricardo Gemignani <ricardo.gemignani@gmail.com>
9 # Copyright (c) 2014 Arun Persaud <arun@nubati.net>
10 # Copyright (c) 2015 Dmitry Pribysh <dmand@yandex.ru>
11 # Copyright (c) 2015 Florian Bruhin <me@the-compiler.org>
12 # Copyright (c) 2015 Radu Ciorba <radu@devrandom.ro>
13 # Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
14 # Copyright (c) 2016, 2018-2019 Ashley Whetter <ashley@awhetter.co.uk>
15 # Copyright (c) 2016-2017 Łukasz Rogalski <rogalski.91@gmail.com>
16 # Copyright (c) 2016-2017 Moises Lopez <moylop260@vauxoo.com>
17 # Copyright (c) 2016 Brian C. Lane <bcl@redhat.com>
18 # Copyright (c) 2017-2018, 2020 hippo91 <guillaume.peillex@gmail.com>
19 # Copyright (c) 2017 ttenhoeve-aa <ttenhoeve@appannie.com>
20 # Copyright (c) 2018 Alan Chan <achan961117@gmail.com>
21 # Copyright (c) 2018 Sushobhit <31987769+sushobhit27@users.noreply.github.com>
22 # Copyright (c) 2018 Yury Gribov <tetra2005@gmail.com>
23 # Copyright (c) 2018 Caio Carrara <ccarrara@redhat.com>
24 # Copyright (c) 2018 ssolanki <sushobhitsolanki@gmail.com>
25 # Copyright (c) 2018 Bryce Guinta <bryce.guinta@protonmail.com>
26 # Copyright (c) 2018 Bryce Guinta <bryce.paul.guinta@gmail.com>
27 # Copyright (c) 2018 Ville Skyttä <ville.skytta@iki.fi>
28 # Copyright (c) 2018 Brian Shaginaw <brian.shaginaw@warbyparker.com>
29 # Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
30 # Copyright (c) 2019 Matthijs Blom <19817960+MatthijsBlom@users.noreply.github.com>
31 # Copyright (c) 2019 Djailla <bastien.vallet@gmail.com>
32 # Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>
33 # Copyright (c) 2019 Nathan Marrow <nmarrow@google.com>
34 # Copyright (c) 2019 Svet <svet@hyperscience.com>
35 # Copyright (c) 2019 Pascal Corpet <pcorpet@users.noreply.github.com>
36 # Copyright (c) 2020 Batuhan Taskaya <batuhanosmantaskaya@gmail.com>
37 # Copyright (c) 2020 Luigi <luigi.cristofolini@q-ctrl.com>
38 # Copyright (c) 2020 ethan-leba <ethanleba5@gmail.com>
39 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>
40 # Copyright (c) 2020 Andrew Simmons <anjsimmo@gmail.com>
41 # Copyright (c) 2020 Ram Rachum <ram@rachum.com>
42 # Copyright (c) 2020 Slavfox <slavfoxman@gmail.com>
43 # Copyright (c) 2020 Anthony Sottile <asottile@umich.edu>
44 # Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>
45 # Copyright (c) 2021 yushao2 <36848472+yushao2@users.noreply.github.com>
46 
47 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
48 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
49 
50 """some functions that may be useful for various checkers
51 """
52 import builtins
53 import itertools
54 import numbers
55 import re
56 import string
57 from functools import lru_cache, partial
58 from typing import (
59     Any,
60     Callable,
61     Dict,
62     Iterable,
63     List,
64     Match,
65     Optional,
66     Set,
67     Tuple,
68     Union,
69 )
70 
71 import _string
72 import astroid
73 
74 BUILTINS_NAME = builtins.__name__
75 COMP_NODE_TYPES = (
76     astroid.ListComp,
77     astroid.SetComp,
78     astroid.DictComp,
79     astroid.GeneratorExp,
80 )
81 EXCEPTIONS_MODULE = "builtins"
82 ABC_MODULES = {"abc", "_py_abc"}
83 ABC_METHODS = {
84     "abc.abstractproperty",
85     "abc.abstractmethod",
86     "abc.abstractclassmethod",
87     "abc.abstractstaticmethod",
88 }
89 TYPING_PROTOCOLS = frozenset(
90     {"typing.Protocol", "typing_extensions.Protocol", ".Protocol"}
91 )
92 ITER_METHOD = "__iter__"
93 AITER_METHOD = "__aiter__"
94 NEXT_METHOD = "__next__"
95 GETITEM_METHOD = "__getitem__"
96 CLASS_GETITEM_METHOD = "__class_getitem__"
97 SETITEM_METHOD = "__setitem__"
98 DELITEM_METHOD = "__delitem__"
99 CONTAINS_METHOD = "__contains__"
100 KEYS_METHOD = "keys"
101 
102 # Dictionary which maps the number of expected parameters a
103 # special method can have to a set of special methods.
104 # The following keys are used to denote the parameters restrictions:
105 #
106 # * None: variable number of parameters
107 # * number: exactly that number of parameters
108 # * tuple: this are the odd ones. Basically it means that the function
109 #          can work with any number of arguments from that tuple,
110 #          although it's best to implement it in order to accept
111 #          all of them.
112 _SPECIAL_METHODS_PARAMS = {
113     None: ("__new__", "__init__", "__call__"),
114     0: (
115         "__del__",
116         "__repr__",
117         "__str__",
118         "__bytes__",
119         "__hash__",
120         "__bool__",
121         "__dir__",
122         "__len__",
123         "__length_hint__",
124         "__iter__",
125         "__reversed__",
126         "__neg__",
127         "__pos__",
128         "__abs__",
129         "__invert__",
130         "__complex__",
131         "__int__",
132         "__float__",
133         "__index__",
134         "__trunc__",
135         "__floor__",
136         "__ceil__",
137         "__enter__",
138         "__aenter__",
139         "__getnewargs_ex__",
140         "__getnewargs__",
141         "__getstate__",
142         "__reduce__",
143         "__copy__",
144         "__unicode__",
145         "__nonzero__",
146         "__await__",
147         "__aiter__",
148         "__anext__",
149         "__fspath__",
150     ),
151     1: (
152         "__format__",
153         "__lt__",
154         "__le__",
155         "__eq__",
156         "__ne__",
157         "__gt__",
158         "__ge__",
159         "__getattr__",
160         "__getattribute__",
161         "__delattr__",
162         "__delete__",
163         "__instancecheck__",
164         "__subclasscheck__",
165         "__getitem__",
166         "__missing__",
167         "__delitem__",
168         "__contains__",
169         "__add__",
170         "__sub__",
171         "__mul__",
172         "__truediv__",
173         "__floordiv__",
174         "__rfloordiv__",
175         "__mod__",
176         "__divmod__",
177         "__lshift__",
178         "__rshift__",
179         "__and__",
180         "__xor__",
181         "__or__",
182         "__radd__",
183         "__rsub__",
184         "__rmul__",
185         "__rtruediv__",
186         "__rmod__",
187         "__rdivmod__",
188         "__rpow__",
189         "__rlshift__",
190         "__rrshift__",
191         "__rand__",
192         "__rxor__",
193         "__ror__",
194         "__iadd__",
195         "__isub__",
196         "__imul__",
197         "__itruediv__",
198         "__ifloordiv__",
199         "__imod__",
200         "__ilshift__",
201         "__irshift__",
202         "__iand__",
203         "__ixor__",
204         "__ior__",
205         "__ipow__",
206         "__setstate__",
207         "__reduce_ex__",
208         "__deepcopy__",
209         "__cmp__",
210         "__matmul__",
211         "__rmatmul__",
212         "__imatmul__",
213         "__div__",
214     ),
215     2: ("__setattr__", "__get__", "__set__", "__setitem__", "__set_name__"),
216     3: ("__exit__", "__aexit__"),
217     (0, 1): ("__round__",),
218     (1, 2): ("__pow__",),
219 }
220 
221 SPECIAL_METHODS_PARAMS = {
222     name: params
223     for params, methods in _SPECIAL_METHODS_PARAMS.items()
224     for name in methods  # type: ignore
225 }
226 PYMETHODS = set(SPECIAL_METHODS_PARAMS)
227 
228 SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(
229     (
230         "builtins.tuple",
231         "builtins.list",
232         "builtins.dict",
233         "builtins.set",
234         "builtins.frozenset",
235         "builtins.type",
236         "collections.deque",
237         "collections.defaultdict",
238         "collections.OrderedDict",
239         "collections.Counter",
240         "collections.ChainMap",
241         "_collections_abc.Awaitable",
242         "_collections_abc.Coroutine",
243         "_collections_abc.AsyncIterable",
244         "_collections_abc.AsyncIterator",
245         "_collections_abc.AsyncGenerator",
246         "_collections_abc.Iterable",
247         "_collections_abc.Iterator",
248         "_collections_abc.Generator",
249         "_collections_abc.Reversible",
250         "_collections_abc.Container",
251         "_collections_abc.Collection",
252         "_collections_abc.Callable",
253         "_collections_abc.Set",
254         "_collections_abc.MutableSet",
255         "_collections_abc.Mapping",
256         "_collections_abc.MutableMapping",
257         "_collections_abc.Sequence",
258         "_collections_abc.MutableSequence",
259         "_collections_abc.ByteString",
260         "_collections_abc.MappingView",
261         "_collections_abc.KeysView",
262         "_collections_abc.ItemsView",
263         "_collections_abc.ValuesView",
264         "contextlib.AbstractContextManager",
265         "contextlib.AbstractAsyncContextManager",
266         "re.Pattern",
267         "re.Match",
268     )
269 )
270 
271 
272 class NoSuchArgumentError(Exception):
273     pass
274 
275 
276 class InferredTypeError(Exception):
277     pass
278 
279 
280 def is_inside_lambda(node: astroid.node_classes.NodeNG) -> bool:
281     """Return true if given node is inside lambda"""
282     parent = node.parent
283     while parent is not None:
284         if isinstance(parent, astroid.Lambda):
285             return True
286         parent = parent.parent
287     return False
288 
289 
290 def get_all_elements(
291     node: astroid.node_classes.NodeNG,
292 ) -> Iterable[astroid.node_classes.NodeNG]:
293     """Recursively returns all atoms in nested lists and tuples."""
294     if isinstance(node, (astroid.Tuple, astroid.List)):
295         for child in node.elts:
296             yield from get_all_elements(child)
297     else:
298         yield node
299 
300 
301 def is_super(node: astroid.node_classes.NodeNG) -> bool:
302     """return True if the node is referencing the "super" builtin function"""
303     if getattr(node, "name", None) == "super" and node.root().name == BUILTINS_NAME:
304         return True
305     return False
306 
307 
308 def is_error(node: astroid.scoped_nodes.FunctionDef) -> bool:
309     """Return true if the given function node only raises an exception"""
310     return len(node.body) == 1 and isinstance(node.body[0], astroid.Raise)
311 
312 
313 builtins = builtins.__dict__.copy()  # type: ignore
314 SPECIAL_BUILTINS = ("__builtins__",)  # '__path__', '__file__')
315 
316 
317 def is_builtin_object(node: astroid.node_classes.NodeNG) -> bool:
318     """Returns True if the given node is an object from the __builtin__ module."""
319     return node and node.root().name == BUILTINS_NAME
320 
321 
322 def is_builtin(name: str) -> bool:
323     """return true if <name> could be considered as a builtin defined by python"""
324     return name in builtins or name in SPECIAL_BUILTINS  # type: ignore
325 
326 
327 def is_defined_in_scope(
328     var_node: astroid.node_classes.NodeNG,
329     varname: str,
330     scope: astroid.node_classes.NodeNG,
331 ) -> bool:
332     if isinstance(scope, astroid.If):
333         for node in scope.body:
334             if (
335                 isinstance(node, astroid.Assign)
336                 and any(
337                     isinstance(target, astroid.AssignName) and target.name == varname
338                     for target in node.targets
339                 )
340             ) or (isinstance(node, astroid.Nonlocal) and varname in node.names):
341                 return True
342     elif isinstance(scope, (COMP_NODE_TYPES, astroid.For)):
343         for ass_node in scope.nodes_of_class(astroid.AssignName):
344             if ass_node.name == varname:
345                 return True
346     elif isinstance(scope, astroid.With):
347         for expr, ids in scope.items:
348             if expr.parent_of(var_node):
349                 break
350             if ids and isinstance(ids, astroid.AssignName) and ids.name == varname:
351                 return True
352     elif isinstance(scope, (astroid.Lambda, astroid.FunctionDef)):
353         if scope.args.is_argument(varname):
354             # If the name is found inside a default value
355             # of a function, then let the search continue
356             # in the parent's tree.
357             if scope.args.parent_of(var_node):
358                 try:
359                     scope.args.default_value(varname)
360                     scope = scope.parent
361                     is_defined_in_scope(var_node, varname, scope)
362                 except astroid.NoDefault:
363                     pass
364             return True
365         if getattr(scope, "name", None) == varname:
366             return True
367     elif isinstance(scope, astroid.ExceptHandler):
368         if isinstance(scope.name, astroid.AssignName):
369             ass_node = scope.name
370             if ass_node.name == varname:
371                 return True
372     return False
373 
374 
375 def is_defined_before(var_node: astroid.Name) -> bool:
376     """Check if the given variable node is defined before
377 
378     Verify that the variable node is defined by a parent node
379     (list, set, dict, or generator comprehension, lambda)
380     or in a previous sibling node on the same line
381     (statement_defining ; statement_using).
382     """
383     varname = var_node.name
384     _node = var_node.parent
385     while _node:
386         if is_defined_in_scope(var_node, varname, _node):
387             return True
388         _node = _node.parent
389     # possibly multiple statements on the same line using semi colon separator
390     stmt = var_node.statement()
391     _node = stmt.previous_sibling()
392     lineno = stmt.fromlineno
393     while _node and _node.fromlineno == lineno:
394         for assign_node in _node.nodes_of_class(astroid.AssignName):
395             if assign_node.name == varname:
396                 return True
397         for imp_node in _node.nodes_of_class((astroid.ImportFrom, astroid.Import)):
398             if varname in [name[1] or name[0] for name in imp_node.names]:
399                 return True
400         _node = _node.previous_sibling()
401     return False
402 
403 
404 def is_default_argument(
405     node: astroid.node_classes.NodeNG,
406     scope: Optional[astroid.node_classes.NodeNG] = None,
407 ) -> bool:
408     """return true if the given Name node is used in function or lambda
409     default argument's value
410     """
411     if not scope:
412         scope = node.scope()
413     if isinstance(scope, (astroid.FunctionDef, astroid.Lambda)):
414         for default_node in scope.args.defaults:
415             for default_name_node in default_node.nodes_of_class(astroid.Name):
416                 if default_name_node is node:
417                     return True
418     return False
419 
420 
421 def is_func_decorator(node: astroid.node_classes.NodeNG) -> bool:
422     """return true if the name is used in function decorator"""
423     parent = node.parent
424     while parent is not None:
425         if isinstance(parent, astroid.Decorators):
426             return True
427         if parent.is_statement or isinstance(
428             parent,
429             (
430                 astroid.Lambda,
431                 astroid.scoped_nodes.ComprehensionScope,
432                 astroid.scoped_nodes.ListComp,
433             ),
434         ):
435             break
436         parent = parent.parent
437     return False
438 
439 
440 def is_ancestor_name(
441     frame: astroid.ClassDef, node: astroid.node_classes.NodeNG
442 ) -> bool:
443     """return True if `frame` is an astroid.Class node with `node` in the
444     subtree of its bases attribute
445     """
446     if not isinstance(frame, astroid.ClassDef):
447         return False
448     for base in frame.bases:
449         if node in base.nodes_of_class(astroid.Name):
450             return True
451     return False
452 
453 
454 def assign_parent(node: astroid.node_classes.NodeNG) -> astroid.node_classes.NodeNG:
455     """return the higher parent which is not an AssignName, Tuple or List node"""
456     while node and isinstance(node, (astroid.AssignName, astroid.Tuple, astroid.List)):
457         node = node.parent
458     return node
459 
460 
461 def overrides_a_method(class_node: astroid.ClassDef, name: str) -> bool:
462     """return True if <name> is a method overridden from an ancestor"""
463     for ancestor in class_node.ancestors():
464         if name in ancestor and isinstance(ancestor[name], astroid.FunctionDef):
465             return True
466     return False
467 
468 
469 def check_messages(*messages: str) -> Callable:
470     """decorator to store messages that are handled by a checker method"""
471 
472     def store_messages(func):
473         func.checks_msgs = messages
474         return func
475 
476     return store_messages
477 
478 
479 class IncompleteFormatString(Exception):
480     """A format string ended in the middle of a format specifier."""
481 
482 
483 class UnsupportedFormatCharacter(Exception):
484     """A format character in a format string is not one of the supported
485     format characters."""
486 
487     def __init__(self, index):
488         Exception.__init__(self, index)
489         self.index = index
490 
491 
492 def parse_format_string(
493     format_string: str,
494 ) -> Tuple[Set[str], int, Dict[str, str], List[str]]:
495     """Parses a format string, returning a tuple of (keys, num_args), where keys
496     is the set of mapping keys in the format string, and num_args is the number
497     of arguments required by the format string.  Raises
498     IncompleteFormatString or UnsupportedFormatCharacter if a
499     parse error occurs."""
500     keys = set()
501     key_types = dict()
502     pos_types = []
503     num_args = 0
504 
505     def next_char(i):
506         i += 1
507         if i == len(format_string):
508             raise IncompleteFormatString
509         return (i, format_string[i])
510 
511     i = 0
512     while i < len(format_string):
513         char = format_string[i]
514         if char == "%":
515             i, char = next_char(i)
516             # Parse the mapping key (optional).
517             key = None
518             if char == "(":
519                 depth = 1
520                 i, char = next_char(i)
521                 key_start = i
522                 while depth != 0:
523                     if char == "(":
524                         depth += 1
525                     elif char == ")":
526                         depth -= 1
527                     i, char = next_char(i)
528                 key_end = i - 1
529                 key = format_string[key_start:key_end]
530 
531             # Parse the conversion flags (optional).
532             while char in "#0- +":
533                 i, char = next_char(i)
534             # Parse the minimum field width (optional).
535             if char == "*":
536                 num_args += 1
537                 i, char = next_char(i)
538             else:
539                 while char in string.digits:
540                     i, char = next_char(i)
541             # Parse the precision (optional).
542             if char == ".":
543                 i, char = next_char(i)
544                 if char == "*":
545                     num_args += 1
546                     i, char = next_char(i)
547                 else:
548                     while char in string.digits:
549                         i, char = next_char(i)
550             # Parse the length modifier (optional).
551             if char in "hlL":
552                 i, char = next_char(i)
553             # Parse the conversion type (mandatory).
554             flags = "diouxXeEfFgGcrs%a"
555             if char not in flags:
556                 raise UnsupportedFormatCharacter(i)
557             if key:
558                 keys.add(key)
559                 key_types[key] = char
560             elif char != "%":
561                 num_args += 1
562                 pos_types.append(char)
563         i += 1
564     return keys, num_args, key_types, pos_types
565 
566 
567 def split_format_field_names(format_string) -> Tuple[str, Iterable[Tuple[bool, str]]]:
568     try:
569         return _string.formatter_field_name_split(format_string)
570     except ValueError as e:
571         raise IncompleteFormatString() from e
572 
573 
574 def collect_string_fields(format_string) -> Iterable[Optional[str]]:
575     """Given a format string, return an iterator
576     of all the valid format fields. It handles nested fields
577     as well.
578     """
579     formatter = string.Formatter()
580     try:
581         parseiterator = formatter.parse(format_string)
582         for result in parseiterator:
583             if all(item is None for item in result[1:]):
584                 # not a replacement format
585                 continue
586             name = result[1]
587             nested = result[2]
588             yield name
589             if nested:
590                 yield from collect_string_fields(nested)
591     except ValueError as exc:
592         # Probably the format string is invalid.
593         if exc.args[0].startswith("cannot switch from manual"):
594             # On Jython, parsing a string with both manual
595             # and automatic positions will fail with a ValueError,
596             # while on CPython it will simply return the fields,
597             # the validation being done in the interpreter (?).
598             # We're just returning two mixed fields in order
599             # to trigger the format-combined-specification check.
600             yield ""
601             yield "1"
602             return
603         raise IncompleteFormatString(format_string) from exc
604 
605 
606 def parse_format_method_string(
607     format_string: str,
608 ) -> Tuple[List[Tuple[str, List[Tuple[bool, str]]]], int, int]:
609     """
610     Parses a PEP 3101 format string, returning a tuple of
611     (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args),
612     where keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt
613     is the number of arguments required by the format string and
614     explicit_pos_args is the number of arguments passed with the position.
615     """
616     keyword_arguments = []
617     implicit_pos_args_cnt = 0
618     explicit_pos_args = set()
619     for name in collect_string_fields(format_string):
620         if name and str(name).isdigit():
621             explicit_pos_args.add(str(name))
622         elif name:
623             keyname, fielditerator = split_format_field_names(name)
624             if isinstance(keyname, numbers.Number):
625                 explicit_pos_args.add(str(keyname))
626             try:
627                 keyword_arguments.append((keyname, list(fielditerator)))
628             except ValueError as e:
629                 raise IncompleteFormatString() from e
630         else:
631             implicit_pos_args_cnt += 1
632     return keyword_arguments, implicit_pos_args_cnt, len(explicit_pos_args)
633 
634 
635 def is_attr_protected(attrname: str) -> bool:
636     """return True if attribute name is protected (start with _ and some other
637     details), False otherwise.
638     """
639     return (
640         attrname[0] == "_"
641         and attrname != "_"
642         and not (attrname.startswith("__") and attrname.endswith("__"))
643     )
644 
645 
646 def node_frame_class(node: astroid.node_classes.NodeNG) -> Optional[astroid.ClassDef]:
647     """Return the class that is wrapping the given node
648 
649     The function returns a class for a method node (or a staticmethod or a
650     classmethod), otherwise it returns `None`.
651     """
652     klass = node.frame()
653     nodes_to_check = (
654         astroid.node_classes.NodeNG,
655         astroid.UnboundMethod,
656         astroid.BaseInstance,
657     )
658     while (
659         klass
660         and isinstance(klass, nodes_to_check)
661         and not isinstance(klass, astroid.ClassDef)
662     ):
663         if klass.parent is None:
664             klass = None
665         else:
666             klass = klass.parent.frame()
667 
668     return klass
669 
670 
671 def is_attr_private(attrname: str) -> Optional[Match[str]]:
672     """Check that attribute name is private (at least two leading underscores,
673     at most one trailing underscore)
674     """
675     regex = re.compile("^_{2,}.*[^_]+_?$")
676     return regex.match(attrname)
677 
678 
679 def get_argument_from_call(
680     call_node: astroid.Call, position: int = None, keyword: str = None
681 ) -> astroid.Name:
682     """Returns the specified argument from a function call.
683 
684     :param astroid.Call call_node: Node representing a function call to check.
685     :param int position: position of the argument.
686     :param str keyword: the keyword of the argument.
687 
688     :returns: The node representing the argument, None if the argument is not found.
689     :rtype: astroid.Name
690     :raises ValueError: if both position and keyword are None.
691     :raises NoSuchArgumentError: if no argument at the provided position or with
692     the provided keyword.
693     """
694     if position is None and keyword is None:
695         raise ValueError("Must specify at least one of: position or keyword.")
696     if position is not None:
697         try:
698             return call_node.args[position]
699         except IndexError:
700             pass
701     if keyword and call_node.keywords:
702         for arg in call_node.keywords:
703             if arg.arg == keyword:
704                 return arg.value
705 
706     raise NoSuchArgumentError
707 
708 
709 def inherit_from_std_ex(node: astroid.node_classes.NodeNG) -> bool:
710     """
711     Return true if the given class node is subclass of
712     exceptions.Exception.
713     """
714     ancestors = node.ancestors() if hasattr(node, "ancestors") else []
715     for ancestor in itertools.chain([node], ancestors):
716         if (
717             ancestor.name in ("Exception", "BaseException")
718             and ancestor.root().name == EXCEPTIONS_MODULE
719         ):
720             return True
721     return False
722 
723 
724 def error_of_type(handler: astroid.ExceptHandler, error_type) -> bool:
725     """
726     Check if the given exception handler catches
727     the given error_type.
728 
729     The *handler* parameter is a node, representing an ExceptHandler node.
730     The *error_type* can be an exception, such as AttributeError,
731     the name of an exception, or it can be a tuple of errors.
732     The function will return True if the handler catches any of the
733     given errors.
734     """
735 
736     def stringify_error(error):
737         if not isinstance(error, str):
738             return error.__name__
739         return error
740 
741     if not isinstance(error_type, tuple):
742         error_type = (error_type,)  # type: ignore
743     expected_errors = {stringify_error(error) for error in error_type}  # type: ignore
744     if not handler.type:
745         return False
746     return handler.catch(expected_errors)
747 
748 
749 def decorated_with_property(node: astroid.FunctionDef) -> bool:
750     """Detect if the given function node is decorated with a property."""
751     if not node.decorators:
752         return False
753     for decorator in node.decorators.nodes:
754         try:
755             if _is_property_decorator(decorator):
756                 return True
757         except astroid.InferenceError:
758             pass
759     return False
760 
761 
762 def _is_property_kind(node, *kinds):
763     if not isinstance(node, (astroid.UnboundMethod, astroid.FunctionDef)):
764         return False
765     if node.decorators:
766         for decorator in node.decorators.nodes:
767             if isinstance(decorator, astroid.Attribute) and decorator.attrname in kinds:
768                 return True
769     return False
770 
771 
772 def is_property_setter(node: astroid.FunctionDef) -> bool:
773     """Check if the given node is a property setter"""
774     return _is_property_kind(node, "setter")
775 
776 
777 def is_property_deleter(node: astroid.FunctionDef) -> bool:
778     """Check if the given node is a property deleter"""
779     return _is_property_kind(node, "deleter")
780 
781 
782 def is_property_setter_or_deleter(node: astroid.FunctionDef) -> bool:
783     """Check if the given node is either a property setter or a deleter"""
784     return _is_property_kind(node, "setter", "deleter")
785 
786 
787 def _is_property_decorator(decorator: astroid.Name) -> bool:
788     for inferred in decorator.infer():
789         if isinstance(inferred, astroid.ClassDef):
790             if inferred.qname() in ("builtins.property", "functools.cached_property"):
791                 return True
792             for ancestor in inferred.ancestors():
793                 if (
794                     ancestor.name == "property"
795                     and ancestor.root().name == BUILTINS_NAME
796                 ):
797                     return True
798     return False
799 
800 
801 def decorated_with(
802     func: Union[astroid.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod],
803     qnames: Iterable[str],
804 ) -> bool:
805     """Determine if the `func` node has a decorator with the qualified name `qname`."""
806     decorators = func.decorators.nodes if func.decorators else []
807     for decorator_node in decorators:
808         if isinstance(decorator_node, astroid.Call):
809             # We only want to infer the function name
810             decorator_node = decorator_node.func
811         try:
812             if any(
813                 i.name in qnames or i.qname() in qnames
814                 for i in decorator_node.infer()
815                 if i is not None and i != astroid.Uninferable
816             ):
817                 return True
818         except astroid.InferenceError:
819             continue
820     return False
821 
822 
823 @lru_cache(maxsize=1024)
824 def unimplemented_abstract_methods(
825     node: astroid.ClassDef, is_abstract_cb: astroid.FunctionDef = None
826 ) -> Dict[str, astroid.node_classes.NodeNG]:
827     """
828     Get the unimplemented abstract methods for the given *node*.
829 
830     A method can be considered abstract if the callback *is_abstract_cb*
831     returns a ``True`` value. The check defaults to verifying that
832     a method is decorated with abstract methods.
833     The function will work only for new-style classes. For old-style
834     classes, it will simply return an empty dictionary.
835     For the rest of them, it will return a dictionary of abstract method
836     names and their inferred objects.
837     """
838     if is_abstract_cb is None:
839         is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)
840     visited: Dict[str, astroid.node_classes.NodeNG] = {}
841     try:
842         mro = reversed(node.mro())
843     except NotImplementedError:
844         # Old style class, it will not have a mro.
845         return {}
846     except astroid.ResolveError:
847         # Probably inconsistent hierarchy, don'try
848         # to figure this out here.
849         return {}
850     for ancestor in mro:
851         for obj in ancestor.values():
852             inferred = obj
853             if isinstance(obj, astroid.AssignName):
854                 inferred = safe_infer(obj)
855                 if not inferred:
856                     # Might be an abstract function,
857                     # but since we don't have enough information
858                     # in order to take this decision, we're taking
859                     # the *safe* decision instead.
860                     if obj.name in visited:
861                         del visited[obj.name]
862                     continue
863                 if not isinstance(inferred, astroid.FunctionDef):
864                     if obj.name in visited:
865                         del visited[obj.name]
866             if isinstance(inferred, astroid.FunctionDef):
867                 # It's critical to use the original name,
868                 # since after inferring, an object can be something
869                 # else than expected, as in the case of the
870                 # following assignment.
871                 #
872                 # class A:
873                 #     def keys(self): pass
874                 #     __iter__ = keys
875                 abstract = is_abstract_cb(inferred)
876                 if abstract:
877                     visited[obj.name] = inferred
878                 elif not abstract and obj.name in visited:
879                     del visited[obj.name]
880     return visited
881 
882 
883 def find_try_except_wrapper_node(
884     node: astroid.node_classes.NodeNG,
885 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:
886     """Return the ExceptHandler or the TryExcept node in which the node is."""
887     current = node
888     ignores = (astroid.ExceptHandler, astroid.TryExcept)
889     while current and not isinstance(current.parent, ignores):
890         current = current.parent
891 
892     if current and isinstance(current.parent, ignores):
893         return current.parent
894     return None
895 
896 
897 def find_except_wrapper_node_in_scope(
898     node: astroid.node_classes.NodeNG,
899 ) -> Optional[Union[astroid.ExceptHandler, astroid.TryExcept]]:
900     """Return the ExceptHandler in which the node is, without going out of scope."""
901     current = node
902     while current.parent is not None:
903         current = current.parent
904         if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):
905             # If we're inside a function/class definition, we don't want to keep checking
906             # higher ancestors for `except` clauses, because if these exist, it means our
907             # function/class was defined in an `except` clause, rather than the current code
908             # actually running in an `except` clause.
909             return None
910         if isinstance(current, astroid.ExceptHandler):
911             return current
912     return None
913 
914 
915 def is_from_fallback_block(node: astroid.node_classes.NodeNG) -> bool:
916     """Check if the given node is from a fallback import block."""
917     context = find_try_except_wrapper_node(node)
918     if not context:
919         return False
920 
921     if isinstance(context, astroid.ExceptHandler):
922         other_body = context.parent.body
923         handlers = context.parent.handlers
924     else:
925         other_body = itertools.chain.from_iterable(
926             handler.body for handler in context.handlers
927         )
928         handlers = context.handlers
929 
930     has_fallback_imports = any(
931         isinstance(import_node, (astroid.ImportFrom, astroid.Import))
932         for import_node in other_body
933     )
934     ignores_import_error = _except_handlers_ignores_exception(handlers, ImportError)
935     return ignores_import_error or has_fallback_imports
936 
937 
938 def _except_handlers_ignores_exception(
939     handlers: astroid.ExceptHandler, exception
940 ) -> bool:
941     func = partial(error_of_type, error_type=(exception,))
942     return any(func(handler) for handler in handlers)
943 
944 
945 def get_exception_handlers(
946     node: astroid.node_classes.NodeNG, exception=Exception
947 ) -> Optional[List[astroid.ExceptHandler]]:
948     """Return the collections of handlers handling the exception in arguments.
949 
950     Args:
951         node (astroid.NodeNG): A node that is potentially wrapped in a try except.
952         exception (builtin.Exception or str): exception or name of the exception.
953 
954     Returns:
955         list: the collection of handlers that are handling the exception or None.
956 
957     """
958     context = find_try_except_wrapper_node(node)
959     if isinstance(context, astroid.TryExcept):
960         return [
961             handler for handler in context.handlers if error_of_type(handler, exception)
962         ]
963     return []
964 
965 
966 def is_node_inside_try_except(node: astroid.Raise) -> bool:
967     """Check if the node is directly under a Try/Except statement.
968     (but not under an ExceptHandler!)
969 
970     Args:
971         node (astroid.Raise): the node raising the exception.
972 
973     Returns:
974         bool: True if the node is inside a try/except statement, False otherwise.
975     """
976     context = find_try_except_wrapper_node(node)
977     return isinstance(context, astroid.TryExcept)
978 
979 
980 def node_ignores_exception(
981     node: astroid.node_classes.NodeNG, exception=Exception
982 ) -> bool:
983     """Check if the node is in a TryExcept which handles the given exception.
984 
985     If the exception is not given, the function is going to look for bare
986     excepts.
987     """
988     managing_handlers = get_exception_handlers(node, exception)
989     if not managing_handlers:
990         return False
991     return any(managing_handlers)
992 
993 
994 def class_is_abstract(node: astroid.ClassDef) -> bool:
995     """return true if the given class node should be considered as an abstract
996     class
997     """
998     # Only check for explicit metaclass=ABCMeta on this specific class
999     meta = node.declared_metaclass()
1000     if meta is not None:
1001         if meta.name == "ABCMeta" and meta.root().name in ABC_MODULES:
1002             return True
1003 
1004     for ancestor in node.ancestors():
1005         if ancestor.name == "ABC" and ancestor.root().name in ABC_MODULES:
1006             # abc.ABC inheritance
1007             return True
1008 
1009     for method in node.methods():
1010         if method.parent.frame() is node:
1011             if method.is_abstract(pass_is_abstract=False):
1012                 return True
1013     return False
1014 
1015 
1016 def _supports_protocol_method(value: astroid.node_classes.NodeNG, attr: str) -> bool:
1017     try:
1018         attributes = value.getattr(attr)
1019     except astroid.NotFoundError:
1020         return False
1021 
1022     first = attributes[0]
1023     if isinstance(first, astroid.AssignName):
1024         if isinstance(first.parent.value, astroid.Const):
1025             return False
1026     return True
1027 
1028 
1029 def is_comprehension(node: astroid.node_classes.NodeNG) -> bool:
1030     comprehensions = (
1031         astroid.ListComp,
1032         astroid.SetComp,
1033         astroid.DictComp,
1034         astroid.GeneratorExp,
1035     )
1036     return isinstance(node, comprehensions)
1037 
1038 
1039 def _supports_mapping_protocol(value: astroid.node_classes.NodeNG) -> bool:
1040     return _supports_protocol_method(
1041         value, GETITEM_METHOD
1042     ) and _supports_protocol_method(value, KEYS_METHOD)
1043 
1044 
1045 def _supports_membership_test_protocol(value: astroid.node_classes.NodeNG) -> bool:
1046     return _supports_protocol_method(value, CONTAINS_METHOD)
1047 
1048 
1049 def _supports_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:
1050     return _supports_protocol_method(value, ITER_METHOD) or _supports_protocol_method(
1051         value, GETITEM_METHOD
1052     )
1053 
1054 
1055 def _supports_async_iteration_protocol(value: astroid.node_classes.NodeNG) -> bool:
1056     return _supports_protocol_method(value, AITER_METHOD)
1057 
1058 
1059 def _supports_getitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1060     return _supports_protocol_method(value, GETITEM_METHOD)
1061 
1062 
1063 def _supports_setitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1064     return _supports_protocol_method(value, SETITEM_METHOD)
1065 
1066 
1067 def _supports_delitem_protocol(value: astroid.node_classes.NodeNG) -> bool:
1068     return _supports_protocol_method(value, DELITEM_METHOD)
1069 
1070 
1071 def _is_abstract_class_name(name: str) -> bool:
1072     lname = name.lower()
1073     is_mixin = lname.endswith("mixin")
1074     is_abstract = lname.startswith("abstract")
1075     is_base = lname.startswith("base") or lname.endswith("base")
1076     return is_mixin or is_abstract or is_base
1077 
1078 
1079 def is_inside_abstract_class(node: astroid.node_classes.NodeNG) -> bool:
1080     while node is not None:
1081         if isinstance(node, astroid.ClassDef):
1082             if class_is_abstract(node):
1083                 return True
1084             name = getattr(node, "name", None)
1085             if name is not None and _is_abstract_class_name(name):
1086                 return True
1087         node = node.parent
1088     return False
1089 
1090 
1091 def _supports_protocol(
1092     value: astroid.node_classes.NodeNG, protocol_callback: astroid.FunctionDef
1093 ) -> bool:
1094     if isinstance(value, astroid.ClassDef):
1095         if not has_known_bases(value):
1096             return True
1097         # classobj can only be iterable if it has an iterable metaclass
1098         meta = value.metaclass()
1099         if meta is not None:
1100             if protocol_callback(meta):
1101                 return True
1102     if isinstance(value, astroid.BaseInstance):
1103         if not has_known_bases(value):
1104             return True
1105         if value.has_dynamic_getattr():
1106             return True
1107         if protocol_callback(value):
1108             return True
1109 
1110     if (
1111         isinstance(value, astroid.bases.Proxy)
1112         and isinstance(value._proxied, astroid.BaseInstance)
1113         and has_known_bases(value._proxied)
1114     ):
1115         value = value._proxied
1116         return protocol_callback(value)
1117 
1118     return False
1119 
1120 
1121 def is_iterable(value: astroid.node_classes.NodeNG, check_async: bool = False) -> bool:
1122     if check_async:
1123         protocol_check = _supports_async_iteration_protocol
1124     else:
1125         protocol_check = _supports_iteration_protocol
1126     return _supports_protocol(value, protocol_check)
1127 
1128 
1129 def is_mapping(value: astroid.node_classes.NodeNG) -> bool:
1130     return _supports_protocol(value, _supports_mapping_protocol)
1131 
1132 
1133 def supports_membership_test(value: astroid.node_classes.NodeNG) -> bool:
1134     supported = _supports_protocol(value, _supports_membership_test_protocol)
1135     return supported or is_iterable(value)
1136 
1137 
1138 def supports_getitem(
1139     value: astroid.node_classes.NodeNG, node: astroid.node_classes.NodeNG
1140 ) -> bool:
1141     if isinstance(value, astroid.ClassDef):
1142         if _supports_protocol_method(value, CLASS_GETITEM_METHOD):
1143             return True
1144         if is_class_subscriptable_pep585_with_postponed_evaluation_enabled(value, node):
1145             return True
1146     return _supports_protocol(value, _supports_getitem_protocol)
1147 
1148 
1149 def supports_setitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:
1150     return _supports_protocol(value, _supports_setitem_protocol)
1151 
1152 
1153 def supports_delitem(value: astroid.node_classes.NodeNG, *_: Any) -> bool:
1154     return _supports_protocol(value, _supports_delitem_protocol)
1155 
1156 
1157 def _get_python_type_of_node(node):
1158     pytype = getattr(node, "pytype", None)
1159     if callable(pytype):
1160         return pytype()
1161     return None
1162 
1163 
1164 @lru_cache(maxsize=1024)
1165 def safe_infer(
1166     node: astroid.node_classes.NodeNG, context=None
1167 ) -> Optional[astroid.node_classes.NodeNG]:
1168     """Return the inferred value for the given node.
1169 
1170     Return None if inference failed or if there is some ambiguity (more than
1171     one node has been inferred of different types).
1172     """
1173     inferred_types = set()
1174     try:
1175         infer_gen = node.infer(context=context)
1176         value = next(infer_gen)
1177     except astroid.InferenceError:
1178         return None
1179 
1180     if value is not astroid.Uninferable:
1181         inferred_types.add(_get_python_type_of_node(value))
1182 
1183     try:
1184         for inferred in infer_gen:
1185             inferred_type = _get_python_type_of_node(inferred)
1186             if inferred_type not in inferred_types:
1187                 return None  # If there is ambiguity on the inferred node.
1188     except astroid.InferenceError:
1189         return None  # There is some kind of ambiguity
1190     except StopIteration:
1191         return value
1192     return value if len(inferred_types) <= 1 else None
1193 
1194 
1195 def has_known_bases(klass: astroid.ClassDef, context=None) -> bool:
1196     """Return true if all base classes of a class could be inferred."""
1197     try:
1198         return klass._all_bases_known
1199     except AttributeError:
1200         pass
1201     for base in klass.bases:
1202         result = safe_infer(base, context=context)
1203         if (
1204             not isinstance(result, astroid.ClassDef)
1205             or result is klass
1206             or not has_known_bases(result, context=context)
1207         ):
1208             klass._all_bases_known = False
1209             return False
1210     klass._all_bases_known = True
1211     return True
1212 
1213 
1214 def is_none(node: astroid.node_classes.NodeNG) -> bool:
1215     return (
1216         node is None
1217         or (isinstance(node, astroid.Const) and node.value is None)
1218         or (isinstance(node, astroid.Name) and node.name == "None")
1219     )
1220 
1221 
1222 def node_type(node: astroid.node_classes.NodeNG) -> Optional[type]:
1223     """Return the inferred type for `node`
1224 
1225     If there is more than one possible type, or if inferred type is Uninferable or None,
1226     return None
1227     """
1228     # check there is only one possible type for the assign node. Else we
1229     # don't handle it for now
1230     types = set()
1231     try:
1232         for var_type in node.infer():
1233             if var_type == astroid.Uninferable or is_none(var_type):
1234                 continue
1235             types.add(var_type)
1236             if len(types) > 1:
1237                 return None
1238     except astroid.InferenceError:
1239         return None
1240     return types.pop() if types else None
1241 
1242 
1243 def is_registered_in_singledispatch_function(node: astroid.FunctionDef) -> bool:
1244     """Check if the given function node is a singledispatch function."""
1245 
1246     singledispatch_qnames = (
1247         "functools.singledispatch",
1248         "singledispatch.singledispatch",
1249     )
1250 
1251     if not isinstance(node, astroid.FunctionDef):
1252         return False
1253 
1254     decorators = node.decorators.nodes if node.decorators else []
1255     for decorator in decorators:
1256         # func.register are function calls
1257         if not isinstance(decorator, astroid.Call):
1258             continue
1259 
1260         func = decorator.func
1261         if not isinstance(func, astroid.Attribute) or func.attrname != "register":
1262             continue
1263 
1264         try:
1265             func_def = next(func.expr.infer())
1266         except astroid.InferenceError:
1267             continue
1268 
1269         if isinstance(func_def, astroid.FunctionDef):
1270             # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here
1271             return decorated_with(func_def, singledispatch_qnames)
1272 
1273     return False
1274 
1275 
1276 def get_node_last_lineno(node: astroid.node_classes.NodeNG) -> int:
1277     """
1278     Get the last lineno of the given node. For a simple statement this will just be node.lineno,
1279     but for a node that has child statements (e.g. a method) this will be the lineno of the last
1280     child statement recursively.
1281     """
1282     # 'finalbody' is always the last clause in a try statement, if present
1283     if getattr(node, "finalbody", False):
1284         return get_node_last_lineno(node.finalbody[-1])
1285     # For if, while, and for statements 'orelse' is always the last clause.
1286     # For try statements 'orelse' is the last in the absence of a 'finalbody'
1287     if getattr(node, "orelse", False):
1288         return get_node_last_lineno(node.orelse[-1])
1289     # try statements have the 'handlers' last if there is no 'orelse' or 'finalbody'
1290     if getattr(node, "handlers", False):
1291         return get_node_last_lineno(node.handlers[-1])
1292     # All compound statements have a 'body'
1293     if getattr(node, "body", False):
1294         return get_node_last_lineno(node.body[-1])
1295     # Not a compound statement
1296     return node.lineno
1297 
1298 
1299 def is_postponed_evaluation_enabled(node: astroid.node_classes.NodeNG) -> bool:
1300     """Check if the postponed evaluation of annotations is enabled"""
1301     module = node.root()
1302     return "annotations" in module.future_imports
1303 
1304 
1305 def is_class_subscriptable_pep585_with_postponed_evaluation_enabled(
1306     value: astroid.ClassDef, node: astroid.node_classes.NodeNG
1307 ) -> bool:
1308     """Check if class is subscriptable with PEP 585 and
1309     postponed evaluation enabled.
1310     """
1311     return (
1312         is_postponed_evaluation_enabled(node)
1313         and value.qname() in SUBSCRIPTABLE_CLASSES_PEP585
1314         and is_node_in_type_annotation_context(node)
1315     )
1316 
1317 
1318 def is_node_in_type_annotation_context(node: astroid.node_classes.NodeNG) -> bool:
1319     """Check if node is in type annotation context.
1320 
1321     Check for 'AnnAssign', function 'Arguments',
1322     or part of function return type anntation.
1323     """
1324     # pylint: disable=too-many-boolean-expressions
1325     current_node, parent_node = node, node.parent
1326     while True:
1327         if (
1328             isinstance(parent_node, astroid.AnnAssign)
1329             and parent_node.annotation == current_node
1330             or isinstance(parent_node, astroid.Arguments)
1331             and current_node
1332             in (
1333                 *parent_node.annotations,
1334                 *parent_node.posonlyargs_annotations,
1335                 *parent_node.kwonlyargs_annotations,
1336                 parent_node.varargannotation,
1337                 parent_node.kwargannotation,
1338             )
1339             or isinstance(parent_node, astroid.FunctionDef)
1340             and parent_node.returns == current_node
1341         ):
1342             return True
1343         current_node, parent_node = parent_node, parent_node.parent
1344         if isinstance(parent_node, astroid.Module):
1345             return False
1346 
1347 
1348 def is_subclass_of(child: astroid.ClassDef, parent: astroid.ClassDef) -> bool:
1349     """
1350     Check if first node is a subclass of second node.
1351     :param child: Node to check for subclass.
1352     :param parent: Node to check for superclass.
1353     :returns: True if child is derived from parent. False otherwise.
1354     """
1355     if not all(isinstance(node, astroid.ClassDef) for node in (child, parent)):
1356         return False
1357 
1358     for ancestor in child.ancestors():
1359         try:
1360             if astroid.helpers.is_subtype(ancestor, parent):
1361                 return True
1362         except astroid.exceptions._NonDeducibleTypeHierarchy:
1363             continue
1364     return False
1365 
1366 
1367 @lru_cache(maxsize=1024)
1368 def is_overload_stub(node: astroid.node_classes.NodeNG) -> bool:
1369     """Check if a node if is a function stub decorated with typing.overload.
1370 
1371     :param node: Node to check.
1372     :returns: True if node is an overload function stub. False otherwise.
1373     """
1374     decorators = getattr(node, "decorators", None)
1375     return bool(decorators and decorated_with(node, ["typing.overload", "overload"]))
1376 
1377 
1378 def is_protocol_class(cls: astroid.node_classes.NodeNG) -> bool:
1379     """Check if the given node represents a protocol class
1380 
1381     :param cls: The node to check
1382     :returns: True if the node is a typing protocol class, false otherwise.
1383     """
1384     if not isinstance(cls, astroid.ClassDef):
1385         return False
1386 
1387     # Use .ancestors() since not all protocol classes can have
1388     # their mro deduced.
1389     return any(parent.qname() in TYPING_PROTOCOLS for parent in cls.ancestors())
1390 
1391 
1392 def is_call_of_name(node: astroid.node_classes.NodeNG, name: str) -> bool:
1393     """Checks if node is a function call with the given name"""
1394     return (
1395         isinstance(node, astroid.Call)
1396         and isinstance(node.func, astroid.Name)
1397         and node.func.name == name
1398     )
1399 
1400 
1401 def is_test_condition(
1402     node: astroid.node_classes.NodeNG,
1403     parent: Optional[astroid.node_classes.NodeNG] = None,
1404 ) -> bool:
1405     """Returns true if the given node is being tested for truthiness"""
1406     parent = parent or node.parent
1407     if isinstance(parent, (astroid.While, astroid.If, astroid.IfExp, astroid.Assert)):
1408         return node is parent.test or parent.test.parent_of(node)
1409     if isinstance(parent, astroid.Comprehension):
1410         return node in parent.ifs
1411     return is_call_of_name(parent, "bool") and parent.parent_of(node)
1412 
1413 
1414 def is_classdef_type(node: astroid.ClassDef) -> bool:
1415     """Test if ClassDef node is Type."""
1416     if node.name == "type":
1417         return True
1418     for base in node.bases:
1419         if isinstance(base, astroid.Name) and base.name == "type":
1420             return True
1421     return False
1422 
1423 
1424 def is_attribute_typed_annotation(
1425     node: Union[astroid.ClassDef, astroid.Instance], attr_name: str
1426 ) -> bool:
1427     """Test if attribute is typed annotation in current node
1428     or any base nodes.
1429     """
1430     attribute = node.locals.get(attr_name, [None])[0]
1431     if (
1432         attribute
1433         and isinstance(attribute, astroid.AssignName)
1434         and isinstance(attribute.parent, astroid.AnnAssign)
1435     ):
1436         return True
1437     for base in node.bases:
1438         inferred = safe_infer(base)
1439         if (
1440             inferred
1441             and isinstance(inferred, astroid.ClassDef)
1442             and is_attribute_typed_annotation(inferred, attr_name)
1443         ):
1444             return True
1445     return False
1446 
1447 
1448 def is_assign_name_annotated_with(node: astroid.AssignName, typing_name: str) -> bool:
1449     """Test if AssignName node has `typing_name` annotation.
1450 
1451     Especially useful to check for `typing._SpecialForm` instances
1452     like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.
1453     """
1454     if not isinstance(node.parent, astroid.AnnAssign):
1455         return False
1456     annotation = node.parent.annotation
1457     if isinstance(annotation, astroid.Subscript):
1458         annotation = annotation.value
1459     if (
1460         isinstance(annotation, astroid.Name)
1461         and annotation.name == typing_name
1462         or isinstance(annotation, astroid.Attribute)
1463         and annotation.attrname == typing_name
1464     ):
1465         return True
1466     return False
1467 
1468 
1469 def get_iterating_dictionary_name(
1470     node: Union[astroid.For, astroid.Comprehension]
1471 ) -> Optional[str]:
1472     """Get the name of the dictionary which keys are being iterated over on
1473     a `astroid.For` or `astroid.Comprehension` node.
1474 
1475     If the iterating object is not either the keys method of a dictionary
1476     or a dictionary itself, this returns None.
1477     """
1478     # Is it a proper keys call?
1479     if (
1480         isinstance(node.iter, astroid.Call)
1481         and isinstance(node.iter.func, astroid.Attribute)
1482         and node.iter.func.attrname == "keys"
1483     ):
1484         inferred = safe_infer(node.iter.func)
1485         if not isinstance(inferred, astroid.BoundMethod):
1486             return None
1487         return node.iter.as_string().rpartition(".keys")[0]
1488 
1489     # Is it a dictionary?
1490     if isinstance(node.iter, (astroid.Name, astroid.Attribute)):
1491         inferred = safe_infer(node.iter)
1492         if not isinstance(inferred, astroid.Dict):
1493             return None
1494         return node.iter.as_string()
1495 
1496     return None
1497 
1498 
1499 def get_subscript_const_value(node: astroid.Subscript) -> astroid.Const:
1500     """
1501     Returns the value 'subscript.slice' of a Subscript node.
1502 
1503     :param node: Subscript Node to extract value from
1504     :returns: Const Node containing subscript value
1505     :raises InferredTypeError: if the subscript node cannot be inferred as a Const
1506     """
1507     inferred = safe_infer(node.slice)
1508     if not isinstance(inferred, astroid.Const):
1509         raise InferredTypeError(
1510             "Subscript.slice cannot be inferred as an astroid.Const"
1511         )
1512 
1513     return inferred

</code><intended_behavior>Modify or enhance the utility function to parse type comments for imports and mark those imports as utilized if found within '# type:' comments. This should preserve the existing functionality of identifying unused imports while also recognizing imports used in type comments as valid usage.</intended_behavior>, <file>pylint/lint/run.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
3 
4 import os
5 import sys
6 import warnings
7 
8 from pylint import __pkginfo__, config, extensions, interfaces
9 from pylint.constants import full_version
10 from pylint.lint.pylinter import PyLinter
11 from pylint.lint.utils import ArgumentPreprocessingError, preprocess_options
12 from pylint.utils import utils
13 
14 try:
15     import multiprocessing
16 except ImportError:
17     multiprocessing = None  # type: ignore
18 
19 
20 def _cpu_count() -> int:
21     """Use sched_affinity if available for virtualized or containerized environments."""
22     sched_getaffinity = getattr(os, "sched_getaffinity", None)
23     # pylint: disable=not-callable,using-constant-test
24     if sched_getaffinity:
25         return len(sched_getaffinity(0))
26     if multiprocessing:
27         return multiprocessing.cpu_count()
28     return 1
29 
30 
31 def cb_list_extensions(option, optname, value, parser):
32     """List all the extensions under pylint.extensions"""
33 
34     for filename in os.listdir(os.path.dirname(extensions.__file__)):
35         if filename.endswith(".py") and not filename.startswith("_"):
36             extension_name, _, _ = filename.partition(".")
37             print(f"pylint.extensions.{extension_name}")
38     sys.exit(0)
39 
40 
41 def cb_list_confidence_levels(option, optname, value, parser):
42     for level in interfaces.CONFIDENCE_LEVELS:
43         print("%-18s: %s" % level)
44     sys.exit(0)
45 
46 
47 def cb_init_hook(optname, value):
48     """exec arbitrary code to set sys.path for instance"""
49     exec(value)  # pylint: disable=exec-used
50 
51 
52 UNUSED_PARAM_SENTINEL = object()
53 
54 
55 class Run:
56     """helper class to use as main for pylint :
57 
58     run(*sys.argv[1:])
59     """
60 
61     LinterClass = PyLinter
62     option_groups = (
63         (
64             "Commands",
65             "Options which are actually commands. Options in this \
66 group are mutually exclusive.",
67         ),
68     )
69 
70     @staticmethod
71     def _return_one(*args):  # pylint: disable=unused-argument
72         return 1
73 
74     def __init__(
75         self,
76         args,
77         reporter=None,
78         exit=True,
79         do_exit=UNUSED_PARAM_SENTINEL,
80     ):  # pylint: disable=redefined-builtin
81         self._rcfile = None
82         self._output = None
83         self._version_asked = False
84         self._plugins = []
85         self.verbose = None
86         try:
87             preprocess_options(
88                 args,
89                 {
90                     # option: (callback, takearg)
91                     "version": (self.version_asked, False),
92                     "init-hook": (cb_init_hook, True),
93                     "rcfile": (self.cb_set_rcfile, True),
94                     "load-plugins": (self.cb_add_plugins, True),
95                     "verbose": (self.cb_verbose_mode, False),
96                     "output": (self.cb_set_output, True),
97                 },
98             )
99         except ArgumentPreprocessingError as ex:
100             print(ex, file=sys.stderr)
101             sys.exit(32)
102 
103         self.linter = linter = self.LinterClass(
104             (
105                 (
106                     "rcfile",
107                     {
108                         "action": "callback",
109                         "callback": Run._return_one,
110                         "group": "Commands",
111                         "type": "string",
112                         "metavar": "<file>",
113                         "help": "Specify a configuration file to load.",
114                     },
115                 ),
116                 (
117                     "output",
118                     {
119                         "action": "callback",
120                         "callback": Run._return_one,
121                         "group": "Commands",
122                         "type": "string",
123                         "metavar": "<file>",
124                         "help": "Specify an output file.",
125                     },
126                 ),
127                 (
128                     "init-hook",
129                     {
130                         "action": "callback",
131                         "callback": Run._return_one,
132                         "type": "string",
133                         "metavar": "<code>",
134                         "level": 1,
135                         "help": "Python code to execute, usually for sys.path "
136                         "manipulation such as pygtk.require().",
137                     },
138                 ),
139                 (
140                     "help-msg",
141                     {
142                         "action": "callback",
143                         "type": "string",
144                         "metavar": "<msg-id>",
145                         "callback": self.cb_help_message,
146                         "group": "Commands",
147                         "help": "Display a help message for the given message id and "
148                         "exit. The value may be a comma separated list of message ids.",
149                     },
150                 ),
151                 (
152                     "list-msgs",
153                     {
154                         "action": "callback",
155                         "metavar": "<msg-id>",
156                         "callback": self.cb_list_messages,
157                         "group": "Commands",
158                         "level": 1,
159                         "help": "Generate pylint's messages.",
160                     },
161                 ),
162                 (
163                     "list-msgs-enabled",
164                     {
165                         "action": "callback",
166                         "metavar": "<msg-id>",
167                         "callback": self.cb_list_messages_enabled,
168                         "group": "Commands",
169                         "level": 1,
170                         "help": "Display a list of what messages are enabled "
171                         "and disabled with the given configuration.",
172                     },
173                 ),
174                 (
175                     "list-groups",
176                     {
177                         "action": "callback",
178                         "metavar": "<msg-id>",
179                         "callback": self.cb_list_groups,
180                         "group": "Commands",
181                         "level": 1,
182                         "help": "List pylint's message groups.",
183                     },
184                 ),
185                 (
186                     "list-conf-levels",
187                     {
188                         "action": "callback",
189                         "callback": cb_list_confidence_levels,
190                         "group": "Commands",
191                         "level": 1,
192                         "help": "Generate pylint's confidence levels.",
193                     },
194                 ),
195                 (
196                     "list-extensions",
197                     {
198                         "action": "callback",
199                         "callback": cb_list_extensions,
200                         "group": "Commands",
201                         "level": 1,
202                         "help": "List available extensions.",
203                     },
204                 ),
205                 (
206                     "full-documentation",
207                     {
208                         "action": "callback",
209                         "metavar": "<msg-id>",
210                         "callback": self.cb_full_documentation,
211                         "group": "Commands",
212                         "level": 1,
213                         "help": "Generate pylint's full documentation.",
214                     },
215                 ),
216                 (
217                     "generate-rcfile",
218                     {
219                         "action": "callback",
220                         "callback": self.cb_generate_config,
221                         "group": "Commands",
222                         "help": "Generate a sample configuration file according to "
223                         "the current configuration. You can put other options "
224                         "before this one to get them in the generated "
225                         "configuration.",
226                     },
227                 ),
228                 (
229                     "generate-man",
230                     {
231                         "action": "callback",
232                         "callback": self.cb_generate_manpage,
233                         "group": "Commands",
234                         "help": "Generate pylint's man page.",
235                         "hide": True,
236                     },
237                 ),
238                 (
239                     "errors-only",
240                     {
241                         "action": "callback",
242                         "callback": self.cb_error_mode,
243                         "short": "E",
244                         "help": "In error mode, checkers without error messages are "
245                         "disabled and for others, only the ERROR messages are "
246                         "displayed, and no reports are done by default.",
247                     },
248                 ),
249                 (
250                     "py3k",
251                     {
252                         "action": "callback",
253                         "callback": self.cb_python3_porting_mode,
254                         "help": "In Python 3 porting mode, all checkers will be "
255                         "disabled and only messages emitted by the porting "
256                         "checker will be displayed.",
257                     },
258                 ),
259                 (
260                     "verbose",
261                     {
262                         "action": "callback",
263                         "callback": self.cb_verbose_mode,
264                         "short": "v",
265                         "help": "In verbose mode, extra non-checker-related info "
266                         "will be displayed.",
267                     },
268                 ),
269             ),
270             option_groups=self.option_groups,
271             pylintrc=self._rcfile,
272         )
273         # register standard checkers
274         if self._version_asked:
275             print(full_version)
276             sys.exit(0)
277         linter.load_default_plugins()
278         # load command line plugins
279         linter.load_plugin_modules(self._plugins)
280         # add some help section
281         linter.add_help_section("Environment variables", config.ENV_HELP, level=1)
282         linter.add_help_section(
283             "Output",
284             "Using the default text output, the message format is :                          \n"
285             "                                                                                \n"
286             "        MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE                                \n"
287             "                                                                                \n"
288             "There are 5 kind of message types :                                             \n"
289             "    * (C) convention, for programming standard violation                        \n"
290             "    * (R) refactor, for bad code smell                                          \n"
291             "    * (W) warning, for python specific problems                                 \n"
292             "    * (E) error, for probable bugs in the code                                  \n"
293             "    * (F) fatal, if an error occurred which prevented pylint from doing further\n"
294             "processing.\n",
295             level=1,
296         )
297         linter.add_help_section(
298             "Output status code",
299             "Pylint should leave with following status code:                                 \n"
300             "    * 0 if everything went fine                                                 \n"
301             "    * 1 if a fatal message was issued                                           \n"
302             "    * 2 if an error message was issued                                          \n"
303             "    * 4 if a warning message was issued                                         \n"
304             "    * 8 if a refactor message was issued                                        \n"
305             "    * 16 if a convention message was issued                                     \n"
306             "    * 32 on usage error                                                         \n"
307             "                                                                                \n"
308             "status 1 to 16 will be bit-ORed so you can know which different categories has\n"
309             "been issued by analysing pylint output status code\n",
310             level=1,
311         )
312         # read configuration
313         linter.disable("I")
314         linter.enable("c-extension-no-member")
315         try:
316             linter.read_config_file(verbose=self.verbose)
317         except OSError as ex:
318             print(ex, file=sys.stderr)
319             sys.exit(32)
320 
321         config_parser = linter.cfgfile_parser
322         # run init hook, if present, before loading plugins
323         if config_parser.has_option("MASTER", "init-hook"):
324             cb_init_hook(
325                 "init-hook", utils._unquote(config_parser.get("MASTER", "init-hook"))
326             )
327         # is there some additional plugins in the file configuration, in
328         if config_parser.has_option("MASTER", "load-plugins"):
329             plugins = utils._splitstrip(config_parser.get("MASTER", "load-plugins"))
330             linter.load_plugin_modules(plugins)
331         # now we can load file config and command line, plugins (which can
332         # provide options) have been registered
333         linter.load_config_file()
334 
335         if reporter:
336             # if a custom reporter is provided as argument, it may be overridden
337             # by file parameters, so re-set it here, but before command line
338             # parsing so it's still overrideable by command line option
339             linter.set_reporter(reporter)
340         try:
341             args = linter.load_command_line_configuration(args)
342         except SystemExit as exc:
343             if exc.code == 2:  # bad options
344                 exc.code = 32
345             raise
346         if not args:
347             print(linter.help())
348             sys.exit(32)
349 
350         if linter.config.jobs < 0:
351             print(
352                 "Jobs number (%d) should be greater than or equal to 0"
353                 % linter.config.jobs,
354                 file=sys.stderr,
355             )
356             sys.exit(32)
357         if linter.config.jobs > 1 or linter.config.jobs == 0:
358             if multiprocessing is None:
359                 print(
360                     "Multiprocessing library is missing, fallback to single process",
361                     file=sys.stderr,
362                 )
363                 linter.set_option("jobs", 1)
364             elif linter.config.jobs == 0:
365                 linter.config.jobs = _cpu_count()
366 
367         # We have loaded configuration from config file and command line. Now, we can
368         # load plugin specific configuration.
369         linter.load_plugin_configuration()
370 
371         # Now that plugins are loaded, get list of all fail_on messages, and enable them
372         linter.enable_fail_on_messages()
373 
374         if self._output:
375             try:
376                 with open(self._output, "w") as output:
377                     linter.reporter.set_output(output)
378                     linter.check(args)
379                     score_value = linter.generate_reports()
380             except OSError as ex:
381                 print(ex, file=sys.stderr)
382                 sys.exit(32)
383         else:
384             linter.check(args)
385             score_value = linter.generate_reports()
386 
387         if do_exit is not UNUSED_PARAM_SENTINEL:
388             warnings.warn(
389                 "do_exit is deprecated and it is going to be removed in a future version.",
390                 DeprecationWarning,
391             )
392             exit = do_exit
393 
394         if exit:
395             if linter.config.exit_zero:
396                 sys.exit(0)
397             else:
398                 if (
399                     score_value
400                     and score_value >= linter.config.fail_under
401                     # detected messages flagged by --fail-on prevent non-zero exit code
402                     and not linter.any_fail_on_issues()
403                 ):
404                     sys.exit(0)
405                 sys.exit(self.linter.msg_status)
406 
407     def version_asked(self, _, __):
408         """callback for version (i.e. before option parsing)"""
409         self._version_asked = True
410 
411     def cb_set_rcfile(self, name, value):
412         """callback for option preprocessing (i.e. before option parsing)"""
413         self._rcfile = value
414 
415     def cb_set_output(self, name, value):
416         """callback for option preprocessing (i.e. before option parsing)"""
417         self._output = value
418 
419     def cb_add_plugins(self, name, value):
420         """callback for option preprocessing (i.e. before option parsing)"""
421         self._plugins.extend(utils._splitstrip(value))
422 
423     def cb_error_mode(self, *args, **kwargs):
424         """error mode:
425         * disable all but error messages
426         * disable the 'miscellaneous' checker which can be safely deactivated in
427           debug
428         * disable reports
429         * do not save execution information
430         """
431         self.linter.error_mode()
432 
433     def cb_generate_config(self, *args, **kwargs):
434         """optik callback for sample config file generation"""
435         self.linter.generate_config(skipsections=("COMMANDS",))
436         sys.exit(0)
437 
438     def cb_generate_manpage(self, *args, **kwargs):
439         """optik callback for sample config file generation"""
440         self.linter.generate_manpage(__pkginfo__)
441         sys.exit(0)
442 
443     def cb_help_message(self, option, optname, value, parser):
444         """optik callback for printing some help about a particular message"""
445         self.linter.msgs_store.help_message(utils._splitstrip(value))
446         sys.exit(0)
447 
448     def cb_full_documentation(self, option, optname, value, parser):
449         """optik callback for printing full documentation"""
450         self.linter.print_full_documentation()
451         sys.exit(0)
452 
453     def cb_list_messages(self, option, optname, value, parser):
454         """optik callback for printing available messages"""
455         self.linter.msgs_store.list_messages()
456         sys.exit(0)
457 
458     def cb_list_messages_enabled(self, option, optname, value, parser):
459         """optik callback for printing available messages"""
460         self.linter.list_messages_enabled()
461         sys.exit(0)
462 
463     def cb_list_groups(self, *args, **kwargs):
464         """List all the check groups that pylint knows about
465 
466         These should be useful to know what check groups someone can disable
467         or enable.
468         """
469         for check in self.linter.get_checker_names():
470             print(check)
471         sys.exit(0)
472 
473     def cb_python3_porting_mode(self, *args, **kwargs):
474         """Activate only the python3 porting checker."""
475         self.linter.python3_porting_mode()
476 
477     def cb_verbose_mode(self, *args, **kwargs):
478         self.verbose = True

</code><intended_behavior>Ensure that during the linting process, the improved logic from 'utils.py' (or wherever else appropriate) is effectively employed to recognize imports used in type comments. This may involve ensuring that the data about used imports includes those found within type comments before finalizing the unused imports report.</intended_behavior>]
2025-10-15 22:15:10.728 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 22:15:10.728 | INFO     | Search-only: skipping patch selection
2025-10-15 22:15:10.798 | INFO     | Task pylint-dev__pylint-4604 completed successfully.
2025-10-15 22:15:10.799 | INFO     | No patch generated. You can try running ACR again.
