[
    {
        "rel_file_path": "django/template/backends/django.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/backends/django.py",
        "start": 32,
        "end": 36,
        "class_name": "DjangoTemplates",
        "method_name": "get_template",
        "code": "32     def get_template(self, template_name):\n33         try:\n34             return Template(self.engine.get_template(template_name), self)\n35         except TemplateDoesNotExist as exc:\n36             reraise(exc, self)\n",
        "intended_behavior": "Modify this method to check if the `autoreload` option is enabled in the `TEMPLATES` settings alongside `cache_templates`. If both are True and the application is in DEBUG mode, the method should verify if the requested template has been modified since its last load. If it has been modified, the method should bypass the cache and reload the template from its source. This behavior ensures that developers get the benefit of cached templates without needing to restart the server after every template change during development. The modification should carefully preserve the method's existing functionality for cases where `autoreload` is not enabled or not applicable."
    },
    {
        "rel_file_path": "django/template/backends/django.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/backends/django.py",
        "start": 14,
        "end": 45,
        "class_name": "DjangoTemplates",
        "method_name": null,
        "code": "14 class DjangoTemplates(BaseEngine):\n15 \n16     app_dirname = 'templates'\n17 \n18     def __init__(self, params):\n19         params = params.copy()\n20         options = params.pop('OPTIONS').copy()\n21         options.setdefault('autoescape', True)\n22         options.setdefault('debug', settings.DEBUG)\n23         options.setdefault('file_charset', 'utf-8')\n24         libraries = options.get('libraries', {})\n25         options['libraries'] = self.get_templatetag_libraries(libraries)\n26         super().__init__(params)\n27         self.engine = Engine(self.dirs, self.app_dirs, **options)\n28 \n29     def from_string(self, template_code):\n30         return Template(self.engine.from_string(template_code), self)\n31 \n32     def get_template(self, template_name):\n33         try:\n34             return Template(self.engine.get_template(template_name), self)\n35         except TemplateDoesNotExist as exc:\n36             reraise(exc, self)\n37 \n38     def get_templatetag_libraries(self, custom_libraries):\n39         \"\"\"\n40         Return a collation of template tag libraries from installed\n41         applications and the supplied custom_libraries argument.\n42         \"\"\"\n43         libraries = get_installed_libraries()\n44         libraries.update(custom_libraries)\n45         return libraries\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/template/loaders/cached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/loaders/cached.py",
        "start": 1,
        "end": 92,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Wrapper class that takes a list of template loaders as an argument and attempts\n3 to load templates from them in order, caching the result.\n4 \"\"\"\n5 \n6 import hashlib\n7 \n8 from django.template import TemplateDoesNotExist\n9 from django.template.backends.django import copy_exception\n10 \n11 from .base import Loader as BaseLoader\n12 \n13 \n14 class Loader(BaseLoader):\n15 \n16     def __init__(self, engine, loaders):\n17         self.get_template_cache = {}\n18         self.loaders = engine.get_template_loaders(loaders)\n19         super().__init__(engine)\n20 \n21     def get_contents(self, origin):\n22         return origin.loader.get_contents(origin)\n23 \n24     def get_template(self, template_name, skip=None):\n25         \"\"\"\n26         Perform the caching that gives this loader its name. Often many of the\n27         templates attempted will be missing, so memory use is of concern here.\n28         To keep it in check, caching behavior is a little complicated when a\n29         template is not found. See ticket #26306 for more details.\n30 \n31         With template debugging disabled, cache the TemplateDoesNotExist class\n32         for every missing template and raise a new instance of it after\n33         fetching it from the cache.\n34 \n35         With template debugging enabled, a unique TemplateDoesNotExist object\n36         is cached for each missing template to preserve debug data. When\n37         raising an exception, Python sets __traceback__, __context__, and\n38         __cause__ attributes on it. Those attributes can contain references to\n39         all sorts of objects up the call chain and caching them creates a\n40         memory leak. Thus, unraised copies of the exceptions are cached and\n41         copies of those copies are raised after they're fetched from the cache.\n42         \"\"\"\n43         key = self.cache_key(template_name, skip)\n44         cached = self.get_template_cache.get(key)\n45         if cached:\n46             if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n47                 raise cached(template_name)\n48             elif isinstance(cached, TemplateDoesNotExist):\n49                 raise copy_exception(cached)\n50             return cached\n51 \n52         try:\n53             template = super().get_template(template_name, skip)\n54         except TemplateDoesNotExist as e:\n55             self.get_template_cache[key] = copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n56             raise\n57         else:\n58             self.get_template_cache[key] = template\n59 \n60         return template\n61 \n62     def get_template_sources(self, template_name):\n63         for loader in self.loaders:\n64             yield from loader.get_template_sources(template_name)\n65 \n66     def cache_key(self, template_name, skip=None):\n67         \"\"\"\n68         Generate a cache key for the template name and skip.\n69 \n70         If skip is provided, only origins that match template_name are included\n71         in the cache key. This ensures each template is only parsed and cached\n72         once if contained in different extend chains like:\n73 \n74             x -> a -> a\n75             y -> a -> a\n76             z -> a -> a\n77         \"\"\"\n78         skip_prefix = ''\n79 \n80         if skip:\n81             matching = [origin.name for origin in skip if origin.template_name == template_name]\n82             if matching:\n83                 skip_prefix = self.generate_hash(matching)\n84 \n85         return '-'.join(s for s in (str(template_name), skip_prefix) if s)\n86 \n87     def generate_hash(self, values):\n88         return hashlib.sha1('|'.join(values).encode()).hexdigest()\n89 \n90     def reset(self):\n91         \"Empty the template cache.\"\n92         self.get_template_cache.clear()\n",
        "intended_behavior": "Given that the `CachedLoader` class was expected but not found, the focus shifts to potentially adding or modifying functionality within this file related to caching. The intended behavior here would involve implementing or extending logic to support checking for template modifications when caching is enabled, specifically when `autoreload` is set to True. This might involve adding a new cache backend or extending the functionality of existing caching mechanisms to be more dynamic in development environments. The change would involve making the cache check for file changes before returning a cached template, reloading the template from disk if a change is detected."
    }
]